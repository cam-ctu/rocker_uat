
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:13:38.348] plan(): Setting new future strategy stack:
[16:13:38.349] List of future strategies:
[16:13:38.349] 1. sequential:
[16:13:38.349]    - args: function (..., envir = parent.frame())
[16:13:38.349]    - tweaked: FALSE
[16:13:38.349]    - call: future::plan("sequential")
[16:13:38.362] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> strategies <- supportedStrategies()
> 
> message("*** resolve() ...")
*** resolve() ...
> 
> message("*** resolve() for default ...")
*** resolve() for default ...
> 
> x <- 1
> y <- resolve(x)
> stopifnot(identical(y, x))
> 
> message("*** resolve() for default ... DONE")
*** resolve() for default ... DONE
> 
> 
> for (strategy in strategies) {
+   message(sprintf("- plan('%s') ...", strategy))
+   plan(strategy)
+ 
+   if (strategy == "multisession" && availableCores() >= 2) {
+     message("*** resolve() for Future objects ...")
+     
+     for (result in c(FALSE, TRUE)) {
+       for (recursive in list(FALSE, TRUE, -1, 0, 1, 2, Inf)) {
+         message(sprintf("- result = %s, recursive = %s ...", result, recursive))
+       
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         })
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         }, lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message("- w/ exception ...")
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")))
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")), lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message(sprintf("- result = %s, recursive = %s ... DONE", result, recursive))
+       } ## for (resolve ...)
+     } ## for (result ...)
+     
+     message("*** resolve() for Future objects ... DONE")
+   } ## if (strategy == "multisession" && availableCores() >= 2)
+   
+   message("*** resolve() for lists ...")
+ 
+   x <- list()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2, lazy = TRUE)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future({Sys.sleep(0.5); 2})
+   x[[4]] <- 4
+   dim(x) <- c(2, 2)
+   y <- resolve(x, idxs = 1)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[1]]))
+   y <- resolve(x, idxs = 2)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[2]]))
+   y <- resolve(x, idxs = 3)
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = seq_along(x))
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = names(x))
+   stopifnot(identical(y, x))
+ 
+   y <- resolve(x, idxs = matrix(c(1, 2), ncol = 2L), result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk })
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk }, lazy = TRUE)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+ 
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   x <- list(1, 2)
+   res <- tryCatch(x <- resolve(x, idxs = "a"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for lists ... DONE")
+ 
+ 
+   message("*** resolve() for environments ...")
+ 
+   x <- new.env()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- new.env()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+ 
+   x <- new.env()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x$b))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a <- future({ 1 })
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "c")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for environments ... DONE")
+ 
+ 
+   message("*** resolve() for list environments ...")
+ 
+   x <- listenv()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- 1
+   x$b <- 2
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   names <- names(x)
+   dim(x) <- c(1, 3)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$a, mustExist = FALSE)))
+   #stopifnot(is.na(futureOf(x$b, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a <- future({ 1 })
+   x$b %<-% { Sys.sleep(0.5); 2 }
+   x$c %<-% { 3 }
+   x$d <- 4
+   names <- names(x)
+   dim(x) <- c(2, 2)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(identical(futureOf(x$a, mustExist = FALSE), x$a))
+   stopifnot(resolved(x$a))
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   idxs <- matrix(c(1, 2), ncol = 2L)
+   y <- resolve(x, idxs = idxs)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$c, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = 4L)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x[[4L]], mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for list environments ... DONE")
+ 
+   message(sprintf("- plan('%s') ...", strategy))
+ } ## for (strategy ...)
- plan('sequential') ...
[16:13:38.553] plan(): Setting new future strategy stack:
[16:13:38.553] List of future strategies:
[16:13:38.553] 1. sequential:
[16:13:38.553]    - args: function (..., envir = parent.frame())
[16:13:38.553]    - tweaked: FALSE
[16:13:38.553]    - call: plan(strategy)
[16:13:38.565] plan(): nbrOfWorkers() = 1
*** resolve() for lists ...
[16:13:38.565] resolve() on list ...
[16:13:38.565]  recursive: 0
[16:13:38.566]  length: 2
[16:13:38.566]  elements: ‘a’, ‘b’
[16:13:38.566]  length: 1 (resolved future 1)
[16:13:38.566]  length: 0 (resolved future 2)
[16:13:38.566] resolve() on list ... DONE
[16:13:38.567] getGlobalsAndPackages() ...
[16:13:38.567] Searching for globals...
[16:13:38.570] 
[16:13:38.570] Searching for globals ... DONE
[16:13:38.570] - globals: [0] <none>
[16:13:38.570] getGlobalsAndPackages() ... DONE
[16:13:38.571] run() for ‘Future’ ...
[16:13:38.571] - state: ‘created’
[16:13:38.571] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:38.571] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:38.571] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:38.572]   - Field: ‘label’
[16:13:38.572]   - Field: ‘local’
[16:13:38.572]   - Field: ‘owner’
[16:13:38.572]   - Field: ‘envir’
[16:13:38.572]   - Field: ‘packages’
[16:13:38.572]   - Field: ‘gc’
[16:13:38.572]   - Field: ‘conditions’
[16:13:38.572]   - Field: ‘expr’
[16:13:38.572]   - Field: ‘uuid’
[16:13:38.572]   - Field: ‘seed’
[16:13:38.573]   - Field: ‘version’
[16:13:38.573]   - Field: ‘result’
[16:13:38.573]   - Field: ‘asynchronous’
[16:13:38.573]   - Field: ‘calls’
[16:13:38.573]   - Field: ‘globals’
[16:13:38.573]   - Field: ‘stdout’
[16:13:38.573]   - Field: ‘earlySignal’
[16:13:38.573]   - Field: ‘lazy’
[16:13:38.573]   - Field: ‘state’
[16:13:38.573] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:38.573] - Launch lazy future ...
[16:13:38.574] Packages needed by the future expression (n = 0): <none>
[16:13:38.574] Packages needed by future strategies (n = 0): <none>
[16:13:38.575] {
[16:13:38.575]     {
[16:13:38.575]         {
[16:13:38.575]             ...future.startTime <- base::Sys.time()
[16:13:38.575]             {
[16:13:38.575]                 {
[16:13:38.575]                   {
[16:13:38.575]                     base::local({
[16:13:38.575]                       has_future <- base::requireNamespace("future", 
[16:13:38.575]                         quietly = TRUE)
[16:13:38.575]                       if (has_future) {
[16:13:38.575]                         ns <- base::getNamespace("future")
[16:13:38.575]                         version <- ns[[".package"]][["version"]]
[16:13:38.575]                         if (is.null(version)) 
[16:13:38.575]                           version <- utils::packageVersion("future")
[16:13:38.575]                       }
[16:13:38.575]                       else {
[16:13:38.575]                         version <- NULL
[16:13:38.575]                       }
[16:13:38.575]                       if (!has_future || version < "1.8.0") {
[16:13:38.575]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:38.575]                           "", base::R.version$version.string), 
[16:13:38.575]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:38.575]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:38.575]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:38.575]                             "release", "version")], collapse = " "), 
[16:13:38.575]                           hostname = base::Sys.info()[["nodename"]])
[16:13:38.575]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:38.575]                           info)
[16:13:38.575]                         info <- base::paste(info, collapse = "; ")
[16:13:38.575]                         if (!has_future) {
[16:13:38.575]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:38.575]                             info)
[16:13:38.575]                         }
[16:13:38.575]                         else {
[16:13:38.575]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:38.575]                             info, version)
[16:13:38.575]                         }
[16:13:38.575]                         base::stop(msg)
[16:13:38.575]                       }
[16:13:38.575]                     })
[16:13:38.575]                   }
[16:13:38.575]                   options(future.plan = NULL)
[16:13:38.575]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:38.575]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:38.575]                 }
[16:13:38.575]                 ...future.workdir <- getwd()
[16:13:38.575]             }
[16:13:38.575]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:38.575]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:38.575]         }
[16:13:38.575]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:38.575]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:38.575]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:38.575]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:38.575]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:38.575]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:38.575]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:38.575]             base::names(...future.oldOptions))
[16:13:38.575]     }
[16:13:38.575]     if (FALSE) {
[16:13:38.575]     }
[16:13:38.575]     else {
[16:13:38.575]         if (TRUE) {
[16:13:38.575]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:38.575]                 open = "w")
[16:13:38.575]         }
[16:13:38.575]         else {
[16:13:38.575]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:38.575]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:38.575]         }
[16:13:38.575]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:38.575]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:38.575]             base::sink(type = "output", split = FALSE)
[16:13:38.575]             base::close(...future.stdout)
[16:13:38.575]         }, add = TRUE)
[16:13:38.575]     }
[16:13:38.575]     ...future.frame <- base::sys.nframe()
[16:13:38.575]     ...future.conditions <- base::list()
[16:13:38.575]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:38.575]     if (FALSE) {
[16:13:38.575]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:38.575]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:38.575]     }
[16:13:38.575]     ...future.result <- base::tryCatch({
[16:13:38.575]         base::withCallingHandlers({
[16:13:38.575]             ...future.value <- base::withVisible(base::local(1))
[16:13:38.575]             future::FutureResult(value = ...future.value$value, 
[16:13:38.575]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:38.575]                   ...future.rng), globalenv = if (FALSE) 
[16:13:38.575]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:38.575]                     ...future.globalenv.names))
[16:13:38.575]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:38.575]         }, condition = base::local({
[16:13:38.575]             c <- base::c
[16:13:38.575]             inherits <- base::inherits
[16:13:38.575]             invokeRestart <- base::invokeRestart
[16:13:38.575]             length <- base::length
[16:13:38.575]             list <- base::list
[16:13:38.575]             seq.int <- base::seq.int
[16:13:38.575]             signalCondition <- base::signalCondition
[16:13:38.575]             sys.calls <- base::sys.calls
[16:13:38.575]             `[[` <- base::`[[`
[16:13:38.575]             `+` <- base::`+`
[16:13:38.575]             `<<-` <- base::`<<-`
[16:13:38.575]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:38.575]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:38.575]                   3L)]
[16:13:38.575]             }
[16:13:38.575]             function(cond) {
[16:13:38.575]                 is_error <- inherits(cond, "error")
[16:13:38.575]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:38.575]                   NULL)
[16:13:38.575]                 if (is_error) {
[16:13:38.575]                   sessionInformation <- function() {
[16:13:38.575]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:38.575]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:38.575]                       search = base::search(), system = base::Sys.info())
[16:13:38.575]                   }
[16:13:38.575]                   ...future.conditions[[length(...future.conditions) + 
[16:13:38.575]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:38.575]                     cond$call), session = sessionInformation(), 
[16:13:38.575]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:38.575]                   signalCondition(cond)
[16:13:38.575]                 }
[16:13:38.575]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:38.575]                 "immediateCondition"))) {
[16:13:38.575]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:38.575]                   ...future.conditions[[length(...future.conditions) + 
[16:13:38.575]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:38.575]                   if (TRUE && !signal) {
[16:13:38.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:38.575]                     {
[16:13:38.575]                       inherits <- base::inherits
[16:13:38.575]                       invokeRestart <- base::invokeRestart
[16:13:38.575]                       is.null <- base::is.null
[16:13:38.575]                       muffled <- FALSE
[16:13:38.575]                       if (inherits(cond, "message")) {
[16:13:38.575]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:38.575]                         if (muffled) 
[16:13:38.575]                           invokeRestart("muffleMessage")
[16:13:38.575]                       }
[16:13:38.575]                       else if (inherits(cond, "warning")) {
[16:13:38.575]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:38.575]                         if (muffled) 
[16:13:38.575]                           invokeRestart("muffleWarning")
[16:13:38.575]                       }
[16:13:38.575]                       else if (inherits(cond, "condition")) {
[16:13:38.575]                         if (!is.null(pattern)) {
[16:13:38.575]                           computeRestarts <- base::computeRestarts
[16:13:38.575]                           grepl <- base::grepl
[16:13:38.575]                           restarts <- computeRestarts(cond)
[16:13:38.575]                           for (restart in restarts) {
[16:13:38.575]                             name <- restart$name
[16:13:38.575]                             if (is.null(name)) 
[16:13:38.575]                               next
[16:13:38.575]                             if (!grepl(pattern, name)) 
[16:13:38.575]                               next
[16:13:38.575]                             invokeRestart(restart)
[16:13:38.575]                             muffled <- TRUE
[16:13:38.575]                             break
[16:13:38.575]                           }
[16:13:38.575]                         }
[16:13:38.575]                       }
[16:13:38.575]                       invisible(muffled)
[16:13:38.575]                     }
[16:13:38.575]                     muffleCondition(cond, pattern = "^muffle")
[16:13:38.575]                   }
[16:13:38.575]                 }
[16:13:38.575]                 else {
[16:13:38.575]                   if (TRUE) {
[16:13:38.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:38.575]                     {
[16:13:38.575]                       inherits <- base::inherits
[16:13:38.575]                       invokeRestart <- base::invokeRestart
[16:13:38.575]                       is.null <- base::is.null
[16:13:38.575]                       muffled <- FALSE
[16:13:38.575]                       if (inherits(cond, "message")) {
[16:13:38.575]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:38.575]                         if (muffled) 
[16:13:38.575]                           invokeRestart("muffleMessage")
[16:13:38.575]                       }
[16:13:38.575]                       else if (inherits(cond, "warning")) {
[16:13:38.575]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:38.575]                         if (muffled) 
[16:13:38.575]                           invokeRestart("muffleWarning")
[16:13:38.575]                       }
[16:13:38.575]                       else if (inherits(cond, "condition")) {
[16:13:38.575]                         if (!is.null(pattern)) {
[16:13:38.575]                           computeRestarts <- base::computeRestarts
[16:13:38.575]                           grepl <- base::grepl
[16:13:38.575]                           restarts <- computeRestarts(cond)
[16:13:38.575]                           for (restart in restarts) {
[16:13:38.575]                             name <- restart$name
[16:13:38.575]                             if (is.null(name)) 
[16:13:38.575]                               next
[16:13:38.575]                             if (!grepl(pattern, name)) 
[16:13:38.575]                               next
[16:13:38.575]                             invokeRestart(restart)
[16:13:38.575]                             muffled <- TRUE
[16:13:38.575]                             break
[16:13:38.575]                           }
[16:13:38.575]                         }
[16:13:38.575]                       }
[16:13:38.575]                       invisible(muffled)
[16:13:38.575]                     }
[16:13:38.575]                     muffleCondition(cond, pattern = "^muffle")
[16:13:38.575]                   }
[16:13:38.575]                 }
[16:13:38.575]             }
[16:13:38.575]         }))
[16:13:38.575]     }, error = function(ex) {
[16:13:38.575]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:38.575]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:38.575]                 ...future.rng), started = ...future.startTime, 
[16:13:38.575]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:38.575]             version = "1.8"), class = "FutureResult")
[16:13:38.575]     }, finally = {
[16:13:38.575]         if (!identical(...future.workdir, getwd())) 
[16:13:38.575]             setwd(...future.workdir)
[16:13:38.575]         {
[16:13:38.575]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:38.575]                 ...future.oldOptions$nwarnings <- NULL
[16:13:38.575]             }
[16:13:38.575]             base::options(...future.oldOptions)
[16:13:38.575]             if (.Platform$OS.type == "windows") {
[16:13:38.575]                 old_names <- names(...future.oldEnvVars)
[16:13:38.575]                 envs <- base::Sys.getenv()
[16:13:38.575]                 names <- names(envs)
[16:13:38.575]                 common <- intersect(names, old_names)
[16:13:38.575]                 added <- setdiff(names, old_names)
[16:13:38.575]                 removed <- setdiff(old_names, names)
[16:13:38.575]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:38.575]                   envs[common]]
[16:13:38.575]                 NAMES <- toupper(changed)
[16:13:38.575]                 args <- list()
[16:13:38.575]                 for (kk in seq_along(NAMES)) {
[16:13:38.575]                   name <- changed[[kk]]
[16:13:38.575]                   NAME <- NAMES[[kk]]
[16:13:38.575]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.575]                     next
[16:13:38.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:38.575]                 }
[16:13:38.575]                 NAMES <- toupper(added)
[16:13:38.575]                 for (kk in seq_along(NAMES)) {
[16:13:38.575]                   name <- added[[kk]]
[16:13:38.575]                   NAME <- NAMES[[kk]]
[16:13:38.575]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.575]                     next
[16:13:38.575]                   args[[name]] <- ""
[16:13:38.575]                 }
[16:13:38.575]                 NAMES <- toupper(removed)
[16:13:38.575]                 for (kk in seq_along(NAMES)) {
[16:13:38.575]                   name <- removed[[kk]]
[16:13:38.575]                   NAME <- NAMES[[kk]]
[16:13:38.575]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.575]                     next
[16:13:38.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:38.575]                 }
[16:13:38.575]                 if (length(args) > 0) 
[16:13:38.575]                   base::do.call(base::Sys.setenv, args = args)
[16:13:38.575]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:38.575]             }
[16:13:38.575]             else {
[16:13:38.575]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:38.575]             }
[16:13:38.575]             {
[16:13:38.575]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:38.575]                   0L) {
[16:13:38.575]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:38.575]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:38.575]                   base::options(opts)
[16:13:38.575]                 }
[16:13:38.575]                 {
[16:13:38.575]                   {
[16:13:38.575]                     NULL
[16:13:38.575]                     RNGkind("Mersenne-Twister")
[16:13:38.575]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:38.575]                       inherits = FALSE)
[16:13:38.575]                   }
[16:13:38.575]                   options(future.plan = NULL)
[16:13:38.575]                   if (is.na(NA_character_)) 
[16:13:38.575]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:38.575]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:38.575]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:38.575]                   {
[16:13:38.575]                     future <- SequentialFuture(..., envir = envir)
[16:13:38.575]                     if (!future$lazy) 
[16:13:38.575]                       future <- run(future)
[16:13:38.575]                     invisible(future)
[16:13:38.575]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:38.575]                 }
[16:13:38.575]             }
[16:13:38.575]         }
[16:13:38.575]     })
[16:13:38.575]     if (TRUE) {
[16:13:38.575]         base::sink(type = "output", split = FALSE)
[16:13:38.575]         if (TRUE) {
[16:13:38.575]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:38.575]         }
[16:13:38.575]         else {
[16:13:38.575]             ...future.result["stdout"] <- base::list(NULL)
[16:13:38.575]         }
[16:13:38.575]         base::close(...future.stdout)
[16:13:38.575]         ...future.stdout <- NULL
[16:13:38.575]     }
[16:13:38.575]     ...future.result$conditions <- ...future.conditions
[16:13:38.575]     ...future.result$finished <- base::Sys.time()
[16:13:38.575]     ...future.result
[16:13:38.575] }
[16:13:38.577] plan(): Setting new future strategy stack:
[16:13:38.577] List of future strategies:
[16:13:38.577] 1. sequential:
[16:13:38.577]    - args: function (..., envir = parent.frame())
[16:13:38.577]    - tweaked: FALSE
[16:13:38.577]    - call: NULL
[16:13:38.578] plan(): nbrOfWorkers() = 1
[16:13:38.579] plan(): Setting new future strategy stack:
[16:13:38.579] List of future strategies:
[16:13:38.579] 1. sequential:
[16:13:38.579]    - args: function (..., envir = parent.frame())
[16:13:38.579]    - tweaked: FALSE
[16:13:38.579]    - call: plan(strategy)
[16:13:38.580] plan(): nbrOfWorkers() = 1
[16:13:38.580] SequentialFuture started (and completed)
[16:13:38.580] - Launch lazy future ... done
[16:13:38.580] run() for ‘SequentialFuture’ ... done
[16:13:38.581] getGlobalsAndPackages() ...
[16:13:38.581] Searching for globals...
[16:13:38.581] 
[16:13:38.581] Searching for globals ... DONE
[16:13:38.583] - globals: [0] <none>
[16:13:38.583] getGlobalsAndPackages() ... DONE
[16:13:38.584] run() for ‘Future’ ...
[16:13:38.584] - state: ‘created’
[16:13:38.584] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:38.584] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:38.584] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:38.584]   - Field: ‘label’
[16:13:38.584]   - Field: ‘local’
[16:13:38.585]   - Field: ‘owner’
[16:13:38.585]   - Field: ‘envir’
[16:13:38.585]   - Field: ‘packages’
[16:13:38.585]   - Field: ‘gc’
[16:13:38.585]   - Field: ‘conditions’
[16:13:38.585]   - Field: ‘expr’
[16:13:38.585]   - Field: ‘uuid’
[16:13:38.585]   - Field: ‘seed’
[16:13:38.585]   - Field: ‘version’
[16:13:38.585]   - Field: ‘result’
[16:13:38.586]   - Field: ‘asynchronous’
[16:13:38.586]   - Field: ‘calls’
[16:13:38.586]   - Field: ‘globals’
[16:13:38.586]   - Field: ‘stdout’
[16:13:38.586]   - Field: ‘earlySignal’
[16:13:38.586]   - Field: ‘lazy’
[16:13:38.586]   - Field: ‘state’
[16:13:38.586] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:38.586] - Launch lazy future ...
[16:13:38.587] Packages needed by the future expression (n = 0): <none>
[16:13:38.587] Packages needed by future strategies (n = 0): <none>
[16:13:38.587] {
[16:13:38.587]     {
[16:13:38.587]         {
[16:13:38.587]             ...future.startTime <- base::Sys.time()
[16:13:38.587]             {
[16:13:38.587]                 {
[16:13:38.587]                   {
[16:13:38.587]                     base::local({
[16:13:38.587]                       has_future <- base::requireNamespace("future", 
[16:13:38.587]                         quietly = TRUE)
[16:13:38.587]                       if (has_future) {
[16:13:38.587]                         ns <- base::getNamespace("future")
[16:13:38.587]                         version <- ns[[".package"]][["version"]]
[16:13:38.587]                         if (is.null(version)) 
[16:13:38.587]                           version <- utils::packageVersion("future")
[16:13:38.587]                       }
[16:13:38.587]                       else {
[16:13:38.587]                         version <- NULL
[16:13:38.587]                       }
[16:13:38.587]                       if (!has_future || version < "1.8.0") {
[16:13:38.587]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:38.587]                           "", base::R.version$version.string), 
[16:13:38.587]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:38.587]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:38.587]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:38.587]                             "release", "version")], collapse = " "), 
[16:13:38.587]                           hostname = base::Sys.info()[["nodename"]])
[16:13:38.587]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:38.587]                           info)
[16:13:38.587]                         info <- base::paste(info, collapse = "; ")
[16:13:38.587]                         if (!has_future) {
[16:13:38.587]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:38.587]                             info)
[16:13:38.587]                         }
[16:13:38.587]                         else {
[16:13:38.587]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:38.587]                             info, version)
[16:13:38.587]                         }
[16:13:38.587]                         base::stop(msg)
[16:13:38.587]                       }
[16:13:38.587]                     })
[16:13:38.587]                   }
[16:13:38.587]                   options(future.plan = NULL)
[16:13:38.587]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:38.587]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:38.587]                 }
[16:13:38.587]                 ...future.workdir <- getwd()
[16:13:38.587]             }
[16:13:38.587]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:38.587]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:38.587]         }
[16:13:38.587]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:38.587]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:38.587]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:38.587]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:38.587]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:38.587]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:38.587]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:38.587]             base::names(...future.oldOptions))
[16:13:38.587]     }
[16:13:38.587]     if (FALSE) {
[16:13:38.587]     }
[16:13:38.587]     else {
[16:13:38.587]         if (TRUE) {
[16:13:38.587]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:38.587]                 open = "w")
[16:13:38.587]         }
[16:13:38.587]         else {
[16:13:38.587]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:38.587]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:38.587]         }
[16:13:38.587]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:38.587]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:38.587]             base::sink(type = "output", split = FALSE)
[16:13:38.587]             base::close(...future.stdout)
[16:13:38.587]         }, add = TRUE)
[16:13:38.587]     }
[16:13:38.587]     ...future.frame <- base::sys.nframe()
[16:13:38.587]     ...future.conditions <- base::list()
[16:13:38.587]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:38.587]     if (FALSE) {
[16:13:38.587]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:38.587]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:38.587]     }
[16:13:38.587]     ...future.result <- base::tryCatch({
[16:13:38.587]         base::withCallingHandlers({
[16:13:38.587]             ...future.value <- base::withVisible(base::local(2))
[16:13:38.587]             future::FutureResult(value = ...future.value$value, 
[16:13:38.587]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:38.587]                   ...future.rng), globalenv = if (FALSE) 
[16:13:38.587]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:38.587]                     ...future.globalenv.names))
[16:13:38.587]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:38.587]         }, condition = base::local({
[16:13:38.587]             c <- base::c
[16:13:38.587]             inherits <- base::inherits
[16:13:38.587]             invokeRestart <- base::invokeRestart
[16:13:38.587]             length <- base::length
[16:13:38.587]             list <- base::list
[16:13:38.587]             seq.int <- base::seq.int
[16:13:38.587]             signalCondition <- base::signalCondition
[16:13:38.587]             sys.calls <- base::sys.calls
[16:13:38.587]             `[[` <- base::`[[`
[16:13:38.587]             `+` <- base::`+`
[16:13:38.587]             `<<-` <- base::`<<-`
[16:13:38.587]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:38.587]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:38.587]                   3L)]
[16:13:38.587]             }
[16:13:38.587]             function(cond) {
[16:13:38.587]                 is_error <- inherits(cond, "error")
[16:13:38.587]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:38.587]                   NULL)
[16:13:38.587]                 if (is_error) {
[16:13:38.587]                   sessionInformation <- function() {
[16:13:38.587]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:38.587]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:38.587]                       search = base::search(), system = base::Sys.info())
[16:13:38.587]                   }
[16:13:38.587]                   ...future.conditions[[length(...future.conditions) + 
[16:13:38.587]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:38.587]                     cond$call), session = sessionInformation(), 
[16:13:38.587]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:38.587]                   signalCondition(cond)
[16:13:38.587]                 }
[16:13:38.587]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:38.587]                 "immediateCondition"))) {
[16:13:38.587]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:38.587]                   ...future.conditions[[length(...future.conditions) + 
[16:13:38.587]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:38.587]                   if (TRUE && !signal) {
[16:13:38.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:38.587]                     {
[16:13:38.587]                       inherits <- base::inherits
[16:13:38.587]                       invokeRestart <- base::invokeRestart
[16:13:38.587]                       is.null <- base::is.null
[16:13:38.587]                       muffled <- FALSE
[16:13:38.587]                       if (inherits(cond, "message")) {
[16:13:38.587]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:38.587]                         if (muffled) 
[16:13:38.587]                           invokeRestart("muffleMessage")
[16:13:38.587]                       }
[16:13:38.587]                       else if (inherits(cond, "warning")) {
[16:13:38.587]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:38.587]                         if (muffled) 
[16:13:38.587]                           invokeRestart("muffleWarning")
[16:13:38.587]                       }
[16:13:38.587]                       else if (inherits(cond, "condition")) {
[16:13:38.587]                         if (!is.null(pattern)) {
[16:13:38.587]                           computeRestarts <- base::computeRestarts
[16:13:38.587]                           grepl <- base::grepl
[16:13:38.587]                           restarts <- computeRestarts(cond)
[16:13:38.587]                           for (restart in restarts) {
[16:13:38.587]                             name <- restart$name
[16:13:38.587]                             if (is.null(name)) 
[16:13:38.587]                               next
[16:13:38.587]                             if (!grepl(pattern, name)) 
[16:13:38.587]                               next
[16:13:38.587]                             invokeRestart(restart)
[16:13:38.587]                             muffled <- TRUE
[16:13:38.587]                             break
[16:13:38.587]                           }
[16:13:38.587]                         }
[16:13:38.587]                       }
[16:13:38.587]                       invisible(muffled)
[16:13:38.587]                     }
[16:13:38.587]                     muffleCondition(cond, pattern = "^muffle")
[16:13:38.587]                   }
[16:13:38.587]                 }
[16:13:38.587]                 else {
[16:13:38.587]                   if (TRUE) {
[16:13:38.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:38.587]                     {
[16:13:38.587]                       inherits <- base::inherits
[16:13:38.587]                       invokeRestart <- base::invokeRestart
[16:13:38.587]                       is.null <- base::is.null
[16:13:38.587]                       muffled <- FALSE
[16:13:38.587]                       if (inherits(cond, "message")) {
[16:13:38.587]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:38.587]                         if (muffled) 
[16:13:38.587]                           invokeRestart("muffleMessage")
[16:13:38.587]                       }
[16:13:38.587]                       else if (inherits(cond, "warning")) {
[16:13:38.587]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:38.587]                         if (muffled) 
[16:13:38.587]                           invokeRestart("muffleWarning")
[16:13:38.587]                       }
[16:13:38.587]                       else if (inherits(cond, "condition")) {
[16:13:38.587]                         if (!is.null(pattern)) {
[16:13:38.587]                           computeRestarts <- base::computeRestarts
[16:13:38.587]                           grepl <- base::grepl
[16:13:38.587]                           restarts <- computeRestarts(cond)
[16:13:38.587]                           for (restart in restarts) {
[16:13:38.587]                             name <- restart$name
[16:13:38.587]                             if (is.null(name)) 
[16:13:38.587]                               next
[16:13:38.587]                             if (!grepl(pattern, name)) 
[16:13:38.587]                               next
[16:13:38.587]                             invokeRestart(restart)
[16:13:38.587]                             muffled <- TRUE
[16:13:38.587]                             break
[16:13:38.587]                           }
[16:13:38.587]                         }
[16:13:38.587]                       }
[16:13:38.587]                       invisible(muffled)
[16:13:38.587]                     }
[16:13:38.587]                     muffleCondition(cond, pattern = "^muffle")
[16:13:38.587]                   }
[16:13:38.587]                 }
[16:13:38.587]             }
[16:13:38.587]         }))
[16:13:38.587]     }, error = function(ex) {
[16:13:38.587]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:38.587]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:38.587]                 ...future.rng), started = ...future.startTime, 
[16:13:38.587]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:38.587]             version = "1.8"), class = "FutureResult")
[16:13:38.587]     }, finally = {
[16:13:38.587]         if (!identical(...future.workdir, getwd())) 
[16:13:38.587]             setwd(...future.workdir)
[16:13:38.587]         {
[16:13:38.587]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:38.587]                 ...future.oldOptions$nwarnings <- NULL
[16:13:38.587]             }
[16:13:38.587]             base::options(...future.oldOptions)
[16:13:38.587]             if (.Platform$OS.type == "windows") {
[16:13:38.587]                 old_names <- names(...future.oldEnvVars)
[16:13:38.587]                 envs <- base::Sys.getenv()
[16:13:38.587]                 names <- names(envs)
[16:13:38.587]                 common <- intersect(names, old_names)
[16:13:38.587]                 added <- setdiff(names, old_names)
[16:13:38.587]                 removed <- setdiff(old_names, names)
[16:13:38.587]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:38.587]                   envs[common]]
[16:13:38.587]                 NAMES <- toupper(changed)
[16:13:38.587]                 args <- list()
[16:13:38.587]                 for (kk in seq_along(NAMES)) {
[16:13:38.587]                   name <- changed[[kk]]
[16:13:38.587]                   NAME <- NAMES[[kk]]
[16:13:38.587]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.587]                     next
[16:13:38.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:38.587]                 }
[16:13:38.587]                 NAMES <- toupper(added)
[16:13:38.587]                 for (kk in seq_along(NAMES)) {
[16:13:38.587]                   name <- added[[kk]]
[16:13:38.587]                   NAME <- NAMES[[kk]]
[16:13:38.587]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.587]                     next
[16:13:38.587]                   args[[name]] <- ""
[16:13:38.587]                 }
[16:13:38.587]                 NAMES <- toupper(removed)
[16:13:38.587]                 for (kk in seq_along(NAMES)) {
[16:13:38.587]                   name <- removed[[kk]]
[16:13:38.587]                   NAME <- NAMES[[kk]]
[16:13:38.587]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.587]                     next
[16:13:38.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:38.587]                 }
[16:13:38.587]                 if (length(args) > 0) 
[16:13:38.587]                   base::do.call(base::Sys.setenv, args = args)
[16:13:38.587]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:38.587]             }
[16:13:38.587]             else {
[16:13:38.587]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:38.587]             }
[16:13:38.587]             {
[16:13:38.587]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:38.587]                   0L) {
[16:13:38.587]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:38.587]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:38.587]                   base::options(opts)
[16:13:38.587]                 }
[16:13:38.587]                 {
[16:13:38.587]                   {
[16:13:38.587]                     NULL
[16:13:38.587]                     RNGkind("Mersenne-Twister")
[16:13:38.587]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:38.587]                       inherits = FALSE)
[16:13:38.587]                   }
[16:13:38.587]                   options(future.plan = NULL)
[16:13:38.587]                   if (is.na(NA_character_)) 
[16:13:38.587]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:38.587]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:38.587]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:38.587]                   {
[16:13:38.587]                     future <- SequentialFuture(..., envir = envir)
[16:13:38.587]                     if (!future$lazy) 
[16:13:38.587]                       future <- run(future)
[16:13:38.587]                     invisible(future)
[16:13:38.587]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:38.587]                 }
[16:13:38.587]             }
[16:13:38.587]         }
[16:13:38.587]     })
[16:13:38.587]     if (TRUE) {
[16:13:38.587]         base::sink(type = "output", split = FALSE)
[16:13:38.587]         if (TRUE) {
[16:13:38.587]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:38.587]         }
[16:13:38.587]         else {
[16:13:38.587]             ...future.result["stdout"] <- base::list(NULL)
[16:13:38.587]         }
[16:13:38.587]         base::close(...future.stdout)
[16:13:38.587]         ...future.stdout <- NULL
[16:13:38.587]     }
[16:13:38.587]     ...future.result$conditions <- ...future.conditions
[16:13:38.587]     ...future.result$finished <- base::Sys.time()
[16:13:38.587]     ...future.result
[16:13:38.587] }
[16:13:38.589] plan(): Setting new future strategy stack:
[16:13:38.589] List of future strategies:
[16:13:38.589] 1. sequential:
[16:13:38.589]    - args: function (..., envir = parent.frame())
[16:13:38.589]    - tweaked: FALSE
[16:13:38.589]    - call: NULL
[16:13:38.589] plan(): nbrOfWorkers() = 1
[16:13:38.590] plan(): Setting new future strategy stack:
[16:13:38.590] List of future strategies:
[16:13:38.590] 1. sequential:
[16:13:38.590]    - args: function (..., envir = parent.frame())
[16:13:38.590]    - tweaked: FALSE
[16:13:38.590]    - call: plan(strategy)
[16:13:38.591] plan(): nbrOfWorkers() = 1
[16:13:38.591] SequentialFuture started (and completed)
[16:13:38.591] - Launch lazy future ... done
[16:13:38.591] run() for ‘SequentialFuture’ ... done
[16:13:38.591] resolve() on list ...
[16:13:38.591]  recursive: 0
[16:13:38.591]  length: 3
[16:13:38.591]  elements: ‘a’, ‘b’, ‘’
[16:13:38.592] resolved() for ‘SequentialFuture’ ...
[16:13:38.592] - state: ‘finished’
[16:13:38.592] - run: TRUE
[16:13:38.592] - result: ‘FutureResult’
[16:13:38.592] resolved() for ‘SequentialFuture’ ... done
[16:13:38.592] Future #1
[16:13:38.592]  length: 2 (resolved future 1)
[16:13:38.592] resolved() for ‘SequentialFuture’ ...
[16:13:38.593] - state: ‘finished’
[16:13:38.593] - run: TRUE
[16:13:38.593] - result: ‘FutureResult’
[16:13:38.593] resolved() for ‘SequentialFuture’ ... done
[16:13:38.593] Future #2
[16:13:38.593]  length: 1 (resolved future 2)
[16:13:38.593]  length: 0 (resolved future 3)
[16:13:38.593] resolve() on list ... DONE
[16:13:38.593] resolved() for ‘SequentialFuture’ ...
[16:13:38.593] - state: ‘finished’
[16:13:38.593] - run: TRUE
[16:13:38.594] - result: ‘FutureResult’
[16:13:38.594] resolved() for ‘SequentialFuture’ ... done
[16:13:38.594] resolved() for ‘SequentialFuture’ ...
[16:13:38.594] - state: ‘finished’
[16:13:38.594] - run: TRUE
[16:13:38.594] - result: ‘FutureResult’
[16:13:38.594] resolved() for ‘SequentialFuture’ ... done
[16:13:38.594] getGlobalsAndPackages() ...
[16:13:38.594] Searching for globals...
[16:13:38.595] 
[16:13:38.595] Searching for globals ... DONE
[16:13:38.595] - globals: [0] <none>
[16:13:38.595] getGlobalsAndPackages() ... DONE
[16:13:38.595] getGlobalsAndPackages() ...
[16:13:38.595] Searching for globals...
[16:13:38.595] 
[16:13:38.596] Searching for globals ... DONE
[16:13:38.596] - globals: [0] <none>
[16:13:38.596] getGlobalsAndPackages() ... DONE
[16:13:38.596] run() for ‘Future’ ...
[16:13:38.596] - state: ‘created’
[16:13:38.596] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:38.596] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:38.597] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:38.597]   - Field: ‘label’
[16:13:38.597]   - Field: ‘local’
[16:13:38.597]   - Field: ‘owner’
[16:13:38.597]   - Field: ‘envir’
[16:13:38.597]   - Field: ‘packages’
[16:13:38.597]   - Field: ‘gc’
[16:13:38.597]   - Field: ‘conditions’
[16:13:38.597]   - Field: ‘expr’
[16:13:38.597]   - Field: ‘uuid’
[16:13:38.598]   - Field: ‘seed’
[16:13:38.598]   - Field: ‘version’
[16:13:38.598]   - Field: ‘result’
[16:13:38.598]   - Field: ‘asynchronous’
[16:13:38.598]   - Field: ‘calls’
[16:13:38.598]   - Field: ‘globals’
[16:13:38.598]   - Field: ‘stdout’
[16:13:38.598]   - Field: ‘earlySignal’
[16:13:38.598]   - Field: ‘lazy’
[16:13:38.598]   - Field: ‘state’
[16:13:38.598] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:38.599] - Launch lazy future ...
[16:13:38.599] Packages needed by the future expression (n = 0): <none>
[16:13:38.599] Packages needed by future strategies (n = 0): <none>
[16:13:38.599] {
[16:13:38.599]     {
[16:13:38.599]         {
[16:13:38.599]             ...future.startTime <- base::Sys.time()
[16:13:38.599]             {
[16:13:38.599]                 {
[16:13:38.599]                   {
[16:13:38.599]                     base::local({
[16:13:38.599]                       has_future <- base::requireNamespace("future", 
[16:13:38.599]                         quietly = TRUE)
[16:13:38.599]                       if (has_future) {
[16:13:38.599]                         ns <- base::getNamespace("future")
[16:13:38.599]                         version <- ns[[".package"]][["version"]]
[16:13:38.599]                         if (is.null(version)) 
[16:13:38.599]                           version <- utils::packageVersion("future")
[16:13:38.599]                       }
[16:13:38.599]                       else {
[16:13:38.599]                         version <- NULL
[16:13:38.599]                       }
[16:13:38.599]                       if (!has_future || version < "1.8.0") {
[16:13:38.599]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:38.599]                           "", base::R.version$version.string), 
[16:13:38.599]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:38.599]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:38.599]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:38.599]                             "release", "version")], collapse = " "), 
[16:13:38.599]                           hostname = base::Sys.info()[["nodename"]])
[16:13:38.599]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:38.599]                           info)
[16:13:38.599]                         info <- base::paste(info, collapse = "; ")
[16:13:38.599]                         if (!has_future) {
[16:13:38.599]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:38.599]                             info)
[16:13:38.599]                         }
[16:13:38.599]                         else {
[16:13:38.599]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:38.599]                             info, version)
[16:13:38.599]                         }
[16:13:38.599]                         base::stop(msg)
[16:13:38.599]                       }
[16:13:38.599]                     })
[16:13:38.599]                   }
[16:13:38.599]                   options(future.plan = NULL)
[16:13:38.599]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:38.599]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:38.599]                 }
[16:13:38.599]                 ...future.workdir <- getwd()
[16:13:38.599]             }
[16:13:38.599]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:38.599]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:38.599]         }
[16:13:38.599]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:38.599]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:38.599]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:38.599]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:38.599]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:38.599]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:38.599]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:38.599]             base::names(...future.oldOptions))
[16:13:38.599]     }
[16:13:38.599]     if (FALSE) {
[16:13:38.599]     }
[16:13:38.599]     else {
[16:13:38.599]         if (TRUE) {
[16:13:38.599]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:38.599]                 open = "w")
[16:13:38.599]         }
[16:13:38.599]         else {
[16:13:38.599]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:38.599]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:38.599]         }
[16:13:38.599]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:38.599]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:38.599]             base::sink(type = "output", split = FALSE)
[16:13:38.599]             base::close(...future.stdout)
[16:13:38.599]         }, add = TRUE)
[16:13:38.599]     }
[16:13:38.599]     ...future.frame <- base::sys.nframe()
[16:13:38.599]     ...future.conditions <- base::list()
[16:13:38.599]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:38.599]     if (FALSE) {
[16:13:38.599]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:38.599]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:38.599]     }
[16:13:38.599]     ...future.result <- base::tryCatch({
[16:13:38.599]         base::withCallingHandlers({
[16:13:38.599]             ...future.value <- base::withVisible(base::local(2))
[16:13:38.599]             future::FutureResult(value = ...future.value$value, 
[16:13:38.599]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:38.599]                   ...future.rng), globalenv = if (FALSE) 
[16:13:38.599]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:38.599]                     ...future.globalenv.names))
[16:13:38.599]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:38.599]         }, condition = base::local({
[16:13:38.599]             c <- base::c
[16:13:38.599]             inherits <- base::inherits
[16:13:38.599]             invokeRestart <- base::invokeRestart
[16:13:38.599]             length <- base::length
[16:13:38.599]             list <- base::list
[16:13:38.599]             seq.int <- base::seq.int
[16:13:38.599]             signalCondition <- base::signalCondition
[16:13:38.599]             sys.calls <- base::sys.calls
[16:13:38.599]             `[[` <- base::`[[`
[16:13:38.599]             `+` <- base::`+`
[16:13:38.599]             `<<-` <- base::`<<-`
[16:13:38.599]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:38.599]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:38.599]                   3L)]
[16:13:38.599]             }
[16:13:38.599]             function(cond) {
[16:13:38.599]                 is_error <- inherits(cond, "error")
[16:13:38.599]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:38.599]                   NULL)
[16:13:38.599]                 if (is_error) {
[16:13:38.599]                   sessionInformation <- function() {
[16:13:38.599]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:38.599]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:38.599]                       search = base::search(), system = base::Sys.info())
[16:13:38.599]                   }
[16:13:38.599]                   ...future.conditions[[length(...future.conditions) + 
[16:13:38.599]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:38.599]                     cond$call), session = sessionInformation(), 
[16:13:38.599]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:38.599]                   signalCondition(cond)
[16:13:38.599]                 }
[16:13:38.599]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:38.599]                 "immediateCondition"))) {
[16:13:38.599]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:38.599]                   ...future.conditions[[length(...future.conditions) + 
[16:13:38.599]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:38.599]                   if (TRUE && !signal) {
[16:13:38.599]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:38.599]                     {
[16:13:38.599]                       inherits <- base::inherits
[16:13:38.599]                       invokeRestart <- base::invokeRestart
[16:13:38.599]                       is.null <- base::is.null
[16:13:38.599]                       muffled <- FALSE
[16:13:38.599]                       if (inherits(cond, "message")) {
[16:13:38.599]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:38.599]                         if (muffled) 
[16:13:38.599]                           invokeRestart("muffleMessage")
[16:13:38.599]                       }
[16:13:38.599]                       else if (inherits(cond, "warning")) {
[16:13:38.599]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:38.599]                         if (muffled) 
[16:13:38.599]                           invokeRestart("muffleWarning")
[16:13:38.599]                       }
[16:13:38.599]                       else if (inherits(cond, "condition")) {
[16:13:38.599]                         if (!is.null(pattern)) {
[16:13:38.599]                           computeRestarts <- base::computeRestarts
[16:13:38.599]                           grepl <- base::grepl
[16:13:38.599]                           restarts <- computeRestarts(cond)
[16:13:38.599]                           for (restart in restarts) {
[16:13:38.599]                             name <- restart$name
[16:13:38.599]                             if (is.null(name)) 
[16:13:38.599]                               next
[16:13:38.599]                             if (!grepl(pattern, name)) 
[16:13:38.599]                               next
[16:13:38.599]                             invokeRestart(restart)
[16:13:38.599]                             muffled <- TRUE
[16:13:38.599]                             break
[16:13:38.599]                           }
[16:13:38.599]                         }
[16:13:38.599]                       }
[16:13:38.599]                       invisible(muffled)
[16:13:38.599]                     }
[16:13:38.599]                     muffleCondition(cond, pattern = "^muffle")
[16:13:38.599]                   }
[16:13:38.599]                 }
[16:13:38.599]                 else {
[16:13:38.599]                   if (TRUE) {
[16:13:38.599]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:38.599]                     {
[16:13:38.599]                       inherits <- base::inherits
[16:13:38.599]                       invokeRestart <- base::invokeRestart
[16:13:38.599]                       is.null <- base::is.null
[16:13:38.599]                       muffled <- FALSE
[16:13:38.599]                       if (inherits(cond, "message")) {
[16:13:38.599]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:38.599]                         if (muffled) 
[16:13:38.599]                           invokeRestart("muffleMessage")
[16:13:38.599]                       }
[16:13:38.599]                       else if (inherits(cond, "warning")) {
[16:13:38.599]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:38.599]                         if (muffled) 
[16:13:38.599]                           invokeRestart("muffleWarning")
[16:13:38.599]                       }
[16:13:38.599]                       else if (inherits(cond, "condition")) {
[16:13:38.599]                         if (!is.null(pattern)) {
[16:13:38.599]                           computeRestarts <- base::computeRestarts
[16:13:38.599]                           grepl <- base::grepl
[16:13:38.599]                           restarts <- computeRestarts(cond)
[16:13:38.599]                           for (restart in restarts) {
[16:13:38.599]                             name <- restart$name
[16:13:38.599]                             if (is.null(name)) 
[16:13:38.599]                               next
[16:13:38.599]                             if (!grepl(pattern, name)) 
[16:13:38.599]                               next
[16:13:38.599]                             invokeRestart(restart)
[16:13:38.599]                             muffled <- TRUE
[16:13:38.599]                             break
[16:13:38.599]                           }
[16:13:38.599]                         }
[16:13:38.599]                       }
[16:13:38.599]                       invisible(muffled)
[16:13:38.599]                     }
[16:13:38.599]                     muffleCondition(cond, pattern = "^muffle")
[16:13:38.599]                   }
[16:13:38.599]                 }
[16:13:38.599]             }
[16:13:38.599]         }))
[16:13:38.599]     }, error = function(ex) {
[16:13:38.599]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:38.599]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:38.599]                 ...future.rng), started = ...future.startTime, 
[16:13:38.599]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:38.599]             version = "1.8"), class = "FutureResult")
[16:13:38.599]     }, finally = {
[16:13:38.599]         if (!identical(...future.workdir, getwd())) 
[16:13:38.599]             setwd(...future.workdir)
[16:13:38.599]         {
[16:13:38.599]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:38.599]                 ...future.oldOptions$nwarnings <- NULL
[16:13:38.599]             }
[16:13:38.599]             base::options(...future.oldOptions)
[16:13:38.599]             if (.Platform$OS.type == "windows") {
[16:13:38.599]                 old_names <- names(...future.oldEnvVars)
[16:13:38.599]                 envs <- base::Sys.getenv()
[16:13:38.599]                 names <- names(envs)
[16:13:38.599]                 common <- intersect(names, old_names)
[16:13:38.599]                 added <- setdiff(names, old_names)
[16:13:38.599]                 removed <- setdiff(old_names, names)
[16:13:38.599]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:38.599]                   envs[common]]
[16:13:38.599]                 NAMES <- toupper(changed)
[16:13:38.599]                 args <- list()
[16:13:38.599]                 for (kk in seq_along(NAMES)) {
[16:13:38.599]                   name <- changed[[kk]]
[16:13:38.599]                   NAME <- NAMES[[kk]]
[16:13:38.599]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.599]                     next
[16:13:38.599]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:38.599]                 }
[16:13:38.599]                 NAMES <- toupper(added)
[16:13:38.599]                 for (kk in seq_along(NAMES)) {
[16:13:38.599]                   name <- added[[kk]]
[16:13:38.599]                   NAME <- NAMES[[kk]]
[16:13:38.599]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.599]                     next
[16:13:38.599]                   args[[name]] <- ""
[16:13:38.599]                 }
[16:13:38.599]                 NAMES <- toupper(removed)
[16:13:38.599]                 for (kk in seq_along(NAMES)) {
[16:13:38.599]                   name <- removed[[kk]]
[16:13:38.599]                   NAME <- NAMES[[kk]]
[16:13:38.599]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.599]                     next
[16:13:38.599]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:38.599]                 }
[16:13:38.599]                 if (length(args) > 0) 
[16:13:38.599]                   base::do.call(base::Sys.setenv, args = args)
[16:13:38.599]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:38.599]             }
[16:13:38.599]             else {
[16:13:38.599]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:38.599]             }
[16:13:38.599]             {
[16:13:38.599]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:38.599]                   0L) {
[16:13:38.599]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:38.599]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:38.599]                   base::options(opts)
[16:13:38.599]                 }
[16:13:38.599]                 {
[16:13:38.599]                   {
[16:13:38.599]                     NULL
[16:13:38.599]                     RNGkind("Mersenne-Twister")
[16:13:38.599]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:38.599]                       inherits = FALSE)
[16:13:38.599]                   }
[16:13:38.599]                   options(future.plan = NULL)
[16:13:38.599]                   if (is.na(NA_character_)) 
[16:13:38.599]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:38.599]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:38.599]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:38.599]                   {
[16:13:38.599]                     future <- SequentialFuture(..., envir = envir)
[16:13:38.599]                     if (!future$lazy) 
[16:13:38.599]                       future <- run(future)
[16:13:38.599]                     invisible(future)
[16:13:38.599]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:38.599]                 }
[16:13:38.599]             }
[16:13:38.599]         }
[16:13:38.599]     })
[16:13:38.599]     if (TRUE) {
[16:13:38.599]         base::sink(type = "output", split = FALSE)
[16:13:38.599]         if (TRUE) {
[16:13:38.599]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:38.599]         }
[16:13:38.599]         else {
[16:13:38.599]             ...future.result["stdout"] <- base::list(NULL)
[16:13:38.599]         }
[16:13:38.599]         base::close(...future.stdout)
[16:13:38.599]         ...future.stdout <- NULL
[16:13:38.599]     }
[16:13:38.599]     ...future.result$conditions <- ...future.conditions
[16:13:38.599]     ...future.result$finished <- base::Sys.time()
[16:13:38.599]     ...future.result
[16:13:38.599] }
[16:13:38.601] plan(): Setting new future strategy stack:
[16:13:38.601] List of future strategies:
[16:13:38.601] 1. sequential:
[16:13:38.601]    - args: function (..., envir = parent.frame())
[16:13:38.601]    - tweaked: FALSE
[16:13:38.601]    - call: NULL
[16:13:38.601] plan(): nbrOfWorkers() = 1
[16:13:38.602] plan(): Setting new future strategy stack:
[16:13:38.602] List of future strategies:
[16:13:38.602] 1. sequential:
[16:13:38.602]    - args: function (..., envir = parent.frame())
[16:13:38.602]    - tweaked: FALSE
[16:13:38.602]    - call: plan(strategy)
[16:13:38.603] plan(): nbrOfWorkers() = 1
[16:13:38.603] SequentialFuture started (and completed)
[16:13:38.603] - Launch lazy future ... done
[16:13:38.603] run() for ‘SequentialFuture’ ... done
[16:13:38.603] resolve() on list ...
[16:13:38.603]  recursive: 0
[16:13:38.603]  length: 3
[16:13:38.603]  elements: ‘a’, ‘b’, ‘’
[16:13:38.604] run() for ‘Future’ ...
[16:13:38.604] - state: ‘created’
[16:13:38.604] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:38.604] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:38.604] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:38.604]   - Field: ‘label’
[16:13:38.604]   - Field: ‘local’
[16:13:38.604]   - Field: ‘owner’
[16:13:38.605]   - Field: ‘envir’
[16:13:38.605]   - Field: ‘packages’
[16:13:38.605]   - Field: ‘gc’
[16:13:38.605]   - Field: ‘conditions’
[16:13:38.605]   - Field: ‘expr’
[16:13:38.605]   - Field: ‘uuid’
[16:13:38.605]   - Field: ‘seed’
[16:13:38.605]   - Field: ‘version’
[16:13:38.605]   - Field: ‘result’
[16:13:38.605]   - Field: ‘asynchronous’
[16:13:38.605]   - Field: ‘calls’
[16:13:38.606]   - Field: ‘globals’
[16:13:38.606]   - Field: ‘stdout’
[16:13:38.606]   - Field: ‘earlySignal’
[16:13:38.606]   - Field: ‘lazy’
[16:13:38.606]   - Field: ‘state’
[16:13:38.606] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:38.606] - Launch lazy future ...
[16:13:38.606] Packages needed by the future expression (n = 0): <none>
[16:13:38.606] Packages needed by future strategies (n = 0): <none>
[16:13:38.607] {
[16:13:38.607]     {
[16:13:38.607]         {
[16:13:38.607]             ...future.startTime <- base::Sys.time()
[16:13:38.607]             {
[16:13:38.607]                 {
[16:13:38.607]                   {
[16:13:38.607]                     base::local({
[16:13:38.607]                       has_future <- base::requireNamespace("future", 
[16:13:38.607]                         quietly = TRUE)
[16:13:38.607]                       if (has_future) {
[16:13:38.607]                         ns <- base::getNamespace("future")
[16:13:38.607]                         version <- ns[[".package"]][["version"]]
[16:13:38.607]                         if (is.null(version)) 
[16:13:38.607]                           version <- utils::packageVersion("future")
[16:13:38.607]                       }
[16:13:38.607]                       else {
[16:13:38.607]                         version <- NULL
[16:13:38.607]                       }
[16:13:38.607]                       if (!has_future || version < "1.8.0") {
[16:13:38.607]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:38.607]                           "", base::R.version$version.string), 
[16:13:38.607]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:38.607]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:38.607]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:38.607]                             "release", "version")], collapse = " "), 
[16:13:38.607]                           hostname = base::Sys.info()[["nodename"]])
[16:13:38.607]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:38.607]                           info)
[16:13:38.607]                         info <- base::paste(info, collapse = "; ")
[16:13:38.607]                         if (!has_future) {
[16:13:38.607]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:38.607]                             info)
[16:13:38.607]                         }
[16:13:38.607]                         else {
[16:13:38.607]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:38.607]                             info, version)
[16:13:38.607]                         }
[16:13:38.607]                         base::stop(msg)
[16:13:38.607]                       }
[16:13:38.607]                     })
[16:13:38.607]                   }
[16:13:38.607]                   options(future.plan = NULL)
[16:13:38.607]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:38.607]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:38.607]                 }
[16:13:38.607]                 ...future.workdir <- getwd()
[16:13:38.607]             }
[16:13:38.607]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:38.607]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:38.607]         }
[16:13:38.607]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:38.607]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:38.607]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:38.607]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:38.607]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:38.607]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:38.607]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:38.607]             base::names(...future.oldOptions))
[16:13:38.607]     }
[16:13:38.607]     if (FALSE) {
[16:13:38.607]     }
[16:13:38.607]     else {
[16:13:38.607]         if (TRUE) {
[16:13:38.607]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:38.607]                 open = "w")
[16:13:38.607]         }
[16:13:38.607]         else {
[16:13:38.607]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:38.607]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:38.607]         }
[16:13:38.607]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:38.607]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:38.607]             base::sink(type = "output", split = FALSE)
[16:13:38.607]             base::close(...future.stdout)
[16:13:38.607]         }, add = TRUE)
[16:13:38.607]     }
[16:13:38.607]     ...future.frame <- base::sys.nframe()
[16:13:38.607]     ...future.conditions <- base::list()
[16:13:38.607]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:38.607]     if (FALSE) {
[16:13:38.607]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:38.607]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:38.607]     }
[16:13:38.607]     ...future.result <- base::tryCatch({
[16:13:38.607]         base::withCallingHandlers({
[16:13:38.607]             ...future.value <- base::withVisible(base::local(1))
[16:13:38.607]             future::FutureResult(value = ...future.value$value, 
[16:13:38.607]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:38.607]                   ...future.rng), globalenv = if (FALSE) 
[16:13:38.607]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:38.607]                     ...future.globalenv.names))
[16:13:38.607]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:38.607]         }, condition = base::local({
[16:13:38.607]             c <- base::c
[16:13:38.607]             inherits <- base::inherits
[16:13:38.607]             invokeRestart <- base::invokeRestart
[16:13:38.607]             length <- base::length
[16:13:38.607]             list <- base::list
[16:13:38.607]             seq.int <- base::seq.int
[16:13:38.607]             signalCondition <- base::signalCondition
[16:13:38.607]             sys.calls <- base::sys.calls
[16:13:38.607]             `[[` <- base::`[[`
[16:13:38.607]             `+` <- base::`+`
[16:13:38.607]             `<<-` <- base::`<<-`
[16:13:38.607]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:38.607]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:38.607]                   3L)]
[16:13:38.607]             }
[16:13:38.607]             function(cond) {
[16:13:38.607]                 is_error <- inherits(cond, "error")
[16:13:38.607]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:38.607]                   NULL)
[16:13:38.607]                 if (is_error) {
[16:13:38.607]                   sessionInformation <- function() {
[16:13:38.607]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:38.607]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:38.607]                       search = base::search(), system = base::Sys.info())
[16:13:38.607]                   }
[16:13:38.607]                   ...future.conditions[[length(...future.conditions) + 
[16:13:38.607]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:38.607]                     cond$call), session = sessionInformation(), 
[16:13:38.607]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:38.607]                   signalCondition(cond)
[16:13:38.607]                 }
[16:13:38.607]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:38.607]                 "immediateCondition"))) {
[16:13:38.607]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:38.607]                   ...future.conditions[[length(...future.conditions) + 
[16:13:38.607]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:38.607]                   if (TRUE && !signal) {
[16:13:38.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:38.607]                     {
[16:13:38.607]                       inherits <- base::inherits
[16:13:38.607]                       invokeRestart <- base::invokeRestart
[16:13:38.607]                       is.null <- base::is.null
[16:13:38.607]                       muffled <- FALSE
[16:13:38.607]                       if (inherits(cond, "message")) {
[16:13:38.607]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:38.607]                         if (muffled) 
[16:13:38.607]                           invokeRestart("muffleMessage")
[16:13:38.607]                       }
[16:13:38.607]                       else if (inherits(cond, "warning")) {
[16:13:38.607]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:38.607]                         if (muffled) 
[16:13:38.607]                           invokeRestart("muffleWarning")
[16:13:38.607]                       }
[16:13:38.607]                       else if (inherits(cond, "condition")) {
[16:13:38.607]                         if (!is.null(pattern)) {
[16:13:38.607]                           computeRestarts <- base::computeRestarts
[16:13:38.607]                           grepl <- base::grepl
[16:13:38.607]                           restarts <- computeRestarts(cond)
[16:13:38.607]                           for (restart in restarts) {
[16:13:38.607]                             name <- restart$name
[16:13:38.607]                             if (is.null(name)) 
[16:13:38.607]                               next
[16:13:38.607]                             if (!grepl(pattern, name)) 
[16:13:38.607]                               next
[16:13:38.607]                             invokeRestart(restart)
[16:13:38.607]                             muffled <- TRUE
[16:13:38.607]                             break
[16:13:38.607]                           }
[16:13:38.607]                         }
[16:13:38.607]                       }
[16:13:38.607]                       invisible(muffled)
[16:13:38.607]                     }
[16:13:38.607]                     muffleCondition(cond, pattern = "^muffle")
[16:13:38.607]                   }
[16:13:38.607]                 }
[16:13:38.607]                 else {
[16:13:38.607]                   if (TRUE) {
[16:13:38.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:38.607]                     {
[16:13:38.607]                       inherits <- base::inherits
[16:13:38.607]                       invokeRestart <- base::invokeRestart
[16:13:38.607]                       is.null <- base::is.null
[16:13:38.607]                       muffled <- FALSE
[16:13:38.607]                       if (inherits(cond, "message")) {
[16:13:38.607]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:38.607]                         if (muffled) 
[16:13:38.607]                           invokeRestart("muffleMessage")
[16:13:38.607]                       }
[16:13:38.607]                       else if (inherits(cond, "warning")) {
[16:13:38.607]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:38.607]                         if (muffled) 
[16:13:38.607]                           invokeRestart("muffleWarning")
[16:13:38.607]                       }
[16:13:38.607]                       else if (inherits(cond, "condition")) {
[16:13:38.607]                         if (!is.null(pattern)) {
[16:13:38.607]                           computeRestarts <- base::computeRestarts
[16:13:38.607]                           grepl <- base::grepl
[16:13:38.607]                           restarts <- computeRestarts(cond)
[16:13:38.607]                           for (restart in restarts) {
[16:13:38.607]                             name <- restart$name
[16:13:38.607]                             if (is.null(name)) 
[16:13:38.607]                               next
[16:13:38.607]                             if (!grepl(pattern, name)) 
[16:13:38.607]                               next
[16:13:38.607]                             invokeRestart(restart)
[16:13:38.607]                             muffled <- TRUE
[16:13:38.607]                             break
[16:13:38.607]                           }
[16:13:38.607]                         }
[16:13:38.607]                       }
[16:13:38.607]                       invisible(muffled)
[16:13:38.607]                     }
[16:13:38.607]                     muffleCondition(cond, pattern = "^muffle")
[16:13:38.607]                   }
[16:13:38.607]                 }
[16:13:38.607]             }
[16:13:38.607]         }))
[16:13:38.607]     }, error = function(ex) {
[16:13:38.607]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:38.607]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:38.607]                 ...future.rng), started = ...future.startTime, 
[16:13:38.607]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:38.607]             version = "1.8"), class = "FutureResult")
[16:13:38.607]     }, finally = {
[16:13:38.607]         if (!identical(...future.workdir, getwd())) 
[16:13:38.607]             setwd(...future.workdir)
[16:13:38.607]         {
[16:13:38.607]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:38.607]                 ...future.oldOptions$nwarnings <- NULL
[16:13:38.607]             }
[16:13:38.607]             base::options(...future.oldOptions)
[16:13:38.607]             if (.Platform$OS.type == "windows") {
[16:13:38.607]                 old_names <- names(...future.oldEnvVars)
[16:13:38.607]                 envs <- base::Sys.getenv()
[16:13:38.607]                 names <- names(envs)
[16:13:38.607]                 common <- intersect(names, old_names)
[16:13:38.607]                 added <- setdiff(names, old_names)
[16:13:38.607]                 removed <- setdiff(old_names, names)
[16:13:38.607]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:38.607]                   envs[common]]
[16:13:38.607]                 NAMES <- toupper(changed)
[16:13:38.607]                 args <- list()
[16:13:38.607]                 for (kk in seq_along(NAMES)) {
[16:13:38.607]                   name <- changed[[kk]]
[16:13:38.607]                   NAME <- NAMES[[kk]]
[16:13:38.607]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.607]                     next
[16:13:38.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:38.607]                 }
[16:13:38.607]                 NAMES <- toupper(added)
[16:13:38.607]                 for (kk in seq_along(NAMES)) {
[16:13:38.607]                   name <- added[[kk]]
[16:13:38.607]                   NAME <- NAMES[[kk]]
[16:13:38.607]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.607]                     next
[16:13:38.607]                   args[[name]] <- ""
[16:13:38.607]                 }
[16:13:38.607]                 NAMES <- toupper(removed)
[16:13:38.607]                 for (kk in seq_along(NAMES)) {
[16:13:38.607]                   name <- removed[[kk]]
[16:13:38.607]                   NAME <- NAMES[[kk]]
[16:13:38.607]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.607]                     next
[16:13:38.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:38.607]                 }
[16:13:38.607]                 if (length(args) > 0) 
[16:13:38.607]                   base::do.call(base::Sys.setenv, args = args)
[16:13:38.607]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:38.607]             }
[16:13:38.607]             else {
[16:13:38.607]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:38.607]             }
[16:13:38.607]             {
[16:13:38.607]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:38.607]                   0L) {
[16:13:38.607]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:38.607]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:38.607]                   base::options(opts)
[16:13:38.607]                 }
[16:13:38.607]                 {
[16:13:38.607]                   {
[16:13:38.607]                     NULL
[16:13:38.607]                     RNGkind("Mersenne-Twister")
[16:13:38.607]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:38.607]                       inherits = FALSE)
[16:13:38.607]                   }
[16:13:38.607]                   options(future.plan = NULL)
[16:13:38.607]                   if (is.na(NA_character_)) 
[16:13:38.607]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:38.607]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:38.607]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:38.607]                   {
[16:13:38.607]                     future <- SequentialFuture(..., envir = envir)
[16:13:38.607]                     if (!future$lazy) 
[16:13:38.607]                       future <- run(future)
[16:13:38.607]                     invisible(future)
[16:13:38.607]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:38.607]                 }
[16:13:38.607]             }
[16:13:38.607]         }
[16:13:38.607]     })
[16:13:38.607]     if (TRUE) {
[16:13:38.607]         base::sink(type = "output", split = FALSE)
[16:13:38.607]         if (TRUE) {
[16:13:38.607]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:38.607]         }
[16:13:38.607]         else {
[16:13:38.607]             ...future.result["stdout"] <- base::list(NULL)
[16:13:38.607]         }
[16:13:38.607]         base::close(...future.stdout)
[16:13:38.607]         ...future.stdout <- NULL
[16:13:38.607]     }
[16:13:38.607]     ...future.result$conditions <- ...future.conditions
[16:13:38.607]     ...future.result$finished <- base::Sys.time()
[16:13:38.607]     ...future.result
[16:13:38.607] }
[16:13:38.609] plan(): Setting new future strategy stack:
[16:13:38.609] List of future strategies:
[16:13:38.609] 1. sequential:
[16:13:38.609]    - args: function (..., envir = parent.frame())
[16:13:38.609]    - tweaked: FALSE
[16:13:38.609]    - call: NULL
[16:13:38.609] plan(): nbrOfWorkers() = 1
[16:13:38.610] plan(): Setting new future strategy stack:
[16:13:38.610] List of future strategies:
[16:13:38.610] 1. sequential:
[16:13:38.610]    - args: function (..., envir = parent.frame())
[16:13:38.610]    - tweaked: FALSE
[16:13:38.610]    - call: plan(strategy)
[16:13:38.610] plan(): nbrOfWorkers() = 1
[16:13:38.610] SequentialFuture started (and completed)
[16:13:38.610] - Launch lazy future ... done
[16:13:38.611] run() for ‘SequentialFuture’ ... done
[16:13:38.611] resolved() for ‘SequentialFuture’ ...
[16:13:38.611] - state: ‘finished’
[16:13:38.611] - run: TRUE
[16:13:38.611] - result: ‘FutureResult’
[16:13:38.611] resolved() for ‘SequentialFuture’ ... done
[16:13:38.611] Future #1
[16:13:38.611]  length: 2 (resolved future 1)
[16:13:38.611] resolved() for ‘SequentialFuture’ ...
[16:13:38.611] - state: ‘finished’
[16:13:38.612] - run: TRUE
[16:13:38.612] - result: ‘FutureResult’
[16:13:38.612] resolved() for ‘SequentialFuture’ ... done
[16:13:38.612] Future #2
[16:13:38.612]  length: 1 (resolved future 2)
[16:13:38.612]  length: 0 (resolved future 3)
[16:13:38.612] resolve() on list ... DONE
[16:13:38.612] resolved() for ‘SequentialFuture’ ...
[16:13:38.612] - state: ‘finished’
[16:13:38.612] - run: TRUE
[16:13:38.613] - result: ‘FutureResult’
[16:13:38.613] resolved() for ‘SequentialFuture’ ... done
[16:13:38.613] resolved() for ‘SequentialFuture’ ...
[16:13:38.613] - state: ‘finished’
[16:13:38.613] - run: TRUE
[16:13:38.613] - result: ‘FutureResult’
[16:13:38.613] resolved() for ‘SequentialFuture’ ... done
[16:13:38.613] getGlobalsAndPackages() ...
[16:13:38.613] Searching for globals...
[16:13:38.614] 
[16:13:38.614] Searching for globals ... DONE
[16:13:38.614] - globals: [0] <none>
[16:13:38.614] getGlobalsAndPackages() ... DONE
[16:13:38.614] getGlobalsAndPackages() ...
[16:13:38.614] Searching for globals...
[16:13:38.614] 
[16:13:38.614] Searching for globals ... DONE
[16:13:38.615] - globals: [0] <none>
[16:13:38.615] getGlobalsAndPackages() ... DONE
[16:13:38.615] resolve() on list ...
[16:13:38.615]  recursive: 0
[16:13:38.615]  length: 3
[16:13:38.615]  elements: ‘a’, ‘b’, ‘’
[16:13:38.615] run() for ‘Future’ ...
[16:13:38.615] - state: ‘created’
[16:13:38.615] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:38.617] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:38.618] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:38.618]   - Field: ‘label’
[16:13:38.618]   - Field: ‘local’
[16:13:38.618]   - Field: ‘owner’
[16:13:38.618]   - Field: ‘envir’
[16:13:38.618]   - Field: ‘packages’
[16:13:38.618]   - Field: ‘gc’
[16:13:38.618]   - Field: ‘conditions’
[16:13:38.618]   - Field: ‘expr’
[16:13:38.618]   - Field: ‘uuid’
[16:13:38.619]   - Field: ‘seed’
[16:13:38.619]   - Field: ‘version’
[16:13:38.619]   - Field: ‘result’
[16:13:38.619]   - Field: ‘asynchronous’
[16:13:38.619]   - Field: ‘calls’
[16:13:38.619]   - Field: ‘globals’
[16:13:38.619]   - Field: ‘stdout’
[16:13:38.619]   - Field: ‘earlySignal’
[16:13:38.619]   - Field: ‘lazy’
[16:13:38.619]   - Field: ‘state’
[16:13:38.620] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:38.620] - Launch lazy future ...
[16:13:38.620] Packages needed by the future expression (n = 0): <none>
[16:13:38.620] Packages needed by future strategies (n = 0): <none>
[16:13:38.620] {
[16:13:38.620]     {
[16:13:38.620]         {
[16:13:38.620]             ...future.startTime <- base::Sys.time()
[16:13:38.620]             {
[16:13:38.620]                 {
[16:13:38.620]                   {
[16:13:38.620]                     base::local({
[16:13:38.620]                       has_future <- base::requireNamespace("future", 
[16:13:38.620]                         quietly = TRUE)
[16:13:38.620]                       if (has_future) {
[16:13:38.620]                         ns <- base::getNamespace("future")
[16:13:38.620]                         version <- ns[[".package"]][["version"]]
[16:13:38.620]                         if (is.null(version)) 
[16:13:38.620]                           version <- utils::packageVersion("future")
[16:13:38.620]                       }
[16:13:38.620]                       else {
[16:13:38.620]                         version <- NULL
[16:13:38.620]                       }
[16:13:38.620]                       if (!has_future || version < "1.8.0") {
[16:13:38.620]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:38.620]                           "", base::R.version$version.string), 
[16:13:38.620]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:38.620]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:38.620]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:38.620]                             "release", "version")], collapse = " "), 
[16:13:38.620]                           hostname = base::Sys.info()[["nodename"]])
[16:13:38.620]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:38.620]                           info)
[16:13:38.620]                         info <- base::paste(info, collapse = "; ")
[16:13:38.620]                         if (!has_future) {
[16:13:38.620]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:38.620]                             info)
[16:13:38.620]                         }
[16:13:38.620]                         else {
[16:13:38.620]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:38.620]                             info, version)
[16:13:38.620]                         }
[16:13:38.620]                         base::stop(msg)
[16:13:38.620]                       }
[16:13:38.620]                     })
[16:13:38.620]                   }
[16:13:38.620]                   options(future.plan = NULL)
[16:13:38.620]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:38.620]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:38.620]                 }
[16:13:38.620]                 ...future.workdir <- getwd()
[16:13:38.620]             }
[16:13:38.620]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:38.620]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:38.620]         }
[16:13:38.620]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:38.620]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:38.620]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:38.620]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:38.620]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:38.620]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:38.620]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:38.620]             base::names(...future.oldOptions))
[16:13:38.620]     }
[16:13:38.620]     if (FALSE) {
[16:13:38.620]     }
[16:13:38.620]     else {
[16:13:38.620]         if (TRUE) {
[16:13:38.620]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:38.620]                 open = "w")
[16:13:38.620]         }
[16:13:38.620]         else {
[16:13:38.620]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:38.620]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:38.620]         }
[16:13:38.620]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:38.620]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:38.620]             base::sink(type = "output", split = FALSE)
[16:13:38.620]             base::close(...future.stdout)
[16:13:38.620]         }, add = TRUE)
[16:13:38.620]     }
[16:13:38.620]     ...future.frame <- base::sys.nframe()
[16:13:38.620]     ...future.conditions <- base::list()
[16:13:38.620]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:38.620]     if (FALSE) {
[16:13:38.620]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:38.620]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:38.620]     }
[16:13:38.620]     ...future.result <- base::tryCatch({
[16:13:38.620]         base::withCallingHandlers({
[16:13:38.620]             ...future.value <- base::withVisible(base::local(1))
[16:13:38.620]             future::FutureResult(value = ...future.value$value, 
[16:13:38.620]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:38.620]                   ...future.rng), globalenv = if (FALSE) 
[16:13:38.620]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:38.620]                     ...future.globalenv.names))
[16:13:38.620]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:38.620]         }, condition = base::local({
[16:13:38.620]             c <- base::c
[16:13:38.620]             inherits <- base::inherits
[16:13:38.620]             invokeRestart <- base::invokeRestart
[16:13:38.620]             length <- base::length
[16:13:38.620]             list <- base::list
[16:13:38.620]             seq.int <- base::seq.int
[16:13:38.620]             signalCondition <- base::signalCondition
[16:13:38.620]             sys.calls <- base::sys.calls
[16:13:38.620]             `[[` <- base::`[[`
[16:13:38.620]             `+` <- base::`+`
[16:13:38.620]             `<<-` <- base::`<<-`
[16:13:38.620]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:38.620]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:38.620]                   3L)]
[16:13:38.620]             }
[16:13:38.620]             function(cond) {
[16:13:38.620]                 is_error <- inherits(cond, "error")
[16:13:38.620]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:38.620]                   NULL)
[16:13:38.620]                 if (is_error) {
[16:13:38.620]                   sessionInformation <- function() {
[16:13:38.620]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:38.620]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:38.620]                       search = base::search(), system = base::Sys.info())
[16:13:38.620]                   }
[16:13:38.620]                   ...future.conditions[[length(...future.conditions) + 
[16:13:38.620]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:38.620]                     cond$call), session = sessionInformation(), 
[16:13:38.620]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:38.620]                   signalCondition(cond)
[16:13:38.620]                 }
[16:13:38.620]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:38.620]                 "immediateCondition"))) {
[16:13:38.620]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:38.620]                   ...future.conditions[[length(...future.conditions) + 
[16:13:38.620]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:38.620]                   if (TRUE && !signal) {
[16:13:38.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:38.620]                     {
[16:13:38.620]                       inherits <- base::inherits
[16:13:38.620]                       invokeRestart <- base::invokeRestart
[16:13:38.620]                       is.null <- base::is.null
[16:13:38.620]                       muffled <- FALSE
[16:13:38.620]                       if (inherits(cond, "message")) {
[16:13:38.620]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:38.620]                         if (muffled) 
[16:13:38.620]                           invokeRestart("muffleMessage")
[16:13:38.620]                       }
[16:13:38.620]                       else if (inherits(cond, "warning")) {
[16:13:38.620]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:38.620]                         if (muffled) 
[16:13:38.620]                           invokeRestart("muffleWarning")
[16:13:38.620]                       }
[16:13:38.620]                       else if (inherits(cond, "condition")) {
[16:13:38.620]                         if (!is.null(pattern)) {
[16:13:38.620]                           computeRestarts <- base::computeRestarts
[16:13:38.620]                           grepl <- base::grepl
[16:13:38.620]                           restarts <- computeRestarts(cond)
[16:13:38.620]                           for (restart in restarts) {
[16:13:38.620]                             name <- restart$name
[16:13:38.620]                             if (is.null(name)) 
[16:13:38.620]                               next
[16:13:38.620]                             if (!grepl(pattern, name)) 
[16:13:38.620]                               next
[16:13:38.620]                             invokeRestart(restart)
[16:13:38.620]                             muffled <- TRUE
[16:13:38.620]                             break
[16:13:38.620]                           }
[16:13:38.620]                         }
[16:13:38.620]                       }
[16:13:38.620]                       invisible(muffled)
[16:13:38.620]                     }
[16:13:38.620]                     muffleCondition(cond, pattern = "^muffle")
[16:13:38.620]                   }
[16:13:38.620]                 }
[16:13:38.620]                 else {
[16:13:38.620]                   if (TRUE) {
[16:13:38.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:38.620]                     {
[16:13:38.620]                       inherits <- base::inherits
[16:13:38.620]                       invokeRestart <- base::invokeRestart
[16:13:38.620]                       is.null <- base::is.null
[16:13:38.620]                       muffled <- FALSE
[16:13:38.620]                       if (inherits(cond, "message")) {
[16:13:38.620]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:38.620]                         if (muffled) 
[16:13:38.620]                           invokeRestart("muffleMessage")
[16:13:38.620]                       }
[16:13:38.620]                       else if (inherits(cond, "warning")) {
[16:13:38.620]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:38.620]                         if (muffled) 
[16:13:38.620]                           invokeRestart("muffleWarning")
[16:13:38.620]                       }
[16:13:38.620]                       else if (inherits(cond, "condition")) {
[16:13:38.620]                         if (!is.null(pattern)) {
[16:13:38.620]                           computeRestarts <- base::computeRestarts
[16:13:38.620]                           grepl <- base::grepl
[16:13:38.620]                           restarts <- computeRestarts(cond)
[16:13:38.620]                           for (restart in restarts) {
[16:13:38.620]                             name <- restart$name
[16:13:38.620]                             if (is.null(name)) 
[16:13:38.620]                               next
[16:13:38.620]                             if (!grepl(pattern, name)) 
[16:13:38.620]                               next
[16:13:38.620]                             invokeRestart(restart)
[16:13:38.620]                             muffled <- TRUE
[16:13:38.620]                             break
[16:13:38.620]                           }
[16:13:38.620]                         }
[16:13:38.620]                       }
[16:13:38.620]                       invisible(muffled)
[16:13:38.620]                     }
[16:13:38.620]                     muffleCondition(cond, pattern = "^muffle")
[16:13:38.620]                   }
[16:13:38.620]                 }
[16:13:38.620]             }
[16:13:38.620]         }))
[16:13:38.620]     }, error = function(ex) {
[16:13:38.620]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:38.620]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:38.620]                 ...future.rng), started = ...future.startTime, 
[16:13:38.620]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:38.620]             version = "1.8"), class = "FutureResult")
[16:13:38.620]     }, finally = {
[16:13:38.620]         if (!identical(...future.workdir, getwd())) 
[16:13:38.620]             setwd(...future.workdir)
[16:13:38.620]         {
[16:13:38.620]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:38.620]                 ...future.oldOptions$nwarnings <- NULL
[16:13:38.620]             }
[16:13:38.620]             base::options(...future.oldOptions)
[16:13:38.620]             if (.Platform$OS.type == "windows") {
[16:13:38.620]                 old_names <- names(...future.oldEnvVars)
[16:13:38.620]                 envs <- base::Sys.getenv()
[16:13:38.620]                 names <- names(envs)
[16:13:38.620]                 common <- intersect(names, old_names)
[16:13:38.620]                 added <- setdiff(names, old_names)
[16:13:38.620]                 removed <- setdiff(old_names, names)
[16:13:38.620]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:38.620]                   envs[common]]
[16:13:38.620]                 NAMES <- toupper(changed)
[16:13:38.620]                 args <- list()
[16:13:38.620]                 for (kk in seq_along(NAMES)) {
[16:13:38.620]                   name <- changed[[kk]]
[16:13:38.620]                   NAME <- NAMES[[kk]]
[16:13:38.620]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.620]                     next
[16:13:38.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:38.620]                 }
[16:13:38.620]                 NAMES <- toupper(added)
[16:13:38.620]                 for (kk in seq_along(NAMES)) {
[16:13:38.620]                   name <- added[[kk]]
[16:13:38.620]                   NAME <- NAMES[[kk]]
[16:13:38.620]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.620]                     next
[16:13:38.620]                   args[[name]] <- ""
[16:13:38.620]                 }
[16:13:38.620]                 NAMES <- toupper(removed)
[16:13:38.620]                 for (kk in seq_along(NAMES)) {
[16:13:38.620]                   name <- removed[[kk]]
[16:13:38.620]                   NAME <- NAMES[[kk]]
[16:13:38.620]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.620]                     next
[16:13:38.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:38.620]                 }
[16:13:38.620]                 if (length(args) > 0) 
[16:13:38.620]                   base::do.call(base::Sys.setenv, args = args)
[16:13:38.620]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:38.620]             }
[16:13:38.620]             else {
[16:13:38.620]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:38.620]             }
[16:13:38.620]             {
[16:13:38.620]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:38.620]                   0L) {
[16:13:38.620]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:38.620]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:38.620]                   base::options(opts)
[16:13:38.620]                 }
[16:13:38.620]                 {
[16:13:38.620]                   {
[16:13:38.620]                     NULL
[16:13:38.620]                     RNGkind("Mersenne-Twister")
[16:13:38.620]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:38.620]                       inherits = FALSE)
[16:13:38.620]                   }
[16:13:38.620]                   options(future.plan = NULL)
[16:13:38.620]                   if (is.na(NA_character_)) 
[16:13:38.620]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:38.620]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:38.620]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:38.620]                   {
[16:13:38.620]                     future <- SequentialFuture(..., envir = envir)
[16:13:38.620]                     if (!future$lazy) 
[16:13:38.620]                       future <- run(future)
[16:13:38.620]                     invisible(future)
[16:13:38.620]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:38.620]                 }
[16:13:38.620]             }
[16:13:38.620]         }
[16:13:38.620]     })
[16:13:38.620]     if (TRUE) {
[16:13:38.620]         base::sink(type = "output", split = FALSE)
[16:13:38.620]         if (TRUE) {
[16:13:38.620]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:38.620]         }
[16:13:38.620]         else {
[16:13:38.620]             ...future.result["stdout"] <- base::list(NULL)
[16:13:38.620]         }
[16:13:38.620]         base::close(...future.stdout)
[16:13:38.620]         ...future.stdout <- NULL
[16:13:38.620]     }
[16:13:38.620]     ...future.result$conditions <- ...future.conditions
[16:13:38.620]     ...future.result$finished <- base::Sys.time()
[16:13:38.620]     ...future.result
[16:13:38.620] }
[16:13:38.622] plan(): Setting new future strategy stack:
[16:13:38.622] List of future strategies:
[16:13:38.622] 1. sequential:
[16:13:38.622]    - args: function (..., envir = parent.frame())
[16:13:38.622]    - tweaked: FALSE
[16:13:38.622]    - call: NULL
[16:13:38.623] plan(): nbrOfWorkers() = 1
[16:13:38.623] plan(): Setting new future strategy stack:
[16:13:38.623] List of future strategies:
[16:13:38.623] 1. sequential:
[16:13:38.623]    - args: function (..., envir = parent.frame())
[16:13:38.623]    - tweaked: FALSE
[16:13:38.623]    - call: plan(strategy)
[16:13:38.624] plan(): nbrOfWorkers() = 1
[16:13:38.624] SequentialFuture started (and completed)
[16:13:38.624] - Launch lazy future ... done
[16:13:38.624] run() for ‘SequentialFuture’ ... done
[16:13:38.624] resolved() for ‘SequentialFuture’ ...
[16:13:38.624] - state: ‘finished’
[16:13:38.624] - run: TRUE
[16:13:38.625] - result: ‘FutureResult’
[16:13:38.625] resolved() for ‘SequentialFuture’ ... done
[16:13:38.625] Future #1
[16:13:38.625]  length: 2 (resolved future 1)
[16:13:38.625] run() for ‘Future’ ...
[16:13:38.625] - state: ‘created’
[16:13:38.625] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:38.625] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:38.626] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:38.626]   - Field: ‘label’
[16:13:38.626]   - Field: ‘local’
[16:13:38.626]   - Field: ‘owner’
[16:13:38.626]   - Field: ‘envir’
[16:13:38.626]   - Field: ‘packages’
[16:13:38.626]   - Field: ‘gc’
[16:13:38.626]   - Field: ‘conditions’
[16:13:38.626]   - Field: ‘expr’
[16:13:38.626]   - Field: ‘uuid’
[16:13:38.627]   - Field: ‘seed’
[16:13:38.627]   - Field: ‘version’
[16:13:38.627]   - Field: ‘result’
[16:13:38.627]   - Field: ‘asynchronous’
[16:13:38.627]   - Field: ‘calls’
[16:13:38.627]   - Field: ‘globals’
[16:13:38.627]   - Field: ‘stdout’
[16:13:38.627]   - Field: ‘earlySignal’
[16:13:38.627]   - Field: ‘lazy’
[16:13:38.627]   - Field: ‘state’
[16:13:38.627] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:38.628] - Launch lazy future ...
[16:13:38.628] Packages needed by the future expression (n = 0): <none>
[16:13:38.628] Packages needed by future strategies (n = 0): <none>
[16:13:38.628] {
[16:13:38.628]     {
[16:13:38.628]         {
[16:13:38.628]             ...future.startTime <- base::Sys.time()
[16:13:38.628]             {
[16:13:38.628]                 {
[16:13:38.628]                   {
[16:13:38.628]                     base::local({
[16:13:38.628]                       has_future <- base::requireNamespace("future", 
[16:13:38.628]                         quietly = TRUE)
[16:13:38.628]                       if (has_future) {
[16:13:38.628]                         ns <- base::getNamespace("future")
[16:13:38.628]                         version <- ns[[".package"]][["version"]]
[16:13:38.628]                         if (is.null(version)) 
[16:13:38.628]                           version <- utils::packageVersion("future")
[16:13:38.628]                       }
[16:13:38.628]                       else {
[16:13:38.628]                         version <- NULL
[16:13:38.628]                       }
[16:13:38.628]                       if (!has_future || version < "1.8.0") {
[16:13:38.628]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:38.628]                           "", base::R.version$version.string), 
[16:13:38.628]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:38.628]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:38.628]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:38.628]                             "release", "version")], collapse = " "), 
[16:13:38.628]                           hostname = base::Sys.info()[["nodename"]])
[16:13:38.628]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:38.628]                           info)
[16:13:38.628]                         info <- base::paste(info, collapse = "; ")
[16:13:38.628]                         if (!has_future) {
[16:13:38.628]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:38.628]                             info)
[16:13:38.628]                         }
[16:13:38.628]                         else {
[16:13:38.628]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:38.628]                             info, version)
[16:13:38.628]                         }
[16:13:38.628]                         base::stop(msg)
[16:13:38.628]                       }
[16:13:38.628]                     })
[16:13:38.628]                   }
[16:13:38.628]                   options(future.plan = NULL)
[16:13:38.628]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:38.628]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:38.628]                 }
[16:13:38.628]                 ...future.workdir <- getwd()
[16:13:38.628]             }
[16:13:38.628]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:38.628]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:38.628]         }
[16:13:38.628]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:38.628]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:38.628]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:38.628]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:38.628]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:38.628]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:38.628]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:38.628]             base::names(...future.oldOptions))
[16:13:38.628]     }
[16:13:38.628]     if (FALSE) {
[16:13:38.628]     }
[16:13:38.628]     else {
[16:13:38.628]         if (TRUE) {
[16:13:38.628]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:38.628]                 open = "w")
[16:13:38.628]         }
[16:13:38.628]         else {
[16:13:38.628]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:38.628]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:38.628]         }
[16:13:38.628]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:38.628]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:38.628]             base::sink(type = "output", split = FALSE)
[16:13:38.628]             base::close(...future.stdout)
[16:13:38.628]         }, add = TRUE)
[16:13:38.628]     }
[16:13:38.628]     ...future.frame <- base::sys.nframe()
[16:13:38.628]     ...future.conditions <- base::list()
[16:13:38.628]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:38.628]     if (FALSE) {
[16:13:38.628]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:38.628]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:38.628]     }
[16:13:38.628]     ...future.result <- base::tryCatch({
[16:13:38.628]         base::withCallingHandlers({
[16:13:38.628]             ...future.value <- base::withVisible(base::local(2))
[16:13:38.628]             future::FutureResult(value = ...future.value$value, 
[16:13:38.628]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:38.628]                   ...future.rng), globalenv = if (FALSE) 
[16:13:38.628]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:38.628]                     ...future.globalenv.names))
[16:13:38.628]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:38.628]         }, condition = base::local({
[16:13:38.628]             c <- base::c
[16:13:38.628]             inherits <- base::inherits
[16:13:38.628]             invokeRestart <- base::invokeRestart
[16:13:38.628]             length <- base::length
[16:13:38.628]             list <- base::list
[16:13:38.628]             seq.int <- base::seq.int
[16:13:38.628]             signalCondition <- base::signalCondition
[16:13:38.628]             sys.calls <- base::sys.calls
[16:13:38.628]             `[[` <- base::`[[`
[16:13:38.628]             `+` <- base::`+`
[16:13:38.628]             `<<-` <- base::`<<-`
[16:13:38.628]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:38.628]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:38.628]                   3L)]
[16:13:38.628]             }
[16:13:38.628]             function(cond) {
[16:13:38.628]                 is_error <- inherits(cond, "error")
[16:13:38.628]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:38.628]                   NULL)
[16:13:38.628]                 if (is_error) {
[16:13:38.628]                   sessionInformation <- function() {
[16:13:38.628]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:38.628]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:38.628]                       search = base::search(), system = base::Sys.info())
[16:13:38.628]                   }
[16:13:38.628]                   ...future.conditions[[length(...future.conditions) + 
[16:13:38.628]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:38.628]                     cond$call), session = sessionInformation(), 
[16:13:38.628]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:38.628]                   signalCondition(cond)
[16:13:38.628]                 }
[16:13:38.628]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:38.628]                 "immediateCondition"))) {
[16:13:38.628]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:38.628]                   ...future.conditions[[length(...future.conditions) + 
[16:13:38.628]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:38.628]                   if (TRUE && !signal) {
[16:13:38.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:38.628]                     {
[16:13:38.628]                       inherits <- base::inherits
[16:13:38.628]                       invokeRestart <- base::invokeRestart
[16:13:38.628]                       is.null <- base::is.null
[16:13:38.628]                       muffled <- FALSE
[16:13:38.628]                       if (inherits(cond, "message")) {
[16:13:38.628]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:38.628]                         if (muffled) 
[16:13:38.628]                           invokeRestart("muffleMessage")
[16:13:38.628]                       }
[16:13:38.628]                       else if (inherits(cond, "warning")) {
[16:13:38.628]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:38.628]                         if (muffled) 
[16:13:38.628]                           invokeRestart("muffleWarning")
[16:13:38.628]                       }
[16:13:38.628]                       else if (inherits(cond, "condition")) {
[16:13:38.628]                         if (!is.null(pattern)) {
[16:13:38.628]                           computeRestarts <- base::computeRestarts
[16:13:38.628]                           grepl <- base::grepl
[16:13:38.628]                           restarts <- computeRestarts(cond)
[16:13:38.628]                           for (restart in restarts) {
[16:13:38.628]                             name <- restart$name
[16:13:38.628]                             if (is.null(name)) 
[16:13:38.628]                               next
[16:13:38.628]                             if (!grepl(pattern, name)) 
[16:13:38.628]                               next
[16:13:38.628]                             invokeRestart(restart)
[16:13:38.628]                             muffled <- TRUE
[16:13:38.628]                             break
[16:13:38.628]                           }
[16:13:38.628]                         }
[16:13:38.628]                       }
[16:13:38.628]                       invisible(muffled)
[16:13:38.628]                     }
[16:13:38.628]                     muffleCondition(cond, pattern = "^muffle")
[16:13:38.628]                   }
[16:13:38.628]                 }
[16:13:38.628]                 else {
[16:13:38.628]                   if (TRUE) {
[16:13:38.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:38.628]                     {
[16:13:38.628]                       inherits <- base::inherits
[16:13:38.628]                       invokeRestart <- base::invokeRestart
[16:13:38.628]                       is.null <- base::is.null
[16:13:38.628]                       muffled <- FALSE
[16:13:38.628]                       if (inherits(cond, "message")) {
[16:13:38.628]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:38.628]                         if (muffled) 
[16:13:38.628]                           invokeRestart("muffleMessage")
[16:13:38.628]                       }
[16:13:38.628]                       else if (inherits(cond, "warning")) {
[16:13:38.628]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:38.628]                         if (muffled) 
[16:13:38.628]                           invokeRestart("muffleWarning")
[16:13:38.628]                       }
[16:13:38.628]                       else if (inherits(cond, "condition")) {
[16:13:38.628]                         if (!is.null(pattern)) {
[16:13:38.628]                           computeRestarts <- base::computeRestarts
[16:13:38.628]                           grepl <- base::grepl
[16:13:38.628]                           restarts <- computeRestarts(cond)
[16:13:38.628]                           for (restart in restarts) {
[16:13:38.628]                             name <- restart$name
[16:13:38.628]                             if (is.null(name)) 
[16:13:38.628]                               next
[16:13:38.628]                             if (!grepl(pattern, name)) 
[16:13:38.628]                               next
[16:13:38.628]                             invokeRestart(restart)
[16:13:38.628]                             muffled <- TRUE
[16:13:38.628]                             break
[16:13:38.628]                           }
[16:13:38.628]                         }
[16:13:38.628]                       }
[16:13:38.628]                       invisible(muffled)
[16:13:38.628]                     }
[16:13:38.628]                     muffleCondition(cond, pattern = "^muffle")
[16:13:38.628]                   }
[16:13:38.628]                 }
[16:13:38.628]             }
[16:13:38.628]         }))
[16:13:38.628]     }, error = function(ex) {
[16:13:38.628]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:38.628]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:38.628]                 ...future.rng), started = ...future.startTime, 
[16:13:38.628]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:38.628]             version = "1.8"), class = "FutureResult")
[16:13:38.628]     }, finally = {
[16:13:38.628]         if (!identical(...future.workdir, getwd())) 
[16:13:38.628]             setwd(...future.workdir)
[16:13:38.628]         {
[16:13:38.628]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:38.628]                 ...future.oldOptions$nwarnings <- NULL
[16:13:38.628]             }
[16:13:38.628]             base::options(...future.oldOptions)
[16:13:38.628]             if (.Platform$OS.type == "windows") {
[16:13:38.628]                 old_names <- names(...future.oldEnvVars)
[16:13:38.628]                 envs <- base::Sys.getenv()
[16:13:38.628]                 names <- names(envs)
[16:13:38.628]                 common <- intersect(names, old_names)
[16:13:38.628]                 added <- setdiff(names, old_names)
[16:13:38.628]                 removed <- setdiff(old_names, names)
[16:13:38.628]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:38.628]                   envs[common]]
[16:13:38.628]                 NAMES <- toupper(changed)
[16:13:38.628]                 args <- list()
[16:13:38.628]                 for (kk in seq_along(NAMES)) {
[16:13:38.628]                   name <- changed[[kk]]
[16:13:38.628]                   NAME <- NAMES[[kk]]
[16:13:38.628]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.628]                     next
[16:13:38.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:38.628]                 }
[16:13:38.628]                 NAMES <- toupper(added)
[16:13:38.628]                 for (kk in seq_along(NAMES)) {
[16:13:38.628]                   name <- added[[kk]]
[16:13:38.628]                   NAME <- NAMES[[kk]]
[16:13:38.628]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.628]                     next
[16:13:38.628]                   args[[name]] <- ""
[16:13:38.628]                 }
[16:13:38.628]                 NAMES <- toupper(removed)
[16:13:38.628]                 for (kk in seq_along(NAMES)) {
[16:13:38.628]                   name <- removed[[kk]]
[16:13:38.628]                   NAME <- NAMES[[kk]]
[16:13:38.628]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.628]                     next
[16:13:38.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:38.628]                 }
[16:13:38.628]                 if (length(args) > 0) 
[16:13:38.628]                   base::do.call(base::Sys.setenv, args = args)
[16:13:38.628]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:38.628]             }
[16:13:38.628]             else {
[16:13:38.628]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:38.628]             }
[16:13:38.628]             {
[16:13:38.628]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:38.628]                   0L) {
[16:13:38.628]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:38.628]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:38.628]                   base::options(opts)
[16:13:38.628]                 }
[16:13:38.628]                 {
[16:13:38.628]                   {
[16:13:38.628]                     NULL
[16:13:38.628]                     RNGkind("Mersenne-Twister")
[16:13:38.628]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:38.628]                       inherits = FALSE)
[16:13:38.628]                   }
[16:13:38.628]                   options(future.plan = NULL)
[16:13:38.628]                   if (is.na(NA_character_)) 
[16:13:38.628]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:38.628]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:38.628]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:38.628]                   {
[16:13:38.628]                     future <- SequentialFuture(..., envir = envir)
[16:13:38.628]                     if (!future$lazy) 
[16:13:38.628]                       future <- run(future)
[16:13:38.628]                     invisible(future)
[16:13:38.628]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:38.628]                 }
[16:13:38.628]             }
[16:13:38.628]         }
[16:13:38.628]     })
[16:13:38.628]     if (TRUE) {
[16:13:38.628]         base::sink(type = "output", split = FALSE)
[16:13:38.628]         if (TRUE) {
[16:13:38.628]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:38.628]         }
[16:13:38.628]         else {
[16:13:38.628]             ...future.result["stdout"] <- base::list(NULL)
[16:13:38.628]         }
[16:13:38.628]         base::close(...future.stdout)
[16:13:38.628]         ...future.stdout <- NULL
[16:13:38.628]     }
[16:13:38.628]     ...future.result$conditions <- ...future.conditions
[16:13:38.628]     ...future.result$finished <- base::Sys.time()
[16:13:38.628]     ...future.result
[16:13:38.628] }
[16:13:38.630] plan(): Setting new future strategy stack:
[16:13:38.630] List of future strategies:
[16:13:38.630] 1. sequential:
[16:13:38.630]    - args: function (..., envir = parent.frame())
[16:13:38.630]    - tweaked: FALSE
[16:13:38.630]    - call: NULL
[16:13:38.630] plan(): nbrOfWorkers() = 1
[16:13:38.631] plan(): Setting new future strategy stack:
[16:13:38.631] List of future strategies:
[16:13:38.631] 1. sequential:
[16:13:38.631]    - args: function (..., envir = parent.frame())
[16:13:38.631]    - tweaked: FALSE
[16:13:38.631]    - call: plan(strategy)
[16:13:38.632] plan(): nbrOfWorkers() = 1
[16:13:38.632] SequentialFuture started (and completed)
[16:13:38.632] - Launch lazy future ... done
[16:13:38.632] run() for ‘SequentialFuture’ ... done
[16:13:38.632] resolved() for ‘SequentialFuture’ ...
[16:13:38.632] - state: ‘finished’
[16:13:38.632] - run: TRUE
[16:13:38.632] - result: ‘FutureResult’
[16:13:38.632] resolved() for ‘SequentialFuture’ ... done
[16:13:38.633] Future #2
[16:13:38.633]  length: 1 (resolved future 2)
[16:13:38.633]  length: 0 (resolved future 3)
[16:13:38.633] resolve() on list ... DONE
[16:13:38.633] resolved() for ‘SequentialFuture’ ...
[16:13:38.633] - state: ‘finished’
[16:13:38.633] - run: TRUE
[16:13:38.633] - result: ‘FutureResult’
[16:13:38.633] resolved() for ‘SequentialFuture’ ... done
[16:13:38.633] resolved() for ‘SequentialFuture’ ...
[16:13:38.634] - state: ‘finished’
[16:13:38.634] - run: TRUE
[16:13:38.634] - result: ‘FutureResult’
[16:13:38.634] resolved() for ‘SequentialFuture’ ... done
[16:13:38.634] getGlobalsAndPackages() ...
[16:13:38.634] Searching for globals...
[16:13:38.634] 
[16:13:38.634] Searching for globals ... DONE
[16:13:38.634] - globals: [0] <none>
[16:13:38.635] getGlobalsAndPackages() ... DONE
[16:13:38.635] run() for ‘Future’ ...
[16:13:38.635] - state: ‘created’
[16:13:38.635] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:38.635] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:38.635] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:38.635]   - Field: ‘label’
[16:13:38.636]   - Field: ‘local’
[16:13:38.636]   - Field: ‘owner’
[16:13:38.636]   - Field: ‘envir’
[16:13:38.636]   - Field: ‘packages’
[16:13:38.636]   - Field: ‘gc’
[16:13:38.636]   - Field: ‘conditions’
[16:13:38.636]   - Field: ‘expr’
[16:13:38.636]   - Field: ‘uuid’
[16:13:38.636]   - Field: ‘seed’
[16:13:38.636]   - Field: ‘version’
[16:13:38.636]   - Field: ‘result’
[16:13:38.637]   - Field: ‘asynchronous’
[16:13:38.637]   - Field: ‘calls’
[16:13:38.637]   - Field: ‘globals’
[16:13:38.637]   - Field: ‘stdout’
[16:13:38.637]   - Field: ‘earlySignal’
[16:13:38.637]   - Field: ‘lazy’
[16:13:38.637]   - Field: ‘state’
[16:13:38.637] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:38.637] - Launch lazy future ...
[16:13:38.637] Packages needed by the future expression (n = 0): <none>
[16:13:38.638] Packages needed by future strategies (n = 0): <none>
[16:13:38.638] {
[16:13:38.638]     {
[16:13:38.638]         {
[16:13:38.638]             ...future.startTime <- base::Sys.time()
[16:13:38.638]             {
[16:13:38.638]                 {
[16:13:38.638]                   {
[16:13:38.638]                     base::local({
[16:13:38.638]                       has_future <- base::requireNamespace("future", 
[16:13:38.638]                         quietly = TRUE)
[16:13:38.638]                       if (has_future) {
[16:13:38.638]                         ns <- base::getNamespace("future")
[16:13:38.638]                         version <- ns[[".package"]][["version"]]
[16:13:38.638]                         if (is.null(version)) 
[16:13:38.638]                           version <- utils::packageVersion("future")
[16:13:38.638]                       }
[16:13:38.638]                       else {
[16:13:38.638]                         version <- NULL
[16:13:38.638]                       }
[16:13:38.638]                       if (!has_future || version < "1.8.0") {
[16:13:38.638]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:38.638]                           "", base::R.version$version.string), 
[16:13:38.638]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:38.638]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:38.638]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:38.638]                             "release", "version")], collapse = " "), 
[16:13:38.638]                           hostname = base::Sys.info()[["nodename"]])
[16:13:38.638]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:38.638]                           info)
[16:13:38.638]                         info <- base::paste(info, collapse = "; ")
[16:13:38.638]                         if (!has_future) {
[16:13:38.638]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:38.638]                             info)
[16:13:38.638]                         }
[16:13:38.638]                         else {
[16:13:38.638]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:38.638]                             info, version)
[16:13:38.638]                         }
[16:13:38.638]                         base::stop(msg)
[16:13:38.638]                       }
[16:13:38.638]                     })
[16:13:38.638]                   }
[16:13:38.638]                   options(future.plan = NULL)
[16:13:38.638]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:38.638]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:38.638]                 }
[16:13:38.638]                 ...future.workdir <- getwd()
[16:13:38.638]             }
[16:13:38.638]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:38.638]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:38.638]         }
[16:13:38.638]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:38.638]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:38.638]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:38.638]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:38.638]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:38.638]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:38.638]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:38.638]             base::names(...future.oldOptions))
[16:13:38.638]     }
[16:13:38.638]     if (FALSE) {
[16:13:38.638]     }
[16:13:38.638]     else {
[16:13:38.638]         if (TRUE) {
[16:13:38.638]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:38.638]                 open = "w")
[16:13:38.638]         }
[16:13:38.638]         else {
[16:13:38.638]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:38.638]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:38.638]         }
[16:13:38.638]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:38.638]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:38.638]             base::sink(type = "output", split = FALSE)
[16:13:38.638]             base::close(...future.stdout)
[16:13:38.638]         }, add = TRUE)
[16:13:38.638]     }
[16:13:38.638]     ...future.frame <- base::sys.nframe()
[16:13:38.638]     ...future.conditions <- base::list()
[16:13:38.638]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:38.638]     if (FALSE) {
[16:13:38.638]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:38.638]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:38.638]     }
[16:13:38.638]     ...future.result <- base::tryCatch({
[16:13:38.638]         base::withCallingHandlers({
[16:13:38.638]             ...future.value <- base::withVisible(base::local(1))
[16:13:38.638]             future::FutureResult(value = ...future.value$value, 
[16:13:38.638]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:38.638]                   ...future.rng), globalenv = if (FALSE) 
[16:13:38.638]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:38.638]                     ...future.globalenv.names))
[16:13:38.638]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:38.638]         }, condition = base::local({
[16:13:38.638]             c <- base::c
[16:13:38.638]             inherits <- base::inherits
[16:13:38.638]             invokeRestart <- base::invokeRestart
[16:13:38.638]             length <- base::length
[16:13:38.638]             list <- base::list
[16:13:38.638]             seq.int <- base::seq.int
[16:13:38.638]             signalCondition <- base::signalCondition
[16:13:38.638]             sys.calls <- base::sys.calls
[16:13:38.638]             `[[` <- base::`[[`
[16:13:38.638]             `+` <- base::`+`
[16:13:38.638]             `<<-` <- base::`<<-`
[16:13:38.638]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:38.638]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:38.638]                   3L)]
[16:13:38.638]             }
[16:13:38.638]             function(cond) {
[16:13:38.638]                 is_error <- inherits(cond, "error")
[16:13:38.638]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:38.638]                   NULL)
[16:13:38.638]                 if (is_error) {
[16:13:38.638]                   sessionInformation <- function() {
[16:13:38.638]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:38.638]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:38.638]                       search = base::search(), system = base::Sys.info())
[16:13:38.638]                   }
[16:13:38.638]                   ...future.conditions[[length(...future.conditions) + 
[16:13:38.638]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:38.638]                     cond$call), session = sessionInformation(), 
[16:13:38.638]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:38.638]                   signalCondition(cond)
[16:13:38.638]                 }
[16:13:38.638]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:38.638]                 "immediateCondition"))) {
[16:13:38.638]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:38.638]                   ...future.conditions[[length(...future.conditions) + 
[16:13:38.638]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:38.638]                   if (TRUE && !signal) {
[16:13:38.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:38.638]                     {
[16:13:38.638]                       inherits <- base::inherits
[16:13:38.638]                       invokeRestart <- base::invokeRestart
[16:13:38.638]                       is.null <- base::is.null
[16:13:38.638]                       muffled <- FALSE
[16:13:38.638]                       if (inherits(cond, "message")) {
[16:13:38.638]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:38.638]                         if (muffled) 
[16:13:38.638]                           invokeRestart("muffleMessage")
[16:13:38.638]                       }
[16:13:38.638]                       else if (inherits(cond, "warning")) {
[16:13:38.638]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:38.638]                         if (muffled) 
[16:13:38.638]                           invokeRestart("muffleWarning")
[16:13:38.638]                       }
[16:13:38.638]                       else if (inherits(cond, "condition")) {
[16:13:38.638]                         if (!is.null(pattern)) {
[16:13:38.638]                           computeRestarts <- base::computeRestarts
[16:13:38.638]                           grepl <- base::grepl
[16:13:38.638]                           restarts <- computeRestarts(cond)
[16:13:38.638]                           for (restart in restarts) {
[16:13:38.638]                             name <- restart$name
[16:13:38.638]                             if (is.null(name)) 
[16:13:38.638]                               next
[16:13:38.638]                             if (!grepl(pattern, name)) 
[16:13:38.638]                               next
[16:13:38.638]                             invokeRestart(restart)
[16:13:38.638]                             muffled <- TRUE
[16:13:38.638]                             break
[16:13:38.638]                           }
[16:13:38.638]                         }
[16:13:38.638]                       }
[16:13:38.638]                       invisible(muffled)
[16:13:38.638]                     }
[16:13:38.638]                     muffleCondition(cond, pattern = "^muffle")
[16:13:38.638]                   }
[16:13:38.638]                 }
[16:13:38.638]                 else {
[16:13:38.638]                   if (TRUE) {
[16:13:38.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:38.638]                     {
[16:13:38.638]                       inherits <- base::inherits
[16:13:38.638]                       invokeRestart <- base::invokeRestart
[16:13:38.638]                       is.null <- base::is.null
[16:13:38.638]                       muffled <- FALSE
[16:13:38.638]                       if (inherits(cond, "message")) {
[16:13:38.638]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:38.638]                         if (muffled) 
[16:13:38.638]                           invokeRestart("muffleMessage")
[16:13:38.638]                       }
[16:13:38.638]                       else if (inherits(cond, "warning")) {
[16:13:38.638]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:38.638]                         if (muffled) 
[16:13:38.638]                           invokeRestart("muffleWarning")
[16:13:38.638]                       }
[16:13:38.638]                       else if (inherits(cond, "condition")) {
[16:13:38.638]                         if (!is.null(pattern)) {
[16:13:38.638]                           computeRestarts <- base::computeRestarts
[16:13:38.638]                           grepl <- base::grepl
[16:13:38.638]                           restarts <- computeRestarts(cond)
[16:13:38.638]                           for (restart in restarts) {
[16:13:38.638]                             name <- restart$name
[16:13:38.638]                             if (is.null(name)) 
[16:13:38.638]                               next
[16:13:38.638]                             if (!grepl(pattern, name)) 
[16:13:38.638]                               next
[16:13:38.638]                             invokeRestart(restart)
[16:13:38.638]                             muffled <- TRUE
[16:13:38.638]                             break
[16:13:38.638]                           }
[16:13:38.638]                         }
[16:13:38.638]                       }
[16:13:38.638]                       invisible(muffled)
[16:13:38.638]                     }
[16:13:38.638]                     muffleCondition(cond, pattern = "^muffle")
[16:13:38.638]                   }
[16:13:38.638]                 }
[16:13:38.638]             }
[16:13:38.638]         }))
[16:13:38.638]     }, error = function(ex) {
[16:13:38.638]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:38.638]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:38.638]                 ...future.rng), started = ...future.startTime, 
[16:13:38.638]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:38.638]             version = "1.8"), class = "FutureResult")
[16:13:38.638]     }, finally = {
[16:13:38.638]         if (!identical(...future.workdir, getwd())) 
[16:13:38.638]             setwd(...future.workdir)
[16:13:38.638]         {
[16:13:38.638]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:38.638]                 ...future.oldOptions$nwarnings <- NULL
[16:13:38.638]             }
[16:13:38.638]             base::options(...future.oldOptions)
[16:13:38.638]             if (.Platform$OS.type == "windows") {
[16:13:38.638]                 old_names <- names(...future.oldEnvVars)
[16:13:38.638]                 envs <- base::Sys.getenv()
[16:13:38.638]                 names <- names(envs)
[16:13:38.638]                 common <- intersect(names, old_names)
[16:13:38.638]                 added <- setdiff(names, old_names)
[16:13:38.638]                 removed <- setdiff(old_names, names)
[16:13:38.638]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:38.638]                   envs[common]]
[16:13:38.638]                 NAMES <- toupper(changed)
[16:13:38.638]                 args <- list()
[16:13:38.638]                 for (kk in seq_along(NAMES)) {
[16:13:38.638]                   name <- changed[[kk]]
[16:13:38.638]                   NAME <- NAMES[[kk]]
[16:13:38.638]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.638]                     next
[16:13:38.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:38.638]                 }
[16:13:38.638]                 NAMES <- toupper(added)
[16:13:38.638]                 for (kk in seq_along(NAMES)) {
[16:13:38.638]                   name <- added[[kk]]
[16:13:38.638]                   NAME <- NAMES[[kk]]
[16:13:38.638]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.638]                     next
[16:13:38.638]                   args[[name]] <- ""
[16:13:38.638]                 }
[16:13:38.638]                 NAMES <- toupper(removed)
[16:13:38.638]                 for (kk in seq_along(NAMES)) {
[16:13:38.638]                   name <- removed[[kk]]
[16:13:38.638]                   NAME <- NAMES[[kk]]
[16:13:38.638]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.638]                     next
[16:13:38.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:38.638]                 }
[16:13:38.638]                 if (length(args) > 0) 
[16:13:38.638]                   base::do.call(base::Sys.setenv, args = args)
[16:13:38.638]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:38.638]             }
[16:13:38.638]             else {
[16:13:38.638]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:38.638]             }
[16:13:38.638]             {
[16:13:38.638]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:38.638]                   0L) {
[16:13:38.638]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:38.638]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:38.638]                   base::options(opts)
[16:13:38.638]                 }
[16:13:38.638]                 {
[16:13:38.638]                   {
[16:13:38.638]                     NULL
[16:13:38.638]                     RNGkind("Mersenne-Twister")
[16:13:38.638]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:38.638]                       inherits = FALSE)
[16:13:38.638]                   }
[16:13:38.638]                   options(future.plan = NULL)
[16:13:38.638]                   if (is.na(NA_character_)) 
[16:13:38.638]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:38.638]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:38.638]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:38.638]                   {
[16:13:38.638]                     future <- SequentialFuture(..., envir = envir)
[16:13:38.638]                     if (!future$lazy) 
[16:13:38.638]                       future <- run(future)
[16:13:38.638]                     invisible(future)
[16:13:38.638]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:38.638]                 }
[16:13:38.638]             }
[16:13:38.638]         }
[16:13:38.638]     })
[16:13:38.638]     if (TRUE) {
[16:13:38.638]         base::sink(type = "output", split = FALSE)
[16:13:38.638]         if (TRUE) {
[16:13:38.638]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:38.638]         }
[16:13:38.638]         else {
[16:13:38.638]             ...future.result["stdout"] <- base::list(NULL)
[16:13:38.638]         }
[16:13:38.638]         base::close(...future.stdout)
[16:13:38.638]         ...future.stdout <- NULL
[16:13:38.638]     }
[16:13:38.638]     ...future.result$conditions <- ...future.conditions
[16:13:38.638]     ...future.result$finished <- base::Sys.time()
[16:13:38.638]     ...future.result
[16:13:38.638] }
[16:13:38.640] plan(): Setting new future strategy stack:
[16:13:38.640] List of future strategies:
[16:13:38.640] 1. sequential:
[16:13:38.640]    - args: function (..., envir = parent.frame())
[16:13:38.640]    - tweaked: FALSE
[16:13:38.640]    - call: NULL
[16:13:38.640] plan(): nbrOfWorkers() = 1
[16:13:38.641] plan(): Setting new future strategy stack:
[16:13:38.641] List of future strategies:
[16:13:38.641] 1. sequential:
[16:13:38.641]    - args: function (..., envir = parent.frame())
[16:13:38.641]    - tweaked: FALSE
[16:13:38.641]    - call: plan(strategy)
[16:13:38.641] plan(): nbrOfWorkers() = 1
[16:13:38.641] SequentialFuture started (and completed)
[16:13:38.642] - Launch lazy future ... done
[16:13:38.642] run() for ‘SequentialFuture’ ... done
[16:13:38.642] getGlobalsAndPackages() ...
[16:13:38.642] Searching for globals...
[16:13:38.647] - globals found: [2] ‘{’, ‘Sys.sleep’
[16:13:38.647] Searching for globals ... DONE
[16:13:38.647] Resolving globals: FALSE
[16:13:38.647] 
[16:13:38.647] 
[16:13:38.648] getGlobalsAndPackages() ... DONE
[16:13:38.648] run() for ‘Future’ ...
[16:13:38.648] - state: ‘created’
[16:13:38.648] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:38.648] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:38.648] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:38.648]   - Field: ‘label’
[16:13:38.649]   - Field: ‘local’
[16:13:38.649]   - Field: ‘owner’
[16:13:38.649]   - Field: ‘envir’
[16:13:38.649]   - Field: ‘packages’
[16:13:38.649]   - Field: ‘gc’
[16:13:38.649]   - Field: ‘conditions’
[16:13:38.649]   - Field: ‘expr’
[16:13:38.649]   - Field: ‘uuid’
[16:13:38.649]   - Field: ‘seed’
[16:13:38.651]   - Field: ‘version’
[16:13:38.651]   - Field: ‘result’
[16:13:38.651]   - Field: ‘asynchronous’
[16:13:38.652]   - Field: ‘calls’
[16:13:38.652]   - Field: ‘globals’
[16:13:38.652]   - Field: ‘stdout’
[16:13:38.652]   - Field: ‘earlySignal’
[16:13:38.652]   - Field: ‘lazy’
[16:13:38.652]   - Field: ‘state’
[16:13:38.652] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:38.652] - Launch lazy future ...
[16:13:38.652] Packages needed by the future expression (n = 0): <none>
[16:13:38.653] Packages needed by future strategies (n = 0): <none>
[16:13:38.653] {
[16:13:38.653]     {
[16:13:38.653]         {
[16:13:38.653]             ...future.startTime <- base::Sys.time()
[16:13:38.653]             {
[16:13:38.653]                 {
[16:13:38.653]                   {
[16:13:38.653]                     base::local({
[16:13:38.653]                       has_future <- base::requireNamespace("future", 
[16:13:38.653]                         quietly = TRUE)
[16:13:38.653]                       if (has_future) {
[16:13:38.653]                         ns <- base::getNamespace("future")
[16:13:38.653]                         version <- ns[[".package"]][["version"]]
[16:13:38.653]                         if (is.null(version)) 
[16:13:38.653]                           version <- utils::packageVersion("future")
[16:13:38.653]                       }
[16:13:38.653]                       else {
[16:13:38.653]                         version <- NULL
[16:13:38.653]                       }
[16:13:38.653]                       if (!has_future || version < "1.8.0") {
[16:13:38.653]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:38.653]                           "", base::R.version$version.string), 
[16:13:38.653]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:38.653]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:38.653]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:38.653]                             "release", "version")], collapse = " "), 
[16:13:38.653]                           hostname = base::Sys.info()[["nodename"]])
[16:13:38.653]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:38.653]                           info)
[16:13:38.653]                         info <- base::paste(info, collapse = "; ")
[16:13:38.653]                         if (!has_future) {
[16:13:38.653]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:38.653]                             info)
[16:13:38.653]                         }
[16:13:38.653]                         else {
[16:13:38.653]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:38.653]                             info, version)
[16:13:38.653]                         }
[16:13:38.653]                         base::stop(msg)
[16:13:38.653]                       }
[16:13:38.653]                     })
[16:13:38.653]                   }
[16:13:38.653]                   options(future.plan = NULL)
[16:13:38.653]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:38.653]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:38.653]                 }
[16:13:38.653]                 ...future.workdir <- getwd()
[16:13:38.653]             }
[16:13:38.653]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:38.653]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:38.653]         }
[16:13:38.653]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:38.653]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:38.653]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:38.653]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:38.653]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:38.653]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:38.653]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:38.653]             base::names(...future.oldOptions))
[16:13:38.653]     }
[16:13:38.653]     if (FALSE) {
[16:13:38.653]     }
[16:13:38.653]     else {
[16:13:38.653]         if (TRUE) {
[16:13:38.653]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:38.653]                 open = "w")
[16:13:38.653]         }
[16:13:38.653]         else {
[16:13:38.653]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:38.653]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:38.653]         }
[16:13:38.653]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:38.653]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:38.653]             base::sink(type = "output", split = FALSE)
[16:13:38.653]             base::close(...future.stdout)
[16:13:38.653]         }, add = TRUE)
[16:13:38.653]     }
[16:13:38.653]     ...future.frame <- base::sys.nframe()
[16:13:38.653]     ...future.conditions <- base::list()
[16:13:38.653]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:38.653]     if (FALSE) {
[16:13:38.653]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:38.653]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:38.653]     }
[16:13:38.653]     ...future.result <- base::tryCatch({
[16:13:38.653]         base::withCallingHandlers({
[16:13:38.653]             ...future.value <- base::withVisible(base::local({
[16:13:38.653]                 Sys.sleep(0.5)
[16:13:38.653]                 2
[16:13:38.653]             }))
[16:13:38.653]             future::FutureResult(value = ...future.value$value, 
[16:13:38.653]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:38.653]                   ...future.rng), globalenv = if (FALSE) 
[16:13:38.653]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:38.653]                     ...future.globalenv.names))
[16:13:38.653]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:38.653]         }, condition = base::local({
[16:13:38.653]             c <- base::c
[16:13:38.653]             inherits <- base::inherits
[16:13:38.653]             invokeRestart <- base::invokeRestart
[16:13:38.653]             length <- base::length
[16:13:38.653]             list <- base::list
[16:13:38.653]             seq.int <- base::seq.int
[16:13:38.653]             signalCondition <- base::signalCondition
[16:13:38.653]             sys.calls <- base::sys.calls
[16:13:38.653]             `[[` <- base::`[[`
[16:13:38.653]             `+` <- base::`+`
[16:13:38.653]             `<<-` <- base::`<<-`
[16:13:38.653]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:38.653]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:38.653]                   3L)]
[16:13:38.653]             }
[16:13:38.653]             function(cond) {
[16:13:38.653]                 is_error <- inherits(cond, "error")
[16:13:38.653]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:38.653]                   NULL)
[16:13:38.653]                 if (is_error) {
[16:13:38.653]                   sessionInformation <- function() {
[16:13:38.653]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:38.653]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:38.653]                       search = base::search(), system = base::Sys.info())
[16:13:38.653]                   }
[16:13:38.653]                   ...future.conditions[[length(...future.conditions) + 
[16:13:38.653]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:38.653]                     cond$call), session = sessionInformation(), 
[16:13:38.653]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:38.653]                   signalCondition(cond)
[16:13:38.653]                 }
[16:13:38.653]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:38.653]                 "immediateCondition"))) {
[16:13:38.653]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:38.653]                   ...future.conditions[[length(...future.conditions) + 
[16:13:38.653]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:38.653]                   if (TRUE && !signal) {
[16:13:38.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:38.653]                     {
[16:13:38.653]                       inherits <- base::inherits
[16:13:38.653]                       invokeRestart <- base::invokeRestart
[16:13:38.653]                       is.null <- base::is.null
[16:13:38.653]                       muffled <- FALSE
[16:13:38.653]                       if (inherits(cond, "message")) {
[16:13:38.653]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:38.653]                         if (muffled) 
[16:13:38.653]                           invokeRestart("muffleMessage")
[16:13:38.653]                       }
[16:13:38.653]                       else if (inherits(cond, "warning")) {
[16:13:38.653]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:38.653]                         if (muffled) 
[16:13:38.653]                           invokeRestart("muffleWarning")
[16:13:38.653]                       }
[16:13:38.653]                       else if (inherits(cond, "condition")) {
[16:13:38.653]                         if (!is.null(pattern)) {
[16:13:38.653]                           computeRestarts <- base::computeRestarts
[16:13:38.653]                           grepl <- base::grepl
[16:13:38.653]                           restarts <- computeRestarts(cond)
[16:13:38.653]                           for (restart in restarts) {
[16:13:38.653]                             name <- restart$name
[16:13:38.653]                             if (is.null(name)) 
[16:13:38.653]                               next
[16:13:38.653]                             if (!grepl(pattern, name)) 
[16:13:38.653]                               next
[16:13:38.653]                             invokeRestart(restart)
[16:13:38.653]                             muffled <- TRUE
[16:13:38.653]                             break
[16:13:38.653]                           }
[16:13:38.653]                         }
[16:13:38.653]                       }
[16:13:38.653]                       invisible(muffled)
[16:13:38.653]                     }
[16:13:38.653]                     muffleCondition(cond, pattern = "^muffle")
[16:13:38.653]                   }
[16:13:38.653]                 }
[16:13:38.653]                 else {
[16:13:38.653]                   if (TRUE) {
[16:13:38.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:38.653]                     {
[16:13:38.653]                       inherits <- base::inherits
[16:13:38.653]                       invokeRestart <- base::invokeRestart
[16:13:38.653]                       is.null <- base::is.null
[16:13:38.653]                       muffled <- FALSE
[16:13:38.653]                       if (inherits(cond, "message")) {
[16:13:38.653]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:38.653]                         if (muffled) 
[16:13:38.653]                           invokeRestart("muffleMessage")
[16:13:38.653]                       }
[16:13:38.653]                       else if (inherits(cond, "warning")) {
[16:13:38.653]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:38.653]                         if (muffled) 
[16:13:38.653]                           invokeRestart("muffleWarning")
[16:13:38.653]                       }
[16:13:38.653]                       else if (inherits(cond, "condition")) {
[16:13:38.653]                         if (!is.null(pattern)) {
[16:13:38.653]                           computeRestarts <- base::computeRestarts
[16:13:38.653]                           grepl <- base::grepl
[16:13:38.653]                           restarts <- computeRestarts(cond)
[16:13:38.653]                           for (restart in restarts) {
[16:13:38.653]                             name <- restart$name
[16:13:38.653]                             if (is.null(name)) 
[16:13:38.653]                               next
[16:13:38.653]                             if (!grepl(pattern, name)) 
[16:13:38.653]                               next
[16:13:38.653]                             invokeRestart(restart)
[16:13:38.653]                             muffled <- TRUE
[16:13:38.653]                             break
[16:13:38.653]                           }
[16:13:38.653]                         }
[16:13:38.653]                       }
[16:13:38.653]                       invisible(muffled)
[16:13:38.653]                     }
[16:13:38.653]                     muffleCondition(cond, pattern = "^muffle")
[16:13:38.653]                   }
[16:13:38.653]                 }
[16:13:38.653]             }
[16:13:38.653]         }))
[16:13:38.653]     }, error = function(ex) {
[16:13:38.653]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:38.653]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:38.653]                 ...future.rng), started = ...future.startTime, 
[16:13:38.653]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:38.653]             version = "1.8"), class = "FutureResult")
[16:13:38.653]     }, finally = {
[16:13:38.653]         if (!identical(...future.workdir, getwd())) 
[16:13:38.653]             setwd(...future.workdir)
[16:13:38.653]         {
[16:13:38.653]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:38.653]                 ...future.oldOptions$nwarnings <- NULL
[16:13:38.653]             }
[16:13:38.653]             base::options(...future.oldOptions)
[16:13:38.653]             if (.Platform$OS.type == "windows") {
[16:13:38.653]                 old_names <- names(...future.oldEnvVars)
[16:13:38.653]                 envs <- base::Sys.getenv()
[16:13:38.653]                 names <- names(envs)
[16:13:38.653]                 common <- intersect(names, old_names)
[16:13:38.653]                 added <- setdiff(names, old_names)
[16:13:38.653]                 removed <- setdiff(old_names, names)
[16:13:38.653]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:38.653]                   envs[common]]
[16:13:38.653]                 NAMES <- toupper(changed)
[16:13:38.653]                 args <- list()
[16:13:38.653]                 for (kk in seq_along(NAMES)) {
[16:13:38.653]                   name <- changed[[kk]]
[16:13:38.653]                   NAME <- NAMES[[kk]]
[16:13:38.653]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.653]                     next
[16:13:38.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:38.653]                 }
[16:13:38.653]                 NAMES <- toupper(added)
[16:13:38.653]                 for (kk in seq_along(NAMES)) {
[16:13:38.653]                   name <- added[[kk]]
[16:13:38.653]                   NAME <- NAMES[[kk]]
[16:13:38.653]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.653]                     next
[16:13:38.653]                   args[[name]] <- ""
[16:13:38.653]                 }
[16:13:38.653]                 NAMES <- toupper(removed)
[16:13:38.653]                 for (kk in seq_along(NAMES)) {
[16:13:38.653]                   name <- removed[[kk]]
[16:13:38.653]                   NAME <- NAMES[[kk]]
[16:13:38.653]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:38.653]                     next
[16:13:38.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:38.653]                 }
[16:13:38.653]                 if (length(args) > 0) 
[16:13:38.653]                   base::do.call(base::Sys.setenv, args = args)
[16:13:38.653]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:38.653]             }
[16:13:38.653]             else {
[16:13:38.653]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:38.653]             }
[16:13:38.653]             {
[16:13:38.653]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:38.653]                   0L) {
[16:13:38.653]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:38.653]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:38.653]                   base::options(opts)
[16:13:38.653]                 }
[16:13:38.653]                 {
[16:13:38.653]                   {
[16:13:38.653]                     NULL
[16:13:38.653]                     RNGkind("Mersenne-Twister")
[16:13:38.653]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:38.653]                       inherits = FALSE)
[16:13:38.653]                   }
[16:13:38.653]                   options(future.plan = NULL)
[16:13:38.653]                   if (is.na(NA_character_)) 
[16:13:38.653]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:38.653]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:38.653]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:38.653]                   {
[16:13:38.653]                     future <- SequentialFuture(..., envir = envir)
[16:13:38.653]                     if (!future$lazy) 
[16:13:38.653]                       future <- run(future)
[16:13:38.653]                     invisible(future)
[16:13:38.653]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:38.653]                 }
[16:13:38.653]             }
[16:13:38.653]         }
[16:13:38.653]     })
[16:13:38.653]     if (TRUE) {
[16:13:38.653]         base::sink(type = "output", split = FALSE)
[16:13:38.653]         if (TRUE) {
[16:13:38.653]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:38.653]         }
[16:13:38.653]         else {
[16:13:38.653]             ...future.result["stdout"] <- base::list(NULL)
[16:13:38.653]         }
[16:13:38.653]         base::close(...future.stdout)
[16:13:38.653]         ...future.stdout <- NULL
[16:13:38.653]     }
[16:13:38.653]     ...future.result$conditions <- ...future.conditions
[16:13:38.653]     ...future.result$finished <- base::Sys.time()
[16:13:38.653]     ...future.result
[16:13:38.653] }
[16:13:38.655] plan(): Setting new future strategy stack:
[16:13:38.655] List of future strategies:
[16:13:38.655] 1. sequential:
[16:13:38.655]    - args: function (..., envir = parent.frame())
[16:13:38.655]    - tweaked: FALSE
[16:13:38.655]    - call: NULL
[16:13:38.655] plan(): nbrOfWorkers() = 1
[16:13:39.157] plan(): Setting new future strategy stack:
[16:13:39.157] List of future strategies:
[16:13:39.157] 1. sequential:
[16:13:39.157]    - args: function (..., envir = parent.frame())
[16:13:39.157]    - tweaked: FALSE
[16:13:39.157]    - call: plan(strategy)
[16:13:39.158] plan(): nbrOfWorkers() = 1
[16:13:39.158] SequentialFuture started (and completed)
[16:13:39.158] - Launch lazy future ... done
[16:13:39.158] run() for ‘SequentialFuture’ ... done
[16:13:39.159] resolve() on list ...
[16:13:39.159]  recursive: 0
[16:13:39.159]  length: 1
[16:13:39.159] 
[16:13:39.159] resolved() for ‘SequentialFuture’ ...
[16:13:39.159] - state: ‘finished’
[16:13:39.159] - run: TRUE
[16:13:39.159] - result: ‘FutureResult’
[16:13:39.159] resolved() for ‘SequentialFuture’ ... done
[16:13:39.159] Future #1
[16:13:39.160]  length: 0 (resolved future 1)
[16:13:39.160] resolve() on list ... DONE
[16:13:39.160] resolved() for ‘SequentialFuture’ ...
[16:13:39.160] - state: ‘finished’
[16:13:39.160] - run: TRUE
[16:13:39.160] - result: ‘FutureResult’
[16:13:39.160] resolved() for ‘SequentialFuture’ ... done
[16:13:39.160] resolve() on list ...
[16:13:39.160]  recursive: 0
[16:13:39.161]  length: 1
[16:13:39.161] 
[16:13:39.161] resolved() for ‘SequentialFuture’ ...
[16:13:39.161] - state: ‘finished’
[16:13:39.161] - run: TRUE
[16:13:39.161] - result: ‘FutureResult’
[16:13:39.161] resolved() for ‘SequentialFuture’ ... done
[16:13:39.161] Future #1
[16:13:39.161]  length: 0 (resolved future 1)
[16:13:39.161] resolve() on list ... DONE
[16:13:39.161] resolved() for ‘SequentialFuture’ ...
[16:13:39.162] - state: ‘finished’
[16:13:39.162] - run: TRUE
[16:13:39.162] - result: ‘FutureResult’
[16:13:39.162] resolved() for ‘SequentialFuture’ ... done
[16:13:39.162] resolve() on list ...
[16:13:39.162]  recursive: 0
[16:13:39.162]  length: 1
[16:13:39.162] 
[16:13:39.162]  length: 0 (resolved future 1)
[16:13:39.162] resolve() on list ... DONE
[16:13:39.163] resolve() on list ...
[16:13:39.163]  recursive: 0
[16:13:39.163]  length: 4
[16:13:39.163] 
[16:13:39.163] resolved() for ‘SequentialFuture’ ...
[16:13:39.163] - state: ‘finished’
[16:13:39.163] - run: TRUE
[16:13:39.163] - result: ‘FutureResult’
[16:13:39.163] resolved() for ‘SequentialFuture’ ... done
[16:13:39.163] Future #1
[16:13:39.164]  length: 3 (resolved future 1)
[16:13:39.164] resolved() for ‘SequentialFuture’ ...
[16:13:39.164] - state: ‘finished’
[16:13:39.164] - run: TRUE
[16:13:39.164] - result: ‘FutureResult’
[16:13:39.164] resolved() for ‘SequentialFuture’ ... done
[16:13:39.164] Future #2
[16:13:39.164]  length: 2 (resolved future 2)
[16:13:39.164]  length: 1 (resolved future 3)
[16:13:39.164]  length: 0 (resolved future 4)
[16:13:39.165] resolve() on list ... DONE
[16:13:39.165] resolve() on list ...
[16:13:39.165]  recursive: 0
[16:13:39.165]  length: 4
[16:13:39.165] 
[16:13:39.165] resolved() for ‘SequentialFuture’ ...
[16:13:39.165] - state: ‘finished’
[16:13:39.165] - run: TRUE
[16:13:39.165] - result: ‘FutureResult’
[16:13:39.165] resolved() for ‘SequentialFuture’ ... done
[16:13:39.166] Future #1
[16:13:39.166]  length: 3 (resolved future 1)
[16:13:39.166] resolved() for ‘SequentialFuture’ ...
[16:13:39.166] - state: ‘finished’
[16:13:39.166] - run: TRUE
[16:13:39.166] - result: ‘FutureResult’
[16:13:39.166] resolved() for ‘SequentialFuture’ ... done
[16:13:39.166] Future #2
[16:13:39.166]  length: 2 (resolved future 2)
[16:13:39.167]  length: 1 (resolved future 3)
[16:13:39.167]  length: 0 (resolved future 4)
[16:13:39.167] resolve() on list ... DONE
[16:13:39.167] resolve() on list ...
[16:13:39.167]  recursive: 0
[16:13:39.168]  length: 1
[16:13:39.168] 
[16:13:39.168]  length: 0 (resolved future 1)
[16:13:39.168] resolve() on list ... DONE
[16:13:39.168] getGlobalsAndPackages() ...
[16:13:39.168] Searching for globals...
[16:13:39.170] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:13:39.170] Searching for globals ... DONE
[16:13:39.170] Resolving globals: FALSE
[16:13:39.171] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:39.171] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:13:39.171] - globals: [1] ‘kk’
[16:13:39.171] 
[16:13:39.171] getGlobalsAndPackages() ... DONE
[16:13:39.172] run() for ‘Future’ ...
[16:13:39.172] - state: ‘created’
[16:13:39.172] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:39.172] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:39.172] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:39.172]   - Field: ‘label’
[16:13:39.173]   - Field: ‘local’
[16:13:39.173]   - Field: ‘owner’
[16:13:39.173]   - Field: ‘envir’
[16:13:39.173]   - Field: ‘packages’
[16:13:39.173]   - Field: ‘gc’
[16:13:39.173]   - Field: ‘conditions’
[16:13:39.173]   - Field: ‘expr’
[16:13:39.173]   - Field: ‘uuid’
[16:13:39.173]   - Field: ‘seed’
[16:13:39.173]   - Field: ‘version’
[16:13:39.173]   - Field: ‘result’
[16:13:39.174]   - Field: ‘asynchronous’
[16:13:39.174]   - Field: ‘calls’
[16:13:39.174]   - Field: ‘globals’
[16:13:39.174]   - Field: ‘stdout’
[16:13:39.174]   - Field: ‘earlySignal’
[16:13:39.174]   - Field: ‘lazy’
[16:13:39.174]   - Field: ‘state’
[16:13:39.174] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:39.174] - Launch lazy future ...
[16:13:39.174] Packages needed by the future expression (n = 0): <none>
[16:13:39.175] Packages needed by future strategies (n = 0): <none>
[16:13:39.175] {
[16:13:39.175]     {
[16:13:39.175]         {
[16:13:39.175]             ...future.startTime <- base::Sys.time()
[16:13:39.175]             {
[16:13:39.175]                 {
[16:13:39.175]                   {
[16:13:39.175]                     base::local({
[16:13:39.175]                       has_future <- base::requireNamespace("future", 
[16:13:39.175]                         quietly = TRUE)
[16:13:39.175]                       if (has_future) {
[16:13:39.175]                         ns <- base::getNamespace("future")
[16:13:39.175]                         version <- ns[[".package"]][["version"]]
[16:13:39.175]                         if (is.null(version)) 
[16:13:39.175]                           version <- utils::packageVersion("future")
[16:13:39.175]                       }
[16:13:39.175]                       else {
[16:13:39.175]                         version <- NULL
[16:13:39.175]                       }
[16:13:39.175]                       if (!has_future || version < "1.8.0") {
[16:13:39.175]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:39.175]                           "", base::R.version$version.string), 
[16:13:39.175]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:39.175]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:39.175]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:39.175]                             "release", "version")], collapse = " "), 
[16:13:39.175]                           hostname = base::Sys.info()[["nodename"]])
[16:13:39.175]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:39.175]                           info)
[16:13:39.175]                         info <- base::paste(info, collapse = "; ")
[16:13:39.175]                         if (!has_future) {
[16:13:39.175]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:39.175]                             info)
[16:13:39.175]                         }
[16:13:39.175]                         else {
[16:13:39.175]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:39.175]                             info, version)
[16:13:39.175]                         }
[16:13:39.175]                         base::stop(msg)
[16:13:39.175]                       }
[16:13:39.175]                     })
[16:13:39.175]                   }
[16:13:39.175]                   options(future.plan = NULL)
[16:13:39.175]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.175]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:39.175]                 }
[16:13:39.175]                 ...future.workdir <- getwd()
[16:13:39.175]             }
[16:13:39.175]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:39.175]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:39.175]         }
[16:13:39.175]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:39.175]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:39.175]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:39.175]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:39.175]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:39.175]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:39.175]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:39.175]             base::names(...future.oldOptions))
[16:13:39.175]     }
[16:13:39.175]     if (FALSE) {
[16:13:39.175]     }
[16:13:39.175]     else {
[16:13:39.175]         if (TRUE) {
[16:13:39.175]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:39.175]                 open = "w")
[16:13:39.175]         }
[16:13:39.175]         else {
[16:13:39.175]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:39.175]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:39.175]         }
[16:13:39.175]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:39.175]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:39.175]             base::sink(type = "output", split = FALSE)
[16:13:39.175]             base::close(...future.stdout)
[16:13:39.175]         }, add = TRUE)
[16:13:39.175]     }
[16:13:39.175]     ...future.frame <- base::sys.nframe()
[16:13:39.175]     ...future.conditions <- base::list()
[16:13:39.175]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:39.175]     if (FALSE) {
[16:13:39.175]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:39.175]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:39.175]     }
[16:13:39.175]     ...future.result <- base::tryCatch({
[16:13:39.175]         base::withCallingHandlers({
[16:13:39.175]             ...future.value <- base::withVisible(base::local({
[16:13:39.175]                 Sys.sleep(0.1)
[16:13:39.175]                 kk
[16:13:39.175]             }))
[16:13:39.175]             future::FutureResult(value = ...future.value$value, 
[16:13:39.175]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.175]                   ...future.rng), globalenv = if (FALSE) 
[16:13:39.175]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:39.175]                     ...future.globalenv.names))
[16:13:39.175]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:39.175]         }, condition = base::local({
[16:13:39.175]             c <- base::c
[16:13:39.175]             inherits <- base::inherits
[16:13:39.175]             invokeRestart <- base::invokeRestart
[16:13:39.175]             length <- base::length
[16:13:39.175]             list <- base::list
[16:13:39.175]             seq.int <- base::seq.int
[16:13:39.175]             signalCondition <- base::signalCondition
[16:13:39.175]             sys.calls <- base::sys.calls
[16:13:39.175]             `[[` <- base::`[[`
[16:13:39.175]             `+` <- base::`+`
[16:13:39.175]             `<<-` <- base::`<<-`
[16:13:39.175]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:39.175]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:39.175]                   3L)]
[16:13:39.175]             }
[16:13:39.175]             function(cond) {
[16:13:39.175]                 is_error <- inherits(cond, "error")
[16:13:39.175]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:39.175]                   NULL)
[16:13:39.175]                 if (is_error) {
[16:13:39.175]                   sessionInformation <- function() {
[16:13:39.175]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:39.175]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:39.175]                       search = base::search(), system = base::Sys.info())
[16:13:39.175]                   }
[16:13:39.175]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.175]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:39.175]                     cond$call), session = sessionInformation(), 
[16:13:39.175]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:39.175]                   signalCondition(cond)
[16:13:39.175]                 }
[16:13:39.175]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:39.175]                 "immediateCondition"))) {
[16:13:39.175]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:39.175]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.175]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:39.175]                   if (TRUE && !signal) {
[16:13:39.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.175]                     {
[16:13:39.175]                       inherits <- base::inherits
[16:13:39.175]                       invokeRestart <- base::invokeRestart
[16:13:39.175]                       is.null <- base::is.null
[16:13:39.175]                       muffled <- FALSE
[16:13:39.175]                       if (inherits(cond, "message")) {
[16:13:39.175]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.175]                         if (muffled) 
[16:13:39.175]                           invokeRestart("muffleMessage")
[16:13:39.175]                       }
[16:13:39.175]                       else if (inherits(cond, "warning")) {
[16:13:39.175]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.175]                         if (muffled) 
[16:13:39.175]                           invokeRestart("muffleWarning")
[16:13:39.175]                       }
[16:13:39.175]                       else if (inherits(cond, "condition")) {
[16:13:39.175]                         if (!is.null(pattern)) {
[16:13:39.175]                           computeRestarts <- base::computeRestarts
[16:13:39.175]                           grepl <- base::grepl
[16:13:39.175]                           restarts <- computeRestarts(cond)
[16:13:39.175]                           for (restart in restarts) {
[16:13:39.175]                             name <- restart$name
[16:13:39.175]                             if (is.null(name)) 
[16:13:39.175]                               next
[16:13:39.175]                             if (!grepl(pattern, name)) 
[16:13:39.175]                               next
[16:13:39.175]                             invokeRestart(restart)
[16:13:39.175]                             muffled <- TRUE
[16:13:39.175]                             break
[16:13:39.175]                           }
[16:13:39.175]                         }
[16:13:39.175]                       }
[16:13:39.175]                       invisible(muffled)
[16:13:39.175]                     }
[16:13:39.175]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.175]                   }
[16:13:39.175]                 }
[16:13:39.175]                 else {
[16:13:39.175]                   if (TRUE) {
[16:13:39.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.175]                     {
[16:13:39.175]                       inherits <- base::inherits
[16:13:39.175]                       invokeRestart <- base::invokeRestart
[16:13:39.175]                       is.null <- base::is.null
[16:13:39.175]                       muffled <- FALSE
[16:13:39.175]                       if (inherits(cond, "message")) {
[16:13:39.175]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.175]                         if (muffled) 
[16:13:39.175]                           invokeRestart("muffleMessage")
[16:13:39.175]                       }
[16:13:39.175]                       else if (inherits(cond, "warning")) {
[16:13:39.175]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.175]                         if (muffled) 
[16:13:39.175]                           invokeRestart("muffleWarning")
[16:13:39.175]                       }
[16:13:39.175]                       else if (inherits(cond, "condition")) {
[16:13:39.175]                         if (!is.null(pattern)) {
[16:13:39.175]                           computeRestarts <- base::computeRestarts
[16:13:39.175]                           grepl <- base::grepl
[16:13:39.175]                           restarts <- computeRestarts(cond)
[16:13:39.175]                           for (restart in restarts) {
[16:13:39.175]                             name <- restart$name
[16:13:39.175]                             if (is.null(name)) 
[16:13:39.175]                               next
[16:13:39.175]                             if (!grepl(pattern, name)) 
[16:13:39.175]                               next
[16:13:39.175]                             invokeRestart(restart)
[16:13:39.175]                             muffled <- TRUE
[16:13:39.175]                             break
[16:13:39.175]                           }
[16:13:39.175]                         }
[16:13:39.175]                       }
[16:13:39.175]                       invisible(muffled)
[16:13:39.175]                     }
[16:13:39.175]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.175]                   }
[16:13:39.175]                 }
[16:13:39.175]             }
[16:13:39.175]         }))
[16:13:39.175]     }, error = function(ex) {
[16:13:39.175]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:39.175]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.175]                 ...future.rng), started = ...future.startTime, 
[16:13:39.175]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:39.175]             version = "1.8"), class = "FutureResult")
[16:13:39.175]     }, finally = {
[16:13:39.175]         if (!identical(...future.workdir, getwd())) 
[16:13:39.175]             setwd(...future.workdir)
[16:13:39.175]         {
[16:13:39.175]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:39.175]                 ...future.oldOptions$nwarnings <- NULL
[16:13:39.175]             }
[16:13:39.175]             base::options(...future.oldOptions)
[16:13:39.175]             if (.Platform$OS.type == "windows") {
[16:13:39.175]                 old_names <- names(...future.oldEnvVars)
[16:13:39.175]                 envs <- base::Sys.getenv()
[16:13:39.175]                 names <- names(envs)
[16:13:39.175]                 common <- intersect(names, old_names)
[16:13:39.175]                 added <- setdiff(names, old_names)
[16:13:39.175]                 removed <- setdiff(old_names, names)
[16:13:39.175]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:39.175]                   envs[common]]
[16:13:39.175]                 NAMES <- toupper(changed)
[16:13:39.175]                 args <- list()
[16:13:39.175]                 for (kk in seq_along(NAMES)) {
[16:13:39.175]                   name <- changed[[kk]]
[16:13:39.175]                   NAME <- NAMES[[kk]]
[16:13:39.175]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.175]                     next
[16:13:39.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.175]                 }
[16:13:39.175]                 NAMES <- toupper(added)
[16:13:39.175]                 for (kk in seq_along(NAMES)) {
[16:13:39.175]                   name <- added[[kk]]
[16:13:39.175]                   NAME <- NAMES[[kk]]
[16:13:39.175]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.175]                     next
[16:13:39.175]                   args[[name]] <- ""
[16:13:39.175]                 }
[16:13:39.175]                 NAMES <- toupper(removed)
[16:13:39.175]                 for (kk in seq_along(NAMES)) {
[16:13:39.175]                   name <- removed[[kk]]
[16:13:39.175]                   NAME <- NAMES[[kk]]
[16:13:39.175]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.175]                     next
[16:13:39.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.175]                 }
[16:13:39.175]                 if (length(args) > 0) 
[16:13:39.175]                   base::do.call(base::Sys.setenv, args = args)
[16:13:39.175]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:39.175]             }
[16:13:39.175]             else {
[16:13:39.175]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:39.175]             }
[16:13:39.175]             {
[16:13:39.175]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:39.175]                   0L) {
[16:13:39.175]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:39.175]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:39.175]                   base::options(opts)
[16:13:39.175]                 }
[16:13:39.175]                 {
[16:13:39.175]                   {
[16:13:39.175]                     NULL
[16:13:39.175]                     RNGkind("Mersenne-Twister")
[16:13:39.175]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:39.175]                       inherits = FALSE)
[16:13:39.175]                   }
[16:13:39.175]                   options(future.plan = NULL)
[16:13:39.175]                   if (is.na(NA_character_)) 
[16:13:39.175]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.175]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:39.175]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:39.175]                   {
[16:13:39.175]                     future <- SequentialFuture(..., envir = envir)
[16:13:39.175]                     if (!future$lazy) 
[16:13:39.175]                       future <- run(future)
[16:13:39.175]                     invisible(future)
[16:13:39.175]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:39.175]                 }
[16:13:39.175]             }
[16:13:39.175]         }
[16:13:39.175]     })
[16:13:39.175]     if (TRUE) {
[16:13:39.175]         base::sink(type = "output", split = FALSE)
[16:13:39.175]         if (TRUE) {
[16:13:39.175]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:39.175]         }
[16:13:39.175]         else {
[16:13:39.175]             ...future.result["stdout"] <- base::list(NULL)
[16:13:39.175]         }
[16:13:39.175]         base::close(...future.stdout)
[16:13:39.175]         ...future.stdout <- NULL
[16:13:39.175]     }
[16:13:39.175]     ...future.result$conditions <- ...future.conditions
[16:13:39.175]     ...future.result$finished <- base::Sys.time()
[16:13:39.175]     ...future.result
[16:13:39.175] }
[16:13:39.177] assign_globals() ...
[16:13:39.177] List of 1
[16:13:39.177]  $ kk: int 1
[16:13:39.177]  - attr(*, "where")=List of 1
[16:13:39.177]   ..$ kk:<environment: R_EmptyEnv> 
[16:13:39.177]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:39.177]  - attr(*, "resolved")= logi FALSE
[16:13:39.177]  - attr(*, "total_size")= num 56
[16:13:39.177]  - attr(*, "already-done")= logi TRUE
[16:13:39.182] - copied ‘kk’ to environment
[16:13:39.182] assign_globals() ... done
[16:13:39.182] plan(): Setting new future strategy stack:
[16:13:39.182] List of future strategies:
[16:13:39.182] 1. sequential:
[16:13:39.182]    - args: function (..., envir = parent.frame())
[16:13:39.182]    - tweaked: FALSE
[16:13:39.182]    - call: NULL
[16:13:39.183] plan(): nbrOfWorkers() = 1
[16:13:39.284] plan(): Setting new future strategy stack:
[16:13:39.284] List of future strategies:
[16:13:39.284] 1. sequential:
[16:13:39.284]    - args: function (..., envir = parent.frame())
[16:13:39.284]    - tweaked: FALSE
[16:13:39.284]    - call: plan(strategy)
[16:13:39.285] plan(): nbrOfWorkers() = 1
[16:13:39.287] SequentialFuture started (and completed)
[16:13:39.287] - Launch lazy future ... done
[16:13:39.287] run() for ‘SequentialFuture’ ... done
[16:13:39.287] getGlobalsAndPackages() ...
[16:13:39.287] Searching for globals...
[16:13:39.289] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:13:39.289] Searching for globals ... DONE
[16:13:39.289] Resolving globals: FALSE
[16:13:39.289] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:39.289] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:13:39.290] - globals: [1] ‘kk’
[16:13:39.290] 
[16:13:39.290] getGlobalsAndPackages() ... DONE
[16:13:39.290] run() for ‘Future’ ...
[16:13:39.290] - state: ‘created’
[16:13:39.290] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:39.291] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:39.291] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:39.291]   - Field: ‘label’
[16:13:39.291]   - Field: ‘local’
[16:13:39.291]   - Field: ‘owner’
[16:13:39.291]   - Field: ‘envir’
[16:13:39.291]   - Field: ‘packages’
[16:13:39.291]   - Field: ‘gc’
[16:13:39.291]   - Field: ‘conditions’
[16:13:39.291]   - Field: ‘expr’
[16:13:39.292]   - Field: ‘uuid’
[16:13:39.292]   - Field: ‘seed’
[16:13:39.292]   - Field: ‘version’
[16:13:39.292]   - Field: ‘result’
[16:13:39.292]   - Field: ‘asynchronous’
[16:13:39.292]   - Field: ‘calls’
[16:13:39.292]   - Field: ‘globals’
[16:13:39.292]   - Field: ‘stdout’
[16:13:39.292]   - Field: ‘earlySignal’
[16:13:39.292]   - Field: ‘lazy’
[16:13:39.292]   - Field: ‘state’
[16:13:39.293] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:39.293] - Launch lazy future ...
[16:13:39.293] Packages needed by the future expression (n = 0): <none>
[16:13:39.293] Packages needed by future strategies (n = 0): <none>
[16:13:39.293] {
[16:13:39.293]     {
[16:13:39.293]         {
[16:13:39.293]             ...future.startTime <- base::Sys.time()
[16:13:39.293]             {
[16:13:39.293]                 {
[16:13:39.293]                   {
[16:13:39.293]                     base::local({
[16:13:39.293]                       has_future <- base::requireNamespace("future", 
[16:13:39.293]                         quietly = TRUE)
[16:13:39.293]                       if (has_future) {
[16:13:39.293]                         ns <- base::getNamespace("future")
[16:13:39.293]                         version <- ns[[".package"]][["version"]]
[16:13:39.293]                         if (is.null(version)) 
[16:13:39.293]                           version <- utils::packageVersion("future")
[16:13:39.293]                       }
[16:13:39.293]                       else {
[16:13:39.293]                         version <- NULL
[16:13:39.293]                       }
[16:13:39.293]                       if (!has_future || version < "1.8.0") {
[16:13:39.293]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:39.293]                           "", base::R.version$version.string), 
[16:13:39.293]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:39.293]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:39.293]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:39.293]                             "release", "version")], collapse = " "), 
[16:13:39.293]                           hostname = base::Sys.info()[["nodename"]])
[16:13:39.293]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:39.293]                           info)
[16:13:39.293]                         info <- base::paste(info, collapse = "; ")
[16:13:39.293]                         if (!has_future) {
[16:13:39.293]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:39.293]                             info)
[16:13:39.293]                         }
[16:13:39.293]                         else {
[16:13:39.293]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:39.293]                             info, version)
[16:13:39.293]                         }
[16:13:39.293]                         base::stop(msg)
[16:13:39.293]                       }
[16:13:39.293]                     })
[16:13:39.293]                   }
[16:13:39.293]                   options(future.plan = NULL)
[16:13:39.293]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.293]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:39.293]                 }
[16:13:39.293]                 ...future.workdir <- getwd()
[16:13:39.293]             }
[16:13:39.293]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:39.293]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:39.293]         }
[16:13:39.293]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:39.293]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:39.293]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:39.293]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:39.293]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:39.293]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:39.293]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:39.293]             base::names(...future.oldOptions))
[16:13:39.293]     }
[16:13:39.293]     if (FALSE) {
[16:13:39.293]     }
[16:13:39.293]     else {
[16:13:39.293]         if (TRUE) {
[16:13:39.293]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:39.293]                 open = "w")
[16:13:39.293]         }
[16:13:39.293]         else {
[16:13:39.293]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:39.293]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:39.293]         }
[16:13:39.293]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:39.293]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:39.293]             base::sink(type = "output", split = FALSE)
[16:13:39.293]             base::close(...future.stdout)
[16:13:39.293]         }, add = TRUE)
[16:13:39.293]     }
[16:13:39.293]     ...future.frame <- base::sys.nframe()
[16:13:39.293]     ...future.conditions <- base::list()
[16:13:39.293]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:39.293]     if (FALSE) {
[16:13:39.293]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:39.293]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:39.293]     }
[16:13:39.293]     ...future.result <- base::tryCatch({
[16:13:39.293]         base::withCallingHandlers({
[16:13:39.293]             ...future.value <- base::withVisible(base::local({
[16:13:39.293]                 Sys.sleep(0.1)
[16:13:39.293]                 kk
[16:13:39.293]             }))
[16:13:39.293]             future::FutureResult(value = ...future.value$value, 
[16:13:39.293]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.293]                   ...future.rng), globalenv = if (FALSE) 
[16:13:39.293]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:39.293]                     ...future.globalenv.names))
[16:13:39.293]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:39.293]         }, condition = base::local({
[16:13:39.293]             c <- base::c
[16:13:39.293]             inherits <- base::inherits
[16:13:39.293]             invokeRestart <- base::invokeRestart
[16:13:39.293]             length <- base::length
[16:13:39.293]             list <- base::list
[16:13:39.293]             seq.int <- base::seq.int
[16:13:39.293]             signalCondition <- base::signalCondition
[16:13:39.293]             sys.calls <- base::sys.calls
[16:13:39.293]             `[[` <- base::`[[`
[16:13:39.293]             `+` <- base::`+`
[16:13:39.293]             `<<-` <- base::`<<-`
[16:13:39.293]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:39.293]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:39.293]                   3L)]
[16:13:39.293]             }
[16:13:39.293]             function(cond) {
[16:13:39.293]                 is_error <- inherits(cond, "error")
[16:13:39.293]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:39.293]                   NULL)
[16:13:39.293]                 if (is_error) {
[16:13:39.293]                   sessionInformation <- function() {
[16:13:39.293]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:39.293]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:39.293]                       search = base::search(), system = base::Sys.info())
[16:13:39.293]                   }
[16:13:39.293]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.293]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:39.293]                     cond$call), session = sessionInformation(), 
[16:13:39.293]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:39.293]                   signalCondition(cond)
[16:13:39.293]                 }
[16:13:39.293]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:39.293]                 "immediateCondition"))) {
[16:13:39.293]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:39.293]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.293]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:39.293]                   if (TRUE && !signal) {
[16:13:39.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.293]                     {
[16:13:39.293]                       inherits <- base::inherits
[16:13:39.293]                       invokeRestart <- base::invokeRestart
[16:13:39.293]                       is.null <- base::is.null
[16:13:39.293]                       muffled <- FALSE
[16:13:39.293]                       if (inherits(cond, "message")) {
[16:13:39.293]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.293]                         if (muffled) 
[16:13:39.293]                           invokeRestart("muffleMessage")
[16:13:39.293]                       }
[16:13:39.293]                       else if (inherits(cond, "warning")) {
[16:13:39.293]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.293]                         if (muffled) 
[16:13:39.293]                           invokeRestart("muffleWarning")
[16:13:39.293]                       }
[16:13:39.293]                       else if (inherits(cond, "condition")) {
[16:13:39.293]                         if (!is.null(pattern)) {
[16:13:39.293]                           computeRestarts <- base::computeRestarts
[16:13:39.293]                           grepl <- base::grepl
[16:13:39.293]                           restarts <- computeRestarts(cond)
[16:13:39.293]                           for (restart in restarts) {
[16:13:39.293]                             name <- restart$name
[16:13:39.293]                             if (is.null(name)) 
[16:13:39.293]                               next
[16:13:39.293]                             if (!grepl(pattern, name)) 
[16:13:39.293]                               next
[16:13:39.293]                             invokeRestart(restart)
[16:13:39.293]                             muffled <- TRUE
[16:13:39.293]                             break
[16:13:39.293]                           }
[16:13:39.293]                         }
[16:13:39.293]                       }
[16:13:39.293]                       invisible(muffled)
[16:13:39.293]                     }
[16:13:39.293]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.293]                   }
[16:13:39.293]                 }
[16:13:39.293]                 else {
[16:13:39.293]                   if (TRUE) {
[16:13:39.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.293]                     {
[16:13:39.293]                       inherits <- base::inherits
[16:13:39.293]                       invokeRestart <- base::invokeRestart
[16:13:39.293]                       is.null <- base::is.null
[16:13:39.293]                       muffled <- FALSE
[16:13:39.293]                       if (inherits(cond, "message")) {
[16:13:39.293]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.293]                         if (muffled) 
[16:13:39.293]                           invokeRestart("muffleMessage")
[16:13:39.293]                       }
[16:13:39.293]                       else if (inherits(cond, "warning")) {
[16:13:39.293]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.293]                         if (muffled) 
[16:13:39.293]                           invokeRestart("muffleWarning")
[16:13:39.293]                       }
[16:13:39.293]                       else if (inherits(cond, "condition")) {
[16:13:39.293]                         if (!is.null(pattern)) {
[16:13:39.293]                           computeRestarts <- base::computeRestarts
[16:13:39.293]                           grepl <- base::grepl
[16:13:39.293]                           restarts <- computeRestarts(cond)
[16:13:39.293]                           for (restart in restarts) {
[16:13:39.293]                             name <- restart$name
[16:13:39.293]                             if (is.null(name)) 
[16:13:39.293]                               next
[16:13:39.293]                             if (!grepl(pattern, name)) 
[16:13:39.293]                               next
[16:13:39.293]                             invokeRestart(restart)
[16:13:39.293]                             muffled <- TRUE
[16:13:39.293]                             break
[16:13:39.293]                           }
[16:13:39.293]                         }
[16:13:39.293]                       }
[16:13:39.293]                       invisible(muffled)
[16:13:39.293]                     }
[16:13:39.293]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.293]                   }
[16:13:39.293]                 }
[16:13:39.293]             }
[16:13:39.293]         }))
[16:13:39.293]     }, error = function(ex) {
[16:13:39.293]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:39.293]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.293]                 ...future.rng), started = ...future.startTime, 
[16:13:39.293]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:39.293]             version = "1.8"), class = "FutureResult")
[16:13:39.293]     }, finally = {
[16:13:39.293]         if (!identical(...future.workdir, getwd())) 
[16:13:39.293]             setwd(...future.workdir)
[16:13:39.293]         {
[16:13:39.293]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:39.293]                 ...future.oldOptions$nwarnings <- NULL
[16:13:39.293]             }
[16:13:39.293]             base::options(...future.oldOptions)
[16:13:39.293]             if (.Platform$OS.type == "windows") {
[16:13:39.293]                 old_names <- names(...future.oldEnvVars)
[16:13:39.293]                 envs <- base::Sys.getenv()
[16:13:39.293]                 names <- names(envs)
[16:13:39.293]                 common <- intersect(names, old_names)
[16:13:39.293]                 added <- setdiff(names, old_names)
[16:13:39.293]                 removed <- setdiff(old_names, names)
[16:13:39.293]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:39.293]                   envs[common]]
[16:13:39.293]                 NAMES <- toupper(changed)
[16:13:39.293]                 args <- list()
[16:13:39.293]                 for (kk in seq_along(NAMES)) {
[16:13:39.293]                   name <- changed[[kk]]
[16:13:39.293]                   NAME <- NAMES[[kk]]
[16:13:39.293]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.293]                     next
[16:13:39.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.293]                 }
[16:13:39.293]                 NAMES <- toupper(added)
[16:13:39.293]                 for (kk in seq_along(NAMES)) {
[16:13:39.293]                   name <- added[[kk]]
[16:13:39.293]                   NAME <- NAMES[[kk]]
[16:13:39.293]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.293]                     next
[16:13:39.293]                   args[[name]] <- ""
[16:13:39.293]                 }
[16:13:39.293]                 NAMES <- toupper(removed)
[16:13:39.293]                 for (kk in seq_along(NAMES)) {
[16:13:39.293]                   name <- removed[[kk]]
[16:13:39.293]                   NAME <- NAMES[[kk]]
[16:13:39.293]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.293]                     next
[16:13:39.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.293]                 }
[16:13:39.293]                 if (length(args) > 0) 
[16:13:39.293]                   base::do.call(base::Sys.setenv, args = args)
[16:13:39.293]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:39.293]             }
[16:13:39.293]             else {
[16:13:39.293]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:39.293]             }
[16:13:39.293]             {
[16:13:39.293]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:39.293]                   0L) {
[16:13:39.293]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:39.293]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:39.293]                   base::options(opts)
[16:13:39.293]                 }
[16:13:39.293]                 {
[16:13:39.293]                   {
[16:13:39.293]                     NULL
[16:13:39.293]                     RNGkind("Mersenne-Twister")
[16:13:39.293]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:39.293]                       inherits = FALSE)
[16:13:39.293]                   }
[16:13:39.293]                   options(future.plan = NULL)
[16:13:39.293]                   if (is.na(NA_character_)) 
[16:13:39.293]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.293]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:39.293]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:39.293]                   {
[16:13:39.293]                     future <- SequentialFuture(..., envir = envir)
[16:13:39.293]                     if (!future$lazy) 
[16:13:39.293]                       future <- run(future)
[16:13:39.293]                     invisible(future)
[16:13:39.293]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:39.293]                 }
[16:13:39.293]             }
[16:13:39.293]         }
[16:13:39.293]     })
[16:13:39.293]     if (TRUE) {
[16:13:39.293]         base::sink(type = "output", split = FALSE)
[16:13:39.293]         if (TRUE) {
[16:13:39.293]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:39.293]         }
[16:13:39.293]         else {
[16:13:39.293]             ...future.result["stdout"] <- base::list(NULL)
[16:13:39.293]         }
[16:13:39.293]         base::close(...future.stdout)
[16:13:39.293]         ...future.stdout <- NULL
[16:13:39.293]     }
[16:13:39.293]     ...future.result$conditions <- ...future.conditions
[16:13:39.293]     ...future.result$finished <- base::Sys.time()
[16:13:39.293]     ...future.result
[16:13:39.293] }
[16:13:39.295] assign_globals() ...
[16:13:39.295] List of 1
[16:13:39.295]  $ kk: int 2
[16:13:39.295]  - attr(*, "where")=List of 1
[16:13:39.295]   ..$ kk:<environment: R_EmptyEnv> 
[16:13:39.295]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:39.295]  - attr(*, "resolved")= logi FALSE
[16:13:39.295]  - attr(*, "total_size")= num 56
[16:13:39.295]  - attr(*, "already-done")= logi TRUE
[16:13:39.297] - copied ‘kk’ to environment
[16:13:39.298] assign_globals() ... done
[16:13:39.298] plan(): Setting new future strategy stack:
[16:13:39.298] List of future strategies:
[16:13:39.298] 1. sequential:
[16:13:39.298]    - args: function (..., envir = parent.frame())
[16:13:39.298]    - tweaked: FALSE
[16:13:39.298]    - call: NULL
[16:13:39.298] plan(): nbrOfWorkers() = 1
[16:13:39.399] plan(): Setting new future strategy stack:
[16:13:39.400] List of future strategies:
[16:13:39.400] 1. sequential:
[16:13:39.400]    - args: function (..., envir = parent.frame())
[16:13:39.400]    - tweaked: FALSE
[16:13:39.400]    - call: plan(strategy)
[16:13:39.400] plan(): nbrOfWorkers() = 1
[16:13:39.400] SequentialFuture started (and completed)
[16:13:39.400] - Launch lazy future ... done
[16:13:39.401] run() for ‘SequentialFuture’ ... done
[16:13:39.401] getGlobalsAndPackages() ...
[16:13:39.401] Searching for globals...
[16:13:39.402] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:13:39.402] Searching for globals ... DONE
[16:13:39.402] Resolving globals: FALSE
[16:13:39.402] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:39.403] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:13:39.403] - globals: [1] ‘kk’
[16:13:39.403] 
[16:13:39.403] getGlobalsAndPackages() ... DONE
[16:13:39.403] run() for ‘Future’ ...
[16:13:39.403] - state: ‘created’
[16:13:39.404] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:39.404] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:39.404] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:39.404]   - Field: ‘label’
[16:13:39.404]   - Field: ‘local’
[16:13:39.404]   - Field: ‘owner’
[16:13:39.404]   - Field: ‘envir’
[16:13:39.404]   - Field: ‘packages’
[16:13:39.405]   - Field: ‘gc’
[16:13:39.405]   - Field: ‘conditions’
[16:13:39.405]   - Field: ‘expr’
[16:13:39.405]   - Field: ‘uuid’
[16:13:39.405]   - Field: ‘seed’
[16:13:39.405]   - Field: ‘version’
[16:13:39.405]   - Field: ‘result’
[16:13:39.405]   - Field: ‘asynchronous’
[16:13:39.405]   - Field: ‘calls’
[16:13:39.405]   - Field: ‘globals’
[16:13:39.405]   - Field: ‘stdout’
[16:13:39.405]   - Field: ‘earlySignal’
[16:13:39.406]   - Field: ‘lazy’
[16:13:39.406]   - Field: ‘state’
[16:13:39.406] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:39.406] - Launch lazy future ...
[16:13:39.406] Packages needed by the future expression (n = 0): <none>
[16:13:39.406] Packages needed by future strategies (n = 0): <none>
[16:13:39.407] {
[16:13:39.407]     {
[16:13:39.407]         {
[16:13:39.407]             ...future.startTime <- base::Sys.time()
[16:13:39.407]             {
[16:13:39.407]                 {
[16:13:39.407]                   {
[16:13:39.407]                     base::local({
[16:13:39.407]                       has_future <- base::requireNamespace("future", 
[16:13:39.407]                         quietly = TRUE)
[16:13:39.407]                       if (has_future) {
[16:13:39.407]                         ns <- base::getNamespace("future")
[16:13:39.407]                         version <- ns[[".package"]][["version"]]
[16:13:39.407]                         if (is.null(version)) 
[16:13:39.407]                           version <- utils::packageVersion("future")
[16:13:39.407]                       }
[16:13:39.407]                       else {
[16:13:39.407]                         version <- NULL
[16:13:39.407]                       }
[16:13:39.407]                       if (!has_future || version < "1.8.0") {
[16:13:39.407]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:39.407]                           "", base::R.version$version.string), 
[16:13:39.407]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:39.407]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:39.407]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:39.407]                             "release", "version")], collapse = " "), 
[16:13:39.407]                           hostname = base::Sys.info()[["nodename"]])
[16:13:39.407]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:39.407]                           info)
[16:13:39.407]                         info <- base::paste(info, collapse = "; ")
[16:13:39.407]                         if (!has_future) {
[16:13:39.407]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:39.407]                             info)
[16:13:39.407]                         }
[16:13:39.407]                         else {
[16:13:39.407]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:39.407]                             info, version)
[16:13:39.407]                         }
[16:13:39.407]                         base::stop(msg)
[16:13:39.407]                       }
[16:13:39.407]                     })
[16:13:39.407]                   }
[16:13:39.407]                   options(future.plan = NULL)
[16:13:39.407]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.407]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:39.407]                 }
[16:13:39.407]                 ...future.workdir <- getwd()
[16:13:39.407]             }
[16:13:39.407]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:39.407]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:39.407]         }
[16:13:39.407]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:39.407]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:39.407]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:39.407]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:39.407]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:39.407]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:39.407]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:39.407]             base::names(...future.oldOptions))
[16:13:39.407]     }
[16:13:39.407]     if (FALSE) {
[16:13:39.407]     }
[16:13:39.407]     else {
[16:13:39.407]         if (TRUE) {
[16:13:39.407]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:39.407]                 open = "w")
[16:13:39.407]         }
[16:13:39.407]         else {
[16:13:39.407]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:39.407]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:39.407]         }
[16:13:39.407]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:39.407]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:39.407]             base::sink(type = "output", split = FALSE)
[16:13:39.407]             base::close(...future.stdout)
[16:13:39.407]         }, add = TRUE)
[16:13:39.407]     }
[16:13:39.407]     ...future.frame <- base::sys.nframe()
[16:13:39.407]     ...future.conditions <- base::list()
[16:13:39.407]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:39.407]     if (FALSE) {
[16:13:39.407]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:39.407]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:39.407]     }
[16:13:39.407]     ...future.result <- base::tryCatch({
[16:13:39.407]         base::withCallingHandlers({
[16:13:39.407]             ...future.value <- base::withVisible(base::local({
[16:13:39.407]                 Sys.sleep(0.1)
[16:13:39.407]                 kk
[16:13:39.407]             }))
[16:13:39.407]             future::FutureResult(value = ...future.value$value, 
[16:13:39.407]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.407]                   ...future.rng), globalenv = if (FALSE) 
[16:13:39.407]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:39.407]                     ...future.globalenv.names))
[16:13:39.407]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:39.407]         }, condition = base::local({
[16:13:39.407]             c <- base::c
[16:13:39.407]             inherits <- base::inherits
[16:13:39.407]             invokeRestart <- base::invokeRestart
[16:13:39.407]             length <- base::length
[16:13:39.407]             list <- base::list
[16:13:39.407]             seq.int <- base::seq.int
[16:13:39.407]             signalCondition <- base::signalCondition
[16:13:39.407]             sys.calls <- base::sys.calls
[16:13:39.407]             `[[` <- base::`[[`
[16:13:39.407]             `+` <- base::`+`
[16:13:39.407]             `<<-` <- base::`<<-`
[16:13:39.407]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:39.407]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:39.407]                   3L)]
[16:13:39.407]             }
[16:13:39.407]             function(cond) {
[16:13:39.407]                 is_error <- inherits(cond, "error")
[16:13:39.407]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:39.407]                   NULL)
[16:13:39.407]                 if (is_error) {
[16:13:39.407]                   sessionInformation <- function() {
[16:13:39.407]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:39.407]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:39.407]                       search = base::search(), system = base::Sys.info())
[16:13:39.407]                   }
[16:13:39.407]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.407]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:39.407]                     cond$call), session = sessionInformation(), 
[16:13:39.407]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:39.407]                   signalCondition(cond)
[16:13:39.407]                 }
[16:13:39.407]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:39.407]                 "immediateCondition"))) {
[16:13:39.407]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:39.407]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.407]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:39.407]                   if (TRUE && !signal) {
[16:13:39.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.407]                     {
[16:13:39.407]                       inherits <- base::inherits
[16:13:39.407]                       invokeRestart <- base::invokeRestart
[16:13:39.407]                       is.null <- base::is.null
[16:13:39.407]                       muffled <- FALSE
[16:13:39.407]                       if (inherits(cond, "message")) {
[16:13:39.407]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.407]                         if (muffled) 
[16:13:39.407]                           invokeRestart("muffleMessage")
[16:13:39.407]                       }
[16:13:39.407]                       else if (inherits(cond, "warning")) {
[16:13:39.407]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.407]                         if (muffled) 
[16:13:39.407]                           invokeRestart("muffleWarning")
[16:13:39.407]                       }
[16:13:39.407]                       else if (inherits(cond, "condition")) {
[16:13:39.407]                         if (!is.null(pattern)) {
[16:13:39.407]                           computeRestarts <- base::computeRestarts
[16:13:39.407]                           grepl <- base::grepl
[16:13:39.407]                           restarts <- computeRestarts(cond)
[16:13:39.407]                           for (restart in restarts) {
[16:13:39.407]                             name <- restart$name
[16:13:39.407]                             if (is.null(name)) 
[16:13:39.407]                               next
[16:13:39.407]                             if (!grepl(pattern, name)) 
[16:13:39.407]                               next
[16:13:39.407]                             invokeRestart(restart)
[16:13:39.407]                             muffled <- TRUE
[16:13:39.407]                             break
[16:13:39.407]                           }
[16:13:39.407]                         }
[16:13:39.407]                       }
[16:13:39.407]                       invisible(muffled)
[16:13:39.407]                     }
[16:13:39.407]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.407]                   }
[16:13:39.407]                 }
[16:13:39.407]                 else {
[16:13:39.407]                   if (TRUE) {
[16:13:39.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.407]                     {
[16:13:39.407]                       inherits <- base::inherits
[16:13:39.407]                       invokeRestart <- base::invokeRestart
[16:13:39.407]                       is.null <- base::is.null
[16:13:39.407]                       muffled <- FALSE
[16:13:39.407]                       if (inherits(cond, "message")) {
[16:13:39.407]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.407]                         if (muffled) 
[16:13:39.407]                           invokeRestart("muffleMessage")
[16:13:39.407]                       }
[16:13:39.407]                       else if (inherits(cond, "warning")) {
[16:13:39.407]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.407]                         if (muffled) 
[16:13:39.407]                           invokeRestart("muffleWarning")
[16:13:39.407]                       }
[16:13:39.407]                       else if (inherits(cond, "condition")) {
[16:13:39.407]                         if (!is.null(pattern)) {
[16:13:39.407]                           computeRestarts <- base::computeRestarts
[16:13:39.407]                           grepl <- base::grepl
[16:13:39.407]                           restarts <- computeRestarts(cond)
[16:13:39.407]                           for (restart in restarts) {
[16:13:39.407]                             name <- restart$name
[16:13:39.407]                             if (is.null(name)) 
[16:13:39.407]                               next
[16:13:39.407]                             if (!grepl(pattern, name)) 
[16:13:39.407]                               next
[16:13:39.407]                             invokeRestart(restart)
[16:13:39.407]                             muffled <- TRUE
[16:13:39.407]                             break
[16:13:39.407]                           }
[16:13:39.407]                         }
[16:13:39.407]                       }
[16:13:39.407]                       invisible(muffled)
[16:13:39.407]                     }
[16:13:39.407]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.407]                   }
[16:13:39.407]                 }
[16:13:39.407]             }
[16:13:39.407]         }))
[16:13:39.407]     }, error = function(ex) {
[16:13:39.407]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:39.407]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.407]                 ...future.rng), started = ...future.startTime, 
[16:13:39.407]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:39.407]             version = "1.8"), class = "FutureResult")
[16:13:39.407]     }, finally = {
[16:13:39.407]         if (!identical(...future.workdir, getwd())) 
[16:13:39.407]             setwd(...future.workdir)
[16:13:39.407]         {
[16:13:39.407]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:39.407]                 ...future.oldOptions$nwarnings <- NULL
[16:13:39.407]             }
[16:13:39.407]             base::options(...future.oldOptions)
[16:13:39.407]             if (.Platform$OS.type == "windows") {
[16:13:39.407]                 old_names <- names(...future.oldEnvVars)
[16:13:39.407]                 envs <- base::Sys.getenv()
[16:13:39.407]                 names <- names(envs)
[16:13:39.407]                 common <- intersect(names, old_names)
[16:13:39.407]                 added <- setdiff(names, old_names)
[16:13:39.407]                 removed <- setdiff(old_names, names)
[16:13:39.407]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:39.407]                   envs[common]]
[16:13:39.407]                 NAMES <- toupper(changed)
[16:13:39.407]                 args <- list()
[16:13:39.407]                 for (kk in seq_along(NAMES)) {
[16:13:39.407]                   name <- changed[[kk]]
[16:13:39.407]                   NAME <- NAMES[[kk]]
[16:13:39.407]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.407]                     next
[16:13:39.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.407]                 }
[16:13:39.407]                 NAMES <- toupper(added)
[16:13:39.407]                 for (kk in seq_along(NAMES)) {
[16:13:39.407]                   name <- added[[kk]]
[16:13:39.407]                   NAME <- NAMES[[kk]]
[16:13:39.407]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.407]                     next
[16:13:39.407]                   args[[name]] <- ""
[16:13:39.407]                 }
[16:13:39.407]                 NAMES <- toupper(removed)
[16:13:39.407]                 for (kk in seq_along(NAMES)) {
[16:13:39.407]                   name <- removed[[kk]]
[16:13:39.407]                   NAME <- NAMES[[kk]]
[16:13:39.407]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.407]                     next
[16:13:39.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.407]                 }
[16:13:39.407]                 if (length(args) > 0) 
[16:13:39.407]                   base::do.call(base::Sys.setenv, args = args)
[16:13:39.407]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:39.407]             }
[16:13:39.407]             else {
[16:13:39.407]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:39.407]             }
[16:13:39.407]             {
[16:13:39.407]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:39.407]                   0L) {
[16:13:39.407]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:39.407]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:39.407]                   base::options(opts)
[16:13:39.407]                 }
[16:13:39.407]                 {
[16:13:39.407]                   {
[16:13:39.407]                     NULL
[16:13:39.407]                     RNGkind("Mersenne-Twister")
[16:13:39.407]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:39.407]                       inherits = FALSE)
[16:13:39.407]                   }
[16:13:39.407]                   options(future.plan = NULL)
[16:13:39.407]                   if (is.na(NA_character_)) 
[16:13:39.407]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.407]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:39.407]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:39.407]                   {
[16:13:39.407]                     future <- SequentialFuture(..., envir = envir)
[16:13:39.407]                     if (!future$lazy) 
[16:13:39.407]                       future <- run(future)
[16:13:39.407]                     invisible(future)
[16:13:39.407]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:39.407]                 }
[16:13:39.407]             }
[16:13:39.407]         }
[16:13:39.407]     })
[16:13:39.407]     if (TRUE) {
[16:13:39.407]         base::sink(type = "output", split = FALSE)
[16:13:39.407]         if (TRUE) {
[16:13:39.407]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:39.407]         }
[16:13:39.407]         else {
[16:13:39.407]             ...future.result["stdout"] <- base::list(NULL)
[16:13:39.407]         }
[16:13:39.407]         base::close(...future.stdout)
[16:13:39.407]         ...future.stdout <- NULL
[16:13:39.407]     }
[16:13:39.407]     ...future.result$conditions <- ...future.conditions
[16:13:39.407]     ...future.result$finished <- base::Sys.time()
[16:13:39.407]     ...future.result
[16:13:39.407] }
[16:13:39.408] assign_globals() ...
[16:13:39.408] List of 1
[16:13:39.408]  $ kk: int 3
[16:13:39.408]  - attr(*, "where")=List of 1
[16:13:39.408]   ..$ kk:<environment: R_EmptyEnv> 
[16:13:39.408]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:39.408]  - attr(*, "resolved")= logi FALSE
[16:13:39.408]  - attr(*, "total_size")= num 56
[16:13:39.408]  - attr(*, "already-done")= logi TRUE
[16:13:39.411] - copied ‘kk’ to environment
[16:13:39.411] assign_globals() ... done
[16:13:39.411] plan(): Setting new future strategy stack:
[16:13:39.411] List of future strategies:
[16:13:39.411] 1. sequential:
[16:13:39.411]    - args: function (..., envir = parent.frame())
[16:13:39.411]    - tweaked: FALSE
[16:13:39.411]    - call: NULL
[16:13:39.412] plan(): nbrOfWorkers() = 1
[16:13:39.513] plan(): Setting new future strategy stack:
[16:13:39.513] List of future strategies:
[16:13:39.513] 1. sequential:
[16:13:39.513]    - args: function (..., envir = parent.frame())
[16:13:39.513]    - tweaked: FALSE
[16:13:39.513]    - call: plan(strategy)
[16:13:39.514] plan(): nbrOfWorkers() = 1
[16:13:39.514] SequentialFuture started (and completed)
[16:13:39.514] - Launch lazy future ... done
[16:13:39.514] run() for ‘SequentialFuture’ ... done
[16:13:39.514] resolve() on list ...
[16:13:39.514]  recursive: 0
[16:13:39.514]  length: 3
[16:13:39.515] 
[16:13:39.515] resolved() for ‘SequentialFuture’ ...
[16:13:39.515] - state: ‘finished’
[16:13:39.515] - run: TRUE
[16:13:39.515] - result: ‘FutureResult’
[16:13:39.515] resolved() for ‘SequentialFuture’ ... done
[16:13:39.515] Future #1
[16:13:39.515]  length: 2 (resolved future 1)
[16:13:39.515] resolved() for ‘SequentialFuture’ ...
[16:13:39.515] - state: ‘finished’
[16:13:39.516] - run: TRUE
[16:13:39.516] - result: ‘FutureResult’
[16:13:39.516] resolved() for ‘SequentialFuture’ ... done
[16:13:39.516] Future #2
[16:13:39.518]  length: 1 (resolved future 2)
[16:13:39.518] resolved() for ‘SequentialFuture’ ...
[16:13:39.518] - state: ‘finished’
[16:13:39.518] - run: TRUE
[16:13:39.518] - result: ‘FutureResult’
[16:13:39.518] resolved() for ‘SequentialFuture’ ... done
[16:13:39.518] Future #3
[16:13:39.518]  length: 0 (resolved future 3)
[16:13:39.519] resolve() on list ... DONE
[16:13:39.519] getGlobalsAndPackages() ...
[16:13:39.519] Searching for globals...
[16:13:39.520] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:13:39.520] Searching for globals ... DONE
[16:13:39.520] Resolving globals: FALSE
[16:13:39.520] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:39.521] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:13:39.521] - globals: [1] ‘kk’
[16:13:39.521] 
[16:13:39.521] getGlobalsAndPackages() ... DONE
[16:13:39.521] getGlobalsAndPackages() ...
[16:13:39.521] Searching for globals...
[16:13:39.522] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:13:39.522] Searching for globals ... DONE
[16:13:39.523] Resolving globals: FALSE
[16:13:39.523] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:39.523] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:13:39.523] - globals: [1] ‘kk’
[16:13:39.523] 
[16:13:39.524] getGlobalsAndPackages() ... DONE
[16:13:39.524] getGlobalsAndPackages() ...
[16:13:39.524] Searching for globals...
[16:13:39.525] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:13:39.525] Searching for globals ... DONE
[16:13:39.525] Resolving globals: FALSE
[16:13:39.525] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:39.526] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:13:39.526] - globals: [1] ‘kk’
[16:13:39.526] 
[16:13:39.526] getGlobalsAndPackages() ... DONE
[16:13:39.526] resolve() on list ...
[16:13:39.526]  recursive: 0
[16:13:39.526]  length: 3
[16:13:39.526] 
[16:13:39.527] run() for ‘Future’ ...
[16:13:39.527] - state: ‘created’
[16:13:39.527] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:39.527] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:39.527] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:39.527]   - Field: ‘label’
[16:13:39.527]   - Field: ‘local’
[16:13:39.528]   - Field: ‘owner’
[16:13:39.528]   - Field: ‘envir’
[16:13:39.528]   - Field: ‘packages’
[16:13:39.528]   - Field: ‘gc’
[16:13:39.528]   - Field: ‘conditions’
[16:13:39.528]   - Field: ‘expr’
[16:13:39.528]   - Field: ‘uuid’
[16:13:39.528]   - Field: ‘seed’
[16:13:39.528]   - Field: ‘version’
[16:13:39.528]   - Field: ‘result’
[16:13:39.529]   - Field: ‘asynchronous’
[16:13:39.529]   - Field: ‘calls’
[16:13:39.529]   - Field: ‘globals’
[16:13:39.529]   - Field: ‘stdout’
[16:13:39.529]   - Field: ‘earlySignal’
[16:13:39.529]   - Field: ‘lazy’
[16:13:39.529]   - Field: ‘state’
[16:13:39.529] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:39.529] - Launch lazy future ...
[16:13:39.529] Packages needed by the future expression (n = 0): <none>
[16:13:39.530] Packages needed by future strategies (n = 0): <none>
[16:13:39.530] {
[16:13:39.530]     {
[16:13:39.530]         {
[16:13:39.530]             ...future.startTime <- base::Sys.time()
[16:13:39.530]             {
[16:13:39.530]                 {
[16:13:39.530]                   {
[16:13:39.530]                     base::local({
[16:13:39.530]                       has_future <- base::requireNamespace("future", 
[16:13:39.530]                         quietly = TRUE)
[16:13:39.530]                       if (has_future) {
[16:13:39.530]                         ns <- base::getNamespace("future")
[16:13:39.530]                         version <- ns[[".package"]][["version"]]
[16:13:39.530]                         if (is.null(version)) 
[16:13:39.530]                           version <- utils::packageVersion("future")
[16:13:39.530]                       }
[16:13:39.530]                       else {
[16:13:39.530]                         version <- NULL
[16:13:39.530]                       }
[16:13:39.530]                       if (!has_future || version < "1.8.0") {
[16:13:39.530]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:39.530]                           "", base::R.version$version.string), 
[16:13:39.530]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:39.530]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:39.530]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:39.530]                             "release", "version")], collapse = " "), 
[16:13:39.530]                           hostname = base::Sys.info()[["nodename"]])
[16:13:39.530]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:39.530]                           info)
[16:13:39.530]                         info <- base::paste(info, collapse = "; ")
[16:13:39.530]                         if (!has_future) {
[16:13:39.530]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:39.530]                             info)
[16:13:39.530]                         }
[16:13:39.530]                         else {
[16:13:39.530]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:39.530]                             info, version)
[16:13:39.530]                         }
[16:13:39.530]                         base::stop(msg)
[16:13:39.530]                       }
[16:13:39.530]                     })
[16:13:39.530]                   }
[16:13:39.530]                   options(future.plan = NULL)
[16:13:39.530]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.530]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:39.530]                 }
[16:13:39.530]                 ...future.workdir <- getwd()
[16:13:39.530]             }
[16:13:39.530]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:39.530]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:39.530]         }
[16:13:39.530]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:39.530]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:39.530]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:39.530]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:39.530]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:39.530]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:39.530]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:39.530]             base::names(...future.oldOptions))
[16:13:39.530]     }
[16:13:39.530]     if (FALSE) {
[16:13:39.530]     }
[16:13:39.530]     else {
[16:13:39.530]         if (TRUE) {
[16:13:39.530]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:39.530]                 open = "w")
[16:13:39.530]         }
[16:13:39.530]         else {
[16:13:39.530]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:39.530]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:39.530]         }
[16:13:39.530]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:39.530]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:39.530]             base::sink(type = "output", split = FALSE)
[16:13:39.530]             base::close(...future.stdout)
[16:13:39.530]         }, add = TRUE)
[16:13:39.530]     }
[16:13:39.530]     ...future.frame <- base::sys.nframe()
[16:13:39.530]     ...future.conditions <- base::list()
[16:13:39.530]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:39.530]     if (FALSE) {
[16:13:39.530]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:39.530]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:39.530]     }
[16:13:39.530]     ...future.result <- base::tryCatch({
[16:13:39.530]         base::withCallingHandlers({
[16:13:39.530]             ...future.value <- base::withVisible(base::local({
[16:13:39.530]                 Sys.sleep(0.1)
[16:13:39.530]                 kk
[16:13:39.530]             }))
[16:13:39.530]             future::FutureResult(value = ...future.value$value, 
[16:13:39.530]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.530]                   ...future.rng), globalenv = if (FALSE) 
[16:13:39.530]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:39.530]                     ...future.globalenv.names))
[16:13:39.530]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:39.530]         }, condition = base::local({
[16:13:39.530]             c <- base::c
[16:13:39.530]             inherits <- base::inherits
[16:13:39.530]             invokeRestart <- base::invokeRestart
[16:13:39.530]             length <- base::length
[16:13:39.530]             list <- base::list
[16:13:39.530]             seq.int <- base::seq.int
[16:13:39.530]             signalCondition <- base::signalCondition
[16:13:39.530]             sys.calls <- base::sys.calls
[16:13:39.530]             `[[` <- base::`[[`
[16:13:39.530]             `+` <- base::`+`
[16:13:39.530]             `<<-` <- base::`<<-`
[16:13:39.530]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:39.530]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:39.530]                   3L)]
[16:13:39.530]             }
[16:13:39.530]             function(cond) {
[16:13:39.530]                 is_error <- inherits(cond, "error")
[16:13:39.530]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:39.530]                   NULL)
[16:13:39.530]                 if (is_error) {
[16:13:39.530]                   sessionInformation <- function() {
[16:13:39.530]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:39.530]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:39.530]                       search = base::search(), system = base::Sys.info())
[16:13:39.530]                   }
[16:13:39.530]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.530]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:39.530]                     cond$call), session = sessionInformation(), 
[16:13:39.530]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:39.530]                   signalCondition(cond)
[16:13:39.530]                 }
[16:13:39.530]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:39.530]                 "immediateCondition"))) {
[16:13:39.530]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:39.530]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.530]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:39.530]                   if (TRUE && !signal) {
[16:13:39.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.530]                     {
[16:13:39.530]                       inherits <- base::inherits
[16:13:39.530]                       invokeRestart <- base::invokeRestart
[16:13:39.530]                       is.null <- base::is.null
[16:13:39.530]                       muffled <- FALSE
[16:13:39.530]                       if (inherits(cond, "message")) {
[16:13:39.530]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.530]                         if (muffled) 
[16:13:39.530]                           invokeRestart("muffleMessage")
[16:13:39.530]                       }
[16:13:39.530]                       else if (inherits(cond, "warning")) {
[16:13:39.530]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.530]                         if (muffled) 
[16:13:39.530]                           invokeRestart("muffleWarning")
[16:13:39.530]                       }
[16:13:39.530]                       else if (inherits(cond, "condition")) {
[16:13:39.530]                         if (!is.null(pattern)) {
[16:13:39.530]                           computeRestarts <- base::computeRestarts
[16:13:39.530]                           grepl <- base::grepl
[16:13:39.530]                           restarts <- computeRestarts(cond)
[16:13:39.530]                           for (restart in restarts) {
[16:13:39.530]                             name <- restart$name
[16:13:39.530]                             if (is.null(name)) 
[16:13:39.530]                               next
[16:13:39.530]                             if (!grepl(pattern, name)) 
[16:13:39.530]                               next
[16:13:39.530]                             invokeRestart(restart)
[16:13:39.530]                             muffled <- TRUE
[16:13:39.530]                             break
[16:13:39.530]                           }
[16:13:39.530]                         }
[16:13:39.530]                       }
[16:13:39.530]                       invisible(muffled)
[16:13:39.530]                     }
[16:13:39.530]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.530]                   }
[16:13:39.530]                 }
[16:13:39.530]                 else {
[16:13:39.530]                   if (TRUE) {
[16:13:39.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.530]                     {
[16:13:39.530]                       inherits <- base::inherits
[16:13:39.530]                       invokeRestart <- base::invokeRestart
[16:13:39.530]                       is.null <- base::is.null
[16:13:39.530]                       muffled <- FALSE
[16:13:39.530]                       if (inherits(cond, "message")) {
[16:13:39.530]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.530]                         if (muffled) 
[16:13:39.530]                           invokeRestart("muffleMessage")
[16:13:39.530]                       }
[16:13:39.530]                       else if (inherits(cond, "warning")) {
[16:13:39.530]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.530]                         if (muffled) 
[16:13:39.530]                           invokeRestart("muffleWarning")
[16:13:39.530]                       }
[16:13:39.530]                       else if (inherits(cond, "condition")) {
[16:13:39.530]                         if (!is.null(pattern)) {
[16:13:39.530]                           computeRestarts <- base::computeRestarts
[16:13:39.530]                           grepl <- base::grepl
[16:13:39.530]                           restarts <- computeRestarts(cond)
[16:13:39.530]                           for (restart in restarts) {
[16:13:39.530]                             name <- restart$name
[16:13:39.530]                             if (is.null(name)) 
[16:13:39.530]                               next
[16:13:39.530]                             if (!grepl(pattern, name)) 
[16:13:39.530]                               next
[16:13:39.530]                             invokeRestart(restart)
[16:13:39.530]                             muffled <- TRUE
[16:13:39.530]                             break
[16:13:39.530]                           }
[16:13:39.530]                         }
[16:13:39.530]                       }
[16:13:39.530]                       invisible(muffled)
[16:13:39.530]                     }
[16:13:39.530]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.530]                   }
[16:13:39.530]                 }
[16:13:39.530]             }
[16:13:39.530]         }))
[16:13:39.530]     }, error = function(ex) {
[16:13:39.530]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:39.530]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.530]                 ...future.rng), started = ...future.startTime, 
[16:13:39.530]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:39.530]             version = "1.8"), class = "FutureResult")
[16:13:39.530]     }, finally = {
[16:13:39.530]         if (!identical(...future.workdir, getwd())) 
[16:13:39.530]             setwd(...future.workdir)
[16:13:39.530]         {
[16:13:39.530]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:39.530]                 ...future.oldOptions$nwarnings <- NULL
[16:13:39.530]             }
[16:13:39.530]             base::options(...future.oldOptions)
[16:13:39.530]             if (.Platform$OS.type == "windows") {
[16:13:39.530]                 old_names <- names(...future.oldEnvVars)
[16:13:39.530]                 envs <- base::Sys.getenv()
[16:13:39.530]                 names <- names(envs)
[16:13:39.530]                 common <- intersect(names, old_names)
[16:13:39.530]                 added <- setdiff(names, old_names)
[16:13:39.530]                 removed <- setdiff(old_names, names)
[16:13:39.530]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:39.530]                   envs[common]]
[16:13:39.530]                 NAMES <- toupper(changed)
[16:13:39.530]                 args <- list()
[16:13:39.530]                 for (kk in seq_along(NAMES)) {
[16:13:39.530]                   name <- changed[[kk]]
[16:13:39.530]                   NAME <- NAMES[[kk]]
[16:13:39.530]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.530]                     next
[16:13:39.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.530]                 }
[16:13:39.530]                 NAMES <- toupper(added)
[16:13:39.530]                 for (kk in seq_along(NAMES)) {
[16:13:39.530]                   name <- added[[kk]]
[16:13:39.530]                   NAME <- NAMES[[kk]]
[16:13:39.530]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.530]                     next
[16:13:39.530]                   args[[name]] <- ""
[16:13:39.530]                 }
[16:13:39.530]                 NAMES <- toupper(removed)
[16:13:39.530]                 for (kk in seq_along(NAMES)) {
[16:13:39.530]                   name <- removed[[kk]]
[16:13:39.530]                   NAME <- NAMES[[kk]]
[16:13:39.530]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.530]                     next
[16:13:39.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.530]                 }
[16:13:39.530]                 if (length(args) > 0) 
[16:13:39.530]                   base::do.call(base::Sys.setenv, args = args)
[16:13:39.530]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:39.530]             }
[16:13:39.530]             else {
[16:13:39.530]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:39.530]             }
[16:13:39.530]             {
[16:13:39.530]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:39.530]                   0L) {
[16:13:39.530]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:39.530]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:39.530]                   base::options(opts)
[16:13:39.530]                 }
[16:13:39.530]                 {
[16:13:39.530]                   {
[16:13:39.530]                     NULL
[16:13:39.530]                     RNGkind("Mersenne-Twister")
[16:13:39.530]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:39.530]                       inherits = FALSE)
[16:13:39.530]                   }
[16:13:39.530]                   options(future.plan = NULL)
[16:13:39.530]                   if (is.na(NA_character_)) 
[16:13:39.530]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.530]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:39.530]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:39.530]                   {
[16:13:39.530]                     future <- SequentialFuture(..., envir = envir)
[16:13:39.530]                     if (!future$lazy) 
[16:13:39.530]                       future <- run(future)
[16:13:39.530]                     invisible(future)
[16:13:39.530]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:39.530]                 }
[16:13:39.530]             }
[16:13:39.530]         }
[16:13:39.530]     })
[16:13:39.530]     if (TRUE) {
[16:13:39.530]         base::sink(type = "output", split = FALSE)
[16:13:39.530]         if (TRUE) {
[16:13:39.530]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:39.530]         }
[16:13:39.530]         else {
[16:13:39.530]             ...future.result["stdout"] <- base::list(NULL)
[16:13:39.530]         }
[16:13:39.530]         base::close(...future.stdout)
[16:13:39.530]         ...future.stdout <- NULL
[16:13:39.530]     }
[16:13:39.530]     ...future.result$conditions <- ...future.conditions
[16:13:39.530]     ...future.result$finished <- base::Sys.time()
[16:13:39.530]     ...future.result
[16:13:39.530] }
[16:13:39.532] assign_globals() ...
[16:13:39.532] List of 1
[16:13:39.532]  $ kk: int 1
[16:13:39.532]  - attr(*, "where")=List of 1
[16:13:39.532]   ..$ kk:<environment: R_EmptyEnv> 
[16:13:39.532]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:39.532]  - attr(*, "resolved")= logi FALSE
[16:13:39.532]  - attr(*, "total_size")= num 56
[16:13:39.532]  - attr(*, "already-done")= logi TRUE
[16:13:39.534] - copied ‘kk’ to environment
[16:13:39.534] assign_globals() ... done
[16:13:39.535] plan(): Setting new future strategy stack:
[16:13:39.535] List of future strategies:
[16:13:39.535] 1. sequential:
[16:13:39.535]    - args: function (..., envir = parent.frame())
[16:13:39.535]    - tweaked: FALSE
[16:13:39.535]    - call: NULL
[16:13:39.535] plan(): nbrOfWorkers() = 1
[16:13:39.636] plan(): Setting new future strategy stack:
[16:13:39.637] List of future strategies:
[16:13:39.637] 1. sequential:
[16:13:39.637]    - args: function (..., envir = parent.frame())
[16:13:39.637]    - tweaked: FALSE
[16:13:39.637]    - call: plan(strategy)
[16:13:39.637] plan(): nbrOfWorkers() = 1
[16:13:39.637] SequentialFuture started (and completed)
[16:13:39.637] - Launch lazy future ... done
[16:13:39.637] run() for ‘SequentialFuture’ ... done
[16:13:39.638] resolved() for ‘SequentialFuture’ ...
[16:13:39.638] - state: ‘finished’
[16:13:39.638] - run: TRUE
[16:13:39.638] - result: ‘FutureResult’
[16:13:39.638] resolved() for ‘SequentialFuture’ ... done
[16:13:39.638] Future #1
[16:13:39.638]  length: 2 (resolved future 1)
[16:13:39.638] run() for ‘Future’ ...
[16:13:39.638] - state: ‘created’
[16:13:39.638] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:39.639] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:39.639] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:39.639]   - Field: ‘label’
[16:13:39.639]   - Field: ‘local’
[16:13:39.639]   - Field: ‘owner’
[16:13:39.639]   - Field: ‘envir’
[16:13:39.639]   - Field: ‘packages’
[16:13:39.640]   - Field: ‘gc’
[16:13:39.640]   - Field: ‘conditions’
[16:13:39.640]   - Field: ‘expr’
[16:13:39.640]   - Field: ‘uuid’
[16:13:39.640]   - Field: ‘seed’
[16:13:39.640]   - Field: ‘version’
[16:13:39.640]   - Field: ‘result’
[16:13:39.640]   - Field: ‘asynchronous’
[16:13:39.640]   - Field: ‘calls’
[16:13:39.640]   - Field: ‘globals’
[16:13:39.640]   - Field: ‘stdout’
[16:13:39.641]   - Field: ‘earlySignal’
[16:13:39.641]   - Field: ‘lazy’
[16:13:39.641]   - Field: ‘state’
[16:13:39.641] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:39.641] - Launch lazy future ...
[16:13:39.641] Packages needed by the future expression (n = 0): <none>
[16:13:39.641] Packages needed by future strategies (n = 0): <none>
[16:13:39.642] {
[16:13:39.642]     {
[16:13:39.642]         {
[16:13:39.642]             ...future.startTime <- base::Sys.time()
[16:13:39.642]             {
[16:13:39.642]                 {
[16:13:39.642]                   {
[16:13:39.642]                     base::local({
[16:13:39.642]                       has_future <- base::requireNamespace("future", 
[16:13:39.642]                         quietly = TRUE)
[16:13:39.642]                       if (has_future) {
[16:13:39.642]                         ns <- base::getNamespace("future")
[16:13:39.642]                         version <- ns[[".package"]][["version"]]
[16:13:39.642]                         if (is.null(version)) 
[16:13:39.642]                           version <- utils::packageVersion("future")
[16:13:39.642]                       }
[16:13:39.642]                       else {
[16:13:39.642]                         version <- NULL
[16:13:39.642]                       }
[16:13:39.642]                       if (!has_future || version < "1.8.0") {
[16:13:39.642]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:39.642]                           "", base::R.version$version.string), 
[16:13:39.642]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:39.642]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:39.642]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:39.642]                             "release", "version")], collapse = " "), 
[16:13:39.642]                           hostname = base::Sys.info()[["nodename"]])
[16:13:39.642]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:39.642]                           info)
[16:13:39.642]                         info <- base::paste(info, collapse = "; ")
[16:13:39.642]                         if (!has_future) {
[16:13:39.642]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:39.642]                             info)
[16:13:39.642]                         }
[16:13:39.642]                         else {
[16:13:39.642]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:39.642]                             info, version)
[16:13:39.642]                         }
[16:13:39.642]                         base::stop(msg)
[16:13:39.642]                       }
[16:13:39.642]                     })
[16:13:39.642]                   }
[16:13:39.642]                   options(future.plan = NULL)
[16:13:39.642]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.642]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:39.642]                 }
[16:13:39.642]                 ...future.workdir <- getwd()
[16:13:39.642]             }
[16:13:39.642]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:39.642]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:39.642]         }
[16:13:39.642]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:39.642]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:39.642]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:39.642]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:39.642]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:39.642]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:39.642]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:39.642]             base::names(...future.oldOptions))
[16:13:39.642]     }
[16:13:39.642]     if (FALSE) {
[16:13:39.642]     }
[16:13:39.642]     else {
[16:13:39.642]         if (TRUE) {
[16:13:39.642]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:39.642]                 open = "w")
[16:13:39.642]         }
[16:13:39.642]         else {
[16:13:39.642]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:39.642]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:39.642]         }
[16:13:39.642]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:39.642]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:39.642]             base::sink(type = "output", split = FALSE)
[16:13:39.642]             base::close(...future.stdout)
[16:13:39.642]         }, add = TRUE)
[16:13:39.642]     }
[16:13:39.642]     ...future.frame <- base::sys.nframe()
[16:13:39.642]     ...future.conditions <- base::list()
[16:13:39.642]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:39.642]     if (FALSE) {
[16:13:39.642]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:39.642]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:39.642]     }
[16:13:39.642]     ...future.result <- base::tryCatch({
[16:13:39.642]         base::withCallingHandlers({
[16:13:39.642]             ...future.value <- base::withVisible(base::local({
[16:13:39.642]                 Sys.sleep(0.1)
[16:13:39.642]                 kk
[16:13:39.642]             }))
[16:13:39.642]             future::FutureResult(value = ...future.value$value, 
[16:13:39.642]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.642]                   ...future.rng), globalenv = if (FALSE) 
[16:13:39.642]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:39.642]                     ...future.globalenv.names))
[16:13:39.642]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:39.642]         }, condition = base::local({
[16:13:39.642]             c <- base::c
[16:13:39.642]             inherits <- base::inherits
[16:13:39.642]             invokeRestart <- base::invokeRestart
[16:13:39.642]             length <- base::length
[16:13:39.642]             list <- base::list
[16:13:39.642]             seq.int <- base::seq.int
[16:13:39.642]             signalCondition <- base::signalCondition
[16:13:39.642]             sys.calls <- base::sys.calls
[16:13:39.642]             `[[` <- base::`[[`
[16:13:39.642]             `+` <- base::`+`
[16:13:39.642]             `<<-` <- base::`<<-`
[16:13:39.642]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:39.642]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:39.642]                   3L)]
[16:13:39.642]             }
[16:13:39.642]             function(cond) {
[16:13:39.642]                 is_error <- inherits(cond, "error")
[16:13:39.642]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:39.642]                   NULL)
[16:13:39.642]                 if (is_error) {
[16:13:39.642]                   sessionInformation <- function() {
[16:13:39.642]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:39.642]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:39.642]                       search = base::search(), system = base::Sys.info())
[16:13:39.642]                   }
[16:13:39.642]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.642]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:39.642]                     cond$call), session = sessionInformation(), 
[16:13:39.642]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:39.642]                   signalCondition(cond)
[16:13:39.642]                 }
[16:13:39.642]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:39.642]                 "immediateCondition"))) {
[16:13:39.642]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:39.642]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.642]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:39.642]                   if (TRUE && !signal) {
[16:13:39.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.642]                     {
[16:13:39.642]                       inherits <- base::inherits
[16:13:39.642]                       invokeRestart <- base::invokeRestart
[16:13:39.642]                       is.null <- base::is.null
[16:13:39.642]                       muffled <- FALSE
[16:13:39.642]                       if (inherits(cond, "message")) {
[16:13:39.642]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.642]                         if (muffled) 
[16:13:39.642]                           invokeRestart("muffleMessage")
[16:13:39.642]                       }
[16:13:39.642]                       else if (inherits(cond, "warning")) {
[16:13:39.642]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.642]                         if (muffled) 
[16:13:39.642]                           invokeRestart("muffleWarning")
[16:13:39.642]                       }
[16:13:39.642]                       else if (inherits(cond, "condition")) {
[16:13:39.642]                         if (!is.null(pattern)) {
[16:13:39.642]                           computeRestarts <- base::computeRestarts
[16:13:39.642]                           grepl <- base::grepl
[16:13:39.642]                           restarts <- computeRestarts(cond)
[16:13:39.642]                           for (restart in restarts) {
[16:13:39.642]                             name <- restart$name
[16:13:39.642]                             if (is.null(name)) 
[16:13:39.642]                               next
[16:13:39.642]                             if (!grepl(pattern, name)) 
[16:13:39.642]                               next
[16:13:39.642]                             invokeRestart(restart)
[16:13:39.642]                             muffled <- TRUE
[16:13:39.642]                             break
[16:13:39.642]                           }
[16:13:39.642]                         }
[16:13:39.642]                       }
[16:13:39.642]                       invisible(muffled)
[16:13:39.642]                     }
[16:13:39.642]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.642]                   }
[16:13:39.642]                 }
[16:13:39.642]                 else {
[16:13:39.642]                   if (TRUE) {
[16:13:39.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.642]                     {
[16:13:39.642]                       inherits <- base::inherits
[16:13:39.642]                       invokeRestart <- base::invokeRestart
[16:13:39.642]                       is.null <- base::is.null
[16:13:39.642]                       muffled <- FALSE
[16:13:39.642]                       if (inherits(cond, "message")) {
[16:13:39.642]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.642]                         if (muffled) 
[16:13:39.642]                           invokeRestart("muffleMessage")
[16:13:39.642]                       }
[16:13:39.642]                       else if (inherits(cond, "warning")) {
[16:13:39.642]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.642]                         if (muffled) 
[16:13:39.642]                           invokeRestart("muffleWarning")
[16:13:39.642]                       }
[16:13:39.642]                       else if (inherits(cond, "condition")) {
[16:13:39.642]                         if (!is.null(pattern)) {
[16:13:39.642]                           computeRestarts <- base::computeRestarts
[16:13:39.642]                           grepl <- base::grepl
[16:13:39.642]                           restarts <- computeRestarts(cond)
[16:13:39.642]                           for (restart in restarts) {
[16:13:39.642]                             name <- restart$name
[16:13:39.642]                             if (is.null(name)) 
[16:13:39.642]                               next
[16:13:39.642]                             if (!grepl(pattern, name)) 
[16:13:39.642]                               next
[16:13:39.642]                             invokeRestart(restart)
[16:13:39.642]                             muffled <- TRUE
[16:13:39.642]                             break
[16:13:39.642]                           }
[16:13:39.642]                         }
[16:13:39.642]                       }
[16:13:39.642]                       invisible(muffled)
[16:13:39.642]                     }
[16:13:39.642]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.642]                   }
[16:13:39.642]                 }
[16:13:39.642]             }
[16:13:39.642]         }))
[16:13:39.642]     }, error = function(ex) {
[16:13:39.642]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:39.642]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.642]                 ...future.rng), started = ...future.startTime, 
[16:13:39.642]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:39.642]             version = "1.8"), class = "FutureResult")
[16:13:39.642]     }, finally = {
[16:13:39.642]         if (!identical(...future.workdir, getwd())) 
[16:13:39.642]             setwd(...future.workdir)
[16:13:39.642]         {
[16:13:39.642]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:39.642]                 ...future.oldOptions$nwarnings <- NULL
[16:13:39.642]             }
[16:13:39.642]             base::options(...future.oldOptions)
[16:13:39.642]             if (.Platform$OS.type == "windows") {
[16:13:39.642]                 old_names <- names(...future.oldEnvVars)
[16:13:39.642]                 envs <- base::Sys.getenv()
[16:13:39.642]                 names <- names(envs)
[16:13:39.642]                 common <- intersect(names, old_names)
[16:13:39.642]                 added <- setdiff(names, old_names)
[16:13:39.642]                 removed <- setdiff(old_names, names)
[16:13:39.642]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:39.642]                   envs[common]]
[16:13:39.642]                 NAMES <- toupper(changed)
[16:13:39.642]                 args <- list()
[16:13:39.642]                 for (kk in seq_along(NAMES)) {
[16:13:39.642]                   name <- changed[[kk]]
[16:13:39.642]                   NAME <- NAMES[[kk]]
[16:13:39.642]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.642]                     next
[16:13:39.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.642]                 }
[16:13:39.642]                 NAMES <- toupper(added)
[16:13:39.642]                 for (kk in seq_along(NAMES)) {
[16:13:39.642]                   name <- added[[kk]]
[16:13:39.642]                   NAME <- NAMES[[kk]]
[16:13:39.642]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.642]                     next
[16:13:39.642]                   args[[name]] <- ""
[16:13:39.642]                 }
[16:13:39.642]                 NAMES <- toupper(removed)
[16:13:39.642]                 for (kk in seq_along(NAMES)) {
[16:13:39.642]                   name <- removed[[kk]]
[16:13:39.642]                   NAME <- NAMES[[kk]]
[16:13:39.642]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.642]                     next
[16:13:39.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.642]                 }
[16:13:39.642]                 if (length(args) > 0) 
[16:13:39.642]                   base::do.call(base::Sys.setenv, args = args)
[16:13:39.642]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:39.642]             }
[16:13:39.642]             else {
[16:13:39.642]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:39.642]             }
[16:13:39.642]             {
[16:13:39.642]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:39.642]                   0L) {
[16:13:39.642]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:39.642]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:39.642]                   base::options(opts)
[16:13:39.642]                 }
[16:13:39.642]                 {
[16:13:39.642]                   {
[16:13:39.642]                     NULL
[16:13:39.642]                     RNGkind("Mersenne-Twister")
[16:13:39.642]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:39.642]                       inherits = FALSE)
[16:13:39.642]                   }
[16:13:39.642]                   options(future.plan = NULL)
[16:13:39.642]                   if (is.na(NA_character_)) 
[16:13:39.642]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.642]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:39.642]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:39.642]                   {
[16:13:39.642]                     future <- SequentialFuture(..., envir = envir)
[16:13:39.642]                     if (!future$lazy) 
[16:13:39.642]                       future <- run(future)
[16:13:39.642]                     invisible(future)
[16:13:39.642]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:39.642]                 }
[16:13:39.642]             }
[16:13:39.642]         }
[16:13:39.642]     })
[16:13:39.642]     if (TRUE) {
[16:13:39.642]         base::sink(type = "output", split = FALSE)
[16:13:39.642]         if (TRUE) {
[16:13:39.642]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:39.642]         }
[16:13:39.642]         else {
[16:13:39.642]             ...future.result["stdout"] <- base::list(NULL)
[16:13:39.642]         }
[16:13:39.642]         base::close(...future.stdout)
[16:13:39.642]         ...future.stdout <- NULL
[16:13:39.642]     }
[16:13:39.642]     ...future.result$conditions <- ...future.conditions
[16:13:39.642]     ...future.result$finished <- base::Sys.time()
[16:13:39.642]     ...future.result
[16:13:39.642] }
[16:13:39.643] assign_globals() ...
[16:13:39.643] List of 1
[16:13:39.643]  $ kk: int 2
[16:13:39.643]  - attr(*, "where")=List of 1
[16:13:39.643]   ..$ kk:<environment: R_EmptyEnv> 
[16:13:39.643]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:39.643]  - attr(*, "resolved")= logi FALSE
[16:13:39.643]  - attr(*, "total_size")= num 56
[16:13:39.643]  - attr(*, "already-done")= logi TRUE
[16:13:39.648] - copied ‘kk’ to environment
[16:13:39.648] assign_globals() ... done
[16:13:39.648] plan(): Setting new future strategy stack:
[16:13:39.648] List of future strategies:
[16:13:39.648] 1. sequential:
[16:13:39.648]    - args: function (..., envir = parent.frame())
[16:13:39.648]    - tweaked: FALSE
[16:13:39.648]    - call: NULL
[16:13:39.649] plan(): nbrOfWorkers() = 1
[16:13:39.750] plan(): Setting new future strategy stack:
[16:13:39.750] List of future strategies:
[16:13:39.750] 1. sequential:
[16:13:39.750]    - args: function (..., envir = parent.frame())
[16:13:39.750]    - tweaked: FALSE
[16:13:39.750]    - call: plan(strategy)
[16:13:39.751] plan(): nbrOfWorkers() = 1
[16:13:39.751] SequentialFuture started (and completed)
[16:13:39.751] - Launch lazy future ... done
[16:13:39.751] run() for ‘SequentialFuture’ ... done
[16:13:39.751] resolved() for ‘SequentialFuture’ ...
[16:13:39.751] - state: ‘finished’
[16:13:39.751] - run: TRUE
[16:13:39.751] - result: ‘FutureResult’
[16:13:39.752] resolved() for ‘SequentialFuture’ ... done
[16:13:39.752] Future #2
[16:13:39.752]  length: 1 (resolved future 2)
[16:13:39.752] run() for ‘Future’ ...
[16:13:39.752] - state: ‘created’
[16:13:39.752] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:39.752] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:39.753] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:39.753]   - Field: ‘label’
[16:13:39.753]   - Field: ‘local’
[16:13:39.753]   - Field: ‘owner’
[16:13:39.753]   - Field: ‘envir’
[16:13:39.753]   - Field: ‘packages’
[16:13:39.753]   - Field: ‘gc’
[16:13:39.753]   - Field: ‘conditions’
[16:13:39.753]   - Field: ‘expr’
[16:13:39.753]   - Field: ‘uuid’
[16:13:39.754]   - Field: ‘seed’
[16:13:39.754]   - Field: ‘version’
[16:13:39.754]   - Field: ‘result’
[16:13:39.754]   - Field: ‘asynchronous’
[16:13:39.754]   - Field: ‘calls’
[16:13:39.754]   - Field: ‘globals’
[16:13:39.754]   - Field: ‘stdout’
[16:13:39.754]   - Field: ‘earlySignal’
[16:13:39.754]   - Field: ‘lazy’
[16:13:39.754]   - Field: ‘state’
[16:13:39.754] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:39.755] - Launch lazy future ...
[16:13:39.755] Packages needed by the future expression (n = 0): <none>
[16:13:39.755] Packages needed by future strategies (n = 0): <none>
[16:13:39.755] {
[16:13:39.755]     {
[16:13:39.755]         {
[16:13:39.755]             ...future.startTime <- base::Sys.time()
[16:13:39.755]             {
[16:13:39.755]                 {
[16:13:39.755]                   {
[16:13:39.755]                     base::local({
[16:13:39.755]                       has_future <- base::requireNamespace("future", 
[16:13:39.755]                         quietly = TRUE)
[16:13:39.755]                       if (has_future) {
[16:13:39.755]                         ns <- base::getNamespace("future")
[16:13:39.755]                         version <- ns[[".package"]][["version"]]
[16:13:39.755]                         if (is.null(version)) 
[16:13:39.755]                           version <- utils::packageVersion("future")
[16:13:39.755]                       }
[16:13:39.755]                       else {
[16:13:39.755]                         version <- NULL
[16:13:39.755]                       }
[16:13:39.755]                       if (!has_future || version < "1.8.0") {
[16:13:39.755]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:39.755]                           "", base::R.version$version.string), 
[16:13:39.755]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:39.755]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:39.755]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:39.755]                             "release", "version")], collapse = " "), 
[16:13:39.755]                           hostname = base::Sys.info()[["nodename"]])
[16:13:39.755]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:39.755]                           info)
[16:13:39.755]                         info <- base::paste(info, collapse = "; ")
[16:13:39.755]                         if (!has_future) {
[16:13:39.755]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:39.755]                             info)
[16:13:39.755]                         }
[16:13:39.755]                         else {
[16:13:39.755]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:39.755]                             info, version)
[16:13:39.755]                         }
[16:13:39.755]                         base::stop(msg)
[16:13:39.755]                       }
[16:13:39.755]                     })
[16:13:39.755]                   }
[16:13:39.755]                   options(future.plan = NULL)
[16:13:39.755]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.755]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:39.755]                 }
[16:13:39.755]                 ...future.workdir <- getwd()
[16:13:39.755]             }
[16:13:39.755]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:39.755]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:39.755]         }
[16:13:39.755]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:39.755]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:39.755]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:39.755]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:39.755]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:39.755]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:39.755]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:39.755]             base::names(...future.oldOptions))
[16:13:39.755]     }
[16:13:39.755]     if (FALSE) {
[16:13:39.755]     }
[16:13:39.755]     else {
[16:13:39.755]         if (TRUE) {
[16:13:39.755]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:39.755]                 open = "w")
[16:13:39.755]         }
[16:13:39.755]         else {
[16:13:39.755]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:39.755]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:39.755]         }
[16:13:39.755]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:39.755]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:39.755]             base::sink(type = "output", split = FALSE)
[16:13:39.755]             base::close(...future.stdout)
[16:13:39.755]         }, add = TRUE)
[16:13:39.755]     }
[16:13:39.755]     ...future.frame <- base::sys.nframe()
[16:13:39.755]     ...future.conditions <- base::list()
[16:13:39.755]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:39.755]     if (FALSE) {
[16:13:39.755]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:39.755]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:39.755]     }
[16:13:39.755]     ...future.result <- base::tryCatch({
[16:13:39.755]         base::withCallingHandlers({
[16:13:39.755]             ...future.value <- base::withVisible(base::local({
[16:13:39.755]                 Sys.sleep(0.1)
[16:13:39.755]                 kk
[16:13:39.755]             }))
[16:13:39.755]             future::FutureResult(value = ...future.value$value, 
[16:13:39.755]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.755]                   ...future.rng), globalenv = if (FALSE) 
[16:13:39.755]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:39.755]                     ...future.globalenv.names))
[16:13:39.755]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:39.755]         }, condition = base::local({
[16:13:39.755]             c <- base::c
[16:13:39.755]             inherits <- base::inherits
[16:13:39.755]             invokeRestart <- base::invokeRestart
[16:13:39.755]             length <- base::length
[16:13:39.755]             list <- base::list
[16:13:39.755]             seq.int <- base::seq.int
[16:13:39.755]             signalCondition <- base::signalCondition
[16:13:39.755]             sys.calls <- base::sys.calls
[16:13:39.755]             `[[` <- base::`[[`
[16:13:39.755]             `+` <- base::`+`
[16:13:39.755]             `<<-` <- base::`<<-`
[16:13:39.755]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:39.755]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:39.755]                   3L)]
[16:13:39.755]             }
[16:13:39.755]             function(cond) {
[16:13:39.755]                 is_error <- inherits(cond, "error")
[16:13:39.755]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:39.755]                   NULL)
[16:13:39.755]                 if (is_error) {
[16:13:39.755]                   sessionInformation <- function() {
[16:13:39.755]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:39.755]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:39.755]                       search = base::search(), system = base::Sys.info())
[16:13:39.755]                   }
[16:13:39.755]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.755]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:39.755]                     cond$call), session = sessionInformation(), 
[16:13:39.755]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:39.755]                   signalCondition(cond)
[16:13:39.755]                 }
[16:13:39.755]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:39.755]                 "immediateCondition"))) {
[16:13:39.755]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:39.755]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.755]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:39.755]                   if (TRUE && !signal) {
[16:13:39.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.755]                     {
[16:13:39.755]                       inherits <- base::inherits
[16:13:39.755]                       invokeRestart <- base::invokeRestart
[16:13:39.755]                       is.null <- base::is.null
[16:13:39.755]                       muffled <- FALSE
[16:13:39.755]                       if (inherits(cond, "message")) {
[16:13:39.755]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.755]                         if (muffled) 
[16:13:39.755]                           invokeRestart("muffleMessage")
[16:13:39.755]                       }
[16:13:39.755]                       else if (inherits(cond, "warning")) {
[16:13:39.755]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.755]                         if (muffled) 
[16:13:39.755]                           invokeRestart("muffleWarning")
[16:13:39.755]                       }
[16:13:39.755]                       else if (inherits(cond, "condition")) {
[16:13:39.755]                         if (!is.null(pattern)) {
[16:13:39.755]                           computeRestarts <- base::computeRestarts
[16:13:39.755]                           grepl <- base::grepl
[16:13:39.755]                           restarts <- computeRestarts(cond)
[16:13:39.755]                           for (restart in restarts) {
[16:13:39.755]                             name <- restart$name
[16:13:39.755]                             if (is.null(name)) 
[16:13:39.755]                               next
[16:13:39.755]                             if (!grepl(pattern, name)) 
[16:13:39.755]                               next
[16:13:39.755]                             invokeRestart(restart)
[16:13:39.755]                             muffled <- TRUE
[16:13:39.755]                             break
[16:13:39.755]                           }
[16:13:39.755]                         }
[16:13:39.755]                       }
[16:13:39.755]                       invisible(muffled)
[16:13:39.755]                     }
[16:13:39.755]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.755]                   }
[16:13:39.755]                 }
[16:13:39.755]                 else {
[16:13:39.755]                   if (TRUE) {
[16:13:39.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.755]                     {
[16:13:39.755]                       inherits <- base::inherits
[16:13:39.755]                       invokeRestart <- base::invokeRestart
[16:13:39.755]                       is.null <- base::is.null
[16:13:39.755]                       muffled <- FALSE
[16:13:39.755]                       if (inherits(cond, "message")) {
[16:13:39.755]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.755]                         if (muffled) 
[16:13:39.755]                           invokeRestart("muffleMessage")
[16:13:39.755]                       }
[16:13:39.755]                       else if (inherits(cond, "warning")) {
[16:13:39.755]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.755]                         if (muffled) 
[16:13:39.755]                           invokeRestart("muffleWarning")
[16:13:39.755]                       }
[16:13:39.755]                       else if (inherits(cond, "condition")) {
[16:13:39.755]                         if (!is.null(pattern)) {
[16:13:39.755]                           computeRestarts <- base::computeRestarts
[16:13:39.755]                           grepl <- base::grepl
[16:13:39.755]                           restarts <- computeRestarts(cond)
[16:13:39.755]                           for (restart in restarts) {
[16:13:39.755]                             name <- restart$name
[16:13:39.755]                             if (is.null(name)) 
[16:13:39.755]                               next
[16:13:39.755]                             if (!grepl(pattern, name)) 
[16:13:39.755]                               next
[16:13:39.755]                             invokeRestart(restart)
[16:13:39.755]                             muffled <- TRUE
[16:13:39.755]                             break
[16:13:39.755]                           }
[16:13:39.755]                         }
[16:13:39.755]                       }
[16:13:39.755]                       invisible(muffled)
[16:13:39.755]                     }
[16:13:39.755]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.755]                   }
[16:13:39.755]                 }
[16:13:39.755]             }
[16:13:39.755]         }))
[16:13:39.755]     }, error = function(ex) {
[16:13:39.755]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:39.755]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.755]                 ...future.rng), started = ...future.startTime, 
[16:13:39.755]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:39.755]             version = "1.8"), class = "FutureResult")
[16:13:39.755]     }, finally = {
[16:13:39.755]         if (!identical(...future.workdir, getwd())) 
[16:13:39.755]             setwd(...future.workdir)
[16:13:39.755]         {
[16:13:39.755]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:39.755]                 ...future.oldOptions$nwarnings <- NULL
[16:13:39.755]             }
[16:13:39.755]             base::options(...future.oldOptions)
[16:13:39.755]             if (.Platform$OS.type == "windows") {
[16:13:39.755]                 old_names <- names(...future.oldEnvVars)
[16:13:39.755]                 envs <- base::Sys.getenv()
[16:13:39.755]                 names <- names(envs)
[16:13:39.755]                 common <- intersect(names, old_names)
[16:13:39.755]                 added <- setdiff(names, old_names)
[16:13:39.755]                 removed <- setdiff(old_names, names)
[16:13:39.755]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:39.755]                   envs[common]]
[16:13:39.755]                 NAMES <- toupper(changed)
[16:13:39.755]                 args <- list()
[16:13:39.755]                 for (kk in seq_along(NAMES)) {
[16:13:39.755]                   name <- changed[[kk]]
[16:13:39.755]                   NAME <- NAMES[[kk]]
[16:13:39.755]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.755]                     next
[16:13:39.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.755]                 }
[16:13:39.755]                 NAMES <- toupper(added)
[16:13:39.755]                 for (kk in seq_along(NAMES)) {
[16:13:39.755]                   name <- added[[kk]]
[16:13:39.755]                   NAME <- NAMES[[kk]]
[16:13:39.755]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.755]                     next
[16:13:39.755]                   args[[name]] <- ""
[16:13:39.755]                 }
[16:13:39.755]                 NAMES <- toupper(removed)
[16:13:39.755]                 for (kk in seq_along(NAMES)) {
[16:13:39.755]                   name <- removed[[kk]]
[16:13:39.755]                   NAME <- NAMES[[kk]]
[16:13:39.755]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.755]                     next
[16:13:39.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.755]                 }
[16:13:39.755]                 if (length(args) > 0) 
[16:13:39.755]                   base::do.call(base::Sys.setenv, args = args)
[16:13:39.755]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:39.755]             }
[16:13:39.755]             else {
[16:13:39.755]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:39.755]             }
[16:13:39.755]             {
[16:13:39.755]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:39.755]                   0L) {
[16:13:39.755]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:39.755]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:39.755]                   base::options(opts)
[16:13:39.755]                 }
[16:13:39.755]                 {
[16:13:39.755]                   {
[16:13:39.755]                     NULL
[16:13:39.755]                     RNGkind("Mersenne-Twister")
[16:13:39.755]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:39.755]                       inherits = FALSE)
[16:13:39.755]                   }
[16:13:39.755]                   options(future.plan = NULL)
[16:13:39.755]                   if (is.na(NA_character_)) 
[16:13:39.755]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.755]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:39.755]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:39.755]                   {
[16:13:39.755]                     future <- SequentialFuture(..., envir = envir)
[16:13:39.755]                     if (!future$lazy) 
[16:13:39.755]                       future <- run(future)
[16:13:39.755]                     invisible(future)
[16:13:39.755]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:39.755]                 }
[16:13:39.755]             }
[16:13:39.755]         }
[16:13:39.755]     })
[16:13:39.755]     if (TRUE) {
[16:13:39.755]         base::sink(type = "output", split = FALSE)
[16:13:39.755]         if (TRUE) {
[16:13:39.755]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:39.755]         }
[16:13:39.755]         else {
[16:13:39.755]             ...future.result["stdout"] <- base::list(NULL)
[16:13:39.755]         }
[16:13:39.755]         base::close(...future.stdout)
[16:13:39.755]         ...future.stdout <- NULL
[16:13:39.755]     }
[16:13:39.755]     ...future.result$conditions <- ...future.conditions
[16:13:39.755]     ...future.result$finished <- base::Sys.time()
[16:13:39.755]     ...future.result
[16:13:39.755] }
[16:13:39.757] assign_globals() ...
[16:13:39.757] List of 1
[16:13:39.757]  $ kk: int 3
[16:13:39.757]  - attr(*, "where")=List of 1
[16:13:39.757]   ..$ kk:<environment: R_EmptyEnv> 
[16:13:39.757]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:39.757]  - attr(*, "resolved")= logi FALSE
[16:13:39.757]  - attr(*, "total_size")= num 56
[16:13:39.757]  - attr(*, "already-done")= logi TRUE
[16:13:39.760] - copied ‘kk’ to environment
[16:13:39.760] assign_globals() ... done
[16:13:39.760] plan(): Setting new future strategy stack:
[16:13:39.760] List of future strategies:
[16:13:39.760] 1. sequential:
[16:13:39.760]    - args: function (..., envir = parent.frame())
[16:13:39.760]    - tweaked: FALSE
[16:13:39.760]    - call: NULL
[16:13:39.761] plan(): nbrOfWorkers() = 1
[16:13:39.862] plan(): Setting new future strategy stack:
[16:13:39.862] List of future strategies:
[16:13:39.862] 1. sequential:
[16:13:39.862]    - args: function (..., envir = parent.frame())
[16:13:39.862]    - tweaked: FALSE
[16:13:39.862]    - call: plan(strategy)
[16:13:39.863] plan(): nbrOfWorkers() = 1
[16:13:39.863] SequentialFuture started (and completed)
[16:13:39.863] - Launch lazy future ... done
[16:13:39.863] run() for ‘SequentialFuture’ ... done
[16:13:39.863] resolved() for ‘SequentialFuture’ ...
[16:13:39.863] - state: ‘finished’
[16:13:39.863] - run: TRUE
[16:13:39.863] - result: ‘FutureResult’
[16:13:39.863] resolved() for ‘SequentialFuture’ ... done
[16:13:39.864] Future #3
[16:13:39.864]  length: 0 (resolved future 3)
[16:13:39.864] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[16:13:39.865] resolve() on environment ...
[16:13:39.865]  recursive: 0
[16:13:39.866]  elements: [2] ‘a’, ‘b’
[16:13:39.866]  length: 1 (resolved future 1)
[16:13:39.866]  length: 0 (resolved future 2)
[16:13:39.866] resolve() on environment ... DONE
[16:13:39.867] getGlobalsAndPackages() ...
[16:13:39.867] Searching for globals...
[16:13:39.867] 
[16:13:39.867] Searching for globals ... DONE
[16:13:39.867] - globals: [0] <none>
[16:13:39.867] getGlobalsAndPackages() ... DONE
[16:13:39.868] run() for ‘Future’ ...
[16:13:39.868] - state: ‘created’
[16:13:39.868] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:39.868] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:39.868] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:39.868]   - Field: ‘label’
[16:13:39.868]   - Field: ‘local’
[16:13:39.869]   - Field: ‘owner’
[16:13:39.869]   - Field: ‘envir’
[16:13:39.869]   - Field: ‘packages’
[16:13:39.869]   - Field: ‘gc’
[16:13:39.869]   - Field: ‘conditions’
[16:13:39.869]   - Field: ‘expr’
[16:13:39.869]   - Field: ‘uuid’
[16:13:39.869]   - Field: ‘seed’
[16:13:39.869]   - Field: ‘version’
[16:13:39.869]   - Field: ‘result’
[16:13:39.869]   - Field: ‘asynchronous’
[16:13:39.870]   - Field: ‘calls’
[16:13:39.870]   - Field: ‘globals’
[16:13:39.870]   - Field: ‘stdout’
[16:13:39.870]   - Field: ‘earlySignal’
[16:13:39.870]   - Field: ‘lazy’
[16:13:39.870]   - Field: ‘state’
[16:13:39.870] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:39.870] - Launch lazy future ...
[16:13:39.870] Packages needed by the future expression (n = 0): <none>
[16:13:39.871] Packages needed by future strategies (n = 0): <none>
[16:13:39.871] {
[16:13:39.871]     {
[16:13:39.871]         {
[16:13:39.871]             ...future.startTime <- base::Sys.time()
[16:13:39.871]             {
[16:13:39.871]                 {
[16:13:39.871]                   {
[16:13:39.871]                     base::local({
[16:13:39.871]                       has_future <- base::requireNamespace("future", 
[16:13:39.871]                         quietly = TRUE)
[16:13:39.871]                       if (has_future) {
[16:13:39.871]                         ns <- base::getNamespace("future")
[16:13:39.871]                         version <- ns[[".package"]][["version"]]
[16:13:39.871]                         if (is.null(version)) 
[16:13:39.871]                           version <- utils::packageVersion("future")
[16:13:39.871]                       }
[16:13:39.871]                       else {
[16:13:39.871]                         version <- NULL
[16:13:39.871]                       }
[16:13:39.871]                       if (!has_future || version < "1.8.0") {
[16:13:39.871]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:39.871]                           "", base::R.version$version.string), 
[16:13:39.871]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:39.871]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:39.871]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:39.871]                             "release", "version")], collapse = " "), 
[16:13:39.871]                           hostname = base::Sys.info()[["nodename"]])
[16:13:39.871]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:39.871]                           info)
[16:13:39.871]                         info <- base::paste(info, collapse = "; ")
[16:13:39.871]                         if (!has_future) {
[16:13:39.871]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:39.871]                             info)
[16:13:39.871]                         }
[16:13:39.871]                         else {
[16:13:39.871]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:39.871]                             info, version)
[16:13:39.871]                         }
[16:13:39.871]                         base::stop(msg)
[16:13:39.871]                       }
[16:13:39.871]                     })
[16:13:39.871]                   }
[16:13:39.871]                   options(future.plan = NULL)
[16:13:39.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:39.871]                 }
[16:13:39.871]                 ...future.workdir <- getwd()
[16:13:39.871]             }
[16:13:39.871]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:39.871]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:39.871]         }
[16:13:39.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:39.871]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:39.871]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:39.871]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:39.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:39.871]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:39.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:39.871]             base::names(...future.oldOptions))
[16:13:39.871]     }
[16:13:39.871]     if (FALSE) {
[16:13:39.871]     }
[16:13:39.871]     else {
[16:13:39.871]         if (TRUE) {
[16:13:39.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:39.871]                 open = "w")
[16:13:39.871]         }
[16:13:39.871]         else {
[16:13:39.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:39.871]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:39.871]         }
[16:13:39.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:39.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:39.871]             base::sink(type = "output", split = FALSE)
[16:13:39.871]             base::close(...future.stdout)
[16:13:39.871]         }, add = TRUE)
[16:13:39.871]     }
[16:13:39.871]     ...future.frame <- base::sys.nframe()
[16:13:39.871]     ...future.conditions <- base::list()
[16:13:39.871]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:39.871]     if (FALSE) {
[16:13:39.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:39.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:39.871]     }
[16:13:39.871]     ...future.result <- base::tryCatch({
[16:13:39.871]         base::withCallingHandlers({
[16:13:39.871]             ...future.value <- base::withVisible(base::local(1))
[16:13:39.871]             future::FutureResult(value = ...future.value$value, 
[16:13:39.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.871]                   ...future.rng), globalenv = if (FALSE) 
[16:13:39.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:39.871]                     ...future.globalenv.names))
[16:13:39.871]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:39.871]         }, condition = base::local({
[16:13:39.871]             c <- base::c
[16:13:39.871]             inherits <- base::inherits
[16:13:39.871]             invokeRestart <- base::invokeRestart
[16:13:39.871]             length <- base::length
[16:13:39.871]             list <- base::list
[16:13:39.871]             seq.int <- base::seq.int
[16:13:39.871]             signalCondition <- base::signalCondition
[16:13:39.871]             sys.calls <- base::sys.calls
[16:13:39.871]             `[[` <- base::`[[`
[16:13:39.871]             `+` <- base::`+`
[16:13:39.871]             `<<-` <- base::`<<-`
[16:13:39.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:39.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:39.871]                   3L)]
[16:13:39.871]             }
[16:13:39.871]             function(cond) {
[16:13:39.871]                 is_error <- inherits(cond, "error")
[16:13:39.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:39.871]                   NULL)
[16:13:39.871]                 if (is_error) {
[16:13:39.871]                   sessionInformation <- function() {
[16:13:39.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:39.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:39.871]                       search = base::search(), system = base::Sys.info())
[16:13:39.871]                   }
[16:13:39.871]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:39.871]                     cond$call), session = sessionInformation(), 
[16:13:39.871]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:39.871]                   signalCondition(cond)
[16:13:39.871]                 }
[16:13:39.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:39.871]                 "immediateCondition"))) {
[16:13:39.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:39.871]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:39.871]                   if (TRUE && !signal) {
[16:13:39.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.871]                     {
[16:13:39.871]                       inherits <- base::inherits
[16:13:39.871]                       invokeRestart <- base::invokeRestart
[16:13:39.871]                       is.null <- base::is.null
[16:13:39.871]                       muffled <- FALSE
[16:13:39.871]                       if (inherits(cond, "message")) {
[16:13:39.871]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.871]                         if (muffled) 
[16:13:39.871]                           invokeRestart("muffleMessage")
[16:13:39.871]                       }
[16:13:39.871]                       else if (inherits(cond, "warning")) {
[16:13:39.871]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.871]                         if (muffled) 
[16:13:39.871]                           invokeRestart("muffleWarning")
[16:13:39.871]                       }
[16:13:39.871]                       else if (inherits(cond, "condition")) {
[16:13:39.871]                         if (!is.null(pattern)) {
[16:13:39.871]                           computeRestarts <- base::computeRestarts
[16:13:39.871]                           grepl <- base::grepl
[16:13:39.871]                           restarts <- computeRestarts(cond)
[16:13:39.871]                           for (restart in restarts) {
[16:13:39.871]                             name <- restart$name
[16:13:39.871]                             if (is.null(name)) 
[16:13:39.871]                               next
[16:13:39.871]                             if (!grepl(pattern, name)) 
[16:13:39.871]                               next
[16:13:39.871]                             invokeRestart(restart)
[16:13:39.871]                             muffled <- TRUE
[16:13:39.871]                             break
[16:13:39.871]                           }
[16:13:39.871]                         }
[16:13:39.871]                       }
[16:13:39.871]                       invisible(muffled)
[16:13:39.871]                     }
[16:13:39.871]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.871]                   }
[16:13:39.871]                 }
[16:13:39.871]                 else {
[16:13:39.871]                   if (TRUE) {
[16:13:39.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.871]                     {
[16:13:39.871]                       inherits <- base::inherits
[16:13:39.871]                       invokeRestart <- base::invokeRestart
[16:13:39.871]                       is.null <- base::is.null
[16:13:39.871]                       muffled <- FALSE
[16:13:39.871]                       if (inherits(cond, "message")) {
[16:13:39.871]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.871]                         if (muffled) 
[16:13:39.871]                           invokeRestart("muffleMessage")
[16:13:39.871]                       }
[16:13:39.871]                       else if (inherits(cond, "warning")) {
[16:13:39.871]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.871]                         if (muffled) 
[16:13:39.871]                           invokeRestart("muffleWarning")
[16:13:39.871]                       }
[16:13:39.871]                       else if (inherits(cond, "condition")) {
[16:13:39.871]                         if (!is.null(pattern)) {
[16:13:39.871]                           computeRestarts <- base::computeRestarts
[16:13:39.871]                           grepl <- base::grepl
[16:13:39.871]                           restarts <- computeRestarts(cond)
[16:13:39.871]                           for (restart in restarts) {
[16:13:39.871]                             name <- restart$name
[16:13:39.871]                             if (is.null(name)) 
[16:13:39.871]                               next
[16:13:39.871]                             if (!grepl(pattern, name)) 
[16:13:39.871]                               next
[16:13:39.871]                             invokeRestart(restart)
[16:13:39.871]                             muffled <- TRUE
[16:13:39.871]                             break
[16:13:39.871]                           }
[16:13:39.871]                         }
[16:13:39.871]                       }
[16:13:39.871]                       invisible(muffled)
[16:13:39.871]                     }
[16:13:39.871]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.871]                   }
[16:13:39.871]                 }
[16:13:39.871]             }
[16:13:39.871]         }))
[16:13:39.871]     }, error = function(ex) {
[16:13:39.871]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:39.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.871]                 ...future.rng), started = ...future.startTime, 
[16:13:39.871]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:39.871]             version = "1.8"), class = "FutureResult")
[16:13:39.871]     }, finally = {
[16:13:39.871]         if (!identical(...future.workdir, getwd())) 
[16:13:39.871]             setwd(...future.workdir)
[16:13:39.871]         {
[16:13:39.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:39.871]                 ...future.oldOptions$nwarnings <- NULL
[16:13:39.871]             }
[16:13:39.871]             base::options(...future.oldOptions)
[16:13:39.871]             if (.Platform$OS.type == "windows") {
[16:13:39.871]                 old_names <- names(...future.oldEnvVars)
[16:13:39.871]                 envs <- base::Sys.getenv()
[16:13:39.871]                 names <- names(envs)
[16:13:39.871]                 common <- intersect(names, old_names)
[16:13:39.871]                 added <- setdiff(names, old_names)
[16:13:39.871]                 removed <- setdiff(old_names, names)
[16:13:39.871]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:39.871]                   envs[common]]
[16:13:39.871]                 NAMES <- toupper(changed)
[16:13:39.871]                 args <- list()
[16:13:39.871]                 for (kk in seq_along(NAMES)) {
[16:13:39.871]                   name <- changed[[kk]]
[16:13:39.871]                   NAME <- NAMES[[kk]]
[16:13:39.871]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.871]                     next
[16:13:39.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.871]                 }
[16:13:39.871]                 NAMES <- toupper(added)
[16:13:39.871]                 for (kk in seq_along(NAMES)) {
[16:13:39.871]                   name <- added[[kk]]
[16:13:39.871]                   NAME <- NAMES[[kk]]
[16:13:39.871]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.871]                     next
[16:13:39.871]                   args[[name]] <- ""
[16:13:39.871]                 }
[16:13:39.871]                 NAMES <- toupper(removed)
[16:13:39.871]                 for (kk in seq_along(NAMES)) {
[16:13:39.871]                   name <- removed[[kk]]
[16:13:39.871]                   NAME <- NAMES[[kk]]
[16:13:39.871]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.871]                     next
[16:13:39.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.871]                 }
[16:13:39.871]                 if (length(args) > 0) 
[16:13:39.871]                   base::do.call(base::Sys.setenv, args = args)
[16:13:39.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:39.871]             }
[16:13:39.871]             else {
[16:13:39.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:39.871]             }
[16:13:39.871]             {
[16:13:39.871]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:39.871]                   0L) {
[16:13:39.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:39.871]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:39.871]                   base::options(opts)
[16:13:39.871]                 }
[16:13:39.871]                 {
[16:13:39.871]                   {
[16:13:39.871]                     NULL
[16:13:39.871]                     RNGkind("Mersenne-Twister")
[16:13:39.871]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:39.871]                       inherits = FALSE)
[16:13:39.871]                   }
[16:13:39.871]                   options(future.plan = NULL)
[16:13:39.871]                   if (is.na(NA_character_)) 
[16:13:39.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:39.871]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:39.871]                   {
[16:13:39.871]                     future <- SequentialFuture(..., envir = envir)
[16:13:39.871]                     if (!future$lazy) 
[16:13:39.871]                       future <- run(future)
[16:13:39.871]                     invisible(future)
[16:13:39.871]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:39.871]                 }
[16:13:39.871]             }
[16:13:39.871]         }
[16:13:39.871]     })
[16:13:39.871]     if (TRUE) {
[16:13:39.871]         base::sink(type = "output", split = FALSE)
[16:13:39.871]         if (TRUE) {
[16:13:39.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:39.871]         }
[16:13:39.871]         else {
[16:13:39.871]             ...future.result["stdout"] <- base::list(NULL)
[16:13:39.871]         }
[16:13:39.871]         base::close(...future.stdout)
[16:13:39.871]         ...future.stdout <- NULL
[16:13:39.871]     }
[16:13:39.871]     ...future.result$conditions <- ...future.conditions
[16:13:39.871]     ...future.result$finished <- base::Sys.time()
[16:13:39.871]     ...future.result
[16:13:39.871] }
[16:13:39.873] plan(): Setting new future strategy stack:
[16:13:39.873] List of future strategies:
[16:13:39.873] 1. sequential:
[16:13:39.873]    - args: function (..., envir = parent.frame())
[16:13:39.873]    - tweaked: FALSE
[16:13:39.873]    - call: NULL
[16:13:39.873] plan(): nbrOfWorkers() = 1
[16:13:39.874] plan(): Setting new future strategy stack:
[16:13:39.874] List of future strategies:
[16:13:39.874] 1. sequential:
[16:13:39.874]    - args: function (..., envir = parent.frame())
[16:13:39.874]    - tweaked: FALSE
[16:13:39.874]    - call: plan(strategy)
[16:13:39.875] plan(): nbrOfWorkers() = 1
[16:13:39.875] SequentialFuture started (and completed)
[16:13:39.875] - Launch lazy future ... done
[16:13:39.875] run() for ‘SequentialFuture’ ... done
[16:13:39.875] getGlobalsAndPackages() ...
[16:13:39.875] Searching for globals...
[16:13:39.875] 
[16:13:39.875] Searching for globals ... DONE
[16:13:39.876] - globals: [0] <none>
[16:13:39.876] getGlobalsAndPackages() ... DONE
[16:13:39.876] run() for ‘Future’ ...
[16:13:39.876] - state: ‘created’
[16:13:39.876] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:39.876] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:39.876] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:39.877]   - Field: ‘label’
[16:13:39.877]   - Field: ‘local’
[16:13:39.877]   - Field: ‘owner’
[16:13:39.877]   - Field: ‘envir’
[16:13:39.877]   - Field: ‘packages’
[16:13:39.877]   - Field: ‘gc’
[16:13:39.877]   - Field: ‘conditions’
[16:13:39.879]   - Field: ‘expr’
[16:13:39.879]   - Field: ‘uuid’
[16:13:39.879]   - Field: ‘seed’
[16:13:39.879]   - Field: ‘version’
[16:13:39.879]   - Field: ‘result’
[16:13:39.880]   - Field: ‘asynchronous’
[16:13:39.880]   - Field: ‘calls’
[16:13:39.880]   - Field: ‘globals’
[16:13:39.880]   - Field: ‘stdout’
[16:13:39.880]   - Field: ‘earlySignal’
[16:13:39.880]   - Field: ‘lazy’
[16:13:39.880]   - Field: ‘state’
[16:13:39.880] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:39.880] - Launch lazy future ...
[16:13:39.880] Packages needed by the future expression (n = 0): <none>
[16:13:39.881] Packages needed by future strategies (n = 0): <none>
[16:13:39.881] {
[16:13:39.881]     {
[16:13:39.881]         {
[16:13:39.881]             ...future.startTime <- base::Sys.time()
[16:13:39.881]             {
[16:13:39.881]                 {
[16:13:39.881]                   {
[16:13:39.881]                     base::local({
[16:13:39.881]                       has_future <- base::requireNamespace("future", 
[16:13:39.881]                         quietly = TRUE)
[16:13:39.881]                       if (has_future) {
[16:13:39.881]                         ns <- base::getNamespace("future")
[16:13:39.881]                         version <- ns[[".package"]][["version"]]
[16:13:39.881]                         if (is.null(version)) 
[16:13:39.881]                           version <- utils::packageVersion("future")
[16:13:39.881]                       }
[16:13:39.881]                       else {
[16:13:39.881]                         version <- NULL
[16:13:39.881]                       }
[16:13:39.881]                       if (!has_future || version < "1.8.0") {
[16:13:39.881]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:39.881]                           "", base::R.version$version.string), 
[16:13:39.881]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:39.881]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:39.881]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:39.881]                             "release", "version")], collapse = " "), 
[16:13:39.881]                           hostname = base::Sys.info()[["nodename"]])
[16:13:39.881]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:39.881]                           info)
[16:13:39.881]                         info <- base::paste(info, collapse = "; ")
[16:13:39.881]                         if (!has_future) {
[16:13:39.881]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:39.881]                             info)
[16:13:39.881]                         }
[16:13:39.881]                         else {
[16:13:39.881]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:39.881]                             info, version)
[16:13:39.881]                         }
[16:13:39.881]                         base::stop(msg)
[16:13:39.881]                       }
[16:13:39.881]                     })
[16:13:39.881]                   }
[16:13:39.881]                   options(future.plan = NULL)
[16:13:39.881]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.881]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:39.881]                 }
[16:13:39.881]                 ...future.workdir <- getwd()
[16:13:39.881]             }
[16:13:39.881]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:39.881]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:39.881]         }
[16:13:39.881]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:39.881]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:39.881]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:39.881]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:39.881]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:39.881]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:39.881]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:39.881]             base::names(...future.oldOptions))
[16:13:39.881]     }
[16:13:39.881]     if (FALSE) {
[16:13:39.881]     }
[16:13:39.881]     else {
[16:13:39.881]         if (TRUE) {
[16:13:39.881]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:39.881]                 open = "w")
[16:13:39.881]         }
[16:13:39.881]         else {
[16:13:39.881]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:39.881]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:39.881]         }
[16:13:39.881]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:39.881]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:39.881]             base::sink(type = "output", split = FALSE)
[16:13:39.881]             base::close(...future.stdout)
[16:13:39.881]         }, add = TRUE)
[16:13:39.881]     }
[16:13:39.881]     ...future.frame <- base::sys.nframe()
[16:13:39.881]     ...future.conditions <- base::list()
[16:13:39.881]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:39.881]     if (FALSE) {
[16:13:39.881]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:39.881]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:39.881]     }
[16:13:39.881]     ...future.result <- base::tryCatch({
[16:13:39.881]         base::withCallingHandlers({
[16:13:39.881]             ...future.value <- base::withVisible(base::local(2))
[16:13:39.881]             future::FutureResult(value = ...future.value$value, 
[16:13:39.881]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.881]                   ...future.rng), globalenv = if (FALSE) 
[16:13:39.881]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:39.881]                     ...future.globalenv.names))
[16:13:39.881]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:39.881]         }, condition = base::local({
[16:13:39.881]             c <- base::c
[16:13:39.881]             inherits <- base::inherits
[16:13:39.881]             invokeRestart <- base::invokeRestart
[16:13:39.881]             length <- base::length
[16:13:39.881]             list <- base::list
[16:13:39.881]             seq.int <- base::seq.int
[16:13:39.881]             signalCondition <- base::signalCondition
[16:13:39.881]             sys.calls <- base::sys.calls
[16:13:39.881]             `[[` <- base::`[[`
[16:13:39.881]             `+` <- base::`+`
[16:13:39.881]             `<<-` <- base::`<<-`
[16:13:39.881]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:39.881]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:39.881]                   3L)]
[16:13:39.881]             }
[16:13:39.881]             function(cond) {
[16:13:39.881]                 is_error <- inherits(cond, "error")
[16:13:39.881]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:39.881]                   NULL)
[16:13:39.881]                 if (is_error) {
[16:13:39.881]                   sessionInformation <- function() {
[16:13:39.881]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:39.881]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:39.881]                       search = base::search(), system = base::Sys.info())
[16:13:39.881]                   }
[16:13:39.881]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.881]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:39.881]                     cond$call), session = sessionInformation(), 
[16:13:39.881]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:39.881]                   signalCondition(cond)
[16:13:39.881]                 }
[16:13:39.881]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:39.881]                 "immediateCondition"))) {
[16:13:39.881]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:39.881]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.881]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:39.881]                   if (TRUE && !signal) {
[16:13:39.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.881]                     {
[16:13:39.881]                       inherits <- base::inherits
[16:13:39.881]                       invokeRestart <- base::invokeRestart
[16:13:39.881]                       is.null <- base::is.null
[16:13:39.881]                       muffled <- FALSE
[16:13:39.881]                       if (inherits(cond, "message")) {
[16:13:39.881]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.881]                         if (muffled) 
[16:13:39.881]                           invokeRestart("muffleMessage")
[16:13:39.881]                       }
[16:13:39.881]                       else if (inherits(cond, "warning")) {
[16:13:39.881]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.881]                         if (muffled) 
[16:13:39.881]                           invokeRestart("muffleWarning")
[16:13:39.881]                       }
[16:13:39.881]                       else if (inherits(cond, "condition")) {
[16:13:39.881]                         if (!is.null(pattern)) {
[16:13:39.881]                           computeRestarts <- base::computeRestarts
[16:13:39.881]                           grepl <- base::grepl
[16:13:39.881]                           restarts <- computeRestarts(cond)
[16:13:39.881]                           for (restart in restarts) {
[16:13:39.881]                             name <- restart$name
[16:13:39.881]                             if (is.null(name)) 
[16:13:39.881]                               next
[16:13:39.881]                             if (!grepl(pattern, name)) 
[16:13:39.881]                               next
[16:13:39.881]                             invokeRestart(restart)
[16:13:39.881]                             muffled <- TRUE
[16:13:39.881]                             break
[16:13:39.881]                           }
[16:13:39.881]                         }
[16:13:39.881]                       }
[16:13:39.881]                       invisible(muffled)
[16:13:39.881]                     }
[16:13:39.881]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.881]                   }
[16:13:39.881]                 }
[16:13:39.881]                 else {
[16:13:39.881]                   if (TRUE) {
[16:13:39.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.881]                     {
[16:13:39.881]                       inherits <- base::inherits
[16:13:39.881]                       invokeRestart <- base::invokeRestart
[16:13:39.881]                       is.null <- base::is.null
[16:13:39.881]                       muffled <- FALSE
[16:13:39.881]                       if (inherits(cond, "message")) {
[16:13:39.881]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.881]                         if (muffled) 
[16:13:39.881]                           invokeRestart("muffleMessage")
[16:13:39.881]                       }
[16:13:39.881]                       else if (inherits(cond, "warning")) {
[16:13:39.881]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.881]                         if (muffled) 
[16:13:39.881]                           invokeRestart("muffleWarning")
[16:13:39.881]                       }
[16:13:39.881]                       else if (inherits(cond, "condition")) {
[16:13:39.881]                         if (!is.null(pattern)) {
[16:13:39.881]                           computeRestarts <- base::computeRestarts
[16:13:39.881]                           grepl <- base::grepl
[16:13:39.881]                           restarts <- computeRestarts(cond)
[16:13:39.881]                           for (restart in restarts) {
[16:13:39.881]                             name <- restart$name
[16:13:39.881]                             if (is.null(name)) 
[16:13:39.881]                               next
[16:13:39.881]                             if (!grepl(pattern, name)) 
[16:13:39.881]                               next
[16:13:39.881]                             invokeRestart(restart)
[16:13:39.881]                             muffled <- TRUE
[16:13:39.881]                             break
[16:13:39.881]                           }
[16:13:39.881]                         }
[16:13:39.881]                       }
[16:13:39.881]                       invisible(muffled)
[16:13:39.881]                     }
[16:13:39.881]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.881]                   }
[16:13:39.881]                 }
[16:13:39.881]             }
[16:13:39.881]         }))
[16:13:39.881]     }, error = function(ex) {
[16:13:39.881]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:39.881]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.881]                 ...future.rng), started = ...future.startTime, 
[16:13:39.881]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:39.881]             version = "1.8"), class = "FutureResult")
[16:13:39.881]     }, finally = {
[16:13:39.881]         if (!identical(...future.workdir, getwd())) 
[16:13:39.881]             setwd(...future.workdir)
[16:13:39.881]         {
[16:13:39.881]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:39.881]                 ...future.oldOptions$nwarnings <- NULL
[16:13:39.881]             }
[16:13:39.881]             base::options(...future.oldOptions)
[16:13:39.881]             if (.Platform$OS.type == "windows") {
[16:13:39.881]                 old_names <- names(...future.oldEnvVars)
[16:13:39.881]                 envs <- base::Sys.getenv()
[16:13:39.881]                 names <- names(envs)
[16:13:39.881]                 common <- intersect(names, old_names)
[16:13:39.881]                 added <- setdiff(names, old_names)
[16:13:39.881]                 removed <- setdiff(old_names, names)
[16:13:39.881]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:39.881]                   envs[common]]
[16:13:39.881]                 NAMES <- toupper(changed)
[16:13:39.881]                 args <- list()
[16:13:39.881]                 for (kk in seq_along(NAMES)) {
[16:13:39.881]                   name <- changed[[kk]]
[16:13:39.881]                   NAME <- NAMES[[kk]]
[16:13:39.881]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.881]                     next
[16:13:39.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.881]                 }
[16:13:39.881]                 NAMES <- toupper(added)
[16:13:39.881]                 for (kk in seq_along(NAMES)) {
[16:13:39.881]                   name <- added[[kk]]
[16:13:39.881]                   NAME <- NAMES[[kk]]
[16:13:39.881]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.881]                     next
[16:13:39.881]                   args[[name]] <- ""
[16:13:39.881]                 }
[16:13:39.881]                 NAMES <- toupper(removed)
[16:13:39.881]                 for (kk in seq_along(NAMES)) {
[16:13:39.881]                   name <- removed[[kk]]
[16:13:39.881]                   NAME <- NAMES[[kk]]
[16:13:39.881]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.881]                     next
[16:13:39.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.881]                 }
[16:13:39.881]                 if (length(args) > 0) 
[16:13:39.881]                   base::do.call(base::Sys.setenv, args = args)
[16:13:39.881]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:39.881]             }
[16:13:39.881]             else {
[16:13:39.881]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:39.881]             }
[16:13:39.881]             {
[16:13:39.881]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:39.881]                   0L) {
[16:13:39.881]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:39.881]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:39.881]                   base::options(opts)
[16:13:39.881]                 }
[16:13:39.881]                 {
[16:13:39.881]                   {
[16:13:39.881]                     NULL
[16:13:39.881]                     RNGkind("Mersenne-Twister")
[16:13:39.881]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:39.881]                       inherits = FALSE)
[16:13:39.881]                   }
[16:13:39.881]                   options(future.plan = NULL)
[16:13:39.881]                   if (is.na(NA_character_)) 
[16:13:39.881]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.881]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:39.881]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:39.881]                   {
[16:13:39.881]                     future <- SequentialFuture(..., envir = envir)
[16:13:39.881]                     if (!future$lazy) 
[16:13:39.881]                       future <- run(future)
[16:13:39.881]                     invisible(future)
[16:13:39.881]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:39.881]                 }
[16:13:39.881]             }
[16:13:39.881]         }
[16:13:39.881]     })
[16:13:39.881]     if (TRUE) {
[16:13:39.881]         base::sink(type = "output", split = FALSE)
[16:13:39.881]         if (TRUE) {
[16:13:39.881]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:39.881]         }
[16:13:39.881]         else {
[16:13:39.881]             ...future.result["stdout"] <- base::list(NULL)
[16:13:39.881]         }
[16:13:39.881]         base::close(...future.stdout)
[16:13:39.881]         ...future.stdout <- NULL
[16:13:39.881]     }
[16:13:39.881]     ...future.result$conditions <- ...future.conditions
[16:13:39.881]     ...future.result$finished <- base::Sys.time()
[16:13:39.881]     ...future.result
[16:13:39.881] }
[16:13:39.883] plan(): Setting new future strategy stack:
[16:13:39.883] List of future strategies:
[16:13:39.883] 1. sequential:
[16:13:39.883]    - args: function (..., envir = parent.frame())
[16:13:39.883]    - tweaked: FALSE
[16:13:39.883]    - call: NULL
[16:13:39.883] plan(): nbrOfWorkers() = 1
[16:13:39.884] plan(): Setting new future strategy stack:
[16:13:39.884] List of future strategies:
[16:13:39.884] 1. sequential:
[16:13:39.884]    - args: function (..., envir = parent.frame())
[16:13:39.884]    - tweaked: FALSE
[16:13:39.884]    - call: plan(strategy)
[16:13:39.884] plan(): nbrOfWorkers() = 1
[16:13:39.885] SequentialFuture started (and completed)
[16:13:39.885] - Launch lazy future ... done
[16:13:39.885] run() for ‘SequentialFuture’ ... done
[16:13:39.885] resolve() on environment ...
[16:13:39.885]  recursive: 0
[16:13:39.886]  elements: [3] ‘a’, ‘b’, ‘c’
[16:13:39.886] resolved() for ‘SequentialFuture’ ...
[16:13:39.886] - state: ‘finished’
[16:13:39.886] - run: TRUE
[16:13:39.886] - result: ‘FutureResult’
[16:13:39.886] resolved() for ‘SequentialFuture’ ... done
[16:13:39.886] Future #1
[16:13:39.887]  length: 2 (resolved future 1)
[16:13:39.887] resolved() for ‘SequentialFuture’ ...
[16:13:39.887] - state: ‘finished’
[16:13:39.887] - run: TRUE
[16:13:39.887] - result: ‘FutureResult’
[16:13:39.887] resolved() for ‘SequentialFuture’ ... done
[16:13:39.887] Future #2
[16:13:39.887]  length: 1 (resolved future 2)
[16:13:39.887]  length: 0 (resolved future 3)
[16:13:39.887] resolve() on environment ... DONE
[16:13:39.888] resolved() for ‘SequentialFuture’ ...
[16:13:39.888] - state: ‘finished’
[16:13:39.888] - run: TRUE
[16:13:39.888] - result: ‘FutureResult’
[16:13:39.888] resolved() for ‘SequentialFuture’ ... done
[16:13:39.888] resolved() for ‘SequentialFuture’ ...
[16:13:39.888] - state: ‘finished’
[16:13:39.888] - run: TRUE
[16:13:39.888] - result: ‘FutureResult’
[16:13:39.888] resolved() for ‘SequentialFuture’ ... done
[16:13:39.889] getGlobalsAndPackages() ...
[16:13:39.889] Searching for globals...
[16:13:39.890] - globals found: [1] ‘{’
[16:13:39.890] Searching for globals ... DONE
[16:13:39.890] Resolving globals: FALSE
[16:13:39.890] 
[16:13:39.891] 
[16:13:39.891] getGlobalsAndPackages() ... DONE
[16:13:39.891] run() for ‘Future’ ...
[16:13:39.891] - state: ‘created’
[16:13:39.891] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:39.891] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:39.892] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:39.892]   - Field: ‘label’
[16:13:39.892]   - Field: ‘local’
[16:13:39.892]   - Field: ‘owner’
[16:13:39.892]   - Field: ‘envir’
[16:13:39.892]   - Field: ‘packages’
[16:13:39.892]   - Field: ‘gc’
[16:13:39.892]   - Field: ‘conditions’
[16:13:39.892]   - Field: ‘expr’
[16:13:39.892]   - Field: ‘uuid’
[16:13:39.893]   - Field: ‘seed’
[16:13:39.893]   - Field: ‘version’
[16:13:39.893]   - Field: ‘result’
[16:13:39.893]   - Field: ‘asynchronous’
[16:13:39.893]   - Field: ‘calls’
[16:13:39.893]   - Field: ‘globals’
[16:13:39.893]   - Field: ‘stdout’
[16:13:39.893]   - Field: ‘earlySignal’
[16:13:39.893]   - Field: ‘lazy’
[16:13:39.893]   - Field: ‘state’
[16:13:39.893] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:39.894] - Launch lazy future ...
[16:13:39.894] Packages needed by the future expression (n = 0): <none>
[16:13:39.894] Packages needed by future strategies (n = 0): <none>
[16:13:39.894] {
[16:13:39.894]     {
[16:13:39.894]         {
[16:13:39.894]             ...future.startTime <- base::Sys.time()
[16:13:39.894]             {
[16:13:39.894]                 {
[16:13:39.894]                   {
[16:13:39.894]                     base::local({
[16:13:39.894]                       has_future <- base::requireNamespace("future", 
[16:13:39.894]                         quietly = TRUE)
[16:13:39.894]                       if (has_future) {
[16:13:39.894]                         ns <- base::getNamespace("future")
[16:13:39.894]                         version <- ns[[".package"]][["version"]]
[16:13:39.894]                         if (is.null(version)) 
[16:13:39.894]                           version <- utils::packageVersion("future")
[16:13:39.894]                       }
[16:13:39.894]                       else {
[16:13:39.894]                         version <- NULL
[16:13:39.894]                       }
[16:13:39.894]                       if (!has_future || version < "1.8.0") {
[16:13:39.894]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:39.894]                           "", base::R.version$version.string), 
[16:13:39.894]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:39.894]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:39.894]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:39.894]                             "release", "version")], collapse = " "), 
[16:13:39.894]                           hostname = base::Sys.info()[["nodename"]])
[16:13:39.894]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:39.894]                           info)
[16:13:39.894]                         info <- base::paste(info, collapse = "; ")
[16:13:39.894]                         if (!has_future) {
[16:13:39.894]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:39.894]                             info)
[16:13:39.894]                         }
[16:13:39.894]                         else {
[16:13:39.894]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:39.894]                             info, version)
[16:13:39.894]                         }
[16:13:39.894]                         base::stop(msg)
[16:13:39.894]                       }
[16:13:39.894]                     })
[16:13:39.894]                   }
[16:13:39.894]                   options(future.plan = NULL)
[16:13:39.894]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.894]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:39.894]                 }
[16:13:39.894]                 ...future.workdir <- getwd()
[16:13:39.894]             }
[16:13:39.894]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:39.894]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:39.894]         }
[16:13:39.894]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:39.894]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:39.894]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:39.894]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:39.894]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:39.894]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:39.894]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:39.894]             base::names(...future.oldOptions))
[16:13:39.894]     }
[16:13:39.894]     if (FALSE) {
[16:13:39.894]     }
[16:13:39.894]     else {
[16:13:39.894]         if (TRUE) {
[16:13:39.894]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:39.894]                 open = "w")
[16:13:39.894]         }
[16:13:39.894]         else {
[16:13:39.894]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:39.894]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:39.894]         }
[16:13:39.894]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:39.894]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:39.894]             base::sink(type = "output", split = FALSE)
[16:13:39.894]             base::close(...future.stdout)
[16:13:39.894]         }, add = TRUE)
[16:13:39.894]     }
[16:13:39.894]     ...future.frame <- base::sys.nframe()
[16:13:39.894]     ...future.conditions <- base::list()
[16:13:39.894]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:39.894]     if (FALSE) {
[16:13:39.894]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:39.894]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:39.894]     }
[16:13:39.894]     ...future.result <- base::tryCatch({
[16:13:39.894]         base::withCallingHandlers({
[16:13:39.894]             ...future.value <- base::withVisible(base::local({
[16:13:39.894]                 1
[16:13:39.894]             }))
[16:13:39.894]             future::FutureResult(value = ...future.value$value, 
[16:13:39.894]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.894]                   ...future.rng), globalenv = if (FALSE) 
[16:13:39.894]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:39.894]                     ...future.globalenv.names))
[16:13:39.894]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:39.894]         }, condition = base::local({
[16:13:39.894]             c <- base::c
[16:13:39.894]             inherits <- base::inherits
[16:13:39.894]             invokeRestart <- base::invokeRestart
[16:13:39.894]             length <- base::length
[16:13:39.894]             list <- base::list
[16:13:39.894]             seq.int <- base::seq.int
[16:13:39.894]             signalCondition <- base::signalCondition
[16:13:39.894]             sys.calls <- base::sys.calls
[16:13:39.894]             `[[` <- base::`[[`
[16:13:39.894]             `+` <- base::`+`
[16:13:39.894]             `<<-` <- base::`<<-`
[16:13:39.894]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:39.894]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:39.894]                   3L)]
[16:13:39.894]             }
[16:13:39.894]             function(cond) {
[16:13:39.894]                 is_error <- inherits(cond, "error")
[16:13:39.894]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:39.894]                   NULL)
[16:13:39.894]                 if (is_error) {
[16:13:39.894]                   sessionInformation <- function() {
[16:13:39.894]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:39.894]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:39.894]                       search = base::search(), system = base::Sys.info())
[16:13:39.894]                   }
[16:13:39.894]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.894]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:39.894]                     cond$call), session = sessionInformation(), 
[16:13:39.894]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:39.894]                   signalCondition(cond)
[16:13:39.894]                 }
[16:13:39.894]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:39.894]                 "immediateCondition"))) {
[16:13:39.894]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:39.894]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.894]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:39.894]                   if (TRUE && !signal) {
[16:13:39.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.894]                     {
[16:13:39.894]                       inherits <- base::inherits
[16:13:39.894]                       invokeRestart <- base::invokeRestart
[16:13:39.894]                       is.null <- base::is.null
[16:13:39.894]                       muffled <- FALSE
[16:13:39.894]                       if (inherits(cond, "message")) {
[16:13:39.894]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.894]                         if (muffled) 
[16:13:39.894]                           invokeRestart("muffleMessage")
[16:13:39.894]                       }
[16:13:39.894]                       else if (inherits(cond, "warning")) {
[16:13:39.894]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.894]                         if (muffled) 
[16:13:39.894]                           invokeRestart("muffleWarning")
[16:13:39.894]                       }
[16:13:39.894]                       else if (inherits(cond, "condition")) {
[16:13:39.894]                         if (!is.null(pattern)) {
[16:13:39.894]                           computeRestarts <- base::computeRestarts
[16:13:39.894]                           grepl <- base::grepl
[16:13:39.894]                           restarts <- computeRestarts(cond)
[16:13:39.894]                           for (restart in restarts) {
[16:13:39.894]                             name <- restart$name
[16:13:39.894]                             if (is.null(name)) 
[16:13:39.894]                               next
[16:13:39.894]                             if (!grepl(pattern, name)) 
[16:13:39.894]                               next
[16:13:39.894]                             invokeRestart(restart)
[16:13:39.894]                             muffled <- TRUE
[16:13:39.894]                             break
[16:13:39.894]                           }
[16:13:39.894]                         }
[16:13:39.894]                       }
[16:13:39.894]                       invisible(muffled)
[16:13:39.894]                     }
[16:13:39.894]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.894]                   }
[16:13:39.894]                 }
[16:13:39.894]                 else {
[16:13:39.894]                   if (TRUE) {
[16:13:39.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.894]                     {
[16:13:39.894]                       inherits <- base::inherits
[16:13:39.894]                       invokeRestart <- base::invokeRestart
[16:13:39.894]                       is.null <- base::is.null
[16:13:39.894]                       muffled <- FALSE
[16:13:39.894]                       if (inherits(cond, "message")) {
[16:13:39.894]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.894]                         if (muffled) 
[16:13:39.894]                           invokeRestart("muffleMessage")
[16:13:39.894]                       }
[16:13:39.894]                       else if (inherits(cond, "warning")) {
[16:13:39.894]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.894]                         if (muffled) 
[16:13:39.894]                           invokeRestart("muffleWarning")
[16:13:39.894]                       }
[16:13:39.894]                       else if (inherits(cond, "condition")) {
[16:13:39.894]                         if (!is.null(pattern)) {
[16:13:39.894]                           computeRestarts <- base::computeRestarts
[16:13:39.894]                           grepl <- base::grepl
[16:13:39.894]                           restarts <- computeRestarts(cond)
[16:13:39.894]                           for (restart in restarts) {
[16:13:39.894]                             name <- restart$name
[16:13:39.894]                             if (is.null(name)) 
[16:13:39.894]                               next
[16:13:39.894]                             if (!grepl(pattern, name)) 
[16:13:39.894]                               next
[16:13:39.894]                             invokeRestart(restart)
[16:13:39.894]                             muffled <- TRUE
[16:13:39.894]                             break
[16:13:39.894]                           }
[16:13:39.894]                         }
[16:13:39.894]                       }
[16:13:39.894]                       invisible(muffled)
[16:13:39.894]                     }
[16:13:39.894]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.894]                   }
[16:13:39.894]                 }
[16:13:39.894]             }
[16:13:39.894]         }))
[16:13:39.894]     }, error = function(ex) {
[16:13:39.894]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:39.894]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.894]                 ...future.rng), started = ...future.startTime, 
[16:13:39.894]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:39.894]             version = "1.8"), class = "FutureResult")
[16:13:39.894]     }, finally = {
[16:13:39.894]         if (!identical(...future.workdir, getwd())) 
[16:13:39.894]             setwd(...future.workdir)
[16:13:39.894]         {
[16:13:39.894]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:39.894]                 ...future.oldOptions$nwarnings <- NULL
[16:13:39.894]             }
[16:13:39.894]             base::options(...future.oldOptions)
[16:13:39.894]             if (.Platform$OS.type == "windows") {
[16:13:39.894]                 old_names <- names(...future.oldEnvVars)
[16:13:39.894]                 envs <- base::Sys.getenv()
[16:13:39.894]                 names <- names(envs)
[16:13:39.894]                 common <- intersect(names, old_names)
[16:13:39.894]                 added <- setdiff(names, old_names)
[16:13:39.894]                 removed <- setdiff(old_names, names)
[16:13:39.894]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:39.894]                   envs[common]]
[16:13:39.894]                 NAMES <- toupper(changed)
[16:13:39.894]                 args <- list()
[16:13:39.894]                 for (kk in seq_along(NAMES)) {
[16:13:39.894]                   name <- changed[[kk]]
[16:13:39.894]                   NAME <- NAMES[[kk]]
[16:13:39.894]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.894]                     next
[16:13:39.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.894]                 }
[16:13:39.894]                 NAMES <- toupper(added)
[16:13:39.894]                 for (kk in seq_along(NAMES)) {
[16:13:39.894]                   name <- added[[kk]]
[16:13:39.894]                   NAME <- NAMES[[kk]]
[16:13:39.894]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.894]                     next
[16:13:39.894]                   args[[name]] <- ""
[16:13:39.894]                 }
[16:13:39.894]                 NAMES <- toupper(removed)
[16:13:39.894]                 for (kk in seq_along(NAMES)) {
[16:13:39.894]                   name <- removed[[kk]]
[16:13:39.894]                   NAME <- NAMES[[kk]]
[16:13:39.894]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.894]                     next
[16:13:39.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.894]                 }
[16:13:39.894]                 if (length(args) > 0) 
[16:13:39.894]                   base::do.call(base::Sys.setenv, args = args)
[16:13:39.894]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:39.894]             }
[16:13:39.894]             else {
[16:13:39.894]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:39.894]             }
[16:13:39.894]             {
[16:13:39.894]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:39.894]                   0L) {
[16:13:39.894]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:39.894]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:39.894]                   base::options(opts)
[16:13:39.894]                 }
[16:13:39.894]                 {
[16:13:39.894]                   {
[16:13:39.894]                     NULL
[16:13:39.894]                     RNGkind("Mersenne-Twister")
[16:13:39.894]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:39.894]                       inherits = FALSE)
[16:13:39.894]                   }
[16:13:39.894]                   options(future.plan = NULL)
[16:13:39.894]                   if (is.na(NA_character_)) 
[16:13:39.894]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.894]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:39.894]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:39.894]                   {
[16:13:39.894]                     future <- SequentialFuture(..., envir = envir)
[16:13:39.894]                     if (!future$lazy) 
[16:13:39.894]                       future <- run(future)
[16:13:39.894]                     invisible(future)
[16:13:39.894]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:39.894]                 }
[16:13:39.894]             }
[16:13:39.894]         }
[16:13:39.894]     })
[16:13:39.894]     if (TRUE) {
[16:13:39.894]         base::sink(type = "output", split = FALSE)
[16:13:39.894]         if (TRUE) {
[16:13:39.894]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:39.894]         }
[16:13:39.894]         else {
[16:13:39.894]             ...future.result["stdout"] <- base::list(NULL)
[16:13:39.894]         }
[16:13:39.894]         base::close(...future.stdout)
[16:13:39.894]         ...future.stdout <- NULL
[16:13:39.894]     }
[16:13:39.894]     ...future.result$conditions <- ...future.conditions
[16:13:39.894]     ...future.result$finished <- base::Sys.time()
[16:13:39.894]     ...future.result
[16:13:39.894] }
[16:13:39.896] plan(): Setting new future strategy stack:
[16:13:39.896] List of future strategies:
[16:13:39.896] 1. sequential:
[16:13:39.896]    - args: function (..., envir = parent.frame())
[16:13:39.896]    - tweaked: FALSE
[16:13:39.896]    - call: NULL
[16:13:39.897] plan(): nbrOfWorkers() = 1
[16:13:39.897] plan(): Setting new future strategy stack:
[16:13:39.898] List of future strategies:
[16:13:39.898] 1. sequential:
[16:13:39.898]    - args: function (..., envir = parent.frame())
[16:13:39.898]    - tweaked: FALSE
[16:13:39.898]    - call: plan(strategy)
[16:13:39.898] plan(): nbrOfWorkers() = 1
[16:13:39.898] SequentialFuture started (and completed)
[16:13:39.898] - Launch lazy future ... done
[16:13:39.898] run() for ‘SequentialFuture’ ... done
[16:13:39.899] getGlobalsAndPackages() ...
[16:13:39.899] Searching for globals...
[16:13:39.899] - globals found: [1] ‘{’
[16:13:39.899] Searching for globals ... DONE
[16:13:39.900] Resolving globals: FALSE
[16:13:39.900] 
[16:13:39.900] 
[16:13:39.900] getGlobalsAndPackages() ... DONE
[16:13:39.900] run() for ‘Future’ ...
[16:13:39.900] - state: ‘created’
[16:13:39.901] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:39.901] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:39.901] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:39.901]   - Field: ‘label’
[16:13:39.901]   - Field: ‘local’
[16:13:39.901]   - Field: ‘owner’
[16:13:39.901]   - Field: ‘envir’
[16:13:39.901]   - Field: ‘packages’
[16:13:39.901]   - Field: ‘gc’
[16:13:39.902]   - Field: ‘conditions’
[16:13:39.902]   - Field: ‘expr’
[16:13:39.902]   - Field: ‘uuid’
[16:13:39.902]   - Field: ‘seed’
[16:13:39.902]   - Field: ‘version’
[16:13:39.902]   - Field: ‘result’
[16:13:39.902]   - Field: ‘asynchronous’
[16:13:39.902]   - Field: ‘calls’
[16:13:39.902]   - Field: ‘globals’
[16:13:39.902]   - Field: ‘stdout’
[16:13:39.903]   - Field: ‘earlySignal’
[16:13:39.903]   - Field: ‘lazy’
[16:13:39.903]   - Field: ‘state’
[16:13:39.903] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:39.903] - Launch lazy future ...
[16:13:39.903] Packages needed by the future expression (n = 0): <none>
[16:13:39.903] Packages needed by future strategies (n = 0): <none>
[16:13:39.904] {
[16:13:39.904]     {
[16:13:39.904]         {
[16:13:39.904]             ...future.startTime <- base::Sys.time()
[16:13:39.904]             {
[16:13:39.904]                 {
[16:13:39.904]                   {
[16:13:39.904]                     base::local({
[16:13:39.904]                       has_future <- base::requireNamespace("future", 
[16:13:39.904]                         quietly = TRUE)
[16:13:39.904]                       if (has_future) {
[16:13:39.904]                         ns <- base::getNamespace("future")
[16:13:39.904]                         version <- ns[[".package"]][["version"]]
[16:13:39.904]                         if (is.null(version)) 
[16:13:39.904]                           version <- utils::packageVersion("future")
[16:13:39.904]                       }
[16:13:39.904]                       else {
[16:13:39.904]                         version <- NULL
[16:13:39.904]                       }
[16:13:39.904]                       if (!has_future || version < "1.8.0") {
[16:13:39.904]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:39.904]                           "", base::R.version$version.string), 
[16:13:39.904]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:39.904]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:39.904]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:39.904]                             "release", "version")], collapse = " "), 
[16:13:39.904]                           hostname = base::Sys.info()[["nodename"]])
[16:13:39.904]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:39.904]                           info)
[16:13:39.904]                         info <- base::paste(info, collapse = "; ")
[16:13:39.904]                         if (!has_future) {
[16:13:39.904]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:39.904]                             info)
[16:13:39.904]                         }
[16:13:39.904]                         else {
[16:13:39.904]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:39.904]                             info, version)
[16:13:39.904]                         }
[16:13:39.904]                         base::stop(msg)
[16:13:39.904]                       }
[16:13:39.904]                     })
[16:13:39.904]                   }
[16:13:39.904]                   options(future.plan = NULL)
[16:13:39.904]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.904]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:39.904]                 }
[16:13:39.904]                 ...future.workdir <- getwd()
[16:13:39.904]             }
[16:13:39.904]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:39.904]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:39.904]         }
[16:13:39.904]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:39.904]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:39.904]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:39.904]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:39.904]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:39.904]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:39.904]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:39.904]             base::names(...future.oldOptions))
[16:13:39.904]     }
[16:13:39.904]     if (FALSE) {
[16:13:39.904]     }
[16:13:39.904]     else {
[16:13:39.904]         if (TRUE) {
[16:13:39.904]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:39.904]                 open = "w")
[16:13:39.904]         }
[16:13:39.904]         else {
[16:13:39.904]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:39.904]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:39.904]         }
[16:13:39.904]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:39.904]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:39.904]             base::sink(type = "output", split = FALSE)
[16:13:39.904]             base::close(...future.stdout)
[16:13:39.904]         }, add = TRUE)
[16:13:39.904]     }
[16:13:39.904]     ...future.frame <- base::sys.nframe()
[16:13:39.904]     ...future.conditions <- base::list()
[16:13:39.904]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:39.904]     if (FALSE) {
[16:13:39.904]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:39.904]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:39.904]     }
[16:13:39.904]     ...future.result <- base::tryCatch({
[16:13:39.904]         base::withCallingHandlers({
[16:13:39.904]             ...future.value <- base::withVisible(base::local({
[16:13:39.904]                 2
[16:13:39.904]             }))
[16:13:39.904]             future::FutureResult(value = ...future.value$value, 
[16:13:39.904]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.904]                   ...future.rng), globalenv = if (FALSE) 
[16:13:39.904]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:39.904]                     ...future.globalenv.names))
[16:13:39.904]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:39.904]         }, condition = base::local({
[16:13:39.904]             c <- base::c
[16:13:39.904]             inherits <- base::inherits
[16:13:39.904]             invokeRestart <- base::invokeRestart
[16:13:39.904]             length <- base::length
[16:13:39.904]             list <- base::list
[16:13:39.904]             seq.int <- base::seq.int
[16:13:39.904]             signalCondition <- base::signalCondition
[16:13:39.904]             sys.calls <- base::sys.calls
[16:13:39.904]             `[[` <- base::`[[`
[16:13:39.904]             `+` <- base::`+`
[16:13:39.904]             `<<-` <- base::`<<-`
[16:13:39.904]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:39.904]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:39.904]                   3L)]
[16:13:39.904]             }
[16:13:39.904]             function(cond) {
[16:13:39.904]                 is_error <- inherits(cond, "error")
[16:13:39.904]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:39.904]                   NULL)
[16:13:39.904]                 if (is_error) {
[16:13:39.904]                   sessionInformation <- function() {
[16:13:39.904]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:39.904]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:39.904]                       search = base::search(), system = base::Sys.info())
[16:13:39.904]                   }
[16:13:39.904]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.904]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:39.904]                     cond$call), session = sessionInformation(), 
[16:13:39.904]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:39.904]                   signalCondition(cond)
[16:13:39.904]                 }
[16:13:39.904]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:39.904]                 "immediateCondition"))) {
[16:13:39.904]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:39.904]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.904]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:39.904]                   if (TRUE && !signal) {
[16:13:39.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.904]                     {
[16:13:39.904]                       inherits <- base::inherits
[16:13:39.904]                       invokeRestart <- base::invokeRestart
[16:13:39.904]                       is.null <- base::is.null
[16:13:39.904]                       muffled <- FALSE
[16:13:39.904]                       if (inherits(cond, "message")) {
[16:13:39.904]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.904]                         if (muffled) 
[16:13:39.904]                           invokeRestart("muffleMessage")
[16:13:39.904]                       }
[16:13:39.904]                       else if (inherits(cond, "warning")) {
[16:13:39.904]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.904]                         if (muffled) 
[16:13:39.904]                           invokeRestart("muffleWarning")
[16:13:39.904]                       }
[16:13:39.904]                       else if (inherits(cond, "condition")) {
[16:13:39.904]                         if (!is.null(pattern)) {
[16:13:39.904]                           computeRestarts <- base::computeRestarts
[16:13:39.904]                           grepl <- base::grepl
[16:13:39.904]                           restarts <- computeRestarts(cond)
[16:13:39.904]                           for (restart in restarts) {
[16:13:39.904]                             name <- restart$name
[16:13:39.904]                             if (is.null(name)) 
[16:13:39.904]                               next
[16:13:39.904]                             if (!grepl(pattern, name)) 
[16:13:39.904]                               next
[16:13:39.904]                             invokeRestart(restart)
[16:13:39.904]                             muffled <- TRUE
[16:13:39.904]                             break
[16:13:39.904]                           }
[16:13:39.904]                         }
[16:13:39.904]                       }
[16:13:39.904]                       invisible(muffled)
[16:13:39.904]                     }
[16:13:39.904]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.904]                   }
[16:13:39.904]                 }
[16:13:39.904]                 else {
[16:13:39.904]                   if (TRUE) {
[16:13:39.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.904]                     {
[16:13:39.904]                       inherits <- base::inherits
[16:13:39.904]                       invokeRestart <- base::invokeRestart
[16:13:39.904]                       is.null <- base::is.null
[16:13:39.904]                       muffled <- FALSE
[16:13:39.904]                       if (inherits(cond, "message")) {
[16:13:39.904]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.904]                         if (muffled) 
[16:13:39.904]                           invokeRestart("muffleMessage")
[16:13:39.904]                       }
[16:13:39.904]                       else if (inherits(cond, "warning")) {
[16:13:39.904]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.904]                         if (muffled) 
[16:13:39.904]                           invokeRestart("muffleWarning")
[16:13:39.904]                       }
[16:13:39.904]                       else if (inherits(cond, "condition")) {
[16:13:39.904]                         if (!is.null(pattern)) {
[16:13:39.904]                           computeRestarts <- base::computeRestarts
[16:13:39.904]                           grepl <- base::grepl
[16:13:39.904]                           restarts <- computeRestarts(cond)
[16:13:39.904]                           for (restart in restarts) {
[16:13:39.904]                             name <- restart$name
[16:13:39.904]                             if (is.null(name)) 
[16:13:39.904]                               next
[16:13:39.904]                             if (!grepl(pattern, name)) 
[16:13:39.904]                               next
[16:13:39.904]                             invokeRestart(restart)
[16:13:39.904]                             muffled <- TRUE
[16:13:39.904]                             break
[16:13:39.904]                           }
[16:13:39.904]                         }
[16:13:39.904]                       }
[16:13:39.904]                       invisible(muffled)
[16:13:39.904]                     }
[16:13:39.904]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.904]                   }
[16:13:39.904]                 }
[16:13:39.904]             }
[16:13:39.904]         }))
[16:13:39.904]     }, error = function(ex) {
[16:13:39.904]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:39.904]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.904]                 ...future.rng), started = ...future.startTime, 
[16:13:39.904]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:39.904]             version = "1.8"), class = "FutureResult")
[16:13:39.904]     }, finally = {
[16:13:39.904]         if (!identical(...future.workdir, getwd())) 
[16:13:39.904]             setwd(...future.workdir)
[16:13:39.904]         {
[16:13:39.904]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:39.904]                 ...future.oldOptions$nwarnings <- NULL
[16:13:39.904]             }
[16:13:39.904]             base::options(...future.oldOptions)
[16:13:39.904]             if (.Platform$OS.type == "windows") {
[16:13:39.904]                 old_names <- names(...future.oldEnvVars)
[16:13:39.904]                 envs <- base::Sys.getenv()
[16:13:39.904]                 names <- names(envs)
[16:13:39.904]                 common <- intersect(names, old_names)
[16:13:39.904]                 added <- setdiff(names, old_names)
[16:13:39.904]                 removed <- setdiff(old_names, names)
[16:13:39.904]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:39.904]                   envs[common]]
[16:13:39.904]                 NAMES <- toupper(changed)
[16:13:39.904]                 args <- list()
[16:13:39.904]                 for (kk in seq_along(NAMES)) {
[16:13:39.904]                   name <- changed[[kk]]
[16:13:39.904]                   NAME <- NAMES[[kk]]
[16:13:39.904]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.904]                     next
[16:13:39.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.904]                 }
[16:13:39.904]                 NAMES <- toupper(added)
[16:13:39.904]                 for (kk in seq_along(NAMES)) {
[16:13:39.904]                   name <- added[[kk]]
[16:13:39.904]                   NAME <- NAMES[[kk]]
[16:13:39.904]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.904]                     next
[16:13:39.904]                   args[[name]] <- ""
[16:13:39.904]                 }
[16:13:39.904]                 NAMES <- toupper(removed)
[16:13:39.904]                 for (kk in seq_along(NAMES)) {
[16:13:39.904]                   name <- removed[[kk]]
[16:13:39.904]                   NAME <- NAMES[[kk]]
[16:13:39.904]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.904]                     next
[16:13:39.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.904]                 }
[16:13:39.904]                 if (length(args) > 0) 
[16:13:39.904]                   base::do.call(base::Sys.setenv, args = args)
[16:13:39.904]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:39.904]             }
[16:13:39.904]             else {
[16:13:39.904]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:39.904]             }
[16:13:39.904]             {
[16:13:39.904]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:39.904]                   0L) {
[16:13:39.904]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:39.904]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:39.904]                   base::options(opts)
[16:13:39.904]                 }
[16:13:39.904]                 {
[16:13:39.904]                   {
[16:13:39.904]                     NULL
[16:13:39.904]                     RNGkind("Mersenne-Twister")
[16:13:39.904]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:39.904]                       inherits = FALSE)
[16:13:39.904]                   }
[16:13:39.904]                   options(future.plan = NULL)
[16:13:39.904]                   if (is.na(NA_character_)) 
[16:13:39.904]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.904]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:39.904]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:39.904]                   {
[16:13:39.904]                     future <- SequentialFuture(..., envir = envir)
[16:13:39.904]                     if (!future$lazy) 
[16:13:39.904]                       future <- run(future)
[16:13:39.904]                     invisible(future)
[16:13:39.904]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:39.904]                 }
[16:13:39.904]             }
[16:13:39.904]         }
[16:13:39.904]     })
[16:13:39.904]     if (TRUE) {
[16:13:39.904]         base::sink(type = "output", split = FALSE)
[16:13:39.904]         if (TRUE) {
[16:13:39.904]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:39.904]         }
[16:13:39.904]         else {
[16:13:39.904]             ...future.result["stdout"] <- base::list(NULL)
[16:13:39.904]         }
[16:13:39.904]         base::close(...future.stdout)
[16:13:39.904]         ...future.stdout <- NULL
[16:13:39.904]     }
[16:13:39.904]     ...future.result$conditions <- ...future.conditions
[16:13:39.904]     ...future.result$finished <- base::Sys.time()
[16:13:39.904]     ...future.result
[16:13:39.904] }
[16:13:39.905] plan(): Setting new future strategy stack:
[16:13:39.905] List of future strategies:
[16:13:39.905] 1. sequential:
[16:13:39.905]    - args: function (..., envir = parent.frame())
[16:13:39.905]    - tweaked: FALSE
[16:13:39.905]    - call: NULL
[16:13:39.906] plan(): nbrOfWorkers() = 1
[16:13:39.907] plan(): Setting new future strategy stack:
[16:13:39.907] List of future strategies:
[16:13:39.907] 1. sequential:
[16:13:39.907]    - args: function (..., envir = parent.frame())
[16:13:39.907]    - tweaked: FALSE
[16:13:39.907]    - call: plan(strategy)
[16:13:39.907] plan(): nbrOfWorkers() = 1
[16:13:39.907] SequentialFuture started (and completed)
[16:13:39.910] - Launch lazy future ... done
[16:13:39.910] run() for ‘SequentialFuture’ ... done
[16:13:39.910] resolve() on environment ...
[16:13:39.910]  recursive: 0
[16:13:39.911]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[16:13:39.911] resolved() for ‘SequentialFuture’ ...
[16:13:39.911] - state: ‘finished’
[16:13:39.911] - run: TRUE
[16:13:39.911] - result: ‘FutureResult’
[16:13:39.911] resolved() for ‘SequentialFuture’ ... done
[16:13:39.911] Future #1
[16:13:39.912]  length: 2 (resolved future 1)
[16:13:39.912] resolved() for ‘SequentialFuture’ ...
[16:13:39.912] - state: ‘finished’
[16:13:39.912] - run: TRUE
[16:13:39.912] - result: ‘FutureResult’
[16:13:39.912] resolved() for ‘SequentialFuture’ ... done
[16:13:39.912] Future #2
[16:13:39.912]  length: 1 (resolved future 2)
[16:13:39.912]  length: 0 (resolved future 3)
[16:13:39.912] resolve() on environment ... DONE
[16:13:39.913] getGlobalsAndPackages() ...
[16:13:39.913] Searching for globals...
[16:13:39.914] - globals found: [1] ‘{’
[16:13:39.914] Searching for globals ... DONE
[16:13:39.914] Resolving globals: FALSE
[16:13:39.914] 
[16:13:39.914] 
[16:13:39.914] getGlobalsAndPackages() ... DONE
[16:13:39.915] run() for ‘Future’ ...
[16:13:39.915] - state: ‘created’
[16:13:39.915] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:39.915] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:39.915] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:39.915]   - Field: ‘label’
[16:13:39.915]   - Field: ‘local’
[16:13:39.915]   - Field: ‘owner’
[16:13:39.916]   - Field: ‘envir’
[16:13:39.916]   - Field: ‘packages’
[16:13:39.916]   - Field: ‘gc’
[16:13:39.916]   - Field: ‘conditions’
[16:13:39.916]   - Field: ‘expr’
[16:13:39.916]   - Field: ‘uuid’
[16:13:39.916]   - Field: ‘seed’
[16:13:39.916]   - Field: ‘version’
[16:13:39.916]   - Field: ‘result’
[16:13:39.916]   - Field: ‘asynchronous’
[16:13:39.916]   - Field: ‘calls’
[16:13:39.917]   - Field: ‘globals’
[16:13:39.917]   - Field: ‘stdout’
[16:13:39.917]   - Field: ‘earlySignal’
[16:13:39.917]   - Field: ‘lazy’
[16:13:39.917]   - Field: ‘state’
[16:13:39.917] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:39.917] - Launch lazy future ...
[16:13:39.917] Packages needed by the future expression (n = 0): <none>
[16:13:39.917] Packages needed by future strategies (n = 0): <none>
[16:13:39.918] {
[16:13:39.918]     {
[16:13:39.918]         {
[16:13:39.918]             ...future.startTime <- base::Sys.time()
[16:13:39.918]             {
[16:13:39.918]                 {
[16:13:39.918]                   {
[16:13:39.918]                     base::local({
[16:13:39.918]                       has_future <- base::requireNamespace("future", 
[16:13:39.918]                         quietly = TRUE)
[16:13:39.918]                       if (has_future) {
[16:13:39.918]                         ns <- base::getNamespace("future")
[16:13:39.918]                         version <- ns[[".package"]][["version"]]
[16:13:39.918]                         if (is.null(version)) 
[16:13:39.918]                           version <- utils::packageVersion("future")
[16:13:39.918]                       }
[16:13:39.918]                       else {
[16:13:39.918]                         version <- NULL
[16:13:39.918]                       }
[16:13:39.918]                       if (!has_future || version < "1.8.0") {
[16:13:39.918]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:39.918]                           "", base::R.version$version.string), 
[16:13:39.918]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:39.918]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:39.918]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:39.918]                             "release", "version")], collapse = " "), 
[16:13:39.918]                           hostname = base::Sys.info()[["nodename"]])
[16:13:39.918]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:39.918]                           info)
[16:13:39.918]                         info <- base::paste(info, collapse = "; ")
[16:13:39.918]                         if (!has_future) {
[16:13:39.918]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:39.918]                             info)
[16:13:39.918]                         }
[16:13:39.918]                         else {
[16:13:39.918]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:39.918]                             info, version)
[16:13:39.918]                         }
[16:13:39.918]                         base::stop(msg)
[16:13:39.918]                       }
[16:13:39.918]                     })
[16:13:39.918]                   }
[16:13:39.918]                   options(future.plan = NULL)
[16:13:39.918]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.918]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:39.918]                 }
[16:13:39.918]                 ...future.workdir <- getwd()
[16:13:39.918]             }
[16:13:39.918]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:39.918]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:39.918]         }
[16:13:39.918]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:39.918]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:39.918]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:39.918]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:39.918]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:39.918]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:39.918]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:39.918]             base::names(...future.oldOptions))
[16:13:39.918]     }
[16:13:39.918]     if (FALSE) {
[16:13:39.918]     }
[16:13:39.918]     else {
[16:13:39.918]         if (TRUE) {
[16:13:39.918]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:39.918]                 open = "w")
[16:13:39.918]         }
[16:13:39.918]         else {
[16:13:39.918]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:39.918]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:39.918]         }
[16:13:39.918]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:39.918]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:39.918]             base::sink(type = "output", split = FALSE)
[16:13:39.918]             base::close(...future.stdout)
[16:13:39.918]         }, add = TRUE)
[16:13:39.918]     }
[16:13:39.918]     ...future.frame <- base::sys.nframe()
[16:13:39.918]     ...future.conditions <- base::list()
[16:13:39.918]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:39.918]     if (FALSE) {
[16:13:39.918]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:39.918]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:39.918]     }
[16:13:39.918]     ...future.result <- base::tryCatch({
[16:13:39.918]         base::withCallingHandlers({
[16:13:39.918]             ...future.value <- base::withVisible(base::local({
[16:13:39.918]                 1
[16:13:39.918]             }))
[16:13:39.918]             future::FutureResult(value = ...future.value$value, 
[16:13:39.918]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.918]                   ...future.rng), globalenv = if (FALSE) 
[16:13:39.918]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:39.918]                     ...future.globalenv.names))
[16:13:39.918]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:39.918]         }, condition = base::local({
[16:13:39.918]             c <- base::c
[16:13:39.918]             inherits <- base::inherits
[16:13:39.918]             invokeRestart <- base::invokeRestart
[16:13:39.918]             length <- base::length
[16:13:39.918]             list <- base::list
[16:13:39.918]             seq.int <- base::seq.int
[16:13:39.918]             signalCondition <- base::signalCondition
[16:13:39.918]             sys.calls <- base::sys.calls
[16:13:39.918]             `[[` <- base::`[[`
[16:13:39.918]             `+` <- base::`+`
[16:13:39.918]             `<<-` <- base::`<<-`
[16:13:39.918]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:39.918]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:39.918]                   3L)]
[16:13:39.918]             }
[16:13:39.918]             function(cond) {
[16:13:39.918]                 is_error <- inherits(cond, "error")
[16:13:39.918]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:39.918]                   NULL)
[16:13:39.918]                 if (is_error) {
[16:13:39.918]                   sessionInformation <- function() {
[16:13:39.918]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:39.918]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:39.918]                       search = base::search(), system = base::Sys.info())
[16:13:39.918]                   }
[16:13:39.918]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.918]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:39.918]                     cond$call), session = sessionInformation(), 
[16:13:39.918]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:39.918]                   signalCondition(cond)
[16:13:39.918]                 }
[16:13:39.918]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:39.918]                 "immediateCondition"))) {
[16:13:39.918]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:39.918]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.918]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:39.918]                   if (TRUE && !signal) {
[16:13:39.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.918]                     {
[16:13:39.918]                       inherits <- base::inherits
[16:13:39.918]                       invokeRestart <- base::invokeRestart
[16:13:39.918]                       is.null <- base::is.null
[16:13:39.918]                       muffled <- FALSE
[16:13:39.918]                       if (inherits(cond, "message")) {
[16:13:39.918]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.918]                         if (muffled) 
[16:13:39.918]                           invokeRestart("muffleMessage")
[16:13:39.918]                       }
[16:13:39.918]                       else if (inherits(cond, "warning")) {
[16:13:39.918]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.918]                         if (muffled) 
[16:13:39.918]                           invokeRestart("muffleWarning")
[16:13:39.918]                       }
[16:13:39.918]                       else if (inherits(cond, "condition")) {
[16:13:39.918]                         if (!is.null(pattern)) {
[16:13:39.918]                           computeRestarts <- base::computeRestarts
[16:13:39.918]                           grepl <- base::grepl
[16:13:39.918]                           restarts <- computeRestarts(cond)
[16:13:39.918]                           for (restart in restarts) {
[16:13:39.918]                             name <- restart$name
[16:13:39.918]                             if (is.null(name)) 
[16:13:39.918]                               next
[16:13:39.918]                             if (!grepl(pattern, name)) 
[16:13:39.918]                               next
[16:13:39.918]                             invokeRestart(restart)
[16:13:39.918]                             muffled <- TRUE
[16:13:39.918]                             break
[16:13:39.918]                           }
[16:13:39.918]                         }
[16:13:39.918]                       }
[16:13:39.918]                       invisible(muffled)
[16:13:39.918]                     }
[16:13:39.918]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.918]                   }
[16:13:39.918]                 }
[16:13:39.918]                 else {
[16:13:39.918]                   if (TRUE) {
[16:13:39.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.918]                     {
[16:13:39.918]                       inherits <- base::inherits
[16:13:39.918]                       invokeRestart <- base::invokeRestart
[16:13:39.918]                       is.null <- base::is.null
[16:13:39.918]                       muffled <- FALSE
[16:13:39.918]                       if (inherits(cond, "message")) {
[16:13:39.918]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.918]                         if (muffled) 
[16:13:39.918]                           invokeRestart("muffleMessage")
[16:13:39.918]                       }
[16:13:39.918]                       else if (inherits(cond, "warning")) {
[16:13:39.918]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.918]                         if (muffled) 
[16:13:39.918]                           invokeRestart("muffleWarning")
[16:13:39.918]                       }
[16:13:39.918]                       else if (inherits(cond, "condition")) {
[16:13:39.918]                         if (!is.null(pattern)) {
[16:13:39.918]                           computeRestarts <- base::computeRestarts
[16:13:39.918]                           grepl <- base::grepl
[16:13:39.918]                           restarts <- computeRestarts(cond)
[16:13:39.918]                           for (restart in restarts) {
[16:13:39.918]                             name <- restart$name
[16:13:39.918]                             if (is.null(name)) 
[16:13:39.918]                               next
[16:13:39.918]                             if (!grepl(pattern, name)) 
[16:13:39.918]                               next
[16:13:39.918]                             invokeRestart(restart)
[16:13:39.918]                             muffled <- TRUE
[16:13:39.918]                             break
[16:13:39.918]                           }
[16:13:39.918]                         }
[16:13:39.918]                       }
[16:13:39.918]                       invisible(muffled)
[16:13:39.918]                     }
[16:13:39.918]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.918]                   }
[16:13:39.918]                 }
[16:13:39.918]             }
[16:13:39.918]         }))
[16:13:39.918]     }, error = function(ex) {
[16:13:39.918]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:39.918]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.918]                 ...future.rng), started = ...future.startTime, 
[16:13:39.918]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:39.918]             version = "1.8"), class = "FutureResult")
[16:13:39.918]     }, finally = {
[16:13:39.918]         if (!identical(...future.workdir, getwd())) 
[16:13:39.918]             setwd(...future.workdir)
[16:13:39.918]         {
[16:13:39.918]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:39.918]                 ...future.oldOptions$nwarnings <- NULL
[16:13:39.918]             }
[16:13:39.918]             base::options(...future.oldOptions)
[16:13:39.918]             if (.Platform$OS.type == "windows") {
[16:13:39.918]                 old_names <- names(...future.oldEnvVars)
[16:13:39.918]                 envs <- base::Sys.getenv()
[16:13:39.918]                 names <- names(envs)
[16:13:39.918]                 common <- intersect(names, old_names)
[16:13:39.918]                 added <- setdiff(names, old_names)
[16:13:39.918]                 removed <- setdiff(old_names, names)
[16:13:39.918]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:39.918]                   envs[common]]
[16:13:39.918]                 NAMES <- toupper(changed)
[16:13:39.918]                 args <- list()
[16:13:39.918]                 for (kk in seq_along(NAMES)) {
[16:13:39.918]                   name <- changed[[kk]]
[16:13:39.918]                   NAME <- NAMES[[kk]]
[16:13:39.918]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.918]                     next
[16:13:39.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.918]                 }
[16:13:39.918]                 NAMES <- toupper(added)
[16:13:39.918]                 for (kk in seq_along(NAMES)) {
[16:13:39.918]                   name <- added[[kk]]
[16:13:39.918]                   NAME <- NAMES[[kk]]
[16:13:39.918]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.918]                     next
[16:13:39.918]                   args[[name]] <- ""
[16:13:39.918]                 }
[16:13:39.918]                 NAMES <- toupper(removed)
[16:13:39.918]                 for (kk in seq_along(NAMES)) {
[16:13:39.918]                   name <- removed[[kk]]
[16:13:39.918]                   NAME <- NAMES[[kk]]
[16:13:39.918]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.918]                     next
[16:13:39.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.918]                 }
[16:13:39.918]                 if (length(args) > 0) 
[16:13:39.918]                   base::do.call(base::Sys.setenv, args = args)
[16:13:39.918]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:39.918]             }
[16:13:39.918]             else {
[16:13:39.918]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:39.918]             }
[16:13:39.918]             {
[16:13:39.918]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:39.918]                   0L) {
[16:13:39.918]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:39.918]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:39.918]                   base::options(opts)
[16:13:39.918]                 }
[16:13:39.918]                 {
[16:13:39.918]                   {
[16:13:39.918]                     NULL
[16:13:39.918]                     RNGkind("Mersenne-Twister")
[16:13:39.918]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:39.918]                       inherits = FALSE)
[16:13:39.918]                   }
[16:13:39.918]                   options(future.plan = NULL)
[16:13:39.918]                   if (is.na(NA_character_)) 
[16:13:39.918]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.918]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:39.918]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:39.918]                   {
[16:13:39.918]                     future <- SequentialFuture(..., envir = envir)
[16:13:39.918]                     if (!future$lazy) 
[16:13:39.918]                       future <- run(future)
[16:13:39.918]                     invisible(future)
[16:13:39.918]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:39.918]                 }
[16:13:39.918]             }
[16:13:39.918]         }
[16:13:39.918]     })
[16:13:39.918]     if (TRUE) {
[16:13:39.918]         base::sink(type = "output", split = FALSE)
[16:13:39.918]         if (TRUE) {
[16:13:39.918]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:39.918]         }
[16:13:39.918]         else {
[16:13:39.918]             ...future.result["stdout"] <- base::list(NULL)
[16:13:39.918]         }
[16:13:39.918]         base::close(...future.stdout)
[16:13:39.918]         ...future.stdout <- NULL
[16:13:39.918]     }
[16:13:39.918]     ...future.result$conditions <- ...future.conditions
[16:13:39.918]     ...future.result$finished <- base::Sys.time()
[16:13:39.918]     ...future.result
[16:13:39.918] }
[16:13:39.920] plan(): Setting new future strategy stack:
[16:13:39.920] List of future strategies:
[16:13:39.920] 1. sequential:
[16:13:39.920]    - args: function (..., envir = parent.frame())
[16:13:39.920]    - tweaked: FALSE
[16:13:39.920]    - call: NULL
[16:13:39.920] plan(): nbrOfWorkers() = 1
[16:13:39.921] plan(): Setting new future strategy stack:
[16:13:39.921] List of future strategies:
[16:13:39.921] 1. sequential:
[16:13:39.921]    - args: function (..., envir = parent.frame())
[16:13:39.921]    - tweaked: FALSE
[16:13:39.921]    - call: plan(strategy)
[16:13:39.921] plan(): nbrOfWorkers() = 1
[16:13:39.921] SequentialFuture started (and completed)
[16:13:39.922] - Launch lazy future ... done
[16:13:39.922] run() for ‘SequentialFuture’ ... done
[16:13:39.922] getGlobalsAndPackages() ...
[16:13:39.922] Searching for globals...
[16:13:39.923] - globals found: [1] ‘{’
[16:13:39.923] Searching for globals ... DONE
[16:13:39.923] Resolving globals: FALSE
[16:13:39.923] 
[16:13:39.923] 
[16:13:39.923] getGlobalsAndPackages() ... DONE
[16:13:39.924] run() for ‘Future’ ...
[16:13:39.924] - state: ‘created’
[16:13:39.924] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:39.924] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:39.924] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:39.924]   - Field: ‘label’
[16:13:39.924]   - Field: ‘local’
[16:13:39.925]   - Field: ‘owner’
[16:13:39.925]   - Field: ‘envir’
[16:13:39.925]   - Field: ‘packages’
[16:13:39.925]   - Field: ‘gc’
[16:13:39.925]   - Field: ‘conditions’
[16:13:39.925]   - Field: ‘expr’
[16:13:39.925]   - Field: ‘uuid’
[16:13:39.925]   - Field: ‘seed’
[16:13:39.925]   - Field: ‘version’
[16:13:39.925]   - Field: ‘result’
[16:13:39.925]   - Field: ‘asynchronous’
[16:13:39.926]   - Field: ‘calls’
[16:13:39.926]   - Field: ‘globals’
[16:13:39.926]   - Field: ‘stdout’
[16:13:39.926]   - Field: ‘earlySignal’
[16:13:39.926]   - Field: ‘lazy’
[16:13:39.926]   - Field: ‘state’
[16:13:39.926] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:39.926] - Launch lazy future ...
[16:13:39.926] Packages needed by the future expression (n = 0): <none>
[16:13:39.927] Packages needed by future strategies (n = 0): <none>
[16:13:39.927] {
[16:13:39.927]     {
[16:13:39.927]         {
[16:13:39.927]             ...future.startTime <- base::Sys.time()
[16:13:39.927]             {
[16:13:39.927]                 {
[16:13:39.927]                   {
[16:13:39.927]                     base::local({
[16:13:39.927]                       has_future <- base::requireNamespace("future", 
[16:13:39.927]                         quietly = TRUE)
[16:13:39.927]                       if (has_future) {
[16:13:39.927]                         ns <- base::getNamespace("future")
[16:13:39.927]                         version <- ns[[".package"]][["version"]]
[16:13:39.927]                         if (is.null(version)) 
[16:13:39.927]                           version <- utils::packageVersion("future")
[16:13:39.927]                       }
[16:13:39.927]                       else {
[16:13:39.927]                         version <- NULL
[16:13:39.927]                       }
[16:13:39.927]                       if (!has_future || version < "1.8.0") {
[16:13:39.927]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:39.927]                           "", base::R.version$version.string), 
[16:13:39.927]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:39.927]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:39.927]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:39.927]                             "release", "version")], collapse = " "), 
[16:13:39.927]                           hostname = base::Sys.info()[["nodename"]])
[16:13:39.927]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:39.927]                           info)
[16:13:39.927]                         info <- base::paste(info, collapse = "; ")
[16:13:39.927]                         if (!has_future) {
[16:13:39.927]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:39.927]                             info)
[16:13:39.927]                         }
[16:13:39.927]                         else {
[16:13:39.927]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:39.927]                             info, version)
[16:13:39.927]                         }
[16:13:39.927]                         base::stop(msg)
[16:13:39.927]                       }
[16:13:39.927]                     })
[16:13:39.927]                   }
[16:13:39.927]                   options(future.plan = NULL)
[16:13:39.927]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.927]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:39.927]                 }
[16:13:39.927]                 ...future.workdir <- getwd()
[16:13:39.927]             }
[16:13:39.927]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:39.927]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:39.927]         }
[16:13:39.927]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:39.927]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:39.927]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:39.927]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:39.927]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:39.927]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:39.927]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:39.927]             base::names(...future.oldOptions))
[16:13:39.927]     }
[16:13:39.927]     if (FALSE) {
[16:13:39.927]     }
[16:13:39.927]     else {
[16:13:39.927]         if (TRUE) {
[16:13:39.927]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:39.927]                 open = "w")
[16:13:39.927]         }
[16:13:39.927]         else {
[16:13:39.927]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:39.927]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:39.927]         }
[16:13:39.927]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:39.927]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:39.927]             base::sink(type = "output", split = FALSE)
[16:13:39.927]             base::close(...future.stdout)
[16:13:39.927]         }, add = TRUE)
[16:13:39.927]     }
[16:13:39.927]     ...future.frame <- base::sys.nframe()
[16:13:39.927]     ...future.conditions <- base::list()
[16:13:39.927]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:39.927]     if (FALSE) {
[16:13:39.927]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:39.927]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:39.927]     }
[16:13:39.927]     ...future.result <- base::tryCatch({
[16:13:39.927]         base::withCallingHandlers({
[16:13:39.927]             ...future.value <- base::withVisible(base::local({
[16:13:39.927]                 2
[16:13:39.927]             }))
[16:13:39.927]             future::FutureResult(value = ...future.value$value, 
[16:13:39.927]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.927]                   ...future.rng), globalenv = if (FALSE) 
[16:13:39.927]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:39.927]                     ...future.globalenv.names))
[16:13:39.927]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:39.927]         }, condition = base::local({
[16:13:39.927]             c <- base::c
[16:13:39.927]             inherits <- base::inherits
[16:13:39.927]             invokeRestart <- base::invokeRestart
[16:13:39.927]             length <- base::length
[16:13:39.927]             list <- base::list
[16:13:39.927]             seq.int <- base::seq.int
[16:13:39.927]             signalCondition <- base::signalCondition
[16:13:39.927]             sys.calls <- base::sys.calls
[16:13:39.927]             `[[` <- base::`[[`
[16:13:39.927]             `+` <- base::`+`
[16:13:39.927]             `<<-` <- base::`<<-`
[16:13:39.927]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:39.927]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:39.927]                   3L)]
[16:13:39.927]             }
[16:13:39.927]             function(cond) {
[16:13:39.927]                 is_error <- inherits(cond, "error")
[16:13:39.927]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:39.927]                   NULL)
[16:13:39.927]                 if (is_error) {
[16:13:39.927]                   sessionInformation <- function() {
[16:13:39.927]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:39.927]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:39.927]                       search = base::search(), system = base::Sys.info())
[16:13:39.927]                   }
[16:13:39.927]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.927]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:39.927]                     cond$call), session = sessionInformation(), 
[16:13:39.927]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:39.927]                   signalCondition(cond)
[16:13:39.927]                 }
[16:13:39.927]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:39.927]                 "immediateCondition"))) {
[16:13:39.927]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:39.927]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.927]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:39.927]                   if (TRUE && !signal) {
[16:13:39.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.927]                     {
[16:13:39.927]                       inherits <- base::inherits
[16:13:39.927]                       invokeRestart <- base::invokeRestart
[16:13:39.927]                       is.null <- base::is.null
[16:13:39.927]                       muffled <- FALSE
[16:13:39.927]                       if (inherits(cond, "message")) {
[16:13:39.927]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.927]                         if (muffled) 
[16:13:39.927]                           invokeRestart("muffleMessage")
[16:13:39.927]                       }
[16:13:39.927]                       else if (inherits(cond, "warning")) {
[16:13:39.927]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.927]                         if (muffled) 
[16:13:39.927]                           invokeRestart("muffleWarning")
[16:13:39.927]                       }
[16:13:39.927]                       else if (inherits(cond, "condition")) {
[16:13:39.927]                         if (!is.null(pattern)) {
[16:13:39.927]                           computeRestarts <- base::computeRestarts
[16:13:39.927]                           grepl <- base::grepl
[16:13:39.927]                           restarts <- computeRestarts(cond)
[16:13:39.927]                           for (restart in restarts) {
[16:13:39.927]                             name <- restart$name
[16:13:39.927]                             if (is.null(name)) 
[16:13:39.927]                               next
[16:13:39.927]                             if (!grepl(pattern, name)) 
[16:13:39.927]                               next
[16:13:39.927]                             invokeRestart(restart)
[16:13:39.927]                             muffled <- TRUE
[16:13:39.927]                             break
[16:13:39.927]                           }
[16:13:39.927]                         }
[16:13:39.927]                       }
[16:13:39.927]                       invisible(muffled)
[16:13:39.927]                     }
[16:13:39.927]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.927]                   }
[16:13:39.927]                 }
[16:13:39.927]                 else {
[16:13:39.927]                   if (TRUE) {
[16:13:39.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.927]                     {
[16:13:39.927]                       inherits <- base::inherits
[16:13:39.927]                       invokeRestart <- base::invokeRestart
[16:13:39.927]                       is.null <- base::is.null
[16:13:39.927]                       muffled <- FALSE
[16:13:39.927]                       if (inherits(cond, "message")) {
[16:13:39.927]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.927]                         if (muffled) 
[16:13:39.927]                           invokeRestart("muffleMessage")
[16:13:39.927]                       }
[16:13:39.927]                       else if (inherits(cond, "warning")) {
[16:13:39.927]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.927]                         if (muffled) 
[16:13:39.927]                           invokeRestart("muffleWarning")
[16:13:39.927]                       }
[16:13:39.927]                       else if (inherits(cond, "condition")) {
[16:13:39.927]                         if (!is.null(pattern)) {
[16:13:39.927]                           computeRestarts <- base::computeRestarts
[16:13:39.927]                           grepl <- base::grepl
[16:13:39.927]                           restarts <- computeRestarts(cond)
[16:13:39.927]                           for (restart in restarts) {
[16:13:39.927]                             name <- restart$name
[16:13:39.927]                             if (is.null(name)) 
[16:13:39.927]                               next
[16:13:39.927]                             if (!grepl(pattern, name)) 
[16:13:39.927]                               next
[16:13:39.927]                             invokeRestart(restart)
[16:13:39.927]                             muffled <- TRUE
[16:13:39.927]                             break
[16:13:39.927]                           }
[16:13:39.927]                         }
[16:13:39.927]                       }
[16:13:39.927]                       invisible(muffled)
[16:13:39.927]                     }
[16:13:39.927]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.927]                   }
[16:13:39.927]                 }
[16:13:39.927]             }
[16:13:39.927]         }))
[16:13:39.927]     }, error = function(ex) {
[16:13:39.927]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:39.927]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.927]                 ...future.rng), started = ...future.startTime, 
[16:13:39.927]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:39.927]             version = "1.8"), class = "FutureResult")
[16:13:39.927]     }, finally = {
[16:13:39.927]         if (!identical(...future.workdir, getwd())) 
[16:13:39.927]             setwd(...future.workdir)
[16:13:39.927]         {
[16:13:39.927]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:39.927]                 ...future.oldOptions$nwarnings <- NULL
[16:13:39.927]             }
[16:13:39.927]             base::options(...future.oldOptions)
[16:13:39.927]             if (.Platform$OS.type == "windows") {
[16:13:39.927]                 old_names <- names(...future.oldEnvVars)
[16:13:39.927]                 envs <- base::Sys.getenv()
[16:13:39.927]                 names <- names(envs)
[16:13:39.927]                 common <- intersect(names, old_names)
[16:13:39.927]                 added <- setdiff(names, old_names)
[16:13:39.927]                 removed <- setdiff(old_names, names)
[16:13:39.927]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:39.927]                   envs[common]]
[16:13:39.927]                 NAMES <- toupper(changed)
[16:13:39.927]                 args <- list()
[16:13:39.927]                 for (kk in seq_along(NAMES)) {
[16:13:39.927]                   name <- changed[[kk]]
[16:13:39.927]                   NAME <- NAMES[[kk]]
[16:13:39.927]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.927]                     next
[16:13:39.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.927]                 }
[16:13:39.927]                 NAMES <- toupper(added)
[16:13:39.927]                 for (kk in seq_along(NAMES)) {
[16:13:39.927]                   name <- added[[kk]]
[16:13:39.927]                   NAME <- NAMES[[kk]]
[16:13:39.927]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.927]                     next
[16:13:39.927]                   args[[name]] <- ""
[16:13:39.927]                 }
[16:13:39.927]                 NAMES <- toupper(removed)
[16:13:39.927]                 for (kk in seq_along(NAMES)) {
[16:13:39.927]                   name <- removed[[kk]]
[16:13:39.927]                   NAME <- NAMES[[kk]]
[16:13:39.927]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.927]                     next
[16:13:39.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.927]                 }
[16:13:39.927]                 if (length(args) > 0) 
[16:13:39.927]                   base::do.call(base::Sys.setenv, args = args)
[16:13:39.927]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:39.927]             }
[16:13:39.927]             else {
[16:13:39.927]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:39.927]             }
[16:13:39.927]             {
[16:13:39.927]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:39.927]                   0L) {
[16:13:39.927]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:39.927]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:39.927]                   base::options(opts)
[16:13:39.927]                 }
[16:13:39.927]                 {
[16:13:39.927]                   {
[16:13:39.927]                     NULL
[16:13:39.927]                     RNGkind("Mersenne-Twister")
[16:13:39.927]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:39.927]                       inherits = FALSE)
[16:13:39.927]                   }
[16:13:39.927]                   options(future.plan = NULL)
[16:13:39.927]                   if (is.na(NA_character_)) 
[16:13:39.927]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.927]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:39.927]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:39.927]                   {
[16:13:39.927]                     future <- SequentialFuture(..., envir = envir)
[16:13:39.927]                     if (!future$lazy) 
[16:13:39.927]                       future <- run(future)
[16:13:39.927]                     invisible(future)
[16:13:39.927]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:39.927]                 }
[16:13:39.927]             }
[16:13:39.927]         }
[16:13:39.927]     })
[16:13:39.927]     if (TRUE) {
[16:13:39.927]         base::sink(type = "output", split = FALSE)
[16:13:39.927]         if (TRUE) {
[16:13:39.927]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:39.927]         }
[16:13:39.927]         else {
[16:13:39.927]             ...future.result["stdout"] <- base::list(NULL)
[16:13:39.927]         }
[16:13:39.927]         base::close(...future.stdout)
[16:13:39.927]         ...future.stdout <- NULL
[16:13:39.927]     }
[16:13:39.927]     ...future.result$conditions <- ...future.conditions
[16:13:39.927]     ...future.result$finished <- base::Sys.time()
[16:13:39.927]     ...future.result
[16:13:39.927] }
[16:13:39.929] plan(): Setting new future strategy stack:
[16:13:39.929] List of future strategies:
[16:13:39.929] 1. sequential:
[16:13:39.929]    - args: function (..., envir = parent.frame())
[16:13:39.929]    - tweaked: FALSE
[16:13:39.929]    - call: NULL
[16:13:39.929] plan(): nbrOfWorkers() = 1
[16:13:39.930] plan(): Setting new future strategy stack:
[16:13:39.930] List of future strategies:
[16:13:39.930] 1. sequential:
[16:13:39.930]    - args: function (..., envir = parent.frame())
[16:13:39.930]    - tweaked: FALSE
[16:13:39.930]    - call: plan(strategy)
[16:13:39.931] plan(): nbrOfWorkers() = 1
[16:13:39.931] SequentialFuture started (and completed)
[16:13:39.931] - Launch lazy future ... done
[16:13:39.931] run() for ‘SequentialFuture’ ... done
[16:13:39.931] resolve() on environment ...
[16:13:39.932]  recursive: 0
[16:13:39.932]  elements: [3] ‘a’
[16:13:39.932] resolved() for ‘SequentialFuture’ ...
[16:13:39.932] - state: ‘finished’
[16:13:39.932] - run: TRUE
[16:13:39.932] - result: ‘FutureResult’
[16:13:39.933] resolved() for ‘SequentialFuture’ ... done
[16:13:39.933] Future #1
[16:13:39.933]  length: 2 (resolved future 1)
[16:13:39.933] resolved() for ‘SequentialFuture’ ...
[16:13:39.933] - state: ‘finished’
[16:13:39.933] - run: TRUE
[16:13:39.933] - result: ‘FutureResult’
[16:13:39.933] resolved() for ‘SequentialFuture’ ... done
[16:13:39.933] Future #2
[16:13:39.933]  length: 1 (resolved future 2)
[16:13:39.934]  length: 0 (resolved future 3)
[16:13:39.934] resolve() on environment ... DONE
[16:13:39.934] resolved() for ‘SequentialFuture’ ...
[16:13:39.934] - state: ‘finished’
[16:13:39.934] - run: TRUE
[16:13:39.934] - result: ‘FutureResult’
[16:13:39.934] resolved() for ‘SequentialFuture’ ... done
[16:13:39.935] resolve() on environment ...
[16:13:39.935]  recursive: 0
[16:13:39.935]  elements: [3] ‘b’
[16:13:39.935] resolved() for ‘SequentialFuture’ ...
[16:13:39.935] - state: ‘finished’
[16:13:39.935] - run: TRUE
[16:13:39.936] - result: ‘FutureResult’
[16:13:39.936] resolved() for ‘SequentialFuture’ ... done
[16:13:39.938] Future #1
[16:13:39.938]  length: 2 (resolved future 1)
[16:13:39.938] resolved() for ‘SequentialFuture’ ...
[16:13:39.938] - state: ‘finished’
[16:13:39.938] - run: TRUE
[16:13:39.938] - result: ‘FutureResult’
[16:13:39.938] resolved() for ‘SequentialFuture’ ... done
[16:13:39.939] Future #2
[16:13:39.939]  length: 1 (resolved future 2)
[16:13:39.939]  length: 0 (resolved future 3)
[16:13:39.939] resolve() on environment ... DONE
[16:13:39.939] resolve() on environment ...
[16:13:39.939]  recursive: 0
[16:13:39.940]  elements: [3] ‘c’
[16:13:39.940] resolved() for ‘SequentialFuture’ ...
[16:13:39.940] - state: ‘finished’
[16:13:39.940] - run: TRUE
[16:13:39.940] - result: ‘FutureResult’
[16:13:39.940] resolved() for ‘SequentialFuture’ ... done
[16:13:39.940] Future #1
[16:13:39.941]  length: 2 (resolved future 1)
[16:13:39.941] resolved() for ‘SequentialFuture’ ...
[16:13:39.941] - state: ‘finished’
[16:13:39.941] - run: TRUE
[16:13:39.941] - result: ‘FutureResult’
[16:13:39.941] resolved() for ‘SequentialFuture’ ... done
[16:13:39.941] Future #2
[16:13:39.941]  length: 1 (resolved future 2)
[16:13:39.941]  length: 0 (resolved future 3)
[16:13:39.941] resolve() on environment ... DONE
[16:13:39.942] resolve() on environment ...
[16:13:39.942]  recursive: 0
[16:13:39.942]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[16:13:39.943] resolved() for ‘SequentialFuture’ ...
[16:13:39.943] - state: ‘finished’
[16:13:39.943] - run: TRUE
[16:13:39.943] - result: ‘FutureResult’
[16:13:39.943] resolved() for ‘SequentialFuture’ ... done
[16:13:39.943] Future #1
[16:13:39.944]  length: 2 (resolved future 1)
[16:13:39.944] resolved() for ‘SequentialFuture’ ...
[16:13:39.944] - state: ‘finished’
[16:13:39.944] - run: TRUE
[16:13:39.944] - result: ‘FutureResult’
[16:13:39.944] resolved() for ‘SequentialFuture’ ... done
[16:13:39.944] Future #2
[16:13:39.944]  length: 1 (resolved future 2)
[16:13:39.944]  length: 0 (resolved future 3)
[16:13:39.945] resolve() on environment ... DONE
[16:13:39.945] resolve() on environment ...
[16:13:39.945]  recursive: 99
[16:13:39.945]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[16:13:39.946] resolved() for ‘SequentialFuture’ ...
[16:13:39.946] - state: ‘finished’
[16:13:39.946] - run: TRUE
[16:13:39.946] - result: ‘FutureResult’
[16:13:39.946] resolved() for ‘SequentialFuture’ ... done
[16:13:39.946] Future #1
[16:13:39.946] resolved() for ‘SequentialFuture’ ...
[16:13:39.946] - state: ‘finished’
[16:13:39.946] - run: TRUE
[16:13:39.947] - result: ‘FutureResult’
[16:13:39.947] resolved() for ‘SequentialFuture’ ... done
[16:13:39.947] A SequentialFuture was resolved
[16:13:39.947]  length: 2 (resolved future 1)
[16:13:39.947] resolved() for ‘SequentialFuture’ ...
[16:13:39.947] - state: ‘finished’
[16:13:39.947] - run: TRUE
[16:13:39.947] - result: ‘FutureResult’
[16:13:39.947] resolved() for ‘SequentialFuture’ ... done
[16:13:39.947] Future #2
[16:13:39.948] resolved() for ‘SequentialFuture’ ...
[16:13:39.948] - state: ‘finished’
[16:13:39.948] - run: TRUE
[16:13:39.948] - result: ‘FutureResult’
[16:13:39.948] resolved() for ‘SequentialFuture’ ... done
[16:13:39.948] A SequentialFuture was resolved
[16:13:39.948]  length: 1 (resolved future 2)
[16:13:39.948]  length: 0 (resolved future 3)
[16:13:39.948] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[16:13:39.949] resolve() on list environment ...
[16:13:39.950]  recursive: 0
[16:13:39.950]  length: 2
[16:13:39.951]  elements: ‘a’, ‘b’
[16:13:39.951]  length: 1 (resolved future 1)
[16:13:39.951]  length: 0 (resolved future 2)
[16:13:39.951] resolve() on list environment ... DONE
[16:13:39.951] getGlobalsAndPackages() ...
[16:13:39.951] Searching for globals...
[16:13:39.951] 
[16:13:39.952] Searching for globals ... DONE
[16:13:39.952] - globals: [0] <none>
[16:13:39.952] getGlobalsAndPackages() ... DONE
[16:13:39.952] run() for ‘Future’ ...
[16:13:39.952] - state: ‘created’
[16:13:39.952] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:39.953] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:39.953] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:39.953]   - Field: ‘label’
[16:13:39.953]   - Field: ‘local’
[16:13:39.953]   - Field: ‘owner’
[16:13:39.953]   - Field: ‘envir’
[16:13:39.953]   - Field: ‘packages’
[16:13:39.953]   - Field: ‘gc’
[16:13:39.953]   - Field: ‘conditions’
[16:13:39.953]   - Field: ‘expr’
[16:13:39.953]   - Field: ‘uuid’
[16:13:39.954]   - Field: ‘seed’
[16:13:39.954]   - Field: ‘version’
[16:13:39.954]   - Field: ‘result’
[16:13:39.954]   - Field: ‘asynchronous’
[16:13:39.954]   - Field: ‘calls’
[16:13:39.954]   - Field: ‘globals’
[16:13:39.954]   - Field: ‘stdout’
[16:13:39.954]   - Field: ‘earlySignal’
[16:13:39.954]   - Field: ‘lazy’
[16:13:39.954]   - Field: ‘state’
[16:13:39.954] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:39.955] - Launch lazy future ...
[16:13:39.955] Packages needed by the future expression (n = 0): <none>
[16:13:39.955] Packages needed by future strategies (n = 0): <none>
[16:13:39.955] {
[16:13:39.955]     {
[16:13:39.955]         {
[16:13:39.955]             ...future.startTime <- base::Sys.time()
[16:13:39.955]             {
[16:13:39.955]                 {
[16:13:39.955]                   {
[16:13:39.955]                     base::local({
[16:13:39.955]                       has_future <- base::requireNamespace("future", 
[16:13:39.955]                         quietly = TRUE)
[16:13:39.955]                       if (has_future) {
[16:13:39.955]                         ns <- base::getNamespace("future")
[16:13:39.955]                         version <- ns[[".package"]][["version"]]
[16:13:39.955]                         if (is.null(version)) 
[16:13:39.955]                           version <- utils::packageVersion("future")
[16:13:39.955]                       }
[16:13:39.955]                       else {
[16:13:39.955]                         version <- NULL
[16:13:39.955]                       }
[16:13:39.955]                       if (!has_future || version < "1.8.0") {
[16:13:39.955]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:39.955]                           "", base::R.version$version.string), 
[16:13:39.955]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:39.955]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:39.955]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:39.955]                             "release", "version")], collapse = " "), 
[16:13:39.955]                           hostname = base::Sys.info()[["nodename"]])
[16:13:39.955]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:39.955]                           info)
[16:13:39.955]                         info <- base::paste(info, collapse = "; ")
[16:13:39.955]                         if (!has_future) {
[16:13:39.955]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:39.955]                             info)
[16:13:39.955]                         }
[16:13:39.955]                         else {
[16:13:39.955]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:39.955]                             info, version)
[16:13:39.955]                         }
[16:13:39.955]                         base::stop(msg)
[16:13:39.955]                       }
[16:13:39.955]                     })
[16:13:39.955]                   }
[16:13:39.955]                   options(future.plan = NULL)
[16:13:39.955]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.955]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:39.955]                 }
[16:13:39.955]                 ...future.workdir <- getwd()
[16:13:39.955]             }
[16:13:39.955]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:39.955]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:39.955]         }
[16:13:39.955]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:39.955]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:39.955]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:39.955]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:39.955]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:39.955]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:39.955]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:39.955]             base::names(...future.oldOptions))
[16:13:39.955]     }
[16:13:39.955]     if (FALSE) {
[16:13:39.955]     }
[16:13:39.955]     else {
[16:13:39.955]         if (TRUE) {
[16:13:39.955]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:39.955]                 open = "w")
[16:13:39.955]         }
[16:13:39.955]         else {
[16:13:39.955]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:39.955]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:39.955]         }
[16:13:39.955]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:39.955]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:39.955]             base::sink(type = "output", split = FALSE)
[16:13:39.955]             base::close(...future.stdout)
[16:13:39.955]         }, add = TRUE)
[16:13:39.955]     }
[16:13:39.955]     ...future.frame <- base::sys.nframe()
[16:13:39.955]     ...future.conditions <- base::list()
[16:13:39.955]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:39.955]     if (FALSE) {
[16:13:39.955]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:39.955]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:39.955]     }
[16:13:39.955]     ...future.result <- base::tryCatch({
[16:13:39.955]         base::withCallingHandlers({
[16:13:39.955]             ...future.value <- base::withVisible(base::local(1))
[16:13:39.955]             future::FutureResult(value = ...future.value$value, 
[16:13:39.955]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.955]                   ...future.rng), globalenv = if (FALSE) 
[16:13:39.955]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:39.955]                     ...future.globalenv.names))
[16:13:39.955]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:39.955]         }, condition = base::local({
[16:13:39.955]             c <- base::c
[16:13:39.955]             inherits <- base::inherits
[16:13:39.955]             invokeRestart <- base::invokeRestart
[16:13:39.955]             length <- base::length
[16:13:39.955]             list <- base::list
[16:13:39.955]             seq.int <- base::seq.int
[16:13:39.955]             signalCondition <- base::signalCondition
[16:13:39.955]             sys.calls <- base::sys.calls
[16:13:39.955]             `[[` <- base::`[[`
[16:13:39.955]             `+` <- base::`+`
[16:13:39.955]             `<<-` <- base::`<<-`
[16:13:39.955]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:39.955]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:39.955]                   3L)]
[16:13:39.955]             }
[16:13:39.955]             function(cond) {
[16:13:39.955]                 is_error <- inherits(cond, "error")
[16:13:39.955]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:39.955]                   NULL)
[16:13:39.955]                 if (is_error) {
[16:13:39.955]                   sessionInformation <- function() {
[16:13:39.955]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:39.955]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:39.955]                       search = base::search(), system = base::Sys.info())
[16:13:39.955]                   }
[16:13:39.955]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.955]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:39.955]                     cond$call), session = sessionInformation(), 
[16:13:39.955]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:39.955]                   signalCondition(cond)
[16:13:39.955]                 }
[16:13:39.955]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:39.955]                 "immediateCondition"))) {
[16:13:39.955]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:39.955]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.955]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:39.955]                   if (TRUE && !signal) {
[16:13:39.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.955]                     {
[16:13:39.955]                       inherits <- base::inherits
[16:13:39.955]                       invokeRestart <- base::invokeRestart
[16:13:39.955]                       is.null <- base::is.null
[16:13:39.955]                       muffled <- FALSE
[16:13:39.955]                       if (inherits(cond, "message")) {
[16:13:39.955]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.955]                         if (muffled) 
[16:13:39.955]                           invokeRestart("muffleMessage")
[16:13:39.955]                       }
[16:13:39.955]                       else if (inherits(cond, "warning")) {
[16:13:39.955]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.955]                         if (muffled) 
[16:13:39.955]                           invokeRestart("muffleWarning")
[16:13:39.955]                       }
[16:13:39.955]                       else if (inherits(cond, "condition")) {
[16:13:39.955]                         if (!is.null(pattern)) {
[16:13:39.955]                           computeRestarts <- base::computeRestarts
[16:13:39.955]                           grepl <- base::grepl
[16:13:39.955]                           restarts <- computeRestarts(cond)
[16:13:39.955]                           for (restart in restarts) {
[16:13:39.955]                             name <- restart$name
[16:13:39.955]                             if (is.null(name)) 
[16:13:39.955]                               next
[16:13:39.955]                             if (!grepl(pattern, name)) 
[16:13:39.955]                               next
[16:13:39.955]                             invokeRestart(restart)
[16:13:39.955]                             muffled <- TRUE
[16:13:39.955]                             break
[16:13:39.955]                           }
[16:13:39.955]                         }
[16:13:39.955]                       }
[16:13:39.955]                       invisible(muffled)
[16:13:39.955]                     }
[16:13:39.955]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.955]                   }
[16:13:39.955]                 }
[16:13:39.955]                 else {
[16:13:39.955]                   if (TRUE) {
[16:13:39.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.955]                     {
[16:13:39.955]                       inherits <- base::inherits
[16:13:39.955]                       invokeRestart <- base::invokeRestart
[16:13:39.955]                       is.null <- base::is.null
[16:13:39.955]                       muffled <- FALSE
[16:13:39.955]                       if (inherits(cond, "message")) {
[16:13:39.955]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.955]                         if (muffled) 
[16:13:39.955]                           invokeRestart("muffleMessage")
[16:13:39.955]                       }
[16:13:39.955]                       else if (inherits(cond, "warning")) {
[16:13:39.955]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.955]                         if (muffled) 
[16:13:39.955]                           invokeRestart("muffleWarning")
[16:13:39.955]                       }
[16:13:39.955]                       else if (inherits(cond, "condition")) {
[16:13:39.955]                         if (!is.null(pattern)) {
[16:13:39.955]                           computeRestarts <- base::computeRestarts
[16:13:39.955]                           grepl <- base::grepl
[16:13:39.955]                           restarts <- computeRestarts(cond)
[16:13:39.955]                           for (restart in restarts) {
[16:13:39.955]                             name <- restart$name
[16:13:39.955]                             if (is.null(name)) 
[16:13:39.955]                               next
[16:13:39.955]                             if (!grepl(pattern, name)) 
[16:13:39.955]                               next
[16:13:39.955]                             invokeRestart(restart)
[16:13:39.955]                             muffled <- TRUE
[16:13:39.955]                             break
[16:13:39.955]                           }
[16:13:39.955]                         }
[16:13:39.955]                       }
[16:13:39.955]                       invisible(muffled)
[16:13:39.955]                     }
[16:13:39.955]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.955]                   }
[16:13:39.955]                 }
[16:13:39.955]             }
[16:13:39.955]         }))
[16:13:39.955]     }, error = function(ex) {
[16:13:39.955]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:39.955]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.955]                 ...future.rng), started = ...future.startTime, 
[16:13:39.955]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:39.955]             version = "1.8"), class = "FutureResult")
[16:13:39.955]     }, finally = {
[16:13:39.955]         if (!identical(...future.workdir, getwd())) 
[16:13:39.955]             setwd(...future.workdir)
[16:13:39.955]         {
[16:13:39.955]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:39.955]                 ...future.oldOptions$nwarnings <- NULL
[16:13:39.955]             }
[16:13:39.955]             base::options(...future.oldOptions)
[16:13:39.955]             if (.Platform$OS.type == "windows") {
[16:13:39.955]                 old_names <- names(...future.oldEnvVars)
[16:13:39.955]                 envs <- base::Sys.getenv()
[16:13:39.955]                 names <- names(envs)
[16:13:39.955]                 common <- intersect(names, old_names)
[16:13:39.955]                 added <- setdiff(names, old_names)
[16:13:39.955]                 removed <- setdiff(old_names, names)
[16:13:39.955]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:39.955]                   envs[common]]
[16:13:39.955]                 NAMES <- toupper(changed)
[16:13:39.955]                 args <- list()
[16:13:39.955]                 for (kk in seq_along(NAMES)) {
[16:13:39.955]                   name <- changed[[kk]]
[16:13:39.955]                   NAME <- NAMES[[kk]]
[16:13:39.955]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.955]                     next
[16:13:39.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.955]                 }
[16:13:39.955]                 NAMES <- toupper(added)
[16:13:39.955]                 for (kk in seq_along(NAMES)) {
[16:13:39.955]                   name <- added[[kk]]
[16:13:39.955]                   NAME <- NAMES[[kk]]
[16:13:39.955]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.955]                     next
[16:13:39.955]                   args[[name]] <- ""
[16:13:39.955]                 }
[16:13:39.955]                 NAMES <- toupper(removed)
[16:13:39.955]                 for (kk in seq_along(NAMES)) {
[16:13:39.955]                   name <- removed[[kk]]
[16:13:39.955]                   NAME <- NAMES[[kk]]
[16:13:39.955]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.955]                     next
[16:13:39.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.955]                 }
[16:13:39.955]                 if (length(args) > 0) 
[16:13:39.955]                   base::do.call(base::Sys.setenv, args = args)
[16:13:39.955]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:39.955]             }
[16:13:39.955]             else {
[16:13:39.955]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:39.955]             }
[16:13:39.955]             {
[16:13:39.955]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:39.955]                   0L) {
[16:13:39.955]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:39.955]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:39.955]                   base::options(opts)
[16:13:39.955]                 }
[16:13:39.955]                 {
[16:13:39.955]                   {
[16:13:39.955]                     NULL
[16:13:39.955]                     RNGkind("Mersenne-Twister")
[16:13:39.955]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:39.955]                       inherits = FALSE)
[16:13:39.955]                   }
[16:13:39.955]                   options(future.plan = NULL)
[16:13:39.955]                   if (is.na(NA_character_)) 
[16:13:39.955]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.955]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:39.955]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:39.955]                   {
[16:13:39.955]                     future <- SequentialFuture(..., envir = envir)
[16:13:39.955]                     if (!future$lazy) 
[16:13:39.955]                       future <- run(future)
[16:13:39.955]                     invisible(future)
[16:13:39.955]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:39.955]                 }
[16:13:39.955]             }
[16:13:39.955]         }
[16:13:39.955]     })
[16:13:39.955]     if (TRUE) {
[16:13:39.955]         base::sink(type = "output", split = FALSE)
[16:13:39.955]         if (TRUE) {
[16:13:39.955]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:39.955]         }
[16:13:39.955]         else {
[16:13:39.955]             ...future.result["stdout"] <- base::list(NULL)
[16:13:39.955]         }
[16:13:39.955]         base::close(...future.stdout)
[16:13:39.955]         ...future.stdout <- NULL
[16:13:39.955]     }
[16:13:39.955]     ...future.result$conditions <- ...future.conditions
[16:13:39.955]     ...future.result$finished <- base::Sys.time()
[16:13:39.955]     ...future.result
[16:13:39.955] }
[16:13:39.957] plan(): Setting new future strategy stack:
[16:13:39.957] List of future strategies:
[16:13:39.957] 1. sequential:
[16:13:39.957]    - args: function (..., envir = parent.frame())
[16:13:39.957]    - tweaked: FALSE
[16:13:39.957]    - call: NULL
[16:13:39.958] plan(): nbrOfWorkers() = 1
[16:13:39.958] plan(): Setting new future strategy stack:
[16:13:39.958] List of future strategies:
[16:13:39.958] 1. sequential:
[16:13:39.958]    - args: function (..., envir = parent.frame())
[16:13:39.958]    - tweaked: FALSE
[16:13:39.958]    - call: plan(strategy)
[16:13:39.959] plan(): nbrOfWorkers() = 1
[16:13:39.959] SequentialFuture started (and completed)
[16:13:39.959] - Launch lazy future ... done
[16:13:39.959] run() for ‘SequentialFuture’ ... done
[16:13:39.959] getGlobalsAndPackages() ...
[16:13:39.959] Searching for globals...
[16:13:39.960] 
[16:13:39.960] Searching for globals ... DONE
[16:13:39.960] - globals: [0] <none>
[16:13:39.960] getGlobalsAndPackages() ... DONE
[16:13:39.960] run() for ‘Future’ ...
[16:13:39.960] - state: ‘created’
[16:13:39.960] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:39.961] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:39.961] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:39.961]   - Field: ‘label’
[16:13:39.961]   - Field: ‘local’
[16:13:39.961]   - Field: ‘owner’
[16:13:39.961]   - Field: ‘envir’
[16:13:39.961]   - Field: ‘packages’
[16:13:39.961]   - Field: ‘gc’
[16:13:39.962]   - Field: ‘conditions’
[16:13:39.962]   - Field: ‘expr’
[16:13:39.962]   - Field: ‘uuid’
[16:13:39.962]   - Field: ‘seed’
[16:13:39.962]   - Field: ‘version’
[16:13:39.962]   - Field: ‘result’
[16:13:39.964]   - Field: ‘asynchronous’
[16:13:39.964]   - Field: ‘calls’
[16:13:39.964]   - Field: ‘globals’
[16:13:39.964]   - Field: ‘stdout’
[16:13:39.964]   - Field: ‘earlySignal’
[16:13:39.965]   - Field: ‘lazy’
[16:13:39.965]   - Field: ‘state’
[16:13:39.965] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:39.965] - Launch lazy future ...
[16:13:39.965] Packages needed by the future expression (n = 0): <none>
[16:13:39.965] Packages needed by future strategies (n = 0): <none>
[16:13:39.966] {
[16:13:39.966]     {
[16:13:39.966]         {
[16:13:39.966]             ...future.startTime <- base::Sys.time()
[16:13:39.966]             {
[16:13:39.966]                 {
[16:13:39.966]                   {
[16:13:39.966]                     base::local({
[16:13:39.966]                       has_future <- base::requireNamespace("future", 
[16:13:39.966]                         quietly = TRUE)
[16:13:39.966]                       if (has_future) {
[16:13:39.966]                         ns <- base::getNamespace("future")
[16:13:39.966]                         version <- ns[[".package"]][["version"]]
[16:13:39.966]                         if (is.null(version)) 
[16:13:39.966]                           version <- utils::packageVersion("future")
[16:13:39.966]                       }
[16:13:39.966]                       else {
[16:13:39.966]                         version <- NULL
[16:13:39.966]                       }
[16:13:39.966]                       if (!has_future || version < "1.8.0") {
[16:13:39.966]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:39.966]                           "", base::R.version$version.string), 
[16:13:39.966]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:39.966]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:39.966]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:39.966]                             "release", "version")], collapse = " "), 
[16:13:39.966]                           hostname = base::Sys.info()[["nodename"]])
[16:13:39.966]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:39.966]                           info)
[16:13:39.966]                         info <- base::paste(info, collapse = "; ")
[16:13:39.966]                         if (!has_future) {
[16:13:39.966]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:39.966]                             info)
[16:13:39.966]                         }
[16:13:39.966]                         else {
[16:13:39.966]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:39.966]                             info, version)
[16:13:39.966]                         }
[16:13:39.966]                         base::stop(msg)
[16:13:39.966]                       }
[16:13:39.966]                     })
[16:13:39.966]                   }
[16:13:39.966]                   options(future.plan = NULL)
[16:13:39.966]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.966]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:39.966]                 }
[16:13:39.966]                 ...future.workdir <- getwd()
[16:13:39.966]             }
[16:13:39.966]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:39.966]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:39.966]         }
[16:13:39.966]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:39.966]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:39.966]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:39.966]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:39.966]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:39.966]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:39.966]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:39.966]             base::names(...future.oldOptions))
[16:13:39.966]     }
[16:13:39.966]     if (FALSE) {
[16:13:39.966]     }
[16:13:39.966]     else {
[16:13:39.966]         if (TRUE) {
[16:13:39.966]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:39.966]                 open = "w")
[16:13:39.966]         }
[16:13:39.966]         else {
[16:13:39.966]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:39.966]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:39.966]         }
[16:13:39.966]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:39.966]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:39.966]             base::sink(type = "output", split = FALSE)
[16:13:39.966]             base::close(...future.stdout)
[16:13:39.966]         }, add = TRUE)
[16:13:39.966]     }
[16:13:39.966]     ...future.frame <- base::sys.nframe()
[16:13:39.966]     ...future.conditions <- base::list()
[16:13:39.966]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:39.966]     if (FALSE) {
[16:13:39.966]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:39.966]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:39.966]     }
[16:13:39.966]     ...future.result <- base::tryCatch({
[16:13:39.966]         base::withCallingHandlers({
[16:13:39.966]             ...future.value <- base::withVisible(base::local(2))
[16:13:39.966]             future::FutureResult(value = ...future.value$value, 
[16:13:39.966]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.966]                   ...future.rng), globalenv = if (FALSE) 
[16:13:39.966]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:39.966]                     ...future.globalenv.names))
[16:13:39.966]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:39.966]         }, condition = base::local({
[16:13:39.966]             c <- base::c
[16:13:39.966]             inherits <- base::inherits
[16:13:39.966]             invokeRestart <- base::invokeRestart
[16:13:39.966]             length <- base::length
[16:13:39.966]             list <- base::list
[16:13:39.966]             seq.int <- base::seq.int
[16:13:39.966]             signalCondition <- base::signalCondition
[16:13:39.966]             sys.calls <- base::sys.calls
[16:13:39.966]             `[[` <- base::`[[`
[16:13:39.966]             `+` <- base::`+`
[16:13:39.966]             `<<-` <- base::`<<-`
[16:13:39.966]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:39.966]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:39.966]                   3L)]
[16:13:39.966]             }
[16:13:39.966]             function(cond) {
[16:13:39.966]                 is_error <- inherits(cond, "error")
[16:13:39.966]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:39.966]                   NULL)
[16:13:39.966]                 if (is_error) {
[16:13:39.966]                   sessionInformation <- function() {
[16:13:39.966]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:39.966]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:39.966]                       search = base::search(), system = base::Sys.info())
[16:13:39.966]                   }
[16:13:39.966]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.966]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:39.966]                     cond$call), session = sessionInformation(), 
[16:13:39.966]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:39.966]                   signalCondition(cond)
[16:13:39.966]                 }
[16:13:39.966]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:39.966]                 "immediateCondition"))) {
[16:13:39.966]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:39.966]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.966]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:39.966]                   if (TRUE && !signal) {
[16:13:39.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.966]                     {
[16:13:39.966]                       inherits <- base::inherits
[16:13:39.966]                       invokeRestart <- base::invokeRestart
[16:13:39.966]                       is.null <- base::is.null
[16:13:39.966]                       muffled <- FALSE
[16:13:39.966]                       if (inherits(cond, "message")) {
[16:13:39.966]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.966]                         if (muffled) 
[16:13:39.966]                           invokeRestart("muffleMessage")
[16:13:39.966]                       }
[16:13:39.966]                       else if (inherits(cond, "warning")) {
[16:13:39.966]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.966]                         if (muffled) 
[16:13:39.966]                           invokeRestart("muffleWarning")
[16:13:39.966]                       }
[16:13:39.966]                       else if (inherits(cond, "condition")) {
[16:13:39.966]                         if (!is.null(pattern)) {
[16:13:39.966]                           computeRestarts <- base::computeRestarts
[16:13:39.966]                           grepl <- base::grepl
[16:13:39.966]                           restarts <- computeRestarts(cond)
[16:13:39.966]                           for (restart in restarts) {
[16:13:39.966]                             name <- restart$name
[16:13:39.966]                             if (is.null(name)) 
[16:13:39.966]                               next
[16:13:39.966]                             if (!grepl(pattern, name)) 
[16:13:39.966]                               next
[16:13:39.966]                             invokeRestart(restart)
[16:13:39.966]                             muffled <- TRUE
[16:13:39.966]                             break
[16:13:39.966]                           }
[16:13:39.966]                         }
[16:13:39.966]                       }
[16:13:39.966]                       invisible(muffled)
[16:13:39.966]                     }
[16:13:39.966]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.966]                   }
[16:13:39.966]                 }
[16:13:39.966]                 else {
[16:13:39.966]                   if (TRUE) {
[16:13:39.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.966]                     {
[16:13:39.966]                       inherits <- base::inherits
[16:13:39.966]                       invokeRestart <- base::invokeRestart
[16:13:39.966]                       is.null <- base::is.null
[16:13:39.966]                       muffled <- FALSE
[16:13:39.966]                       if (inherits(cond, "message")) {
[16:13:39.966]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.966]                         if (muffled) 
[16:13:39.966]                           invokeRestart("muffleMessage")
[16:13:39.966]                       }
[16:13:39.966]                       else if (inherits(cond, "warning")) {
[16:13:39.966]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.966]                         if (muffled) 
[16:13:39.966]                           invokeRestart("muffleWarning")
[16:13:39.966]                       }
[16:13:39.966]                       else if (inherits(cond, "condition")) {
[16:13:39.966]                         if (!is.null(pattern)) {
[16:13:39.966]                           computeRestarts <- base::computeRestarts
[16:13:39.966]                           grepl <- base::grepl
[16:13:39.966]                           restarts <- computeRestarts(cond)
[16:13:39.966]                           for (restart in restarts) {
[16:13:39.966]                             name <- restart$name
[16:13:39.966]                             if (is.null(name)) 
[16:13:39.966]                               next
[16:13:39.966]                             if (!grepl(pattern, name)) 
[16:13:39.966]                               next
[16:13:39.966]                             invokeRestart(restart)
[16:13:39.966]                             muffled <- TRUE
[16:13:39.966]                             break
[16:13:39.966]                           }
[16:13:39.966]                         }
[16:13:39.966]                       }
[16:13:39.966]                       invisible(muffled)
[16:13:39.966]                     }
[16:13:39.966]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.966]                   }
[16:13:39.966]                 }
[16:13:39.966]             }
[16:13:39.966]         }))
[16:13:39.966]     }, error = function(ex) {
[16:13:39.966]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:39.966]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.966]                 ...future.rng), started = ...future.startTime, 
[16:13:39.966]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:39.966]             version = "1.8"), class = "FutureResult")
[16:13:39.966]     }, finally = {
[16:13:39.966]         if (!identical(...future.workdir, getwd())) 
[16:13:39.966]             setwd(...future.workdir)
[16:13:39.966]         {
[16:13:39.966]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:39.966]                 ...future.oldOptions$nwarnings <- NULL
[16:13:39.966]             }
[16:13:39.966]             base::options(...future.oldOptions)
[16:13:39.966]             if (.Platform$OS.type == "windows") {
[16:13:39.966]                 old_names <- names(...future.oldEnvVars)
[16:13:39.966]                 envs <- base::Sys.getenv()
[16:13:39.966]                 names <- names(envs)
[16:13:39.966]                 common <- intersect(names, old_names)
[16:13:39.966]                 added <- setdiff(names, old_names)
[16:13:39.966]                 removed <- setdiff(old_names, names)
[16:13:39.966]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:39.966]                   envs[common]]
[16:13:39.966]                 NAMES <- toupper(changed)
[16:13:39.966]                 args <- list()
[16:13:39.966]                 for (kk in seq_along(NAMES)) {
[16:13:39.966]                   name <- changed[[kk]]
[16:13:39.966]                   NAME <- NAMES[[kk]]
[16:13:39.966]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.966]                     next
[16:13:39.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.966]                 }
[16:13:39.966]                 NAMES <- toupper(added)
[16:13:39.966]                 for (kk in seq_along(NAMES)) {
[16:13:39.966]                   name <- added[[kk]]
[16:13:39.966]                   NAME <- NAMES[[kk]]
[16:13:39.966]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.966]                     next
[16:13:39.966]                   args[[name]] <- ""
[16:13:39.966]                 }
[16:13:39.966]                 NAMES <- toupper(removed)
[16:13:39.966]                 for (kk in seq_along(NAMES)) {
[16:13:39.966]                   name <- removed[[kk]]
[16:13:39.966]                   NAME <- NAMES[[kk]]
[16:13:39.966]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.966]                     next
[16:13:39.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.966]                 }
[16:13:39.966]                 if (length(args) > 0) 
[16:13:39.966]                   base::do.call(base::Sys.setenv, args = args)
[16:13:39.966]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:39.966]             }
[16:13:39.966]             else {
[16:13:39.966]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:39.966]             }
[16:13:39.966]             {
[16:13:39.966]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:39.966]                   0L) {
[16:13:39.966]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:39.966]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:39.966]                   base::options(opts)
[16:13:39.966]                 }
[16:13:39.966]                 {
[16:13:39.966]                   {
[16:13:39.966]                     NULL
[16:13:39.966]                     RNGkind("Mersenne-Twister")
[16:13:39.966]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:39.966]                       inherits = FALSE)
[16:13:39.966]                   }
[16:13:39.966]                   options(future.plan = NULL)
[16:13:39.966]                   if (is.na(NA_character_)) 
[16:13:39.966]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.966]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:39.966]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:39.966]                   {
[16:13:39.966]                     future <- SequentialFuture(..., envir = envir)
[16:13:39.966]                     if (!future$lazy) 
[16:13:39.966]                       future <- run(future)
[16:13:39.966]                     invisible(future)
[16:13:39.966]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:39.966]                 }
[16:13:39.966]             }
[16:13:39.966]         }
[16:13:39.966]     })
[16:13:39.966]     if (TRUE) {
[16:13:39.966]         base::sink(type = "output", split = FALSE)
[16:13:39.966]         if (TRUE) {
[16:13:39.966]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:39.966]         }
[16:13:39.966]         else {
[16:13:39.966]             ...future.result["stdout"] <- base::list(NULL)
[16:13:39.966]         }
[16:13:39.966]         base::close(...future.stdout)
[16:13:39.966]         ...future.stdout <- NULL
[16:13:39.966]     }
[16:13:39.966]     ...future.result$conditions <- ...future.conditions
[16:13:39.966]     ...future.result$finished <- base::Sys.time()
[16:13:39.966]     ...future.result
[16:13:39.966] }
[16:13:39.967] plan(): Setting new future strategy stack:
[16:13:39.967] List of future strategies:
[16:13:39.967] 1. sequential:
[16:13:39.967]    - args: function (..., envir = parent.frame())
[16:13:39.967]    - tweaked: FALSE
[16:13:39.967]    - call: NULL
[16:13:39.968] plan(): nbrOfWorkers() = 1
[16:13:39.969] plan(): Setting new future strategy stack:
[16:13:39.969] List of future strategies:
[16:13:39.969] 1. sequential:
[16:13:39.969]    - args: function (..., envir = parent.frame())
[16:13:39.969]    - tweaked: FALSE
[16:13:39.969]    - call: plan(strategy)
[16:13:39.969] plan(): nbrOfWorkers() = 1
[16:13:39.969] SequentialFuture started (and completed)
[16:13:39.969] - Launch lazy future ... done
[16:13:39.969] run() for ‘SequentialFuture’ ... done
[16:13:39.970] resolve() on list environment ...
[16:13:39.970]  recursive: 0
[16:13:39.971]  length: 3
[16:13:39.971]  elements: ‘a’, ‘b’, ‘c’
[16:13:39.971] resolved() for ‘SequentialFuture’ ...
[16:13:39.971] - state: ‘finished’
[16:13:39.971] - run: TRUE
[16:13:39.971] - result: ‘FutureResult’
[16:13:39.971] resolved() for ‘SequentialFuture’ ... done
[16:13:39.971] Future #1
[16:13:39.972]  length: 2 (resolved future 1)
[16:13:39.972] resolved() for ‘SequentialFuture’ ...
[16:13:39.972] - state: ‘finished’
[16:13:39.972] - run: TRUE
[16:13:39.972] - result: ‘FutureResult’
[16:13:39.972] resolved() for ‘SequentialFuture’ ... done
[16:13:39.972] Future #2
[16:13:39.972]  length: 1 (resolved future 2)
[16:13:39.972]  length: 0 (resolved future 3)
[16:13:39.972] resolve() on list environment ... DONE
[16:13:39.973] getGlobalsAndPackages() ...
[16:13:39.973] Searching for globals...
[16:13:39.974] - globals found: [1] ‘{’
[16:13:39.974] Searching for globals ... DONE
[16:13:39.974] Resolving globals: FALSE
[16:13:39.974] 
[16:13:39.975] 
[16:13:39.975] getGlobalsAndPackages() ... DONE
[16:13:39.975] run() for ‘Future’ ...
[16:13:39.975] - state: ‘created’
[16:13:39.975] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:39.975] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:39.975] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:39.976]   - Field: ‘label’
[16:13:39.976]   - Field: ‘local’
[16:13:39.976]   - Field: ‘owner’
[16:13:39.976]   - Field: ‘envir’
[16:13:39.976]   - Field: ‘packages’
[16:13:39.976]   - Field: ‘gc’
[16:13:39.976]   - Field: ‘conditions’
[16:13:39.976]   - Field: ‘expr’
[16:13:39.976]   - Field: ‘uuid’
[16:13:39.976]   - Field: ‘seed’
[16:13:39.977]   - Field: ‘version’
[16:13:39.977]   - Field: ‘result’
[16:13:39.977]   - Field: ‘asynchronous’
[16:13:39.977]   - Field: ‘calls’
[16:13:39.977]   - Field: ‘globals’
[16:13:39.977]   - Field: ‘stdout’
[16:13:39.977]   - Field: ‘earlySignal’
[16:13:39.977]   - Field: ‘lazy’
[16:13:39.977]   - Field: ‘state’
[16:13:39.977] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:39.977] - Launch lazy future ...
[16:13:39.978] Packages needed by the future expression (n = 0): <none>
[16:13:39.978] Packages needed by future strategies (n = 0): <none>
[16:13:39.978] {
[16:13:39.978]     {
[16:13:39.978]         {
[16:13:39.978]             ...future.startTime <- base::Sys.time()
[16:13:39.978]             {
[16:13:39.978]                 {
[16:13:39.978]                   {
[16:13:39.978]                     base::local({
[16:13:39.978]                       has_future <- base::requireNamespace("future", 
[16:13:39.978]                         quietly = TRUE)
[16:13:39.978]                       if (has_future) {
[16:13:39.978]                         ns <- base::getNamespace("future")
[16:13:39.978]                         version <- ns[[".package"]][["version"]]
[16:13:39.978]                         if (is.null(version)) 
[16:13:39.978]                           version <- utils::packageVersion("future")
[16:13:39.978]                       }
[16:13:39.978]                       else {
[16:13:39.978]                         version <- NULL
[16:13:39.978]                       }
[16:13:39.978]                       if (!has_future || version < "1.8.0") {
[16:13:39.978]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:39.978]                           "", base::R.version$version.string), 
[16:13:39.978]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:39.978]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:39.978]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:39.978]                             "release", "version")], collapse = " "), 
[16:13:39.978]                           hostname = base::Sys.info()[["nodename"]])
[16:13:39.978]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:39.978]                           info)
[16:13:39.978]                         info <- base::paste(info, collapse = "; ")
[16:13:39.978]                         if (!has_future) {
[16:13:39.978]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:39.978]                             info)
[16:13:39.978]                         }
[16:13:39.978]                         else {
[16:13:39.978]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:39.978]                             info, version)
[16:13:39.978]                         }
[16:13:39.978]                         base::stop(msg)
[16:13:39.978]                       }
[16:13:39.978]                     })
[16:13:39.978]                   }
[16:13:39.978]                   options(future.plan = NULL)
[16:13:39.978]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.978]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:39.978]                 }
[16:13:39.978]                 ...future.workdir <- getwd()
[16:13:39.978]             }
[16:13:39.978]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:39.978]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:39.978]         }
[16:13:39.978]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:39.978]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:39.978]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:39.978]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:39.978]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:39.978]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:39.978]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:39.978]             base::names(...future.oldOptions))
[16:13:39.978]     }
[16:13:39.978]     if (FALSE) {
[16:13:39.978]     }
[16:13:39.978]     else {
[16:13:39.978]         if (TRUE) {
[16:13:39.978]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:39.978]                 open = "w")
[16:13:39.978]         }
[16:13:39.978]         else {
[16:13:39.978]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:39.978]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:39.978]         }
[16:13:39.978]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:39.978]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:39.978]             base::sink(type = "output", split = FALSE)
[16:13:39.978]             base::close(...future.stdout)
[16:13:39.978]         }, add = TRUE)
[16:13:39.978]     }
[16:13:39.978]     ...future.frame <- base::sys.nframe()
[16:13:39.978]     ...future.conditions <- base::list()
[16:13:39.978]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:39.978]     if (FALSE) {
[16:13:39.978]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:39.978]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:39.978]     }
[16:13:39.978]     ...future.result <- base::tryCatch({
[16:13:39.978]         base::withCallingHandlers({
[16:13:39.978]             ...future.value <- base::withVisible(base::local({
[16:13:39.978]                 1
[16:13:39.978]             }))
[16:13:39.978]             future::FutureResult(value = ...future.value$value, 
[16:13:39.978]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.978]                   ...future.rng), globalenv = if (FALSE) 
[16:13:39.978]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:39.978]                     ...future.globalenv.names))
[16:13:39.978]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:39.978]         }, condition = base::local({
[16:13:39.978]             c <- base::c
[16:13:39.978]             inherits <- base::inherits
[16:13:39.978]             invokeRestart <- base::invokeRestart
[16:13:39.978]             length <- base::length
[16:13:39.978]             list <- base::list
[16:13:39.978]             seq.int <- base::seq.int
[16:13:39.978]             signalCondition <- base::signalCondition
[16:13:39.978]             sys.calls <- base::sys.calls
[16:13:39.978]             `[[` <- base::`[[`
[16:13:39.978]             `+` <- base::`+`
[16:13:39.978]             `<<-` <- base::`<<-`
[16:13:39.978]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:39.978]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:39.978]                   3L)]
[16:13:39.978]             }
[16:13:39.978]             function(cond) {
[16:13:39.978]                 is_error <- inherits(cond, "error")
[16:13:39.978]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:39.978]                   NULL)
[16:13:39.978]                 if (is_error) {
[16:13:39.978]                   sessionInformation <- function() {
[16:13:39.978]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:39.978]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:39.978]                       search = base::search(), system = base::Sys.info())
[16:13:39.978]                   }
[16:13:39.978]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.978]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:39.978]                     cond$call), session = sessionInformation(), 
[16:13:39.978]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:39.978]                   signalCondition(cond)
[16:13:39.978]                 }
[16:13:39.978]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:39.978]                 "immediateCondition"))) {
[16:13:39.978]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:39.978]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.978]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:39.978]                   if (TRUE && !signal) {
[16:13:39.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.978]                     {
[16:13:39.978]                       inherits <- base::inherits
[16:13:39.978]                       invokeRestart <- base::invokeRestart
[16:13:39.978]                       is.null <- base::is.null
[16:13:39.978]                       muffled <- FALSE
[16:13:39.978]                       if (inherits(cond, "message")) {
[16:13:39.978]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.978]                         if (muffled) 
[16:13:39.978]                           invokeRestart("muffleMessage")
[16:13:39.978]                       }
[16:13:39.978]                       else if (inherits(cond, "warning")) {
[16:13:39.978]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.978]                         if (muffled) 
[16:13:39.978]                           invokeRestart("muffleWarning")
[16:13:39.978]                       }
[16:13:39.978]                       else if (inherits(cond, "condition")) {
[16:13:39.978]                         if (!is.null(pattern)) {
[16:13:39.978]                           computeRestarts <- base::computeRestarts
[16:13:39.978]                           grepl <- base::grepl
[16:13:39.978]                           restarts <- computeRestarts(cond)
[16:13:39.978]                           for (restart in restarts) {
[16:13:39.978]                             name <- restart$name
[16:13:39.978]                             if (is.null(name)) 
[16:13:39.978]                               next
[16:13:39.978]                             if (!grepl(pattern, name)) 
[16:13:39.978]                               next
[16:13:39.978]                             invokeRestart(restart)
[16:13:39.978]                             muffled <- TRUE
[16:13:39.978]                             break
[16:13:39.978]                           }
[16:13:39.978]                         }
[16:13:39.978]                       }
[16:13:39.978]                       invisible(muffled)
[16:13:39.978]                     }
[16:13:39.978]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.978]                   }
[16:13:39.978]                 }
[16:13:39.978]                 else {
[16:13:39.978]                   if (TRUE) {
[16:13:39.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.978]                     {
[16:13:39.978]                       inherits <- base::inherits
[16:13:39.978]                       invokeRestart <- base::invokeRestart
[16:13:39.978]                       is.null <- base::is.null
[16:13:39.978]                       muffled <- FALSE
[16:13:39.978]                       if (inherits(cond, "message")) {
[16:13:39.978]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.978]                         if (muffled) 
[16:13:39.978]                           invokeRestart("muffleMessage")
[16:13:39.978]                       }
[16:13:39.978]                       else if (inherits(cond, "warning")) {
[16:13:39.978]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.978]                         if (muffled) 
[16:13:39.978]                           invokeRestart("muffleWarning")
[16:13:39.978]                       }
[16:13:39.978]                       else if (inherits(cond, "condition")) {
[16:13:39.978]                         if (!is.null(pattern)) {
[16:13:39.978]                           computeRestarts <- base::computeRestarts
[16:13:39.978]                           grepl <- base::grepl
[16:13:39.978]                           restarts <- computeRestarts(cond)
[16:13:39.978]                           for (restart in restarts) {
[16:13:39.978]                             name <- restart$name
[16:13:39.978]                             if (is.null(name)) 
[16:13:39.978]                               next
[16:13:39.978]                             if (!grepl(pattern, name)) 
[16:13:39.978]                               next
[16:13:39.978]                             invokeRestart(restart)
[16:13:39.978]                             muffled <- TRUE
[16:13:39.978]                             break
[16:13:39.978]                           }
[16:13:39.978]                         }
[16:13:39.978]                       }
[16:13:39.978]                       invisible(muffled)
[16:13:39.978]                     }
[16:13:39.978]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.978]                   }
[16:13:39.978]                 }
[16:13:39.978]             }
[16:13:39.978]         }))
[16:13:39.978]     }, error = function(ex) {
[16:13:39.978]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:39.978]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.978]                 ...future.rng), started = ...future.startTime, 
[16:13:39.978]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:39.978]             version = "1.8"), class = "FutureResult")
[16:13:39.978]     }, finally = {
[16:13:39.978]         if (!identical(...future.workdir, getwd())) 
[16:13:39.978]             setwd(...future.workdir)
[16:13:39.978]         {
[16:13:39.978]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:39.978]                 ...future.oldOptions$nwarnings <- NULL
[16:13:39.978]             }
[16:13:39.978]             base::options(...future.oldOptions)
[16:13:39.978]             if (.Platform$OS.type == "windows") {
[16:13:39.978]                 old_names <- names(...future.oldEnvVars)
[16:13:39.978]                 envs <- base::Sys.getenv()
[16:13:39.978]                 names <- names(envs)
[16:13:39.978]                 common <- intersect(names, old_names)
[16:13:39.978]                 added <- setdiff(names, old_names)
[16:13:39.978]                 removed <- setdiff(old_names, names)
[16:13:39.978]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:39.978]                   envs[common]]
[16:13:39.978]                 NAMES <- toupper(changed)
[16:13:39.978]                 args <- list()
[16:13:39.978]                 for (kk in seq_along(NAMES)) {
[16:13:39.978]                   name <- changed[[kk]]
[16:13:39.978]                   NAME <- NAMES[[kk]]
[16:13:39.978]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.978]                     next
[16:13:39.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.978]                 }
[16:13:39.978]                 NAMES <- toupper(added)
[16:13:39.978]                 for (kk in seq_along(NAMES)) {
[16:13:39.978]                   name <- added[[kk]]
[16:13:39.978]                   NAME <- NAMES[[kk]]
[16:13:39.978]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.978]                     next
[16:13:39.978]                   args[[name]] <- ""
[16:13:39.978]                 }
[16:13:39.978]                 NAMES <- toupper(removed)
[16:13:39.978]                 for (kk in seq_along(NAMES)) {
[16:13:39.978]                   name <- removed[[kk]]
[16:13:39.978]                   NAME <- NAMES[[kk]]
[16:13:39.978]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.978]                     next
[16:13:39.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.978]                 }
[16:13:39.978]                 if (length(args) > 0) 
[16:13:39.978]                   base::do.call(base::Sys.setenv, args = args)
[16:13:39.978]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:39.978]             }
[16:13:39.978]             else {
[16:13:39.978]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:39.978]             }
[16:13:39.978]             {
[16:13:39.978]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:39.978]                   0L) {
[16:13:39.978]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:39.978]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:39.978]                   base::options(opts)
[16:13:39.978]                 }
[16:13:39.978]                 {
[16:13:39.978]                   {
[16:13:39.978]                     NULL
[16:13:39.978]                     RNGkind("Mersenne-Twister")
[16:13:39.978]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:39.978]                       inherits = FALSE)
[16:13:39.978]                   }
[16:13:39.978]                   options(future.plan = NULL)
[16:13:39.978]                   if (is.na(NA_character_)) 
[16:13:39.978]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.978]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:39.978]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:39.978]                   {
[16:13:39.978]                     future <- SequentialFuture(..., envir = envir)
[16:13:39.978]                     if (!future$lazy) 
[16:13:39.978]                       future <- run(future)
[16:13:39.978]                     invisible(future)
[16:13:39.978]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:39.978]                 }
[16:13:39.978]             }
[16:13:39.978]         }
[16:13:39.978]     })
[16:13:39.978]     if (TRUE) {
[16:13:39.978]         base::sink(type = "output", split = FALSE)
[16:13:39.978]         if (TRUE) {
[16:13:39.978]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:39.978]         }
[16:13:39.978]         else {
[16:13:39.978]             ...future.result["stdout"] <- base::list(NULL)
[16:13:39.978]         }
[16:13:39.978]         base::close(...future.stdout)
[16:13:39.978]         ...future.stdout <- NULL
[16:13:39.978]     }
[16:13:39.978]     ...future.result$conditions <- ...future.conditions
[16:13:39.978]     ...future.result$finished <- base::Sys.time()
[16:13:39.978]     ...future.result
[16:13:39.978] }
[16:13:39.980] plan(): Setting new future strategy stack:
[16:13:39.980] List of future strategies:
[16:13:39.980] 1. sequential:
[16:13:39.980]    - args: function (..., envir = parent.frame())
[16:13:39.980]    - tweaked: FALSE
[16:13:39.980]    - call: NULL
[16:13:39.980] plan(): nbrOfWorkers() = 1
[16:13:39.981] plan(): Setting new future strategy stack:
[16:13:39.981] List of future strategies:
[16:13:39.981] 1. sequential:
[16:13:39.981]    - args: function (..., envir = parent.frame())
[16:13:39.981]    - tweaked: FALSE
[16:13:39.981]    - call: plan(strategy)
[16:13:39.982] plan(): nbrOfWorkers() = 1
[16:13:39.982] SequentialFuture started (and completed)
[16:13:39.982] - Launch lazy future ... done
[16:13:39.982] run() for ‘SequentialFuture’ ... done
[16:13:39.982] getGlobalsAndPackages() ...
[16:13:39.982] Searching for globals...
[16:13:39.983] - globals found: [1] ‘{’
[16:13:39.983] Searching for globals ... DONE
[16:13:39.983] Resolving globals: FALSE
[16:13:39.983] 
[16:13:39.983] 
[16:13:39.984] getGlobalsAndPackages() ... DONE
[16:13:39.984] run() for ‘Future’ ...
[16:13:39.984] - state: ‘created’
[16:13:39.984] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:39.984] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:39.984] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:39.985]   - Field: ‘label’
[16:13:39.985]   - Field: ‘local’
[16:13:39.985]   - Field: ‘owner’
[16:13:39.985]   - Field: ‘envir’
[16:13:39.985]   - Field: ‘packages’
[16:13:39.985]   - Field: ‘gc’
[16:13:39.985]   - Field: ‘conditions’
[16:13:39.985]   - Field: ‘expr’
[16:13:39.985]   - Field: ‘uuid’
[16:13:39.985]   - Field: ‘seed’
[16:13:39.986]   - Field: ‘version’
[16:13:39.986]   - Field: ‘result’
[16:13:39.986]   - Field: ‘asynchronous’
[16:13:39.986]   - Field: ‘calls’
[16:13:39.986]   - Field: ‘globals’
[16:13:39.986]   - Field: ‘stdout’
[16:13:39.986]   - Field: ‘earlySignal’
[16:13:39.986]   - Field: ‘lazy’
[16:13:39.986]   - Field: ‘state’
[16:13:39.986] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:39.987] - Launch lazy future ...
[16:13:39.987] Packages needed by the future expression (n = 0): <none>
[16:13:39.987] Packages needed by future strategies (n = 0): <none>
[16:13:39.987] {
[16:13:39.987]     {
[16:13:39.987]         {
[16:13:39.987]             ...future.startTime <- base::Sys.time()
[16:13:39.987]             {
[16:13:39.987]                 {
[16:13:39.987]                   {
[16:13:39.987]                     base::local({
[16:13:39.987]                       has_future <- base::requireNamespace("future", 
[16:13:39.987]                         quietly = TRUE)
[16:13:39.987]                       if (has_future) {
[16:13:39.987]                         ns <- base::getNamespace("future")
[16:13:39.987]                         version <- ns[[".package"]][["version"]]
[16:13:39.987]                         if (is.null(version)) 
[16:13:39.987]                           version <- utils::packageVersion("future")
[16:13:39.987]                       }
[16:13:39.987]                       else {
[16:13:39.987]                         version <- NULL
[16:13:39.987]                       }
[16:13:39.987]                       if (!has_future || version < "1.8.0") {
[16:13:39.987]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:39.987]                           "", base::R.version$version.string), 
[16:13:39.987]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:39.987]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:39.987]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:39.987]                             "release", "version")], collapse = " "), 
[16:13:39.987]                           hostname = base::Sys.info()[["nodename"]])
[16:13:39.987]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:39.987]                           info)
[16:13:39.987]                         info <- base::paste(info, collapse = "; ")
[16:13:39.987]                         if (!has_future) {
[16:13:39.987]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:39.987]                             info)
[16:13:39.987]                         }
[16:13:39.987]                         else {
[16:13:39.987]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:39.987]                             info, version)
[16:13:39.987]                         }
[16:13:39.987]                         base::stop(msg)
[16:13:39.987]                       }
[16:13:39.987]                     })
[16:13:39.987]                   }
[16:13:39.987]                   options(future.plan = NULL)
[16:13:39.987]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.987]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:39.987]                 }
[16:13:39.987]                 ...future.workdir <- getwd()
[16:13:39.987]             }
[16:13:39.987]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:39.987]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:39.987]         }
[16:13:39.987]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:39.987]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:39.987]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:39.987]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:39.987]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:39.987]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:39.987]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:39.987]             base::names(...future.oldOptions))
[16:13:39.987]     }
[16:13:39.987]     if (FALSE) {
[16:13:39.987]     }
[16:13:39.987]     else {
[16:13:39.987]         if (TRUE) {
[16:13:39.987]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:39.987]                 open = "w")
[16:13:39.987]         }
[16:13:39.987]         else {
[16:13:39.987]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:39.987]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:39.987]         }
[16:13:39.987]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:39.987]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:39.987]             base::sink(type = "output", split = FALSE)
[16:13:39.987]             base::close(...future.stdout)
[16:13:39.987]         }, add = TRUE)
[16:13:39.987]     }
[16:13:39.987]     ...future.frame <- base::sys.nframe()
[16:13:39.987]     ...future.conditions <- base::list()
[16:13:39.987]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:39.987]     if (FALSE) {
[16:13:39.987]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:39.987]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:39.987]     }
[16:13:39.987]     ...future.result <- base::tryCatch({
[16:13:39.987]         base::withCallingHandlers({
[16:13:39.987]             ...future.value <- base::withVisible(base::local({
[16:13:39.987]                 2
[16:13:39.987]             }))
[16:13:39.987]             future::FutureResult(value = ...future.value$value, 
[16:13:39.987]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.987]                   ...future.rng), globalenv = if (FALSE) 
[16:13:39.987]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:39.987]                     ...future.globalenv.names))
[16:13:39.987]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:39.987]         }, condition = base::local({
[16:13:39.987]             c <- base::c
[16:13:39.987]             inherits <- base::inherits
[16:13:39.987]             invokeRestart <- base::invokeRestart
[16:13:39.987]             length <- base::length
[16:13:39.987]             list <- base::list
[16:13:39.987]             seq.int <- base::seq.int
[16:13:39.987]             signalCondition <- base::signalCondition
[16:13:39.987]             sys.calls <- base::sys.calls
[16:13:39.987]             `[[` <- base::`[[`
[16:13:39.987]             `+` <- base::`+`
[16:13:39.987]             `<<-` <- base::`<<-`
[16:13:39.987]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:39.987]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:39.987]                   3L)]
[16:13:39.987]             }
[16:13:39.987]             function(cond) {
[16:13:39.987]                 is_error <- inherits(cond, "error")
[16:13:39.987]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:39.987]                   NULL)
[16:13:39.987]                 if (is_error) {
[16:13:39.987]                   sessionInformation <- function() {
[16:13:39.987]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:39.987]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:39.987]                       search = base::search(), system = base::Sys.info())
[16:13:39.987]                   }
[16:13:39.987]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.987]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:39.987]                     cond$call), session = sessionInformation(), 
[16:13:39.987]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:39.987]                   signalCondition(cond)
[16:13:39.987]                 }
[16:13:39.987]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:39.987]                 "immediateCondition"))) {
[16:13:39.987]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:39.987]                   ...future.conditions[[length(...future.conditions) + 
[16:13:39.987]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:39.987]                   if (TRUE && !signal) {
[16:13:39.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.987]                     {
[16:13:39.987]                       inherits <- base::inherits
[16:13:39.987]                       invokeRestart <- base::invokeRestart
[16:13:39.987]                       is.null <- base::is.null
[16:13:39.987]                       muffled <- FALSE
[16:13:39.987]                       if (inherits(cond, "message")) {
[16:13:39.987]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.987]                         if (muffled) 
[16:13:39.987]                           invokeRestart("muffleMessage")
[16:13:39.987]                       }
[16:13:39.987]                       else if (inherits(cond, "warning")) {
[16:13:39.987]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.987]                         if (muffled) 
[16:13:39.987]                           invokeRestart("muffleWarning")
[16:13:39.987]                       }
[16:13:39.987]                       else if (inherits(cond, "condition")) {
[16:13:39.987]                         if (!is.null(pattern)) {
[16:13:39.987]                           computeRestarts <- base::computeRestarts
[16:13:39.987]                           grepl <- base::grepl
[16:13:39.987]                           restarts <- computeRestarts(cond)
[16:13:39.987]                           for (restart in restarts) {
[16:13:39.987]                             name <- restart$name
[16:13:39.987]                             if (is.null(name)) 
[16:13:39.987]                               next
[16:13:39.987]                             if (!grepl(pattern, name)) 
[16:13:39.987]                               next
[16:13:39.987]                             invokeRestart(restart)
[16:13:39.987]                             muffled <- TRUE
[16:13:39.987]                             break
[16:13:39.987]                           }
[16:13:39.987]                         }
[16:13:39.987]                       }
[16:13:39.987]                       invisible(muffled)
[16:13:39.987]                     }
[16:13:39.987]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.987]                   }
[16:13:39.987]                 }
[16:13:39.987]                 else {
[16:13:39.987]                   if (TRUE) {
[16:13:39.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:39.987]                     {
[16:13:39.987]                       inherits <- base::inherits
[16:13:39.987]                       invokeRestart <- base::invokeRestart
[16:13:39.987]                       is.null <- base::is.null
[16:13:39.987]                       muffled <- FALSE
[16:13:39.987]                       if (inherits(cond, "message")) {
[16:13:39.987]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:39.987]                         if (muffled) 
[16:13:39.987]                           invokeRestart("muffleMessage")
[16:13:39.987]                       }
[16:13:39.987]                       else if (inherits(cond, "warning")) {
[16:13:39.987]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:39.987]                         if (muffled) 
[16:13:39.987]                           invokeRestart("muffleWarning")
[16:13:39.987]                       }
[16:13:39.987]                       else if (inherits(cond, "condition")) {
[16:13:39.987]                         if (!is.null(pattern)) {
[16:13:39.987]                           computeRestarts <- base::computeRestarts
[16:13:39.987]                           grepl <- base::grepl
[16:13:39.987]                           restarts <- computeRestarts(cond)
[16:13:39.987]                           for (restart in restarts) {
[16:13:39.987]                             name <- restart$name
[16:13:39.987]                             if (is.null(name)) 
[16:13:39.987]                               next
[16:13:39.987]                             if (!grepl(pattern, name)) 
[16:13:39.987]                               next
[16:13:39.987]                             invokeRestart(restart)
[16:13:39.987]                             muffled <- TRUE
[16:13:39.987]                             break
[16:13:39.987]                           }
[16:13:39.987]                         }
[16:13:39.987]                       }
[16:13:39.987]                       invisible(muffled)
[16:13:39.987]                     }
[16:13:39.987]                     muffleCondition(cond, pattern = "^muffle")
[16:13:39.987]                   }
[16:13:39.987]                 }
[16:13:39.987]             }
[16:13:39.987]         }))
[16:13:39.987]     }, error = function(ex) {
[16:13:39.987]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:39.987]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:39.987]                 ...future.rng), started = ...future.startTime, 
[16:13:39.987]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:39.987]             version = "1.8"), class = "FutureResult")
[16:13:39.987]     }, finally = {
[16:13:39.987]         if (!identical(...future.workdir, getwd())) 
[16:13:39.987]             setwd(...future.workdir)
[16:13:39.987]         {
[16:13:39.987]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:39.987]                 ...future.oldOptions$nwarnings <- NULL
[16:13:39.987]             }
[16:13:39.987]             base::options(...future.oldOptions)
[16:13:39.987]             if (.Platform$OS.type == "windows") {
[16:13:39.987]                 old_names <- names(...future.oldEnvVars)
[16:13:39.987]                 envs <- base::Sys.getenv()
[16:13:39.987]                 names <- names(envs)
[16:13:39.987]                 common <- intersect(names, old_names)
[16:13:39.987]                 added <- setdiff(names, old_names)
[16:13:39.987]                 removed <- setdiff(old_names, names)
[16:13:39.987]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:39.987]                   envs[common]]
[16:13:39.987]                 NAMES <- toupper(changed)
[16:13:39.987]                 args <- list()
[16:13:39.987]                 for (kk in seq_along(NAMES)) {
[16:13:39.987]                   name <- changed[[kk]]
[16:13:39.987]                   NAME <- NAMES[[kk]]
[16:13:39.987]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.987]                     next
[16:13:39.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.987]                 }
[16:13:39.987]                 NAMES <- toupper(added)
[16:13:39.987]                 for (kk in seq_along(NAMES)) {
[16:13:39.987]                   name <- added[[kk]]
[16:13:39.987]                   NAME <- NAMES[[kk]]
[16:13:39.987]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.987]                     next
[16:13:39.987]                   args[[name]] <- ""
[16:13:39.987]                 }
[16:13:39.987]                 NAMES <- toupper(removed)
[16:13:39.987]                 for (kk in seq_along(NAMES)) {
[16:13:39.987]                   name <- removed[[kk]]
[16:13:39.987]                   NAME <- NAMES[[kk]]
[16:13:39.987]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:39.987]                     next
[16:13:39.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:39.987]                 }
[16:13:39.987]                 if (length(args) > 0) 
[16:13:39.987]                   base::do.call(base::Sys.setenv, args = args)
[16:13:39.987]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:39.987]             }
[16:13:39.987]             else {
[16:13:39.987]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:39.987]             }
[16:13:39.987]             {
[16:13:39.987]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:39.987]                   0L) {
[16:13:39.987]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:39.987]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:39.987]                   base::options(opts)
[16:13:39.987]                 }
[16:13:39.987]                 {
[16:13:39.987]                   {
[16:13:39.987]                     NULL
[16:13:39.987]                     RNGkind("Mersenne-Twister")
[16:13:39.987]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:39.987]                       inherits = FALSE)
[16:13:39.987]                   }
[16:13:39.987]                   options(future.plan = NULL)
[16:13:39.987]                   if (is.na(NA_character_)) 
[16:13:39.987]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:39.987]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:39.987]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:39.987]                   {
[16:13:39.987]                     future <- SequentialFuture(..., envir = envir)
[16:13:39.987]                     if (!future$lazy) 
[16:13:39.987]                       future <- run(future)
[16:13:39.987]                     invisible(future)
[16:13:39.987]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:39.987]                 }
[16:13:39.987]             }
[16:13:39.987]         }
[16:13:39.987]     })
[16:13:39.987]     if (TRUE) {
[16:13:39.987]         base::sink(type = "output", split = FALSE)
[16:13:39.987]         if (TRUE) {
[16:13:39.987]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:39.987]         }
[16:13:39.987]         else {
[16:13:39.987]             ...future.result["stdout"] <- base::list(NULL)
[16:13:39.987]         }
[16:13:39.987]         base::close(...future.stdout)
[16:13:39.987]         ...future.stdout <- NULL
[16:13:39.987]     }
[16:13:39.987]     ...future.result$conditions <- ...future.conditions
[16:13:39.987]     ...future.result$finished <- base::Sys.time()
[16:13:39.987]     ...future.result
[16:13:39.987] }
[16:13:39.989] plan(): Setting new future strategy stack:
[16:13:39.989] List of future strategies:
[16:13:39.989] 1. sequential:
[16:13:39.989]    - args: function (..., envir = parent.frame())
[16:13:39.989]    - tweaked: FALSE
[16:13:39.989]    - call: NULL
[16:13:39.990] plan(): nbrOfWorkers() = 1
[16:13:39.990] plan(): Setting new future strategy stack:
[16:13:39.990] List of future strategies:
[16:13:39.990] 1. sequential:
[16:13:39.990]    - args: function (..., envir = parent.frame())
[16:13:39.990]    - tweaked: FALSE
[16:13:39.990]    - call: plan(strategy)
[16:13:39.991] plan(): nbrOfWorkers() = 1
[16:13:39.993] SequentialFuture started (and completed)
[16:13:39.993] - Launch lazy future ... done
[16:13:39.993] run() for ‘SequentialFuture’ ... done
[16:13:39.994] resolve() on list environment ...
[16:13:39.994]  recursive: 0
[16:13:39.994]  length: 3
[16:13:39.995]  elements: ‘a’, ‘b’, ‘c’
[16:13:39.995] resolved() for ‘SequentialFuture’ ...
[16:13:39.995] - state: ‘finished’
[16:13:39.995] - run: TRUE
[16:13:39.995] - result: ‘FutureResult’
[16:13:39.995] resolved() for ‘SequentialFuture’ ... done
[16:13:39.995] Future #1
[16:13:39.995]  length: 2 (resolved future 1)
[16:13:39.995] resolved() for ‘SequentialFuture’ ...
[16:13:39.995] - state: ‘finished’
[16:13:39.996] - run: TRUE
[16:13:39.996] - result: ‘FutureResult’
[16:13:39.996] resolved() for ‘SequentialFuture’ ... done
[16:13:39.996] Future #2
[16:13:39.996]  length: 1 (resolved future 2)
[16:13:39.996]  length: 0 (resolved future 3)
[16:13:39.996] resolve() on list environment ... DONE
[16:13:39.997] getGlobalsAndPackages() ...
[16:13:39.997] Searching for globals...
[16:13:39.997] - globals found: [1] ‘{’
[16:13:39.997] Searching for globals ... DONE
[16:13:39.998] Resolving globals: FALSE
[16:13:39.998] 
[16:13:39.998] 
[16:13:39.998] getGlobalsAndPackages() ... DONE
[16:13:39.998] run() for ‘Future’ ...
[16:13:39.998] - state: ‘created’
[16:13:39.998] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:39.999] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:39.999] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:39.999]   - Field: ‘label’
[16:13:39.999]   - Field: ‘local’
[16:13:39.999]   - Field: ‘owner’
[16:13:39.999]   - Field: ‘envir’
[16:13:39.999]   - Field: ‘packages’
[16:13:39.999]   - Field: ‘gc’
[16:13:39.999]   - Field: ‘conditions’
[16:13:40.000]   - Field: ‘expr’
[16:13:40.000]   - Field: ‘uuid’
[16:13:40.000]   - Field: ‘seed’
[16:13:40.000]   - Field: ‘version’
[16:13:40.000]   - Field: ‘result’
[16:13:40.000]   - Field: ‘asynchronous’
[16:13:40.000]   - Field: ‘calls’
[16:13:40.000]   - Field: ‘globals’
[16:13:40.000]   - Field: ‘stdout’
[16:13:40.000]   - Field: ‘earlySignal’
[16:13:40.001]   - Field: ‘lazy’
[16:13:40.001]   - Field: ‘state’
[16:13:40.001] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:40.001] - Launch lazy future ...
[16:13:40.001] Packages needed by the future expression (n = 0): <none>
[16:13:40.001] Packages needed by future strategies (n = 0): <none>
[16:13:40.002] {
[16:13:40.002]     {
[16:13:40.002]         {
[16:13:40.002]             ...future.startTime <- base::Sys.time()
[16:13:40.002]             {
[16:13:40.002]                 {
[16:13:40.002]                   {
[16:13:40.002]                     base::local({
[16:13:40.002]                       has_future <- base::requireNamespace("future", 
[16:13:40.002]                         quietly = TRUE)
[16:13:40.002]                       if (has_future) {
[16:13:40.002]                         ns <- base::getNamespace("future")
[16:13:40.002]                         version <- ns[[".package"]][["version"]]
[16:13:40.002]                         if (is.null(version)) 
[16:13:40.002]                           version <- utils::packageVersion("future")
[16:13:40.002]                       }
[16:13:40.002]                       else {
[16:13:40.002]                         version <- NULL
[16:13:40.002]                       }
[16:13:40.002]                       if (!has_future || version < "1.8.0") {
[16:13:40.002]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:40.002]                           "", base::R.version$version.string), 
[16:13:40.002]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:40.002]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:40.002]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:40.002]                             "release", "version")], collapse = " "), 
[16:13:40.002]                           hostname = base::Sys.info()[["nodename"]])
[16:13:40.002]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:40.002]                           info)
[16:13:40.002]                         info <- base::paste(info, collapse = "; ")
[16:13:40.002]                         if (!has_future) {
[16:13:40.002]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:40.002]                             info)
[16:13:40.002]                         }
[16:13:40.002]                         else {
[16:13:40.002]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:40.002]                             info, version)
[16:13:40.002]                         }
[16:13:40.002]                         base::stop(msg)
[16:13:40.002]                       }
[16:13:40.002]                     })
[16:13:40.002]                   }
[16:13:40.002]                   options(future.plan = NULL)
[16:13:40.002]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:40.002]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:40.002]                 }
[16:13:40.002]                 ...future.workdir <- getwd()
[16:13:40.002]             }
[16:13:40.002]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:40.002]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:40.002]         }
[16:13:40.002]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:40.002]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:40.002]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:40.002]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:40.002]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:40.002]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:40.002]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:40.002]             base::names(...future.oldOptions))
[16:13:40.002]     }
[16:13:40.002]     if (FALSE) {
[16:13:40.002]     }
[16:13:40.002]     else {
[16:13:40.002]         if (TRUE) {
[16:13:40.002]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:40.002]                 open = "w")
[16:13:40.002]         }
[16:13:40.002]         else {
[16:13:40.002]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:40.002]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:40.002]         }
[16:13:40.002]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:40.002]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:40.002]             base::sink(type = "output", split = FALSE)
[16:13:40.002]             base::close(...future.stdout)
[16:13:40.002]         }, add = TRUE)
[16:13:40.002]     }
[16:13:40.002]     ...future.frame <- base::sys.nframe()
[16:13:40.002]     ...future.conditions <- base::list()
[16:13:40.002]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:40.002]     if (FALSE) {
[16:13:40.002]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:40.002]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:40.002]     }
[16:13:40.002]     ...future.result <- base::tryCatch({
[16:13:40.002]         base::withCallingHandlers({
[16:13:40.002]             ...future.value <- base::withVisible(base::local({
[16:13:40.002]                 1
[16:13:40.002]             }))
[16:13:40.002]             future::FutureResult(value = ...future.value$value, 
[16:13:40.002]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:40.002]                   ...future.rng), globalenv = if (FALSE) 
[16:13:40.002]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:40.002]                     ...future.globalenv.names))
[16:13:40.002]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:40.002]         }, condition = base::local({
[16:13:40.002]             c <- base::c
[16:13:40.002]             inherits <- base::inherits
[16:13:40.002]             invokeRestart <- base::invokeRestart
[16:13:40.002]             length <- base::length
[16:13:40.002]             list <- base::list
[16:13:40.002]             seq.int <- base::seq.int
[16:13:40.002]             signalCondition <- base::signalCondition
[16:13:40.002]             sys.calls <- base::sys.calls
[16:13:40.002]             `[[` <- base::`[[`
[16:13:40.002]             `+` <- base::`+`
[16:13:40.002]             `<<-` <- base::`<<-`
[16:13:40.002]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:40.002]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:40.002]                   3L)]
[16:13:40.002]             }
[16:13:40.002]             function(cond) {
[16:13:40.002]                 is_error <- inherits(cond, "error")
[16:13:40.002]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:40.002]                   NULL)
[16:13:40.002]                 if (is_error) {
[16:13:40.002]                   sessionInformation <- function() {
[16:13:40.002]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:40.002]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:40.002]                       search = base::search(), system = base::Sys.info())
[16:13:40.002]                   }
[16:13:40.002]                   ...future.conditions[[length(...future.conditions) + 
[16:13:40.002]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:40.002]                     cond$call), session = sessionInformation(), 
[16:13:40.002]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:40.002]                   signalCondition(cond)
[16:13:40.002]                 }
[16:13:40.002]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:40.002]                 "immediateCondition"))) {
[16:13:40.002]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:40.002]                   ...future.conditions[[length(...future.conditions) + 
[16:13:40.002]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:40.002]                   if (TRUE && !signal) {
[16:13:40.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.002]                     {
[16:13:40.002]                       inherits <- base::inherits
[16:13:40.002]                       invokeRestart <- base::invokeRestart
[16:13:40.002]                       is.null <- base::is.null
[16:13:40.002]                       muffled <- FALSE
[16:13:40.002]                       if (inherits(cond, "message")) {
[16:13:40.002]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:40.002]                         if (muffled) 
[16:13:40.002]                           invokeRestart("muffleMessage")
[16:13:40.002]                       }
[16:13:40.002]                       else if (inherits(cond, "warning")) {
[16:13:40.002]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:40.002]                         if (muffled) 
[16:13:40.002]                           invokeRestart("muffleWarning")
[16:13:40.002]                       }
[16:13:40.002]                       else if (inherits(cond, "condition")) {
[16:13:40.002]                         if (!is.null(pattern)) {
[16:13:40.002]                           computeRestarts <- base::computeRestarts
[16:13:40.002]                           grepl <- base::grepl
[16:13:40.002]                           restarts <- computeRestarts(cond)
[16:13:40.002]                           for (restart in restarts) {
[16:13:40.002]                             name <- restart$name
[16:13:40.002]                             if (is.null(name)) 
[16:13:40.002]                               next
[16:13:40.002]                             if (!grepl(pattern, name)) 
[16:13:40.002]                               next
[16:13:40.002]                             invokeRestart(restart)
[16:13:40.002]                             muffled <- TRUE
[16:13:40.002]                             break
[16:13:40.002]                           }
[16:13:40.002]                         }
[16:13:40.002]                       }
[16:13:40.002]                       invisible(muffled)
[16:13:40.002]                     }
[16:13:40.002]                     muffleCondition(cond, pattern = "^muffle")
[16:13:40.002]                   }
[16:13:40.002]                 }
[16:13:40.002]                 else {
[16:13:40.002]                   if (TRUE) {
[16:13:40.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.002]                     {
[16:13:40.002]                       inherits <- base::inherits
[16:13:40.002]                       invokeRestart <- base::invokeRestart
[16:13:40.002]                       is.null <- base::is.null
[16:13:40.002]                       muffled <- FALSE
[16:13:40.002]                       if (inherits(cond, "message")) {
[16:13:40.002]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:40.002]                         if (muffled) 
[16:13:40.002]                           invokeRestart("muffleMessage")
[16:13:40.002]                       }
[16:13:40.002]                       else if (inherits(cond, "warning")) {
[16:13:40.002]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:40.002]                         if (muffled) 
[16:13:40.002]                           invokeRestart("muffleWarning")
[16:13:40.002]                       }
[16:13:40.002]                       else if (inherits(cond, "condition")) {
[16:13:40.002]                         if (!is.null(pattern)) {
[16:13:40.002]                           computeRestarts <- base::computeRestarts
[16:13:40.002]                           grepl <- base::grepl
[16:13:40.002]                           restarts <- computeRestarts(cond)
[16:13:40.002]                           for (restart in restarts) {
[16:13:40.002]                             name <- restart$name
[16:13:40.002]                             if (is.null(name)) 
[16:13:40.002]                               next
[16:13:40.002]                             if (!grepl(pattern, name)) 
[16:13:40.002]                               next
[16:13:40.002]                             invokeRestart(restart)
[16:13:40.002]                             muffled <- TRUE
[16:13:40.002]                             break
[16:13:40.002]                           }
[16:13:40.002]                         }
[16:13:40.002]                       }
[16:13:40.002]                       invisible(muffled)
[16:13:40.002]                     }
[16:13:40.002]                     muffleCondition(cond, pattern = "^muffle")
[16:13:40.002]                   }
[16:13:40.002]                 }
[16:13:40.002]             }
[16:13:40.002]         }))
[16:13:40.002]     }, error = function(ex) {
[16:13:40.002]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:40.002]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:40.002]                 ...future.rng), started = ...future.startTime, 
[16:13:40.002]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:40.002]             version = "1.8"), class = "FutureResult")
[16:13:40.002]     }, finally = {
[16:13:40.002]         if (!identical(...future.workdir, getwd())) 
[16:13:40.002]             setwd(...future.workdir)
[16:13:40.002]         {
[16:13:40.002]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:40.002]                 ...future.oldOptions$nwarnings <- NULL
[16:13:40.002]             }
[16:13:40.002]             base::options(...future.oldOptions)
[16:13:40.002]             if (.Platform$OS.type == "windows") {
[16:13:40.002]                 old_names <- names(...future.oldEnvVars)
[16:13:40.002]                 envs <- base::Sys.getenv()
[16:13:40.002]                 names <- names(envs)
[16:13:40.002]                 common <- intersect(names, old_names)
[16:13:40.002]                 added <- setdiff(names, old_names)
[16:13:40.002]                 removed <- setdiff(old_names, names)
[16:13:40.002]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:40.002]                   envs[common]]
[16:13:40.002]                 NAMES <- toupper(changed)
[16:13:40.002]                 args <- list()
[16:13:40.002]                 for (kk in seq_along(NAMES)) {
[16:13:40.002]                   name <- changed[[kk]]
[16:13:40.002]                   NAME <- NAMES[[kk]]
[16:13:40.002]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.002]                     next
[16:13:40.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:40.002]                 }
[16:13:40.002]                 NAMES <- toupper(added)
[16:13:40.002]                 for (kk in seq_along(NAMES)) {
[16:13:40.002]                   name <- added[[kk]]
[16:13:40.002]                   NAME <- NAMES[[kk]]
[16:13:40.002]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.002]                     next
[16:13:40.002]                   args[[name]] <- ""
[16:13:40.002]                 }
[16:13:40.002]                 NAMES <- toupper(removed)
[16:13:40.002]                 for (kk in seq_along(NAMES)) {
[16:13:40.002]                   name <- removed[[kk]]
[16:13:40.002]                   NAME <- NAMES[[kk]]
[16:13:40.002]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.002]                     next
[16:13:40.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:40.002]                 }
[16:13:40.002]                 if (length(args) > 0) 
[16:13:40.002]                   base::do.call(base::Sys.setenv, args = args)
[16:13:40.002]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:40.002]             }
[16:13:40.002]             else {
[16:13:40.002]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:40.002]             }
[16:13:40.002]             {
[16:13:40.002]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:40.002]                   0L) {
[16:13:40.002]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:40.002]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:40.002]                   base::options(opts)
[16:13:40.002]                 }
[16:13:40.002]                 {
[16:13:40.002]                   {
[16:13:40.002]                     NULL
[16:13:40.002]                     RNGkind("Mersenne-Twister")
[16:13:40.002]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:40.002]                       inherits = FALSE)
[16:13:40.002]                   }
[16:13:40.002]                   options(future.plan = NULL)
[16:13:40.002]                   if (is.na(NA_character_)) 
[16:13:40.002]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:40.002]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:40.002]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:40.002]                   {
[16:13:40.002]                     future <- SequentialFuture(..., envir = envir)
[16:13:40.002]                     if (!future$lazy) 
[16:13:40.002]                       future <- run(future)
[16:13:40.002]                     invisible(future)
[16:13:40.002]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:40.002]                 }
[16:13:40.002]             }
[16:13:40.002]         }
[16:13:40.002]     })
[16:13:40.002]     if (TRUE) {
[16:13:40.002]         base::sink(type = "output", split = FALSE)
[16:13:40.002]         if (TRUE) {
[16:13:40.002]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:40.002]         }
[16:13:40.002]         else {
[16:13:40.002]             ...future.result["stdout"] <- base::list(NULL)
[16:13:40.002]         }
[16:13:40.002]         base::close(...future.stdout)
[16:13:40.002]         ...future.stdout <- NULL
[16:13:40.002]     }
[16:13:40.002]     ...future.result$conditions <- ...future.conditions
[16:13:40.002]     ...future.result$finished <- base::Sys.time()
[16:13:40.002]     ...future.result
[16:13:40.002] }
[16:13:40.003] plan(): Setting new future strategy stack:
[16:13:40.003] List of future strategies:
[16:13:40.003] 1. sequential:
[16:13:40.003]    - args: function (..., envir = parent.frame())
[16:13:40.003]    - tweaked: FALSE
[16:13:40.003]    - call: NULL
[16:13:40.004] plan(): nbrOfWorkers() = 1
[16:13:40.004] plan(): Setting new future strategy stack:
[16:13:40.005] List of future strategies:
[16:13:40.005] 1. sequential:
[16:13:40.005]    - args: function (..., envir = parent.frame())
[16:13:40.005]    - tweaked: FALSE
[16:13:40.005]    - call: plan(strategy)
[16:13:40.005] plan(): nbrOfWorkers() = 1
[16:13:40.005] SequentialFuture started (and completed)
[16:13:40.005] - Launch lazy future ... done
[16:13:40.005] run() for ‘SequentialFuture’ ... done
[16:13:40.006] getGlobalsAndPackages() ...
[16:13:40.006] Searching for globals...
[16:13:40.007] - globals found: [2] ‘{’, ‘Sys.sleep’
[16:13:40.007] Searching for globals ... DONE
[16:13:40.007] Resolving globals: FALSE
[16:13:40.007] 
[16:13:40.007] 
[16:13:40.007] getGlobalsAndPackages() ... DONE
[16:13:40.008] run() for ‘Future’ ...
[16:13:40.008] - state: ‘created’
[16:13:40.008] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:40.008] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:40.008] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:40.008]   - Field: ‘label’
[16:13:40.008]   - Field: ‘local’
[16:13:40.009]   - Field: ‘owner’
[16:13:40.009]   - Field: ‘envir’
[16:13:40.009]   - Field: ‘packages’
[16:13:40.009]   - Field: ‘gc’
[16:13:40.009]   - Field: ‘conditions’
[16:13:40.009]   - Field: ‘expr’
[16:13:40.009]   - Field: ‘uuid’
[16:13:40.009]   - Field: ‘seed’
[16:13:40.009]   - Field: ‘version’
[16:13:40.009]   - Field: ‘result’
[16:13:40.009]   - Field: ‘asynchronous’
[16:13:40.010]   - Field: ‘calls’
[16:13:40.010]   - Field: ‘globals’
[16:13:40.010]   - Field: ‘stdout’
[16:13:40.010]   - Field: ‘earlySignal’
[16:13:40.010]   - Field: ‘lazy’
[16:13:40.010]   - Field: ‘state’
[16:13:40.010] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:40.010] - Launch lazy future ...
[16:13:40.010] Packages needed by the future expression (n = 0): <none>
[16:13:40.010] Packages needed by future strategies (n = 0): <none>
[16:13:40.011] {
[16:13:40.011]     {
[16:13:40.011]         {
[16:13:40.011]             ...future.startTime <- base::Sys.time()
[16:13:40.011]             {
[16:13:40.011]                 {
[16:13:40.011]                   {
[16:13:40.011]                     base::local({
[16:13:40.011]                       has_future <- base::requireNamespace("future", 
[16:13:40.011]                         quietly = TRUE)
[16:13:40.011]                       if (has_future) {
[16:13:40.011]                         ns <- base::getNamespace("future")
[16:13:40.011]                         version <- ns[[".package"]][["version"]]
[16:13:40.011]                         if (is.null(version)) 
[16:13:40.011]                           version <- utils::packageVersion("future")
[16:13:40.011]                       }
[16:13:40.011]                       else {
[16:13:40.011]                         version <- NULL
[16:13:40.011]                       }
[16:13:40.011]                       if (!has_future || version < "1.8.0") {
[16:13:40.011]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:40.011]                           "", base::R.version$version.string), 
[16:13:40.011]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:40.011]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:40.011]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:40.011]                             "release", "version")], collapse = " "), 
[16:13:40.011]                           hostname = base::Sys.info()[["nodename"]])
[16:13:40.011]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:40.011]                           info)
[16:13:40.011]                         info <- base::paste(info, collapse = "; ")
[16:13:40.011]                         if (!has_future) {
[16:13:40.011]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:40.011]                             info)
[16:13:40.011]                         }
[16:13:40.011]                         else {
[16:13:40.011]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:40.011]                             info, version)
[16:13:40.011]                         }
[16:13:40.011]                         base::stop(msg)
[16:13:40.011]                       }
[16:13:40.011]                     })
[16:13:40.011]                   }
[16:13:40.011]                   options(future.plan = NULL)
[16:13:40.011]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:40.011]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:40.011]                 }
[16:13:40.011]                 ...future.workdir <- getwd()
[16:13:40.011]             }
[16:13:40.011]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:40.011]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:40.011]         }
[16:13:40.011]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:40.011]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:40.011]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:40.011]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:40.011]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:40.011]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:40.011]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:40.011]             base::names(...future.oldOptions))
[16:13:40.011]     }
[16:13:40.011]     if (FALSE) {
[16:13:40.011]     }
[16:13:40.011]     else {
[16:13:40.011]         if (TRUE) {
[16:13:40.011]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:40.011]                 open = "w")
[16:13:40.011]         }
[16:13:40.011]         else {
[16:13:40.011]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:40.011]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:40.011]         }
[16:13:40.011]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:40.011]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:40.011]             base::sink(type = "output", split = FALSE)
[16:13:40.011]             base::close(...future.stdout)
[16:13:40.011]         }, add = TRUE)
[16:13:40.011]     }
[16:13:40.011]     ...future.frame <- base::sys.nframe()
[16:13:40.011]     ...future.conditions <- base::list()
[16:13:40.011]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:40.011]     if (FALSE) {
[16:13:40.011]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:40.011]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:40.011]     }
[16:13:40.011]     ...future.result <- base::tryCatch({
[16:13:40.011]         base::withCallingHandlers({
[16:13:40.011]             ...future.value <- base::withVisible(base::local({
[16:13:40.011]                 Sys.sleep(0.5)
[16:13:40.011]                 2
[16:13:40.011]             }))
[16:13:40.011]             future::FutureResult(value = ...future.value$value, 
[16:13:40.011]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:40.011]                   ...future.rng), globalenv = if (FALSE) 
[16:13:40.011]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:40.011]                     ...future.globalenv.names))
[16:13:40.011]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:40.011]         }, condition = base::local({
[16:13:40.011]             c <- base::c
[16:13:40.011]             inherits <- base::inherits
[16:13:40.011]             invokeRestart <- base::invokeRestart
[16:13:40.011]             length <- base::length
[16:13:40.011]             list <- base::list
[16:13:40.011]             seq.int <- base::seq.int
[16:13:40.011]             signalCondition <- base::signalCondition
[16:13:40.011]             sys.calls <- base::sys.calls
[16:13:40.011]             `[[` <- base::`[[`
[16:13:40.011]             `+` <- base::`+`
[16:13:40.011]             `<<-` <- base::`<<-`
[16:13:40.011]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:40.011]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:40.011]                   3L)]
[16:13:40.011]             }
[16:13:40.011]             function(cond) {
[16:13:40.011]                 is_error <- inherits(cond, "error")
[16:13:40.011]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:40.011]                   NULL)
[16:13:40.011]                 if (is_error) {
[16:13:40.011]                   sessionInformation <- function() {
[16:13:40.011]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:40.011]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:40.011]                       search = base::search(), system = base::Sys.info())
[16:13:40.011]                   }
[16:13:40.011]                   ...future.conditions[[length(...future.conditions) + 
[16:13:40.011]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:40.011]                     cond$call), session = sessionInformation(), 
[16:13:40.011]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:40.011]                   signalCondition(cond)
[16:13:40.011]                 }
[16:13:40.011]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:40.011]                 "immediateCondition"))) {
[16:13:40.011]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:40.011]                   ...future.conditions[[length(...future.conditions) + 
[16:13:40.011]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:40.011]                   if (TRUE && !signal) {
[16:13:40.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.011]                     {
[16:13:40.011]                       inherits <- base::inherits
[16:13:40.011]                       invokeRestart <- base::invokeRestart
[16:13:40.011]                       is.null <- base::is.null
[16:13:40.011]                       muffled <- FALSE
[16:13:40.011]                       if (inherits(cond, "message")) {
[16:13:40.011]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:40.011]                         if (muffled) 
[16:13:40.011]                           invokeRestart("muffleMessage")
[16:13:40.011]                       }
[16:13:40.011]                       else if (inherits(cond, "warning")) {
[16:13:40.011]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:40.011]                         if (muffled) 
[16:13:40.011]                           invokeRestart("muffleWarning")
[16:13:40.011]                       }
[16:13:40.011]                       else if (inherits(cond, "condition")) {
[16:13:40.011]                         if (!is.null(pattern)) {
[16:13:40.011]                           computeRestarts <- base::computeRestarts
[16:13:40.011]                           grepl <- base::grepl
[16:13:40.011]                           restarts <- computeRestarts(cond)
[16:13:40.011]                           for (restart in restarts) {
[16:13:40.011]                             name <- restart$name
[16:13:40.011]                             if (is.null(name)) 
[16:13:40.011]                               next
[16:13:40.011]                             if (!grepl(pattern, name)) 
[16:13:40.011]                               next
[16:13:40.011]                             invokeRestart(restart)
[16:13:40.011]                             muffled <- TRUE
[16:13:40.011]                             break
[16:13:40.011]                           }
[16:13:40.011]                         }
[16:13:40.011]                       }
[16:13:40.011]                       invisible(muffled)
[16:13:40.011]                     }
[16:13:40.011]                     muffleCondition(cond, pattern = "^muffle")
[16:13:40.011]                   }
[16:13:40.011]                 }
[16:13:40.011]                 else {
[16:13:40.011]                   if (TRUE) {
[16:13:40.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.011]                     {
[16:13:40.011]                       inherits <- base::inherits
[16:13:40.011]                       invokeRestart <- base::invokeRestart
[16:13:40.011]                       is.null <- base::is.null
[16:13:40.011]                       muffled <- FALSE
[16:13:40.011]                       if (inherits(cond, "message")) {
[16:13:40.011]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:40.011]                         if (muffled) 
[16:13:40.011]                           invokeRestart("muffleMessage")
[16:13:40.011]                       }
[16:13:40.011]                       else if (inherits(cond, "warning")) {
[16:13:40.011]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:40.011]                         if (muffled) 
[16:13:40.011]                           invokeRestart("muffleWarning")
[16:13:40.011]                       }
[16:13:40.011]                       else if (inherits(cond, "condition")) {
[16:13:40.011]                         if (!is.null(pattern)) {
[16:13:40.011]                           computeRestarts <- base::computeRestarts
[16:13:40.011]                           grepl <- base::grepl
[16:13:40.011]                           restarts <- computeRestarts(cond)
[16:13:40.011]                           for (restart in restarts) {
[16:13:40.011]                             name <- restart$name
[16:13:40.011]                             if (is.null(name)) 
[16:13:40.011]                               next
[16:13:40.011]                             if (!grepl(pattern, name)) 
[16:13:40.011]                               next
[16:13:40.011]                             invokeRestart(restart)
[16:13:40.011]                             muffled <- TRUE
[16:13:40.011]                             break
[16:13:40.011]                           }
[16:13:40.011]                         }
[16:13:40.011]                       }
[16:13:40.011]                       invisible(muffled)
[16:13:40.011]                     }
[16:13:40.011]                     muffleCondition(cond, pattern = "^muffle")
[16:13:40.011]                   }
[16:13:40.011]                 }
[16:13:40.011]             }
[16:13:40.011]         }))
[16:13:40.011]     }, error = function(ex) {
[16:13:40.011]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:40.011]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:40.011]                 ...future.rng), started = ...future.startTime, 
[16:13:40.011]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:40.011]             version = "1.8"), class = "FutureResult")
[16:13:40.011]     }, finally = {
[16:13:40.011]         if (!identical(...future.workdir, getwd())) 
[16:13:40.011]             setwd(...future.workdir)
[16:13:40.011]         {
[16:13:40.011]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:40.011]                 ...future.oldOptions$nwarnings <- NULL
[16:13:40.011]             }
[16:13:40.011]             base::options(...future.oldOptions)
[16:13:40.011]             if (.Platform$OS.type == "windows") {
[16:13:40.011]                 old_names <- names(...future.oldEnvVars)
[16:13:40.011]                 envs <- base::Sys.getenv()
[16:13:40.011]                 names <- names(envs)
[16:13:40.011]                 common <- intersect(names, old_names)
[16:13:40.011]                 added <- setdiff(names, old_names)
[16:13:40.011]                 removed <- setdiff(old_names, names)
[16:13:40.011]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:40.011]                   envs[common]]
[16:13:40.011]                 NAMES <- toupper(changed)
[16:13:40.011]                 args <- list()
[16:13:40.011]                 for (kk in seq_along(NAMES)) {
[16:13:40.011]                   name <- changed[[kk]]
[16:13:40.011]                   NAME <- NAMES[[kk]]
[16:13:40.011]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.011]                     next
[16:13:40.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:40.011]                 }
[16:13:40.011]                 NAMES <- toupper(added)
[16:13:40.011]                 for (kk in seq_along(NAMES)) {
[16:13:40.011]                   name <- added[[kk]]
[16:13:40.011]                   NAME <- NAMES[[kk]]
[16:13:40.011]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.011]                     next
[16:13:40.011]                   args[[name]] <- ""
[16:13:40.011]                 }
[16:13:40.011]                 NAMES <- toupper(removed)
[16:13:40.011]                 for (kk in seq_along(NAMES)) {
[16:13:40.011]                   name <- removed[[kk]]
[16:13:40.011]                   NAME <- NAMES[[kk]]
[16:13:40.011]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.011]                     next
[16:13:40.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:40.011]                 }
[16:13:40.011]                 if (length(args) > 0) 
[16:13:40.011]                   base::do.call(base::Sys.setenv, args = args)
[16:13:40.011]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:40.011]             }
[16:13:40.011]             else {
[16:13:40.011]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:40.011]             }
[16:13:40.011]             {
[16:13:40.011]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:40.011]                   0L) {
[16:13:40.011]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:40.011]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:40.011]                   base::options(opts)
[16:13:40.011]                 }
[16:13:40.011]                 {
[16:13:40.011]                   {
[16:13:40.011]                     NULL
[16:13:40.011]                     RNGkind("Mersenne-Twister")
[16:13:40.011]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:40.011]                       inherits = FALSE)
[16:13:40.011]                   }
[16:13:40.011]                   options(future.plan = NULL)
[16:13:40.011]                   if (is.na(NA_character_)) 
[16:13:40.011]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:40.011]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:40.011]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:40.011]                   {
[16:13:40.011]                     future <- SequentialFuture(..., envir = envir)
[16:13:40.011]                     if (!future$lazy) 
[16:13:40.011]                       future <- run(future)
[16:13:40.011]                     invisible(future)
[16:13:40.011]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:40.011]                 }
[16:13:40.011]             }
[16:13:40.011]         }
[16:13:40.011]     })
[16:13:40.011]     if (TRUE) {
[16:13:40.011]         base::sink(type = "output", split = FALSE)
[16:13:40.011]         if (TRUE) {
[16:13:40.011]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:40.011]         }
[16:13:40.011]         else {
[16:13:40.011]             ...future.result["stdout"] <- base::list(NULL)
[16:13:40.011]         }
[16:13:40.011]         base::close(...future.stdout)
[16:13:40.011]         ...future.stdout <- NULL
[16:13:40.011]     }
[16:13:40.011]     ...future.result$conditions <- ...future.conditions
[16:13:40.011]     ...future.result$finished <- base::Sys.time()
[16:13:40.011]     ...future.result
[16:13:40.011] }
[16:13:40.013] plan(): Setting new future strategy stack:
[16:13:40.013] List of future strategies:
[16:13:40.013] 1. sequential:
[16:13:40.013]    - args: function (..., envir = parent.frame())
[16:13:40.013]    - tweaked: FALSE
[16:13:40.013]    - call: NULL
[16:13:40.013] plan(): nbrOfWorkers() = 1
[16:13:40.515] plan(): Setting new future strategy stack:
[16:13:40.515] List of future strategies:
[16:13:40.515] 1. sequential:
[16:13:40.515]    - args: function (..., envir = parent.frame())
[16:13:40.515]    - tweaked: FALSE
[16:13:40.515]    - call: plan(strategy)
[16:13:40.515] plan(): nbrOfWorkers() = 1
[16:13:40.516] SequentialFuture started (and completed)
[16:13:40.516] - Launch lazy future ... done
[16:13:40.516] run() for ‘SequentialFuture’ ... done
[16:13:40.516] getGlobalsAndPackages() ...
[16:13:40.516] Searching for globals...
[16:13:40.517] - globals found: [1] ‘{’
[16:13:40.517] Searching for globals ... DONE
[16:13:40.517] Resolving globals: FALSE
[16:13:40.518] 
[16:13:40.518] 
[16:13:40.518] getGlobalsAndPackages() ... DONE
[16:13:40.518] run() for ‘Future’ ...
[16:13:40.518] - state: ‘created’
[16:13:40.518] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:40.519] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:40.519] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:40.519]   - Field: ‘label’
[16:13:40.519]   - Field: ‘local’
[16:13:40.521]   - Field: ‘owner’
[16:13:40.521]   - Field: ‘envir’
[16:13:40.521]   - Field: ‘packages’
[16:13:40.521]   - Field: ‘gc’
[16:13:40.521]   - Field: ‘conditions’
[16:13:40.522]   - Field: ‘expr’
[16:13:40.522]   - Field: ‘uuid’
[16:13:40.522]   - Field: ‘seed’
[16:13:40.522]   - Field: ‘version’
[16:13:40.522]   - Field: ‘result’
[16:13:40.522]   - Field: ‘asynchronous’
[16:13:40.522]   - Field: ‘calls’
[16:13:40.522]   - Field: ‘globals’
[16:13:40.522]   - Field: ‘stdout’
[16:13:40.522]   - Field: ‘earlySignal’
[16:13:40.523]   - Field: ‘lazy’
[16:13:40.523]   - Field: ‘state’
[16:13:40.523] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:40.523] - Launch lazy future ...
[16:13:40.523] Packages needed by the future expression (n = 0): <none>
[16:13:40.523] Packages needed by future strategies (n = 0): <none>
[16:13:40.524] {
[16:13:40.524]     {
[16:13:40.524]         {
[16:13:40.524]             ...future.startTime <- base::Sys.time()
[16:13:40.524]             {
[16:13:40.524]                 {
[16:13:40.524]                   {
[16:13:40.524]                     base::local({
[16:13:40.524]                       has_future <- base::requireNamespace("future", 
[16:13:40.524]                         quietly = TRUE)
[16:13:40.524]                       if (has_future) {
[16:13:40.524]                         ns <- base::getNamespace("future")
[16:13:40.524]                         version <- ns[[".package"]][["version"]]
[16:13:40.524]                         if (is.null(version)) 
[16:13:40.524]                           version <- utils::packageVersion("future")
[16:13:40.524]                       }
[16:13:40.524]                       else {
[16:13:40.524]                         version <- NULL
[16:13:40.524]                       }
[16:13:40.524]                       if (!has_future || version < "1.8.0") {
[16:13:40.524]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:40.524]                           "", base::R.version$version.string), 
[16:13:40.524]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:40.524]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:40.524]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:40.524]                             "release", "version")], collapse = " "), 
[16:13:40.524]                           hostname = base::Sys.info()[["nodename"]])
[16:13:40.524]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:40.524]                           info)
[16:13:40.524]                         info <- base::paste(info, collapse = "; ")
[16:13:40.524]                         if (!has_future) {
[16:13:40.524]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:40.524]                             info)
[16:13:40.524]                         }
[16:13:40.524]                         else {
[16:13:40.524]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:40.524]                             info, version)
[16:13:40.524]                         }
[16:13:40.524]                         base::stop(msg)
[16:13:40.524]                       }
[16:13:40.524]                     })
[16:13:40.524]                   }
[16:13:40.524]                   options(future.plan = NULL)
[16:13:40.524]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:40.524]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:40.524]                 }
[16:13:40.524]                 ...future.workdir <- getwd()
[16:13:40.524]             }
[16:13:40.524]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:40.524]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:40.524]         }
[16:13:40.524]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:40.524]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:40.524]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:40.524]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:40.524]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:40.524]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:40.524]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:40.524]             base::names(...future.oldOptions))
[16:13:40.524]     }
[16:13:40.524]     if (FALSE) {
[16:13:40.524]     }
[16:13:40.524]     else {
[16:13:40.524]         if (TRUE) {
[16:13:40.524]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:40.524]                 open = "w")
[16:13:40.524]         }
[16:13:40.524]         else {
[16:13:40.524]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:40.524]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:40.524]         }
[16:13:40.524]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:40.524]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:40.524]             base::sink(type = "output", split = FALSE)
[16:13:40.524]             base::close(...future.stdout)
[16:13:40.524]         }, add = TRUE)
[16:13:40.524]     }
[16:13:40.524]     ...future.frame <- base::sys.nframe()
[16:13:40.524]     ...future.conditions <- base::list()
[16:13:40.524]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:40.524]     if (FALSE) {
[16:13:40.524]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:40.524]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:40.524]     }
[16:13:40.524]     ...future.result <- base::tryCatch({
[16:13:40.524]         base::withCallingHandlers({
[16:13:40.524]             ...future.value <- base::withVisible(base::local({
[16:13:40.524]                 3
[16:13:40.524]             }))
[16:13:40.524]             future::FutureResult(value = ...future.value$value, 
[16:13:40.524]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:40.524]                   ...future.rng), globalenv = if (FALSE) 
[16:13:40.524]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:40.524]                     ...future.globalenv.names))
[16:13:40.524]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:40.524]         }, condition = base::local({
[16:13:40.524]             c <- base::c
[16:13:40.524]             inherits <- base::inherits
[16:13:40.524]             invokeRestart <- base::invokeRestart
[16:13:40.524]             length <- base::length
[16:13:40.524]             list <- base::list
[16:13:40.524]             seq.int <- base::seq.int
[16:13:40.524]             signalCondition <- base::signalCondition
[16:13:40.524]             sys.calls <- base::sys.calls
[16:13:40.524]             `[[` <- base::`[[`
[16:13:40.524]             `+` <- base::`+`
[16:13:40.524]             `<<-` <- base::`<<-`
[16:13:40.524]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:40.524]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:40.524]                   3L)]
[16:13:40.524]             }
[16:13:40.524]             function(cond) {
[16:13:40.524]                 is_error <- inherits(cond, "error")
[16:13:40.524]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:40.524]                   NULL)
[16:13:40.524]                 if (is_error) {
[16:13:40.524]                   sessionInformation <- function() {
[16:13:40.524]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:40.524]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:40.524]                       search = base::search(), system = base::Sys.info())
[16:13:40.524]                   }
[16:13:40.524]                   ...future.conditions[[length(...future.conditions) + 
[16:13:40.524]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:40.524]                     cond$call), session = sessionInformation(), 
[16:13:40.524]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:40.524]                   signalCondition(cond)
[16:13:40.524]                 }
[16:13:40.524]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:40.524]                 "immediateCondition"))) {
[16:13:40.524]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:40.524]                   ...future.conditions[[length(...future.conditions) + 
[16:13:40.524]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:40.524]                   if (TRUE && !signal) {
[16:13:40.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.524]                     {
[16:13:40.524]                       inherits <- base::inherits
[16:13:40.524]                       invokeRestart <- base::invokeRestart
[16:13:40.524]                       is.null <- base::is.null
[16:13:40.524]                       muffled <- FALSE
[16:13:40.524]                       if (inherits(cond, "message")) {
[16:13:40.524]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:40.524]                         if (muffled) 
[16:13:40.524]                           invokeRestart("muffleMessage")
[16:13:40.524]                       }
[16:13:40.524]                       else if (inherits(cond, "warning")) {
[16:13:40.524]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:40.524]                         if (muffled) 
[16:13:40.524]                           invokeRestart("muffleWarning")
[16:13:40.524]                       }
[16:13:40.524]                       else if (inherits(cond, "condition")) {
[16:13:40.524]                         if (!is.null(pattern)) {
[16:13:40.524]                           computeRestarts <- base::computeRestarts
[16:13:40.524]                           grepl <- base::grepl
[16:13:40.524]                           restarts <- computeRestarts(cond)
[16:13:40.524]                           for (restart in restarts) {
[16:13:40.524]                             name <- restart$name
[16:13:40.524]                             if (is.null(name)) 
[16:13:40.524]                               next
[16:13:40.524]                             if (!grepl(pattern, name)) 
[16:13:40.524]                               next
[16:13:40.524]                             invokeRestart(restart)
[16:13:40.524]                             muffled <- TRUE
[16:13:40.524]                             break
[16:13:40.524]                           }
[16:13:40.524]                         }
[16:13:40.524]                       }
[16:13:40.524]                       invisible(muffled)
[16:13:40.524]                     }
[16:13:40.524]                     muffleCondition(cond, pattern = "^muffle")
[16:13:40.524]                   }
[16:13:40.524]                 }
[16:13:40.524]                 else {
[16:13:40.524]                   if (TRUE) {
[16:13:40.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.524]                     {
[16:13:40.524]                       inherits <- base::inherits
[16:13:40.524]                       invokeRestart <- base::invokeRestart
[16:13:40.524]                       is.null <- base::is.null
[16:13:40.524]                       muffled <- FALSE
[16:13:40.524]                       if (inherits(cond, "message")) {
[16:13:40.524]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:40.524]                         if (muffled) 
[16:13:40.524]                           invokeRestart("muffleMessage")
[16:13:40.524]                       }
[16:13:40.524]                       else if (inherits(cond, "warning")) {
[16:13:40.524]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:40.524]                         if (muffled) 
[16:13:40.524]                           invokeRestart("muffleWarning")
[16:13:40.524]                       }
[16:13:40.524]                       else if (inherits(cond, "condition")) {
[16:13:40.524]                         if (!is.null(pattern)) {
[16:13:40.524]                           computeRestarts <- base::computeRestarts
[16:13:40.524]                           grepl <- base::grepl
[16:13:40.524]                           restarts <- computeRestarts(cond)
[16:13:40.524]                           for (restart in restarts) {
[16:13:40.524]                             name <- restart$name
[16:13:40.524]                             if (is.null(name)) 
[16:13:40.524]                               next
[16:13:40.524]                             if (!grepl(pattern, name)) 
[16:13:40.524]                               next
[16:13:40.524]                             invokeRestart(restart)
[16:13:40.524]                             muffled <- TRUE
[16:13:40.524]                             break
[16:13:40.524]                           }
[16:13:40.524]                         }
[16:13:40.524]                       }
[16:13:40.524]                       invisible(muffled)
[16:13:40.524]                     }
[16:13:40.524]                     muffleCondition(cond, pattern = "^muffle")
[16:13:40.524]                   }
[16:13:40.524]                 }
[16:13:40.524]             }
[16:13:40.524]         }))
[16:13:40.524]     }, error = function(ex) {
[16:13:40.524]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:40.524]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:40.524]                 ...future.rng), started = ...future.startTime, 
[16:13:40.524]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:40.524]             version = "1.8"), class = "FutureResult")
[16:13:40.524]     }, finally = {
[16:13:40.524]         if (!identical(...future.workdir, getwd())) 
[16:13:40.524]             setwd(...future.workdir)
[16:13:40.524]         {
[16:13:40.524]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:40.524]                 ...future.oldOptions$nwarnings <- NULL
[16:13:40.524]             }
[16:13:40.524]             base::options(...future.oldOptions)
[16:13:40.524]             if (.Platform$OS.type == "windows") {
[16:13:40.524]                 old_names <- names(...future.oldEnvVars)
[16:13:40.524]                 envs <- base::Sys.getenv()
[16:13:40.524]                 names <- names(envs)
[16:13:40.524]                 common <- intersect(names, old_names)
[16:13:40.524]                 added <- setdiff(names, old_names)
[16:13:40.524]                 removed <- setdiff(old_names, names)
[16:13:40.524]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:40.524]                   envs[common]]
[16:13:40.524]                 NAMES <- toupper(changed)
[16:13:40.524]                 args <- list()
[16:13:40.524]                 for (kk in seq_along(NAMES)) {
[16:13:40.524]                   name <- changed[[kk]]
[16:13:40.524]                   NAME <- NAMES[[kk]]
[16:13:40.524]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.524]                     next
[16:13:40.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:40.524]                 }
[16:13:40.524]                 NAMES <- toupper(added)
[16:13:40.524]                 for (kk in seq_along(NAMES)) {
[16:13:40.524]                   name <- added[[kk]]
[16:13:40.524]                   NAME <- NAMES[[kk]]
[16:13:40.524]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.524]                     next
[16:13:40.524]                   args[[name]] <- ""
[16:13:40.524]                 }
[16:13:40.524]                 NAMES <- toupper(removed)
[16:13:40.524]                 for (kk in seq_along(NAMES)) {
[16:13:40.524]                   name <- removed[[kk]]
[16:13:40.524]                   NAME <- NAMES[[kk]]
[16:13:40.524]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.524]                     next
[16:13:40.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:40.524]                 }
[16:13:40.524]                 if (length(args) > 0) 
[16:13:40.524]                   base::do.call(base::Sys.setenv, args = args)
[16:13:40.524]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:40.524]             }
[16:13:40.524]             else {
[16:13:40.524]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:40.524]             }
[16:13:40.524]             {
[16:13:40.524]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:40.524]                   0L) {
[16:13:40.524]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:40.524]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:40.524]                   base::options(opts)
[16:13:40.524]                 }
[16:13:40.524]                 {
[16:13:40.524]                   {
[16:13:40.524]                     NULL
[16:13:40.524]                     RNGkind("Mersenne-Twister")
[16:13:40.524]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:40.524]                       inherits = FALSE)
[16:13:40.524]                   }
[16:13:40.524]                   options(future.plan = NULL)
[16:13:40.524]                   if (is.na(NA_character_)) 
[16:13:40.524]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:40.524]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:40.524]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:40.524]                   {
[16:13:40.524]                     future <- SequentialFuture(..., envir = envir)
[16:13:40.524]                     if (!future$lazy) 
[16:13:40.524]                       future <- run(future)
[16:13:40.524]                     invisible(future)
[16:13:40.524]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:40.524]                 }
[16:13:40.524]             }
[16:13:40.524]         }
[16:13:40.524]     })
[16:13:40.524]     if (TRUE) {
[16:13:40.524]         base::sink(type = "output", split = FALSE)
[16:13:40.524]         if (TRUE) {
[16:13:40.524]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:40.524]         }
[16:13:40.524]         else {
[16:13:40.524]             ...future.result["stdout"] <- base::list(NULL)
[16:13:40.524]         }
[16:13:40.524]         base::close(...future.stdout)
[16:13:40.524]         ...future.stdout <- NULL
[16:13:40.524]     }
[16:13:40.524]     ...future.result$conditions <- ...future.conditions
[16:13:40.524]     ...future.result$finished <- base::Sys.time()
[16:13:40.524]     ...future.result
[16:13:40.524] }
[16:13:40.525] plan(): Setting new future strategy stack:
[16:13:40.526] List of future strategies:
[16:13:40.526] 1. sequential:
[16:13:40.526]    - args: function (..., envir = parent.frame())
[16:13:40.526]    - tweaked: FALSE
[16:13:40.526]    - call: NULL
[16:13:40.526] plan(): nbrOfWorkers() = 1
[16:13:40.527] plan(): Setting new future strategy stack:
[16:13:40.527] List of future strategies:
[16:13:40.527] 1. sequential:
[16:13:40.527]    - args: function (..., envir = parent.frame())
[16:13:40.527]    - tweaked: FALSE
[16:13:40.527]    - call: plan(strategy)
[16:13:40.527] plan(): nbrOfWorkers() = 1
[16:13:40.527] SequentialFuture started (and completed)
[16:13:40.527] - Launch lazy future ... done
[16:13:40.527] run() for ‘SequentialFuture’ ... done
[16:13:40.528] resolve() on list environment ...
[16:13:40.528]  recursive: 0
[16:13:40.529]  length: 4
[16:13:40.529]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:13:40.529] resolved() for ‘SequentialFuture’ ...
[16:13:40.529] - state: ‘finished’
[16:13:40.529] - run: TRUE
[16:13:40.529] - result: ‘FutureResult’
[16:13:40.529] resolved() for ‘SequentialFuture’ ... done
[16:13:40.530] Future #1
[16:13:40.530]  length: 3 (resolved future 1)
[16:13:40.530] resolved() for ‘SequentialFuture’ ...
[16:13:40.530] - state: ‘finished’
[16:13:40.530] - run: TRUE
[16:13:40.530] - result: ‘FutureResult’
[16:13:40.530] resolved() for ‘SequentialFuture’ ... done
[16:13:40.530] Future #2
[16:13:40.530]  length: 2 (resolved future 2)
[16:13:40.530] resolved() for ‘SequentialFuture’ ...
[16:13:40.531] - state: ‘finished’
[16:13:40.531] - run: TRUE
[16:13:40.531] - result: ‘FutureResult’
[16:13:40.531] resolved() for ‘SequentialFuture’ ... done
[16:13:40.531] Future #3
[16:13:40.531]  length: 1 (resolved future 3)
[16:13:40.531]  length: 0 (resolved future 4)
[16:13:40.531] resolve() on list environment ... DONE
[16:13:40.532] resolved() for ‘SequentialFuture’ ...
[16:13:40.532] - state: ‘finished’
[16:13:40.532] - run: TRUE
[16:13:40.532] - result: ‘FutureResult’
[16:13:40.532] resolved() for ‘SequentialFuture’ ... done
[16:13:40.532] resolve() on list environment ...
[16:13:40.532]  recursive: 0
[16:13:40.533]  length: 4
[16:13:40.533]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:13:40.533] resolved() for ‘SequentialFuture’ ...
[16:13:40.533] - state: ‘finished’
[16:13:40.533] - run: TRUE
[16:13:40.533] - result: ‘FutureResult’
[16:13:40.533] resolved() for ‘SequentialFuture’ ... done
[16:13:40.534] Future #1
[16:13:40.534]  length: 3 (resolved future 1)
[16:13:40.534] resolved() for ‘SequentialFuture’ ...
[16:13:40.534] - state: ‘finished’
[16:13:40.534] - run: TRUE
[16:13:40.534] - result: ‘FutureResult’
[16:13:40.534] resolved() for ‘SequentialFuture’ ... done
[16:13:40.534] Future #2
[16:13:40.534]  length: 2 (resolved future 2)
[16:13:40.534] resolved() for ‘SequentialFuture’ ...
[16:13:40.535] - state: ‘finished’
[16:13:40.535] - run: TRUE
[16:13:40.535] - result: ‘FutureResult’
[16:13:40.535] resolved() for ‘SequentialFuture’ ... done
[16:13:40.535] Future #3
[16:13:40.535]  length: 1 (resolved future 3)
[16:13:40.535]  length: 0 (resolved future 4)
[16:13:40.535] resolve() on list environment ... DONE
[16:13:40.536] resolve() on list environment ...
[16:13:40.536]  recursive: 0
[16:13:40.537]  length: 4
[16:13:40.537]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:13:40.537] resolved() for ‘SequentialFuture’ ...
[16:13:40.537] - state: ‘finished’
[16:13:40.537] - run: TRUE
[16:13:40.537] - result: ‘FutureResult’
[16:13:40.537] resolved() for ‘SequentialFuture’ ... done
[16:13:40.537] Future #1
[16:13:40.537]  length: 3 (resolved future 1)
[16:13:40.537] resolved() for ‘SequentialFuture’ ...
[16:13:40.538] - state: ‘finished’
[16:13:40.538] - run: TRUE
[16:13:40.538] - result: ‘FutureResult’
[16:13:40.538] resolved() for ‘SequentialFuture’ ... done
[16:13:40.538] Future #2
[16:13:40.538]  length: 2 (resolved future 2)
[16:13:40.538] resolved() for ‘SequentialFuture’ ...
[16:13:40.538] - state: ‘finished’
[16:13:40.538] - run: TRUE
[16:13:40.538] - result: ‘FutureResult’
[16:13:40.538] resolved() for ‘SequentialFuture’ ... done
[16:13:40.539] Future #3
[16:13:40.539]  length: 1 (resolved future 3)
[16:13:40.539]  length: 0 (resolved future 4)
[16:13:40.539] resolve() on list environment ... DONE
[16:13:40.539] resolve() on list environment ...
[16:13:40.539]  recursive: 0
[16:13:40.540]  length: 4
[16:13:40.540]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:13:40.540] resolved() for ‘SequentialFuture’ ...
[16:13:40.540] - state: ‘finished’
[16:13:40.540] - run: TRUE
[16:13:40.541] - result: ‘FutureResult’
[16:13:40.541] resolved() for ‘SequentialFuture’ ... done
[16:13:40.541] Future #1
[16:13:40.541]  length: 3 (resolved future 1)
[16:13:40.541] resolved() for ‘SequentialFuture’ ...
[16:13:40.541] - state: ‘finished’
[16:13:40.541] - run: TRUE
[16:13:40.541] - result: ‘FutureResult’
[16:13:40.541] resolved() for ‘SequentialFuture’ ... done
[16:13:40.541] Future #2
[16:13:40.541]  length: 2 (resolved future 2)
[16:13:40.542] resolved() for ‘SequentialFuture’ ...
[16:13:40.542] - state: ‘finished’
[16:13:40.542] - run: TRUE
[16:13:40.542] - result: ‘FutureResult’
[16:13:40.542] resolved() for ‘SequentialFuture’ ... done
[16:13:40.542] Future #3
[16:13:40.542]  length: 1 (resolved future 3)
[16:13:40.542]  length: 0 (resolved future 4)
[16:13:40.542] resolve() on list environment ... DONE
[16:13:40.568] resolve() on list environment ...
[16:13:40.569]  recursive: 0
[16:13:40.569]  length: 4
[16:13:40.570]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:13:40.570] resolved() for ‘SequentialFuture’ ...
[16:13:40.570] - state: ‘finished’
[16:13:40.570] - run: TRUE
[16:13:40.570] - result: ‘FutureResult’
[16:13:40.570] resolved() for ‘SequentialFuture’ ... done
[16:13:40.570] Future #1
[16:13:40.570]  length: 3 (resolved future 1)
[16:13:40.571] resolved() for ‘SequentialFuture’ ...
[16:13:40.571] - state: ‘finished’
[16:13:40.571] - run: TRUE
[16:13:40.571] - result: ‘FutureResult’
[16:13:40.571] resolved() for ‘SequentialFuture’ ... done
[16:13:40.571] Future #2
[16:13:40.571]  length: 2 (resolved future 2)
[16:13:40.571] resolved() for ‘SequentialFuture’ ...
[16:13:40.571] - state: ‘finished’
[16:13:40.571] - run: TRUE
[16:13:40.572] - result: ‘FutureResult’
[16:13:40.572] resolved() for ‘SequentialFuture’ ... done
[16:13:40.572] Future #3
[16:13:40.572]  length: 1 (resolved future 3)
[16:13:40.572]  length: 0 (resolved future 4)
[16:13:40.572] resolve() on list environment ... DONE
[16:13:40.573] resolve() on list environment ...
[16:13:40.573]  recursive: 99
[16:13:40.573]  length: 4
[16:13:40.573]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:13:40.574] resolved() for ‘SequentialFuture’ ...
[16:13:40.574] - state: ‘finished’
[16:13:40.574] - run: TRUE
[16:13:40.574] - result: ‘FutureResult’
[16:13:40.574] resolved() for ‘SequentialFuture’ ... done
[16:13:40.574] Future #1
[16:13:40.574] resolved() for ‘SequentialFuture’ ...
[16:13:40.574] - state: ‘finished’
[16:13:40.574] - run: TRUE
[16:13:40.574] - result: ‘FutureResult’
[16:13:40.574] resolved() for ‘SequentialFuture’ ... done
[16:13:40.575] A SequentialFuture was resolved
[16:13:40.575]  length: 3 (resolved future 1)
[16:13:40.575] resolved() for ‘SequentialFuture’ ...
[16:13:40.575] - state: ‘finished’
[16:13:40.575] - run: TRUE
[16:13:40.575] - result: ‘FutureResult’
[16:13:40.575] resolved() for ‘SequentialFuture’ ... done
[16:13:40.575] Future #2
[16:13:40.575] resolved() for ‘SequentialFuture’ ...
[16:13:40.575] - state: ‘finished’
[16:13:40.576] - run: TRUE
[16:13:40.576] - result: ‘FutureResult’
[16:13:40.576] resolved() for ‘SequentialFuture’ ... done
[16:13:40.576] A SequentialFuture was resolved
[16:13:40.576]  length: 2 (resolved future 2)
[16:13:40.576] resolved() for ‘SequentialFuture’ ...
[16:13:40.576] - state: ‘finished’
[16:13:40.576] - run: TRUE
[16:13:40.576] - result: ‘FutureResult’
[16:13:40.576] resolved() for ‘SequentialFuture’ ... done
[16:13:40.577] Future #3
[16:13:40.577] resolved() for ‘SequentialFuture’ ...
[16:13:40.577] - state: ‘finished’
[16:13:40.577] - run: TRUE
[16:13:40.577] - result: ‘FutureResult’
[16:13:40.577] resolved() for ‘SequentialFuture’ ... done
[16:13:40.577] A SequentialFuture was resolved
[16:13:40.577]  length: 1 (resolved future 3)
[16:13:40.577]  length: 0 (resolved future 4)
[16:13:40.577] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('sequential') ...
- plan('multicore') ...
[16:13:40.578] plan(): Setting new future strategy stack:
[16:13:40.578] List of future strategies:
[16:13:40.578] 1. multicore:
[16:13:40.578]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:40.578]    - tweaked: FALSE
[16:13:40.578]    - call: plan(strategy)
[16:13:40.582] plan(): nbrOfWorkers() = 2
*** resolve() for lists ...
[16:13:40.583] resolve() on list ...
[16:13:40.583]  recursive: 0
[16:13:40.583]  length: 2
[16:13:40.583]  elements: ‘a’, ‘b’
[16:13:40.583]  length: 1 (resolved future 1)
[16:13:40.583]  length: 0 (resolved future 2)
[16:13:40.583] resolve() on list ... DONE
[16:13:40.584] getGlobalsAndPackages() ...
[16:13:40.584] Searching for globals...
[16:13:40.584] 
[16:13:40.584] Searching for globals ... DONE
[16:13:40.584] - globals: [0] <none>
[16:13:40.584] getGlobalsAndPackages() ... DONE
[16:13:40.585] run() for ‘Future’ ...
[16:13:40.585] - state: ‘created’
[16:13:40.585] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:40.588] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:40.588] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:40.589]   - Field: ‘label’
[16:13:40.589]   - Field: ‘local’
[16:13:40.589]   - Field: ‘owner’
[16:13:40.589]   - Field: ‘envir’
[16:13:40.589]   - Field: ‘workers’
[16:13:40.589]   - Field: ‘packages’
[16:13:40.589]   - Field: ‘gc’
[16:13:40.589]   - Field: ‘job’
[16:13:40.589]   - Field: ‘conditions’
[16:13:40.589]   - Field: ‘expr’
[16:13:40.590]   - Field: ‘uuid’
[16:13:40.590]   - Field: ‘seed’
[16:13:40.590]   - Field: ‘version’
[16:13:40.590]   - Field: ‘result’
[16:13:40.590]   - Field: ‘asynchronous’
[16:13:40.590]   - Field: ‘calls’
[16:13:40.590]   - Field: ‘globals’
[16:13:40.590]   - Field: ‘stdout’
[16:13:40.590]   - Field: ‘earlySignal’
[16:13:40.590]   - Field: ‘lazy’
[16:13:40.591]   - Field: ‘state’
[16:13:40.591] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:40.591] - Launch lazy future ...
[16:13:40.592] Packages needed by the future expression (n = 0): <none>
[16:13:40.592] Packages needed by future strategies (n = 0): <none>
[16:13:40.592] {
[16:13:40.592]     {
[16:13:40.592]         {
[16:13:40.592]             ...future.startTime <- base::Sys.time()
[16:13:40.592]             {
[16:13:40.592]                 {
[16:13:40.592]                   {
[16:13:40.592]                     {
[16:13:40.592]                       base::local({
[16:13:40.592]                         has_future <- base::requireNamespace("future", 
[16:13:40.592]                           quietly = TRUE)
[16:13:40.592]                         if (has_future) {
[16:13:40.592]                           ns <- base::getNamespace("future")
[16:13:40.592]                           version <- ns[[".package"]][["version"]]
[16:13:40.592]                           if (is.null(version)) 
[16:13:40.592]                             version <- utils::packageVersion("future")
[16:13:40.592]                         }
[16:13:40.592]                         else {
[16:13:40.592]                           version <- NULL
[16:13:40.592]                         }
[16:13:40.592]                         if (!has_future || version < "1.8.0") {
[16:13:40.592]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:40.592]                             "", base::R.version$version.string), 
[16:13:40.592]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:40.592]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:40.592]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:40.592]                               "release", "version")], collapse = " "), 
[16:13:40.592]                             hostname = base::Sys.info()[["nodename"]])
[16:13:40.592]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:40.592]                             info)
[16:13:40.592]                           info <- base::paste(info, collapse = "; ")
[16:13:40.592]                           if (!has_future) {
[16:13:40.592]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:40.592]                               info)
[16:13:40.592]                           }
[16:13:40.592]                           else {
[16:13:40.592]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:40.592]                               info, version)
[16:13:40.592]                           }
[16:13:40.592]                           base::stop(msg)
[16:13:40.592]                         }
[16:13:40.592]                       })
[16:13:40.592]                     }
[16:13:40.592]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:40.592]                     base::options(mc.cores = 1L)
[16:13:40.592]                   }
[16:13:40.592]                   options(future.plan = NULL)
[16:13:40.592]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:40.592]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:40.592]                 }
[16:13:40.592]                 ...future.workdir <- getwd()
[16:13:40.592]             }
[16:13:40.592]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:40.592]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:40.592]         }
[16:13:40.592]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:40.592]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:40.592]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:40.592]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:40.592]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:40.592]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:40.592]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:40.592]             base::names(...future.oldOptions))
[16:13:40.592]     }
[16:13:40.592]     if (FALSE) {
[16:13:40.592]     }
[16:13:40.592]     else {
[16:13:40.592]         if (TRUE) {
[16:13:40.592]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:40.592]                 open = "w")
[16:13:40.592]         }
[16:13:40.592]         else {
[16:13:40.592]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:40.592]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:40.592]         }
[16:13:40.592]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:40.592]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:40.592]             base::sink(type = "output", split = FALSE)
[16:13:40.592]             base::close(...future.stdout)
[16:13:40.592]         }, add = TRUE)
[16:13:40.592]     }
[16:13:40.592]     ...future.frame <- base::sys.nframe()
[16:13:40.592]     ...future.conditions <- base::list()
[16:13:40.592]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:40.592]     if (FALSE) {
[16:13:40.592]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:40.592]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:40.592]     }
[16:13:40.592]     ...future.result <- base::tryCatch({
[16:13:40.592]         base::withCallingHandlers({
[16:13:40.592]             ...future.value <- base::withVisible(base::local({
[16:13:40.592]                 withCallingHandlers({
[16:13:40.592]                   1
[16:13:40.592]                 }, immediateCondition = function(cond) {
[16:13:40.592]                   save_rds <- function (object, pathname, ...) 
[16:13:40.592]                   {
[16:13:40.592]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:40.592]                     if (file_test("-f", pathname_tmp)) {
[16:13:40.592]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.592]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:40.592]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.592]                         fi_tmp[["mtime"]])
[16:13:40.592]                     }
[16:13:40.592]                     tryCatch({
[16:13:40.592]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:40.592]                     }, error = function(ex) {
[16:13:40.592]                       msg <- conditionMessage(ex)
[16:13:40.592]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.592]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:40.592]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.592]                         fi_tmp[["mtime"]], msg)
[16:13:40.592]                       ex$message <- msg
[16:13:40.592]                       stop(ex)
[16:13:40.592]                     })
[16:13:40.592]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:40.592]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:40.592]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:40.592]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.592]                       fi <- file.info(pathname)
[16:13:40.592]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:40.592]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.592]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:40.592]                         fi[["size"]], fi[["mtime"]])
[16:13:40.592]                       stop(msg)
[16:13:40.592]                     }
[16:13:40.592]                     invisible(pathname)
[16:13:40.592]                   }
[16:13:40.592]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:40.592]                     rootPath = tempdir()) 
[16:13:40.592]                   {
[16:13:40.592]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:40.592]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:40.592]                       tmpdir = path, fileext = ".rds")
[16:13:40.592]                     save_rds(obj, file)
[16:13:40.592]                   }
[16:13:40.592]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:40.592]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.592]                   {
[16:13:40.592]                     inherits <- base::inherits
[16:13:40.592]                     invokeRestart <- base::invokeRestart
[16:13:40.592]                     is.null <- base::is.null
[16:13:40.592]                     muffled <- FALSE
[16:13:40.592]                     if (inherits(cond, "message")) {
[16:13:40.592]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:40.592]                       if (muffled) 
[16:13:40.592]                         invokeRestart("muffleMessage")
[16:13:40.592]                     }
[16:13:40.592]                     else if (inherits(cond, "warning")) {
[16:13:40.592]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:40.592]                       if (muffled) 
[16:13:40.592]                         invokeRestart("muffleWarning")
[16:13:40.592]                     }
[16:13:40.592]                     else if (inherits(cond, "condition")) {
[16:13:40.592]                       if (!is.null(pattern)) {
[16:13:40.592]                         computeRestarts <- base::computeRestarts
[16:13:40.592]                         grepl <- base::grepl
[16:13:40.592]                         restarts <- computeRestarts(cond)
[16:13:40.592]                         for (restart in restarts) {
[16:13:40.592]                           name <- restart$name
[16:13:40.592]                           if (is.null(name)) 
[16:13:40.592]                             next
[16:13:40.592]                           if (!grepl(pattern, name)) 
[16:13:40.592]                             next
[16:13:40.592]                           invokeRestart(restart)
[16:13:40.592]                           muffled <- TRUE
[16:13:40.592]                           break
[16:13:40.592]                         }
[16:13:40.592]                       }
[16:13:40.592]                     }
[16:13:40.592]                     invisible(muffled)
[16:13:40.592]                   }
[16:13:40.592]                   muffleCondition(cond)
[16:13:40.592]                 })
[16:13:40.592]             }))
[16:13:40.592]             future::FutureResult(value = ...future.value$value, 
[16:13:40.592]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:40.592]                   ...future.rng), globalenv = if (FALSE) 
[16:13:40.592]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:40.592]                     ...future.globalenv.names))
[16:13:40.592]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:40.592]         }, condition = base::local({
[16:13:40.592]             c <- base::c
[16:13:40.592]             inherits <- base::inherits
[16:13:40.592]             invokeRestart <- base::invokeRestart
[16:13:40.592]             length <- base::length
[16:13:40.592]             list <- base::list
[16:13:40.592]             seq.int <- base::seq.int
[16:13:40.592]             signalCondition <- base::signalCondition
[16:13:40.592]             sys.calls <- base::sys.calls
[16:13:40.592]             `[[` <- base::`[[`
[16:13:40.592]             `+` <- base::`+`
[16:13:40.592]             `<<-` <- base::`<<-`
[16:13:40.592]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:40.592]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:40.592]                   3L)]
[16:13:40.592]             }
[16:13:40.592]             function(cond) {
[16:13:40.592]                 is_error <- inherits(cond, "error")
[16:13:40.592]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:40.592]                   NULL)
[16:13:40.592]                 if (is_error) {
[16:13:40.592]                   sessionInformation <- function() {
[16:13:40.592]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:40.592]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:40.592]                       search = base::search(), system = base::Sys.info())
[16:13:40.592]                   }
[16:13:40.592]                   ...future.conditions[[length(...future.conditions) + 
[16:13:40.592]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:40.592]                     cond$call), session = sessionInformation(), 
[16:13:40.592]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:40.592]                   signalCondition(cond)
[16:13:40.592]                 }
[16:13:40.592]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:40.592]                 "immediateCondition"))) {
[16:13:40.592]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:40.592]                   ...future.conditions[[length(...future.conditions) + 
[16:13:40.592]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:40.592]                   if (TRUE && !signal) {
[16:13:40.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.592]                     {
[16:13:40.592]                       inherits <- base::inherits
[16:13:40.592]                       invokeRestart <- base::invokeRestart
[16:13:40.592]                       is.null <- base::is.null
[16:13:40.592]                       muffled <- FALSE
[16:13:40.592]                       if (inherits(cond, "message")) {
[16:13:40.592]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:40.592]                         if (muffled) 
[16:13:40.592]                           invokeRestart("muffleMessage")
[16:13:40.592]                       }
[16:13:40.592]                       else if (inherits(cond, "warning")) {
[16:13:40.592]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:40.592]                         if (muffled) 
[16:13:40.592]                           invokeRestart("muffleWarning")
[16:13:40.592]                       }
[16:13:40.592]                       else if (inherits(cond, "condition")) {
[16:13:40.592]                         if (!is.null(pattern)) {
[16:13:40.592]                           computeRestarts <- base::computeRestarts
[16:13:40.592]                           grepl <- base::grepl
[16:13:40.592]                           restarts <- computeRestarts(cond)
[16:13:40.592]                           for (restart in restarts) {
[16:13:40.592]                             name <- restart$name
[16:13:40.592]                             if (is.null(name)) 
[16:13:40.592]                               next
[16:13:40.592]                             if (!grepl(pattern, name)) 
[16:13:40.592]                               next
[16:13:40.592]                             invokeRestart(restart)
[16:13:40.592]                             muffled <- TRUE
[16:13:40.592]                             break
[16:13:40.592]                           }
[16:13:40.592]                         }
[16:13:40.592]                       }
[16:13:40.592]                       invisible(muffled)
[16:13:40.592]                     }
[16:13:40.592]                     muffleCondition(cond, pattern = "^muffle")
[16:13:40.592]                   }
[16:13:40.592]                 }
[16:13:40.592]                 else {
[16:13:40.592]                   if (TRUE) {
[16:13:40.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.592]                     {
[16:13:40.592]                       inherits <- base::inherits
[16:13:40.592]                       invokeRestart <- base::invokeRestart
[16:13:40.592]                       is.null <- base::is.null
[16:13:40.592]                       muffled <- FALSE
[16:13:40.592]                       if (inherits(cond, "message")) {
[16:13:40.592]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:40.592]                         if (muffled) 
[16:13:40.592]                           invokeRestart("muffleMessage")
[16:13:40.592]                       }
[16:13:40.592]                       else if (inherits(cond, "warning")) {
[16:13:40.592]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:40.592]                         if (muffled) 
[16:13:40.592]                           invokeRestart("muffleWarning")
[16:13:40.592]                       }
[16:13:40.592]                       else if (inherits(cond, "condition")) {
[16:13:40.592]                         if (!is.null(pattern)) {
[16:13:40.592]                           computeRestarts <- base::computeRestarts
[16:13:40.592]                           grepl <- base::grepl
[16:13:40.592]                           restarts <- computeRestarts(cond)
[16:13:40.592]                           for (restart in restarts) {
[16:13:40.592]                             name <- restart$name
[16:13:40.592]                             if (is.null(name)) 
[16:13:40.592]                               next
[16:13:40.592]                             if (!grepl(pattern, name)) 
[16:13:40.592]                               next
[16:13:40.592]                             invokeRestart(restart)
[16:13:40.592]                             muffled <- TRUE
[16:13:40.592]                             break
[16:13:40.592]                           }
[16:13:40.592]                         }
[16:13:40.592]                       }
[16:13:40.592]                       invisible(muffled)
[16:13:40.592]                     }
[16:13:40.592]                     muffleCondition(cond, pattern = "^muffle")
[16:13:40.592]                   }
[16:13:40.592]                 }
[16:13:40.592]             }
[16:13:40.592]         }))
[16:13:40.592]     }, error = function(ex) {
[16:13:40.592]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:40.592]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:40.592]                 ...future.rng), started = ...future.startTime, 
[16:13:40.592]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:40.592]             version = "1.8"), class = "FutureResult")
[16:13:40.592]     }, finally = {
[16:13:40.592]         if (!identical(...future.workdir, getwd())) 
[16:13:40.592]             setwd(...future.workdir)
[16:13:40.592]         {
[16:13:40.592]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:40.592]                 ...future.oldOptions$nwarnings <- NULL
[16:13:40.592]             }
[16:13:40.592]             base::options(...future.oldOptions)
[16:13:40.592]             if (.Platform$OS.type == "windows") {
[16:13:40.592]                 old_names <- names(...future.oldEnvVars)
[16:13:40.592]                 envs <- base::Sys.getenv()
[16:13:40.592]                 names <- names(envs)
[16:13:40.592]                 common <- intersect(names, old_names)
[16:13:40.592]                 added <- setdiff(names, old_names)
[16:13:40.592]                 removed <- setdiff(old_names, names)
[16:13:40.592]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:40.592]                   envs[common]]
[16:13:40.592]                 NAMES <- toupper(changed)
[16:13:40.592]                 args <- list()
[16:13:40.592]                 for (kk in seq_along(NAMES)) {
[16:13:40.592]                   name <- changed[[kk]]
[16:13:40.592]                   NAME <- NAMES[[kk]]
[16:13:40.592]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.592]                     next
[16:13:40.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:40.592]                 }
[16:13:40.592]                 NAMES <- toupper(added)
[16:13:40.592]                 for (kk in seq_along(NAMES)) {
[16:13:40.592]                   name <- added[[kk]]
[16:13:40.592]                   NAME <- NAMES[[kk]]
[16:13:40.592]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.592]                     next
[16:13:40.592]                   args[[name]] <- ""
[16:13:40.592]                 }
[16:13:40.592]                 NAMES <- toupper(removed)
[16:13:40.592]                 for (kk in seq_along(NAMES)) {
[16:13:40.592]                   name <- removed[[kk]]
[16:13:40.592]                   NAME <- NAMES[[kk]]
[16:13:40.592]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.592]                     next
[16:13:40.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:40.592]                 }
[16:13:40.592]                 if (length(args) > 0) 
[16:13:40.592]                   base::do.call(base::Sys.setenv, args = args)
[16:13:40.592]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:40.592]             }
[16:13:40.592]             else {
[16:13:40.592]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:40.592]             }
[16:13:40.592]             {
[16:13:40.592]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:40.592]                   0L) {
[16:13:40.592]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:40.592]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:40.592]                   base::options(opts)
[16:13:40.592]                 }
[16:13:40.592]                 {
[16:13:40.592]                   {
[16:13:40.592]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:40.592]                     NULL
[16:13:40.592]                   }
[16:13:40.592]                   options(future.plan = NULL)
[16:13:40.592]                   if (is.na(NA_character_)) 
[16:13:40.592]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:40.592]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:40.592]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:40.592]                     envir = parent.frame()) 
[16:13:40.592]                   {
[16:13:40.592]                     default_workers <- missing(workers)
[16:13:40.592]                     if (is.function(workers)) 
[16:13:40.592]                       workers <- workers()
[16:13:40.592]                     workers <- structure(as.integer(workers), 
[16:13:40.592]                       class = class(workers))
[16:13:40.592]                     stop_if_not(is.finite(workers), workers >= 
[16:13:40.592]                       1L)
[16:13:40.592]                     if ((workers == 1L && !inherits(workers, 
[16:13:40.592]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:40.592]                       if (default_workers) 
[16:13:40.592]                         supportsMulticore(warn = TRUE)
[16:13:40.592]                       return(sequential(..., envir = envir))
[16:13:40.592]                     }
[16:13:40.592]                     oopts <- options(mc.cores = workers)
[16:13:40.592]                     on.exit(options(oopts))
[16:13:40.592]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:40.592]                       envir = envir)
[16:13:40.592]                     if (!future$lazy) 
[16:13:40.592]                       future <- run(future)
[16:13:40.592]                     invisible(future)
[16:13:40.592]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:40.592]                 }
[16:13:40.592]             }
[16:13:40.592]         }
[16:13:40.592]     })
[16:13:40.592]     if (TRUE) {
[16:13:40.592]         base::sink(type = "output", split = FALSE)
[16:13:40.592]         if (TRUE) {
[16:13:40.592]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:40.592]         }
[16:13:40.592]         else {
[16:13:40.592]             ...future.result["stdout"] <- base::list(NULL)
[16:13:40.592]         }
[16:13:40.592]         base::close(...future.stdout)
[16:13:40.592]         ...future.stdout <- NULL
[16:13:40.592]     }
[16:13:40.592]     ...future.result$conditions <- ...future.conditions
[16:13:40.592]     ...future.result$finished <- base::Sys.time()
[16:13:40.592]     ...future.result
[16:13:40.592] }
[16:13:40.595] requestCore(): workers = 2
[16:13:40.598] MulticoreFuture started
[16:13:40.598] - Launch lazy future ... done
[16:13:40.598] run() for ‘MulticoreFuture’ ... done
[16:13:40.598] plan(): Setting new future strategy stack:
[16:13:40.599] getGlobalsAndPackages() ...
[16:13:40.599] Searching for globals...
[16:13:40.599] List of future strategies:
[16:13:40.599] 1. sequential:
[16:13:40.599]    - args: function (..., envir = parent.frame())
[16:13:40.599]    - tweaked: FALSE
[16:13:40.599]    - call: NULL
[16:13:40.600] plan(): nbrOfWorkers() = 1
[16:13:40.600] 
[16:13:40.600] Searching for globals ... DONE
[16:13:40.601] - globals: [0] <none>
[16:13:40.601] getGlobalsAndPackages() ... DONE
[16:13:40.601] run() for ‘Future’ ...
[16:13:40.601] - state: ‘created’
[16:13:40.602] plan(): Setting new future strategy stack:
[16:13:40.602] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:40.602] List of future strategies:
[16:13:40.602] 1. multicore:
[16:13:40.602]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:40.602]    - tweaked: FALSE
[16:13:40.602]    - call: plan(strategy)
[16:13:40.606] plan(): nbrOfWorkers() = 2
[16:13:40.606] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:40.607] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:40.607]   - Field: ‘label’
[16:13:40.607]   - Field: ‘local’
[16:13:40.607]   - Field: ‘owner’
[16:13:40.607]   - Field: ‘envir’
[16:13:40.607]   - Field: ‘workers’
[16:13:40.608]   - Field: ‘packages’
[16:13:40.608]   - Field: ‘gc’
[16:13:40.608]   - Field: ‘job’
[16:13:40.608]   - Field: ‘conditions’
[16:13:40.608]   - Field: ‘expr’
[16:13:40.608]   - Field: ‘uuid’
[16:13:40.608]   - Field: ‘seed’
[16:13:40.609]   - Field: ‘version’
[16:13:40.609]   - Field: ‘result’
[16:13:40.609]   - Field: ‘asynchronous’
[16:13:40.609]   - Field: ‘calls’
[16:13:40.609]   - Field: ‘globals’
[16:13:40.609]   - Field: ‘stdout’
[16:13:40.609]   - Field: ‘earlySignal’
[16:13:40.610]   - Field: ‘lazy’
[16:13:40.610]   - Field: ‘state’
[16:13:40.610] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:40.610] - Launch lazy future ...
[16:13:40.614] Packages needed by the future expression (n = 0): <none>
[16:13:40.614] Packages needed by future strategies (n = 0): <none>
[16:13:40.616] {
[16:13:40.616]     {
[16:13:40.616]         {
[16:13:40.616]             ...future.startTime <- base::Sys.time()
[16:13:40.616]             {
[16:13:40.616]                 {
[16:13:40.616]                   {
[16:13:40.616]                     {
[16:13:40.616]                       base::local({
[16:13:40.616]                         has_future <- base::requireNamespace("future", 
[16:13:40.616]                           quietly = TRUE)
[16:13:40.616]                         if (has_future) {
[16:13:40.616]                           ns <- base::getNamespace("future")
[16:13:40.616]                           version <- ns[[".package"]][["version"]]
[16:13:40.616]                           if (is.null(version)) 
[16:13:40.616]                             version <- utils::packageVersion("future")
[16:13:40.616]                         }
[16:13:40.616]                         else {
[16:13:40.616]                           version <- NULL
[16:13:40.616]                         }
[16:13:40.616]                         if (!has_future || version < "1.8.0") {
[16:13:40.616]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:40.616]                             "", base::R.version$version.string), 
[16:13:40.616]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:40.616]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:40.616]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:40.616]                               "release", "version")], collapse = " "), 
[16:13:40.616]                             hostname = base::Sys.info()[["nodename"]])
[16:13:40.616]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:40.616]                             info)
[16:13:40.616]                           info <- base::paste(info, collapse = "; ")
[16:13:40.616]                           if (!has_future) {
[16:13:40.616]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:40.616]                               info)
[16:13:40.616]                           }
[16:13:40.616]                           else {
[16:13:40.616]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:40.616]                               info, version)
[16:13:40.616]                           }
[16:13:40.616]                           base::stop(msg)
[16:13:40.616]                         }
[16:13:40.616]                       })
[16:13:40.616]                     }
[16:13:40.616]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:40.616]                     base::options(mc.cores = 1L)
[16:13:40.616]                   }
[16:13:40.616]                   options(future.plan = NULL)
[16:13:40.616]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:40.616]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:40.616]                 }
[16:13:40.616]                 ...future.workdir <- getwd()
[16:13:40.616]             }
[16:13:40.616]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:40.616]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:40.616]         }
[16:13:40.616]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:40.616]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:40.616]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:40.616]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:40.616]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:40.616]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:40.616]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:40.616]             base::names(...future.oldOptions))
[16:13:40.616]     }
[16:13:40.616]     if (FALSE) {
[16:13:40.616]     }
[16:13:40.616]     else {
[16:13:40.616]         if (TRUE) {
[16:13:40.616]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:40.616]                 open = "w")
[16:13:40.616]         }
[16:13:40.616]         else {
[16:13:40.616]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:40.616]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:40.616]         }
[16:13:40.616]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:40.616]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:40.616]             base::sink(type = "output", split = FALSE)
[16:13:40.616]             base::close(...future.stdout)
[16:13:40.616]         }, add = TRUE)
[16:13:40.616]     }
[16:13:40.616]     ...future.frame <- base::sys.nframe()
[16:13:40.616]     ...future.conditions <- base::list()
[16:13:40.616]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:40.616]     if (FALSE) {
[16:13:40.616]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:40.616]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:40.616]     }
[16:13:40.616]     ...future.result <- base::tryCatch({
[16:13:40.616]         base::withCallingHandlers({
[16:13:40.616]             ...future.value <- base::withVisible(base::local({
[16:13:40.616]                 withCallingHandlers({
[16:13:40.616]                   2
[16:13:40.616]                 }, immediateCondition = function(cond) {
[16:13:40.616]                   save_rds <- function (object, pathname, ...) 
[16:13:40.616]                   {
[16:13:40.616]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:40.616]                     if (file_test("-f", pathname_tmp)) {
[16:13:40.616]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.616]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:40.616]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.616]                         fi_tmp[["mtime"]])
[16:13:40.616]                     }
[16:13:40.616]                     tryCatch({
[16:13:40.616]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:40.616]                     }, error = function(ex) {
[16:13:40.616]                       msg <- conditionMessage(ex)
[16:13:40.616]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.616]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:40.616]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.616]                         fi_tmp[["mtime"]], msg)
[16:13:40.616]                       ex$message <- msg
[16:13:40.616]                       stop(ex)
[16:13:40.616]                     })
[16:13:40.616]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:40.616]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:40.616]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:40.616]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.616]                       fi <- file.info(pathname)
[16:13:40.616]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:40.616]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.616]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:40.616]                         fi[["size"]], fi[["mtime"]])
[16:13:40.616]                       stop(msg)
[16:13:40.616]                     }
[16:13:40.616]                     invisible(pathname)
[16:13:40.616]                   }
[16:13:40.616]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:40.616]                     rootPath = tempdir()) 
[16:13:40.616]                   {
[16:13:40.616]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:40.616]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:40.616]                       tmpdir = path, fileext = ".rds")
[16:13:40.616]                     save_rds(obj, file)
[16:13:40.616]                   }
[16:13:40.616]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:40.616]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.616]                   {
[16:13:40.616]                     inherits <- base::inherits
[16:13:40.616]                     invokeRestart <- base::invokeRestart
[16:13:40.616]                     is.null <- base::is.null
[16:13:40.616]                     muffled <- FALSE
[16:13:40.616]                     if (inherits(cond, "message")) {
[16:13:40.616]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:40.616]                       if (muffled) 
[16:13:40.616]                         invokeRestart("muffleMessage")
[16:13:40.616]                     }
[16:13:40.616]                     else if (inherits(cond, "warning")) {
[16:13:40.616]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:40.616]                       if (muffled) 
[16:13:40.616]                         invokeRestart("muffleWarning")
[16:13:40.616]                     }
[16:13:40.616]                     else if (inherits(cond, "condition")) {
[16:13:40.616]                       if (!is.null(pattern)) {
[16:13:40.616]                         computeRestarts <- base::computeRestarts
[16:13:40.616]                         grepl <- base::grepl
[16:13:40.616]                         restarts <- computeRestarts(cond)
[16:13:40.616]                         for (restart in restarts) {
[16:13:40.616]                           name <- restart$name
[16:13:40.616]                           if (is.null(name)) 
[16:13:40.616]                             next
[16:13:40.616]                           if (!grepl(pattern, name)) 
[16:13:40.616]                             next
[16:13:40.616]                           invokeRestart(restart)
[16:13:40.616]                           muffled <- TRUE
[16:13:40.616]                           break
[16:13:40.616]                         }
[16:13:40.616]                       }
[16:13:40.616]                     }
[16:13:40.616]                     invisible(muffled)
[16:13:40.616]                   }
[16:13:40.616]                   muffleCondition(cond)
[16:13:40.616]                 })
[16:13:40.616]             }))
[16:13:40.616]             future::FutureResult(value = ...future.value$value, 
[16:13:40.616]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:40.616]                   ...future.rng), globalenv = if (FALSE) 
[16:13:40.616]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:40.616]                     ...future.globalenv.names))
[16:13:40.616]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:40.616]         }, condition = base::local({
[16:13:40.616]             c <- base::c
[16:13:40.616]             inherits <- base::inherits
[16:13:40.616]             invokeRestart <- base::invokeRestart
[16:13:40.616]             length <- base::length
[16:13:40.616]             list <- base::list
[16:13:40.616]             seq.int <- base::seq.int
[16:13:40.616]             signalCondition <- base::signalCondition
[16:13:40.616]             sys.calls <- base::sys.calls
[16:13:40.616]             `[[` <- base::`[[`
[16:13:40.616]             `+` <- base::`+`
[16:13:40.616]             `<<-` <- base::`<<-`
[16:13:40.616]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:40.616]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:40.616]                   3L)]
[16:13:40.616]             }
[16:13:40.616]             function(cond) {
[16:13:40.616]                 is_error <- inherits(cond, "error")
[16:13:40.616]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:40.616]                   NULL)
[16:13:40.616]                 if (is_error) {
[16:13:40.616]                   sessionInformation <- function() {
[16:13:40.616]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:40.616]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:40.616]                       search = base::search(), system = base::Sys.info())
[16:13:40.616]                   }
[16:13:40.616]                   ...future.conditions[[length(...future.conditions) + 
[16:13:40.616]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:40.616]                     cond$call), session = sessionInformation(), 
[16:13:40.616]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:40.616]                   signalCondition(cond)
[16:13:40.616]                 }
[16:13:40.616]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:40.616]                 "immediateCondition"))) {
[16:13:40.616]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:40.616]                   ...future.conditions[[length(...future.conditions) + 
[16:13:40.616]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:40.616]                   if (TRUE && !signal) {
[16:13:40.616]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.616]                     {
[16:13:40.616]                       inherits <- base::inherits
[16:13:40.616]                       invokeRestart <- base::invokeRestart
[16:13:40.616]                       is.null <- base::is.null
[16:13:40.616]                       muffled <- FALSE
[16:13:40.616]                       if (inherits(cond, "message")) {
[16:13:40.616]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:40.616]                         if (muffled) 
[16:13:40.616]                           invokeRestart("muffleMessage")
[16:13:40.616]                       }
[16:13:40.616]                       else if (inherits(cond, "warning")) {
[16:13:40.616]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:40.616]                         if (muffled) 
[16:13:40.616]                           invokeRestart("muffleWarning")
[16:13:40.616]                       }
[16:13:40.616]                       else if (inherits(cond, "condition")) {
[16:13:40.616]                         if (!is.null(pattern)) {
[16:13:40.616]                           computeRestarts <- base::computeRestarts
[16:13:40.616]                           grepl <- base::grepl
[16:13:40.616]                           restarts <- computeRestarts(cond)
[16:13:40.616]                           for (restart in restarts) {
[16:13:40.616]                             name <- restart$name
[16:13:40.616]                             if (is.null(name)) 
[16:13:40.616]                               next
[16:13:40.616]                             if (!grepl(pattern, name)) 
[16:13:40.616]                               next
[16:13:40.616]                             invokeRestart(restart)
[16:13:40.616]                             muffled <- TRUE
[16:13:40.616]                             break
[16:13:40.616]                           }
[16:13:40.616]                         }
[16:13:40.616]                       }
[16:13:40.616]                       invisible(muffled)
[16:13:40.616]                     }
[16:13:40.616]                     muffleCondition(cond, pattern = "^muffle")
[16:13:40.616]                   }
[16:13:40.616]                 }
[16:13:40.616]                 else {
[16:13:40.616]                   if (TRUE) {
[16:13:40.616]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.616]                     {
[16:13:40.616]                       inherits <- base::inherits
[16:13:40.616]                       invokeRestart <- base::invokeRestart
[16:13:40.616]                       is.null <- base::is.null
[16:13:40.616]                       muffled <- FALSE
[16:13:40.616]                       if (inherits(cond, "message")) {
[16:13:40.616]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:40.616]                         if (muffled) 
[16:13:40.616]                           invokeRestart("muffleMessage")
[16:13:40.616]                       }
[16:13:40.616]                       else if (inherits(cond, "warning")) {
[16:13:40.616]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:40.616]                         if (muffled) 
[16:13:40.616]                           invokeRestart("muffleWarning")
[16:13:40.616]                       }
[16:13:40.616]                       else if (inherits(cond, "condition")) {
[16:13:40.616]                         if (!is.null(pattern)) {
[16:13:40.616]                           computeRestarts <- base::computeRestarts
[16:13:40.616]                           grepl <- base::grepl
[16:13:40.616]                           restarts <- computeRestarts(cond)
[16:13:40.616]                           for (restart in restarts) {
[16:13:40.616]                             name <- restart$name
[16:13:40.616]                             if (is.null(name)) 
[16:13:40.616]                               next
[16:13:40.616]                             if (!grepl(pattern, name)) 
[16:13:40.616]                               next
[16:13:40.616]                             invokeRestart(restart)
[16:13:40.616]                             muffled <- TRUE
[16:13:40.616]                             break
[16:13:40.616]                           }
[16:13:40.616]                         }
[16:13:40.616]                       }
[16:13:40.616]                       invisible(muffled)
[16:13:40.616]                     }
[16:13:40.616]                     muffleCondition(cond, pattern = "^muffle")
[16:13:40.616]                   }
[16:13:40.616]                 }
[16:13:40.616]             }
[16:13:40.616]         }))
[16:13:40.616]     }, error = function(ex) {
[16:13:40.616]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:40.616]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:40.616]                 ...future.rng), started = ...future.startTime, 
[16:13:40.616]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:40.616]             version = "1.8"), class = "FutureResult")
[16:13:40.616]     }, finally = {
[16:13:40.616]         if (!identical(...future.workdir, getwd())) 
[16:13:40.616]             setwd(...future.workdir)
[16:13:40.616]         {
[16:13:40.616]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:40.616]                 ...future.oldOptions$nwarnings <- NULL
[16:13:40.616]             }
[16:13:40.616]             base::options(...future.oldOptions)
[16:13:40.616]             if (.Platform$OS.type == "windows") {
[16:13:40.616]                 old_names <- names(...future.oldEnvVars)
[16:13:40.616]                 envs <- base::Sys.getenv()
[16:13:40.616]                 names <- names(envs)
[16:13:40.616]                 common <- intersect(names, old_names)
[16:13:40.616]                 added <- setdiff(names, old_names)
[16:13:40.616]                 removed <- setdiff(old_names, names)
[16:13:40.616]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:40.616]                   envs[common]]
[16:13:40.616]                 NAMES <- toupper(changed)
[16:13:40.616]                 args <- list()
[16:13:40.616]                 for (kk in seq_along(NAMES)) {
[16:13:40.616]                   name <- changed[[kk]]
[16:13:40.616]                   NAME <- NAMES[[kk]]
[16:13:40.616]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.616]                     next
[16:13:40.616]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:40.616]                 }
[16:13:40.616]                 NAMES <- toupper(added)
[16:13:40.616]                 for (kk in seq_along(NAMES)) {
[16:13:40.616]                   name <- added[[kk]]
[16:13:40.616]                   NAME <- NAMES[[kk]]
[16:13:40.616]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.616]                     next
[16:13:40.616]                   args[[name]] <- ""
[16:13:40.616]                 }
[16:13:40.616]                 NAMES <- toupper(removed)
[16:13:40.616]                 for (kk in seq_along(NAMES)) {
[16:13:40.616]                   name <- removed[[kk]]
[16:13:40.616]                   NAME <- NAMES[[kk]]
[16:13:40.616]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.616]                     next
[16:13:40.616]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:40.616]                 }
[16:13:40.616]                 if (length(args) > 0) 
[16:13:40.616]                   base::do.call(base::Sys.setenv, args = args)
[16:13:40.616]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:40.616]             }
[16:13:40.616]             else {
[16:13:40.616]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:40.616]             }
[16:13:40.616]             {
[16:13:40.616]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:40.616]                   0L) {
[16:13:40.616]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:40.616]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:40.616]                   base::options(opts)
[16:13:40.616]                 }
[16:13:40.616]                 {
[16:13:40.616]                   {
[16:13:40.616]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:40.616]                     NULL
[16:13:40.616]                   }
[16:13:40.616]                   options(future.plan = NULL)
[16:13:40.616]                   if (is.na(NA_character_)) 
[16:13:40.616]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:40.616]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:40.616]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:40.616]                     envir = parent.frame()) 
[16:13:40.616]                   {
[16:13:40.616]                     default_workers <- missing(workers)
[16:13:40.616]                     if (is.function(workers)) 
[16:13:40.616]                       workers <- workers()
[16:13:40.616]                     workers <- structure(as.integer(workers), 
[16:13:40.616]                       class = class(workers))
[16:13:40.616]                     stop_if_not(is.finite(workers), workers >= 
[16:13:40.616]                       1L)
[16:13:40.616]                     if ((workers == 1L && !inherits(workers, 
[16:13:40.616]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:40.616]                       if (default_workers) 
[16:13:40.616]                         supportsMulticore(warn = TRUE)
[16:13:40.616]                       return(sequential(..., envir = envir))
[16:13:40.616]                     }
[16:13:40.616]                     oopts <- options(mc.cores = workers)
[16:13:40.616]                     on.exit(options(oopts))
[16:13:40.616]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:40.616]                       envir = envir)
[16:13:40.616]                     if (!future$lazy) 
[16:13:40.616]                       future <- run(future)
[16:13:40.616]                     invisible(future)
[16:13:40.616]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:40.616]                 }
[16:13:40.616]             }
[16:13:40.616]         }
[16:13:40.616]     })
[16:13:40.616]     if (TRUE) {
[16:13:40.616]         base::sink(type = "output", split = FALSE)
[16:13:40.616]         if (TRUE) {
[16:13:40.616]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:40.616]         }
[16:13:40.616]         else {
[16:13:40.616]             ...future.result["stdout"] <- base::list(NULL)
[16:13:40.616]         }
[16:13:40.616]         base::close(...future.stdout)
[16:13:40.616]         ...future.stdout <- NULL
[16:13:40.616]     }
[16:13:40.616]     ...future.result$conditions <- ...future.conditions
[16:13:40.616]     ...future.result$finished <- base::Sys.time()
[16:13:40.616]     ...future.result
[16:13:40.616] }
[16:13:40.619] requestCore(): workers = 2
[16:13:40.626] MulticoreFuture started
[16:13:40.627] - Launch lazy future ... done
[16:13:40.627] run() for ‘MulticoreFuture’ ... done
[16:13:40.627] resolve() on list ...
[16:13:40.627] plan(): Setting new future strategy stack:
[16:13:40.627]  recursive: 0
[16:13:40.628]  length: 3
[16:13:40.628]  elements: ‘a’, ‘b’, ‘’
[16:13:40.628] List of future strategies:
[16:13:40.628] 1. sequential:
[16:13:40.628]    - args: function (..., envir = parent.frame())
[16:13:40.628]    - tweaked: FALSE
[16:13:40.628]    - call: NULL
[16:13:40.629] plan(): nbrOfWorkers() = 1
[16:13:40.630] Future #1
[16:13:40.631]  length: 2 (resolved future 1)
[16:13:40.631] plan(): Setting new future strategy stack:
[16:13:40.631] List of future strategies:
[16:13:40.631] 1. multicore:
[16:13:40.631]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:40.631]    - tweaked: FALSE
[16:13:40.631]    - call: plan(strategy)
[16:13:40.637] plan(): nbrOfWorkers() = 2
[16:13:40.637] Future #2
[16:13:40.638]  length: 1 (resolved future 2)
[16:13:40.638]  length: 0 (resolved future 3)
[16:13:40.638] resolve() on list ... DONE
[16:13:40.639] getGlobalsAndPackages() ...
[16:13:40.639] Searching for globals...
[16:13:40.640] 
[16:13:40.640] Searching for globals ... DONE
[16:13:40.640] - globals: [0] <none>
[16:13:40.640] getGlobalsAndPackages() ... DONE
[16:13:40.641] getGlobalsAndPackages() ...
[16:13:40.641] Searching for globals...
[16:13:40.641] 
[16:13:40.641] Searching for globals ... DONE
[16:13:40.642] - globals: [0] <none>
[16:13:40.642] getGlobalsAndPackages() ... DONE
[16:13:40.642] run() for ‘Future’ ...
[16:13:40.642] - state: ‘created’
[16:13:40.642] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:40.647] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:40.647] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:40.647]   - Field: ‘label’
[16:13:40.647]   - Field: ‘local’
[16:13:40.648]   - Field: ‘owner’
[16:13:40.648]   - Field: ‘envir’
[16:13:40.648]   - Field: ‘workers’
[16:13:40.648]   - Field: ‘packages’
[16:13:40.648]   - Field: ‘gc’
[16:13:40.648]   - Field: ‘job’
[16:13:40.649]   - Field: ‘conditions’
[16:13:40.649]   - Field: ‘expr’
[16:13:40.649]   - Field: ‘uuid’
[16:13:40.649]   - Field: ‘seed’
[16:13:40.649]   - Field: ‘version’
[16:13:40.649]   - Field: ‘result’
[16:13:40.649]   - Field: ‘asynchronous’
[16:13:40.650]   - Field: ‘calls’
[16:13:40.650]   - Field: ‘globals’
[16:13:40.650]   - Field: ‘stdout’
[16:13:40.650]   - Field: ‘earlySignal’
[16:13:40.650]   - Field: ‘lazy’
[16:13:40.650]   - Field: ‘state’
[16:13:40.650] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:40.651] - Launch lazy future ...
[16:13:40.651] Packages needed by the future expression (n = 0): <none>
[16:13:40.651] Packages needed by future strategies (n = 0): <none>
[16:13:40.652] {
[16:13:40.652]     {
[16:13:40.652]         {
[16:13:40.652]             ...future.startTime <- base::Sys.time()
[16:13:40.652]             {
[16:13:40.652]                 {
[16:13:40.652]                   {
[16:13:40.652]                     {
[16:13:40.652]                       base::local({
[16:13:40.652]                         has_future <- base::requireNamespace("future", 
[16:13:40.652]                           quietly = TRUE)
[16:13:40.652]                         if (has_future) {
[16:13:40.652]                           ns <- base::getNamespace("future")
[16:13:40.652]                           version <- ns[[".package"]][["version"]]
[16:13:40.652]                           if (is.null(version)) 
[16:13:40.652]                             version <- utils::packageVersion("future")
[16:13:40.652]                         }
[16:13:40.652]                         else {
[16:13:40.652]                           version <- NULL
[16:13:40.652]                         }
[16:13:40.652]                         if (!has_future || version < "1.8.0") {
[16:13:40.652]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:40.652]                             "", base::R.version$version.string), 
[16:13:40.652]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:40.652]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:40.652]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:40.652]                               "release", "version")], collapse = " "), 
[16:13:40.652]                             hostname = base::Sys.info()[["nodename"]])
[16:13:40.652]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:40.652]                             info)
[16:13:40.652]                           info <- base::paste(info, collapse = "; ")
[16:13:40.652]                           if (!has_future) {
[16:13:40.652]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:40.652]                               info)
[16:13:40.652]                           }
[16:13:40.652]                           else {
[16:13:40.652]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:40.652]                               info, version)
[16:13:40.652]                           }
[16:13:40.652]                           base::stop(msg)
[16:13:40.652]                         }
[16:13:40.652]                       })
[16:13:40.652]                     }
[16:13:40.652]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:40.652]                     base::options(mc.cores = 1L)
[16:13:40.652]                   }
[16:13:40.652]                   options(future.plan = NULL)
[16:13:40.652]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:40.652]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:40.652]                 }
[16:13:40.652]                 ...future.workdir <- getwd()
[16:13:40.652]             }
[16:13:40.652]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:40.652]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:40.652]         }
[16:13:40.652]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:40.652]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:40.652]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:40.652]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:40.652]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:40.652]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:40.652]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:40.652]             base::names(...future.oldOptions))
[16:13:40.652]     }
[16:13:40.652]     if (FALSE) {
[16:13:40.652]     }
[16:13:40.652]     else {
[16:13:40.652]         if (TRUE) {
[16:13:40.652]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:40.652]                 open = "w")
[16:13:40.652]         }
[16:13:40.652]         else {
[16:13:40.652]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:40.652]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:40.652]         }
[16:13:40.652]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:40.652]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:40.652]             base::sink(type = "output", split = FALSE)
[16:13:40.652]             base::close(...future.stdout)
[16:13:40.652]         }, add = TRUE)
[16:13:40.652]     }
[16:13:40.652]     ...future.frame <- base::sys.nframe()
[16:13:40.652]     ...future.conditions <- base::list()
[16:13:40.652]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:40.652]     if (FALSE) {
[16:13:40.652]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:40.652]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:40.652]     }
[16:13:40.652]     ...future.result <- base::tryCatch({
[16:13:40.652]         base::withCallingHandlers({
[16:13:40.652]             ...future.value <- base::withVisible(base::local({
[16:13:40.652]                 withCallingHandlers({
[16:13:40.652]                   2
[16:13:40.652]                 }, immediateCondition = function(cond) {
[16:13:40.652]                   save_rds <- function (object, pathname, ...) 
[16:13:40.652]                   {
[16:13:40.652]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:40.652]                     if (file_test("-f", pathname_tmp)) {
[16:13:40.652]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.652]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:40.652]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.652]                         fi_tmp[["mtime"]])
[16:13:40.652]                     }
[16:13:40.652]                     tryCatch({
[16:13:40.652]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:40.652]                     }, error = function(ex) {
[16:13:40.652]                       msg <- conditionMessage(ex)
[16:13:40.652]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.652]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:40.652]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.652]                         fi_tmp[["mtime"]], msg)
[16:13:40.652]                       ex$message <- msg
[16:13:40.652]                       stop(ex)
[16:13:40.652]                     })
[16:13:40.652]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:40.652]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:40.652]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:40.652]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.652]                       fi <- file.info(pathname)
[16:13:40.652]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:40.652]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.652]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:40.652]                         fi[["size"]], fi[["mtime"]])
[16:13:40.652]                       stop(msg)
[16:13:40.652]                     }
[16:13:40.652]                     invisible(pathname)
[16:13:40.652]                   }
[16:13:40.652]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:40.652]                     rootPath = tempdir()) 
[16:13:40.652]                   {
[16:13:40.652]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:40.652]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:40.652]                       tmpdir = path, fileext = ".rds")
[16:13:40.652]                     save_rds(obj, file)
[16:13:40.652]                   }
[16:13:40.652]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:40.652]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.652]                   {
[16:13:40.652]                     inherits <- base::inherits
[16:13:40.652]                     invokeRestart <- base::invokeRestart
[16:13:40.652]                     is.null <- base::is.null
[16:13:40.652]                     muffled <- FALSE
[16:13:40.652]                     if (inherits(cond, "message")) {
[16:13:40.652]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:40.652]                       if (muffled) 
[16:13:40.652]                         invokeRestart("muffleMessage")
[16:13:40.652]                     }
[16:13:40.652]                     else if (inherits(cond, "warning")) {
[16:13:40.652]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:40.652]                       if (muffled) 
[16:13:40.652]                         invokeRestart("muffleWarning")
[16:13:40.652]                     }
[16:13:40.652]                     else if (inherits(cond, "condition")) {
[16:13:40.652]                       if (!is.null(pattern)) {
[16:13:40.652]                         computeRestarts <- base::computeRestarts
[16:13:40.652]                         grepl <- base::grepl
[16:13:40.652]                         restarts <- computeRestarts(cond)
[16:13:40.652]                         for (restart in restarts) {
[16:13:40.652]                           name <- restart$name
[16:13:40.652]                           if (is.null(name)) 
[16:13:40.652]                             next
[16:13:40.652]                           if (!grepl(pattern, name)) 
[16:13:40.652]                             next
[16:13:40.652]                           invokeRestart(restart)
[16:13:40.652]                           muffled <- TRUE
[16:13:40.652]                           break
[16:13:40.652]                         }
[16:13:40.652]                       }
[16:13:40.652]                     }
[16:13:40.652]                     invisible(muffled)
[16:13:40.652]                   }
[16:13:40.652]                   muffleCondition(cond)
[16:13:40.652]                 })
[16:13:40.652]             }))
[16:13:40.652]             future::FutureResult(value = ...future.value$value, 
[16:13:40.652]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:40.652]                   ...future.rng), globalenv = if (FALSE) 
[16:13:40.652]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:40.652]                     ...future.globalenv.names))
[16:13:40.652]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:40.652]         }, condition = base::local({
[16:13:40.652]             c <- base::c
[16:13:40.652]             inherits <- base::inherits
[16:13:40.652]             invokeRestart <- base::invokeRestart
[16:13:40.652]             length <- base::length
[16:13:40.652]             list <- base::list
[16:13:40.652]             seq.int <- base::seq.int
[16:13:40.652]             signalCondition <- base::signalCondition
[16:13:40.652]             sys.calls <- base::sys.calls
[16:13:40.652]             `[[` <- base::`[[`
[16:13:40.652]             `+` <- base::`+`
[16:13:40.652]             `<<-` <- base::`<<-`
[16:13:40.652]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:40.652]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:40.652]                   3L)]
[16:13:40.652]             }
[16:13:40.652]             function(cond) {
[16:13:40.652]                 is_error <- inherits(cond, "error")
[16:13:40.652]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:40.652]                   NULL)
[16:13:40.652]                 if (is_error) {
[16:13:40.652]                   sessionInformation <- function() {
[16:13:40.652]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:40.652]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:40.652]                       search = base::search(), system = base::Sys.info())
[16:13:40.652]                   }
[16:13:40.652]                   ...future.conditions[[length(...future.conditions) + 
[16:13:40.652]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:40.652]                     cond$call), session = sessionInformation(), 
[16:13:40.652]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:40.652]                   signalCondition(cond)
[16:13:40.652]                 }
[16:13:40.652]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:40.652]                 "immediateCondition"))) {
[16:13:40.652]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:40.652]                   ...future.conditions[[length(...future.conditions) + 
[16:13:40.652]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:40.652]                   if (TRUE && !signal) {
[16:13:40.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.652]                     {
[16:13:40.652]                       inherits <- base::inherits
[16:13:40.652]                       invokeRestart <- base::invokeRestart
[16:13:40.652]                       is.null <- base::is.null
[16:13:40.652]                       muffled <- FALSE
[16:13:40.652]                       if (inherits(cond, "message")) {
[16:13:40.652]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:40.652]                         if (muffled) 
[16:13:40.652]                           invokeRestart("muffleMessage")
[16:13:40.652]                       }
[16:13:40.652]                       else if (inherits(cond, "warning")) {
[16:13:40.652]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:40.652]                         if (muffled) 
[16:13:40.652]                           invokeRestart("muffleWarning")
[16:13:40.652]                       }
[16:13:40.652]                       else if (inherits(cond, "condition")) {
[16:13:40.652]                         if (!is.null(pattern)) {
[16:13:40.652]                           computeRestarts <- base::computeRestarts
[16:13:40.652]                           grepl <- base::grepl
[16:13:40.652]                           restarts <- computeRestarts(cond)
[16:13:40.652]                           for (restart in restarts) {
[16:13:40.652]                             name <- restart$name
[16:13:40.652]                             if (is.null(name)) 
[16:13:40.652]                               next
[16:13:40.652]                             if (!grepl(pattern, name)) 
[16:13:40.652]                               next
[16:13:40.652]                             invokeRestart(restart)
[16:13:40.652]                             muffled <- TRUE
[16:13:40.652]                             break
[16:13:40.652]                           }
[16:13:40.652]                         }
[16:13:40.652]                       }
[16:13:40.652]                       invisible(muffled)
[16:13:40.652]                     }
[16:13:40.652]                     muffleCondition(cond, pattern = "^muffle")
[16:13:40.652]                   }
[16:13:40.652]                 }
[16:13:40.652]                 else {
[16:13:40.652]                   if (TRUE) {
[16:13:40.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.652]                     {
[16:13:40.652]                       inherits <- base::inherits
[16:13:40.652]                       invokeRestart <- base::invokeRestart
[16:13:40.652]                       is.null <- base::is.null
[16:13:40.652]                       muffled <- FALSE
[16:13:40.652]                       if (inherits(cond, "message")) {
[16:13:40.652]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:40.652]                         if (muffled) 
[16:13:40.652]                           invokeRestart("muffleMessage")
[16:13:40.652]                       }
[16:13:40.652]                       else if (inherits(cond, "warning")) {
[16:13:40.652]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:40.652]                         if (muffled) 
[16:13:40.652]                           invokeRestart("muffleWarning")
[16:13:40.652]                       }
[16:13:40.652]                       else if (inherits(cond, "condition")) {
[16:13:40.652]                         if (!is.null(pattern)) {
[16:13:40.652]                           computeRestarts <- base::computeRestarts
[16:13:40.652]                           grepl <- base::grepl
[16:13:40.652]                           restarts <- computeRestarts(cond)
[16:13:40.652]                           for (restart in restarts) {
[16:13:40.652]                             name <- restart$name
[16:13:40.652]                             if (is.null(name)) 
[16:13:40.652]                               next
[16:13:40.652]                             if (!grepl(pattern, name)) 
[16:13:40.652]                               next
[16:13:40.652]                             invokeRestart(restart)
[16:13:40.652]                             muffled <- TRUE
[16:13:40.652]                             break
[16:13:40.652]                           }
[16:13:40.652]                         }
[16:13:40.652]                       }
[16:13:40.652]                       invisible(muffled)
[16:13:40.652]                     }
[16:13:40.652]                     muffleCondition(cond, pattern = "^muffle")
[16:13:40.652]                   }
[16:13:40.652]                 }
[16:13:40.652]             }
[16:13:40.652]         }))
[16:13:40.652]     }, error = function(ex) {
[16:13:40.652]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:40.652]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:40.652]                 ...future.rng), started = ...future.startTime, 
[16:13:40.652]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:40.652]             version = "1.8"), class = "FutureResult")
[16:13:40.652]     }, finally = {
[16:13:40.652]         if (!identical(...future.workdir, getwd())) 
[16:13:40.652]             setwd(...future.workdir)
[16:13:40.652]         {
[16:13:40.652]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:40.652]                 ...future.oldOptions$nwarnings <- NULL
[16:13:40.652]             }
[16:13:40.652]             base::options(...future.oldOptions)
[16:13:40.652]             if (.Platform$OS.type == "windows") {
[16:13:40.652]                 old_names <- names(...future.oldEnvVars)
[16:13:40.652]                 envs <- base::Sys.getenv()
[16:13:40.652]                 names <- names(envs)
[16:13:40.652]                 common <- intersect(names, old_names)
[16:13:40.652]                 added <- setdiff(names, old_names)
[16:13:40.652]                 removed <- setdiff(old_names, names)
[16:13:40.652]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:40.652]                   envs[common]]
[16:13:40.652]                 NAMES <- toupper(changed)
[16:13:40.652]                 args <- list()
[16:13:40.652]                 for (kk in seq_along(NAMES)) {
[16:13:40.652]                   name <- changed[[kk]]
[16:13:40.652]                   NAME <- NAMES[[kk]]
[16:13:40.652]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.652]                     next
[16:13:40.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:40.652]                 }
[16:13:40.652]                 NAMES <- toupper(added)
[16:13:40.652]                 for (kk in seq_along(NAMES)) {
[16:13:40.652]                   name <- added[[kk]]
[16:13:40.652]                   NAME <- NAMES[[kk]]
[16:13:40.652]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.652]                     next
[16:13:40.652]                   args[[name]] <- ""
[16:13:40.652]                 }
[16:13:40.652]                 NAMES <- toupper(removed)
[16:13:40.652]                 for (kk in seq_along(NAMES)) {
[16:13:40.652]                   name <- removed[[kk]]
[16:13:40.652]                   NAME <- NAMES[[kk]]
[16:13:40.652]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.652]                     next
[16:13:40.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:40.652]                 }
[16:13:40.652]                 if (length(args) > 0) 
[16:13:40.652]                   base::do.call(base::Sys.setenv, args = args)
[16:13:40.652]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:40.652]             }
[16:13:40.652]             else {
[16:13:40.652]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:40.652]             }
[16:13:40.652]             {
[16:13:40.652]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:40.652]                   0L) {
[16:13:40.652]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:40.652]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:40.652]                   base::options(opts)
[16:13:40.652]                 }
[16:13:40.652]                 {
[16:13:40.652]                   {
[16:13:40.652]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:40.652]                     NULL
[16:13:40.652]                   }
[16:13:40.652]                   options(future.plan = NULL)
[16:13:40.652]                   if (is.na(NA_character_)) 
[16:13:40.652]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:40.652]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:40.652]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:40.652]                     envir = parent.frame()) 
[16:13:40.652]                   {
[16:13:40.652]                     default_workers <- missing(workers)
[16:13:40.652]                     if (is.function(workers)) 
[16:13:40.652]                       workers <- workers()
[16:13:40.652]                     workers <- structure(as.integer(workers), 
[16:13:40.652]                       class = class(workers))
[16:13:40.652]                     stop_if_not(is.finite(workers), workers >= 
[16:13:40.652]                       1L)
[16:13:40.652]                     if ((workers == 1L && !inherits(workers, 
[16:13:40.652]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:40.652]                       if (default_workers) 
[16:13:40.652]                         supportsMulticore(warn = TRUE)
[16:13:40.652]                       return(sequential(..., envir = envir))
[16:13:40.652]                     }
[16:13:40.652]                     oopts <- options(mc.cores = workers)
[16:13:40.652]                     on.exit(options(oopts))
[16:13:40.652]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:40.652]                       envir = envir)
[16:13:40.652]                     if (!future$lazy) 
[16:13:40.652]                       future <- run(future)
[16:13:40.652]                     invisible(future)
[16:13:40.652]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:40.652]                 }
[16:13:40.652]             }
[16:13:40.652]         }
[16:13:40.652]     })
[16:13:40.652]     if (TRUE) {
[16:13:40.652]         base::sink(type = "output", split = FALSE)
[16:13:40.652]         if (TRUE) {
[16:13:40.652]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:40.652]         }
[16:13:40.652]         else {
[16:13:40.652]             ...future.result["stdout"] <- base::list(NULL)
[16:13:40.652]         }
[16:13:40.652]         base::close(...future.stdout)
[16:13:40.652]         ...future.stdout <- NULL
[16:13:40.652]     }
[16:13:40.652]     ...future.result$conditions <- ...future.conditions
[16:13:40.652]     ...future.result$finished <- base::Sys.time()
[16:13:40.652]     ...future.result
[16:13:40.652] }
[16:13:40.655] requestCore(): workers = 2
[16:13:40.656] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:40.671] MulticoreFuture started
[16:13:40.672] - Launch lazy future ... done
[16:13:40.672] run() for ‘MulticoreFuture’ ... done
[16:13:40.673] resolve() on list ...
[16:13:40.673]  recursive: 0
[16:13:40.673] plan(): Setting new future strategy stack:
[16:13:40.673]  length: 3
[16:13:40.673]  elements: ‘a’, ‘b’, ‘’
[16:13:40.674] run() for ‘Future’ ...
[16:13:40.674] - state: ‘created’
[16:13:40.673] List of future strategies:
[16:13:40.673] 1. sequential:
[16:13:40.673]    - args: function (..., envir = parent.frame())
[16:13:40.673]    - tweaked: FALSE
[16:13:40.673]    - call: NULL
[16:13:40.674] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:40.674] plan(): nbrOfWorkers() = 1
[16:13:40.677] plan(): Setting new future strategy stack:
[16:13:40.677] List of future strategies:
[16:13:40.677] 1. multicore:
[16:13:40.677]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:40.677]    - tweaked: FALSE
[16:13:40.677]    - call: plan(strategy)
[16:13:40.681] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:40.681] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:40.681]   - Field: ‘label’
[16:13:40.681]   - Field: ‘local’
[16:13:40.681]   - Field: ‘owner’
[16:13:40.682]   - Field: ‘envir’
[16:13:40.682]   - Field: ‘workers’
[16:13:40.682]   - Field: ‘packages’
[16:13:40.682]   - Field: ‘gc’
[16:13:40.683]   - Field: ‘job’
[16:13:40.683] plan(): nbrOfWorkers() = 2
[16:13:40.683]   - Field: ‘conditions’
[16:13:40.683]   - Field: ‘expr’
[16:13:40.683]   - Field: ‘uuid’
[16:13:40.683]   - Field: ‘seed’
[16:13:40.684]   - Field: ‘version’
[16:13:40.684]   - Field: ‘result’
[16:13:40.684]   - Field: ‘asynchronous’
[16:13:40.684]   - Field: ‘calls’
[16:13:40.684]   - Field: ‘globals’
[16:13:40.685]   - Field: ‘stdout’
[16:13:40.685]   - Field: ‘earlySignal’
[16:13:40.685]   - Field: ‘lazy’
[16:13:40.685]   - Field: ‘state’
[16:13:40.685] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:40.685] - Launch lazy future ...
[16:13:40.686] Packages needed by the future expression (n = 0): <none>
[16:13:40.686] Packages needed by future strategies (n = 0): <none>
[16:13:40.687] {
[16:13:40.687]     {
[16:13:40.687]         {
[16:13:40.687]             ...future.startTime <- base::Sys.time()
[16:13:40.687]             {
[16:13:40.687]                 {
[16:13:40.687]                   {
[16:13:40.687]                     {
[16:13:40.687]                       base::local({
[16:13:40.687]                         has_future <- base::requireNamespace("future", 
[16:13:40.687]                           quietly = TRUE)
[16:13:40.687]                         if (has_future) {
[16:13:40.687]                           ns <- base::getNamespace("future")
[16:13:40.687]                           version <- ns[[".package"]][["version"]]
[16:13:40.687]                           if (is.null(version)) 
[16:13:40.687]                             version <- utils::packageVersion("future")
[16:13:40.687]                         }
[16:13:40.687]                         else {
[16:13:40.687]                           version <- NULL
[16:13:40.687]                         }
[16:13:40.687]                         if (!has_future || version < "1.8.0") {
[16:13:40.687]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:40.687]                             "", base::R.version$version.string), 
[16:13:40.687]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:40.687]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:40.687]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:40.687]                               "release", "version")], collapse = " "), 
[16:13:40.687]                             hostname = base::Sys.info()[["nodename"]])
[16:13:40.687]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:40.687]                             info)
[16:13:40.687]                           info <- base::paste(info, collapse = "; ")
[16:13:40.687]                           if (!has_future) {
[16:13:40.687]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:40.687]                               info)
[16:13:40.687]                           }
[16:13:40.687]                           else {
[16:13:40.687]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:40.687]                               info, version)
[16:13:40.687]                           }
[16:13:40.687]                           base::stop(msg)
[16:13:40.687]                         }
[16:13:40.687]                       })
[16:13:40.687]                     }
[16:13:40.687]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:40.687]                     base::options(mc.cores = 1L)
[16:13:40.687]                   }
[16:13:40.687]                   options(future.plan = NULL)
[16:13:40.687]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:40.687]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:40.687]                 }
[16:13:40.687]                 ...future.workdir <- getwd()
[16:13:40.687]             }
[16:13:40.687]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:40.687]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:40.687]         }
[16:13:40.687]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:40.687]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:40.687]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:40.687]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:40.687]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:40.687]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:40.687]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:40.687]             base::names(...future.oldOptions))
[16:13:40.687]     }
[16:13:40.687]     if (FALSE) {
[16:13:40.687]     }
[16:13:40.687]     else {
[16:13:40.687]         if (TRUE) {
[16:13:40.687]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:40.687]                 open = "w")
[16:13:40.687]         }
[16:13:40.687]         else {
[16:13:40.687]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:40.687]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:40.687]         }
[16:13:40.687]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:40.687]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:40.687]             base::sink(type = "output", split = FALSE)
[16:13:40.687]             base::close(...future.stdout)
[16:13:40.687]         }, add = TRUE)
[16:13:40.687]     }
[16:13:40.687]     ...future.frame <- base::sys.nframe()
[16:13:40.687]     ...future.conditions <- base::list()
[16:13:40.687]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:40.687]     if (FALSE) {
[16:13:40.687]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:40.687]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:40.687]     }
[16:13:40.687]     ...future.result <- base::tryCatch({
[16:13:40.687]         base::withCallingHandlers({
[16:13:40.687]             ...future.value <- base::withVisible(base::local({
[16:13:40.687]                 withCallingHandlers({
[16:13:40.687]                   1
[16:13:40.687]                 }, immediateCondition = function(cond) {
[16:13:40.687]                   save_rds <- function (object, pathname, ...) 
[16:13:40.687]                   {
[16:13:40.687]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:40.687]                     if (file_test("-f", pathname_tmp)) {
[16:13:40.687]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.687]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:40.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.687]                         fi_tmp[["mtime"]])
[16:13:40.687]                     }
[16:13:40.687]                     tryCatch({
[16:13:40.687]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:40.687]                     }, error = function(ex) {
[16:13:40.687]                       msg <- conditionMessage(ex)
[16:13:40.687]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.687]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:40.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.687]                         fi_tmp[["mtime"]], msg)
[16:13:40.687]                       ex$message <- msg
[16:13:40.687]                       stop(ex)
[16:13:40.687]                     })
[16:13:40.687]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:40.687]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:40.687]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:40.687]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.687]                       fi <- file.info(pathname)
[16:13:40.687]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:40.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.687]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:40.687]                         fi[["size"]], fi[["mtime"]])
[16:13:40.687]                       stop(msg)
[16:13:40.687]                     }
[16:13:40.687]                     invisible(pathname)
[16:13:40.687]                   }
[16:13:40.687]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:40.687]                     rootPath = tempdir()) 
[16:13:40.687]                   {
[16:13:40.687]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:40.687]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:40.687]                       tmpdir = path, fileext = ".rds")
[16:13:40.687]                     save_rds(obj, file)
[16:13:40.687]                   }
[16:13:40.687]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:40.687]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.687]                   {
[16:13:40.687]                     inherits <- base::inherits
[16:13:40.687]                     invokeRestart <- base::invokeRestart
[16:13:40.687]                     is.null <- base::is.null
[16:13:40.687]                     muffled <- FALSE
[16:13:40.687]                     if (inherits(cond, "message")) {
[16:13:40.687]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:40.687]                       if (muffled) 
[16:13:40.687]                         invokeRestart("muffleMessage")
[16:13:40.687]                     }
[16:13:40.687]                     else if (inherits(cond, "warning")) {
[16:13:40.687]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:40.687]                       if (muffled) 
[16:13:40.687]                         invokeRestart("muffleWarning")
[16:13:40.687]                     }
[16:13:40.687]                     else if (inherits(cond, "condition")) {
[16:13:40.687]                       if (!is.null(pattern)) {
[16:13:40.687]                         computeRestarts <- base::computeRestarts
[16:13:40.687]                         grepl <- base::grepl
[16:13:40.687]                         restarts <- computeRestarts(cond)
[16:13:40.687]                         for (restart in restarts) {
[16:13:40.687]                           name <- restart$name
[16:13:40.687]                           if (is.null(name)) 
[16:13:40.687]                             next
[16:13:40.687]                           if (!grepl(pattern, name)) 
[16:13:40.687]                             next
[16:13:40.687]                           invokeRestart(restart)
[16:13:40.687]                           muffled <- TRUE
[16:13:40.687]                           break
[16:13:40.687]                         }
[16:13:40.687]                       }
[16:13:40.687]                     }
[16:13:40.687]                     invisible(muffled)
[16:13:40.687]                   }
[16:13:40.687]                   muffleCondition(cond)
[16:13:40.687]                 })
[16:13:40.687]             }))
[16:13:40.687]             future::FutureResult(value = ...future.value$value, 
[16:13:40.687]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:40.687]                   ...future.rng), globalenv = if (FALSE) 
[16:13:40.687]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:40.687]                     ...future.globalenv.names))
[16:13:40.687]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:40.687]         }, condition = base::local({
[16:13:40.687]             c <- base::c
[16:13:40.687]             inherits <- base::inherits
[16:13:40.687]             invokeRestart <- base::invokeRestart
[16:13:40.687]             length <- base::length
[16:13:40.687]             list <- base::list
[16:13:40.687]             seq.int <- base::seq.int
[16:13:40.687]             signalCondition <- base::signalCondition
[16:13:40.687]             sys.calls <- base::sys.calls
[16:13:40.687]             `[[` <- base::`[[`
[16:13:40.687]             `+` <- base::`+`
[16:13:40.687]             `<<-` <- base::`<<-`
[16:13:40.687]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:40.687]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:40.687]                   3L)]
[16:13:40.687]             }
[16:13:40.687]             function(cond) {
[16:13:40.687]                 is_error <- inherits(cond, "error")
[16:13:40.687]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:40.687]                   NULL)
[16:13:40.687]                 if (is_error) {
[16:13:40.687]                   sessionInformation <- function() {
[16:13:40.687]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:40.687]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:40.687]                       search = base::search(), system = base::Sys.info())
[16:13:40.687]                   }
[16:13:40.687]                   ...future.conditions[[length(...future.conditions) + 
[16:13:40.687]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:40.687]                     cond$call), session = sessionInformation(), 
[16:13:40.687]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:40.687]                   signalCondition(cond)
[16:13:40.687]                 }
[16:13:40.687]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:40.687]                 "immediateCondition"))) {
[16:13:40.687]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:40.687]                   ...future.conditions[[length(...future.conditions) + 
[16:13:40.687]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:40.687]                   if (TRUE && !signal) {
[16:13:40.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.687]                     {
[16:13:40.687]                       inherits <- base::inherits
[16:13:40.687]                       invokeRestart <- base::invokeRestart
[16:13:40.687]                       is.null <- base::is.null
[16:13:40.687]                       muffled <- FALSE
[16:13:40.687]                       if (inherits(cond, "message")) {
[16:13:40.687]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:40.687]                         if (muffled) 
[16:13:40.687]                           invokeRestart("muffleMessage")
[16:13:40.687]                       }
[16:13:40.687]                       else if (inherits(cond, "warning")) {
[16:13:40.687]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:40.687]                         if (muffled) 
[16:13:40.687]                           invokeRestart("muffleWarning")
[16:13:40.687]                       }
[16:13:40.687]                       else if (inherits(cond, "condition")) {
[16:13:40.687]                         if (!is.null(pattern)) {
[16:13:40.687]                           computeRestarts <- base::computeRestarts
[16:13:40.687]                           grepl <- base::grepl
[16:13:40.687]                           restarts <- computeRestarts(cond)
[16:13:40.687]                           for (restart in restarts) {
[16:13:40.687]                             name <- restart$name
[16:13:40.687]                             if (is.null(name)) 
[16:13:40.687]                               next
[16:13:40.687]                             if (!grepl(pattern, name)) 
[16:13:40.687]                               next
[16:13:40.687]                             invokeRestart(restart)
[16:13:40.687]                             muffled <- TRUE
[16:13:40.687]                             break
[16:13:40.687]                           }
[16:13:40.687]                         }
[16:13:40.687]                       }
[16:13:40.687]                       invisible(muffled)
[16:13:40.687]                     }
[16:13:40.687]                     muffleCondition(cond, pattern = "^muffle")
[16:13:40.687]                   }
[16:13:40.687]                 }
[16:13:40.687]                 else {
[16:13:40.687]                   if (TRUE) {
[16:13:40.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.687]                     {
[16:13:40.687]                       inherits <- base::inherits
[16:13:40.687]                       invokeRestart <- base::invokeRestart
[16:13:40.687]                       is.null <- base::is.null
[16:13:40.687]                       muffled <- FALSE
[16:13:40.687]                       if (inherits(cond, "message")) {
[16:13:40.687]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:40.687]                         if (muffled) 
[16:13:40.687]                           invokeRestart("muffleMessage")
[16:13:40.687]                       }
[16:13:40.687]                       else if (inherits(cond, "warning")) {
[16:13:40.687]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:40.687]                         if (muffled) 
[16:13:40.687]                           invokeRestart("muffleWarning")
[16:13:40.687]                       }
[16:13:40.687]                       else if (inherits(cond, "condition")) {
[16:13:40.687]                         if (!is.null(pattern)) {
[16:13:40.687]                           computeRestarts <- base::computeRestarts
[16:13:40.687]                           grepl <- base::grepl
[16:13:40.687]                           restarts <- computeRestarts(cond)
[16:13:40.687]                           for (restart in restarts) {
[16:13:40.687]                             name <- restart$name
[16:13:40.687]                             if (is.null(name)) 
[16:13:40.687]                               next
[16:13:40.687]                             if (!grepl(pattern, name)) 
[16:13:40.687]                               next
[16:13:40.687]                             invokeRestart(restart)
[16:13:40.687]                             muffled <- TRUE
[16:13:40.687]                             break
[16:13:40.687]                           }
[16:13:40.687]                         }
[16:13:40.687]                       }
[16:13:40.687]                       invisible(muffled)
[16:13:40.687]                     }
[16:13:40.687]                     muffleCondition(cond, pattern = "^muffle")
[16:13:40.687]                   }
[16:13:40.687]                 }
[16:13:40.687]             }
[16:13:40.687]         }))
[16:13:40.687]     }, error = function(ex) {
[16:13:40.687]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:40.687]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:40.687]                 ...future.rng), started = ...future.startTime, 
[16:13:40.687]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:40.687]             version = "1.8"), class = "FutureResult")
[16:13:40.687]     }, finally = {
[16:13:40.687]         if (!identical(...future.workdir, getwd())) 
[16:13:40.687]             setwd(...future.workdir)
[16:13:40.687]         {
[16:13:40.687]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:40.687]                 ...future.oldOptions$nwarnings <- NULL
[16:13:40.687]             }
[16:13:40.687]             base::options(...future.oldOptions)
[16:13:40.687]             if (.Platform$OS.type == "windows") {
[16:13:40.687]                 old_names <- names(...future.oldEnvVars)
[16:13:40.687]                 envs <- base::Sys.getenv()
[16:13:40.687]                 names <- names(envs)
[16:13:40.687]                 common <- intersect(names, old_names)
[16:13:40.687]                 added <- setdiff(names, old_names)
[16:13:40.687]                 removed <- setdiff(old_names, names)
[16:13:40.687]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:40.687]                   envs[common]]
[16:13:40.687]                 NAMES <- toupper(changed)
[16:13:40.687]                 args <- list()
[16:13:40.687]                 for (kk in seq_along(NAMES)) {
[16:13:40.687]                   name <- changed[[kk]]
[16:13:40.687]                   NAME <- NAMES[[kk]]
[16:13:40.687]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.687]                     next
[16:13:40.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:40.687]                 }
[16:13:40.687]                 NAMES <- toupper(added)
[16:13:40.687]                 for (kk in seq_along(NAMES)) {
[16:13:40.687]                   name <- added[[kk]]
[16:13:40.687]                   NAME <- NAMES[[kk]]
[16:13:40.687]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.687]                     next
[16:13:40.687]                   args[[name]] <- ""
[16:13:40.687]                 }
[16:13:40.687]                 NAMES <- toupper(removed)
[16:13:40.687]                 for (kk in seq_along(NAMES)) {
[16:13:40.687]                   name <- removed[[kk]]
[16:13:40.687]                   NAME <- NAMES[[kk]]
[16:13:40.687]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.687]                     next
[16:13:40.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:40.687]                 }
[16:13:40.687]                 if (length(args) > 0) 
[16:13:40.687]                   base::do.call(base::Sys.setenv, args = args)
[16:13:40.687]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:40.687]             }
[16:13:40.687]             else {
[16:13:40.687]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:40.687]             }
[16:13:40.687]             {
[16:13:40.687]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:40.687]                   0L) {
[16:13:40.687]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:40.687]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:40.687]                   base::options(opts)
[16:13:40.687]                 }
[16:13:40.687]                 {
[16:13:40.687]                   {
[16:13:40.687]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:40.687]                     NULL
[16:13:40.687]                   }
[16:13:40.687]                   options(future.plan = NULL)
[16:13:40.687]                   if (is.na(NA_character_)) 
[16:13:40.687]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:40.687]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:40.687]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:40.687]                     envir = parent.frame()) 
[16:13:40.687]                   {
[16:13:40.687]                     default_workers <- missing(workers)
[16:13:40.687]                     if (is.function(workers)) 
[16:13:40.687]                       workers <- workers()
[16:13:40.687]                     workers <- structure(as.integer(workers), 
[16:13:40.687]                       class = class(workers))
[16:13:40.687]                     stop_if_not(is.finite(workers), workers >= 
[16:13:40.687]                       1L)
[16:13:40.687]                     if ((workers == 1L && !inherits(workers, 
[16:13:40.687]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:40.687]                       if (default_workers) 
[16:13:40.687]                         supportsMulticore(warn = TRUE)
[16:13:40.687]                       return(sequential(..., envir = envir))
[16:13:40.687]                     }
[16:13:40.687]                     oopts <- options(mc.cores = workers)
[16:13:40.687]                     on.exit(options(oopts))
[16:13:40.687]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:40.687]                       envir = envir)
[16:13:40.687]                     if (!future$lazy) 
[16:13:40.687]                       future <- run(future)
[16:13:40.687]                     invisible(future)
[16:13:40.687]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:40.687]                 }
[16:13:40.687]             }
[16:13:40.687]         }
[16:13:40.687]     })
[16:13:40.687]     if (TRUE) {
[16:13:40.687]         base::sink(type = "output", split = FALSE)
[16:13:40.687]         if (TRUE) {
[16:13:40.687]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:40.687]         }
[16:13:40.687]         else {
[16:13:40.687]             ...future.result["stdout"] <- base::list(NULL)
[16:13:40.687]         }
[16:13:40.687]         base::close(...future.stdout)
[16:13:40.687]         ...future.stdout <- NULL
[16:13:40.687]     }
[16:13:40.687]     ...future.result$conditions <- ...future.conditions
[16:13:40.687]     ...future.result$finished <- base::Sys.time()
[16:13:40.687]     ...future.result
[16:13:40.687] }
[16:13:40.690] requestCore(): workers = 2
[16:13:40.691] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:40.724] MulticoreFuture started
[16:13:40.725] - Launch lazy future ... done
[16:13:40.725] run() for ‘MulticoreFuture’ ... done
[16:13:40.725] plan(): Setting new future strategy stack:
[16:13:40.726] List of future strategies:
[16:13:40.726] 1. sequential:
[16:13:40.726]    - args: function (..., envir = parent.frame())
[16:13:40.726]    - tweaked: FALSE
[16:13:40.726]    - call: NULL
[16:13:40.727] plan(): nbrOfWorkers() = 1
[16:13:40.729] plan(): Setting new future strategy stack:
[16:13:40.729] List of future strategies:
[16:13:40.729] 1. multicore:
[16:13:40.729]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:40.729]    - tweaked: FALSE
[16:13:40.729]    - call: plan(strategy)
[16:13:40.734] plan(): nbrOfWorkers() = 2
[16:13:40.735] Future #1
[16:13:40.735]  length: 2 (resolved future 1)
[16:13:40.736] Future #2
[16:13:40.736]  length: 1 (resolved future 2)
[16:13:40.736]  length: 0 (resolved future 3)
[16:13:40.736] resolve() on list ... DONE
[16:13:40.737] getGlobalsAndPackages() ...
[16:13:40.737] Searching for globals...
[16:13:40.738] 
[16:13:40.738] Searching for globals ... DONE
[16:13:40.738] - globals: [0] <none>
[16:13:40.738] getGlobalsAndPackages() ... DONE
[16:13:40.738] getGlobalsAndPackages() ...
[16:13:40.739] Searching for globals...
[16:13:40.739] 
[16:13:40.739] Searching for globals ... DONE
[16:13:40.739] - globals: [0] <none>
[16:13:40.739] getGlobalsAndPackages() ... DONE
[16:13:40.740] resolve() on list ...
[16:13:40.740]  recursive: 0
[16:13:40.740]  length: 3
[16:13:40.740]  elements: ‘a’, ‘b’, ‘’
[16:13:40.741] run() for ‘Future’ ...
[16:13:40.741] - state: ‘created’
[16:13:40.741] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:40.745] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:40.746] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:40.746]   - Field: ‘label’
[16:13:40.746]   - Field: ‘local’
[16:13:40.746]   - Field: ‘owner’
[16:13:40.746]   - Field: ‘envir’
[16:13:40.746]   - Field: ‘workers’
[16:13:40.747]   - Field: ‘packages’
[16:13:40.747]   - Field: ‘gc’
[16:13:40.747]   - Field: ‘job’
[16:13:40.747]   - Field: ‘conditions’
[16:13:40.747]   - Field: ‘expr’
[16:13:40.747]   - Field: ‘uuid’
[16:13:40.747]   - Field: ‘seed’
[16:13:40.748]   - Field: ‘version’
[16:13:40.748]   - Field: ‘result’
[16:13:40.748]   - Field: ‘asynchronous’
[16:13:40.748]   - Field: ‘calls’
[16:13:40.748]   - Field: ‘globals’
[16:13:40.748]   - Field: ‘stdout’
[16:13:40.749]   - Field: ‘earlySignal’
[16:13:40.749]   - Field: ‘lazy’
[16:13:40.749]   - Field: ‘state’
[16:13:40.749] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:40.749] - Launch lazy future ...
[16:13:40.750] Packages needed by the future expression (n = 0): <none>
[16:13:40.750] Packages needed by future strategies (n = 0): <none>
[16:13:40.751] {
[16:13:40.751]     {
[16:13:40.751]         {
[16:13:40.751]             ...future.startTime <- base::Sys.time()
[16:13:40.751]             {
[16:13:40.751]                 {
[16:13:40.751]                   {
[16:13:40.751]                     {
[16:13:40.751]                       base::local({
[16:13:40.751]                         has_future <- base::requireNamespace("future", 
[16:13:40.751]                           quietly = TRUE)
[16:13:40.751]                         if (has_future) {
[16:13:40.751]                           ns <- base::getNamespace("future")
[16:13:40.751]                           version <- ns[[".package"]][["version"]]
[16:13:40.751]                           if (is.null(version)) 
[16:13:40.751]                             version <- utils::packageVersion("future")
[16:13:40.751]                         }
[16:13:40.751]                         else {
[16:13:40.751]                           version <- NULL
[16:13:40.751]                         }
[16:13:40.751]                         if (!has_future || version < "1.8.0") {
[16:13:40.751]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:40.751]                             "", base::R.version$version.string), 
[16:13:40.751]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:40.751]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:40.751]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:40.751]                               "release", "version")], collapse = " "), 
[16:13:40.751]                             hostname = base::Sys.info()[["nodename"]])
[16:13:40.751]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:40.751]                             info)
[16:13:40.751]                           info <- base::paste(info, collapse = "; ")
[16:13:40.751]                           if (!has_future) {
[16:13:40.751]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:40.751]                               info)
[16:13:40.751]                           }
[16:13:40.751]                           else {
[16:13:40.751]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:40.751]                               info, version)
[16:13:40.751]                           }
[16:13:40.751]                           base::stop(msg)
[16:13:40.751]                         }
[16:13:40.751]                       })
[16:13:40.751]                     }
[16:13:40.751]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:40.751]                     base::options(mc.cores = 1L)
[16:13:40.751]                   }
[16:13:40.751]                   options(future.plan = NULL)
[16:13:40.751]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:40.751]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:40.751]                 }
[16:13:40.751]                 ...future.workdir <- getwd()
[16:13:40.751]             }
[16:13:40.751]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:40.751]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:40.751]         }
[16:13:40.751]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:40.751]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:40.751]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:40.751]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:40.751]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:40.751]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:40.751]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:40.751]             base::names(...future.oldOptions))
[16:13:40.751]     }
[16:13:40.751]     if (FALSE) {
[16:13:40.751]     }
[16:13:40.751]     else {
[16:13:40.751]         if (TRUE) {
[16:13:40.751]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:40.751]                 open = "w")
[16:13:40.751]         }
[16:13:40.751]         else {
[16:13:40.751]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:40.751]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:40.751]         }
[16:13:40.751]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:40.751]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:40.751]             base::sink(type = "output", split = FALSE)
[16:13:40.751]             base::close(...future.stdout)
[16:13:40.751]         }, add = TRUE)
[16:13:40.751]     }
[16:13:40.751]     ...future.frame <- base::sys.nframe()
[16:13:40.751]     ...future.conditions <- base::list()
[16:13:40.751]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:40.751]     if (FALSE) {
[16:13:40.751]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:40.751]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:40.751]     }
[16:13:40.751]     ...future.result <- base::tryCatch({
[16:13:40.751]         base::withCallingHandlers({
[16:13:40.751]             ...future.value <- base::withVisible(base::local({
[16:13:40.751]                 withCallingHandlers({
[16:13:40.751]                   1
[16:13:40.751]                 }, immediateCondition = function(cond) {
[16:13:40.751]                   save_rds <- function (object, pathname, ...) 
[16:13:40.751]                   {
[16:13:40.751]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:40.751]                     if (file_test("-f", pathname_tmp)) {
[16:13:40.751]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.751]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:40.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.751]                         fi_tmp[["mtime"]])
[16:13:40.751]                     }
[16:13:40.751]                     tryCatch({
[16:13:40.751]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:40.751]                     }, error = function(ex) {
[16:13:40.751]                       msg <- conditionMessage(ex)
[16:13:40.751]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.751]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:40.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.751]                         fi_tmp[["mtime"]], msg)
[16:13:40.751]                       ex$message <- msg
[16:13:40.751]                       stop(ex)
[16:13:40.751]                     })
[16:13:40.751]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:40.751]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:40.751]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:40.751]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.751]                       fi <- file.info(pathname)
[16:13:40.751]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:40.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.751]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:40.751]                         fi[["size"]], fi[["mtime"]])
[16:13:40.751]                       stop(msg)
[16:13:40.751]                     }
[16:13:40.751]                     invisible(pathname)
[16:13:40.751]                   }
[16:13:40.751]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:40.751]                     rootPath = tempdir()) 
[16:13:40.751]                   {
[16:13:40.751]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:40.751]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:40.751]                       tmpdir = path, fileext = ".rds")
[16:13:40.751]                     save_rds(obj, file)
[16:13:40.751]                   }
[16:13:40.751]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:40.751]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.751]                   {
[16:13:40.751]                     inherits <- base::inherits
[16:13:40.751]                     invokeRestart <- base::invokeRestart
[16:13:40.751]                     is.null <- base::is.null
[16:13:40.751]                     muffled <- FALSE
[16:13:40.751]                     if (inherits(cond, "message")) {
[16:13:40.751]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:40.751]                       if (muffled) 
[16:13:40.751]                         invokeRestart("muffleMessage")
[16:13:40.751]                     }
[16:13:40.751]                     else if (inherits(cond, "warning")) {
[16:13:40.751]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:40.751]                       if (muffled) 
[16:13:40.751]                         invokeRestart("muffleWarning")
[16:13:40.751]                     }
[16:13:40.751]                     else if (inherits(cond, "condition")) {
[16:13:40.751]                       if (!is.null(pattern)) {
[16:13:40.751]                         computeRestarts <- base::computeRestarts
[16:13:40.751]                         grepl <- base::grepl
[16:13:40.751]                         restarts <- computeRestarts(cond)
[16:13:40.751]                         for (restart in restarts) {
[16:13:40.751]                           name <- restart$name
[16:13:40.751]                           if (is.null(name)) 
[16:13:40.751]                             next
[16:13:40.751]                           if (!grepl(pattern, name)) 
[16:13:40.751]                             next
[16:13:40.751]                           invokeRestart(restart)
[16:13:40.751]                           muffled <- TRUE
[16:13:40.751]                           break
[16:13:40.751]                         }
[16:13:40.751]                       }
[16:13:40.751]                     }
[16:13:40.751]                     invisible(muffled)
[16:13:40.751]                   }
[16:13:40.751]                   muffleCondition(cond)
[16:13:40.751]                 })
[16:13:40.751]             }))
[16:13:40.751]             future::FutureResult(value = ...future.value$value, 
[16:13:40.751]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:40.751]                   ...future.rng), globalenv = if (FALSE) 
[16:13:40.751]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:40.751]                     ...future.globalenv.names))
[16:13:40.751]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:40.751]         }, condition = base::local({
[16:13:40.751]             c <- base::c
[16:13:40.751]             inherits <- base::inherits
[16:13:40.751]             invokeRestart <- base::invokeRestart
[16:13:40.751]             length <- base::length
[16:13:40.751]             list <- base::list
[16:13:40.751]             seq.int <- base::seq.int
[16:13:40.751]             signalCondition <- base::signalCondition
[16:13:40.751]             sys.calls <- base::sys.calls
[16:13:40.751]             `[[` <- base::`[[`
[16:13:40.751]             `+` <- base::`+`
[16:13:40.751]             `<<-` <- base::`<<-`
[16:13:40.751]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:40.751]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:40.751]                   3L)]
[16:13:40.751]             }
[16:13:40.751]             function(cond) {
[16:13:40.751]                 is_error <- inherits(cond, "error")
[16:13:40.751]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:40.751]                   NULL)
[16:13:40.751]                 if (is_error) {
[16:13:40.751]                   sessionInformation <- function() {
[16:13:40.751]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:40.751]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:40.751]                       search = base::search(), system = base::Sys.info())
[16:13:40.751]                   }
[16:13:40.751]                   ...future.conditions[[length(...future.conditions) + 
[16:13:40.751]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:40.751]                     cond$call), session = sessionInformation(), 
[16:13:40.751]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:40.751]                   signalCondition(cond)
[16:13:40.751]                 }
[16:13:40.751]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:40.751]                 "immediateCondition"))) {
[16:13:40.751]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:40.751]                   ...future.conditions[[length(...future.conditions) + 
[16:13:40.751]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:40.751]                   if (TRUE && !signal) {
[16:13:40.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.751]                     {
[16:13:40.751]                       inherits <- base::inherits
[16:13:40.751]                       invokeRestart <- base::invokeRestart
[16:13:40.751]                       is.null <- base::is.null
[16:13:40.751]                       muffled <- FALSE
[16:13:40.751]                       if (inherits(cond, "message")) {
[16:13:40.751]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:40.751]                         if (muffled) 
[16:13:40.751]                           invokeRestart("muffleMessage")
[16:13:40.751]                       }
[16:13:40.751]                       else if (inherits(cond, "warning")) {
[16:13:40.751]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:40.751]                         if (muffled) 
[16:13:40.751]                           invokeRestart("muffleWarning")
[16:13:40.751]                       }
[16:13:40.751]                       else if (inherits(cond, "condition")) {
[16:13:40.751]                         if (!is.null(pattern)) {
[16:13:40.751]                           computeRestarts <- base::computeRestarts
[16:13:40.751]                           grepl <- base::grepl
[16:13:40.751]                           restarts <- computeRestarts(cond)
[16:13:40.751]                           for (restart in restarts) {
[16:13:40.751]                             name <- restart$name
[16:13:40.751]                             if (is.null(name)) 
[16:13:40.751]                               next
[16:13:40.751]                             if (!grepl(pattern, name)) 
[16:13:40.751]                               next
[16:13:40.751]                             invokeRestart(restart)
[16:13:40.751]                             muffled <- TRUE
[16:13:40.751]                             break
[16:13:40.751]                           }
[16:13:40.751]                         }
[16:13:40.751]                       }
[16:13:40.751]                       invisible(muffled)
[16:13:40.751]                     }
[16:13:40.751]                     muffleCondition(cond, pattern = "^muffle")
[16:13:40.751]                   }
[16:13:40.751]                 }
[16:13:40.751]                 else {
[16:13:40.751]                   if (TRUE) {
[16:13:40.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.751]                     {
[16:13:40.751]                       inherits <- base::inherits
[16:13:40.751]                       invokeRestart <- base::invokeRestart
[16:13:40.751]                       is.null <- base::is.null
[16:13:40.751]                       muffled <- FALSE
[16:13:40.751]                       if (inherits(cond, "message")) {
[16:13:40.751]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:40.751]                         if (muffled) 
[16:13:40.751]                           invokeRestart("muffleMessage")
[16:13:40.751]                       }
[16:13:40.751]                       else if (inherits(cond, "warning")) {
[16:13:40.751]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:40.751]                         if (muffled) 
[16:13:40.751]                           invokeRestart("muffleWarning")
[16:13:40.751]                       }
[16:13:40.751]                       else if (inherits(cond, "condition")) {
[16:13:40.751]                         if (!is.null(pattern)) {
[16:13:40.751]                           computeRestarts <- base::computeRestarts
[16:13:40.751]                           grepl <- base::grepl
[16:13:40.751]                           restarts <- computeRestarts(cond)
[16:13:40.751]                           for (restart in restarts) {
[16:13:40.751]                             name <- restart$name
[16:13:40.751]                             if (is.null(name)) 
[16:13:40.751]                               next
[16:13:40.751]                             if (!grepl(pattern, name)) 
[16:13:40.751]                               next
[16:13:40.751]                             invokeRestart(restart)
[16:13:40.751]                             muffled <- TRUE
[16:13:40.751]                             break
[16:13:40.751]                           }
[16:13:40.751]                         }
[16:13:40.751]                       }
[16:13:40.751]                       invisible(muffled)
[16:13:40.751]                     }
[16:13:40.751]                     muffleCondition(cond, pattern = "^muffle")
[16:13:40.751]                   }
[16:13:40.751]                 }
[16:13:40.751]             }
[16:13:40.751]         }))
[16:13:40.751]     }, error = function(ex) {
[16:13:40.751]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:40.751]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:40.751]                 ...future.rng), started = ...future.startTime, 
[16:13:40.751]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:40.751]             version = "1.8"), class = "FutureResult")
[16:13:40.751]     }, finally = {
[16:13:40.751]         if (!identical(...future.workdir, getwd())) 
[16:13:40.751]             setwd(...future.workdir)
[16:13:40.751]         {
[16:13:40.751]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:40.751]                 ...future.oldOptions$nwarnings <- NULL
[16:13:40.751]             }
[16:13:40.751]             base::options(...future.oldOptions)
[16:13:40.751]             if (.Platform$OS.type == "windows") {
[16:13:40.751]                 old_names <- names(...future.oldEnvVars)
[16:13:40.751]                 envs <- base::Sys.getenv()
[16:13:40.751]                 names <- names(envs)
[16:13:40.751]                 common <- intersect(names, old_names)
[16:13:40.751]                 added <- setdiff(names, old_names)
[16:13:40.751]                 removed <- setdiff(old_names, names)
[16:13:40.751]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:40.751]                   envs[common]]
[16:13:40.751]                 NAMES <- toupper(changed)
[16:13:40.751]                 args <- list()
[16:13:40.751]                 for (kk in seq_along(NAMES)) {
[16:13:40.751]                   name <- changed[[kk]]
[16:13:40.751]                   NAME <- NAMES[[kk]]
[16:13:40.751]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.751]                     next
[16:13:40.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:40.751]                 }
[16:13:40.751]                 NAMES <- toupper(added)
[16:13:40.751]                 for (kk in seq_along(NAMES)) {
[16:13:40.751]                   name <- added[[kk]]
[16:13:40.751]                   NAME <- NAMES[[kk]]
[16:13:40.751]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.751]                     next
[16:13:40.751]                   args[[name]] <- ""
[16:13:40.751]                 }
[16:13:40.751]                 NAMES <- toupper(removed)
[16:13:40.751]                 for (kk in seq_along(NAMES)) {
[16:13:40.751]                   name <- removed[[kk]]
[16:13:40.751]                   NAME <- NAMES[[kk]]
[16:13:40.751]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.751]                     next
[16:13:40.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:40.751]                 }
[16:13:40.751]                 if (length(args) > 0) 
[16:13:40.751]                   base::do.call(base::Sys.setenv, args = args)
[16:13:40.751]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:40.751]             }
[16:13:40.751]             else {
[16:13:40.751]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:40.751]             }
[16:13:40.751]             {
[16:13:40.751]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:40.751]                   0L) {
[16:13:40.751]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:40.751]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:40.751]                   base::options(opts)
[16:13:40.751]                 }
[16:13:40.751]                 {
[16:13:40.751]                   {
[16:13:40.751]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:40.751]                     NULL
[16:13:40.751]                   }
[16:13:40.751]                   options(future.plan = NULL)
[16:13:40.751]                   if (is.na(NA_character_)) 
[16:13:40.751]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:40.751]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:40.751]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:40.751]                     envir = parent.frame()) 
[16:13:40.751]                   {
[16:13:40.751]                     default_workers <- missing(workers)
[16:13:40.751]                     if (is.function(workers)) 
[16:13:40.751]                       workers <- workers()
[16:13:40.751]                     workers <- structure(as.integer(workers), 
[16:13:40.751]                       class = class(workers))
[16:13:40.751]                     stop_if_not(is.finite(workers), workers >= 
[16:13:40.751]                       1L)
[16:13:40.751]                     if ((workers == 1L && !inherits(workers, 
[16:13:40.751]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:40.751]                       if (default_workers) 
[16:13:40.751]                         supportsMulticore(warn = TRUE)
[16:13:40.751]                       return(sequential(..., envir = envir))
[16:13:40.751]                     }
[16:13:40.751]                     oopts <- options(mc.cores = workers)
[16:13:40.751]                     on.exit(options(oopts))
[16:13:40.751]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:40.751]                       envir = envir)
[16:13:40.751]                     if (!future$lazy) 
[16:13:40.751]                       future <- run(future)
[16:13:40.751]                     invisible(future)
[16:13:40.751]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:40.751]                 }
[16:13:40.751]             }
[16:13:40.751]         }
[16:13:40.751]     })
[16:13:40.751]     if (TRUE) {
[16:13:40.751]         base::sink(type = "output", split = FALSE)
[16:13:40.751]         if (TRUE) {
[16:13:40.751]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:40.751]         }
[16:13:40.751]         else {
[16:13:40.751]             ...future.result["stdout"] <- base::list(NULL)
[16:13:40.751]         }
[16:13:40.751]         base::close(...future.stdout)
[16:13:40.751]         ...future.stdout <- NULL
[16:13:40.751]     }
[16:13:40.751]     ...future.result$conditions <- ...future.conditions
[16:13:40.751]     ...future.result$finished <- base::Sys.time()
[16:13:40.751]     ...future.result
[16:13:40.751] }
[16:13:40.754] requestCore(): workers = 2
[16:13:40.755] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:40.769] MulticoreFuture started
[16:13:40.769] - Launch lazy future ... done
[16:13:40.770] run() for ‘MulticoreFuture’ ... done
[16:13:40.770] plan(): Setting new future strategy stack:
[16:13:40.770] List of future strategies:
[16:13:40.770] 1. sequential:
[16:13:40.770]    - args: function (..., envir = parent.frame())
[16:13:40.770]    - tweaked: FALSE
[16:13:40.770]    - call: NULL
[16:13:40.771] plan(): nbrOfWorkers() = 1
[16:13:40.773] plan(): Setting new future strategy stack:
[16:13:40.773] List of future strategies:
[16:13:40.773] 1. multicore:
[16:13:40.773]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:40.773]    - tweaked: FALSE
[16:13:40.773]    - call: plan(strategy)
[16:13:40.779] plan(): nbrOfWorkers() = 2
[16:13:40.779] Future #1
[16:13:40.779]  length: 2 (resolved future 1)
[16:13:40.780] run() for ‘Future’ ...
[16:13:40.780] - state: ‘created’
[16:13:40.780] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:40.785] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:40.785] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:40.785]   - Field: ‘label’
[16:13:40.785]   - Field: ‘local’
[16:13:40.785]   - Field: ‘owner’
[16:13:40.785]   - Field: ‘envir’
[16:13:40.786]   - Field: ‘workers’
[16:13:40.786]   - Field: ‘packages’
[16:13:40.786]   - Field: ‘gc’
[16:13:40.786]   - Field: ‘job’
[16:13:40.786]   - Field: ‘conditions’
[16:13:40.786]   - Field: ‘expr’
[16:13:40.787]   - Field: ‘uuid’
[16:13:40.787]   - Field: ‘seed’
[16:13:40.787]   - Field: ‘version’
[16:13:40.787]   - Field: ‘result’
[16:13:40.787]   - Field: ‘asynchronous’
[16:13:40.787]   - Field: ‘calls’
[16:13:40.788]   - Field: ‘globals’
[16:13:40.788]   - Field: ‘stdout’
[16:13:40.788]   - Field: ‘earlySignal’
[16:13:40.788]   - Field: ‘lazy’
[16:13:40.788]   - Field: ‘state’
[16:13:40.788] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:40.789] - Launch lazy future ...
[16:13:40.789] Packages needed by the future expression (n = 0): <none>
[16:13:40.789] Packages needed by future strategies (n = 0): <none>
[16:13:40.790] {
[16:13:40.790]     {
[16:13:40.790]         {
[16:13:40.790]             ...future.startTime <- base::Sys.time()
[16:13:40.790]             {
[16:13:40.790]                 {
[16:13:40.790]                   {
[16:13:40.790]                     {
[16:13:40.790]                       base::local({
[16:13:40.790]                         has_future <- base::requireNamespace("future", 
[16:13:40.790]                           quietly = TRUE)
[16:13:40.790]                         if (has_future) {
[16:13:40.790]                           ns <- base::getNamespace("future")
[16:13:40.790]                           version <- ns[[".package"]][["version"]]
[16:13:40.790]                           if (is.null(version)) 
[16:13:40.790]                             version <- utils::packageVersion("future")
[16:13:40.790]                         }
[16:13:40.790]                         else {
[16:13:40.790]                           version <- NULL
[16:13:40.790]                         }
[16:13:40.790]                         if (!has_future || version < "1.8.0") {
[16:13:40.790]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:40.790]                             "", base::R.version$version.string), 
[16:13:40.790]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:40.790]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:40.790]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:40.790]                               "release", "version")], collapse = " "), 
[16:13:40.790]                             hostname = base::Sys.info()[["nodename"]])
[16:13:40.790]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:40.790]                             info)
[16:13:40.790]                           info <- base::paste(info, collapse = "; ")
[16:13:40.790]                           if (!has_future) {
[16:13:40.790]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:40.790]                               info)
[16:13:40.790]                           }
[16:13:40.790]                           else {
[16:13:40.790]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:40.790]                               info, version)
[16:13:40.790]                           }
[16:13:40.790]                           base::stop(msg)
[16:13:40.790]                         }
[16:13:40.790]                       })
[16:13:40.790]                     }
[16:13:40.790]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:40.790]                     base::options(mc.cores = 1L)
[16:13:40.790]                   }
[16:13:40.790]                   options(future.plan = NULL)
[16:13:40.790]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:40.790]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:40.790]                 }
[16:13:40.790]                 ...future.workdir <- getwd()
[16:13:40.790]             }
[16:13:40.790]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:40.790]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:40.790]         }
[16:13:40.790]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:40.790]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:40.790]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:40.790]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:40.790]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:40.790]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:40.790]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:40.790]             base::names(...future.oldOptions))
[16:13:40.790]     }
[16:13:40.790]     if (FALSE) {
[16:13:40.790]     }
[16:13:40.790]     else {
[16:13:40.790]         if (TRUE) {
[16:13:40.790]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:40.790]                 open = "w")
[16:13:40.790]         }
[16:13:40.790]         else {
[16:13:40.790]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:40.790]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:40.790]         }
[16:13:40.790]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:40.790]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:40.790]             base::sink(type = "output", split = FALSE)
[16:13:40.790]             base::close(...future.stdout)
[16:13:40.790]         }, add = TRUE)
[16:13:40.790]     }
[16:13:40.790]     ...future.frame <- base::sys.nframe()
[16:13:40.790]     ...future.conditions <- base::list()
[16:13:40.790]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:40.790]     if (FALSE) {
[16:13:40.790]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:40.790]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:40.790]     }
[16:13:40.790]     ...future.result <- base::tryCatch({
[16:13:40.790]         base::withCallingHandlers({
[16:13:40.790]             ...future.value <- base::withVisible(base::local({
[16:13:40.790]                 withCallingHandlers({
[16:13:40.790]                   2
[16:13:40.790]                 }, immediateCondition = function(cond) {
[16:13:40.790]                   save_rds <- function (object, pathname, ...) 
[16:13:40.790]                   {
[16:13:40.790]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:40.790]                     if (file_test("-f", pathname_tmp)) {
[16:13:40.790]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.790]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:40.790]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.790]                         fi_tmp[["mtime"]])
[16:13:40.790]                     }
[16:13:40.790]                     tryCatch({
[16:13:40.790]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:40.790]                     }, error = function(ex) {
[16:13:40.790]                       msg <- conditionMessage(ex)
[16:13:40.790]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.790]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:40.790]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.790]                         fi_tmp[["mtime"]], msg)
[16:13:40.790]                       ex$message <- msg
[16:13:40.790]                       stop(ex)
[16:13:40.790]                     })
[16:13:40.790]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:40.790]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:40.790]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:40.790]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.790]                       fi <- file.info(pathname)
[16:13:40.790]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:40.790]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.790]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:40.790]                         fi[["size"]], fi[["mtime"]])
[16:13:40.790]                       stop(msg)
[16:13:40.790]                     }
[16:13:40.790]                     invisible(pathname)
[16:13:40.790]                   }
[16:13:40.790]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:40.790]                     rootPath = tempdir()) 
[16:13:40.790]                   {
[16:13:40.790]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:40.790]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:40.790]                       tmpdir = path, fileext = ".rds")
[16:13:40.790]                     save_rds(obj, file)
[16:13:40.790]                   }
[16:13:40.790]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:40.790]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.790]                   {
[16:13:40.790]                     inherits <- base::inherits
[16:13:40.790]                     invokeRestart <- base::invokeRestart
[16:13:40.790]                     is.null <- base::is.null
[16:13:40.790]                     muffled <- FALSE
[16:13:40.790]                     if (inherits(cond, "message")) {
[16:13:40.790]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:40.790]                       if (muffled) 
[16:13:40.790]                         invokeRestart("muffleMessage")
[16:13:40.790]                     }
[16:13:40.790]                     else if (inherits(cond, "warning")) {
[16:13:40.790]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:40.790]                       if (muffled) 
[16:13:40.790]                         invokeRestart("muffleWarning")
[16:13:40.790]                     }
[16:13:40.790]                     else if (inherits(cond, "condition")) {
[16:13:40.790]                       if (!is.null(pattern)) {
[16:13:40.790]                         computeRestarts <- base::computeRestarts
[16:13:40.790]                         grepl <- base::grepl
[16:13:40.790]                         restarts <- computeRestarts(cond)
[16:13:40.790]                         for (restart in restarts) {
[16:13:40.790]                           name <- restart$name
[16:13:40.790]                           if (is.null(name)) 
[16:13:40.790]                             next
[16:13:40.790]                           if (!grepl(pattern, name)) 
[16:13:40.790]                             next
[16:13:40.790]                           invokeRestart(restart)
[16:13:40.790]                           muffled <- TRUE
[16:13:40.790]                           break
[16:13:40.790]                         }
[16:13:40.790]                       }
[16:13:40.790]                     }
[16:13:40.790]                     invisible(muffled)
[16:13:40.790]                   }
[16:13:40.790]                   muffleCondition(cond)
[16:13:40.790]                 })
[16:13:40.790]             }))
[16:13:40.790]             future::FutureResult(value = ...future.value$value, 
[16:13:40.790]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:40.790]                   ...future.rng), globalenv = if (FALSE) 
[16:13:40.790]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:40.790]                     ...future.globalenv.names))
[16:13:40.790]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:40.790]         }, condition = base::local({
[16:13:40.790]             c <- base::c
[16:13:40.790]             inherits <- base::inherits
[16:13:40.790]             invokeRestart <- base::invokeRestart
[16:13:40.790]             length <- base::length
[16:13:40.790]             list <- base::list
[16:13:40.790]             seq.int <- base::seq.int
[16:13:40.790]             signalCondition <- base::signalCondition
[16:13:40.790]             sys.calls <- base::sys.calls
[16:13:40.790]             `[[` <- base::`[[`
[16:13:40.790]             `+` <- base::`+`
[16:13:40.790]             `<<-` <- base::`<<-`
[16:13:40.790]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:40.790]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:40.790]                   3L)]
[16:13:40.790]             }
[16:13:40.790]             function(cond) {
[16:13:40.790]                 is_error <- inherits(cond, "error")
[16:13:40.790]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:40.790]                   NULL)
[16:13:40.790]                 if (is_error) {
[16:13:40.790]                   sessionInformation <- function() {
[16:13:40.790]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:40.790]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:40.790]                       search = base::search(), system = base::Sys.info())
[16:13:40.790]                   }
[16:13:40.790]                   ...future.conditions[[length(...future.conditions) + 
[16:13:40.790]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:40.790]                     cond$call), session = sessionInformation(), 
[16:13:40.790]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:40.790]                   signalCondition(cond)
[16:13:40.790]                 }
[16:13:40.790]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:40.790]                 "immediateCondition"))) {
[16:13:40.790]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:40.790]                   ...future.conditions[[length(...future.conditions) + 
[16:13:40.790]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:40.790]                   if (TRUE && !signal) {
[16:13:40.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.790]                     {
[16:13:40.790]                       inherits <- base::inherits
[16:13:40.790]                       invokeRestart <- base::invokeRestart
[16:13:40.790]                       is.null <- base::is.null
[16:13:40.790]                       muffled <- FALSE
[16:13:40.790]                       if (inherits(cond, "message")) {
[16:13:40.790]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:40.790]                         if (muffled) 
[16:13:40.790]                           invokeRestart("muffleMessage")
[16:13:40.790]                       }
[16:13:40.790]                       else if (inherits(cond, "warning")) {
[16:13:40.790]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:40.790]                         if (muffled) 
[16:13:40.790]                           invokeRestart("muffleWarning")
[16:13:40.790]                       }
[16:13:40.790]                       else if (inherits(cond, "condition")) {
[16:13:40.790]                         if (!is.null(pattern)) {
[16:13:40.790]                           computeRestarts <- base::computeRestarts
[16:13:40.790]                           grepl <- base::grepl
[16:13:40.790]                           restarts <- computeRestarts(cond)
[16:13:40.790]                           for (restart in restarts) {
[16:13:40.790]                             name <- restart$name
[16:13:40.790]                             if (is.null(name)) 
[16:13:40.790]                               next
[16:13:40.790]                             if (!grepl(pattern, name)) 
[16:13:40.790]                               next
[16:13:40.790]                             invokeRestart(restart)
[16:13:40.790]                             muffled <- TRUE
[16:13:40.790]                             break
[16:13:40.790]                           }
[16:13:40.790]                         }
[16:13:40.790]                       }
[16:13:40.790]                       invisible(muffled)
[16:13:40.790]                     }
[16:13:40.790]                     muffleCondition(cond, pattern = "^muffle")
[16:13:40.790]                   }
[16:13:40.790]                 }
[16:13:40.790]                 else {
[16:13:40.790]                   if (TRUE) {
[16:13:40.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.790]                     {
[16:13:40.790]                       inherits <- base::inherits
[16:13:40.790]                       invokeRestart <- base::invokeRestart
[16:13:40.790]                       is.null <- base::is.null
[16:13:40.790]                       muffled <- FALSE
[16:13:40.790]                       if (inherits(cond, "message")) {
[16:13:40.790]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:40.790]                         if (muffled) 
[16:13:40.790]                           invokeRestart("muffleMessage")
[16:13:40.790]                       }
[16:13:40.790]                       else if (inherits(cond, "warning")) {
[16:13:40.790]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:40.790]                         if (muffled) 
[16:13:40.790]                           invokeRestart("muffleWarning")
[16:13:40.790]                       }
[16:13:40.790]                       else if (inherits(cond, "condition")) {
[16:13:40.790]                         if (!is.null(pattern)) {
[16:13:40.790]                           computeRestarts <- base::computeRestarts
[16:13:40.790]                           grepl <- base::grepl
[16:13:40.790]                           restarts <- computeRestarts(cond)
[16:13:40.790]                           for (restart in restarts) {
[16:13:40.790]                             name <- restart$name
[16:13:40.790]                             if (is.null(name)) 
[16:13:40.790]                               next
[16:13:40.790]                             if (!grepl(pattern, name)) 
[16:13:40.790]                               next
[16:13:40.790]                             invokeRestart(restart)
[16:13:40.790]                             muffled <- TRUE
[16:13:40.790]                             break
[16:13:40.790]                           }
[16:13:40.790]                         }
[16:13:40.790]                       }
[16:13:40.790]                       invisible(muffled)
[16:13:40.790]                     }
[16:13:40.790]                     muffleCondition(cond, pattern = "^muffle")
[16:13:40.790]                   }
[16:13:40.790]                 }
[16:13:40.790]             }
[16:13:40.790]         }))
[16:13:40.790]     }, error = function(ex) {
[16:13:40.790]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:40.790]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:40.790]                 ...future.rng), started = ...future.startTime, 
[16:13:40.790]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:40.790]             version = "1.8"), class = "FutureResult")
[16:13:40.790]     }, finally = {
[16:13:40.790]         if (!identical(...future.workdir, getwd())) 
[16:13:40.790]             setwd(...future.workdir)
[16:13:40.790]         {
[16:13:40.790]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:40.790]                 ...future.oldOptions$nwarnings <- NULL
[16:13:40.790]             }
[16:13:40.790]             base::options(...future.oldOptions)
[16:13:40.790]             if (.Platform$OS.type == "windows") {
[16:13:40.790]                 old_names <- names(...future.oldEnvVars)
[16:13:40.790]                 envs <- base::Sys.getenv()
[16:13:40.790]                 names <- names(envs)
[16:13:40.790]                 common <- intersect(names, old_names)
[16:13:40.790]                 added <- setdiff(names, old_names)
[16:13:40.790]                 removed <- setdiff(old_names, names)
[16:13:40.790]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:40.790]                   envs[common]]
[16:13:40.790]                 NAMES <- toupper(changed)
[16:13:40.790]                 args <- list()
[16:13:40.790]                 for (kk in seq_along(NAMES)) {
[16:13:40.790]                   name <- changed[[kk]]
[16:13:40.790]                   NAME <- NAMES[[kk]]
[16:13:40.790]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.790]                     next
[16:13:40.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:40.790]                 }
[16:13:40.790]                 NAMES <- toupper(added)
[16:13:40.790]                 for (kk in seq_along(NAMES)) {
[16:13:40.790]                   name <- added[[kk]]
[16:13:40.790]                   NAME <- NAMES[[kk]]
[16:13:40.790]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.790]                     next
[16:13:40.790]                   args[[name]] <- ""
[16:13:40.790]                 }
[16:13:40.790]                 NAMES <- toupper(removed)
[16:13:40.790]                 for (kk in seq_along(NAMES)) {
[16:13:40.790]                   name <- removed[[kk]]
[16:13:40.790]                   NAME <- NAMES[[kk]]
[16:13:40.790]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.790]                     next
[16:13:40.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:40.790]                 }
[16:13:40.790]                 if (length(args) > 0) 
[16:13:40.790]                   base::do.call(base::Sys.setenv, args = args)
[16:13:40.790]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:40.790]             }
[16:13:40.790]             else {
[16:13:40.790]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:40.790]             }
[16:13:40.790]             {
[16:13:40.790]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:40.790]                   0L) {
[16:13:40.790]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:40.790]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:40.790]                   base::options(opts)
[16:13:40.790]                 }
[16:13:40.790]                 {
[16:13:40.790]                   {
[16:13:40.790]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:40.790]                     NULL
[16:13:40.790]                   }
[16:13:40.790]                   options(future.plan = NULL)
[16:13:40.790]                   if (is.na(NA_character_)) 
[16:13:40.790]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:40.790]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:40.790]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:40.790]                     envir = parent.frame()) 
[16:13:40.790]                   {
[16:13:40.790]                     default_workers <- missing(workers)
[16:13:40.790]                     if (is.function(workers)) 
[16:13:40.790]                       workers <- workers()
[16:13:40.790]                     workers <- structure(as.integer(workers), 
[16:13:40.790]                       class = class(workers))
[16:13:40.790]                     stop_if_not(is.finite(workers), workers >= 
[16:13:40.790]                       1L)
[16:13:40.790]                     if ((workers == 1L && !inherits(workers, 
[16:13:40.790]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:40.790]                       if (default_workers) 
[16:13:40.790]                         supportsMulticore(warn = TRUE)
[16:13:40.790]                       return(sequential(..., envir = envir))
[16:13:40.790]                     }
[16:13:40.790]                     oopts <- options(mc.cores = workers)
[16:13:40.790]                     on.exit(options(oopts))
[16:13:40.790]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:40.790]                       envir = envir)
[16:13:40.790]                     if (!future$lazy) 
[16:13:40.790]                       future <- run(future)
[16:13:40.790]                     invisible(future)
[16:13:40.790]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:40.790]                 }
[16:13:40.790]             }
[16:13:40.790]         }
[16:13:40.790]     })
[16:13:40.790]     if (TRUE) {
[16:13:40.790]         base::sink(type = "output", split = FALSE)
[16:13:40.790]         if (TRUE) {
[16:13:40.790]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:40.790]         }
[16:13:40.790]         else {
[16:13:40.790]             ...future.result["stdout"] <- base::list(NULL)
[16:13:40.790]         }
[16:13:40.790]         base::close(...future.stdout)
[16:13:40.790]         ...future.stdout <- NULL
[16:13:40.790]     }
[16:13:40.790]     ...future.result$conditions <- ...future.conditions
[16:13:40.790]     ...future.result$finished <- base::Sys.time()
[16:13:40.790]     ...future.result
[16:13:40.790] }
[16:13:40.794] requestCore(): workers = 2
[16:13:40.794] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:40.808] MulticoreFuture started
[16:13:40.808] - Launch lazy future ... done
[16:13:40.808] run() for ‘MulticoreFuture’ ... done
[16:13:40.809] plan(): Setting new future strategy stack:
[16:13:40.809] List of future strategies:
[16:13:40.809] 1. sequential:
[16:13:40.809]    - args: function (..., envir = parent.frame())
[16:13:40.809]    - tweaked: FALSE
[16:13:40.809]    - call: NULL
[16:13:40.810] plan(): nbrOfWorkers() = 1
[16:13:40.818] plan(): Setting new future strategy stack:
[16:13:40.820]  length: 1 (resolved future 3)
[16:13:40.819] List of future strategies:
[16:13:40.819] 1. multicore:
[16:13:40.819]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:40.819]    - tweaked: FALSE
[16:13:40.819]    - call: plan(strategy)
[16:13:40.825] plan(): nbrOfWorkers() = 2
[16:13:40.830] Future #2
[16:13:40.834]  length: 0 (resolved future 2)
[16:13:40.834] resolve() on list ... DONE
[16:13:40.835] getGlobalsAndPackages() ...
[16:13:40.836] Searching for globals...
[16:13:40.837] 
[16:13:40.837] Searching for globals ... DONE
[16:13:40.837] - globals: [0] <none>
[16:13:40.838] getGlobalsAndPackages() ... DONE
[16:13:40.838] run() for ‘Future’ ...
[16:13:40.839] - state: ‘created’
[16:13:40.839] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:40.844] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:40.844] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:40.844]   - Field: ‘label’
[16:13:40.844]   - Field: ‘local’
[16:13:40.844]   - Field: ‘owner’
[16:13:40.845]   - Field: ‘envir’
[16:13:40.845]   - Field: ‘workers’
[16:13:40.845]   - Field: ‘packages’
[16:13:40.845]   - Field: ‘gc’
[16:13:40.845]   - Field: ‘job’
[16:13:40.845]   - Field: ‘conditions’
[16:13:40.845]   - Field: ‘expr’
[16:13:40.846]   - Field: ‘uuid’
[16:13:40.846]   - Field: ‘seed’
[16:13:40.846]   - Field: ‘version’
[16:13:40.846]   - Field: ‘result’
[16:13:40.846]   - Field: ‘asynchronous’
[16:13:40.846]   - Field: ‘calls’
[16:13:40.847]   - Field: ‘globals’
[16:13:40.847]   - Field: ‘stdout’
[16:13:40.847]   - Field: ‘earlySignal’
[16:13:40.847]   - Field: ‘lazy’
[16:13:40.848]   - Field: ‘state’
[16:13:40.848] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:40.848] - Launch lazy future ...
[16:13:40.848] Packages needed by the future expression (n = 0): <none>
[16:13:40.848] Packages needed by future strategies (n = 0): <none>
[16:13:40.849] {
[16:13:40.849]     {
[16:13:40.849]         {
[16:13:40.849]             ...future.startTime <- base::Sys.time()
[16:13:40.849]             {
[16:13:40.849]                 {
[16:13:40.849]                   {
[16:13:40.849]                     {
[16:13:40.849]                       base::local({
[16:13:40.849]                         has_future <- base::requireNamespace("future", 
[16:13:40.849]                           quietly = TRUE)
[16:13:40.849]                         if (has_future) {
[16:13:40.849]                           ns <- base::getNamespace("future")
[16:13:40.849]                           version <- ns[[".package"]][["version"]]
[16:13:40.849]                           if (is.null(version)) 
[16:13:40.849]                             version <- utils::packageVersion("future")
[16:13:40.849]                         }
[16:13:40.849]                         else {
[16:13:40.849]                           version <- NULL
[16:13:40.849]                         }
[16:13:40.849]                         if (!has_future || version < "1.8.0") {
[16:13:40.849]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:40.849]                             "", base::R.version$version.string), 
[16:13:40.849]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:40.849]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:40.849]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:40.849]                               "release", "version")], collapse = " "), 
[16:13:40.849]                             hostname = base::Sys.info()[["nodename"]])
[16:13:40.849]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:40.849]                             info)
[16:13:40.849]                           info <- base::paste(info, collapse = "; ")
[16:13:40.849]                           if (!has_future) {
[16:13:40.849]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:40.849]                               info)
[16:13:40.849]                           }
[16:13:40.849]                           else {
[16:13:40.849]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:40.849]                               info, version)
[16:13:40.849]                           }
[16:13:40.849]                           base::stop(msg)
[16:13:40.849]                         }
[16:13:40.849]                       })
[16:13:40.849]                     }
[16:13:40.849]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:40.849]                     base::options(mc.cores = 1L)
[16:13:40.849]                   }
[16:13:40.849]                   options(future.plan = NULL)
[16:13:40.849]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:40.849]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:40.849]                 }
[16:13:40.849]                 ...future.workdir <- getwd()
[16:13:40.849]             }
[16:13:40.849]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:40.849]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:40.849]         }
[16:13:40.849]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:40.849]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:40.849]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:40.849]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:40.849]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:40.849]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:40.849]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:40.849]             base::names(...future.oldOptions))
[16:13:40.849]     }
[16:13:40.849]     if (FALSE) {
[16:13:40.849]     }
[16:13:40.849]     else {
[16:13:40.849]         if (TRUE) {
[16:13:40.849]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:40.849]                 open = "w")
[16:13:40.849]         }
[16:13:40.849]         else {
[16:13:40.849]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:40.849]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:40.849]         }
[16:13:40.849]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:40.849]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:40.849]             base::sink(type = "output", split = FALSE)
[16:13:40.849]             base::close(...future.stdout)
[16:13:40.849]         }, add = TRUE)
[16:13:40.849]     }
[16:13:40.849]     ...future.frame <- base::sys.nframe()
[16:13:40.849]     ...future.conditions <- base::list()
[16:13:40.849]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:40.849]     if (FALSE) {
[16:13:40.849]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:40.849]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:40.849]     }
[16:13:40.849]     ...future.result <- base::tryCatch({
[16:13:40.849]         base::withCallingHandlers({
[16:13:40.849]             ...future.value <- base::withVisible(base::local({
[16:13:40.849]                 withCallingHandlers({
[16:13:40.849]                   1
[16:13:40.849]                 }, immediateCondition = function(cond) {
[16:13:40.849]                   save_rds <- function (object, pathname, ...) 
[16:13:40.849]                   {
[16:13:40.849]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:40.849]                     if (file_test("-f", pathname_tmp)) {
[16:13:40.849]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.849]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:40.849]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.849]                         fi_tmp[["mtime"]])
[16:13:40.849]                     }
[16:13:40.849]                     tryCatch({
[16:13:40.849]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:40.849]                     }, error = function(ex) {
[16:13:40.849]                       msg <- conditionMessage(ex)
[16:13:40.849]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.849]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:40.849]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.849]                         fi_tmp[["mtime"]], msg)
[16:13:40.849]                       ex$message <- msg
[16:13:40.849]                       stop(ex)
[16:13:40.849]                     })
[16:13:40.849]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:40.849]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:40.849]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:40.849]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.849]                       fi <- file.info(pathname)
[16:13:40.849]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:40.849]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.849]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:40.849]                         fi[["size"]], fi[["mtime"]])
[16:13:40.849]                       stop(msg)
[16:13:40.849]                     }
[16:13:40.849]                     invisible(pathname)
[16:13:40.849]                   }
[16:13:40.849]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:40.849]                     rootPath = tempdir()) 
[16:13:40.849]                   {
[16:13:40.849]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:40.849]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:40.849]                       tmpdir = path, fileext = ".rds")
[16:13:40.849]                     save_rds(obj, file)
[16:13:40.849]                   }
[16:13:40.849]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:40.849]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.849]                   {
[16:13:40.849]                     inherits <- base::inherits
[16:13:40.849]                     invokeRestart <- base::invokeRestart
[16:13:40.849]                     is.null <- base::is.null
[16:13:40.849]                     muffled <- FALSE
[16:13:40.849]                     if (inherits(cond, "message")) {
[16:13:40.849]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:40.849]                       if (muffled) 
[16:13:40.849]                         invokeRestart("muffleMessage")
[16:13:40.849]                     }
[16:13:40.849]                     else if (inherits(cond, "warning")) {
[16:13:40.849]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:40.849]                       if (muffled) 
[16:13:40.849]                         invokeRestart("muffleWarning")
[16:13:40.849]                     }
[16:13:40.849]                     else if (inherits(cond, "condition")) {
[16:13:40.849]                       if (!is.null(pattern)) {
[16:13:40.849]                         computeRestarts <- base::computeRestarts
[16:13:40.849]                         grepl <- base::grepl
[16:13:40.849]                         restarts <- computeRestarts(cond)
[16:13:40.849]                         for (restart in restarts) {
[16:13:40.849]                           name <- restart$name
[16:13:40.849]                           if (is.null(name)) 
[16:13:40.849]                             next
[16:13:40.849]                           if (!grepl(pattern, name)) 
[16:13:40.849]                             next
[16:13:40.849]                           invokeRestart(restart)
[16:13:40.849]                           muffled <- TRUE
[16:13:40.849]                           break
[16:13:40.849]                         }
[16:13:40.849]                       }
[16:13:40.849]                     }
[16:13:40.849]                     invisible(muffled)
[16:13:40.849]                   }
[16:13:40.849]                   muffleCondition(cond)
[16:13:40.849]                 })
[16:13:40.849]             }))
[16:13:40.849]             future::FutureResult(value = ...future.value$value, 
[16:13:40.849]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:40.849]                   ...future.rng), globalenv = if (FALSE) 
[16:13:40.849]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:40.849]                     ...future.globalenv.names))
[16:13:40.849]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:40.849]         }, condition = base::local({
[16:13:40.849]             c <- base::c
[16:13:40.849]             inherits <- base::inherits
[16:13:40.849]             invokeRestart <- base::invokeRestart
[16:13:40.849]             length <- base::length
[16:13:40.849]             list <- base::list
[16:13:40.849]             seq.int <- base::seq.int
[16:13:40.849]             signalCondition <- base::signalCondition
[16:13:40.849]             sys.calls <- base::sys.calls
[16:13:40.849]             `[[` <- base::`[[`
[16:13:40.849]             `+` <- base::`+`
[16:13:40.849]             `<<-` <- base::`<<-`
[16:13:40.849]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:40.849]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:40.849]                   3L)]
[16:13:40.849]             }
[16:13:40.849]             function(cond) {
[16:13:40.849]                 is_error <- inherits(cond, "error")
[16:13:40.849]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:40.849]                   NULL)
[16:13:40.849]                 if (is_error) {
[16:13:40.849]                   sessionInformation <- function() {
[16:13:40.849]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:40.849]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:40.849]                       search = base::search(), system = base::Sys.info())
[16:13:40.849]                   }
[16:13:40.849]                   ...future.conditions[[length(...future.conditions) + 
[16:13:40.849]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:40.849]                     cond$call), session = sessionInformation(), 
[16:13:40.849]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:40.849]                   signalCondition(cond)
[16:13:40.849]                 }
[16:13:40.849]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:40.849]                 "immediateCondition"))) {
[16:13:40.849]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:40.849]                   ...future.conditions[[length(...future.conditions) + 
[16:13:40.849]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:40.849]                   if (TRUE && !signal) {
[16:13:40.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.849]                     {
[16:13:40.849]                       inherits <- base::inherits
[16:13:40.849]                       invokeRestart <- base::invokeRestart
[16:13:40.849]                       is.null <- base::is.null
[16:13:40.849]                       muffled <- FALSE
[16:13:40.849]                       if (inherits(cond, "message")) {
[16:13:40.849]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:40.849]                         if (muffled) 
[16:13:40.849]                           invokeRestart("muffleMessage")
[16:13:40.849]                       }
[16:13:40.849]                       else if (inherits(cond, "warning")) {
[16:13:40.849]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:40.849]                         if (muffled) 
[16:13:40.849]                           invokeRestart("muffleWarning")
[16:13:40.849]                       }
[16:13:40.849]                       else if (inherits(cond, "condition")) {
[16:13:40.849]                         if (!is.null(pattern)) {
[16:13:40.849]                           computeRestarts <- base::computeRestarts
[16:13:40.849]                           grepl <- base::grepl
[16:13:40.849]                           restarts <- computeRestarts(cond)
[16:13:40.849]                           for (restart in restarts) {
[16:13:40.849]                             name <- restart$name
[16:13:40.849]                             if (is.null(name)) 
[16:13:40.849]                               next
[16:13:40.849]                             if (!grepl(pattern, name)) 
[16:13:40.849]                               next
[16:13:40.849]                             invokeRestart(restart)
[16:13:40.849]                             muffled <- TRUE
[16:13:40.849]                             break
[16:13:40.849]                           }
[16:13:40.849]                         }
[16:13:40.849]                       }
[16:13:40.849]                       invisible(muffled)
[16:13:40.849]                     }
[16:13:40.849]                     muffleCondition(cond, pattern = "^muffle")
[16:13:40.849]                   }
[16:13:40.849]                 }
[16:13:40.849]                 else {
[16:13:40.849]                   if (TRUE) {
[16:13:40.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.849]                     {
[16:13:40.849]                       inherits <- base::inherits
[16:13:40.849]                       invokeRestart <- base::invokeRestart
[16:13:40.849]                       is.null <- base::is.null
[16:13:40.849]                       muffled <- FALSE
[16:13:40.849]                       if (inherits(cond, "message")) {
[16:13:40.849]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:40.849]                         if (muffled) 
[16:13:40.849]                           invokeRestart("muffleMessage")
[16:13:40.849]                       }
[16:13:40.849]                       else if (inherits(cond, "warning")) {
[16:13:40.849]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:40.849]                         if (muffled) 
[16:13:40.849]                           invokeRestart("muffleWarning")
[16:13:40.849]                       }
[16:13:40.849]                       else if (inherits(cond, "condition")) {
[16:13:40.849]                         if (!is.null(pattern)) {
[16:13:40.849]                           computeRestarts <- base::computeRestarts
[16:13:40.849]                           grepl <- base::grepl
[16:13:40.849]                           restarts <- computeRestarts(cond)
[16:13:40.849]                           for (restart in restarts) {
[16:13:40.849]                             name <- restart$name
[16:13:40.849]                             if (is.null(name)) 
[16:13:40.849]                               next
[16:13:40.849]                             if (!grepl(pattern, name)) 
[16:13:40.849]                               next
[16:13:40.849]                             invokeRestart(restart)
[16:13:40.849]                             muffled <- TRUE
[16:13:40.849]                             break
[16:13:40.849]                           }
[16:13:40.849]                         }
[16:13:40.849]                       }
[16:13:40.849]                       invisible(muffled)
[16:13:40.849]                     }
[16:13:40.849]                     muffleCondition(cond, pattern = "^muffle")
[16:13:40.849]                   }
[16:13:40.849]                 }
[16:13:40.849]             }
[16:13:40.849]         }))
[16:13:40.849]     }, error = function(ex) {
[16:13:40.849]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:40.849]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:40.849]                 ...future.rng), started = ...future.startTime, 
[16:13:40.849]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:40.849]             version = "1.8"), class = "FutureResult")
[16:13:40.849]     }, finally = {
[16:13:40.849]         if (!identical(...future.workdir, getwd())) 
[16:13:40.849]             setwd(...future.workdir)
[16:13:40.849]         {
[16:13:40.849]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:40.849]                 ...future.oldOptions$nwarnings <- NULL
[16:13:40.849]             }
[16:13:40.849]             base::options(...future.oldOptions)
[16:13:40.849]             if (.Platform$OS.type == "windows") {
[16:13:40.849]                 old_names <- names(...future.oldEnvVars)
[16:13:40.849]                 envs <- base::Sys.getenv()
[16:13:40.849]                 names <- names(envs)
[16:13:40.849]                 common <- intersect(names, old_names)
[16:13:40.849]                 added <- setdiff(names, old_names)
[16:13:40.849]                 removed <- setdiff(old_names, names)
[16:13:40.849]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:40.849]                   envs[common]]
[16:13:40.849]                 NAMES <- toupper(changed)
[16:13:40.849]                 args <- list()
[16:13:40.849]                 for (kk in seq_along(NAMES)) {
[16:13:40.849]                   name <- changed[[kk]]
[16:13:40.849]                   NAME <- NAMES[[kk]]
[16:13:40.849]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.849]                     next
[16:13:40.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:40.849]                 }
[16:13:40.849]                 NAMES <- toupper(added)
[16:13:40.849]                 for (kk in seq_along(NAMES)) {
[16:13:40.849]                   name <- added[[kk]]
[16:13:40.849]                   NAME <- NAMES[[kk]]
[16:13:40.849]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.849]                     next
[16:13:40.849]                   args[[name]] <- ""
[16:13:40.849]                 }
[16:13:40.849]                 NAMES <- toupper(removed)
[16:13:40.849]                 for (kk in seq_along(NAMES)) {
[16:13:40.849]                   name <- removed[[kk]]
[16:13:40.849]                   NAME <- NAMES[[kk]]
[16:13:40.849]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.849]                     next
[16:13:40.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:40.849]                 }
[16:13:40.849]                 if (length(args) > 0) 
[16:13:40.849]                   base::do.call(base::Sys.setenv, args = args)
[16:13:40.849]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:40.849]             }
[16:13:40.849]             else {
[16:13:40.849]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:40.849]             }
[16:13:40.849]             {
[16:13:40.849]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:40.849]                   0L) {
[16:13:40.849]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:40.849]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:40.849]                   base::options(opts)
[16:13:40.849]                 }
[16:13:40.849]                 {
[16:13:40.849]                   {
[16:13:40.849]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:40.849]                     NULL
[16:13:40.849]                   }
[16:13:40.849]                   options(future.plan = NULL)
[16:13:40.849]                   if (is.na(NA_character_)) 
[16:13:40.849]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:40.849]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:40.849]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:40.849]                     envir = parent.frame()) 
[16:13:40.849]                   {
[16:13:40.849]                     default_workers <- missing(workers)
[16:13:40.849]                     if (is.function(workers)) 
[16:13:40.849]                       workers <- workers()
[16:13:40.849]                     workers <- structure(as.integer(workers), 
[16:13:40.849]                       class = class(workers))
[16:13:40.849]                     stop_if_not(is.finite(workers), workers >= 
[16:13:40.849]                       1L)
[16:13:40.849]                     if ((workers == 1L && !inherits(workers, 
[16:13:40.849]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:40.849]                       if (default_workers) 
[16:13:40.849]                         supportsMulticore(warn = TRUE)
[16:13:40.849]                       return(sequential(..., envir = envir))
[16:13:40.849]                     }
[16:13:40.849]                     oopts <- options(mc.cores = workers)
[16:13:40.849]                     on.exit(options(oopts))
[16:13:40.849]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:40.849]                       envir = envir)
[16:13:40.849]                     if (!future$lazy) 
[16:13:40.849]                       future <- run(future)
[16:13:40.849]                     invisible(future)
[16:13:40.849]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:40.849]                 }
[16:13:40.849]             }
[16:13:40.849]         }
[16:13:40.849]     })
[16:13:40.849]     if (TRUE) {
[16:13:40.849]         base::sink(type = "output", split = FALSE)
[16:13:40.849]         if (TRUE) {
[16:13:40.849]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:40.849]         }
[16:13:40.849]         else {
[16:13:40.849]             ...future.result["stdout"] <- base::list(NULL)
[16:13:40.849]         }
[16:13:40.849]         base::close(...future.stdout)
[16:13:40.849]         ...future.stdout <- NULL
[16:13:40.849]     }
[16:13:40.849]     ...future.result$conditions <- ...future.conditions
[16:13:40.849]     ...future.result$finished <- base::Sys.time()
[16:13:40.849]     ...future.result
[16:13:40.849] }
[16:13:40.852] requestCore(): workers = 2
[16:13:40.852] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:40.867] MulticoreFuture started
[16:13:40.867] - Launch lazy future ... done
[16:13:40.868] run() for ‘MulticoreFuture’ ... done
[16:13:40.868] plan(): Setting new future strategy stack:
[16:13:40.868] getGlobalsAndPackages() ...
[16:13:40.868] Searching for globals...
[16:13:40.868] List of future strategies:
[16:13:40.868] 1. sequential:
[16:13:40.868]    - args: function (..., envir = parent.frame())
[16:13:40.868]    - tweaked: FALSE
[16:13:40.868]    - call: NULL
[16:13:40.869] plan(): nbrOfWorkers() = 1
[16:13:40.870] - globals found: [2] ‘{’, ‘Sys.sleep’
[16:13:40.871] Searching for globals ... DONE
[16:13:40.871] Resolving globals: FALSE
[16:13:40.871] plan(): Setting new future strategy stack:
[16:13:40.872] 
[16:13:40.872] 
[16:13:40.871] List of future strategies:
[16:13:40.871] 1. multicore:
[16:13:40.871]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:40.871]    - tweaked: FALSE
[16:13:40.871]    - call: plan(strategy)
[16:13:40.872] getGlobalsAndPackages() ... DONE
[16:13:40.872] run() for ‘Future’ ...
[16:13:40.873] - state: ‘created’
[16:13:40.873] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:40.877] plan(): nbrOfWorkers() = 2
[16:13:40.878] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:40.878] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:40.878]   - Field: ‘label’
[16:13:40.878]   - Field: ‘local’
[16:13:40.878]   - Field: ‘owner’
[16:13:40.879]   - Field: ‘envir’
[16:13:40.879]   - Field: ‘workers’
[16:13:40.879]   - Field: ‘packages’
[16:13:40.879]   - Field: ‘gc’
[16:13:40.879]   - Field: ‘job’
[16:13:40.879]   - Field: ‘conditions’
[16:13:40.880]   - Field: ‘expr’
[16:13:40.880]   - Field: ‘uuid’
[16:13:40.880]   - Field: ‘seed’
[16:13:40.880]   - Field: ‘version’
[16:13:40.880]   - Field: ‘result’
[16:13:40.881]   - Field: ‘asynchronous’
[16:13:40.881]   - Field: ‘calls’
[16:13:40.881]   - Field: ‘globals’
[16:13:40.881]   - Field: ‘stdout’
[16:13:40.881]   - Field: ‘earlySignal’
[16:13:40.881]   - Field: ‘lazy’
[16:13:40.882]   - Field: ‘state’
[16:13:40.882] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:40.882] - Launch lazy future ...
[16:13:40.883] Packages needed by the future expression (n = 0): <none>
[16:13:40.883] Packages needed by future strategies (n = 0): <none>
[16:13:40.884] {
[16:13:40.884]     {
[16:13:40.884]         {
[16:13:40.884]             ...future.startTime <- base::Sys.time()
[16:13:40.884]             {
[16:13:40.884]                 {
[16:13:40.884]                   {
[16:13:40.884]                     {
[16:13:40.884]                       base::local({
[16:13:40.884]                         has_future <- base::requireNamespace("future", 
[16:13:40.884]                           quietly = TRUE)
[16:13:40.884]                         if (has_future) {
[16:13:40.884]                           ns <- base::getNamespace("future")
[16:13:40.884]                           version <- ns[[".package"]][["version"]]
[16:13:40.884]                           if (is.null(version)) 
[16:13:40.884]                             version <- utils::packageVersion("future")
[16:13:40.884]                         }
[16:13:40.884]                         else {
[16:13:40.884]                           version <- NULL
[16:13:40.884]                         }
[16:13:40.884]                         if (!has_future || version < "1.8.0") {
[16:13:40.884]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:40.884]                             "", base::R.version$version.string), 
[16:13:40.884]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:40.884]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:40.884]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:40.884]                               "release", "version")], collapse = " "), 
[16:13:40.884]                             hostname = base::Sys.info()[["nodename"]])
[16:13:40.884]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:40.884]                             info)
[16:13:40.884]                           info <- base::paste(info, collapse = "; ")
[16:13:40.884]                           if (!has_future) {
[16:13:40.884]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:40.884]                               info)
[16:13:40.884]                           }
[16:13:40.884]                           else {
[16:13:40.884]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:40.884]                               info, version)
[16:13:40.884]                           }
[16:13:40.884]                           base::stop(msg)
[16:13:40.884]                         }
[16:13:40.884]                       })
[16:13:40.884]                     }
[16:13:40.884]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:40.884]                     base::options(mc.cores = 1L)
[16:13:40.884]                   }
[16:13:40.884]                   options(future.plan = NULL)
[16:13:40.884]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:40.884]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:40.884]                 }
[16:13:40.884]                 ...future.workdir <- getwd()
[16:13:40.884]             }
[16:13:40.884]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:40.884]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:40.884]         }
[16:13:40.884]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:40.884]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:40.884]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:40.884]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:40.884]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:40.884]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:40.884]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:40.884]             base::names(...future.oldOptions))
[16:13:40.884]     }
[16:13:40.884]     if (FALSE) {
[16:13:40.884]     }
[16:13:40.884]     else {
[16:13:40.884]         if (TRUE) {
[16:13:40.884]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:40.884]                 open = "w")
[16:13:40.884]         }
[16:13:40.884]         else {
[16:13:40.884]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:40.884]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:40.884]         }
[16:13:40.884]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:40.884]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:40.884]             base::sink(type = "output", split = FALSE)
[16:13:40.884]             base::close(...future.stdout)
[16:13:40.884]         }, add = TRUE)
[16:13:40.884]     }
[16:13:40.884]     ...future.frame <- base::sys.nframe()
[16:13:40.884]     ...future.conditions <- base::list()
[16:13:40.884]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:40.884]     if (FALSE) {
[16:13:40.884]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:40.884]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:40.884]     }
[16:13:40.884]     ...future.result <- base::tryCatch({
[16:13:40.884]         base::withCallingHandlers({
[16:13:40.884]             ...future.value <- base::withVisible(base::local({
[16:13:40.884]                 withCallingHandlers({
[16:13:40.884]                   {
[16:13:40.884]                     Sys.sleep(0.5)
[16:13:40.884]                     2
[16:13:40.884]                   }
[16:13:40.884]                 }, immediateCondition = function(cond) {
[16:13:40.884]                   save_rds <- function (object, pathname, ...) 
[16:13:40.884]                   {
[16:13:40.884]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:40.884]                     if (file_test("-f", pathname_tmp)) {
[16:13:40.884]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.884]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:40.884]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.884]                         fi_tmp[["mtime"]])
[16:13:40.884]                     }
[16:13:40.884]                     tryCatch({
[16:13:40.884]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:40.884]                     }, error = function(ex) {
[16:13:40.884]                       msg <- conditionMessage(ex)
[16:13:40.884]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.884]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:40.884]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.884]                         fi_tmp[["mtime"]], msg)
[16:13:40.884]                       ex$message <- msg
[16:13:40.884]                       stop(ex)
[16:13:40.884]                     })
[16:13:40.884]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:40.884]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:40.884]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:40.884]                       fi_tmp <- file.info(pathname_tmp)
[16:13:40.884]                       fi <- file.info(pathname)
[16:13:40.884]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:40.884]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:40.884]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:40.884]                         fi[["size"]], fi[["mtime"]])
[16:13:40.884]                       stop(msg)
[16:13:40.884]                     }
[16:13:40.884]                     invisible(pathname)
[16:13:40.884]                   }
[16:13:40.884]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:40.884]                     rootPath = tempdir()) 
[16:13:40.884]                   {
[16:13:40.884]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:40.884]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:40.884]                       tmpdir = path, fileext = ".rds")
[16:13:40.884]                     save_rds(obj, file)
[16:13:40.884]                   }
[16:13:40.884]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:40.884]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.884]                   {
[16:13:40.884]                     inherits <- base::inherits
[16:13:40.884]                     invokeRestart <- base::invokeRestart
[16:13:40.884]                     is.null <- base::is.null
[16:13:40.884]                     muffled <- FALSE
[16:13:40.884]                     if (inherits(cond, "message")) {
[16:13:40.884]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:40.884]                       if (muffled) 
[16:13:40.884]                         invokeRestart("muffleMessage")
[16:13:40.884]                     }
[16:13:40.884]                     else if (inherits(cond, "warning")) {
[16:13:40.884]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:40.884]                       if (muffled) 
[16:13:40.884]                         invokeRestart("muffleWarning")
[16:13:40.884]                     }
[16:13:40.884]                     else if (inherits(cond, "condition")) {
[16:13:40.884]                       if (!is.null(pattern)) {
[16:13:40.884]                         computeRestarts <- base::computeRestarts
[16:13:40.884]                         grepl <- base::grepl
[16:13:40.884]                         restarts <- computeRestarts(cond)
[16:13:40.884]                         for (restart in restarts) {
[16:13:40.884]                           name <- restart$name
[16:13:40.884]                           if (is.null(name)) 
[16:13:40.884]                             next
[16:13:40.884]                           if (!grepl(pattern, name)) 
[16:13:40.884]                             next
[16:13:40.884]                           invokeRestart(restart)
[16:13:40.884]                           muffled <- TRUE
[16:13:40.884]                           break
[16:13:40.884]                         }
[16:13:40.884]                       }
[16:13:40.884]                     }
[16:13:40.884]                     invisible(muffled)
[16:13:40.884]                   }
[16:13:40.884]                   muffleCondition(cond)
[16:13:40.884]                 })
[16:13:40.884]             }))
[16:13:40.884]             future::FutureResult(value = ...future.value$value, 
[16:13:40.884]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:40.884]                   ...future.rng), globalenv = if (FALSE) 
[16:13:40.884]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:40.884]                     ...future.globalenv.names))
[16:13:40.884]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:40.884]         }, condition = base::local({
[16:13:40.884]             c <- base::c
[16:13:40.884]             inherits <- base::inherits
[16:13:40.884]             invokeRestart <- base::invokeRestart
[16:13:40.884]             length <- base::length
[16:13:40.884]             list <- base::list
[16:13:40.884]             seq.int <- base::seq.int
[16:13:40.884]             signalCondition <- base::signalCondition
[16:13:40.884]             sys.calls <- base::sys.calls
[16:13:40.884]             `[[` <- base::`[[`
[16:13:40.884]             `+` <- base::`+`
[16:13:40.884]             `<<-` <- base::`<<-`
[16:13:40.884]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:40.884]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:40.884]                   3L)]
[16:13:40.884]             }
[16:13:40.884]             function(cond) {
[16:13:40.884]                 is_error <- inherits(cond, "error")
[16:13:40.884]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:40.884]                   NULL)
[16:13:40.884]                 if (is_error) {
[16:13:40.884]                   sessionInformation <- function() {
[16:13:40.884]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:40.884]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:40.884]                       search = base::search(), system = base::Sys.info())
[16:13:40.884]                   }
[16:13:40.884]                   ...future.conditions[[length(...future.conditions) + 
[16:13:40.884]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:40.884]                     cond$call), session = sessionInformation(), 
[16:13:40.884]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:40.884]                   signalCondition(cond)
[16:13:40.884]                 }
[16:13:40.884]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:40.884]                 "immediateCondition"))) {
[16:13:40.884]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:40.884]                   ...future.conditions[[length(...future.conditions) + 
[16:13:40.884]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:40.884]                   if (TRUE && !signal) {
[16:13:40.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.884]                     {
[16:13:40.884]                       inherits <- base::inherits
[16:13:40.884]                       invokeRestart <- base::invokeRestart
[16:13:40.884]                       is.null <- base::is.null
[16:13:40.884]                       muffled <- FALSE
[16:13:40.884]                       if (inherits(cond, "message")) {
[16:13:40.884]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:40.884]                         if (muffled) 
[16:13:40.884]                           invokeRestart("muffleMessage")
[16:13:40.884]                       }
[16:13:40.884]                       else if (inherits(cond, "warning")) {
[16:13:40.884]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:40.884]                         if (muffled) 
[16:13:40.884]                           invokeRestart("muffleWarning")
[16:13:40.884]                       }
[16:13:40.884]                       else if (inherits(cond, "condition")) {
[16:13:40.884]                         if (!is.null(pattern)) {
[16:13:40.884]                           computeRestarts <- base::computeRestarts
[16:13:40.884]                           grepl <- base::grepl
[16:13:40.884]                           restarts <- computeRestarts(cond)
[16:13:40.884]                           for (restart in restarts) {
[16:13:40.884]                             name <- restart$name
[16:13:40.884]                             if (is.null(name)) 
[16:13:40.884]                               next
[16:13:40.884]                             if (!grepl(pattern, name)) 
[16:13:40.884]                               next
[16:13:40.884]                             invokeRestart(restart)
[16:13:40.884]                             muffled <- TRUE
[16:13:40.884]                             break
[16:13:40.884]                           }
[16:13:40.884]                         }
[16:13:40.884]                       }
[16:13:40.884]                       invisible(muffled)
[16:13:40.884]                     }
[16:13:40.884]                     muffleCondition(cond, pattern = "^muffle")
[16:13:40.884]                   }
[16:13:40.884]                 }
[16:13:40.884]                 else {
[16:13:40.884]                   if (TRUE) {
[16:13:40.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:40.884]                     {
[16:13:40.884]                       inherits <- base::inherits
[16:13:40.884]                       invokeRestart <- base::invokeRestart
[16:13:40.884]                       is.null <- base::is.null
[16:13:40.884]                       muffled <- FALSE
[16:13:40.884]                       if (inherits(cond, "message")) {
[16:13:40.884]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:40.884]                         if (muffled) 
[16:13:40.884]                           invokeRestart("muffleMessage")
[16:13:40.884]                       }
[16:13:40.884]                       else if (inherits(cond, "warning")) {
[16:13:40.884]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:40.884]                         if (muffled) 
[16:13:40.884]                           invokeRestart("muffleWarning")
[16:13:40.884]                       }
[16:13:40.884]                       else if (inherits(cond, "condition")) {
[16:13:40.884]                         if (!is.null(pattern)) {
[16:13:40.884]                           computeRestarts <- base::computeRestarts
[16:13:40.884]                           grepl <- base::grepl
[16:13:40.884]                           restarts <- computeRestarts(cond)
[16:13:40.884]                           for (restart in restarts) {
[16:13:40.884]                             name <- restart$name
[16:13:40.884]                             if (is.null(name)) 
[16:13:40.884]                               next
[16:13:40.884]                             if (!grepl(pattern, name)) 
[16:13:40.884]                               next
[16:13:40.884]                             invokeRestart(restart)
[16:13:40.884]                             muffled <- TRUE
[16:13:40.884]                             break
[16:13:40.884]                           }
[16:13:40.884]                         }
[16:13:40.884]                       }
[16:13:40.884]                       invisible(muffled)
[16:13:40.884]                     }
[16:13:40.884]                     muffleCondition(cond, pattern = "^muffle")
[16:13:40.884]                   }
[16:13:40.884]                 }
[16:13:40.884]             }
[16:13:40.884]         }))
[16:13:40.884]     }, error = function(ex) {
[16:13:40.884]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:40.884]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:40.884]                 ...future.rng), started = ...future.startTime, 
[16:13:40.884]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:40.884]             version = "1.8"), class = "FutureResult")
[16:13:40.884]     }, finally = {
[16:13:40.884]         if (!identical(...future.workdir, getwd())) 
[16:13:40.884]             setwd(...future.workdir)
[16:13:40.884]         {
[16:13:40.884]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:40.884]                 ...future.oldOptions$nwarnings <- NULL
[16:13:40.884]             }
[16:13:40.884]             base::options(...future.oldOptions)
[16:13:40.884]             if (.Platform$OS.type == "windows") {
[16:13:40.884]                 old_names <- names(...future.oldEnvVars)
[16:13:40.884]                 envs <- base::Sys.getenv()
[16:13:40.884]                 names <- names(envs)
[16:13:40.884]                 common <- intersect(names, old_names)
[16:13:40.884]                 added <- setdiff(names, old_names)
[16:13:40.884]                 removed <- setdiff(old_names, names)
[16:13:40.884]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:40.884]                   envs[common]]
[16:13:40.884]                 NAMES <- toupper(changed)
[16:13:40.884]                 args <- list()
[16:13:40.884]                 for (kk in seq_along(NAMES)) {
[16:13:40.884]                   name <- changed[[kk]]
[16:13:40.884]                   NAME <- NAMES[[kk]]
[16:13:40.884]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.884]                     next
[16:13:40.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:40.884]                 }
[16:13:40.884]                 NAMES <- toupper(added)
[16:13:40.884]                 for (kk in seq_along(NAMES)) {
[16:13:40.884]                   name <- added[[kk]]
[16:13:40.884]                   NAME <- NAMES[[kk]]
[16:13:40.884]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.884]                     next
[16:13:40.884]                   args[[name]] <- ""
[16:13:40.884]                 }
[16:13:40.884]                 NAMES <- toupper(removed)
[16:13:40.884]                 for (kk in seq_along(NAMES)) {
[16:13:40.884]                   name <- removed[[kk]]
[16:13:40.884]                   NAME <- NAMES[[kk]]
[16:13:40.884]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:40.884]                     next
[16:13:40.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:40.884]                 }
[16:13:40.884]                 if (length(args) > 0) 
[16:13:40.884]                   base::do.call(base::Sys.setenv, args = args)
[16:13:40.884]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:40.884]             }
[16:13:40.884]             else {
[16:13:40.884]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:40.884]             }
[16:13:40.884]             {
[16:13:40.884]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:40.884]                   0L) {
[16:13:40.884]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:40.884]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:40.884]                   base::options(opts)
[16:13:40.884]                 }
[16:13:40.884]                 {
[16:13:40.884]                   {
[16:13:40.884]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:40.884]                     NULL
[16:13:40.884]                   }
[16:13:40.884]                   options(future.plan = NULL)
[16:13:40.884]                   if (is.na(NA_character_)) 
[16:13:40.884]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:40.884]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:40.884]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:40.884]                     envir = parent.frame()) 
[16:13:40.884]                   {
[16:13:40.884]                     default_workers <- missing(workers)
[16:13:40.884]                     if (is.function(workers)) 
[16:13:40.884]                       workers <- workers()
[16:13:40.884]                     workers <- structure(as.integer(workers), 
[16:13:40.884]                       class = class(workers))
[16:13:40.884]                     stop_if_not(is.finite(workers), workers >= 
[16:13:40.884]                       1L)
[16:13:40.884]                     if ((workers == 1L && !inherits(workers, 
[16:13:40.884]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:40.884]                       if (default_workers) 
[16:13:40.884]                         supportsMulticore(warn = TRUE)
[16:13:40.884]                       return(sequential(..., envir = envir))
[16:13:40.884]                     }
[16:13:40.884]                     oopts <- options(mc.cores = workers)
[16:13:40.884]                     on.exit(options(oopts))
[16:13:40.884]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:40.884]                       envir = envir)
[16:13:40.884]                     if (!future$lazy) 
[16:13:40.884]                       future <- run(future)
[16:13:40.884]                     invisible(future)
[16:13:40.884]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:40.884]                 }
[16:13:40.884]             }
[16:13:40.884]         }
[16:13:40.884]     })
[16:13:40.884]     if (TRUE) {
[16:13:40.884]         base::sink(type = "output", split = FALSE)
[16:13:40.884]         if (TRUE) {
[16:13:40.884]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:40.884]         }
[16:13:40.884]         else {
[16:13:40.884]             ...future.result["stdout"] <- base::list(NULL)
[16:13:40.884]         }
[16:13:40.884]         base::close(...future.stdout)
[16:13:40.884]         ...future.stdout <- NULL
[16:13:40.884]     }
[16:13:40.884]     ...future.result$conditions <- ...future.conditions
[16:13:40.884]     ...future.result$finished <- base::Sys.time()
[16:13:40.884]     ...future.result
[16:13:40.884] }
[16:13:40.888] requestCore(): workers = 2
[16:13:40.888] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:40.903] MulticoreFuture started
[16:13:40.903] - Launch lazy future ... done
[16:13:40.904] run() for ‘MulticoreFuture’ ... done
[16:13:40.904] plan(): Setting new future strategy stack:
[16:13:40.904] resolve() on list ...
[16:13:40.905]  recursive: 0
[16:13:40.905]  length: 1
[16:13:40.905] 
[16:13:40.904] List of future strategies:
[16:13:40.904] 1. sequential:
[16:13:40.904]    - args: function (..., envir = parent.frame())
[16:13:40.904]    - tweaked: FALSE
[16:13:40.904]    - call: NULL
[16:13:40.905] Future #1
[16:13:40.905] plan(): nbrOfWorkers() = 1
[16:13:40.906]  length: 0 (resolved future 1)
[16:13:40.906] resolve() on list ... DONE
[16:13:40.906] resolve() on list ...
[16:13:40.907]  recursive: 0
[16:13:40.907]  length: 1
[16:13:40.907] 
[16:13:41.409] plan(): Setting new future strategy stack:
[16:13:41.409] List of future strategies:
[16:13:41.409] 1. multicore:
[16:13:41.409]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:41.409]    - tweaked: FALSE
[16:13:41.409]    - call: plan(strategy)
[16:13:41.414] plan(): nbrOfWorkers() = 2
[16:13:41.419] Future #1
[16:13:41.419]  length: 0 (resolved future 1)
[16:13:41.420] resolve() on list ... DONE
[16:13:41.420] resolve() on list ...
[16:13:41.420]  recursive: 0
[16:13:41.421]  length: 1
[16:13:41.421] 
[16:13:41.421]  length: 0 (resolved future 1)
[16:13:41.421] resolve() on list ... DONE
[16:13:41.421] resolve() on list ...
[16:13:41.422]  recursive: 0
[16:13:41.422]  length: 4
[16:13:41.422] 
[16:13:41.422] Future #1
[16:13:41.422]  length: 3 (resolved future 1)
[16:13:41.423] Future #2
[16:13:41.423]  length: 2 (resolved future 2)
[16:13:41.423]  length: 1 (resolved future 3)
[16:13:41.423]  length: 0 (resolved future 4)
[16:13:41.423] resolve() on list ... DONE
[16:13:41.424] resolve() on list ...
[16:13:41.424]  recursive: 0
[16:13:41.424]  length: 4
[16:13:41.424] 
[16:13:41.424] Future #1
[16:13:41.425]  length: 3 (resolved future 1)
[16:13:41.425] Future #2
[16:13:41.425]  length: 2 (resolved future 2)
[16:13:41.425]  length: 1 (resolved future 3)
[16:13:41.425]  length: 0 (resolved future 4)
[16:13:41.425] resolve() on list ... DONE
[16:13:41.426] resolve() on list ...
[16:13:41.426]  recursive: 0
[16:13:41.426]  length: 1
[16:13:41.430] 
[16:13:41.430]  length: 0 (resolved future 1)
[16:13:41.431] resolve() on list ... DONE
[16:13:41.431] getGlobalsAndPackages() ...
[16:13:41.431] Searching for globals...
[16:13:41.434] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:13:41.435] Searching for globals ... DONE
[16:13:41.435] Resolving globals: FALSE
[16:13:41.436] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:41.436] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:13:41.436] - globals: [1] ‘kk’
[16:13:41.437] 
[16:13:41.437] getGlobalsAndPackages() ... DONE
[16:13:41.437] run() for ‘Future’ ...
[16:13:41.438] - state: ‘created’
[16:13:41.438] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:41.442] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:41.443] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:41.443]   - Field: ‘label’
[16:13:41.443]   - Field: ‘local’
[16:13:41.443]   - Field: ‘owner’
[16:13:41.444]   - Field: ‘envir’
[16:13:41.444]   - Field: ‘workers’
[16:13:41.444]   - Field: ‘packages’
[16:13:41.444]   - Field: ‘gc’
[16:13:41.444]   - Field: ‘job’
[16:13:41.444]   - Field: ‘conditions’
[16:13:41.445]   - Field: ‘expr’
[16:13:41.445]   - Field: ‘uuid’
[16:13:41.445]   - Field: ‘seed’
[16:13:41.445]   - Field: ‘version’
[16:13:41.445]   - Field: ‘result’
[16:13:41.445]   - Field: ‘asynchronous’
[16:13:41.446]   - Field: ‘calls’
[16:13:41.446]   - Field: ‘globals’
[16:13:41.446]   - Field: ‘stdout’
[16:13:41.446]   - Field: ‘earlySignal’
[16:13:41.446]   - Field: ‘lazy’
[16:13:41.446]   - Field: ‘state’
[16:13:41.446] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:41.447] - Launch lazy future ...
[16:13:41.447] Packages needed by the future expression (n = 0): <none>
[16:13:41.447] Packages needed by future strategies (n = 0): <none>
[16:13:41.448] {
[16:13:41.448]     {
[16:13:41.448]         {
[16:13:41.448]             ...future.startTime <- base::Sys.time()
[16:13:41.448]             {
[16:13:41.448]                 {
[16:13:41.448]                   {
[16:13:41.448]                     {
[16:13:41.448]                       base::local({
[16:13:41.448]                         has_future <- base::requireNamespace("future", 
[16:13:41.448]                           quietly = TRUE)
[16:13:41.448]                         if (has_future) {
[16:13:41.448]                           ns <- base::getNamespace("future")
[16:13:41.448]                           version <- ns[[".package"]][["version"]]
[16:13:41.448]                           if (is.null(version)) 
[16:13:41.448]                             version <- utils::packageVersion("future")
[16:13:41.448]                         }
[16:13:41.448]                         else {
[16:13:41.448]                           version <- NULL
[16:13:41.448]                         }
[16:13:41.448]                         if (!has_future || version < "1.8.0") {
[16:13:41.448]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:41.448]                             "", base::R.version$version.string), 
[16:13:41.448]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:41.448]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:41.448]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:41.448]                               "release", "version")], collapse = " "), 
[16:13:41.448]                             hostname = base::Sys.info()[["nodename"]])
[16:13:41.448]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:41.448]                             info)
[16:13:41.448]                           info <- base::paste(info, collapse = "; ")
[16:13:41.448]                           if (!has_future) {
[16:13:41.448]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:41.448]                               info)
[16:13:41.448]                           }
[16:13:41.448]                           else {
[16:13:41.448]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:41.448]                               info, version)
[16:13:41.448]                           }
[16:13:41.448]                           base::stop(msg)
[16:13:41.448]                         }
[16:13:41.448]                       })
[16:13:41.448]                     }
[16:13:41.448]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:41.448]                     base::options(mc.cores = 1L)
[16:13:41.448]                   }
[16:13:41.448]                   options(future.plan = NULL)
[16:13:41.448]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:41.448]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:41.448]                 }
[16:13:41.448]                 ...future.workdir <- getwd()
[16:13:41.448]             }
[16:13:41.448]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:41.448]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:41.448]         }
[16:13:41.448]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:41.448]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:41.448]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:41.448]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:41.448]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:41.448]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:41.448]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:41.448]             base::names(...future.oldOptions))
[16:13:41.448]     }
[16:13:41.448]     if (FALSE) {
[16:13:41.448]     }
[16:13:41.448]     else {
[16:13:41.448]         if (TRUE) {
[16:13:41.448]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:41.448]                 open = "w")
[16:13:41.448]         }
[16:13:41.448]         else {
[16:13:41.448]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:41.448]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:41.448]         }
[16:13:41.448]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:41.448]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:41.448]             base::sink(type = "output", split = FALSE)
[16:13:41.448]             base::close(...future.stdout)
[16:13:41.448]         }, add = TRUE)
[16:13:41.448]     }
[16:13:41.448]     ...future.frame <- base::sys.nframe()
[16:13:41.448]     ...future.conditions <- base::list()
[16:13:41.448]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:41.448]     if (FALSE) {
[16:13:41.448]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:41.448]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:41.448]     }
[16:13:41.448]     ...future.result <- base::tryCatch({
[16:13:41.448]         base::withCallingHandlers({
[16:13:41.448]             ...future.value <- base::withVisible(base::local({
[16:13:41.448]                 withCallingHandlers({
[16:13:41.448]                   {
[16:13:41.448]                     Sys.sleep(0.1)
[16:13:41.448]                     kk
[16:13:41.448]                   }
[16:13:41.448]                 }, immediateCondition = function(cond) {
[16:13:41.448]                   save_rds <- function (object, pathname, ...) 
[16:13:41.448]                   {
[16:13:41.448]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:41.448]                     if (file_test("-f", pathname_tmp)) {
[16:13:41.448]                       fi_tmp <- file.info(pathname_tmp)
[16:13:41.448]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:41.448]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:41.448]                         fi_tmp[["mtime"]])
[16:13:41.448]                     }
[16:13:41.448]                     tryCatch({
[16:13:41.448]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:41.448]                     }, error = function(ex) {
[16:13:41.448]                       msg <- conditionMessage(ex)
[16:13:41.448]                       fi_tmp <- file.info(pathname_tmp)
[16:13:41.448]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:41.448]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:41.448]                         fi_tmp[["mtime"]], msg)
[16:13:41.448]                       ex$message <- msg
[16:13:41.448]                       stop(ex)
[16:13:41.448]                     })
[16:13:41.448]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:41.448]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:41.448]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:41.448]                       fi_tmp <- file.info(pathname_tmp)
[16:13:41.448]                       fi <- file.info(pathname)
[16:13:41.448]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:41.448]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:41.448]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:41.448]                         fi[["size"]], fi[["mtime"]])
[16:13:41.448]                       stop(msg)
[16:13:41.448]                     }
[16:13:41.448]                     invisible(pathname)
[16:13:41.448]                   }
[16:13:41.448]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:41.448]                     rootPath = tempdir()) 
[16:13:41.448]                   {
[16:13:41.448]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:41.448]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:41.448]                       tmpdir = path, fileext = ".rds")
[16:13:41.448]                     save_rds(obj, file)
[16:13:41.448]                   }
[16:13:41.448]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:41.448]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:41.448]                   {
[16:13:41.448]                     inherits <- base::inherits
[16:13:41.448]                     invokeRestart <- base::invokeRestart
[16:13:41.448]                     is.null <- base::is.null
[16:13:41.448]                     muffled <- FALSE
[16:13:41.448]                     if (inherits(cond, "message")) {
[16:13:41.448]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:41.448]                       if (muffled) 
[16:13:41.448]                         invokeRestart("muffleMessage")
[16:13:41.448]                     }
[16:13:41.448]                     else if (inherits(cond, "warning")) {
[16:13:41.448]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:41.448]                       if (muffled) 
[16:13:41.448]                         invokeRestart("muffleWarning")
[16:13:41.448]                     }
[16:13:41.448]                     else if (inherits(cond, "condition")) {
[16:13:41.448]                       if (!is.null(pattern)) {
[16:13:41.448]                         computeRestarts <- base::computeRestarts
[16:13:41.448]                         grepl <- base::grepl
[16:13:41.448]                         restarts <- computeRestarts(cond)
[16:13:41.448]                         for (restart in restarts) {
[16:13:41.448]                           name <- restart$name
[16:13:41.448]                           if (is.null(name)) 
[16:13:41.448]                             next
[16:13:41.448]                           if (!grepl(pattern, name)) 
[16:13:41.448]                             next
[16:13:41.448]                           invokeRestart(restart)
[16:13:41.448]                           muffled <- TRUE
[16:13:41.448]                           break
[16:13:41.448]                         }
[16:13:41.448]                       }
[16:13:41.448]                     }
[16:13:41.448]                     invisible(muffled)
[16:13:41.448]                   }
[16:13:41.448]                   muffleCondition(cond)
[16:13:41.448]                 })
[16:13:41.448]             }))
[16:13:41.448]             future::FutureResult(value = ...future.value$value, 
[16:13:41.448]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:41.448]                   ...future.rng), globalenv = if (FALSE) 
[16:13:41.448]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:41.448]                     ...future.globalenv.names))
[16:13:41.448]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:41.448]         }, condition = base::local({
[16:13:41.448]             c <- base::c
[16:13:41.448]             inherits <- base::inherits
[16:13:41.448]             invokeRestart <- base::invokeRestart
[16:13:41.448]             length <- base::length
[16:13:41.448]             list <- base::list
[16:13:41.448]             seq.int <- base::seq.int
[16:13:41.448]             signalCondition <- base::signalCondition
[16:13:41.448]             sys.calls <- base::sys.calls
[16:13:41.448]             `[[` <- base::`[[`
[16:13:41.448]             `+` <- base::`+`
[16:13:41.448]             `<<-` <- base::`<<-`
[16:13:41.448]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:41.448]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:41.448]                   3L)]
[16:13:41.448]             }
[16:13:41.448]             function(cond) {
[16:13:41.448]                 is_error <- inherits(cond, "error")
[16:13:41.448]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:41.448]                   NULL)
[16:13:41.448]                 if (is_error) {
[16:13:41.448]                   sessionInformation <- function() {
[16:13:41.448]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:41.448]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:41.448]                       search = base::search(), system = base::Sys.info())
[16:13:41.448]                   }
[16:13:41.448]                   ...future.conditions[[length(...future.conditions) + 
[16:13:41.448]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:41.448]                     cond$call), session = sessionInformation(), 
[16:13:41.448]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:41.448]                   signalCondition(cond)
[16:13:41.448]                 }
[16:13:41.448]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:41.448]                 "immediateCondition"))) {
[16:13:41.448]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:41.448]                   ...future.conditions[[length(...future.conditions) + 
[16:13:41.448]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:41.448]                   if (TRUE && !signal) {
[16:13:41.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:41.448]                     {
[16:13:41.448]                       inherits <- base::inherits
[16:13:41.448]                       invokeRestart <- base::invokeRestart
[16:13:41.448]                       is.null <- base::is.null
[16:13:41.448]                       muffled <- FALSE
[16:13:41.448]                       if (inherits(cond, "message")) {
[16:13:41.448]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:41.448]                         if (muffled) 
[16:13:41.448]                           invokeRestart("muffleMessage")
[16:13:41.448]                       }
[16:13:41.448]                       else if (inherits(cond, "warning")) {
[16:13:41.448]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:41.448]                         if (muffled) 
[16:13:41.448]                           invokeRestart("muffleWarning")
[16:13:41.448]                       }
[16:13:41.448]                       else if (inherits(cond, "condition")) {
[16:13:41.448]                         if (!is.null(pattern)) {
[16:13:41.448]                           computeRestarts <- base::computeRestarts
[16:13:41.448]                           grepl <- base::grepl
[16:13:41.448]                           restarts <- computeRestarts(cond)
[16:13:41.448]                           for (restart in restarts) {
[16:13:41.448]                             name <- restart$name
[16:13:41.448]                             if (is.null(name)) 
[16:13:41.448]                               next
[16:13:41.448]                             if (!grepl(pattern, name)) 
[16:13:41.448]                               next
[16:13:41.448]                             invokeRestart(restart)
[16:13:41.448]                             muffled <- TRUE
[16:13:41.448]                             break
[16:13:41.448]                           }
[16:13:41.448]                         }
[16:13:41.448]                       }
[16:13:41.448]                       invisible(muffled)
[16:13:41.448]                     }
[16:13:41.448]                     muffleCondition(cond, pattern = "^muffle")
[16:13:41.448]                   }
[16:13:41.448]                 }
[16:13:41.448]                 else {
[16:13:41.448]                   if (TRUE) {
[16:13:41.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:41.448]                     {
[16:13:41.448]                       inherits <- base::inherits
[16:13:41.448]                       invokeRestart <- base::invokeRestart
[16:13:41.448]                       is.null <- base::is.null
[16:13:41.448]                       muffled <- FALSE
[16:13:41.448]                       if (inherits(cond, "message")) {
[16:13:41.448]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:41.448]                         if (muffled) 
[16:13:41.448]                           invokeRestart("muffleMessage")
[16:13:41.448]                       }
[16:13:41.448]                       else if (inherits(cond, "warning")) {
[16:13:41.448]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:41.448]                         if (muffled) 
[16:13:41.448]                           invokeRestart("muffleWarning")
[16:13:41.448]                       }
[16:13:41.448]                       else if (inherits(cond, "condition")) {
[16:13:41.448]                         if (!is.null(pattern)) {
[16:13:41.448]                           computeRestarts <- base::computeRestarts
[16:13:41.448]                           grepl <- base::grepl
[16:13:41.448]                           restarts <- computeRestarts(cond)
[16:13:41.448]                           for (restart in restarts) {
[16:13:41.448]                             name <- restart$name
[16:13:41.448]                             if (is.null(name)) 
[16:13:41.448]                               next
[16:13:41.448]                             if (!grepl(pattern, name)) 
[16:13:41.448]                               next
[16:13:41.448]                             invokeRestart(restart)
[16:13:41.448]                             muffled <- TRUE
[16:13:41.448]                             break
[16:13:41.448]                           }
[16:13:41.448]                         }
[16:13:41.448]                       }
[16:13:41.448]                       invisible(muffled)
[16:13:41.448]                     }
[16:13:41.448]                     muffleCondition(cond, pattern = "^muffle")
[16:13:41.448]                   }
[16:13:41.448]                 }
[16:13:41.448]             }
[16:13:41.448]         }))
[16:13:41.448]     }, error = function(ex) {
[16:13:41.448]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:41.448]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:41.448]                 ...future.rng), started = ...future.startTime, 
[16:13:41.448]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:41.448]             version = "1.8"), class = "FutureResult")
[16:13:41.448]     }, finally = {
[16:13:41.448]         if (!identical(...future.workdir, getwd())) 
[16:13:41.448]             setwd(...future.workdir)
[16:13:41.448]         {
[16:13:41.448]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:41.448]                 ...future.oldOptions$nwarnings <- NULL
[16:13:41.448]             }
[16:13:41.448]             base::options(...future.oldOptions)
[16:13:41.448]             if (.Platform$OS.type == "windows") {
[16:13:41.448]                 old_names <- names(...future.oldEnvVars)
[16:13:41.448]                 envs <- base::Sys.getenv()
[16:13:41.448]                 names <- names(envs)
[16:13:41.448]                 common <- intersect(names, old_names)
[16:13:41.448]                 added <- setdiff(names, old_names)
[16:13:41.448]                 removed <- setdiff(old_names, names)
[16:13:41.448]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:41.448]                   envs[common]]
[16:13:41.448]                 NAMES <- toupper(changed)
[16:13:41.448]                 args <- list()
[16:13:41.448]                 for (kk in seq_along(NAMES)) {
[16:13:41.448]                   name <- changed[[kk]]
[16:13:41.448]                   NAME <- NAMES[[kk]]
[16:13:41.448]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:41.448]                     next
[16:13:41.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:41.448]                 }
[16:13:41.448]                 NAMES <- toupper(added)
[16:13:41.448]                 for (kk in seq_along(NAMES)) {
[16:13:41.448]                   name <- added[[kk]]
[16:13:41.448]                   NAME <- NAMES[[kk]]
[16:13:41.448]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:41.448]                     next
[16:13:41.448]                   args[[name]] <- ""
[16:13:41.448]                 }
[16:13:41.448]                 NAMES <- toupper(removed)
[16:13:41.448]                 for (kk in seq_along(NAMES)) {
[16:13:41.448]                   name <- removed[[kk]]
[16:13:41.448]                   NAME <- NAMES[[kk]]
[16:13:41.448]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:41.448]                     next
[16:13:41.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:41.448]                 }
[16:13:41.448]                 if (length(args) > 0) 
[16:13:41.448]                   base::do.call(base::Sys.setenv, args = args)
[16:13:41.448]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:41.448]             }
[16:13:41.448]             else {
[16:13:41.448]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:41.448]             }
[16:13:41.448]             {
[16:13:41.448]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:41.448]                   0L) {
[16:13:41.448]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:41.448]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:41.448]                   base::options(opts)
[16:13:41.448]                 }
[16:13:41.448]                 {
[16:13:41.448]                   {
[16:13:41.448]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:41.448]                     NULL
[16:13:41.448]                   }
[16:13:41.448]                   options(future.plan = NULL)
[16:13:41.448]                   if (is.na(NA_character_)) 
[16:13:41.448]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:41.448]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:41.448]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:41.448]                     envir = parent.frame()) 
[16:13:41.448]                   {
[16:13:41.448]                     default_workers <- missing(workers)
[16:13:41.448]                     if (is.function(workers)) 
[16:13:41.448]                       workers <- workers()
[16:13:41.448]                     workers <- structure(as.integer(workers), 
[16:13:41.448]                       class = class(workers))
[16:13:41.448]                     stop_if_not(is.finite(workers), workers >= 
[16:13:41.448]                       1L)
[16:13:41.448]                     if ((workers == 1L && !inherits(workers, 
[16:13:41.448]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:41.448]                       if (default_workers) 
[16:13:41.448]                         supportsMulticore(warn = TRUE)
[16:13:41.448]                       return(sequential(..., envir = envir))
[16:13:41.448]                     }
[16:13:41.448]                     oopts <- options(mc.cores = workers)
[16:13:41.448]                     on.exit(options(oopts))
[16:13:41.448]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:41.448]                       envir = envir)
[16:13:41.448]                     if (!future$lazy) 
[16:13:41.448]                       future <- run(future)
[16:13:41.448]                     invisible(future)
[16:13:41.448]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:41.448]                 }
[16:13:41.448]             }
[16:13:41.448]         }
[16:13:41.448]     })
[16:13:41.448]     if (TRUE) {
[16:13:41.448]         base::sink(type = "output", split = FALSE)
[16:13:41.448]         if (TRUE) {
[16:13:41.448]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:41.448]         }
[16:13:41.448]         else {
[16:13:41.448]             ...future.result["stdout"] <- base::list(NULL)
[16:13:41.448]         }
[16:13:41.448]         base::close(...future.stdout)
[16:13:41.448]         ...future.stdout <- NULL
[16:13:41.448]     }
[16:13:41.448]     ...future.result$conditions <- ...future.conditions
[16:13:41.448]     ...future.result$finished <- base::Sys.time()
[16:13:41.448]     ...future.result
[16:13:41.448] }
[16:13:41.450] assign_globals() ...
[16:13:41.450] List of 1
[16:13:41.450]  $ kk: int 1
[16:13:41.450]  - attr(*, "where")=List of 1
[16:13:41.450]   ..$ kk:<environment: R_EmptyEnv> 
[16:13:41.450]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:41.450]  - attr(*, "resolved")= logi FALSE
[16:13:41.450]  - attr(*, "total_size")= num 56
[16:13:41.450]  - attr(*, "already-done")= logi TRUE
[16:13:41.454] - copied ‘kk’ to environment
[16:13:41.454] assign_globals() ... done
[16:13:41.454] requestCore(): workers = 2
[16:13:41.455] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:41.468] MulticoreFuture started
[16:13:41.469] - Launch lazy future ... done
[16:13:41.469] run() for ‘MulticoreFuture’ ... done
[16:13:41.470] getGlobalsAndPackages() ...
[16:13:41.470] plan(): Setting new future strategy stack:
[16:13:41.470] Searching for globals...
[16:13:41.470] List of future strategies:
[16:13:41.470] 1. sequential:
[16:13:41.470]    - args: function (..., envir = parent.frame())
[16:13:41.470]    - tweaked: FALSE
[16:13:41.470]    - call: NULL
[16:13:41.472] plan(): nbrOfWorkers() = 1
[16:13:41.473] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:13:41.474] Searching for globals ... DONE
[16:13:41.474] Resolving globals: FALSE
[16:13:41.475] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:41.475] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:13:41.476] - globals: [1] ‘kk’
[16:13:41.476] 
[16:13:41.476] getGlobalsAndPackages() ... DONE
[16:13:41.476] run() for ‘Future’ ...
[16:13:41.477] - state: ‘created’
[16:13:41.477] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:41.482] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:41.482] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:41.482]   - Field: ‘label’
[16:13:41.482]   - Field: ‘local’
[16:13:41.482]   - Field: ‘owner’
[16:13:41.483]   - Field: ‘envir’
[16:13:41.483]   - Field: ‘workers’
[16:13:41.483]   - Field: ‘packages’
[16:13:41.483]   - Field: ‘gc’
[16:13:41.483]   - Field: ‘job’
[16:13:41.483]   - Field: ‘conditions’
[16:13:41.483]   - Field: ‘expr’
[16:13:41.484]   - Field: ‘uuid’
[16:13:41.484]   - Field: ‘seed’
[16:13:41.484]   - Field: ‘version’
[16:13:41.484]   - Field: ‘result’
[16:13:41.484]   - Field: ‘asynchronous’
[16:13:41.484]   - Field: ‘calls’
[16:13:41.485]   - Field: ‘globals’
[16:13:41.485]   - Field: ‘stdout’
[16:13:41.485]   - Field: ‘earlySignal’
[16:13:41.485]   - Field: ‘lazy’
[16:13:41.485]   - Field: ‘state’
[16:13:41.485] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:41.485] - Launch lazy future ...
[16:13:41.486] Packages needed by the future expression (n = 0): <none>
[16:13:41.486] Packages needed by future strategies (n = 0): <none>
[16:13:41.487] {
[16:13:41.487]     {
[16:13:41.487]         {
[16:13:41.487]             ...future.startTime <- base::Sys.time()
[16:13:41.487]             {
[16:13:41.487]                 {
[16:13:41.487]                   {
[16:13:41.487]                     {
[16:13:41.487]                       base::local({
[16:13:41.487]                         has_future <- base::requireNamespace("future", 
[16:13:41.487]                           quietly = TRUE)
[16:13:41.487]                         if (has_future) {
[16:13:41.487]                           ns <- base::getNamespace("future")
[16:13:41.487]                           version <- ns[[".package"]][["version"]]
[16:13:41.487]                           if (is.null(version)) 
[16:13:41.487]                             version <- utils::packageVersion("future")
[16:13:41.487]                         }
[16:13:41.487]                         else {
[16:13:41.487]                           version <- NULL
[16:13:41.487]                         }
[16:13:41.487]                         if (!has_future || version < "1.8.0") {
[16:13:41.487]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:41.487]                             "", base::R.version$version.string), 
[16:13:41.487]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:41.487]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:41.487]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:41.487]                               "release", "version")], collapse = " "), 
[16:13:41.487]                             hostname = base::Sys.info()[["nodename"]])
[16:13:41.487]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:41.487]                             info)
[16:13:41.487]                           info <- base::paste(info, collapse = "; ")
[16:13:41.487]                           if (!has_future) {
[16:13:41.487]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:41.487]                               info)
[16:13:41.487]                           }
[16:13:41.487]                           else {
[16:13:41.487]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:41.487]                               info, version)
[16:13:41.487]                           }
[16:13:41.487]                           base::stop(msg)
[16:13:41.487]                         }
[16:13:41.487]                       })
[16:13:41.487]                     }
[16:13:41.487]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:41.487]                     base::options(mc.cores = 1L)
[16:13:41.487]                   }
[16:13:41.487]                   options(future.plan = NULL)
[16:13:41.487]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:41.487]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:41.487]                 }
[16:13:41.487]                 ...future.workdir <- getwd()
[16:13:41.487]             }
[16:13:41.487]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:41.487]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:41.487]         }
[16:13:41.487]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:41.487]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:41.487]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:41.487]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:41.487]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:41.487]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:41.487]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:41.487]             base::names(...future.oldOptions))
[16:13:41.487]     }
[16:13:41.487]     if (FALSE) {
[16:13:41.487]     }
[16:13:41.487]     else {
[16:13:41.487]         if (TRUE) {
[16:13:41.487]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:41.487]                 open = "w")
[16:13:41.487]         }
[16:13:41.487]         else {
[16:13:41.487]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:41.487]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:41.487]         }
[16:13:41.487]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:41.487]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:41.487]             base::sink(type = "output", split = FALSE)
[16:13:41.487]             base::close(...future.stdout)
[16:13:41.487]         }, add = TRUE)
[16:13:41.487]     }
[16:13:41.487]     ...future.frame <- base::sys.nframe()
[16:13:41.487]     ...future.conditions <- base::list()
[16:13:41.487]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:41.487]     if (FALSE) {
[16:13:41.487]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:41.487]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:41.487]     }
[16:13:41.487]     ...future.result <- base::tryCatch({
[16:13:41.487]         base::withCallingHandlers({
[16:13:41.487]             ...future.value <- base::withVisible(base::local({
[16:13:41.487]                 withCallingHandlers({
[16:13:41.487]                   {
[16:13:41.487]                     Sys.sleep(0.1)
[16:13:41.487]                     kk
[16:13:41.487]                   }
[16:13:41.487]                 }, immediateCondition = function(cond) {
[16:13:41.487]                   save_rds <- function (object, pathname, ...) 
[16:13:41.487]                   {
[16:13:41.487]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:41.487]                     if (file_test("-f", pathname_tmp)) {
[16:13:41.487]                       fi_tmp <- file.info(pathname_tmp)
[16:13:41.487]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:41.487]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:41.487]                         fi_tmp[["mtime"]])
[16:13:41.487]                     }
[16:13:41.487]                     tryCatch({
[16:13:41.487]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:41.487]                     }, error = function(ex) {
[16:13:41.487]                       msg <- conditionMessage(ex)
[16:13:41.487]                       fi_tmp <- file.info(pathname_tmp)
[16:13:41.487]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:41.487]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:41.487]                         fi_tmp[["mtime"]], msg)
[16:13:41.487]                       ex$message <- msg
[16:13:41.487]                       stop(ex)
[16:13:41.487]                     })
[16:13:41.487]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:41.487]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:41.487]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:41.487]                       fi_tmp <- file.info(pathname_tmp)
[16:13:41.487]                       fi <- file.info(pathname)
[16:13:41.487]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:41.487]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:41.487]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:41.487]                         fi[["size"]], fi[["mtime"]])
[16:13:41.487]                       stop(msg)
[16:13:41.487]                     }
[16:13:41.487]                     invisible(pathname)
[16:13:41.487]                   }
[16:13:41.487]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:41.487]                     rootPath = tempdir()) 
[16:13:41.487]                   {
[16:13:41.487]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:41.487]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:41.487]                       tmpdir = path, fileext = ".rds")
[16:13:41.487]                     save_rds(obj, file)
[16:13:41.487]                   }
[16:13:41.487]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:41.487]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:41.487]                   {
[16:13:41.487]                     inherits <- base::inherits
[16:13:41.487]                     invokeRestart <- base::invokeRestart
[16:13:41.487]                     is.null <- base::is.null
[16:13:41.487]                     muffled <- FALSE
[16:13:41.487]                     if (inherits(cond, "message")) {
[16:13:41.487]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:41.487]                       if (muffled) 
[16:13:41.487]                         invokeRestart("muffleMessage")
[16:13:41.487]                     }
[16:13:41.487]                     else if (inherits(cond, "warning")) {
[16:13:41.487]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:41.487]                       if (muffled) 
[16:13:41.487]                         invokeRestart("muffleWarning")
[16:13:41.487]                     }
[16:13:41.487]                     else if (inherits(cond, "condition")) {
[16:13:41.487]                       if (!is.null(pattern)) {
[16:13:41.487]                         computeRestarts <- base::computeRestarts
[16:13:41.487]                         grepl <- base::grepl
[16:13:41.487]                         restarts <- computeRestarts(cond)
[16:13:41.487]                         for (restart in restarts) {
[16:13:41.487]                           name <- restart$name
[16:13:41.487]                           if (is.null(name)) 
[16:13:41.487]                             next
[16:13:41.487]                           if (!grepl(pattern, name)) 
[16:13:41.487]                             next
[16:13:41.487]                           invokeRestart(restart)
[16:13:41.487]                           muffled <- TRUE
[16:13:41.487]                           break
[16:13:41.487]                         }
[16:13:41.487]                       }
[16:13:41.487]                     }
[16:13:41.487]                     invisible(muffled)
[16:13:41.487]                   }
[16:13:41.487]                   muffleCondition(cond)
[16:13:41.487]                 })
[16:13:41.487]             }))
[16:13:41.487]             future::FutureResult(value = ...future.value$value, 
[16:13:41.487]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:41.487]                   ...future.rng), globalenv = if (FALSE) 
[16:13:41.487]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:41.487]                     ...future.globalenv.names))
[16:13:41.487]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:41.487]         }, condition = base::local({
[16:13:41.487]             c <- base::c
[16:13:41.487]             inherits <- base::inherits
[16:13:41.487]             invokeRestart <- base::invokeRestart
[16:13:41.487]             length <- base::length
[16:13:41.487]             list <- base::list
[16:13:41.487]             seq.int <- base::seq.int
[16:13:41.487]             signalCondition <- base::signalCondition
[16:13:41.487]             sys.calls <- base::sys.calls
[16:13:41.487]             `[[` <- base::`[[`
[16:13:41.487]             `+` <- base::`+`
[16:13:41.487]             `<<-` <- base::`<<-`
[16:13:41.487]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:41.487]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:41.487]                   3L)]
[16:13:41.487]             }
[16:13:41.487]             function(cond) {
[16:13:41.487]                 is_error <- inherits(cond, "error")
[16:13:41.487]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:41.487]                   NULL)
[16:13:41.487]                 if (is_error) {
[16:13:41.487]                   sessionInformation <- function() {
[16:13:41.487]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:41.487]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:41.487]                       search = base::search(), system = base::Sys.info())
[16:13:41.487]                   }
[16:13:41.487]                   ...future.conditions[[length(...future.conditions) + 
[16:13:41.487]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:41.487]                     cond$call), session = sessionInformation(), 
[16:13:41.487]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:41.487]                   signalCondition(cond)
[16:13:41.487]                 }
[16:13:41.487]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:41.487]                 "immediateCondition"))) {
[16:13:41.487]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:41.487]                   ...future.conditions[[length(...future.conditions) + 
[16:13:41.487]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:41.487]                   if (TRUE && !signal) {
[16:13:41.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:41.487]                     {
[16:13:41.487]                       inherits <- base::inherits
[16:13:41.487]                       invokeRestart <- base::invokeRestart
[16:13:41.487]                       is.null <- base::is.null
[16:13:41.487]                       muffled <- FALSE
[16:13:41.487]                       if (inherits(cond, "message")) {
[16:13:41.487]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:41.487]                         if (muffled) 
[16:13:41.487]                           invokeRestart("muffleMessage")
[16:13:41.487]                       }
[16:13:41.487]                       else if (inherits(cond, "warning")) {
[16:13:41.487]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:41.487]                         if (muffled) 
[16:13:41.487]                           invokeRestart("muffleWarning")
[16:13:41.487]                       }
[16:13:41.487]                       else if (inherits(cond, "condition")) {
[16:13:41.487]                         if (!is.null(pattern)) {
[16:13:41.487]                           computeRestarts <- base::computeRestarts
[16:13:41.487]                           grepl <- base::grepl
[16:13:41.487]                           restarts <- computeRestarts(cond)
[16:13:41.487]                           for (restart in restarts) {
[16:13:41.487]                             name <- restart$name
[16:13:41.487]                             if (is.null(name)) 
[16:13:41.487]                               next
[16:13:41.487]                             if (!grepl(pattern, name)) 
[16:13:41.487]                               next
[16:13:41.487]                             invokeRestart(restart)
[16:13:41.487]                             muffled <- TRUE
[16:13:41.487]                             break
[16:13:41.487]                           }
[16:13:41.487]                         }
[16:13:41.487]                       }
[16:13:41.487]                       invisible(muffled)
[16:13:41.487]                     }
[16:13:41.487]                     muffleCondition(cond, pattern = "^muffle")
[16:13:41.487]                   }
[16:13:41.487]                 }
[16:13:41.487]                 else {
[16:13:41.487]                   if (TRUE) {
[16:13:41.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:41.487]                     {
[16:13:41.487]                       inherits <- base::inherits
[16:13:41.487]                       invokeRestart <- base::invokeRestart
[16:13:41.487]                       is.null <- base::is.null
[16:13:41.487]                       muffled <- FALSE
[16:13:41.487]                       if (inherits(cond, "message")) {
[16:13:41.487]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:41.487]                         if (muffled) 
[16:13:41.487]                           invokeRestart("muffleMessage")
[16:13:41.487]                       }
[16:13:41.487]                       else if (inherits(cond, "warning")) {
[16:13:41.487]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:41.487]                         if (muffled) 
[16:13:41.487]                           invokeRestart("muffleWarning")
[16:13:41.487]                       }
[16:13:41.487]                       else if (inherits(cond, "condition")) {
[16:13:41.487]                         if (!is.null(pattern)) {
[16:13:41.487]                           computeRestarts <- base::computeRestarts
[16:13:41.487]                           grepl <- base::grepl
[16:13:41.487]                           restarts <- computeRestarts(cond)
[16:13:41.487]                           for (restart in restarts) {
[16:13:41.487]                             name <- restart$name
[16:13:41.487]                             if (is.null(name)) 
[16:13:41.487]                               next
[16:13:41.487]                             if (!grepl(pattern, name)) 
[16:13:41.487]                               next
[16:13:41.487]                             invokeRestart(restart)
[16:13:41.487]                             muffled <- TRUE
[16:13:41.487]                             break
[16:13:41.487]                           }
[16:13:41.487]                         }
[16:13:41.487]                       }
[16:13:41.487]                       invisible(muffled)
[16:13:41.487]                     }
[16:13:41.487]                     muffleCondition(cond, pattern = "^muffle")
[16:13:41.487]                   }
[16:13:41.487]                 }
[16:13:41.487]             }
[16:13:41.487]         }))
[16:13:41.487]     }, error = function(ex) {
[16:13:41.487]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:41.487]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:41.487]                 ...future.rng), started = ...future.startTime, 
[16:13:41.487]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:41.487]             version = "1.8"), class = "FutureResult")
[16:13:41.487]     }, finally = {
[16:13:41.487]         if (!identical(...future.workdir, getwd())) 
[16:13:41.487]             setwd(...future.workdir)
[16:13:41.487]         {
[16:13:41.487]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:41.487]                 ...future.oldOptions$nwarnings <- NULL
[16:13:41.487]             }
[16:13:41.487]             base::options(...future.oldOptions)
[16:13:41.487]             if (.Platform$OS.type == "windows") {
[16:13:41.487]                 old_names <- names(...future.oldEnvVars)
[16:13:41.487]                 envs <- base::Sys.getenv()
[16:13:41.487]                 names <- names(envs)
[16:13:41.487]                 common <- intersect(names, old_names)
[16:13:41.487]                 added <- setdiff(names, old_names)
[16:13:41.487]                 removed <- setdiff(old_names, names)
[16:13:41.487]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:41.487]                   envs[common]]
[16:13:41.487]                 NAMES <- toupper(changed)
[16:13:41.487]                 args <- list()
[16:13:41.487]                 for (kk in seq_along(NAMES)) {
[16:13:41.487]                   name <- changed[[kk]]
[16:13:41.487]                   NAME <- NAMES[[kk]]
[16:13:41.487]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:41.487]                     next
[16:13:41.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:41.487]                 }
[16:13:41.487]                 NAMES <- toupper(added)
[16:13:41.487]                 for (kk in seq_along(NAMES)) {
[16:13:41.487]                   name <- added[[kk]]
[16:13:41.487]                   NAME <- NAMES[[kk]]
[16:13:41.487]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:41.487]                     next
[16:13:41.487]                   args[[name]] <- ""
[16:13:41.487]                 }
[16:13:41.487]                 NAMES <- toupper(removed)
[16:13:41.487]                 for (kk in seq_along(NAMES)) {
[16:13:41.487]                   name <- removed[[kk]]
[16:13:41.487]                   NAME <- NAMES[[kk]]
[16:13:41.487]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:41.487]                     next
[16:13:41.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:41.487]                 }
[16:13:41.487]                 if (length(args) > 0) 
[16:13:41.487]                   base::do.call(base::Sys.setenv, args = args)
[16:13:41.487]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:41.487]             }
[16:13:41.487]             else {
[16:13:41.487]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:41.487]             }
[16:13:41.487]             {
[16:13:41.487]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:41.487]                   0L) {
[16:13:41.487]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:41.487]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:41.487]                   base::options(opts)
[16:13:41.487]                 }
[16:13:41.487]                 {
[16:13:41.487]                   {
[16:13:41.487]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:41.487]                     NULL
[16:13:41.487]                   }
[16:13:41.487]                   options(future.plan = NULL)
[16:13:41.487]                   if (is.na(NA_character_)) 
[16:13:41.487]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:41.487]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:41.487]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:41.487]                     envir = parent.frame()) 
[16:13:41.487]                   {
[16:13:41.487]                     default_workers <- missing(workers)
[16:13:41.487]                     if (is.function(workers)) 
[16:13:41.487]                       workers <- workers()
[16:13:41.487]                     workers <- structure(as.integer(workers), 
[16:13:41.487]                       class = class(workers))
[16:13:41.487]                     stop_if_not(is.finite(workers), workers >= 
[16:13:41.487]                       1L)
[16:13:41.487]                     if ((workers == 1L && !inherits(workers, 
[16:13:41.487]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:41.487]                       if (default_workers) 
[16:13:41.487]                         supportsMulticore(warn = TRUE)
[16:13:41.487]                       return(sequential(..., envir = envir))
[16:13:41.487]                     }
[16:13:41.487]                     oopts <- options(mc.cores = workers)
[16:13:41.487]                     on.exit(options(oopts))
[16:13:41.487]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:41.487]                       envir = envir)
[16:13:41.487]                     if (!future$lazy) 
[16:13:41.487]                       future <- run(future)
[16:13:41.487]                     invisible(future)
[16:13:41.487]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:41.487]                 }
[16:13:41.487]             }
[16:13:41.487]         }
[16:13:41.487]     })
[16:13:41.487]     if (TRUE) {
[16:13:41.487]         base::sink(type = "output", split = FALSE)
[16:13:41.487]         if (TRUE) {
[16:13:41.487]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:41.487]         }
[16:13:41.487]         else {
[16:13:41.487]             ...future.result["stdout"] <- base::list(NULL)
[16:13:41.487]         }
[16:13:41.487]         base::close(...future.stdout)
[16:13:41.487]         ...future.stdout <- NULL
[16:13:41.487]     }
[16:13:41.487]     ...future.result$conditions <- ...future.conditions
[16:13:41.487]     ...future.result$finished <- base::Sys.time()
[16:13:41.487]     ...future.result
[16:13:41.487] }
[16:13:41.491] assign_globals() ...
[16:13:41.491] List of 1
[16:13:41.491]  $ kk: int 2
[16:13:41.491]  - attr(*, "where")=List of 1
[16:13:41.491]   ..$ kk:<environment: R_EmptyEnv> 
[16:13:41.491]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:41.491]  - attr(*, "resolved")= logi FALSE
[16:13:41.491]  - attr(*, "total_size")= num 56
[16:13:41.491]  - attr(*, "already-done")= logi TRUE
[16:13:41.495] - copied ‘kk’ to environment
[16:13:41.495] assign_globals() ... done
[16:13:41.495] requestCore(): workers = 2
[16:13:41.496] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:41.514] MulticoreFuture started
[16:13:41.515] - Launch lazy future ... done
[16:13:41.516] plan(): Setting new future strategy stack:
[16:13:41.516] run() for ‘MulticoreFuture’ ... done
[16:13:41.517] getGlobalsAndPackages() ...
[16:13:41.516] List of future strategies:
[16:13:41.516] 1. sequential:
[16:13:41.516]    - args: function (..., envir = parent.frame())
[16:13:41.516]    - tweaked: FALSE
[16:13:41.516]    - call: NULL
[16:13:41.517] Searching for globals...
[16:13:41.518] plan(): nbrOfWorkers() = 1
[16:13:41.521] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:13:41.521] Searching for globals ... DONE
[16:13:41.521] Resolving globals: FALSE
[16:13:41.522] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:41.523] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:13:41.523] - globals: [1] ‘kk’
[16:13:41.523] 
[16:13:41.523] getGlobalsAndPackages() ... DONE
[16:13:41.524] run() for ‘Future’ ...
[16:13:41.524] - state: ‘created’
[16:13:41.525] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:41.531] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:41.531] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:41.531]   - Field: ‘label’
[16:13:41.531]   - Field: ‘local’
[16:13:41.531]   - Field: ‘owner’
[16:13:41.532]   - Field: ‘envir’
[16:13:41.532]   - Field: ‘workers’
[16:13:41.532]   - Field: ‘packages’
[16:13:41.532]   - Field: ‘gc’
[16:13:41.532]   - Field: ‘job’
[16:13:41.533]   - Field: ‘conditions’
[16:13:41.533]   - Field: ‘expr’
[16:13:41.533]   - Field: ‘uuid’
[16:13:41.533]   - Field: ‘seed’
[16:13:41.533]   - Field: ‘version’
[16:13:41.534]   - Field: ‘result’
[16:13:41.534]   - Field: ‘asynchronous’
[16:13:41.534]   - Field: ‘calls’
[16:13:41.534]   - Field: ‘globals’
[16:13:41.534]   - Field: ‘stdout’
[16:13:41.534]   - Field: ‘earlySignal’
[16:13:41.534]   - Field: ‘lazy’
[16:13:41.535]   - Field: ‘state’
[16:13:41.535] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:41.535] - Launch lazy future ...
[16:13:41.535] Packages needed by the future expression (n = 0): <none>
[16:13:41.536] Packages needed by future strategies (n = 0): <none>
[16:13:41.536] {
[16:13:41.536]     {
[16:13:41.536]         {
[16:13:41.536]             ...future.startTime <- base::Sys.time()
[16:13:41.536]             {
[16:13:41.536]                 {
[16:13:41.536]                   {
[16:13:41.536]                     {
[16:13:41.536]                       base::local({
[16:13:41.536]                         has_future <- base::requireNamespace("future", 
[16:13:41.536]                           quietly = TRUE)
[16:13:41.536]                         if (has_future) {
[16:13:41.536]                           ns <- base::getNamespace("future")
[16:13:41.536]                           version <- ns[[".package"]][["version"]]
[16:13:41.536]                           if (is.null(version)) 
[16:13:41.536]                             version <- utils::packageVersion("future")
[16:13:41.536]                         }
[16:13:41.536]                         else {
[16:13:41.536]                           version <- NULL
[16:13:41.536]                         }
[16:13:41.536]                         if (!has_future || version < "1.8.0") {
[16:13:41.536]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:41.536]                             "", base::R.version$version.string), 
[16:13:41.536]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:41.536]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:41.536]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:41.536]                               "release", "version")], collapse = " "), 
[16:13:41.536]                             hostname = base::Sys.info()[["nodename"]])
[16:13:41.536]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:41.536]                             info)
[16:13:41.536]                           info <- base::paste(info, collapse = "; ")
[16:13:41.536]                           if (!has_future) {
[16:13:41.536]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:41.536]                               info)
[16:13:41.536]                           }
[16:13:41.536]                           else {
[16:13:41.536]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:41.536]                               info, version)
[16:13:41.536]                           }
[16:13:41.536]                           base::stop(msg)
[16:13:41.536]                         }
[16:13:41.536]                       })
[16:13:41.536]                     }
[16:13:41.536]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:41.536]                     base::options(mc.cores = 1L)
[16:13:41.536]                   }
[16:13:41.536]                   options(future.plan = NULL)
[16:13:41.536]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:41.536]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:41.536]                 }
[16:13:41.536]                 ...future.workdir <- getwd()
[16:13:41.536]             }
[16:13:41.536]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:41.536]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:41.536]         }
[16:13:41.536]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:41.536]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:41.536]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:41.536]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:41.536]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:41.536]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:41.536]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:41.536]             base::names(...future.oldOptions))
[16:13:41.536]     }
[16:13:41.536]     if (FALSE) {
[16:13:41.536]     }
[16:13:41.536]     else {
[16:13:41.536]         if (TRUE) {
[16:13:41.536]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:41.536]                 open = "w")
[16:13:41.536]         }
[16:13:41.536]         else {
[16:13:41.536]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:41.536]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:41.536]         }
[16:13:41.536]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:41.536]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:41.536]             base::sink(type = "output", split = FALSE)
[16:13:41.536]             base::close(...future.stdout)
[16:13:41.536]         }, add = TRUE)
[16:13:41.536]     }
[16:13:41.536]     ...future.frame <- base::sys.nframe()
[16:13:41.536]     ...future.conditions <- base::list()
[16:13:41.536]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:41.536]     if (FALSE) {
[16:13:41.536]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:41.536]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:41.536]     }
[16:13:41.536]     ...future.result <- base::tryCatch({
[16:13:41.536]         base::withCallingHandlers({
[16:13:41.536]             ...future.value <- base::withVisible(base::local({
[16:13:41.536]                 withCallingHandlers({
[16:13:41.536]                   {
[16:13:41.536]                     Sys.sleep(0.1)
[16:13:41.536]                     kk
[16:13:41.536]                   }
[16:13:41.536]                 }, immediateCondition = function(cond) {
[16:13:41.536]                   save_rds <- function (object, pathname, ...) 
[16:13:41.536]                   {
[16:13:41.536]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:41.536]                     if (file_test("-f", pathname_tmp)) {
[16:13:41.536]                       fi_tmp <- file.info(pathname_tmp)
[16:13:41.536]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:41.536]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:41.536]                         fi_tmp[["mtime"]])
[16:13:41.536]                     }
[16:13:41.536]                     tryCatch({
[16:13:41.536]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:41.536]                     }, error = function(ex) {
[16:13:41.536]                       msg <- conditionMessage(ex)
[16:13:41.536]                       fi_tmp <- file.info(pathname_tmp)
[16:13:41.536]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:41.536]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:41.536]                         fi_tmp[["mtime"]], msg)
[16:13:41.536]                       ex$message <- msg
[16:13:41.536]                       stop(ex)
[16:13:41.536]                     })
[16:13:41.536]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:41.536]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:41.536]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:41.536]                       fi_tmp <- file.info(pathname_tmp)
[16:13:41.536]                       fi <- file.info(pathname)
[16:13:41.536]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:41.536]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:41.536]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:41.536]                         fi[["size"]], fi[["mtime"]])
[16:13:41.536]                       stop(msg)
[16:13:41.536]                     }
[16:13:41.536]                     invisible(pathname)
[16:13:41.536]                   }
[16:13:41.536]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:41.536]                     rootPath = tempdir()) 
[16:13:41.536]                   {
[16:13:41.536]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:41.536]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:41.536]                       tmpdir = path, fileext = ".rds")
[16:13:41.536]                     save_rds(obj, file)
[16:13:41.536]                   }
[16:13:41.536]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:41.536]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:41.536]                   {
[16:13:41.536]                     inherits <- base::inherits
[16:13:41.536]                     invokeRestart <- base::invokeRestart
[16:13:41.536]                     is.null <- base::is.null
[16:13:41.536]                     muffled <- FALSE
[16:13:41.536]                     if (inherits(cond, "message")) {
[16:13:41.536]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:41.536]                       if (muffled) 
[16:13:41.536]                         invokeRestart("muffleMessage")
[16:13:41.536]                     }
[16:13:41.536]                     else if (inherits(cond, "warning")) {
[16:13:41.536]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:41.536]                       if (muffled) 
[16:13:41.536]                         invokeRestart("muffleWarning")
[16:13:41.536]                     }
[16:13:41.536]                     else if (inherits(cond, "condition")) {
[16:13:41.536]                       if (!is.null(pattern)) {
[16:13:41.536]                         computeRestarts <- base::computeRestarts
[16:13:41.536]                         grepl <- base::grepl
[16:13:41.536]                         restarts <- computeRestarts(cond)
[16:13:41.536]                         for (restart in restarts) {
[16:13:41.536]                           name <- restart$name
[16:13:41.536]                           if (is.null(name)) 
[16:13:41.536]                             next
[16:13:41.536]                           if (!grepl(pattern, name)) 
[16:13:41.536]                             next
[16:13:41.536]                           invokeRestart(restart)
[16:13:41.536]                           muffled <- TRUE
[16:13:41.536]                           break
[16:13:41.536]                         }
[16:13:41.536]                       }
[16:13:41.536]                     }
[16:13:41.536]                     invisible(muffled)
[16:13:41.536]                   }
[16:13:41.536]                   muffleCondition(cond)
[16:13:41.536]                 })
[16:13:41.536]             }))
[16:13:41.536]             future::FutureResult(value = ...future.value$value, 
[16:13:41.536]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:41.536]                   ...future.rng), globalenv = if (FALSE) 
[16:13:41.536]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:41.536]                     ...future.globalenv.names))
[16:13:41.536]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:41.536]         }, condition = base::local({
[16:13:41.536]             c <- base::c
[16:13:41.536]             inherits <- base::inherits
[16:13:41.536]             invokeRestart <- base::invokeRestart
[16:13:41.536]             length <- base::length
[16:13:41.536]             list <- base::list
[16:13:41.536]             seq.int <- base::seq.int
[16:13:41.536]             signalCondition <- base::signalCondition
[16:13:41.536]             sys.calls <- base::sys.calls
[16:13:41.536]             `[[` <- base::`[[`
[16:13:41.536]             `+` <- base::`+`
[16:13:41.536]             `<<-` <- base::`<<-`
[16:13:41.536]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:41.536]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:41.536]                   3L)]
[16:13:41.536]             }
[16:13:41.536]             function(cond) {
[16:13:41.536]                 is_error <- inherits(cond, "error")
[16:13:41.536]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:41.536]                   NULL)
[16:13:41.536]                 if (is_error) {
[16:13:41.536]                   sessionInformation <- function() {
[16:13:41.536]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:41.536]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:41.536]                       search = base::search(), system = base::Sys.info())
[16:13:41.536]                   }
[16:13:41.536]                   ...future.conditions[[length(...future.conditions) + 
[16:13:41.536]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:41.536]                     cond$call), session = sessionInformation(), 
[16:13:41.536]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:41.536]                   signalCondition(cond)
[16:13:41.536]                 }
[16:13:41.536]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:41.536]                 "immediateCondition"))) {
[16:13:41.536]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:41.536]                   ...future.conditions[[length(...future.conditions) + 
[16:13:41.536]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:41.536]                   if (TRUE && !signal) {
[16:13:41.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:41.536]                     {
[16:13:41.536]                       inherits <- base::inherits
[16:13:41.536]                       invokeRestart <- base::invokeRestart
[16:13:41.536]                       is.null <- base::is.null
[16:13:41.536]                       muffled <- FALSE
[16:13:41.536]                       if (inherits(cond, "message")) {
[16:13:41.536]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:41.536]                         if (muffled) 
[16:13:41.536]                           invokeRestart("muffleMessage")
[16:13:41.536]                       }
[16:13:41.536]                       else if (inherits(cond, "warning")) {
[16:13:41.536]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:41.536]                         if (muffled) 
[16:13:41.536]                           invokeRestart("muffleWarning")
[16:13:41.536]                       }
[16:13:41.536]                       else if (inherits(cond, "condition")) {
[16:13:41.536]                         if (!is.null(pattern)) {
[16:13:41.536]                           computeRestarts <- base::computeRestarts
[16:13:41.536]                           grepl <- base::grepl
[16:13:41.536]                           restarts <- computeRestarts(cond)
[16:13:41.536]                           for (restart in restarts) {
[16:13:41.536]                             name <- restart$name
[16:13:41.536]                             if (is.null(name)) 
[16:13:41.536]                               next
[16:13:41.536]                             if (!grepl(pattern, name)) 
[16:13:41.536]                               next
[16:13:41.536]                             invokeRestart(restart)
[16:13:41.536]                             muffled <- TRUE
[16:13:41.536]                             break
[16:13:41.536]                           }
[16:13:41.536]                         }
[16:13:41.536]                       }
[16:13:41.536]                       invisible(muffled)
[16:13:41.536]                     }
[16:13:41.536]                     muffleCondition(cond, pattern = "^muffle")
[16:13:41.536]                   }
[16:13:41.536]                 }
[16:13:41.536]                 else {
[16:13:41.536]                   if (TRUE) {
[16:13:41.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:41.536]                     {
[16:13:41.536]                       inherits <- base::inherits
[16:13:41.536]                       invokeRestart <- base::invokeRestart
[16:13:41.536]                       is.null <- base::is.null
[16:13:41.536]                       muffled <- FALSE
[16:13:41.536]                       if (inherits(cond, "message")) {
[16:13:41.536]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:41.536]                         if (muffled) 
[16:13:41.536]                           invokeRestart("muffleMessage")
[16:13:41.536]                       }
[16:13:41.536]                       else if (inherits(cond, "warning")) {
[16:13:41.536]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:41.536]                         if (muffled) 
[16:13:41.536]                           invokeRestart("muffleWarning")
[16:13:41.536]                       }
[16:13:41.536]                       else if (inherits(cond, "condition")) {
[16:13:41.536]                         if (!is.null(pattern)) {
[16:13:41.536]                           computeRestarts <- base::computeRestarts
[16:13:41.536]                           grepl <- base::grepl
[16:13:41.536]                           restarts <- computeRestarts(cond)
[16:13:41.536]                           for (restart in restarts) {
[16:13:41.536]                             name <- restart$name
[16:13:41.536]                             if (is.null(name)) 
[16:13:41.536]                               next
[16:13:41.536]                             if (!grepl(pattern, name)) 
[16:13:41.536]                               next
[16:13:41.536]                             invokeRestart(restart)
[16:13:41.536]                             muffled <- TRUE
[16:13:41.536]                             break
[16:13:41.536]                           }
[16:13:41.536]                         }
[16:13:41.536]                       }
[16:13:41.536]                       invisible(muffled)
[16:13:41.536]                     }
[16:13:41.536]                     muffleCondition(cond, pattern = "^muffle")
[16:13:41.536]                   }
[16:13:41.536]                 }
[16:13:41.536]             }
[16:13:41.536]         }))
[16:13:41.536]     }, error = function(ex) {
[16:13:41.536]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:41.536]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:41.536]                 ...future.rng), started = ...future.startTime, 
[16:13:41.536]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:41.536]             version = "1.8"), class = "FutureResult")
[16:13:41.536]     }, finally = {
[16:13:41.536]         if (!identical(...future.workdir, getwd())) 
[16:13:41.536]             setwd(...future.workdir)
[16:13:41.536]         {
[16:13:41.536]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:41.536]                 ...future.oldOptions$nwarnings <- NULL
[16:13:41.536]             }
[16:13:41.536]             base::options(...future.oldOptions)
[16:13:41.536]             if (.Platform$OS.type == "windows") {
[16:13:41.536]                 old_names <- names(...future.oldEnvVars)
[16:13:41.536]                 envs <- base::Sys.getenv()
[16:13:41.536]                 names <- names(envs)
[16:13:41.536]                 common <- intersect(names, old_names)
[16:13:41.536]                 added <- setdiff(names, old_names)
[16:13:41.536]                 removed <- setdiff(old_names, names)
[16:13:41.536]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:41.536]                   envs[common]]
[16:13:41.536]                 NAMES <- toupper(changed)
[16:13:41.536]                 args <- list()
[16:13:41.536]                 for (kk in seq_along(NAMES)) {
[16:13:41.536]                   name <- changed[[kk]]
[16:13:41.536]                   NAME <- NAMES[[kk]]
[16:13:41.536]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:41.536]                     next
[16:13:41.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:41.536]                 }
[16:13:41.536]                 NAMES <- toupper(added)
[16:13:41.536]                 for (kk in seq_along(NAMES)) {
[16:13:41.536]                   name <- added[[kk]]
[16:13:41.536]                   NAME <- NAMES[[kk]]
[16:13:41.536]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:41.536]                     next
[16:13:41.536]                   args[[name]] <- ""
[16:13:41.536]                 }
[16:13:41.536]                 NAMES <- toupper(removed)
[16:13:41.536]                 for (kk in seq_along(NAMES)) {
[16:13:41.536]                   name <- removed[[kk]]
[16:13:41.536]                   NAME <- NAMES[[kk]]
[16:13:41.536]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:41.536]                     next
[16:13:41.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:41.536]                 }
[16:13:41.536]                 if (length(args) > 0) 
[16:13:41.536]                   base::do.call(base::Sys.setenv, args = args)
[16:13:41.536]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:41.536]             }
[16:13:41.536]             else {
[16:13:41.536]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:41.536]             }
[16:13:41.536]             {
[16:13:41.536]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:41.536]                   0L) {
[16:13:41.536]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:41.536]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:41.536]                   base::options(opts)
[16:13:41.536]                 }
[16:13:41.536]                 {
[16:13:41.536]                   {
[16:13:41.536]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:41.536]                     NULL
[16:13:41.536]                   }
[16:13:41.536]                   options(future.plan = NULL)
[16:13:41.536]                   if (is.na(NA_character_)) 
[16:13:41.536]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:41.536]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:41.536]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:41.536]                     envir = parent.frame()) 
[16:13:41.536]                   {
[16:13:41.536]                     default_workers <- missing(workers)
[16:13:41.536]                     if (is.function(workers)) 
[16:13:41.536]                       workers <- workers()
[16:13:41.536]                     workers <- structure(as.integer(workers), 
[16:13:41.536]                       class = class(workers))
[16:13:41.536]                     stop_if_not(is.finite(workers), workers >= 
[16:13:41.536]                       1L)
[16:13:41.536]                     if ((workers == 1L && !inherits(workers, 
[16:13:41.536]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:41.536]                       if (default_workers) 
[16:13:41.536]                         supportsMulticore(warn = TRUE)
[16:13:41.536]                       return(sequential(..., envir = envir))
[16:13:41.536]                     }
[16:13:41.536]                     oopts <- options(mc.cores = workers)
[16:13:41.536]                     on.exit(options(oopts))
[16:13:41.536]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:41.536]                       envir = envir)
[16:13:41.536]                     if (!future$lazy) 
[16:13:41.536]                       future <- run(future)
[16:13:41.536]                     invisible(future)
[16:13:41.536]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:41.536]                 }
[16:13:41.536]             }
[16:13:41.536]         }
[16:13:41.536]     })
[16:13:41.536]     if (TRUE) {
[16:13:41.536]         base::sink(type = "output", split = FALSE)
[16:13:41.536]         if (TRUE) {
[16:13:41.536]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:41.536]         }
[16:13:41.536]         else {
[16:13:41.536]             ...future.result["stdout"] <- base::list(NULL)
[16:13:41.536]         }
[16:13:41.536]         base::close(...future.stdout)
[16:13:41.536]         ...future.stdout <- NULL
[16:13:41.536]     }
[16:13:41.536]     ...future.result$conditions <- ...future.conditions
[16:13:41.536]     ...future.result$finished <- base::Sys.time()
[16:13:41.536]     ...future.result
[16:13:41.536] }
[16:13:41.540] assign_globals() ...
[16:13:41.541] List of 1
[16:13:41.541]  $ kk: int 3
[16:13:41.541]  - attr(*, "where")=List of 1
[16:13:41.541]   ..$ kk:<environment: R_EmptyEnv> 
[16:13:41.541]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:41.541]  - attr(*, "resolved")= logi FALSE
[16:13:41.541]  - attr(*, "total_size")= num 56
[16:13:41.541]  - attr(*, "already-done")= logi TRUE
[16:13:41.545] - copied ‘kk’ to environment
[16:13:41.545] assign_globals() ... done
[16:13:41.545] requestCore(): workers = 2
[16:13:41.545] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:41.574] plan(): Setting new future strategy stack:
[16:13:41.575] List of future strategies:
[16:13:41.575] 1. multicore:
[16:13:41.575]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:41.575]    - tweaked: FALSE
[16:13:41.575]    - call: plan(strategy)
[16:13:41.577] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[16:13:41.579] plan(): nbrOfWorkers() = 2
[16:13:41.592] MulticoreFuture started
[16:13:41.593] - Launch lazy future ... done
[16:13:41.593] run() for ‘MulticoreFuture’ ... done
[16:13:41.593] plan(): Setting new future strategy stack:
[16:13:41.593] resolve() on list ...
[16:13:41.594]  recursive: 0
[16:13:41.594]  length: 3
[16:13:41.594] 
[16:13:41.593] List of future strategies:
[16:13:41.593] 1. sequential:
[16:13:41.593]    - args: function (..., envir = parent.frame())
[16:13:41.593]    - tweaked: FALSE
[16:13:41.593]    - call: NULL
[16:13:41.594] Future #1
[16:13:41.594]  length: 2 (resolved future 1)
[16:13:41.595] plan(): nbrOfWorkers() = 1
[16:13:41.621] plan(): Setting new future strategy stack:
[16:13:41.621] List of future strategies:
[16:13:41.621] 1. multicore:
[16:13:41.621]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:41.621]    - tweaked: FALSE
[16:13:41.621]    - call: plan(strategy)
[16:13:41.626] plan(): nbrOfWorkers() = 2
[16:13:41.626] Future #2
[16:13:41.627]  length: 1 (resolved future 2)
[16:13:41.697] plan(): Setting new future strategy stack:
[16:13:41.697] List of future strategies:
[16:13:41.697] 1. multicore:
[16:13:41.697]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:41.697]    - tweaked: FALSE
[16:13:41.697]    - call: plan(strategy)
[16:13:41.703] plan(): nbrOfWorkers() = 2
[16:13:41.709] Future #3
[16:13:41.709]  length: 0 (resolved future 3)
[16:13:41.709] resolve() on list ... DONE
[16:13:41.709] getGlobalsAndPackages() ...
[16:13:41.710] Searching for globals...
[16:13:41.712] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:13:41.712] Searching for globals ... DONE
[16:13:41.712] Resolving globals: FALSE
[16:13:41.713] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:41.713] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:13:41.714] - globals: [1] ‘kk’
[16:13:41.714] 
[16:13:41.714] getGlobalsAndPackages() ... DONE
[16:13:41.715] getGlobalsAndPackages() ...
[16:13:41.715] Searching for globals...
[16:13:41.716] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:13:41.716] Searching for globals ... DONE
[16:13:41.717] Resolving globals: FALSE
[16:13:41.717] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:41.718] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:13:41.718] - globals: [1] ‘kk’
[16:13:41.718] 
[16:13:41.718] getGlobalsAndPackages() ... DONE
[16:13:41.718] getGlobalsAndPackages() ...
[16:13:41.719] Searching for globals...
[16:13:41.720] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:13:41.720] Searching for globals ... DONE
[16:13:41.720] Resolving globals: FALSE
[16:13:41.721] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:41.721] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:13:41.722] - globals: [1] ‘kk’
[16:13:41.722] 
[16:13:41.722] getGlobalsAndPackages() ... DONE
[16:13:41.722] resolve() on list ...
[16:13:41.722]  recursive: 0
[16:13:41.722]  length: 3
[16:13:41.726] 
[16:13:41.726] run() for ‘Future’ ...
[16:13:41.727] - state: ‘created’
[16:13:41.727] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:41.733] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:41.733] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:41.733]   - Field: ‘label’
[16:13:41.733]   - Field: ‘local’
[16:13:41.733]   - Field: ‘owner’
[16:13:41.734]   - Field: ‘envir’
[16:13:41.734]   - Field: ‘workers’
[16:13:41.734]   - Field: ‘packages’
[16:13:41.734]   - Field: ‘gc’
[16:13:41.734]   - Field: ‘job’
[16:13:41.734]   - Field: ‘conditions’
[16:13:41.735]   - Field: ‘expr’
[16:13:41.735]   - Field: ‘uuid’
[16:13:41.735]   - Field: ‘seed’
[16:13:41.735]   - Field: ‘version’
[16:13:41.735]   - Field: ‘result’
[16:13:41.735]   - Field: ‘asynchronous’
[16:13:41.735]   - Field: ‘calls’
[16:13:41.736]   - Field: ‘globals’
[16:13:41.736]   - Field: ‘stdout’
[16:13:41.736]   - Field: ‘earlySignal’
[16:13:41.736]   - Field: ‘lazy’
[16:13:41.736]   - Field: ‘state’
[16:13:41.736] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:41.737] - Launch lazy future ...
[16:13:41.737] Packages needed by the future expression (n = 0): <none>
[16:13:41.737] Packages needed by future strategies (n = 0): <none>
[16:13:41.738] {
[16:13:41.738]     {
[16:13:41.738]         {
[16:13:41.738]             ...future.startTime <- base::Sys.time()
[16:13:41.738]             {
[16:13:41.738]                 {
[16:13:41.738]                   {
[16:13:41.738]                     {
[16:13:41.738]                       base::local({
[16:13:41.738]                         has_future <- base::requireNamespace("future", 
[16:13:41.738]                           quietly = TRUE)
[16:13:41.738]                         if (has_future) {
[16:13:41.738]                           ns <- base::getNamespace("future")
[16:13:41.738]                           version <- ns[[".package"]][["version"]]
[16:13:41.738]                           if (is.null(version)) 
[16:13:41.738]                             version <- utils::packageVersion("future")
[16:13:41.738]                         }
[16:13:41.738]                         else {
[16:13:41.738]                           version <- NULL
[16:13:41.738]                         }
[16:13:41.738]                         if (!has_future || version < "1.8.0") {
[16:13:41.738]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:41.738]                             "", base::R.version$version.string), 
[16:13:41.738]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:41.738]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:41.738]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:41.738]                               "release", "version")], collapse = " "), 
[16:13:41.738]                             hostname = base::Sys.info()[["nodename"]])
[16:13:41.738]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:41.738]                             info)
[16:13:41.738]                           info <- base::paste(info, collapse = "; ")
[16:13:41.738]                           if (!has_future) {
[16:13:41.738]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:41.738]                               info)
[16:13:41.738]                           }
[16:13:41.738]                           else {
[16:13:41.738]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:41.738]                               info, version)
[16:13:41.738]                           }
[16:13:41.738]                           base::stop(msg)
[16:13:41.738]                         }
[16:13:41.738]                       })
[16:13:41.738]                     }
[16:13:41.738]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:41.738]                     base::options(mc.cores = 1L)
[16:13:41.738]                   }
[16:13:41.738]                   options(future.plan = NULL)
[16:13:41.738]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:41.738]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:41.738]                 }
[16:13:41.738]                 ...future.workdir <- getwd()
[16:13:41.738]             }
[16:13:41.738]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:41.738]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:41.738]         }
[16:13:41.738]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:41.738]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:41.738]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:41.738]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:41.738]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:41.738]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:41.738]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:41.738]             base::names(...future.oldOptions))
[16:13:41.738]     }
[16:13:41.738]     if (FALSE) {
[16:13:41.738]     }
[16:13:41.738]     else {
[16:13:41.738]         if (TRUE) {
[16:13:41.738]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:41.738]                 open = "w")
[16:13:41.738]         }
[16:13:41.738]         else {
[16:13:41.738]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:41.738]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:41.738]         }
[16:13:41.738]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:41.738]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:41.738]             base::sink(type = "output", split = FALSE)
[16:13:41.738]             base::close(...future.stdout)
[16:13:41.738]         }, add = TRUE)
[16:13:41.738]     }
[16:13:41.738]     ...future.frame <- base::sys.nframe()
[16:13:41.738]     ...future.conditions <- base::list()
[16:13:41.738]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:41.738]     if (FALSE) {
[16:13:41.738]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:41.738]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:41.738]     }
[16:13:41.738]     ...future.result <- base::tryCatch({
[16:13:41.738]         base::withCallingHandlers({
[16:13:41.738]             ...future.value <- base::withVisible(base::local({
[16:13:41.738]                 withCallingHandlers({
[16:13:41.738]                   {
[16:13:41.738]                     Sys.sleep(0.1)
[16:13:41.738]                     kk
[16:13:41.738]                   }
[16:13:41.738]                 }, immediateCondition = function(cond) {
[16:13:41.738]                   save_rds <- function (object, pathname, ...) 
[16:13:41.738]                   {
[16:13:41.738]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:41.738]                     if (file_test("-f", pathname_tmp)) {
[16:13:41.738]                       fi_tmp <- file.info(pathname_tmp)
[16:13:41.738]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:41.738]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:41.738]                         fi_tmp[["mtime"]])
[16:13:41.738]                     }
[16:13:41.738]                     tryCatch({
[16:13:41.738]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:41.738]                     }, error = function(ex) {
[16:13:41.738]                       msg <- conditionMessage(ex)
[16:13:41.738]                       fi_tmp <- file.info(pathname_tmp)
[16:13:41.738]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:41.738]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:41.738]                         fi_tmp[["mtime"]], msg)
[16:13:41.738]                       ex$message <- msg
[16:13:41.738]                       stop(ex)
[16:13:41.738]                     })
[16:13:41.738]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:41.738]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:41.738]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:41.738]                       fi_tmp <- file.info(pathname_tmp)
[16:13:41.738]                       fi <- file.info(pathname)
[16:13:41.738]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:41.738]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:41.738]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:41.738]                         fi[["size"]], fi[["mtime"]])
[16:13:41.738]                       stop(msg)
[16:13:41.738]                     }
[16:13:41.738]                     invisible(pathname)
[16:13:41.738]                   }
[16:13:41.738]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:41.738]                     rootPath = tempdir()) 
[16:13:41.738]                   {
[16:13:41.738]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:41.738]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:41.738]                       tmpdir = path, fileext = ".rds")
[16:13:41.738]                     save_rds(obj, file)
[16:13:41.738]                   }
[16:13:41.738]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:41.738]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:41.738]                   {
[16:13:41.738]                     inherits <- base::inherits
[16:13:41.738]                     invokeRestart <- base::invokeRestart
[16:13:41.738]                     is.null <- base::is.null
[16:13:41.738]                     muffled <- FALSE
[16:13:41.738]                     if (inherits(cond, "message")) {
[16:13:41.738]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:41.738]                       if (muffled) 
[16:13:41.738]                         invokeRestart("muffleMessage")
[16:13:41.738]                     }
[16:13:41.738]                     else if (inherits(cond, "warning")) {
[16:13:41.738]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:41.738]                       if (muffled) 
[16:13:41.738]                         invokeRestart("muffleWarning")
[16:13:41.738]                     }
[16:13:41.738]                     else if (inherits(cond, "condition")) {
[16:13:41.738]                       if (!is.null(pattern)) {
[16:13:41.738]                         computeRestarts <- base::computeRestarts
[16:13:41.738]                         grepl <- base::grepl
[16:13:41.738]                         restarts <- computeRestarts(cond)
[16:13:41.738]                         for (restart in restarts) {
[16:13:41.738]                           name <- restart$name
[16:13:41.738]                           if (is.null(name)) 
[16:13:41.738]                             next
[16:13:41.738]                           if (!grepl(pattern, name)) 
[16:13:41.738]                             next
[16:13:41.738]                           invokeRestart(restart)
[16:13:41.738]                           muffled <- TRUE
[16:13:41.738]                           break
[16:13:41.738]                         }
[16:13:41.738]                       }
[16:13:41.738]                     }
[16:13:41.738]                     invisible(muffled)
[16:13:41.738]                   }
[16:13:41.738]                   muffleCondition(cond)
[16:13:41.738]                 })
[16:13:41.738]             }))
[16:13:41.738]             future::FutureResult(value = ...future.value$value, 
[16:13:41.738]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:41.738]                   ...future.rng), globalenv = if (FALSE) 
[16:13:41.738]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:41.738]                     ...future.globalenv.names))
[16:13:41.738]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:41.738]         }, condition = base::local({
[16:13:41.738]             c <- base::c
[16:13:41.738]             inherits <- base::inherits
[16:13:41.738]             invokeRestart <- base::invokeRestart
[16:13:41.738]             length <- base::length
[16:13:41.738]             list <- base::list
[16:13:41.738]             seq.int <- base::seq.int
[16:13:41.738]             signalCondition <- base::signalCondition
[16:13:41.738]             sys.calls <- base::sys.calls
[16:13:41.738]             `[[` <- base::`[[`
[16:13:41.738]             `+` <- base::`+`
[16:13:41.738]             `<<-` <- base::`<<-`
[16:13:41.738]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:41.738]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:41.738]                   3L)]
[16:13:41.738]             }
[16:13:41.738]             function(cond) {
[16:13:41.738]                 is_error <- inherits(cond, "error")
[16:13:41.738]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:41.738]                   NULL)
[16:13:41.738]                 if (is_error) {
[16:13:41.738]                   sessionInformation <- function() {
[16:13:41.738]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:41.738]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:41.738]                       search = base::search(), system = base::Sys.info())
[16:13:41.738]                   }
[16:13:41.738]                   ...future.conditions[[length(...future.conditions) + 
[16:13:41.738]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:41.738]                     cond$call), session = sessionInformation(), 
[16:13:41.738]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:41.738]                   signalCondition(cond)
[16:13:41.738]                 }
[16:13:41.738]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:41.738]                 "immediateCondition"))) {
[16:13:41.738]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:41.738]                   ...future.conditions[[length(...future.conditions) + 
[16:13:41.738]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:41.738]                   if (TRUE && !signal) {
[16:13:41.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:41.738]                     {
[16:13:41.738]                       inherits <- base::inherits
[16:13:41.738]                       invokeRestart <- base::invokeRestart
[16:13:41.738]                       is.null <- base::is.null
[16:13:41.738]                       muffled <- FALSE
[16:13:41.738]                       if (inherits(cond, "message")) {
[16:13:41.738]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:41.738]                         if (muffled) 
[16:13:41.738]                           invokeRestart("muffleMessage")
[16:13:41.738]                       }
[16:13:41.738]                       else if (inherits(cond, "warning")) {
[16:13:41.738]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:41.738]                         if (muffled) 
[16:13:41.738]                           invokeRestart("muffleWarning")
[16:13:41.738]                       }
[16:13:41.738]                       else if (inherits(cond, "condition")) {
[16:13:41.738]                         if (!is.null(pattern)) {
[16:13:41.738]                           computeRestarts <- base::computeRestarts
[16:13:41.738]                           grepl <- base::grepl
[16:13:41.738]                           restarts <- computeRestarts(cond)
[16:13:41.738]                           for (restart in restarts) {
[16:13:41.738]                             name <- restart$name
[16:13:41.738]                             if (is.null(name)) 
[16:13:41.738]                               next
[16:13:41.738]                             if (!grepl(pattern, name)) 
[16:13:41.738]                               next
[16:13:41.738]                             invokeRestart(restart)
[16:13:41.738]                             muffled <- TRUE
[16:13:41.738]                             break
[16:13:41.738]                           }
[16:13:41.738]                         }
[16:13:41.738]                       }
[16:13:41.738]                       invisible(muffled)
[16:13:41.738]                     }
[16:13:41.738]                     muffleCondition(cond, pattern = "^muffle")
[16:13:41.738]                   }
[16:13:41.738]                 }
[16:13:41.738]                 else {
[16:13:41.738]                   if (TRUE) {
[16:13:41.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:41.738]                     {
[16:13:41.738]                       inherits <- base::inherits
[16:13:41.738]                       invokeRestart <- base::invokeRestart
[16:13:41.738]                       is.null <- base::is.null
[16:13:41.738]                       muffled <- FALSE
[16:13:41.738]                       if (inherits(cond, "message")) {
[16:13:41.738]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:41.738]                         if (muffled) 
[16:13:41.738]                           invokeRestart("muffleMessage")
[16:13:41.738]                       }
[16:13:41.738]                       else if (inherits(cond, "warning")) {
[16:13:41.738]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:41.738]                         if (muffled) 
[16:13:41.738]                           invokeRestart("muffleWarning")
[16:13:41.738]                       }
[16:13:41.738]                       else if (inherits(cond, "condition")) {
[16:13:41.738]                         if (!is.null(pattern)) {
[16:13:41.738]                           computeRestarts <- base::computeRestarts
[16:13:41.738]                           grepl <- base::grepl
[16:13:41.738]                           restarts <- computeRestarts(cond)
[16:13:41.738]                           for (restart in restarts) {
[16:13:41.738]                             name <- restart$name
[16:13:41.738]                             if (is.null(name)) 
[16:13:41.738]                               next
[16:13:41.738]                             if (!grepl(pattern, name)) 
[16:13:41.738]                               next
[16:13:41.738]                             invokeRestart(restart)
[16:13:41.738]                             muffled <- TRUE
[16:13:41.738]                             break
[16:13:41.738]                           }
[16:13:41.738]                         }
[16:13:41.738]                       }
[16:13:41.738]                       invisible(muffled)
[16:13:41.738]                     }
[16:13:41.738]                     muffleCondition(cond, pattern = "^muffle")
[16:13:41.738]                   }
[16:13:41.738]                 }
[16:13:41.738]             }
[16:13:41.738]         }))
[16:13:41.738]     }, error = function(ex) {
[16:13:41.738]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:41.738]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:41.738]                 ...future.rng), started = ...future.startTime, 
[16:13:41.738]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:41.738]             version = "1.8"), class = "FutureResult")
[16:13:41.738]     }, finally = {
[16:13:41.738]         if (!identical(...future.workdir, getwd())) 
[16:13:41.738]             setwd(...future.workdir)
[16:13:41.738]         {
[16:13:41.738]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:41.738]                 ...future.oldOptions$nwarnings <- NULL
[16:13:41.738]             }
[16:13:41.738]             base::options(...future.oldOptions)
[16:13:41.738]             if (.Platform$OS.type == "windows") {
[16:13:41.738]                 old_names <- names(...future.oldEnvVars)
[16:13:41.738]                 envs <- base::Sys.getenv()
[16:13:41.738]                 names <- names(envs)
[16:13:41.738]                 common <- intersect(names, old_names)
[16:13:41.738]                 added <- setdiff(names, old_names)
[16:13:41.738]                 removed <- setdiff(old_names, names)
[16:13:41.738]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:41.738]                   envs[common]]
[16:13:41.738]                 NAMES <- toupper(changed)
[16:13:41.738]                 args <- list()
[16:13:41.738]                 for (kk in seq_along(NAMES)) {
[16:13:41.738]                   name <- changed[[kk]]
[16:13:41.738]                   NAME <- NAMES[[kk]]
[16:13:41.738]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:41.738]                     next
[16:13:41.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:41.738]                 }
[16:13:41.738]                 NAMES <- toupper(added)
[16:13:41.738]                 for (kk in seq_along(NAMES)) {
[16:13:41.738]                   name <- added[[kk]]
[16:13:41.738]                   NAME <- NAMES[[kk]]
[16:13:41.738]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:41.738]                     next
[16:13:41.738]                   args[[name]] <- ""
[16:13:41.738]                 }
[16:13:41.738]                 NAMES <- toupper(removed)
[16:13:41.738]                 for (kk in seq_along(NAMES)) {
[16:13:41.738]                   name <- removed[[kk]]
[16:13:41.738]                   NAME <- NAMES[[kk]]
[16:13:41.738]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:41.738]                     next
[16:13:41.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:41.738]                 }
[16:13:41.738]                 if (length(args) > 0) 
[16:13:41.738]                   base::do.call(base::Sys.setenv, args = args)
[16:13:41.738]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:41.738]             }
[16:13:41.738]             else {
[16:13:41.738]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:41.738]             }
[16:13:41.738]             {
[16:13:41.738]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:41.738]                   0L) {
[16:13:41.738]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:41.738]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:41.738]                   base::options(opts)
[16:13:41.738]                 }
[16:13:41.738]                 {
[16:13:41.738]                   {
[16:13:41.738]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:41.738]                     NULL
[16:13:41.738]                   }
[16:13:41.738]                   options(future.plan = NULL)
[16:13:41.738]                   if (is.na(NA_character_)) 
[16:13:41.738]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:41.738]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:41.738]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:41.738]                     envir = parent.frame()) 
[16:13:41.738]                   {
[16:13:41.738]                     default_workers <- missing(workers)
[16:13:41.738]                     if (is.function(workers)) 
[16:13:41.738]                       workers <- workers()
[16:13:41.738]                     workers <- structure(as.integer(workers), 
[16:13:41.738]                       class = class(workers))
[16:13:41.738]                     stop_if_not(is.finite(workers), workers >= 
[16:13:41.738]                       1L)
[16:13:41.738]                     if ((workers == 1L && !inherits(workers, 
[16:13:41.738]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:41.738]                       if (default_workers) 
[16:13:41.738]                         supportsMulticore(warn = TRUE)
[16:13:41.738]                       return(sequential(..., envir = envir))
[16:13:41.738]                     }
[16:13:41.738]                     oopts <- options(mc.cores = workers)
[16:13:41.738]                     on.exit(options(oopts))
[16:13:41.738]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:41.738]                       envir = envir)
[16:13:41.738]                     if (!future$lazy) 
[16:13:41.738]                       future <- run(future)
[16:13:41.738]                     invisible(future)
[16:13:41.738]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:41.738]                 }
[16:13:41.738]             }
[16:13:41.738]         }
[16:13:41.738]     })
[16:13:41.738]     if (TRUE) {
[16:13:41.738]         base::sink(type = "output", split = FALSE)
[16:13:41.738]         if (TRUE) {
[16:13:41.738]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:41.738]         }
[16:13:41.738]         else {
[16:13:41.738]             ...future.result["stdout"] <- base::list(NULL)
[16:13:41.738]         }
[16:13:41.738]         base::close(...future.stdout)
[16:13:41.738]         ...future.stdout <- NULL
[16:13:41.738]     }
[16:13:41.738]     ...future.result$conditions <- ...future.conditions
[16:13:41.738]     ...future.result$finished <- base::Sys.time()
[16:13:41.738]     ...future.result
[16:13:41.738] }
[16:13:41.741] assign_globals() ...
[16:13:41.741] List of 1
[16:13:41.741]  $ kk: int 1
[16:13:41.741]  - attr(*, "where")=List of 1
[16:13:41.741]   ..$ kk:<environment: R_EmptyEnv> 
[16:13:41.741]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:41.741]  - attr(*, "resolved")= logi FALSE
[16:13:41.741]  - attr(*, "total_size")= num 56
[16:13:41.741]  - attr(*, "already-done")= logi TRUE
[16:13:41.745] - copied ‘kk’ to environment
[16:13:41.745] assign_globals() ... done
[16:13:41.745] requestCore(): workers = 2
[16:13:41.746] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:41.759] MulticoreFuture started
[16:13:41.760] - Launch lazy future ... done
[16:13:41.760] run() for ‘MulticoreFuture’ ... done
[16:13:41.761] plan(): Setting new future strategy stack:
[16:13:41.761] List of future strategies:
[16:13:41.761] 1. sequential:
[16:13:41.761]    - args: function (..., envir = parent.frame())
[16:13:41.761]    - tweaked: FALSE
[16:13:41.761]    - call: NULL
[16:13:41.762] plan(): nbrOfWorkers() = 1
[16:13:41.771] run() for ‘Future’ ...
[16:13:41.771] - state: ‘created’
[16:13:41.771] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:41.777] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:41.777] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:41.778]   - Field: ‘label’
[16:13:41.778]   - Field: ‘local’
[16:13:41.778]   - Field: ‘owner’
[16:13:41.778]   - Field: ‘envir’
[16:13:41.778]   - Field: ‘workers’
[16:13:41.778]   - Field: ‘packages’
[16:13:41.779]   - Field: ‘gc’
[16:13:41.779]   - Field: ‘job’
[16:13:41.779]   - Field: ‘conditions’
[16:13:41.779]   - Field: ‘expr’
[16:13:41.779]   - Field: ‘uuid’
[16:13:41.779]   - Field: ‘seed’
[16:13:41.780]   - Field: ‘version’
[16:13:41.780]   - Field: ‘result’
[16:13:41.780]   - Field: ‘asynchronous’
[16:13:41.780]   - Field: ‘calls’
[16:13:41.780]   - Field: ‘globals’
[16:13:41.780]   - Field: ‘stdout’
[16:13:41.781]   - Field: ‘earlySignal’
[16:13:41.781]   - Field: ‘lazy’
[16:13:41.781]   - Field: ‘state’
[16:13:41.781] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:41.781] - Launch lazy future ...
[16:13:41.782] Packages needed by the future expression (n = 0): <none>
[16:13:41.782] Packages needed by future strategies (n = 0): <none>
[16:13:41.783] {
[16:13:41.783]     {
[16:13:41.783]         {
[16:13:41.783]             ...future.startTime <- base::Sys.time()
[16:13:41.783]             {
[16:13:41.783]                 {
[16:13:41.783]                   {
[16:13:41.783]                     {
[16:13:41.783]                       base::local({
[16:13:41.783]                         has_future <- base::requireNamespace("future", 
[16:13:41.783]                           quietly = TRUE)
[16:13:41.783]                         if (has_future) {
[16:13:41.783]                           ns <- base::getNamespace("future")
[16:13:41.783]                           version <- ns[[".package"]][["version"]]
[16:13:41.783]                           if (is.null(version)) 
[16:13:41.783]                             version <- utils::packageVersion("future")
[16:13:41.783]                         }
[16:13:41.783]                         else {
[16:13:41.783]                           version <- NULL
[16:13:41.783]                         }
[16:13:41.783]                         if (!has_future || version < "1.8.0") {
[16:13:41.783]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:41.783]                             "", base::R.version$version.string), 
[16:13:41.783]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:41.783]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:41.783]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:41.783]                               "release", "version")], collapse = " "), 
[16:13:41.783]                             hostname = base::Sys.info()[["nodename"]])
[16:13:41.783]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:41.783]                             info)
[16:13:41.783]                           info <- base::paste(info, collapse = "; ")
[16:13:41.783]                           if (!has_future) {
[16:13:41.783]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:41.783]                               info)
[16:13:41.783]                           }
[16:13:41.783]                           else {
[16:13:41.783]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:41.783]                               info, version)
[16:13:41.783]                           }
[16:13:41.783]                           base::stop(msg)
[16:13:41.783]                         }
[16:13:41.783]                       })
[16:13:41.783]                     }
[16:13:41.783]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:41.783]                     base::options(mc.cores = 1L)
[16:13:41.783]                   }
[16:13:41.783]                   options(future.plan = NULL)
[16:13:41.783]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:41.783]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:41.783]                 }
[16:13:41.783]                 ...future.workdir <- getwd()
[16:13:41.783]             }
[16:13:41.783]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:41.783]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:41.783]         }
[16:13:41.783]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:41.783]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:41.783]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:41.783]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:41.783]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:41.783]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:41.783]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:41.783]             base::names(...future.oldOptions))
[16:13:41.783]     }
[16:13:41.783]     if (FALSE) {
[16:13:41.783]     }
[16:13:41.783]     else {
[16:13:41.783]         if (TRUE) {
[16:13:41.783]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:41.783]                 open = "w")
[16:13:41.783]         }
[16:13:41.783]         else {
[16:13:41.783]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:41.783]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:41.783]         }
[16:13:41.783]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:41.783]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:41.783]             base::sink(type = "output", split = FALSE)
[16:13:41.783]             base::close(...future.stdout)
[16:13:41.783]         }, add = TRUE)
[16:13:41.783]     }
[16:13:41.783]     ...future.frame <- base::sys.nframe()
[16:13:41.783]     ...future.conditions <- base::list()
[16:13:41.783]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:41.783]     if (FALSE) {
[16:13:41.783]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:41.783]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:41.783]     }
[16:13:41.783]     ...future.result <- base::tryCatch({
[16:13:41.783]         base::withCallingHandlers({
[16:13:41.783]             ...future.value <- base::withVisible(base::local({
[16:13:41.783]                 withCallingHandlers({
[16:13:41.783]                   {
[16:13:41.783]                     Sys.sleep(0.1)
[16:13:41.783]                     kk
[16:13:41.783]                   }
[16:13:41.783]                 }, immediateCondition = function(cond) {
[16:13:41.783]                   save_rds <- function (object, pathname, ...) 
[16:13:41.783]                   {
[16:13:41.783]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:41.783]                     if (file_test("-f", pathname_tmp)) {
[16:13:41.783]                       fi_tmp <- file.info(pathname_tmp)
[16:13:41.783]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:41.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:41.783]                         fi_tmp[["mtime"]])
[16:13:41.783]                     }
[16:13:41.783]                     tryCatch({
[16:13:41.783]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:41.783]                     }, error = function(ex) {
[16:13:41.783]                       msg <- conditionMessage(ex)
[16:13:41.783]                       fi_tmp <- file.info(pathname_tmp)
[16:13:41.783]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:41.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:41.783]                         fi_tmp[["mtime"]], msg)
[16:13:41.783]                       ex$message <- msg
[16:13:41.783]                       stop(ex)
[16:13:41.783]                     })
[16:13:41.783]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:41.783]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:41.783]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:41.783]                       fi_tmp <- file.info(pathname_tmp)
[16:13:41.783]                       fi <- file.info(pathname)
[16:13:41.783]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:41.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:41.783]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:41.783]                         fi[["size"]], fi[["mtime"]])
[16:13:41.783]                       stop(msg)
[16:13:41.783]                     }
[16:13:41.783]                     invisible(pathname)
[16:13:41.783]                   }
[16:13:41.783]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:41.783]                     rootPath = tempdir()) 
[16:13:41.783]                   {
[16:13:41.783]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:41.783]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:41.783]                       tmpdir = path, fileext = ".rds")
[16:13:41.783]                     save_rds(obj, file)
[16:13:41.783]                   }
[16:13:41.783]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:41.783]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:41.783]                   {
[16:13:41.783]                     inherits <- base::inherits
[16:13:41.783]                     invokeRestart <- base::invokeRestart
[16:13:41.783]                     is.null <- base::is.null
[16:13:41.783]                     muffled <- FALSE
[16:13:41.783]                     if (inherits(cond, "message")) {
[16:13:41.783]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:41.783]                       if (muffled) 
[16:13:41.783]                         invokeRestart("muffleMessage")
[16:13:41.783]                     }
[16:13:41.783]                     else if (inherits(cond, "warning")) {
[16:13:41.783]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:41.783]                       if (muffled) 
[16:13:41.783]                         invokeRestart("muffleWarning")
[16:13:41.783]                     }
[16:13:41.783]                     else if (inherits(cond, "condition")) {
[16:13:41.783]                       if (!is.null(pattern)) {
[16:13:41.783]                         computeRestarts <- base::computeRestarts
[16:13:41.783]                         grepl <- base::grepl
[16:13:41.783]                         restarts <- computeRestarts(cond)
[16:13:41.783]                         for (restart in restarts) {
[16:13:41.783]                           name <- restart$name
[16:13:41.783]                           if (is.null(name)) 
[16:13:41.783]                             next
[16:13:41.783]                           if (!grepl(pattern, name)) 
[16:13:41.783]                             next
[16:13:41.783]                           invokeRestart(restart)
[16:13:41.783]                           muffled <- TRUE
[16:13:41.783]                           break
[16:13:41.783]                         }
[16:13:41.783]                       }
[16:13:41.783]                     }
[16:13:41.783]                     invisible(muffled)
[16:13:41.783]                   }
[16:13:41.783]                   muffleCondition(cond)
[16:13:41.783]                 })
[16:13:41.783]             }))
[16:13:41.783]             future::FutureResult(value = ...future.value$value, 
[16:13:41.783]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:41.783]                   ...future.rng), globalenv = if (FALSE) 
[16:13:41.783]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:41.783]                     ...future.globalenv.names))
[16:13:41.783]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:41.783]         }, condition = base::local({
[16:13:41.783]             c <- base::c
[16:13:41.783]             inherits <- base::inherits
[16:13:41.783]             invokeRestart <- base::invokeRestart
[16:13:41.783]             length <- base::length
[16:13:41.783]             list <- base::list
[16:13:41.783]             seq.int <- base::seq.int
[16:13:41.783]             signalCondition <- base::signalCondition
[16:13:41.783]             sys.calls <- base::sys.calls
[16:13:41.783]             `[[` <- base::`[[`
[16:13:41.783]             `+` <- base::`+`
[16:13:41.783]             `<<-` <- base::`<<-`
[16:13:41.783]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:41.783]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:41.783]                   3L)]
[16:13:41.783]             }
[16:13:41.783]             function(cond) {
[16:13:41.783]                 is_error <- inherits(cond, "error")
[16:13:41.783]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:41.783]                   NULL)
[16:13:41.783]                 if (is_error) {
[16:13:41.783]                   sessionInformation <- function() {
[16:13:41.783]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:41.783]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:41.783]                       search = base::search(), system = base::Sys.info())
[16:13:41.783]                   }
[16:13:41.783]                   ...future.conditions[[length(...future.conditions) + 
[16:13:41.783]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:41.783]                     cond$call), session = sessionInformation(), 
[16:13:41.783]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:41.783]                   signalCondition(cond)
[16:13:41.783]                 }
[16:13:41.783]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:41.783]                 "immediateCondition"))) {
[16:13:41.783]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:41.783]                   ...future.conditions[[length(...future.conditions) + 
[16:13:41.783]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:41.783]                   if (TRUE && !signal) {
[16:13:41.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:41.783]                     {
[16:13:41.783]                       inherits <- base::inherits
[16:13:41.783]                       invokeRestart <- base::invokeRestart
[16:13:41.783]                       is.null <- base::is.null
[16:13:41.783]                       muffled <- FALSE
[16:13:41.783]                       if (inherits(cond, "message")) {
[16:13:41.783]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:41.783]                         if (muffled) 
[16:13:41.783]                           invokeRestart("muffleMessage")
[16:13:41.783]                       }
[16:13:41.783]                       else if (inherits(cond, "warning")) {
[16:13:41.783]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:41.783]                         if (muffled) 
[16:13:41.783]                           invokeRestart("muffleWarning")
[16:13:41.783]                       }
[16:13:41.783]                       else if (inherits(cond, "condition")) {
[16:13:41.783]                         if (!is.null(pattern)) {
[16:13:41.783]                           computeRestarts <- base::computeRestarts
[16:13:41.783]                           grepl <- base::grepl
[16:13:41.783]                           restarts <- computeRestarts(cond)
[16:13:41.783]                           for (restart in restarts) {
[16:13:41.783]                             name <- restart$name
[16:13:41.783]                             if (is.null(name)) 
[16:13:41.783]                               next
[16:13:41.783]                             if (!grepl(pattern, name)) 
[16:13:41.783]                               next
[16:13:41.783]                             invokeRestart(restart)
[16:13:41.783]                             muffled <- TRUE
[16:13:41.783]                             break
[16:13:41.783]                           }
[16:13:41.783]                         }
[16:13:41.783]                       }
[16:13:41.783]                       invisible(muffled)
[16:13:41.783]                     }
[16:13:41.783]                     muffleCondition(cond, pattern = "^muffle")
[16:13:41.783]                   }
[16:13:41.783]                 }
[16:13:41.783]                 else {
[16:13:41.783]                   if (TRUE) {
[16:13:41.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:41.783]                     {
[16:13:41.783]                       inherits <- base::inherits
[16:13:41.783]                       invokeRestart <- base::invokeRestart
[16:13:41.783]                       is.null <- base::is.null
[16:13:41.783]                       muffled <- FALSE
[16:13:41.783]                       if (inherits(cond, "message")) {
[16:13:41.783]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:41.783]                         if (muffled) 
[16:13:41.783]                           invokeRestart("muffleMessage")
[16:13:41.783]                       }
[16:13:41.783]                       else if (inherits(cond, "warning")) {
[16:13:41.783]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:41.783]                         if (muffled) 
[16:13:41.783]                           invokeRestart("muffleWarning")
[16:13:41.783]                       }
[16:13:41.783]                       else if (inherits(cond, "condition")) {
[16:13:41.783]                         if (!is.null(pattern)) {
[16:13:41.783]                           computeRestarts <- base::computeRestarts
[16:13:41.783]                           grepl <- base::grepl
[16:13:41.783]                           restarts <- computeRestarts(cond)
[16:13:41.783]                           for (restart in restarts) {
[16:13:41.783]                             name <- restart$name
[16:13:41.783]                             if (is.null(name)) 
[16:13:41.783]                               next
[16:13:41.783]                             if (!grepl(pattern, name)) 
[16:13:41.783]                               next
[16:13:41.783]                             invokeRestart(restart)
[16:13:41.783]                             muffled <- TRUE
[16:13:41.783]                             break
[16:13:41.783]                           }
[16:13:41.783]                         }
[16:13:41.783]                       }
[16:13:41.783]                       invisible(muffled)
[16:13:41.783]                     }
[16:13:41.783]                     muffleCondition(cond, pattern = "^muffle")
[16:13:41.783]                   }
[16:13:41.783]                 }
[16:13:41.783]             }
[16:13:41.783]         }))
[16:13:41.783]     }, error = function(ex) {
[16:13:41.783]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:41.783]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:41.783]                 ...future.rng), started = ...future.startTime, 
[16:13:41.783]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:41.783]             version = "1.8"), class = "FutureResult")
[16:13:41.783]     }, finally = {
[16:13:41.783]         if (!identical(...future.workdir, getwd())) 
[16:13:41.783]             setwd(...future.workdir)
[16:13:41.783]         {
[16:13:41.783]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:41.783]                 ...future.oldOptions$nwarnings <- NULL
[16:13:41.783]             }
[16:13:41.783]             base::options(...future.oldOptions)
[16:13:41.783]             if (.Platform$OS.type == "windows") {
[16:13:41.783]                 old_names <- names(...future.oldEnvVars)
[16:13:41.783]                 envs <- base::Sys.getenv()
[16:13:41.783]                 names <- names(envs)
[16:13:41.783]                 common <- intersect(names, old_names)
[16:13:41.783]                 added <- setdiff(names, old_names)
[16:13:41.783]                 removed <- setdiff(old_names, names)
[16:13:41.783]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:41.783]                   envs[common]]
[16:13:41.783]                 NAMES <- toupper(changed)
[16:13:41.783]                 args <- list()
[16:13:41.783]                 for (kk in seq_along(NAMES)) {
[16:13:41.783]                   name <- changed[[kk]]
[16:13:41.783]                   NAME <- NAMES[[kk]]
[16:13:41.783]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:41.783]                     next
[16:13:41.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:41.783]                 }
[16:13:41.783]                 NAMES <- toupper(added)
[16:13:41.783]                 for (kk in seq_along(NAMES)) {
[16:13:41.783]                   name <- added[[kk]]
[16:13:41.783]                   NAME <- NAMES[[kk]]
[16:13:41.783]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:41.783]                     next
[16:13:41.783]                   args[[name]] <- ""
[16:13:41.783]                 }
[16:13:41.783]                 NAMES <- toupper(removed)
[16:13:41.783]                 for (kk in seq_along(NAMES)) {
[16:13:41.783]                   name <- removed[[kk]]
[16:13:41.783]                   NAME <- NAMES[[kk]]
[16:13:41.783]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:41.783]                     next
[16:13:41.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:41.783]                 }
[16:13:41.783]                 if (length(args) > 0) 
[16:13:41.783]                   base::do.call(base::Sys.setenv, args = args)
[16:13:41.783]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:41.783]             }
[16:13:41.783]             else {
[16:13:41.783]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:41.783]             }
[16:13:41.783]             {
[16:13:41.783]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:41.783]                   0L) {
[16:13:41.783]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:41.783]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:41.783]                   base::options(opts)
[16:13:41.783]                 }
[16:13:41.783]                 {
[16:13:41.783]                   {
[16:13:41.783]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:41.783]                     NULL
[16:13:41.783]                   }
[16:13:41.783]                   options(future.plan = NULL)
[16:13:41.783]                   if (is.na(NA_character_)) 
[16:13:41.783]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:41.783]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:41.783]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:41.783]                     envir = parent.frame()) 
[16:13:41.783]                   {
[16:13:41.783]                     default_workers <- missing(workers)
[16:13:41.783]                     if (is.function(workers)) 
[16:13:41.783]                       workers <- workers()
[16:13:41.783]                     workers <- structure(as.integer(workers), 
[16:13:41.783]                       class = class(workers))
[16:13:41.783]                     stop_if_not(is.finite(workers), workers >= 
[16:13:41.783]                       1L)
[16:13:41.783]                     if ((workers == 1L && !inherits(workers, 
[16:13:41.783]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:41.783]                       if (default_workers) 
[16:13:41.783]                         supportsMulticore(warn = TRUE)
[16:13:41.783]                       return(sequential(..., envir = envir))
[16:13:41.783]                     }
[16:13:41.783]                     oopts <- options(mc.cores = workers)
[16:13:41.783]                     on.exit(options(oopts))
[16:13:41.783]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:41.783]                       envir = envir)
[16:13:41.783]                     if (!future$lazy) 
[16:13:41.783]                       future <- run(future)
[16:13:41.783]                     invisible(future)
[16:13:41.783]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:41.783]                 }
[16:13:41.783]             }
[16:13:41.783]         }
[16:13:41.783]     })
[16:13:41.783]     if (TRUE) {
[16:13:41.783]         base::sink(type = "output", split = FALSE)
[16:13:41.783]         if (TRUE) {
[16:13:41.783]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:41.783]         }
[16:13:41.783]         else {
[16:13:41.783]             ...future.result["stdout"] <- base::list(NULL)
[16:13:41.783]         }
[16:13:41.783]         base::close(...future.stdout)
[16:13:41.783]         ...future.stdout <- NULL
[16:13:41.783]     }
[16:13:41.783]     ...future.result$conditions <- ...future.conditions
[16:13:41.783]     ...future.result$finished <- base::Sys.time()
[16:13:41.783]     ...future.result
[16:13:41.783] }
[16:13:41.787] assign_globals() ...
[16:13:41.787] List of 1
[16:13:41.787]  $ kk: int 2
[16:13:41.787]  - attr(*, "where")=List of 1
[16:13:41.787]   ..$ kk:<environment: R_EmptyEnv> 
[16:13:41.787]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:41.787]  - attr(*, "resolved")= logi FALSE
[16:13:41.787]  - attr(*, "total_size")= num 56
[16:13:41.787]  - attr(*, "already-done")= logi TRUE
[16:13:41.791] - copied ‘kk’ to environment
[16:13:41.791] assign_globals() ... done
[16:13:41.791] requestCore(): workers = 2
[16:13:41.792] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:41.805] MulticoreFuture started
[16:13:41.805] - Launch lazy future ... done
[16:13:41.806] run() for ‘MulticoreFuture’ ... done
[16:13:41.806] plan(): Setting new future strategy stack:
[16:13:41.807] List of future strategies:
[16:13:41.807] 1. sequential:
[16:13:41.807]    - args: function (..., envir = parent.frame())
[16:13:41.807]    - tweaked: FALSE
[16:13:41.807]    - call: NULL
[16:13:41.808] plan(): nbrOfWorkers() = 1
[16:13:41.817] run() for ‘Future’ ...
[16:13:41.817] - state: ‘created’
[16:13:41.817] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:41.823] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:41.823] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:41.823]   - Field: ‘label’
[16:13:41.823]   - Field: ‘local’
[16:13:41.823]   - Field: ‘owner’
[16:13:41.823]   - Field: ‘envir’
[16:13:41.824]   - Field: ‘workers’
[16:13:41.824]   - Field: ‘packages’
[16:13:41.824]   - Field: ‘gc’
[16:13:41.824]   - Field: ‘job’
[16:13:41.824]   - Field: ‘conditions’
[16:13:41.824]   - Field: ‘expr’
[16:13:41.825]   - Field: ‘uuid’
[16:13:41.825]   - Field: ‘seed’
[16:13:41.825]   - Field: ‘version’
[16:13:41.825]   - Field: ‘result’
[16:13:41.825]   - Field: ‘asynchronous’
[16:13:41.825]   - Field: ‘calls’
[16:13:41.826]   - Field: ‘globals’
[16:13:41.826]   - Field: ‘stdout’
[16:13:41.826]   - Field: ‘earlySignal’
[16:13:41.826]   - Field: ‘lazy’
[16:13:41.826]   - Field: ‘state’
[16:13:41.826] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:41.826] - Launch lazy future ...
[16:13:41.831] Packages needed by the future expression (n = 0): <none>
[16:13:41.831] Packages needed by future strategies (n = 0): <none>
[16:13:41.833] {
[16:13:41.833]     {
[16:13:41.833]         {
[16:13:41.833]             ...future.startTime <- base::Sys.time()
[16:13:41.833]             {
[16:13:41.833]                 {
[16:13:41.833]                   {
[16:13:41.833]                     {
[16:13:41.833]                       base::local({
[16:13:41.833]                         has_future <- base::requireNamespace("future", 
[16:13:41.833]                           quietly = TRUE)
[16:13:41.833]                         if (has_future) {
[16:13:41.833]                           ns <- base::getNamespace("future")
[16:13:41.833]                           version <- ns[[".package"]][["version"]]
[16:13:41.833]                           if (is.null(version)) 
[16:13:41.833]                             version <- utils::packageVersion("future")
[16:13:41.833]                         }
[16:13:41.833]                         else {
[16:13:41.833]                           version <- NULL
[16:13:41.833]                         }
[16:13:41.833]                         if (!has_future || version < "1.8.0") {
[16:13:41.833]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:41.833]                             "", base::R.version$version.string), 
[16:13:41.833]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:41.833]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:41.833]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:41.833]                               "release", "version")], collapse = " "), 
[16:13:41.833]                             hostname = base::Sys.info()[["nodename"]])
[16:13:41.833]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:41.833]                             info)
[16:13:41.833]                           info <- base::paste(info, collapse = "; ")
[16:13:41.833]                           if (!has_future) {
[16:13:41.833]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:41.833]                               info)
[16:13:41.833]                           }
[16:13:41.833]                           else {
[16:13:41.833]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:41.833]                               info, version)
[16:13:41.833]                           }
[16:13:41.833]                           base::stop(msg)
[16:13:41.833]                         }
[16:13:41.833]                       })
[16:13:41.833]                     }
[16:13:41.833]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:41.833]                     base::options(mc.cores = 1L)
[16:13:41.833]                   }
[16:13:41.833]                   options(future.plan = NULL)
[16:13:41.833]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:41.833]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:41.833]                 }
[16:13:41.833]                 ...future.workdir <- getwd()
[16:13:41.833]             }
[16:13:41.833]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:41.833]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:41.833]         }
[16:13:41.833]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:41.833]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:41.833]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:41.833]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:41.833]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:41.833]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:41.833]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:41.833]             base::names(...future.oldOptions))
[16:13:41.833]     }
[16:13:41.833]     if (FALSE) {
[16:13:41.833]     }
[16:13:41.833]     else {
[16:13:41.833]         if (TRUE) {
[16:13:41.833]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:41.833]                 open = "w")
[16:13:41.833]         }
[16:13:41.833]         else {
[16:13:41.833]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:41.833]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:41.833]         }
[16:13:41.833]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:41.833]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:41.833]             base::sink(type = "output", split = FALSE)
[16:13:41.833]             base::close(...future.stdout)
[16:13:41.833]         }, add = TRUE)
[16:13:41.833]     }
[16:13:41.833]     ...future.frame <- base::sys.nframe()
[16:13:41.833]     ...future.conditions <- base::list()
[16:13:41.833]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:41.833]     if (FALSE) {
[16:13:41.833]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:41.833]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:41.833]     }
[16:13:41.833]     ...future.result <- base::tryCatch({
[16:13:41.833]         base::withCallingHandlers({
[16:13:41.833]             ...future.value <- base::withVisible(base::local({
[16:13:41.833]                 withCallingHandlers({
[16:13:41.833]                   {
[16:13:41.833]                     Sys.sleep(0.1)
[16:13:41.833]                     kk
[16:13:41.833]                   }
[16:13:41.833]                 }, immediateCondition = function(cond) {
[16:13:41.833]                   save_rds <- function (object, pathname, ...) 
[16:13:41.833]                   {
[16:13:41.833]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:41.833]                     if (file_test("-f", pathname_tmp)) {
[16:13:41.833]                       fi_tmp <- file.info(pathname_tmp)
[16:13:41.833]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:41.833]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:41.833]                         fi_tmp[["mtime"]])
[16:13:41.833]                     }
[16:13:41.833]                     tryCatch({
[16:13:41.833]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:41.833]                     }, error = function(ex) {
[16:13:41.833]                       msg <- conditionMessage(ex)
[16:13:41.833]                       fi_tmp <- file.info(pathname_tmp)
[16:13:41.833]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:41.833]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:41.833]                         fi_tmp[["mtime"]], msg)
[16:13:41.833]                       ex$message <- msg
[16:13:41.833]                       stop(ex)
[16:13:41.833]                     })
[16:13:41.833]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:41.833]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:41.833]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:41.833]                       fi_tmp <- file.info(pathname_tmp)
[16:13:41.833]                       fi <- file.info(pathname)
[16:13:41.833]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:41.833]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:41.833]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:41.833]                         fi[["size"]], fi[["mtime"]])
[16:13:41.833]                       stop(msg)
[16:13:41.833]                     }
[16:13:41.833]                     invisible(pathname)
[16:13:41.833]                   }
[16:13:41.833]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:41.833]                     rootPath = tempdir()) 
[16:13:41.833]                   {
[16:13:41.833]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:41.833]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:41.833]                       tmpdir = path, fileext = ".rds")
[16:13:41.833]                     save_rds(obj, file)
[16:13:41.833]                   }
[16:13:41.833]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:41.833]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:41.833]                   {
[16:13:41.833]                     inherits <- base::inherits
[16:13:41.833]                     invokeRestart <- base::invokeRestart
[16:13:41.833]                     is.null <- base::is.null
[16:13:41.833]                     muffled <- FALSE
[16:13:41.833]                     if (inherits(cond, "message")) {
[16:13:41.833]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:41.833]                       if (muffled) 
[16:13:41.833]                         invokeRestart("muffleMessage")
[16:13:41.833]                     }
[16:13:41.833]                     else if (inherits(cond, "warning")) {
[16:13:41.833]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:41.833]                       if (muffled) 
[16:13:41.833]                         invokeRestart("muffleWarning")
[16:13:41.833]                     }
[16:13:41.833]                     else if (inherits(cond, "condition")) {
[16:13:41.833]                       if (!is.null(pattern)) {
[16:13:41.833]                         computeRestarts <- base::computeRestarts
[16:13:41.833]                         grepl <- base::grepl
[16:13:41.833]                         restarts <- computeRestarts(cond)
[16:13:41.833]                         for (restart in restarts) {
[16:13:41.833]                           name <- restart$name
[16:13:41.833]                           if (is.null(name)) 
[16:13:41.833]                             next
[16:13:41.833]                           if (!grepl(pattern, name)) 
[16:13:41.833]                             next
[16:13:41.833]                           invokeRestart(restart)
[16:13:41.833]                           muffled <- TRUE
[16:13:41.833]                           break
[16:13:41.833]                         }
[16:13:41.833]                       }
[16:13:41.833]                     }
[16:13:41.833]                     invisible(muffled)
[16:13:41.833]                   }
[16:13:41.833]                   muffleCondition(cond)
[16:13:41.833]                 })
[16:13:41.833]             }))
[16:13:41.833]             future::FutureResult(value = ...future.value$value, 
[16:13:41.833]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:41.833]                   ...future.rng), globalenv = if (FALSE) 
[16:13:41.833]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:41.833]                     ...future.globalenv.names))
[16:13:41.833]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:41.833]         }, condition = base::local({
[16:13:41.833]             c <- base::c
[16:13:41.833]             inherits <- base::inherits
[16:13:41.833]             invokeRestart <- base::invokeRestart
[16:13:41.833]             length <- base::length
[16:13:41.833]             list <- base::list
[16:13:41.833]             seq.int <- base::seq.int
[16:13:41.833]             signalCondition <- base::signalCondition
[16:13:41.833]             sys.calls <- base::sys.calls
[16:13:41.833]             `[[` <- base::`[[`
[16:13:41.833]             `+` <- base::`+`
[16:13:41.833]             `<<-` <- base::`<<-`
[16:13:41.833]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:41.833]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:41.833]                   3L)]
[16:13:41.833]             }
[16:13:41.833]             function(cond) {
[16:13:41.833]                 is_error <- inherits(cond, "error")
[16:13:41.833]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:41.833]                   NULL)
[16:13:41.833]                 if (is_error) {
[16:13:41.833]                   sessionInformation <- function() {
[16:13:41.833]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:41.833]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:41.833]                       search = base::search(), system = base::Sys.info())
[16:13:41.833]                   }
[16:13:41.833]                   ...future.conditions[[length(...future.conditions) + 
[16:13:41.833]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:41.833]                     cond$call), session = sessionInformation(), 
[16:13:41.833]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:41.833]                   signalCondition(cond)
[16:13:41.833]                 }
[16:13:41.833]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:41.833]                 "immediateCondition"))) {
[16:13:41.833]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:41.833]                   ...future.conditions[[length(...future.conditions) + 
[16:13:41.833]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:41.833]                   if (TRUE && !signal) {
[16:13:41.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:41.833]                     {
[16:13:41.833]                       inherits <- base::inherits
[16:13:41.833]                       invokeRestart <- base::invokeRestart
[16:13:41.833]                       is.null <- base::is.null
[16:13:41.833]                       muffled <- FALSE
[16:13:41.833]                       if (inherits(cond, "message")) {
[16:13:41.833]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:41.833]                         if (muffled) 
[16:13:41.833]                           invokeRestart("muffleMessage")
[16:13:41.833]                       }
[16:13:41.833]                       else if (inherits(cond, "warning")) {
[16:13:41.833]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:41.833]                         if (muffled) 
[16:13:41.833]                           invokeRestart("muffleWarning")
[16:13:41.833]                       }
[16:13:41.833]                       else if (inherits(cond, "condition")) {
[16:13:41.833]                         if (!is.null(pattern)) {
[16:13:41.833]                           computeRestarts <- base::computeRestarts
[16:13:41.833]                           grepl <- base::grepl
[16:13:41.833]                           restarts <- computeRestarts(cond)
[16:13:41.833]                           for (restart in restarts) {
[16:13:41.833]                             name <- restart$name
[16:13:41.833]                             if (is.null(name)) 
[16:13:41.833]                               next
[16:13:41.833]                             if (!grepl(pattern, name)) 
[16:13:41.833]                               next
[16:13:41.833]                             invokeRestart(restart)
[16:13:41.833]                             muffled <- TRUE
[16:13:41.833]                             break
[16:13:41.833]                           }
[16:13:41.833]                         }
[16:13:41.833]                       }
[16:13:41.833]                       invisible(muffled)
[16:13:41.833]                     }
[16:13:41.833]                     muffleCondition(cond, pattern = "^muffle")
[16:13:41.833]                   }
[16:13:41.833]                 }
[16:13:41.833]                 else {
[16:13:41.833]                   if (TRUE) {
[16:13:41.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:41.833]                     {
[16:13:41.833]                       inherits <- base::inherits
[16:13:41.833]                       invokeRestart <- base::invokeRestart
[16:13:41.833]                       is.null <- base::is.null
[16:13:41.833]                       muffled <- FALSE
[16:13:41.833]                       if (inherits(cond, "message")) {
[16:13:41.833]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:41.833]                         if (muffled) 
[16:13:41.833]                           invokeRestart("muffleMessage")
[16:13:41.833]                       }
[16:13:41.833]                       else if (inherits(cond, "warning")) {
[16:13:41.833]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:41.833]                         if (muffled) 
[16:13:41.833]                           invokeRestart("muffleWarning")
[16:13:41.833]                       }
[16:13:41.833]                       else if (inherits(cond, "condition")) {
[16:13:41.833]                         if (!is.null(pattern)) {
[16:13:41.833]                           computeRestarts <- base::computeRestarts
[16:13:41.833]                           grepl <- base::grepl
[16:13:41.833]                           restarts <- computeRestarts(cond)
[16:13:41.833]                           for (restart in restarts) {
[16:13:41.833]                             name <- restart$name
[16:13:41.833]                             if (is.null(name)) 
[16:13:41.833]                               next
[16:13:41.833]                             if (!grepl(pattern, name)) 
[16:13:41.833]                               next
[16:13:41.833]                             invokeRestart(restart)
[16:13:41.833]                             muffled <- TRUE
[16:13:41.833]                             break
[16:13:41.833]                           }
[16:13:41.833]                         }
[16:13:41.833]                       }
[16:13:41.833]                       invisible(muffled)
[16:13:41.833]                     }
[16:13:41.833]                     muffleCondition(cond, pattern = "^muffle")
[16:13:41.833]                   }
[16:13:41.833]                 }
[16:13:41.833]             }
[16:13:41.833]         }))
[16:13:41.833]     }, error = function(ex) {
[16:13:41.833]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:41.833]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:41.833]                 ...future.rng), started = ...future.startTime, 
[16:13:41.833]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:41.833]             version = "1.8"), class = "FutureResult")
[16:13:41.833]     }, finally = {
[16:13:41.833]         if (!identical(...future.workdir, getwd())) 
[16:13:41.833]             setwd(...future.workdir)
[16:13:41.833]         {
[16:13:41.833]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:41.833]                 ...future.oldOptions$nwarnings <- NULL
[16:13:41.833]             }
[16:13:41.833]             base::options(...future.oldOptions)
[16:13:41.833]             if (.Platform$OS.type == "windows") {
[16:13:41.833]                 old_names <- names(...future.oldEnvVars)
[16:13:41.833]                 envs <- base::Sys.getenv()
[16:13:41.833]                 names <- names(envs)
[16:13:41.833]                 common <- intersect(names, old_names)
[16:13:41.833]                 added <- setdiff(names, old_names)
[16:13:41.833]                 removed <- setdiff(old_names, names)
[16:13:41.833]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:41.833]                   envs[common]]
[16:13:41.833]                 NAMES <- toupper(changed)
[16:13:41.833]                 args <- list()
[16:13:41.833]                 for (kk in seq_along(NAMES)) {
[16:13:41.833]                   name <- changed[[kk]]
[16:13:41.833]                   NAME <- NAMES[[kk]]
[16:13:41.833]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:41.833]                     next
[16:13:41.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:41.833]                 }
[16:13:41.833]                 NAMES <- toupper(added)
[16:13:41.833]                 for (kk in seq_along(NAMES)) {
[16:13:41.833]                   name <- added[[kk]]
[16:13:41.833]                   NAME <- NAMES[[kk]]
[16:13:41.833]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:41.833]                     next
[16:13:41.833]                   args[[name]] <- ""
[16:13:41.833]                 }
[16:13:41.833]                 NAMES <- toupper(removed)
[16:13:41.833]                 for (kk in seq_along(NAMES)) {
[16:13:41.833]                   name <- removed[[kk]]
[16:13:41.833]                   NAME <- NAMES[[kk]]
[16:13:41.833]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:41.833]                     next
[16:13:41.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:41.833]                 }
[16:13:41.833]                 if (length(args) > 0) 
[16:13:41.833]                   base::do.call(base::Sys.setenv, args = args)
[16:13:41.833]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:41.833]             }
[16:13:41.833]             else {
[16:13:41.833]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:41.833]             }
[16:13:41.833]             {
[16:13:41.833]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:41.833]                   0L) {
[16:13:41.833]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:41.833]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:41.833]                   base::options(opts)
[16:13:41.833]                 }
[16:13:41.833]                 {
[16:13:41.833]                   {
[16:13:41.833]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:41.833]                     NULL
[16:13:41.833]                   }
[16:13:41.833]                   options(future.plan = NULL)
[16:13:41.833]                   if (is.na(NA_character_)) 
[16:13:41.833]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:41.833]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:41.833]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:41.833]                     envir = parent.frame()) 
[16:13:41.833]                   {
[16:13:41.833]                     default_workers <- missing(workers)
[16:13:41.833]                     if (is.function(workers)) 
[16:13:41.833]                       workers <- workers()
[16:13:41.833]                     workers <- structure(as.integer(workers), 
[16:13:41.833]                       class = class(workers))
[16:13:41.833]                     stop_if_not(is.finite(workers), workers >= 
[16:13:41.833]                       1L)
[16:13:41.833]                     if ((workers == 1L && !inherits(workers, 
[16:13:41.833]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:41.833]                       if (default_workers) 
[16:13:41.833]                         supportsMulticore(warn = TRUE)
[16:13:41.833]                       return(sequential(..., envir = envir))
[16:13:41.833]                     }
[16:13:41.833]                     oopts <- options(mc.cores = workers)
[16:13:41.833]                     on.exit(options(oopts))
[16:13:41.833]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:41.833]                       envir = envir)
[16:13:41.833]                     if (!future$lazy) 
[16:13:41.833]                       future <- run(future)
[16:13:41.833]                     invisible(future)
[16:13:41.833]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:41.833]                 }
[16:13:41.833]             }
[16:13:41.833]         }
[16:13:41.833]     })
[16:13:41.833]     if (TRUE) {
[16:13:41.833]         base::sink(type = "output", split = FALSE)
[16:13:41.833]         if (TRUE) {
[16:13:41.833]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:41.833]         }
[16:13:41.833]         else {
[16:13:41.833]             ...future.result["stdout"] <- base::list(NULL)
[16:13:41.833]         }
[16:13:41.833]         base::close(...future.stdout)
[16:13:41.833]         ...future.stdout <- NULL
[16:13:41.833]     }
[16:13:41.833]     ...future.result$conditions <- ...future.conditions
[16:13:41.833]     ...future.result$finished <- base::Sys.time()
[16:13:41.833]     ...future.result
[16:13:41.833] }
[16:13:41.836] assign_globals() ...
[16:13:41.836] List of 1
[16:13:41.836]  $ kk: int 3
[16:13:41.836]  - attr(*, "where")=List of 1
[16:13:41.836]   ..$ kk:<environment: R_EmptyEnv> 
[16:13:41.836]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:41.836]  - attr(*, "resolved")= logi FALSE
[16:13:41.836]  - attr(*, "total_size")= num 56
[16:13:41.836]  - attr(*, "already-done")= logi TRUE
[16:13:41.841] - copied ‘kk’ to environment
[16:13:41.841] assign_globals() ... done
[16:13:41.841] requestCore(): workers = 2
[16:13:41.842] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:41.864] plan(): Setting new future strategy stack:
[16:13:41.865] List of future strategies:
[16:13:41.865] 1. multicore:
[16:13:41.865]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:41.865]    - tweaked: FALSE
[16:13:41.865]    - call: plan(strategy)
[16:13:41.869] plan(): nbrOfWorkers() = 2
[16:13:41.873] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[16:13:41.887] MulticoreFuture started
[16:13:41.888] - Launch lazy future ... done
[16:13:41.888] run() for ‘MulticoreFuture’ ... done
[16:13:41.889] plan(): Setting new future strategy stack:
[16:13:41.889] List of future strategies:
[16:13:41.889] 1. sequential:
[16:13:41.889]    - args: function (..., envir = parent.frame())
[16:13:41.889]    - tweaked: FALSE
[16:13:41.889]    - call: NULL
[16:13:41.890] plan(): nbrOfWorkers() = 1
[16:13:41.909] Future #1
[16:13:41.910]  length: 2 (resolved future 1)
[16:13:41.910] plan(): Setting new future strategy stack:
[16:13:41.910] List of future strategies:
[16:13:41.910] 1. multicore:
[16:13:41.910]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:41.910]    - tweaked: FALSE
[16:13:41.910]    - call: plan(strategy)
[16:13:41.915] plan(): nbrOfWorkers() = 2
[16:13:41.915] Future #2
[16:13:41.915]  length: 1 (resolved future 2)
[16:13:41.993] plan(): Setting new future strategy stack:
[16:13:41.993] List of future strategies:
[16:13:41.993] 1. multicore:
[16:13:41.993]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:41.993]    - tweaked: FALSE
[16:13:41.993]    - call: plan(strategy)
[16:13:41.998] plan(): nbrOfWorkers() = 2
[16:13:41.999] Future #3
[16:13:41.999]  length: 0 (resolved future 3)
[16:13:41.999] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[16:13:42.001] resolve() on environment ...
[16:13:42.001]  recursive: 0
[16:13:42.002]  elements: [2] ‘a’, ‘b’
[16:13:42.002]  length: 1 (resolved future 1)
[16:13:42.002]  length: 0 (resolved future 2)
[16:13:42.002] resolve() on environment ... DONE
[16:13:42.003] getGlobalsAndPackages() ...
[16:13:42.003] Searching for globals...
[16:13:42.004] 
[16:13:42.004] Searching for globals ... DONE
[16:13:42.004] - globals: [0] <none>
[16:13:42.004] getGlobalsAndPackages() ... DONE
[16:13:42.005] run() for ‘Future’ ...
[16:13:42.005] - state: ‘created’
[16:13:42.005] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:42.010] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:42.010] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:42.010]   - Field: ‘label’
[16:13:42.010]   - Field: ‘local’
[16:13:42.010]   - Field: ‘owner’
[16:13:42.010]   - Field: ‘envir’
[16:13:42.011]   - Field: ‘workers’
[16:13:42.011]   - Field: ‘packages’
[16:13:42.011]   - Field: ‘gc’
[16:13:42.011]   - Field: ‘job’
[16:13:42.011]   - Field: ‘conditions’
[16:13:42.011]   - Field: ‘expr’
[16:13:42.012]   - Field: ‘uuid’
[16:13:42.012]   - Field: ‘seed’
[16:13:42.012]   - Field: ‘version’
[16:13:42.012]   - Field: ‘result’
[16:13:42.012]   - Field: ‘asynchronous’
[16:13:42.012]   - Field: ‘calls’
[16:13:42.013]   - Field: ‘globals’
[16:13:42.013]   - Field: ‘stdout’
[16:13:42.013]   - Field: ‘earlySignal’
[16:13:42.013]   - Field: ‘lazy’
[16:13:42.013]   - Field: ‘state’
[16:13:42.013] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:42.014] - Launch lazy future ...
[16:13:42.014] Packages needed by the future expression (n = 0): <none>
[16:13:42.014] Packages needed by future strategies (n = 0): <none>
[16:13:42.015] {
[16:13:42.015]     {
[16:13:42.015]         {
[16:13:42.015]             ...future.startTime <- base::Sys.time()
[16:13:42.015]             {
[16:13:42.015]                 {
[16:13:42.015]                   {
[16:13:42.015]                     {
[16:13:42.015]                       base::local({
[16:13:42.015]                         has_future <- base::requireNamespace("future", 
[16:13:42.015]                           quietly = TRUE)
[16:13:42.015]                         if (has_future) {
[16:13:42.015]                           ns <- base::getNamespace("future")
[16:13:42.015]                           version <- ns[[".package"]][["version"]]
[16:13:42.015]                           if (is.null(version)) 
[16:13:42.015]                             version <- utils::packageVersion("future")
[16:13:42.015]                         }
[16:13:42.015]                         else {
[16:13:42.015]                           version <- NULL
[16:13:42.015]                         }
[16:13:42.015]                         if (!has_future || version < "1.8.0") {
[16:13:42.015]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:42.015]                             "", base::R.version$version.string), 
[16:13:42.015]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:42.015]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:42.015]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:42.015]                               "release", "version")], collapse = " "), 
[16:13:42.015]                             hostname = base::Sys.info()[["nodename"]])
[16:13:42.015]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:42.015]                             info)
[16:13:42.015]                           info <- base::paste(info, collapse = "; ")
[16:13:42.015]                           if (!has_future) {
[16:13:42.015]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:42.015]                               info)
[16:13:42.015]                           }
[16:13:42.015]                           else {
[16:13:42.015]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:42.015]                               info, version)
[16:13:42.015]                           }
[16:13:42.015]                           base::stop(msg)
[16:13:42.015]                         }
[16:13:42.015]                       })
[16:13:42.015]                     }
[16:13:42.015]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:42.015]                     base::options(mc.cores = 1L)
[16:13:42.015]                   }
[16:13:42.015]                   options(future.plan = NULL)
[16:13:42.015]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.015]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:42.015]                 }
[16:13:42.015]                 ...future.workdir <- getwd()
[16:13:42.015]             }
[16:13:42.015]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:42.015]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:42.015]         }
[16:13:42.015]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:42.015]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:42.015]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:42.015]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:42.015]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:42.015]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:42.015]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:42.015]             base::names(...future.oldOptions))
[16:13:42.015]     }
[16:13:42.015]     if (FALSE) {
[16:13:42.015]     }
[16:13:42.015]     else {
[16:13:42.015]         if (TRUE) {
[16:13:42.015]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:42.015]                 open = "w")
[16:13:42.015]         }
[16:13:42.015]         else {
[16:13:42.015]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:42.015]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:42.015]         }
[16:13:42.015]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:42.015]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:42.015]             base::sink(type = "output", split = FALSE)
[16:13:42.015]             base::close(...future.stdout)
[16:13:42.015]         }, add = TRUE)
[16:13:42.015]     }
[16:13:42.015]     ...future.frame <- base::sys.nframe()
[16:13:42.015]     ...future.conditions <- base::list()
[16:13:42.015]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:42.015]     if (FALSE) {
[16:13:42.015]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:42.015]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:42.015]     }
[16:13:42.015]     ...future.result <- base::tryCatch({
[16:13:42.015]         base::withCallingHandlers({
[16:13:42.015]             ...future.value <- base::withVisible(base::local({
[16:13:42.015]                 withCallingHandlers({
[16:13:42.015]                   1
[16:13:42.015]                 }, immediateCondition = function(cond) {
[16:13:42.015]                   save_rds <- function (object, pathname, ...) 
[16:13:42.015]                   {
[16:13:42.015]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:42.015]                     if (file_test("-f", pathname_tmp)) {
[16:13:42.015]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.015]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:42.015]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.015]                         fi_tmp[["mtime"]])
[16:13:42.015]                     }
[16:13:42.015]                     tryCatch({
[16:13:42.015]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:42.015]                     }, error = function(ex) {
[16:13:42.015]                       msg <- conditionMessage(ex)
[16:13:42.015]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.015]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:42.015]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.015]                         fi_tmp[["mtime"]], msg)
[16:13:42.015]                       ex$message <- msg
[16:13:42.015]                       stop(ex)
[16:13:42.015]                     })
[16:13:42.015]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:42.015]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:42.015]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:42.015]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.015]                       fi <- file.info(pathname)
[16:13:42.015]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:42.015]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.015]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:42.015]                         fi[["size"]], fi[["mtime"]])
[16:13:42.015]                       stop(msg)
[16:13:42.015]                     }
[16:13:42.015]                     invisible(pathname)
[16:13:42.015]                   }
[16:13:42.015]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:42.015]                     rootPath = tempdir()) 
[16:13:42.015]                   {
[16:13:42.015]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:42.015]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:42.015]                       tmpdir = path, fileext = ".rds")
[16:13:42.015]                     save_rds(obj, file)
[16:13:42.015]                   }
[16:13:42.015]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:42.015]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.015]                   {
[16:13:42.015]                     inherits <- base::inherits
[16:13:42.015]                     invokeRestart <- base::invokeRestart
[16:13:42.015]                     is.null <- base::is.null
[16:13:42.015]                     muffled <- FALSE
[16:13:42.015]                     if (inherits(cond, "message")) {
[16:13:42.015]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:42.015]                       if (muffled) 
[16:13:42.015]                         invokeRestart("muffleMessage")
[16:13:42.015]                     }
[16:13:42.015]                     else if (inherits(cond, "warning")) {
[16:13:42.015]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:42.015]                       if (muffled) 
[16:13:42.015]                         invokeRestart("muffleWarning")
[16:13:42.015]                     }
[16:13:42.015]                     else if (inherits(cond, "condition")) {
[16:13:42.015]                       if (!is.null(pattern)) {
[16:13:42.015]                         computeRestarts <- base::computeRestarts
[16:13:42.015]                         grepl <- base::grepl
[16:13:42.015]                         restarts <- computeRestarts(cond)
[16:13:42.015]                         for (restart in restarts) {
[16:13:42.015]                           name <- restart$name
[16:13:42.015]                           if (is.null(name)) 
[16:13:42.015]                             next
[16:13:42.015]                           if (!grepl(pattern, name)) 
[16:13:42.015]                             next
[16:13:42.015]                           invokeRestart(restart)
[16:13:42.015]                           muffled <- TRUE
[16:13:42.015]                           break
[16:13:42.015]                         }
[16:13:42.015]                       }
[16:13:42.015]                     }
[16:13:42.015]                     invisible(muffled)
[16:13:42.015]                   }
[16:13:42.015]                   muffleCondition(cond)
[16:13:42.015]                 })
[16:13:42.015]             }))
[16:13:42.015]             future::FutureResult(value = ...future.value$value, 
[16:13:42.015]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.015]                   ...future.rng), globalenv = if (FALSE) 
[16:13:42.015]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:42.015]                     ...future.globalenv.names))
[16:13:42.015]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:42.015]         }, condition = base::local({
[16:13:42.015]             c <- base::c
[16:13:42.015]             inherits <- base::inherits
[16:13:42.015]             invokeRestart <- base::invokeRestart
[16:13:42.015]             length <- base::length
[16:13:42.015]             list <- base::list
[16:13:42.015]             seq.int <- base::seq.int
[16:13:42.015]             signalCondition <- base::signalCondition
[16:13:42.015]             sys.calls <- base::sys.calls
[16:13:42.015]             `[[` <- base::`[[`
[16:13:42.015]             `+` <- base::`+`
[16:13:42.015]             `<<-` <- base::`<<-`
[16:13:42.015]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:42.015]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:42.015]                   3L)]
[16:13:42.015]             }
[16:13:42.015]             function(cond) {
[16:13:42.015]                 is_error <- inherits(cond, "error")
[16:13:42.015]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:42.015]                   NULL)
[16:13:42.015]                 if (is_error) {
[16:13:42.015]                   sessionInformation <- function() {
[16:13:42.015]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:42.015]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:42.015]                       search = base::search(), system = base::Sys.info())
[16:13:42.015]                   }
[16:13:42.015]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.015]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:42.015]                     cond$call), session = sessionInformation(), 
[16:13:42.015]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:42.015]                   signalCondition(cond)
[16:13:42.015]                 }
[16:13:42.015]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:42.015]                 "immediateCondition"))) {
[16:13:42.015]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:42.015]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.015]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:42.015]                   if (TRUE && !signal) {
[16:13:42.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.015]                     {
[16:13:42.015]                       inherits <- base::inherits
[16:13:42.015]                       invokeRestart <- base::invokeRestart
[16:13:42.015]                       is.null <- base::is.null
[16:13:42.015]                       muffled <- FALSE
[16:13:42.015]                       if (inherits(cond, "message")) {
[16:13:42.015]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.015]                         if (muffled) 
[16:13:42.015]                           invokeRestart("muffleMessage")
[16:13:42.015]                       }
[16:13:42.015]                       else if (inherits(cond, "warning")) {
[16:13:42.015]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.015]                         if (muffled) 
[16:13:42.015]                           invokeRestart("muffleWarning")
[16:13:42.015]                       }
[16:13:42.015]                       else if (inherits(cond, "condition")) {
[16:13:42.015]                         if (!is.null(pattern)) {
[16:13:42.015]                           computeRestarts <- base::computeRestarts
[16:13:42.015]                           grepl <- base::grepl
[16:13:42.015]                           restarts <- computeRestarts(cond)
[16:13:42.015]                           for (restart in restarts) {
[16:13:42.015]                             name <- restart$name
[16:13:42.015]                             if (is.null(name)) 
[16:13:42.015]                               next
[16:13:42.015]                             if (!grepl(pattern, name)) 
[16:13:42.015]                               next
[16:13:42.015]                             invokeRestart(restart)
[16:13:42.015]                             muffled <- TRUE
[16:13:42.015]                             break
[16:13:42.015]                           }
[16:13:42.015]                         }
[16:13:42.015]                       }
[16:13:42.015]                       invisible(muffled)
[16:13:42.015]                     }
[16:13:42.015]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.015]                   }
[16:13:42.015]                 }
[16:13:42.015]                 else {
[16:13:42.015]                   if (TRUE) {
[16:13:42.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.015]                     {
[16:13:42.015]                       inherits <- base::inherits
[16:13:42.015]                       invokeRestart <- base::invokeRestart
[16:13:42.015]                       is.null <- base::is.null
[16:13:42.015]                       muffled <- FALSE
[16:13:42.015]                       if (inherits(cond, "message")) {
[16:13:42.015]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.015]                         if (muffled) 
[16:13:42.015]                           invokeRestart("muffleMessage")
[16:13:42.015]                       }
[16:13:42.015]                       else if (inherits(cond, "warning")) {
[16:13:42.015]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.015]                         if (muffled) 
[16:13:42.015]                           invokeRestart("muffleWarning")
[16:13:42.015]                       }
[16:13:42.015]                       else if (inherits(cond, "condition")) {
[16:13:42.015]                         if (!is.null(pattern)) {
[16:13:42.015]                           computeRestarts <- base::computeRestarts
[16:13:42.015]                           grepl <- base::grepl
[16:13:42.015]                           restarts <- computeRestarts(cond)
[16:13:42.015]                           for (restart in restarts) {
[16:13:42.015]                             name <- restart$name
[16:13:42.015]                             if (is.null(name)) 
[16:13:42.015]                               next
[16:13:42.015]                             if (!grepl(pattern, name)) 
[16:13:42.015]                               next
[16:13:42.015]                             invokeRestart(restart)
[16:13:42.015]                             muffled <- TRUE
[16:13:42.015]                             break
[16:13:42.015]                           }
[16:13:42.015]                         }
[16:13:42.015]                       }
[16:13:42.015]                       invisible(muffled)
[16:13:42.015]                     }
[16:13:42.015]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.015]                   }
[16:13:42.015]                 }
[16:13:42.015]             }
[16:13:42.015]         }))
[16:13:42.015]     }, error = function(ex) {
[16:13:42.015]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:42.015]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.015]                 ...future.rng), started = ...future.startTime, 
[16:13:42.015]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:42.015]             version = "1.8"), class = "FutureResult")
[16:13:42.015]     }, finally = {
[16:13:42.015]         if (!identical(...future.workdir, getwd())) 
[16:13:42.015]             setwd(...future.workdir)
[16:13:42.015]         {
[16:13:42.015]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:42.015]                 ...future.oldOptions$nwarnings <- NULL
[16:13:42.015]             }
[16:13:42.015]             base::options(...future.oldOptions)
[16:13:42.015]             if (.Platform$OS.type == "windows") {
[16:13:42.015]                 old_names <- names(...future.oldEnvVars)
[16:13:42.015]                 envs <- base::Sys.getenv()
[16:13:42.015]                 names <- names(envs)
[16:13:42.015]                 common <- intersect(names, old_names)
[16:13:42.015]                 added <- setdiff(names, old_names)
[16:13:42.015]                 removed <- setdiff(old_names, names)
[16:13:42.015]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:42.015]                   envs[common]]
[16:13:42.015]                 NAMES <- toupper(changed)
[16:13:42.015]                 args <- list()
[16:13:42.015]                 for (kk in seq_along(NAMES)) {
[16:13:42.015]                   name <- changed[[kk]]
[16:13:42.015]                   NAME <- NAMES[[kk]]
[16:13:42.015]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.015]                     next
[16:13:42.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.015]                 }
[16:13:42.015]                 NAMES <- toupper(added)
[16:13:42.015]                 for (kk in seq_along(NAMES)) {
[16:13:42.015]                   name <- added[[kk]]
[16:13:42.015]                   NAME <- NAMES[[kk]]
[16:13:42.015]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.015]                     next
[16:13:42.015]                   args[[name]] <- ""
[16:13:42.015]                 }
[16:13:42.015]                 NAMES <- toupper(removed)
[16:13:42.015]                 for (kk in seq_along(NAMES)) {
[16:13:42.015]                   name <- removed[[kk]]
[16:13:42.015]                   NAME <- NAMES[[kk]]
[16:13:42.015]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.015]                     next
[16:13:42.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.015]                 }
[16:13:42.015]                 if (length(args) > 0) 
[16:13:42.015]                   base::do.call(base::Sys.setenv, args = args)
[16:13:42.015]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:42.015]             }
[16:13:42.015]             else {
[16:13:42.015]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:42.015]             }
[16:13:42.015]             {
[16:13:42.015]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:42.015]                   0L) {
[16:13:42.015]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:42.015]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:42.015]                   base::options(opts)
[16:13:42.015]                 }
[16:13:42.015]                 {
[16:13:42.015]                   {
[16:13:42.015]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:42.015]                     NULL
[16:13:42.015]                   }
[16:13:42.015]                   options(future.plan = NULL)
[16:13:42.015]                   if (is.na(NA_character_)) 
[16:13:42.015]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.015]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:42.015]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:42.015]                     envir = parent.frame()) 
[16:13:42.015]                   {
[16:13:42.015]                     default_workers <- missing(workers)
[16:13:42.015]                     if (is.function(workers)) 
[16:13:42.015]                       workers <- workers()
[16:13:42.015]                     workers <- structure(as.integer(workers), 
[16:13:42.015]                       class = class(workers))
[16:13:42.015]                     stop_if_not(is.finite(workers), workers >= 
[16:13:42.015]                       1L)
[16:13:42.015]                     if ((workers == 1L && !inherits(workers, 
[16:13:42.015]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:42.015]                       if (default_workers) 
[16:13:42.015]                         supportsMulticore(warn = TRUE)
[16:13:42.015]                       return(sequential(..., envir = envir))
[16:13:42.015]                     }
[16:13:42.015]                     oopts <- options(mc.cores = workers)
[16:13:42.015]                     on.exit(options(oopts))
[16:13:42.015]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:42.015]                       envir = envir)
[16:13:42.015]                     if (!future$lazy) 
[16:13:42.015]                       future <- run(future)
[16:13:42.015]                     invisible(future)
[16:13:42.015]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:42.015]                 }
[16:13:42.015]             }
[16:13:42.015]         }
[16:13:42.015]     })
[16:13:42.015]     if (TRUE) {
[16:13:42.015]         base::sink(type = "output", split = FALSE)
[16:13:42.015]         if (TRUE) {
[16:13:42.015]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:42.015]         }
[16:13:42.015]         else {
[16:13:42.015]             ...future.result["stdout"] <- base::list(NULL)
[16:13:42.015]         }
[16:13:42.015]         base::close(...future.stdout)
[16:13:42.015]         ...future.stdout <- NULL
[16:13:42.015]     }
[16:13:42.015]     ...future.result$conditions <- ...future.conditions
[16:13:42.015]     ...future.result$finished <- base::Sys.time()
[16:13:42.015]     ...future.result
[16:13:42.015] }
[16:13:42.018] requestCore(): workers = 2
[16:13:42.019] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:42.033] MulticoreFuture started
[16:13:42.033] - Launch lazy future ... done
[16:13:42.033] run() for ‘MulticoreFuture’ ... done
[16:13:42.034] getGlobalsAndPackages() ...
[16:13:42.034] plan(): Setting new future strategy stack:
[16:13:42.034] Searching for globals...
[16:13:42.034] List of future strategies:
[16:13:42.034] 1. sequential:
[16:13:42.034]    - args: function (..., envir = parent.frame())
[16:13:42.034]    - tweaked: FALSE
[16:13:42.034]    - call: NULL
[16:13:42.035] 
[16:13:42.035] Searching for globals ... DONE
[16:13:42.035] plan(): nbrOfWorkers() = 1
[16:13:42.035] - globals: [0] <none>
[16:13:42.035] getGlobalsAndPackages() ... DONE
[16:13:42.036] run() for ‘Future’ ...
[16:13:42.036] - state: ‘created’
[16:13:42.036] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:42.037] plan(): Setting new future strategy stack:
[16:13:42.037] List of future strategies:
[16:13:42.037] 1. multicore:
[16:13:42.037]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:42.037]    - tweaked: FALSE
[16:13:42.037]    - call: plan(strategy)
[16:13:42.042] plan(): nbrOfWorkers() = 2
[16:13:42.042] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:42.042] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:42.042]   - Field: ‘label’
[16:13:42.043]   - Field: ‘local’
[16:13:42.043]   - Field: ‘owner’
[16:13:42.043]   - Field: ‘envir’
[16:13:42.043]   - Field: ‘workers’
[16:13:42.043]   - Field: ‘packages’
[16:13:42.044]   - Field: ‘gc’
[16:13:42.044]   - Field: ‘job’
[16:13:42.044]   - Field: ‘conditions’
[16:13:42.044]   - Field: ‘expr’
[16:13:42.044]   - Field: ‘uuid’
[16:13:42.044]   - Field: ‘seed’
[16:13:42.045]   - Field: ‘version’
[16:13:42.045]   - Field: ‘result’
[16:13:42.045]   - Field: ‘asynchronous’
[16:13:42.045]   - Field: ‘calls’
[16:13:42.045]   - Field: ‘globals’
[16:13:42.045]   - Field: ‘stdout’
[16:13:42.045]   - Field: ‘earlySignal’
[16:13:42.046]   - Field: ‘lazy’
[16:13:42.046]   - Field: ‘state’
[16:13:42.046] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:42.046] - Launch lazy future ...
[16:13:42.047] Packages needed by the future expression (n = 0): <none>
[16:13:42.047] Packages needed by future strategies (n = 0): <none>
[16:13:42.047] {
[16:13:42.047]     {
[16:13:42.047]         {
[16:13:42.047]             ...future.startTime <- base::Sys.time()
[16:13:42.047]             {
[16:13:42.047]                 {
[16:13:42.047]                   {
[16:13:42.047]                     {
[16:13:42.047]                       base::local({
[16:13:42.047]                         has_future <- base::requireNamespace("future", 
[16:13:42.047]                           quietly = TRUE)
[16:13:42.047]                         if (has_future) {
[16:13:42.047]                           ns <- base::getNamespace("future")
[16:13:42.047]                           version <- ns[[".package"]][["version"]]
[16:13:42.047]                           if (is.null(version)) 
[16:13:42.047]                             version <- utils::packageVersion("future")
[16:13:42.047]                         }
[16:13:42.047]                         else {
[16:13:42.047]                           version <- NULL
[16:13:42.047]                         }
[16:13:42.047]                         if (!has_future || version < "1.8.0") {
[16:13:42.047]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:42.047]                             "", base::R.version$version.string), 
[16:13:42.047]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:42.047]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:42.047]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:42.047]                               "release", "version")], collapse = " "), 
[16:13:42.047]                             hostname = base::Sys.info()[["nodename"]])
[16:13:42.047]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:42.047]                             info)
[16:13:42.047]                           info <- base::paste(info, collapse = "; ")
[16:13:42.047]                           if (!has_future) {
[16:13:42.047]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:42.047]                               info)
[16:13:42.047]                           }
[16:13:42.047]                           else {
[16:13:42.047]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:42.047]                               info, version)
[16:13:42.047]                           }
[16:13:42.047]                           base::stop(msg)
[16:13:42.047]                         }
[16:13:42.047]                       })
[16:13:42.047]                     }
[16:13:42.047]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:42.047]                     base::options(mc.cores = 1L)
[16:13:42.047]                   }
[16:13:42.047]                   options(future.plan = NULL)
[16:13:42.047]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.047]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:42.047]                 }
[16:13:42.047]                 ...future.workdir <- getwd()
[16:13:42.047]             }
[16:13:42.047]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:42.047]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:42.047]         }
[16:13:42.047]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:42.047]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:42.047]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:42.047]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:42.047]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:42.047]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:42.047]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:42.047]             base::names(...future.oldOptions))
[16:13:42.047]     }
[16:13:42.047]     if (FALSE) {
[16:13:42.047]     }
[16:13:42.047]     else {
[16:13:42.047]         if (TRUE) {
[16:13:42.047]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:42.047]                 open = "w")
[16:13:42.047]         }
[16:13:42.047]         else {
[16:13:42.047]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:42.047]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:42.047]         }
[16:13:42.047]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:42.047]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:42.047]             base::sink(type = "output", split = FALSE)
[16:13:42.047]             base::close(...future.stdout)
[16:13:42.047]         }, add = TRUE)
[16:13:42.047]     }
[16:13:42.047]     ...future.frame <- base::sys.nframe()
[16:13:42.047]     ...future.conditions <- base::list()
[16:13:42.047]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:42.047]     if (FALSE) {
[16:13:42.047]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:42.047]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:42.047]     }
[16:13:42.047]     ...future.result <- base::tryCatch({
[16:13:42.047]         base::withCallingHandlers({
[16:13:42.047]             ...future.value <- base::withVisible(base::local({
[16:13:42.047]                 withCallingHandlers({
[16:13:42.047]                   2
[16:13:42.047]                 }, immediateCondition = function(cond) {
[16:13:42.047]                   save_rds <- function (object, pathname, ...) 
[16:13:42.047]                   {
[16:13:42.047]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:42.047]                     if (file_test("-f", pathname_tmp)) {
[16:13:42.047]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.047]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:42.047]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.047]                         fi_tmp[["mtime"]])
[16:13:42.047]                     }
[16:13:42.047]                     tryCatch({
[16:13:42.047]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:42.047]                     }, error = function(ex) {
[16:13:42.047]                       msg <- conditionMessage(ex)
[16:13:42.047]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.047]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:42.047]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.047]                         fi_tmp[["mtime"]], msg)
[16:13:42.047]                       ex$message <- msg
[16:13:42.047]                       stop(ex)
[16:13:42.047]                     })
[16:13:42.047]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:42.047]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:42.047]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:42.047]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.047]                       fi <- file.info(pathname)
[16:13:42.047]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:42.047]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.047]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:42.047]                         fi[["size"]], fi[["mtime"]])
[16:13:42.047]                       stop(msg)
[16:13:42.047]                     }
[16:13:42.047]                     invisible(pathname)
[16:13:42.047]                   }
[16:13:42.047]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:42.047]                     rootPath = tempdir()) 
[16:13:42.047]                   {
[16:13:42.047]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:42.047]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:42.047]                       tmpdir = path, fileext = ".rds")
[16:13:42.047]                     save_rds(obj, file)
[16:13:42.047]                   }
[16:13:42.047]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:42.047]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.047]                   {
[16:13:42.047]                     inherits <- base::inherits
[16:13:42.047]                     invokeRestart <- base::invokeRestart
[16:13:42.047]                     is.null <- base::is.null
[16:13:42.047]                     muffled <- FALSE
[16:13:42.047]                     if (inherits(cond, "message")) {
[16:13:42.047]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:42.047]                       if (muffled) 
[16:13:42.047]                         invokeRestart("muffleMessage")
[16:13:42.047]                     }
[16:13:42.047]                     else if (inherits(cond, "warning")) {
[16:13:42.047]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:42.047]                       if (muffled) 
[16:13:42.047]                         invokeRestart("muffleWarning")
[16:13:42.047]                     }
[16:13:42.047]                     else if (inherits(cond, "condition")) {
[16:13:42.047]                       if (!is.null(pattern)) {
[16:13:42.047]                         computeRestarts <- base::computeRestarts
[16:13:42.047]                         grepl <- base::grepl
[16:13:42.047]                         restarts <- computeRestarts(cond)
[16:13:42.047]                         for (restart in restarts) {
[16:13:42.047]                           name <- restart$name
[16:13:42.047]                           if (is.null(name)) 
[16:13:42.047]                             next
[16:13:42.047]                           if (!grepl(pattern, name)) 
[16:13:42.047]                             next
[16:13:42.047]                           invokeRestart(restart)
[16:13:42.047]                           muffled <- TRUE
[16:13:42.047]                           break
[16:13:42.047]                         }
[16:13:42.047]                       }
[16:13:42.047]                     }
[16:13:42.047]                     invisible(muffled)
[16:13:42.047]                   }
[16:13:42.047]                   muffleCondition(cond)
[16:13:42.047]                 })
[16:13:42.047]             }))
[16:13:42.047]             future::FutureResult(value = ...future.value$value, 
[16:13:42.047]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.047]                   ...future.rng), globalenv = if (FALSE) 
[16:13:42.047]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:42.047]                     ...future.globalenv.names))
[16:13:42.047]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:42.047]         }, condition = base::local({
[16:13:42.047]             c <- base::c
[16:13:42.047]             inherits <- base::inherits
[16:13:42.047]             invokeRestart <- base::invokeRestart
[16:13:42.047]             length <- base::length
[16:13:42.047]             list <- base::list
[16:13:42.047]             seq.int <- base::seq.int
[16:13:42.047]             signalCondition <- base::signalCondition
[16:13:42.047]             sys.calls <- base::sys.calls
[16:13:42.047]             `[[` <- base::`[[`
[16:13:42.047]             `+` <- base::`+`
[16:13:42.047]             `<<-` <- base::`<<-`
[16:13:42.047]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:42.047]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:42.047]                   3L)]
[16:13:42.047]             }
[16:13:42.047]             function(cond) {
[16:13:42.047]                 is_error <- inherits(cond, "error")
[16:13:42.047]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:42.047]                   NULL)
[16:13:42.047]                 if (is_error) {
[16:13:42.047]                   sessionInformation <- function() {
[16:13:42.047]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:42.047]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:42.047]                       search = base::search(), system = base::Sys.info())
[16:13:42.047]                   }
[16:13:42.047]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.047]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:42.047]                     cond$call), session = sessionInformation(), 
[16:13:42.047]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:42.047]                   signalCondition(cond)
[16:13:42.047]                 }
[16:13:42.047]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:42.047]                 "immediateCondition"))) {
[16:13:42.047]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:42.047]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.047]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:42.047]                   if (TRUE && !signal) {
[16:13:42.047]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.047]                     {
[16:13:42.047]                       inherits <- base::inherits
[16:13:42.047]                       invokeRestart <- base::invokeRestart
[16:13:42.047]                       is.null <- base::is.null
[16:13:42.047]                       muffled <- FALSE
[16:13:42.047]                       if (inherits(cond, "message")) {
[16:13:42.047]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.047]                         if (muffled) 
[16:13:42.047]                           invokeRestart("muffleMessage")
[16:13:42.047]                       }
[16:13:42.047]                       else if (inherits(cond, "warning")) {
[16:13:42.047]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.047]                         if (muffled) 
[16:13:42.047]                           invokeRestart("muffleWarning")
[16:13:42.047]                       }
[16:13:42.047]                       else if (inherits(cond, "condition")) {
[16:13:42.047]                         if (!is.null(pattern)) {
[16:13:42.047]                           computeRestarts <- base::computeRestarts
[16:13:42.047]                           grepl <- base::grepl
[16:13:42.047]                           restarts <- computeRestarts(cond)
[16:13:42.047]                           for (restart in restarts) {
[16:13:42.047]                             name <- restart$name
[16:13:42.047]                             if (is.null(name)) 
[16:13:42.047]                               next
[16:13:42.047]                             if (!grepl(pattern, name)) 
[16:13:42.047]                               next
[16:13:42.047]                             invokeRestart(restart)
[16:13:42.047]                             muffled <- TRUE
[16:13:42.047]                             break
[16:13:42.047]                           }
[16:13:42.047]                         }
[16:13:42.047]                       }
[16:13:42.047]                       invisible(muffled)
[16:13:42.047]                     }
[16:13:42.047]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.047]                   }
[16:13:42.047]                 }
[16:13:42.047]                 else {
[16:13:42.047]                   if (TRUE) {
[16:13:42.047]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.047]                     {
[16:13:42.047]                       inherits <- base::inherits
[16:13:42.047]                       invokeRestart <- base::invokeRestart
[16:13:42.047]                       is.null <- base::is.null
[16:13:42.047]                       muffled <- FALSE
[16:13:42.047]                       if (inherits(cond, "message")) {
[16:13:42.047]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.047]                         if (muffled) 
[16:13:42.047]                           invokeRestart("muffleMessage")
[16:13:42.047]                       }
[16:13:42.047]                       else if (inherits(cond, "warning")) {
[16:13:42.047]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.047]                         if (muffled) 
[16:13:42.047]                           invokeRestart("muffleWarning")
[16:13:42.047]                       }
[16:13:42.047]                       else if (inherits(cond, "condition")) {
[16:13:42.047]                         if (!is.null(pattern)) {
[16:13:42.047]                           computeRestarts <- base::computeRestarts
[16:13:42.047]                           grepl <- base::grepl
[16:13:42.047]                           restarts <- computeRestarts(cond)
[16:13:42.047]                           for (restart in restarts) {
[16:13:42.047]                             name <- restart$name
[16:13:42.047]                             if (is.null(name)) 
[16:13:42.047]                               next
[16:13:42.047]                             if (!grepl(pattern, name)) 
[16:13:42.047]                               next
[16:13:42.047]                             invokeRestart(restart)
[16:13:42.047]                             muffled <- TRUE
[16:13:42.047]                             break
[16:13:42.047]                           }
[16:13:42.047]                         }
[16:13:42.047]                       }
[16:13:42.047]                       invisible(muffled)
[16:13:42.047]                     }
[16:13:42.047]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.047]                   }
[16:13:42.047]                 }
[16:13:42.047]             }
[16:13:42.047]         }))
[16:13:42.047]     }, error = function(ex) {
[16:13:42.047]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:42.047]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.047]                 ...future.rng), started = ...future.startTime, 
[16:13:42.047]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:42.047]             version = "1.8"), class = "FutureResult")
[16:13:42.047]     }, finally = {
[16:13:42.047]         if (!identical(...future.workdir, getwd())) 
[16:13:42.047]             setwd(...future.workdir)
[16:13:42.047]         {
[16:13:42.047]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:42.047]                 ...future.oldOptions$nwarnings <- NULL
[16:13:42.047]             }
[16:13:42.047]             base::options(...future.oldOptions)
[16:13:42.047]             if (.Platform$OS.type == "windows") {
[16:13:42.047]                 old_names <- names(...future.oldEnvVars)
[16:13:42.047]                 envs <- base::Sys.getenv()
[16:13:42.047]                 names <- names(envs)
[16:13:42.047]                 common <- intersect(names, old_names)
[16:13:42.047]                 added <- setdiff(names, old_names)
[16:13:42.047]                 removed <- setdiff(old_names, names)
[16:13:42.047]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:42.047]                   envs[common]]
[16:13:42.047]                 NAMES <- toupper(changed)
[16:13:42.047]                 args <- list()
[16:13:42.047]                 for (kk in seq_along(NAMES)) {
[16:13:42.047]                   name <- changed[[kk]]
[16:13:42.047]                   NAME <- NAMES[[kk]]
[16:13:42.047]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.047]                     next
[16:13:42.047]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.047]                 }
[16:13:42.047]                 NAMES <- toupper(added)
[16:13:42.047]                 for (kk in seq_along(NAMES)) {
[16:13:42.047]                   name <- added[[kk]]
[16:13:42.047]                   NAME <- NAMES[[kk]]
[16:13:42.047]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.047]                     next
[16:13:42.047]                   args[[name]] <- ""
[16:13:42.047]                 }
[16:13:42.047]                 NAMES <- toupper(removed)
[16:13:42.047]                 for (kk in seq_along(NAMES)) {
[16:13:42.047]                   name <- removed[[kk]]
[16:13:42.047]                   NAME <- NAMES[[kk]]
[16:13:42.047]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.047]                     next
[16:13:42.047]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.047]                 }
[16:13:42.047]                 if (length(args) > 0) 
[16:13:42.047]                   base::do.call(base::Sys.setenv, args = args)
[16:13:42.047]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:42.047]             }
[16:13:42.047]             else {
[16:13:42.047]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:42.047]             }
[16:13:42.047]             {
[16:13:42.047]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:42.047]                   0L) {
[16:13:42.047]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:42.047]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:42.047]                   base::options(opts)
[16:13:42.047]                 }
[16:13:42.047]                 {
[16:13:42.047]                   {
[16:13:42.047]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:42.047]                     NULL
[16:13:42.047]                   }
[16:13:42.047]                   options(future.plan = NULL)
[16:13:42.047]                   if (is.na(NA_character_)) 
[16:13:42.047]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.047]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:42.047]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:42.047]                     envir = parent.frame()) 
[16:13:42.047]                   {
[16:13:42.047]                     default_workers <- missing(workers)
[16:13:42.047]                     if (is.function(workers)) 
[16:13:42.047]                       workers <- workers()
[16:13:42.047]                     workers <- structure(as.integer(workers), 
[16:13:42.047]                       class = class(workers))
[16:13:42.047]                     stop_if_not(is.finite(workers), workers >= 
[16:13:42.047]                       1L)
[16:13:42.047]                     if ((workers == 1L && !inherits(workers, 
[16:13:42.047]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:42.047]                       if (default_workers) 
[16:13:42.047]                         supportsMulticore(warn = TRUE)
[16:13:42.047]                       return(sequential(..., envir = envir))
[16:13:42.047]                     }
[16:13:42.047]                     oopts <- options(mc.cores = workers)
[16:13:42.047]                     on.exit(options(oopts))
[16:13:42.047]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:42.047]                       envir = envir)
[16:13:42.047]                     if (!future$lazy) 
[16:13:42.047]                       future <- run(future)
[16:13:42.047]                     invisible(future)
[16:13:42.047]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:42.047]                 }
[16:13:42.047]             }
[16:13:42.047]         }
[16:13:42.047]     })
[16:13:42.047]     if (TRUE) {
[16:13:42.047]         base::sink(type = "output", split = FALSE)
[16:13:42.047]         if (TRUE) {
[16:13:42.047]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:42.047]         }
[16:13:42.047]         else {
[16:13:42.047]             ...future.result["stdout"] <- base::list(NULL)
[16:13:42.047]         }
[16:13:42.047]         base::close(...future.stdout)
[16:13:42.047]         ...future.stdout <- NULL
[16:13:42.047]     }
[16:13:42.047]     ...future.result$conditions <- ...future.conditions
[16:13:42.047]     ...future.result$finished <- base::Sys.time()
[16:13:42.047]     ...future.result
[16:13:42.047] }
[16:13:42.051] requestCore(): workers = 2
[16:13:42.051] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:42.072] MulticoreFuture started
[16:13:42.073] - Launch lazy future ... done
[16:13:42.073] run() for ‘MulticoreFuture’ ... done
[16:13:42.073] plan(): Setting new future strategy stack:
[16:13:42.074] List of future strategies:
[16:13:42.074] 1. sequential:
[16:13:42.074]    - args: function (..., envir = parent.frame())
[16:13:42.074]    - tweaked: FALSE
[16:13:42.074]    - call: NULL
[16:13:42.076] plan(): nbrOfWorkers() = 1
[16:13:42.077] resolve() on environment ...
[16:13:42.077]  recursive: 0
[16:13:42.079] plan(): Setting new future strategy stack:
[16:13:42.079]  elements: [3] ‘a’, ‘b’, ‘c’
[16:13:42.080] Future #1
[16:13:42.079] List of future strategies:
[16:13:42.079] 1. multicore:
[16:13:42.079]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:42.079]    - tweaked: FALSE
[16:13:42.079]    - call: plan(strategy)
[16:13:42.081]  length: 2 (resolved future 1)
[16:13:42.085] plan(): nbrOfWorkers() = 2
[16:13:42.086] Future #2
[16:13:42.086]  length: 1 (resolved future 2)
[16:13:42.086]  length: 0 (resolved future 3)
[16:13:42.086] resolve() on environment ... DONE
[16:13:42.088] getGlobalsAndPackages() ...
[16:13:42.088] Searching for globals...
[16:13:42.089] - globals found: [1] ‘{’
[16:13:42.090] Searching for globals ... DONE
[16:13:42.090] Resolving globals: FALSE
[16:13:42.090] 
[16:13:42.090] 
[16:13:42.091] getGlobalsAndPackages() ... DONE
[16:13:42.091] run() for ‘Future’ ...
[16:13:42.092] - state: ‘created’
[16:13:42.092] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:42.096] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:42.096] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:42.097]   - Field: ‘label’
[16:13:42.097]   - Field: ‘local’
[16:13:42.097]   - Field: ‘owner’
[16:13:42.097]   - Field: ‘envir’
[16:13:42.097]   - Field: ‘workers’
[16:13:42.097]   - Field: ‘packages’
[16:13:42.098]   - Field: ‘gc’
[16:13:42.098]   - Field: ‘job’
[16:13:42.098]   - Field: ‘conditions’
[16:13:42.098]   - Field: ‘expr’
[16:13:42.098]   - Field: ‘uuid’
[16:13:42.098]   - Field: ‘seed’
[16:13:42.098]   - Field: ‘version’
[16:13:42.099]   - Field: ‘result’
[16:13:42.099]   - Field: ‘asynchronous’
[16:13:42.099]   - Field: ‘calls’
[16:13:42.099]   - Field: ‘globals’
[16:13:42.099]   - Field: ‘stdout’
[16:13:42.099]   - Field: ‘earlySignal’
[16:13:42.099]   - Field: ‘lazy’
[16:13:42.099]   - Field: ‘state’
[16:13:42.100] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:42.100] - Launch lazy future ...
[16:13:42.100] Packages needed by the future expression (n = 0): <none>
[16:13:42.100] Packages needed by future strategies (n = 0): <none>
[16:13:42.101] {
[16:13:42.101]     {
[16:13:42.101]         {
[16:13:42.101]             ...future.startTime <- base::Sys.time()
[16:13:42.101]             {
[16:13:42.101]                 {
[16:13:42.101]                   {
[16:13:42.101]                     {
[16:13:42.101]                       base::local({
[16:13:42.101]                         has_future <- base::requireNamespace("future", 
[16:13:42.101]                           quietly = TRUE)
[16:13:42.101]                         if (has_future) {
[16:13:42.101]                           ns <- base::getNamespace("future")
[16:13:42.101]                           version <- ns[[".package"]][["version"]]
[16:13:42.101]                           if (is.null(version)) 
[16:13:42.101]                             version <- utils::packageVersion("future")
[16:13:42.101]                         }
[16:13:42.101]                         else {
[16:13:42.101]                           version <- NULL
[16:13:42.101]                         }
[16:13:42.101]                         if (!has_future || version < "1.8.0") {
[16:13:42.101]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:42.101]                             "", base::R.version$version.string), 
[16:13:42.101]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:42.101]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:42.101]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:42.101]                               "release", "version")], collapse = " "), 
[16:13:42.101]                             hostname = base::Sys.info()[["nodename"]])
[16:13:42.101]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:42.101]                             info)
[16:13:42.101]                           info <- base::paste(info, collapse = "; ")
[16:13:42.101]                           if (!has_future) {
[16:13:42.101]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:42.101]                               info)
[16:13:42.101]                           }
[16:13:42.101]                           else {
[16:13:42.101]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:42.101]                               info, version)
[16:13:42.101]                           }
[16:13:42.101]                           base::stop(msg)
[16:13:42.101]                         }
[16:13:42.101]                       })
[16:13:42.101]                     }
[16:13:42.101]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:42.101]                     base::options(mc.cores = 1L)
[16:13:42.101]                   }
[16:13:42.101]                   options(future.plan = NULL)
[16:13:42.101]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.101]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:42.101]                 }
[16:13:42.101]                 ...future.workdir <- getwd()
[16:13:42.101]             }
[16:13:42.101]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:42.101]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:42.101]         }
[16:13:42.101]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:42.101]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:42.101]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:42.101]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:42.101]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:42.101]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:42.101]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:42.101]             base::names(...future.oldOptions))
[16:13:42.101]     }
[16:13:42.101]     if (FALSE) {
[16:13:42.101]     }
[16:13:42.101]     else {
[16:13:42.101]         if (TRUE) {
[16:13:42.101]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:42.101]                 open = "w")
[16:13:42.101]         }
[16:13:42.101]         else {
[16:13:42.101]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:42.101]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:42.101]         }
[16:13:42.101]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:42.101]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:42.101]             base::sink(type = "output", split = FALSE)
[16:13:42.101]             base::close(...future.stdout)
[16:13:42.101]         }, add = TRUE)
[16:13:42.101]     }
[16:13:42.101]     ...future.frame <- base::sys.nframe()
[16:13:42.101]     ...future.conditions <- base::list()
[16:13:42.101]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:42.101]     if (FALSE) {
[16:13:42.101]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:42.101]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:42.101]     }
[16:13:42.101]     ...future.result <- base::tryCatch({
[16:13:42.101]         base::withCallingHandlers({
[16:13:42.101]             ...future.value <- base::withVisible(base::local({
[16:13:42.101]                 withCallingHandlers({
[16:13:42.101]                   {
[16:13:42.101]                     1
[16:13:42.101]                   }
[16:13:42.101]                 }, immediateCondition = function(cond) {
[16:13:42.101]                   save_rds <- function (object, pathname, ...) 
[16:13:42.101]                   {
[16:13:42.101]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:42.101]                     if (file_test("-f", pathname_tmp)) {
[16:13:42.101]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.101]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:42.101]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.101]                         fi_tmp[["mtime"]])
[16:13:42.101]                     }
[16:13:42.101]                     tryCatch({
[16:13:42.101]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:42.101]                     }, error = function(ex) {
[16:13:42.101]                       msg <- conditionMessage(ex)
[16:13:42.101]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.101]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:42.101]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.101]                         fi_tmp[["mtime"]], msg)
[16:13:42.101]                       ex$message <- msg
[16:13:42.101]                       stop(ex)
[16:13:42.101]                     })
[16:13:42.101]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:42.101]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:42.101]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:42.101]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.101]                       fi <- file.info(pathname)
[16:13:42.101]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:42.101]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.101]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:42.101]                         fi[["size"]], fi[["mtime"]])
[16:13:42.101]                       stop(msg)
[16:13:42.101]                     }
[16:13:42.101]                     invisible(pathname)
[16:13:42.101]                   }
[16:13:42.101]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:42.101]                     rootPath = tempdir()) 
[16:13:42.101]                   {
[16:13:42.101]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:42.101]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:42.101]                       tmpdir = path, fileext = ".rds")
[16:13:42.101]                     save_rds(obj, file)
[16:13:42.101]                   }
[16:13:42.101]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:42.101]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.101]                   {
[16:13:42.101]                     inherits <- base::inherits
[16:13:42.101]                     invokeRestart <- base::invokeRestart
[16:13:42.101]                     is.null <- base::is.null
[16:13:42.101]                     muffled <- FALSE
[16:13:42.101]                     if (inherits(cond, "message")) {
[16:13:42.101]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:42.101]                       if (muffled) 
[16:13:42.101]                         invokeRestart("muffleMessage")
[16:13:42.101]                     }
[16:13:42.101]                     else if (inherits(cond, "warning")) {
[16:13:42.101]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:42.101]                       if (muffled) 
[16:13:42.101]                         invokeRestart("muffleWarning")
[16:13:42.101]                     }
[16:13:42.101]                     else if (inherits(cond, "condition")) {
[16:13:42.101]                       if (!is.null(pattern)) {
[16:13:42.101]                         computeRestarts <- base::computeRestarts
[16:13:42.101]                         grepl <- base::grepl
[16:13:42.101]                         restarts <- computeRestarts(cond)
[16:13:42.101]                         for (restart in restarts) {
[16:13:42.101]                           name <- restart$name
[16:13:42.101]                           if (is.null(name)) 
[16:13:42.101]                             next
[16:13:42.101]                           if (!grepl(pattern, name)) 
[16:13:42.101]                             next
[16:13:42.101]                           invokeRestart(restart)
[16:13:42.101]                           muffled <- TRUE
[16:13:42.101]                           break
[16:13:42.101]                         }
[16:13:42.101]                       }
[16:13:42.101]                     }
[16:13:42.101]                     invisible(muffled)
[16:13:42.101]                   }
[16:13:42.101]                   muffleCondition(cond)
[16:13:42.101]                 })
[16:13:42.101]             }))
[16:13:42.101]             future::FutureResult(value = ...future.value$value, 
[16:13:42.101]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.101]                   ...future.rng), globalenv = if (FALSE) 
[16:13:42.101]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:42.101]                     ...future.globalenv.names))
[16:13:42.101]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:42.101]         }, condition = base::local({
[16:13:42.101]             c <- base::c
[16:13:42.101]             inherits <- base::inherits
[16:13:42.101]             invokeRestart <- base::invokeRestart
[16:13:42.101]             length <- base::length
[16:13:42.101]             list <- base::list
[16:13:42.101]             seq.int <- base::seq.int
[16:13:42.101]             signalCondition <- base::signalCondition
[16:13:42.101]             sys.calls <- base::sys.calls
[16:13:42.101]             `[[` <- base::`[[`
[16:13:42.101]             `+` <- base::`+`
[16:13:42.101]             `<<-` <- base::`<<-`
[16:13:42.101]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:42.101]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:42.101]                   3L)]
[16:13:42.101]             }
[16:13:42.101]             function(cond) {
[16:13:42.101]                 is_error <- inherits(cond, "error")
[16:13:42.101]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:42.101]                   NULL)
[16:13:42.101]                 if (is_error) {
[16:13:42.101]                   sessionInformation <- function() {
[16:13:42.101]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:42.101]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:42.101]                       search = base::search(), system = base::Sys.info())
[16:13:42.101]                   }
[16:13:42.101]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.101]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:42.101]                     cond$call), session = sessionInformation(), 
[16:13:42.101]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:42.101]                   signalCondition(cond)
[16:13:42.101]                 }
[16:13:42.101]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:42.101]                 "immediateCondition"))) {
[16:13:42.101]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:42.101]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.101]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:42.101]                   if (TRUE && !signal) {
[16:13:42.101]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.101]                     {
[16:13:42.101]                       inherits <- base::inherits
[16:13:42.101]                       invokeRestart <- base::invokeRestart
[16:13:42.101]                       is.null <- base::is.null
[16:13:42.101]                       muffled <- FALSE
[16:13:42.101]                       if (inherits(cond, "message")) {
[16:13:42.101]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.101]                         if (muffled) 
[16:13:42.101]                           invokeRestart("muffleMessage")
[16:13:42.101]                       }
[16:13:42.101]                       else if (inherits(cond, "warning")) {
[16:13:42.101]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.101]                         if (muffled) 
[16:13:42.101]                           invokeRestart("muffleWarning")
[16:13:42.101]                       }
[16:13:42.101]                       else if (inherits(cond, "condition")) {
[16:13:42.101]                         if (!is.null(pattern)) {
[16:13:42.101]                           computeRestarts <- base::computeRestarts
[16:13:42.101]                           grepl <- base::grepl
[16:13:42.101]                           restarts <- computeRestarts(cond)
[16:13:42.101]                           for (restart in restarts) {
[16:13:42.101]                             name <- restart$name
[16:13:42.101]                             if (is.null(name)) 
[16:13:42.101]                               next
[16:13:42.101]                             if (!grepl(pattern, name)) 
[16:13:42.101]                               next
[16:13:42.101]                             invokeRestart(restart)
[16:13:42.101]                             muffled <- TRUE
[16:13:42.101]                             break
[16:13:42.101]                           }
[16:13:42.101]                         }
[16:13:42.101]                       }
[16:13:42.101]                       invisible(muffled)
[16:13:42.101]                     }
[16:13:42.101]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.101]                   }
[16:13:42.101]                 }
[16:13:42.101]                 else {
[16:13:42.101]                   if (TRUE) {
[16:13:42.101]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.101]                     {
[16:13:42.101]                       inherits <- base::inherits
[16:13:42.101]                       invokeRestart <- base::invokeRestart
[16:13:42.101]                       is.null <- base::is.null
[16:13:42.101]                       muffled <- FALSE
[16:13:42.101]                       if (inherits(cond, "message")) {
[16:13:42.101]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.101]                         if (muffled) 
[16:13:42.101]                           invokeRestart("muffleMessage")
[16:13:42.101]                       }
[16:13:42.101]                       else if (inherits(cond, "warning")) {
[16:13:42.101]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.101]                         if (muffled) 
[16:13:42.101]                           invokeRestart("muffleWarning")
[16:13:42.101]                       }
[16:13:42.101]                       else if (inherits(cond, "condition")) {
[16:13:42.101]                         if (!is.null(pattern)) {
[16:13:42.101]                           computeRestarts <- base::computeRestarts
[16:13:42.101]                           grepl <- base::grepl
[16:13:42.101]                           restarts <- computeRestarts(cond)
[16:13:42.101]                           for (restart in restarts) {
[16:13:42.101]                             name <- restart$name
[16:13:42.101]                             if (is.null(name)) 
[16:13:42.101]                               next
[16:13:42.101]                             if (!grepl(pattern, name)) 
[16:13:42.101]                               next
[16:13:42.101]                             invokeRestart(restart)
[16:13:42.101]                             muffled <- TRUE
[16:13:42.101]                             break
[16:13:42.101]                           }
[16:13:42.101]                         }
[16:13:42.101]                       }
[16:13:42.101]                       invisible(muffled)
[16:13:42.101]                     }
[16:13:42.101]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.101]                   }
[16:13:42.101]                 }
[16:13:42.101]             }
[16:13:42.101]         }))
[16:13:42.101]     }, error = function(ex) {
[16:13:42.101]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:42.101]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.101]                 ...future.rng), started = ...future.startTime, 
[16:13:42.101]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:42.101]             version = "1.8"), class = "FutureResult")
[16:13:42.101]     }, finally = {
[16:13:42.101]         if (!identical(...future.workdir, getwd())) 
[16:13:42.101]             setwd(...future.workdir)
[16:13:42.101]         {
[16:13:42.101]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:42.101]                 ...future.oldOptions$nwarnings <- NULL
[16:13:42.101]             }
[16:13:42.101]             base::options(...future.oldOptions)
[16:13:42.101]             if (.Platform$OS.type == "windows") {
[16:13:42.101]                 old_names <- names(...future.oldEnvVars)
[16:13:42.101]                 envs <- base::Sys.getenv()
[16:13:42.101]                 names <- names(envs)
[16:13:42.101]                 common <- intersect(names, old_names)
[16:13:42.101]                 added <- setdiff(names, old_names)
[16:13:42.101]                 removed <- setdiff(old_names, names)
[16:13:42.101]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:42.101]                   envs[common]]
[16:13:42.101]                 NAMES <- toupper(changed)
[16:13:42.101]                 args <- list()
[16:13:42.101]                 for (kk in seq_along(NAMES)) {
[16:13:42.101]                   name <- changed[[kk]]
[16:13:42.101]                   NAME <- NAMES[[kk]]
[16:13:42.101]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.101]                     next
[16:13:42.101]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.101]                 }
[16:13:42.101]                 NAMES <- toupper(added)
[16:13:42.101]                 for (kk in seq_along(NAMES)) {
[16:13:42.101]                   name <- added[[kk]]
[16:13:42.101]                   NAME <- NAMES[[kk]]
[16:13:42.101]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.101]                     next
[16:13:42.101]                   args[[name]] <- ""
[16:13:42.101]                 }
[16:13:42.101]                 NAMES <- toupper(removed)
[16:13:42.101]                 for (kk in seq_along(NAMES)) {
[16:13:42.101]                   name <- removed[[kk]]
[16:13:42.101]                   NAME <- NAMES[[kk]]
[16:13:42.101]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.101]                     next
[16:13:42.101]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.101]                 }
[16:13:42.101]                 if (length(args) > 0) 
[16:13:42.101]                   base::do.call(base::Sys.setenv, args = args)
[16:13:42.101]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:42.101]             }
[16:13:42.101]             else {
[16:13:42.101]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:42.101]             }
[16:13:42.101]             {
[16:13:42.101]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:42.101]                   0L) {
[16:13:42.101]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:42.101]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:42.101]                   base::options(opts)
[16:13:42.101]                 }
[16:13:42.101]                 {
[16:13:42.101]                   {
[16:13:42.101]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:42.101]                     NULL
[16:13:42.101]                   }
[16:13:42.101]                   options(future.plan = NULL)
[16:13:42.101]                   if (is.na(NA_character_)) 
[16:13:42.101]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.101]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:42.101]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:42.101]                     envir = parent.frame()) 
[16:13:42.101]                   {
[16:13:42.101]                     default_workers <- missing(workers)
[16:13:42.101]                     if (is.function(workers)) 
[16:13:42.101]                       workers <- workers()
[16:13:42.101]                     workers <- structure(as.integer(workers), 
[16:13:42.101]                       class = class(workers))
[16:13:42.101]                     stop_if_not(is.finite(workers), workers >= 
[16:13:42.101]                       1L)
[16:13:42.101]                     if ((workers == 1L && !inherits(workers, 
[16:13:42.101]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:42.101]                       if (default_workers) 
[16:13:42.101]                         supportsMulticore(warn = TRUE)
[16:13:42.101]                       return(sequential(..., envir = envir))
[16:13:42.101]                     }
[16:13:42.101]                     oopts <- options(mc.cores = workers)
[16:13:42.101]                     on.exit(options(oopts))
[16:13:42.101]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:42.101]                       envir = envir)
[16:13:42.101]                     if (!future$lazy) 
[16:13:42.101]                       future <- run(future)
[16:13:42.101]                     invisible(future)
[16:13:42.101]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:42.101]                 }
[16:13:42.101]             }
[16:13:42.101]         }
[16:13:42.101]     })
[16:13:42.101]     if (TRUE) {
[16:13:42.101]         base::sink(type = "output", split = FALSE)
[16:13:42.101]         if (TRUE) {
[16:13:42.101]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:42.101]         }
[16:13:42.101]         else {
[16:13:42.101]             ...future.result["stdout"] <- base::list(NULL)
[16:13:42.101]         }
[16:13:42.101]         base::close(...future.stdout)
[16:13:42.101]         ...future.stdout <- NULL
[16:13:42.101]     }
[16:13:42.101]     ...future.result$conditions <- ...future.conditions
[16:13:42.101]     ...future.result$finished <- base::Sys.time()
[16:13:42.101]     ...future.result
[16:13:42.101] }
[16:13:42.104] requestCore(): workers = 2
[16:13:42.104] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:42.117] MulticoreFuture started
[16:13:42.118] - Launch lazy future ... done
[16:13:42.118] run() for ‘MulticoreFuture’ ... done
[16:13:42.119] plan(): Setting new future strategy stack:
[16:13:42.120] getGlobalsAndPackages() ...
[16:13:42.120] Searching for globals...
[16:13:42.119] List of future strategies:
[16:13:42.119] 1. sequential:
[16:13:42.119]    - args: function (..., envir = parent.frame())
[16:13:42.119]    - tweaked: FALSE
[16:13:42.119]    - call: NULL
[16:13:42.120] plan(): nbrOfWorkers() = 1
[16:13:42.122] - globals found: [1] ‘{’
[16:13:42.122] Searching for globals ... DONE
[16:13:42.122] Resolving globals: FALSE
[16:13:42.123] plan(): Setting new future strategy stack:
[16:13:42.123] 
[16:13:42.123] 
[16:13:42.124] getGlobalsAndPackages() ... DONE
[16:13:42.123] List of future strategies:
[16:13:42.123] 1. multicore:
[16:13:42.123]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:42.123]    - tweaked: FALSE
[16:13:42.123]    - call: plan(strategy)
[16:13:42.124] run() for ‘Future’ ...
[16:13:42.125] - state: ‘created’
[16:13:42.125] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:42.130] plan(): nbrOfWorkers() = 2
[16:13:42.131] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:42.131] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:42.131]   - Field: ‘label’
[16:13:42.131]   - Field: ‘local’
[16:13:42.131]   - Field: ‘owner’
[16:13:42.131]   - Field: ‘envir’
[16:13:42.132]   - Field: ‘workers’
[16:13:42.132]   - Field: ‘packages’
[16:13:42.132]   - Field: ‘gc’
[16:13:42.132]   - Field: ‘job’
[16:13:42.132]   - Field: ‘conditions’
[16:13:42.132]   - Field: ‘expr’
[16:13:42.133]   - Field: ‘uuid’
[16:13:42.133]   - Field: ‘seed’
[16:13:42.133]   - Field: ‘version’
[16:13:42.133]   - Field: ‘result’
[16:13:42.133]   - Field: ‘asynchronous’
[16:13:42.133]   - Field: ‘calls’
[16:13:42.133]   - Field: ‘globals’
[16:13:42.134]   - Field: ‘stdout’
[16:13:42.134]   - Field: ‘earlySignal’
[16:13:42.134]   - Field: ‘lazy’
[16:13:42.134]   - Field: ‘state’
[16:13:42.134] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:42.134] - Launch lazy future ...
[16:13:42.135] Packages needed by the future expression (n = 0): <none>
[16:13:42.135] Packages needed by future strategies (n = 0): <none>
[16:13:42.136] {
[16:13:42.136]     {
[16:13:42.136]         {
[16:13:42.136]             ...future.startTime <- base::Sys.time()
[16:13:42.136]             {
[16:13:42.136]                 {
[16:13:42.136]                   {
[16:13:42.136]                     {
[16:13:42.136]                       base::local({
[16:13:42.136]                         has_future <- base::requireNamespace("future", 
[16:13:42.136]                           quietly = TRUE)
[16:13:42.136]                         if (has_future) {
[16:13:42.136]                           ns <- base::getNamespace("future")
[16:13:42.136]                           version <- ns[[".package"]][["version"]]
[16:13:42.136]                           if (is.null(version)) 
[16:13:42.136]                             version <- utils::packageVersion("future")
[16:13:42.136]                         }
[16:13:42.136]                         else {
[16:13:42.136]                           version <- NULL
[16:13:42.136]                         }
[16:13:42.136]                         if (!has_future || version < "1.8.0") {
[16:13:42.136]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:42.136]                             "", base::R.version$version.string), 
[16:13:42.136]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:42.136]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:42.136]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:42.136]                               "release", "version")], collapse = " "), 
[16:13:42.136]                             hostname = base::Sys.info()[["nodename"]])
[16:13:42.136]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:42.136]                             info)
[16:13:42.136]                           info <- base::paste(info, collapse = "; ")
[16:13:42.136]                           if (!has_future) {
[16:13:42.136]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:42.136]                               info)
[16:13:42.136]                           }
[16:13:42.136]                           else {
[16:13:42.136]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:42.136]                               info, version)
[16:13:42.136]                           }
[16:13:42.136]                           base::stop(msg)
[16:13:42.136]                         }
[16:13:42.136]                       })
[16:13:42.136]                     }
[16:13:42.136]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:42.136]                     base::options(mc.cores = 1L)
[16:13:42.136]                   }
[16:13:42.136]                   options(future.plan = NULL)
[16:13:42.136]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.136]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:42.136]                 }
[16:13:42.136]                 ...future.workdir <- getwd()
[16:13:42.136]             }
[16:13:42.136]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:42.136]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:42.136]         }
[16:13:42.136]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:42.136]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:42.136]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:42.136]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:42.136]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:42.136]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:42.136]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:42.136]             base::names(...future.oldOptions))
[16:13:42.136]     }
[16:13:42.136]     if (FALSE) {
[16:13:42.136]     }
[16:13:42.136]     else {
[16:13:42.136]         if (TRUE) {
[16:13:42.136]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:42.136]                 open = "w")
[16:13:42.136]         }
[16:13:42.136]         else {
[16:13:42.136]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:42.136]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:42.136]         }
[16:13:42.136]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:42.136]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:42.136]             base::sink(type = "output", split = FALSE)
[16:13:42.136]             base::close(...future.stdout)
[16:13:42.136]         }, add = TRUE)
[16:13:42.136]     }
[16:13:42.136]     ...future.frame <- base::sys.nframe()
[16:13:42.136]     ...future.conditions <- base::list()
[16:13:42.136]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:42.136]     if (FALSE) {
[16:13:42.136]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:42.136]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:42.136]     }
[16:13:42.136]     ...future.result <- base::tryCatch({
[16:13:42.136]         base::withCallingHandlers({
[16:13:42.136]             ...future.value <- base::withVisible(base::local({
[16:13:42.136]                 withCallingHandlers({
[16:13:42.136]                   {
[16:13:42.136]                     2
[16:13:42.136]                   }
[16:13:42.136]                 }, immediateCondition = function(cond) {
[16:13:42.136]                   save_rds <- function (object, pathname, ...) 
[16:13:42.136]                   {
[16:13:42.136]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:42.136]                     if (file_test("-f", pathname_tmp)) {
[16:13:42.136]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.136]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:42.136]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.136]                         fi_tmp[["mtime"]])
[16:13:42.136]                     }
[16:13:42.136]                     tryCatch({
[16:13:42.136]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:42.136]                     }, error = function(ex) {
[16:13:42.136]                       msg <- conditionMessage(ex)
[16:13:42.136]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.136]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:42.136]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.136]                         fi_tmp[["mtime"]], msg)
[16:13:42.136]                       ex$message <- msg
[16:13:42.136]                       stop(ex)
[16:13:42.136]                     })
[16:13:42.136]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:42.136]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:42.136]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:42.136]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.136]                       fi <- file.info(pathname)
[16:13:42.136]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:42.136]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.136]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:42.136]                         fi[["size"]], fi[["mtime"]])
[16:13:42.136]                       stop(msg)
[16:13:42.136]                     }
[16:13:42.136]                     invisible(pathname)
[16:13:42.136]                   }
[16:13:42.136]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:42.136]                     rootPath = tempdir()) 
[16:13:42.136]                   {
[16:13:42.136]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:42.136]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:42.136]                       tmpdir = path, fileext = ".rds")
[16:13:42.136]                     save_rds(obj, file)
[16:13:42.136]                   }
[16:13:42.136]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:42.136]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.136]                   {
[16:13:42.136]                     inherits <- base::inherits
[16:13:42.136]                     invokeRestart <- base::invokeRestart
[16:13:42.136]                     is.null <- base::is.null
[16:13:42.136]                     muffled <- FALSE
[16:13:42.136]                     if (inherits(cond, "message")) {
[16:13:42.136]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:42.136]                       if (muffled) 
[16:13:42.136]                         invokeRestart("muffleMessage")
[16:13:42.136]                     }
[16:13:42.136]                     else if (inherits(cond, "warning")) {
[16:13:42.136]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:42.136]                       if (muffled) 
[16:13:42.136]                         invokeRestart("muffleWarning")
[16:13:42.136]                     }
[16:13:42.136]                     else if (inherits(cond, "condition")) {
[16:13:42.136]                       if (!is.null(pattern)) {
[16:13:42.136]                         computeRestarts <- base::computeRestarts
[16:13:42.136]                         grepl <- base::grepl
[16:13:42.136]                         restarts <- computeRestarts(cond)
[16:13:42.136]                         for (restart in restarts) {
[16:13:42.136]                           name <- restart$name
[16:13:42.136]                           if (is.null(name)) 
[16:13:42.136]                             next
[16:13:42.136]                           if (!grepl(pattern, name)) 
[16:13:42.136]                             next
[16:13:42.136]                           invokeRestart(restart)
[16:13:42.136]                           muffled <- TRUE
[16:13:42.136]                           break
[16:13:42.136]                         }
[16:13:42.136]                       }
[16:13:42.136]                     }
[16:13:42.136]                     invisible(muffled)
[16:13:42.136]                   }
[16:13:42.136]                   muffleCondition(cond)
[16:13:42.136]                 })
[16:13:42.136]             }))
[16:13:42.136]             future::FutureResult(value = ...future.value$value, 
[16:13:42.136]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.136]                   ...future.rng), globalenv = if (FALSE) 
[16:13:42.136]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:42.136]                     ...future.globalenv.names))
[16:13:42.136]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:42.136]         }, condition = base::local({
[16:13:42.136]             c <- base::c
[16:13:42.136]             inherits <- base::inherits
[16:13:42.136]             invokeRestart <- base::invokeRestart
[16:13:42.136]             length <- base::length
[16:13:42.136]             list <- base::list
[16:13:42.136]             seq.int <- base::seq.int
[16:13:42.136]             signalCondition <- base::signalCondition
[16:13:42.136]             sys.calls <- base::sys.calls
[16:13:42.136]             `[[` <- base::`[[`
[16:13:42.136]             `+` <- base::`+`
[16:13:42.136]             `<<-` <- base::`<<-`
[16:13:42.136]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:42.136]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:42.136]                   3L)]
[16:13:42.136]             }
[16:13:42.136]             function(cond) {
[16:13:42.136]                 is_error <- inherits(cond, "error")
[16:13:42.136]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:42.136]                   NULL)
[16:13:42.136]                 if (is_error) {
[16:13:42.136]                   sessionInformation <- function() {
[16:13:42.136]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:42.136]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:42.136]                       search = base::search(), system = base::Sys.info())
[16:13:42.136]                   }
[16:13:42.136]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.136]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:42.136]                     cond$call), session = sessionInformation(), 
[16:13:42.136]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:42.136]                   signalCondition(cond)
[16:13:42.136]                 }
[16:13:42.136]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:42.136]                 "immediateCondition"))) {
[16:13:42.136]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:42.136]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.136]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:42.136]                   if (TRUE && !signal) {
[16:13:42.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.136]                     {
[16:13:42.136]                       inherits <- base::inherits
[16:13:42.136]                       invokeRestart <- base::invokeRestart
[16:13:42.136]                       is.null <- base::is.null
[16:13:42.136]                       muffled <- FALSE
[16:13:42.136]                       if (inherits(cond, "message")) {
[16:13:42.136]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.136]                         if (muffled) 
[16:13:42.136]                           invokeRestart("muffleMessage")
[16:13:42.136]                       }
[16:13:42.136]                       else if (inherits(cond, "warning")) {
[16:13:42.136]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.136]                         if (muffled) 
[16:13:42.136]                           invokeRestart("muffleWarning")
[16:13:42.136]                       }
[16:13:42.136]                       else if (inherits(cond, "condition")) {
[16:13:42.136]                         if (!is.null(pattern)) {
[16:13:42.136]                           computeRestarts <- base::computeRestarts
[16:13:42.136]                           grepl <- base::grepl
[16:13:42.136]                           restarts <- computeRestarts(cond)
[16:13:42.136]                           for (restart in restarts) {
[16:13:42.136]                             name <- restart$name
[16:13:42.136]                             if (is.null(name)) 
[16:13:42.136]                               next
[16:13:42.136]                             if (!grepl(pattern, name)) 
[16:13:42.136]                               next
[16:13:42.136]                             invokeRestart(restart)
[16:13:42.136]                             muffled <- TRUE
[16:13:42.136]                             break
[16:13:42.136]                           }
[16:13:42.136]                         }
[16:13:42.136]                       }
[16:13:42.136]                       invisible(muffled)
[16:13:42.136]                     }
[16:13:42.136]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.136]                   }
[16:13:42.136]                 }
[16:13:42.136]                 else {
[16:13:42.136]                   if (TRUE) {
[16:13:42.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.136]                     {
[16:13:42.136]                       inherits <- base::inherits
[16:13:42.136]                       invokeRestart <- base::invokeRestart
[16:13:42.136]                       is.null <- base::is.null
[16:13:42.136]                       muffled <- FALSE
[16:13:42.136]                       if (inherits(cond, "message")) {
[16:13:42.136]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.136]                         if (muffled) 
[16:13:42.136]                           invokeRestart("muffleMessage")
[16:13:42.136]                       }
[16:13:42.136]                       else if (inherits(cond, "warning")) {
[16:13:42.136]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.136]                         if (muffled) 
[16:13:42.136]                           invokeRestart("muffleWarning")
[16:13:42.136]                       }
[16:13:42.136]                       else if (inherits(cond, "condition")) {
[16:13:42.136]                         if (!is.null(pattern)) {
[16:13:42.136]                           computeRestarts <- base::computeRestarts
[16:13:42.136]                           grepl <- base::grepl
[16:13:42.136]                           restarts <- computeRestarts(cond)
[16:13:42.136]                           for (restart in restarts) {
[16:13:42.136]                             name <- restart$name
[16:13:42.136]                             if (is.null(name)) 
[16:13:42.136]                               next
[16:13:42.136]                             if (!grepl(pattern, name)) 
[16:13:42.136]                               next
[16:13:42.136]                             invokeRestart(restart)
[16:13:42.136]                             muffled <- TRUE
[16:13:42.136]                             break
[16:13:42.136]                           }
[16:13:42.136]                         }
[16:13:42.136]                       }
[16:13:42.136]                       invisible(muffled)
[16:13:42.136]                     }
[16:13:42.136]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.136]                   }
[16:13:42.136]                 }
[16:13:42.136]             }
[16:13:42.136]         }))
[16:13:42.136]     }, error = function(ex) {
[16:13:42.136]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:42.136]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.136]                 ...future.rng), started = ...future.startTime, 
[16:13:42.136]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:42.136]             version = "1.8"), class = "FutureResult")
[16:13:42.136]     }, finally = {
[16:13:42.136]         if (!identical(...future.workdir, getwd())) 
[16:13:42.136]             setwd(...future.workdir)
[16:13:42.136]         {
[16:13:42.136]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:42.136]                 ...future.oldOptions$nwarnings <- NULL
[16:13:42.136]             }
[16:13:42.136]             base::options(...future.oldOptions)
[16:13:42.136]             if (.Platform$OS.type == "windows") {
[16:13:42.136]                 old_names <- names(...future.oldEnvVars)
[16:13:42.136]                 envs <- base::Sys.getenv()
[16:13:42.136]                 names <- names(envs)
[16:13:42.136]                 common <- intersect(names, old_names)
[16:13:42.136]                 added <- setdiff(names, old_names)
[16:13:42.136]                 removed <- setdiff(old_names, names)
[16:13:42.136]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:42.136]                   envs[common]]
[16:13:42.136]                 NAMES <- toupper(changed)
[16:13:42.136]                 args <- list()
[16:13:42.136]                 for (kk in seq_along(NAMES)) {
[16:13:42.136]                   name <- changed[[kk]]
[16:13:42.136]                   NAME <- NAMES[[kk]]
[16:13:42.136]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.136]                     next
[16:13:42.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.136]                 }
[16:13:42.136]                 NAMES <- toupper(added)
[16:13:42.136]                 for (kk in seq_along(NAMES)) {
[16:13:42.136]                   name <- added[[kk]]
[16:13:42.136]                   NAME <- NAMES[[kk]]
[16:13:42.136]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.136]                     next
[16:13:42.136]                   args[[name]] <- ""
[16:13:42.136]                 }
[16:13:42.136]                 NAMES <- toupper(removed)
[16:13:42.136]                 for (kk in seq_along(NAMES)) {
[16:13:42.136]                   name <- removed[[kk]]
[16:13:42.136]                   NAME <- NAMES[[kk]]
[16:13:42.136]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.136]                     next
[16:13:42.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.136]                 }
[16:13:42.136]                 if (length(args) > 0) 
[16:13:42.136]                   base::do.call(base::Sys.setenv, args = args)
[16:13:42.136]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:42.136]             }
[16:13:42.136]             else {
[16:13:42.136]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:42.136]             }
[16:13:42.136]             {
[16:13:42.136]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:42.136]                   0L) {
[16:13:42.136]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:42.136]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:42.136]                   base::options(opts)
[16:13:42.136]                 }
[16:13:42.136]                 {
[16:13:42.136]                   {
[16:13:42.136]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:42.136]                     NULL
[16:13:42.136]                   }
[16:13:42.136]                   options(future.plan = NULL)
[16:13:42.136]                   if (is.na(NA_character_)) 
[16:13:42.136]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.136]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:42.136]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:42.136]                     envir = parent.frame()) 
[16:13:42.136]                   {
[16:13:42.136]                     default_workers <- missing(workers)
[16:13:42.136]                     if (is.function(workers)) 
[16:13:42.136]                       workers <- workers()
[16:13:42.136]                     workers <- structure(as.integer(workers), 
[16:13:42.136]                       class = class(workers))
[16:13:42.136]                     stop_if_not(is.finite(workers), workers >= 
[16:13:42.136]                       1L)
[16:13:42.136]                     if ((workers == 1L && !inherits(workers, 
[16:13:42.136]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:42.136]                       if (default_workers) 
[16:13:42.136]                         supportsMulticore(warn = TRUE)
[16:13:42.136]                       return(sequential(..., envir = envir))
[16:13:42.136]                     }
[16:13:42.136]                     oopts <- options(mc.cores = workers)
[16:13:42.136]                     on.exit(options(oopts))
[16:13:42.136]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:42.136]                       envir = envir)
[16:13:42.136]                     if (!future$lazy) 
[16:13:42.136]                       future <- run(future)
[16:13:42.136]                     invisible(future)
[16:13:42.136]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:42.136]                 }
[16:13:42.136]             }
[16:13:42.136]         }
[16:13:42.136]     })
[16:13:42.136]     if (TRUE) {
[16:13:42.136]         base::sink(type = "output", split = FALSE)
[16:13:42.136]         if (TRUE) {
[16:13:42.136]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:42.136]         }
[16:13:42.136]         else {
[16:13:42.136]             ...future.result["stdout"] <- base::list(NULL)
[16:13:42.136]         }
[16:13:42.136]         base::close(...future.stdout)
[16:13:42.136]         ...future.stdout <- NULL
[16:13:42.136]     }
[16:13:42.136]     ...future.result$conditions <- ...future.conditions
[16:13:42.136]     ...future.result$finished <- base::Sys.time()
[16:13:42.136]     ...future.result
[16:13:42.136] }
[16:13:42.139] requestCore(): workers = 2
[16:13:42.140] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:42.154] MulticoreFuture started
[16:13:42.154] - Launch lazy future ... done
[16:13:42.154] run() for ‘MulticoreFuture’ ... done
[16:13:42.155] plan(): Setting new future strategy stack:
[16:13:42.155] List of future strategies:
[16:13:42.155] 1. sequential:
[16:13:42.155]    - args: function (..., envir = parent.frame())
[16:13:42.155]    - tweaked: FALSE
[16:13:42.155]    - call: NULL
[16:13:42.156] plan(): nbrOfWorkers() = 1
[16:13:42.156] resolve() on environment ...
[16:13:42.156]  recursive: 0
[16:13:42.157]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[16:13:42.158] Future #1
[16:13:42.158]  length: 2 (resolved future 1)
[16:13:42.158] plan(): Setting new future strategy stack:
[16:13:42.158] List of future strategies:
[16:13:42.158] 1. multicore:
[16:13:42.158]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:42.158]    - tweaked: FALSE
[16:13:42.158]    - call: plan(strategy)
[16:13:42.163] plan(): nbrOfWorkers() = 2
[16:13:42.164] Future #2
[16:13:42.164]  length: 1 (resolved future 2)
[16:13:42.164]  length: 0 (resolved future 3)
[16:13:42.164] resolve() on environment ... DONE
[16:13:42.165] getGlobalsAndPackages() ...
[16:13:42.165] Searching for globals...
[16:13:42.166] - globals found: [1] ‘{’
[16:13:42.166] Searching for globals ... DONE
[16:13:42.167] Resolving globals: FALSE
[16:13:42.167] 
[16:13:42.171] 
[16:13:42.172] getGlobalsAndPackages() ... DONE
[16:13:42.172] run() for ‘Future’ ...
[16:13:42.173] - state: ‘created’
[16:13:42.173] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:42.179] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:42.179] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:42.180]   - Field: ‘label’
[16:13:42.180]   - Field: ‘local’
[16:13:42.180]   - Field: ‘owner’
[16:13:42.180]   - Field: ‘envir’
[16:13:42.180]   - Field: ‘workers’
[16:13:42.180]   - Field: ‘packages’
[16:13:42.181]   - Field: ‘gc’
[16:13:42.181]   - Field: ‘job’
[16:13:42.181]   - Field: ‘conditions’
[16:13:42.181]   - Field: ‘expr’
[16:13:42.181]   - Field: ‘uuid’
[16:13:42.181]   - Field: ‘seed’
[16:13:42.181]   - Field: ‘version’
[16:13:42.182]   - Field: ‘result’
[16:13:42.182]   - Field: ‘asynchronous’
[16:13:42.182]   - Field: ‘calls’
[16:13:42.182]   - Field: ‘globals’
[16:13:42.182]   - Field: ‘stdout’
[16:13:42.182]   - Field: ‘earlySignal’
[16:13:42.183]   - Field: ‘lazy’
[16:13:42.183]   - Field: ‘state’
[16:13:42.183] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:42.183] - Launch lazy future ...
[16:13:42.184] Packages needed by the future expression (n = 0): <none>
[16:13:42.184] Packages needed by future strategies (n = 0): <none>
[16:13:42.185] {
[16:13:42.185]     {
[16:13:42.185]         {
[16:13:42.185]             ...future.startTime <- base::Sys.time()
[16:13:42.185]             {
[16:13:42.185]                 {
[16:13:42.185]                   {
[16:13:42.185]                     {
[16:13:42.185]                       base::local({
[16:13:42.185]                         has_future <- base::requireNamespace("future", 
[16:13:42.185]                           quietly = TRUE)
[16:13:42.185]                         if (has_future) {
[16:13:42.185]                           ns <- base::getNamespace("future")
[16:13:42.185]                           version <- ns[[".package"]][["version"]]
[16:13:42.185]                           if (is.null(version)) 
[16:13:42.185]                             version <- utils::packageVersion("future")
[16:13:42.185]                         }
[16:13:42.185]                         else {
[16:13:42.185]                           version <- NULL
[16:13:42.185]                         }
[16:13:42.185]                         if (!has_future || version < "1.8.0") {
[16:13:42.185]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:42.185]                             "", base::R.version$version.string), 
[16:13:42.185]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:42.185]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:42.185]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:42.185]                               "release", "version")], collapse = " "), 
[16:13:42.185]                             hostname = base::Sys.info()[["nodename"]])
[16:13:42.185]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:42.185]                             info)
[16:13:42.185]                           info <- base::paste(info, collapse = "; ")
[16:13:42.185]                           if (!has_future) {
[16:13:42.185]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:42.185]                               info)
[16:13:42.185]                           }
[16:13:42.185]                           else {
[16:13:42.185]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:42.185]                               info, version)
[16:13:42.185]                           }
[16:13:42.185]                           base::stop(msg)
[16:13:42.185]                         }
[16:13:42.185]                       })
[16:13:42.185]                     }
[16:13:42.185]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:42.185]                     base::options(mc.cores = 1L)
[16:13:42.185]                   }
[16:13:42.185]                   options(future.plan = NULL)
[16:13:42.185]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.185]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:42.185]                 }
[16:13:42.185]                 ...future.workdir <- getwd()
[16:13:42.185]             }
[16:13:42.185]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:42.185]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:42.185]         }
[16:13:42.185]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:42.185]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:42.185]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:42.185]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:42.185]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:42.185]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:42.185]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:42.185]             base::names(...future.oldOptions))
[16:13:42.185]     }
[16:13:42.185]     if (FALSE) {
[16:13:42.185]     }
[16:13:42.185]     else {
[16:13:42.185]         if (TRUE) {
[16:13:42.185]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:42.185]                 open = "w")
[16:13:42.185]         }
[16:13:42.185]         else {
[16:13:42.185]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:42.185]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:42.185]         }
[16:13:42.185]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:42.185]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:42.185]             base::sink(type = "output", split = FALSE)
[16:13:42.185]             base::close(...future.stdout)
[16:13:42.185]         }, add = TRUE)
[16:13:42.185]     }
[16:13:42.185]     ...future.frame <- base::sys.nframe()
[16:13:42.185]     ...future.conditions <- base::list()
[16:13:42.185]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:42.185]     if (FALSE) {
[16:13:42.185]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:42.185]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:42.185]     }
[16:13:42.185]     ...future.result <- base::tryCatch({
[16:13:42.185]         base::withCallingHandlers({
[16:13:42.185]             ...future.value <- base::withVisible(base::local({
[16:13:42.185]                 withCallingHandlers({
[16:13:42.185]                   {
[16:13:42.185]                     1
[16:13:42.185]                   }
[16:13:42.185]                 }, immediateCondition = function(cond) {
[16:13:42.185]                   save_rds <- function (object, pathname, ...) 
[16:13:42.185]                   {
[16:13:42.185]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:42.185]                     if (file_test("-f", pathname_tmp)) {
[16:13:42.185]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.185]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:42.185]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.185]                         fi_tmp[["mtime"]])
[16:13:42.185]                     }
[16:13:42.185]                     tryCatch({
[16:13:42.185]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:42.185]                     }, error = function(ex) {
[16:13:42.185]                       msg <- conditionMessage(ex)
[16:13:42.185]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.185]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:42.185]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.185]                         fi_tmp[["mtime"]], msg)
[16:13:42.185]                       ex$message <- msg
[16:13:42.185]                       stop(ex)
[16:13:42.185]                     })
[16:13:42.185]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:42.185]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:42.185]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:42.185]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.185]                       fi <- file.info(pathname)
[16:13:42.185]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:42.185]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.185]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:42.185]                         fi[["size"]], fi[["mtime"]])
[16:13:42.185]                       stop(msg)
[16:13:42.185]                     }
[16:13:42.185]                     invisible(pathname)
[16:13:42.185]                   }
[16:13:42.185]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:42.185]                     rootPath = tempdir()) 
[16:13:42.185]                   {
[16:13:42.185]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:42.185]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:42.185]                       tmpdir = path, fileext = ".rds")
[16:13:42.185]                     save_rds(obj, file)
[16:13:42.185]                   }
[16:13:42.185]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:42.185]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.185]                   {
[16:13:42.185]                     inherits <- base::inherits
[16:13:42.185]                     invokeRestart <- base::invokeRestart
[16:13:42.185]                     is.null <- base::is.null
[16:13:42.185]                     muffled <- FALSE
[16:13:42.185]                     if (inherits(cond, "message")) {
[16:13:42.185]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:42.185]                       if (muffled) 
[16:13:42.185]                         invokeRestart("muffleMessage")
[16:13:42.185]                     }
[16:13:42.185]                     else if (inherits(cond, "warning")) {
[16:13:42.185]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:42.185]                       if (muffled) 
[16:13:42.185]                         invokeRestart("muffleWarning")
[16:13:42.185]                     }
[16:13:42.185]                     else if (inherits(cond, "condition")) {
[16:13:42.185]                       if (!is.null(pattern)) {
[16:13:42.185]                         computeRestarts <- base::computeRestarts
[16:13:42.185]                         grepl <- base::grepl
[16:13:42.185]                         restarts <- computeRestarts(cond)
[16:13:42.185]                         for (restart in restarts) {
[16:13:42.185]                           name <- restart$name
[16:13:42.185]                           if (is.null(name)) 
[16:13:42.185]                             next
[16:13:42.185]                           if (!grepl(pattern, name)) 
[16:13:42.185]                             next
[16:13:42.185]                           invokeRestart(restart)
[16:13:42.185]                           muffled <- TRUE
[16:13:42.185]                           break
[16:13:42.185]                         }
[16:13:42.185]                       }
[16:13:42.185]                     }
[16:13:42.185]                     invisible(muffled)
[16:13:42.185]                   }
[16:13:42.185]                   muffleCondition(cond)
[16:13:42.185]                 })
[16:13:42.185]             }))
[16:13:42.185]             future::FutureResult(value = ...future.value$value, 
[16:13:42.185]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.185]                   ...future.rng), globalenv = if (FALSE) 
[16:13:42.185]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:42.185]                     ...future.globalenv.names))
[16:13:42.185]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:42.185]         }, condition = base::local({
[16:13:42.185]             c <- base::c
[16:13:42.185]             inherits <- base::inherits
[16:13:42.185]             invokeRestart <- base::invokeRestart
[16:13:42.185]             length <- base::length
[16:13:42.185]             list <- base::list
[16:13:42.185]             seq.int <- base::seq.int
[16:13:42.185]             signalCondition <- base::signalCondition
[16:13:42.185]             sys.calls <- base::sys.calls
[16:13:42.185]             `[[` <- base::`[[`
[16:13:42.185]             `+` <- base::`+`
[16:13:42.185]             `<<-` <- base::`<<-`
[16:13:42.185]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:42.185]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:42.185]                   3L)]
[16:13:42.185]             }
[16:13:42.185]             function(cond) {
[16:13:42.185]                 is_error <- inherits(cond, "error")
[16:13:42.185]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:42.185]                   NULL)
[16:13:42.185]                 if (is_error) {
[16:13:42.185]                   sessionInformation <- function() {
[16:13:42.185]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:42.185]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:42.185]                       search = base::search(), system = base::Sys.info())
[16:13:42.185]                   }
[16:13:42.185]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.185]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:42.185]                     cond$call), session = sessionInformation(), 
[16:13:42.185]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:42.185]                   signalCondition(cond)
[16:13:42.185]                 }
[16:13:42.185]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:42.185]                 "immediateCondition"))) {
[16:13:42.185]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:42.185]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.185]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:42.185]                   if (TRUE && !signal) {
[16:13:42.185]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.185]                     {
[16:13:42.185]                       inherits <- base::inherits
[16:13:42.185]                       invokeRestart <- base::invokeRestart
[16:13:42.185]                       is.null <- base::is.null
[16:13:42.185]                       muffled <- FALSE
[16:13:42.185]                       if (inherits(cond, "message")) {
[16:13:42.185]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.185]                         if (muffled) 
[16:13:42.185]                           invokeRestart("muffleMessage")
[16:13:42.185]                       }
[16:13:42.185]                       else if (inherits(cond, "warning")) {
[16:13:42.185]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.185]                         if (muffled) 
[16:13:42.185]                           invokeRestart("muffleWarning")
[16:13:42.185]                       }
[16:13:42.185]                       else if (inherits(cond, "condition")) {
[16:13:42.185]                         if (!is.null(pattern)) {
[16:13:42.185]                           computeRestarts <- base::computeRestarts
[16:13:42.185]                           grepl <- base::grepl
[16:13:42.185]                           restarts <- computeRestarts(cond)
[16:13:42.185]                           for (restart in restarts) {
[16:13:42.185]                             name <- restart$name
[16:13:42.185]                             if (is.null(name)) 
[16:13:42.185]                               next
[16:13:42.185]                             if (!grepl(pattern, name)) 
[16:13:42.185]                               next
[16:13:42.185]                             invokeRestart(restart)
[16:13:42.185]                             muffled <- TRUE
[16:13:42.185]                             break
[16:13:42.185]                           }
[16:13:42.185]                         }
[16:13:42.185]                       }
[16:13:42.185]                       invisible(muffled)
[16:13:42.185]                     }
[16:13:42.185]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.185]                   }
[16:13:42.185]                 }
[16:13:42.185]                 else {
[16:13:42.185]                   if (TRUE) {
[16:13:42.185]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.185]                     {
[16:13:42.185]                       inherits <- base::inherits
[16:13:42.185]                       invokeRestart <- base::invokeRestart
[16:13:42.185]                       is.null <- base::is.null
[16:13:42.185]                       muffled <- FALSE
[16:13:42.185]                       if (inherits(cond, "message")) {
[16:13:42.185]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.185]                         if (muffled) 
[16:13:42.185]                           invokeRestart("muffleMessage")
[16:13:42.185]                       }
[16:13:42.185]                       else if (inherits(cond, "warning")) {
[16:13:42.185]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.185]                         if (muffled) 
[16:13:42.185]                           invokeRestart("muffleWarning")
[16:13:42.185]                       }
[16:13:42.185]                       else if (inherits(cond, "condition")) {
[16:13:42.185]                         if (!is.null(pattern)) {
[16:13:42.185]                           computeRestarts <- base::computeRestarts
[16:13:42.185]                           grepl <- base::grepl
[16:13:42.185]                           restarts <- computeRestarts(cond)
[16:13:42.185]                           for (restart in restarts) {
[16:13:42.185]                             name <- restart$name
[16:13:42.185]                             if (is.null(name)) 
[16:13:42.185]                               next
[16:13:42.185]                             if (!grepl(pattern, name)) 
[16:13:42.185]                               next
[16:13:42.185]                             invokeRestart(restart)
[16:13:42.185]                             muffled <- TRUE
[16:13:42.185]                             break
[16:13:42.185]                           }
[16:13:42.185]                         }
[16:13:42.185]                       }
[16:13:42.185]                       invisible(muffled)
[16:13:42.185]                     }
[16:13:42.185]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.185]                   }
[16:13:42.185]                 }
[16:13:42.185]             }
[16:13:42.185]         }))
[16:13:42.185]     }, error = function(ex) {
[16:13:42.185]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:42.185]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.185]                 ...future.rng), started = ...future.startTime, 
[16:13:42.185]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:42.185]             version = "1.8"), class = "FutureResult")
[16:13:42.185]     }, finally = {
[16:13:42.185]         if (!identical(...future.workdir, getwd())) 
[16:13:42.185]             setwd(...future.workdir)
[16:13:42.185]         {
[16:13:42.185]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:42.185]                 ...future.oldOptions$nwarnings <- NULL
[16:13:42.185]             }
[16:13:42.185]             base::options(...future.oldOptions)
[16:13:42.185]             if (.Platform$OS.type == "windows") {
[16:13:42.185]                 old_names <- names(...future.oldEnvVars)
[16:13:42.185]                 envs <- base::Sys.getenv()
[16:13:42.185]                 names <- names(envs)
[16:13:42.185]                 common <- intersect(names, old_names)
[16:13:42.185]                 added <- setdiff(names, old_names)
[16:13:42.185]                 removed <- setdiff(old_names, names)
[16:13:42.185]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:42.185]                   envs[common]]
[16:13:42.185]                 NAMES <- toupper(changed)
[16:13:42.185]                 args <- list()
[16:13:42.185]                 for (kk in seq_along(NAMES)) {
[16:13:42.185]                   name <- changed[[kk]]
[16:13:42.185]                   NAME <- NAMES[[kk]]
[16:13:42.185]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.185]                     next
[16:13:42.185]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.185]                 }
[16:13:42.185]                 NAMES <- toupper(added)
[16:13:42.185]                 for (kk in seq_along(NAMES)) {
[16:13:42.185]                   name <- added[[kk]]
[16:13:42.185]                   NAME <- NAMES[[kk]]
[16:13:42.185]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.185]                     next
[16:13:42.185]                   args[[name]] <- ""
[16:13:42.185]                 }
[16:13:42.185]                 NAMES <- toupper(removed)
[16:13:42.185]                 for (kk in seq_along(NAMES)) {
[16:13:42.185]                   name <- removed[[kk]]
[16:13:42.185]                   NAME <- NAMES[[kk]]
[16:13:42.185]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.185]                     next
[16:13:42.185]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.185]                 }
[16:13:42.185]                 if (length(args) > 0) 
[16:13:42.185]                   base::do.call(base::Sys.setenv, args = args)
[16:13:42.185]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:42.185]             }
[16:13:42.185]             else {
[16:13:42.185]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:42.185]             }
[16:13:42.185]             {
[16:13:42.185]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:42.185]                   0L) {
[16:13:42.185]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:42.185]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:42.185]                   base::options(opts)
[16:13:42.185]                 }
[16:13:42.185]                 {
[16:13:42.185]                   {
[16:13:42.185]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:42.185]                     NULL
[16:13:42.185]                   }
[16:13:42.185]                   options(future.plan = NULL)
[16:13:42.185]                   if (is.na(NA_character_)) 
[16:13:42.185]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.185]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:42.185]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:42.185]                     envir = parent.frame()) 
[16:13:42.185]                   {
[16:13:42.185]                     default_workers <- missing(workers)
[16:13:42.185]                     if (is.function(workers)) 
[16:13:42.185]                       workers <- workers()
[16:13:42.185]                     workers <- structure(as.integer(workers), 
[16:13:42.185]                       class = class(workers))
[16:13:42.185]                     stop_if_not(is.finite(workers), workers >= 
[16:13:42.185]                       1L)
[16:13:42.185]                     if ((workers == 1L && !inherits(workers, 
[16:13:42.185]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:42.185]                       if (default_workers) 
[16:13:42.185]                         supportsMulticore(warn = TRUE)
[16:13:42.185]                       return(sequential(..., envir = envir))
[16:13:42.185]                     }
[16:13:42.185]                     oopts <- options(mc.cores = workers)
[16:13:42.185]                     on.exit(options(oopts))
[16:13:42.185]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:42.185]                       envir = envir)
[16:13:42.185]                     if (!future$lazy) 
[16:13:42.185]                       future <- run(future)
[16:13:42.185]                     invisible(future)
[16:13:42.185]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:42.185]                 }
[16:13:42.185]             }
[16:13:42.185]         }
[16:13:42.185]     })
[16:13:42.185]     if (TRUE) {
[16:13:42.185]         base::sink(type = "output", split = FALSE)
[16:13:42.185]         if (TRUE) {
[16:13:42.185]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:42.185]         }
[16:13:42.185]         else {
[16:13:42.185]             ...future.result["stdout"] <- base::list(NULL)
[16:13:42.185]         }
[16:13:42.185]         base::close(...future.stdout)
[16:13:42.185]         ...future.stdout <- NULL
[16:13:42.185]     }
[16:13:42.185]     ...future.result$conditions <- ...future.conditions
[16:13:42.185]     ...future.result$finished <- base::Sys.time()
[16:13:42.185]     ...future.result
[16:13:42.185] }
[16:13:42.188] requestCore(): workers = 2
[16:13:42.188] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:42.202] MulticoreFuture started
[16:13:42.203] - Launch lazy future ... done
[16:13:42.203] run() for ‘MulticoreFuture’ ... done
[16:13:42.203] plan(): Setting new future strategy stack:
[16:13:42.204] getGlobalsAndPackages() ...
[16:13:42.204] Searching for globals...
[16:13:42.204] List of future strategies:
[16:13:42.204] 1. sequential:
[16:13:42.204]    - args: function (..., envir = parent.frame())
[16:13:42.204]    - tweaked: FALSE
[16:13:42.204]    - call: NULL
[16:13:42.205] plan(): nbrOfWorkers() = 1
[16:13:42.206] - globals found: [1] ‘{’
[16:13:42.206] Searching for globals ... DONE
[16:13:42.206] Resolving globals: FALSE
[16:13:42.206] plan(): Setting new future strategy stack:
[16:13:42.207] 
[16:13:42.207] 
[16:13:42.207] getGlobalsAndPackages() ... DONE
[16:13:42.207] List of future strategies:
[16:13:42.207] 1. multicore:
[16:13:42.207]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:42.207]    - tweaked: FALSE
[16:13:42.207]    - call: plan(strategy)
[16:13:42.207] run() for ‘Future’ ...
[16:13:42.208] - state: ‘created’
[16:13:42.208] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:42.212] plan(): nbrOfWorkers() = 2
[16:13:42.213] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:42.213] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:42.213]   - Field: ‘label’
[16:13:42.213]   - Field: ‘local’
[16:13:42.214]   - Field: ‘owner’
[16:13:42.214]   - Field: ‘envir’
[16:13:42.214]   - Field: ‘workers’
[16:13:42.214]   - Field: ‘packages’
[16:13:42.214]   - Field: ‘gc’
[16:13:42.214]   - Field: ‘job’
[16:13:42.215]   - Field: ‘conditions’
[16:13:42.215]   - Field: ‘expr’
[16:13:42.215]   - Field: ‘uuid’
[16:13:42.215]   - Field: ‘seed’
[16:13:42.215]   - Field: ‘version’
[16:13:42.215]   - Field: ‘result’
[16:13:42.216]   - Field: ‘asynchronous’
[16:13:42.216]   - Field: ‘calls’
[16:13:42.216]   - Field: ‘globals’
[16:13:42.216]   - Field: ‘stdout’
[16:13:42.216]   - Field: ‘earlySignal’
[16:13:42.216]   - Field: ‘lazy’
[16:13:42.216]   - Field: ‘state’
[16:13:42.217] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:42.217] - Launch lazy future ...
[16:13:42.217] Packages needed by the future expression (n = 0): <none>
[16:13:42.217] Packages needed by future strategies (n = 0): <none>
[16:13:42.218] {
[16:13:42.218]     {
[16:13:42.218]         {
[16:13:42.218]             ...future.startTime <- base::Sys.time()
[16:13:42.218]             {
[16:13:42.218]                 {
[16:13:42.218]                   {
[16:13:42.218]                     {
[16:13:42.218]                       base::local({
[16:13:42.218]                         has_future <- base::requireNamespace("future", 
[16:13:42.218]                           quietly = TRUE)
[16:13:42.218]                         if (has_future) {
[16:13:42.218]                           ns <- base::getNamespace("future")
[16:13:42.218]                           version <- ns[[".package"]][["version"]]
[16:13:42.218]                           if (is.null(version)) 
[16:13:42.218]                             version <- utils::packageVersion("future")
[16:13:42.218]                         }
[16:13:42.218]                         else {
[16:13:42.218]                           version <- NULL
[16:13:42.218]                         }
[16:13:42.218]                         if (!has_future || version < "1.8.0") {
[16:13:42.218]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:42.218]                             "", base::R.version$version.string), 
[16:13:42.218]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:42.218]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:42.218]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:42.218]                               "release", "version")], collapse = " "), 
[16:13:42.218]                             hostname = base::Sys.info()[["nodename"]])
[16:13:42.218]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:42.218]                             info)
[16:13:42.218]                           info <- base::paste(info, collapse = "; ")
[16:13:42.218]                           if (!has_future) {
[16:13:42.218]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:42.218]                               info)
[16:13:42.218]                           }
[16:13:42.218]                           else {
[16:13:42.218]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:42.218]                               info, version)
[16:13:42.218]                           }
[16:13:42.218]                           base::stop(msg)
[16:13:42.218]                         }
[16:13:42.218]                       })
[16:13:42.218]                     }
[16:13:42.218]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:42.218]                     base::options(mc.cores = 1L)
[16:13:42.218]                   }
[16:13:42.218]                   options(future.plan = NULL)
[16:13:42.218]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.218]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:42.218]                 }
[16:13:42.218]                 ...future.workdir <- getwd()
[16:13:42.218]             }
[16:13:42.218]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:42.218]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:42.218]         }
[16:13:42.218]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:42.218]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:42.218]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:42.218]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:42.218]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:42.218]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:42.218]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:42.218]             base::names(...future.oldOptions))
[16:13:42.218]     }
[16:13:42.218]     if (FALSE) {
[16:13:42.218]     }
[16:13:42.218]     else {
[16:13:42.218]         if (TRUE) {
[16:13:42.218]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:42.218]                 open = "w")
[16:13:42.218]         }
[16:13:42.218]         else {
[16:13:42.218]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:42.218]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:42.218]         }
[16:13:42.218]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:42.218]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:42.218]             base::sink(type = "output", split = FALSE)
[16:13:42.218]             base::close(...future.stdout)
[16:13:42.218]         }, add = TRUE)
[16:13:42.218]     }
[16:13:42.218]     ...future.frame <- base::sys.nframe()
[16:13:42.218]     ...future.conditions <- base::list()
[16:13:42.218]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:42.218]     if (FALSE) {
[16:13:42.218]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:42.218]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:42.218]     }
[16:13:42.218]     ...future.result <- base::tryCatch({
[16:13:42.218]         base::withCallingHandlers({
[16:13:42.218]             ...future.value <- base::withVisible(base::local({
[16:13:42.218]                 withCallingHandlers({
[16:13:42.218]                   {
[16:13:42.218]                     2
[16:13:42.218]                   }
[16:13:42.218]                 }, immediateCondition = function(cond) {
[16:13:42.218]                   save_rds <- function (object, pathname, ...) 
[16:13:42.218]                   {
[16:13:42.218]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:42.218]                     if (file_test("-f", pathname_tmp)) {
[16:13:42.218]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.218]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:42.218]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.218]                         fi_tmp[["mtime"]])
[16:13:42.218]                     }
[16:13:42.218]                     tryCatch({
[16:13:42.218]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:42.218]                     }, error = function(ex) {
[16:13:42.218]                       msg <- conditionMessage(ex)
[16:13:42.218]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.218]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:42.218]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.218]                         fi_tmp[["mtime"]], msg)
[16:13:42.218]                       ex$message <- msg
[16:13:42.218]                       stop(ex)
[16:13:42.218]                     })
[16:13:42.218]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:42.218]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:42.218]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:42.218]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.218]                       fi <- file.info(pathname)
[16:13:42.218]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:42.218]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.218]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:42.218]                         fi[["size"]], fi[["mtime"]])
[16:13:42.218]                       stop(msg)
[16:13:42.218]                     }
[16:13:42.218]                     invisible(pathname)
[16:13:42.218]                   }
[16:13:42.218]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:42.218]                     rootPath = tempdir()) 
[16:13:42.218]                   {
[16:13:42.218]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:42.218]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:42.218]                       tmpdir = path, fileext = ".rds")
[16:13:42.218]                     save_rds(obj, file)
[16:13:42.218]                   }
[16:13:42.218]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:42.218]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.218]                   {
[16:13:42.218]                     inherits <- base::inherits
[16:13:42.218]                     invokeRestart <- base::invokeRestart
[16:13:42.218]                     is.null <- base::is.null
[16:13:42.218]                     muffled <- FALSE
[16:13:42.218]                     if (inherits(cond, "message")) {
[16:13:42.218]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:42.218]                       if (muffled) 
[16:13:42.218]                         invokeRestart("muffleMessage")
[16:13:42.218]                     }
[16:13:42.218]                     else if (inherits(cond, "warning")) {
[16:13:42.218]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:42.218]                       if (muffled) 
[16:13:42.218]                         invokeRestart("muffleWarning")
[16:13:42.218]                     }
[16:13:42.218]                     else if (inherits(cond, "condition")) {
[16:13:42.218]                       if (!is.null(pattern)) {
[16:13:42.218]                         computeRestarts <- base::computeRestarts
[16:13:42.218]                         grepl <- base::grepl
[16:13:42.218]                         restarts <- computeRestarts(cond)
[16:13:42.218]                         for (restart in restarts) {
[16:13:42.218]                           name <- restart$name
[16:13:42.218]                           if (is.null(name)) 
[16:13:42.218]                             next
[16:13:42.218]                           if (!grepl(pattern, name)) 
[16:13:42.218]                             next
[16:13:42.218]                           invokeRestart(restart)
[16:13:42.218]                           muffled <- TRUE
[16:13:42.218]                           break
[16:13:42.218]                         }
[16:13:42.218]                       }
[16:13:42.218]                     }
[16:13:42.218]                     invisible(muffled)
[16:13:42.218]                   }
[16:13:42.218]                   muffleCondition(cond)
[16:13:42.218]                 })
[16:13:42.218]             }))
[16:13:42.218]             future::FutureResult(value = ...future.value$value, 
[16:13:42.218]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.218]                   ...future.rng), globalenv = if (FALSE) 
[16:13:42.218]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:42.218]                     ...future.globalenv.names))
[16:13:42.218]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:42.218]         }, condition = base::local({
[16:13:42.218]             c <- base::c
[16:13:42.218]             inherits <- base::inherits
[16:13:42.218]             invokeRestart <- base::invokeRestart
[16:13:42.218]             length <- base::length
[16:13:42.218]             list <- base::list
[16:13:42.218]             seq.int <- base::seq.int
[16:13:42.218]             signalCondition <- base::signalCondition
[16:13:42.218]             sys.calls <- base::sys.calls
[16:13:42.218]             `[[` <- base::`[[`
[16:13:42.218]             `+` <- base::`+`
[16:13:42.218]             `<<-` <- base::`<<-`
[16:13:42.218]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:42.218]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:42.218]                   3L)]
[16:13:42.218]             }
[16:13:42.218]             function(cond) {
[16:13:42.218]                 is_error <- inherits(cond, "error")
[16:13:42.218]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:42.218]                   NULL)
[16:13:42.218]                 if (is_error) {
[16:13:42.218]                   sessionInformation <- function() {
[16:13:42.218]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:42.218]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:42.218]                       search = base::search(), system = base::Sys.info())
[16:13:42.218]                   }
[16:13:42.218]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.218]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:42.218]                     cond$call), session = sessionInformation(), 
[16:13:42.218]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:42.218]                   signalCondition(cond)
[16:13:42.218]                 }
[16:13:42.218]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:42.218]                 "immediateCondition"))) {
[16:13:42.218]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:42.218]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.218]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:42.218]                   if (TRUE && !signal) {
[16:13:42.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.218]                     {
[16:13:42.218]                       inherits <- base::inherits
[16:13:42.218]                       invokeRestart <- base::invokeRestart
[16:13:42.218]                       is.null <- base::is.null
[16:13:42.218]                       muffled <- FALSE
[16:13:42.218]                       if (inherits(cond, "message")) {
[16:13:42.218]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.218]                         if (muffled) 
[16:13:42.218]                           invokeRestart("muffleMessage")
[16:13:42.218]                       }
[16:13:42.218]                       else if (inherits(cond, "warning")) {
[16:13:42.218]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.218]                         if (muffled) 
[16:13:42.218]                           invokeRestart("muffleWarning")
[16:13:42.218]                       }
[16:13:42.218]                       else if (inherits(cond, "condition")) {
[16:13:42.218]                         if (!is.null(pattern)) {
[16:13:42.218]                           computeRestarts <- base::computeRestarts
[16:13:42.218]                           grepl <- base::grepl
[16:13:42.218]                           restarts <- computeRestarts(cond)
[16:13:42.218]                           for (restart in restarts) {
[16:13:42.218]                             name <- restart$name
[16:13:42.218]                             if (is.null(name)) 
[16:13:42.218]                               next
[16:13:42.218]                             if (!grepl(pattern, name)) 
[16:13:42.218]                               next
[16:13:42.218]                             invokeRestart(restart)
[16:13:42.218]                             muffled <- TRUE
[16:13:42.218]                             break
[16:13:42.218]                           }
[16:13:42.218]                         }
[16:13:42.218]                       }
[16:13:42.218]                       invisible(muffled)
[16:13:42.218]                     }
[16:13:42.218]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.218]                   }
[16:13:42.218]                 }
[16:13:42.218]                 else {
[16:13:42.218]                   if (TRUE) {
[16:13:42.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.218]                     {
[16:13:42.218]                       inherits <- base::inherits
[16:13:42.218]                       invokeRestart <- base::invokeRestart
[16:13:42.218]                       is.null <- base::is.null
[16:13:42.218]                       muffled <- FALSE
[16:13:42.218]                       if (inherits(cond, "message")) {
[16:13:42.218]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.218]                         if (muffled) 
[16:13:42.218]                           invokeRestart("muffleMessage")
[16:13:42.218]                       }
[16:13:42.218]                       else if (inherits(cond, "warning")) {
[16:13:42.218]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.218]                         if (muffled) 
[16:13:42.218]                           invokeRestart("muffleWarning")
[16:13:42.218]                       }
[16:13:42.218]                       else if (inherits(cond, "condition")) {
[16:13:42.218]                         if (!is.null(pattern)) {
[16:13:42.218]                           computeRestarts <- base::computeRestarts
[16:13:42.218]                           grepl <- base::grepl
[16:13:42.218]                           restarts <- computeRestarts(cond)
[16:13:42.218]                           for (restart in restarts) {
[16:13:42.218]                             name <- restart$name
[16:13:42.218]                             if (is.null(name)) 
[16:13:42.218]                               next
[16:13:42.218]                             if (!grepl(pattern, name)) 
[16:13:42.218]                               next
[16:13:42.218]                             invokeRestart(restart)
[16:13:42.218]                             muffled <- TRUE
[16:13:42.218]                             break
[16:13:42.218]                           }
[16:13:42.218]                         }
[16:13:42.218]                       }
[16:13:42.218]                       invisible(muffled)
[16:13:42.218]                     }
[16:13:42.218]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.218]                   }
[16:13:42.218]                 }
[16:13:42.218]             }
[16:13:42.218]         }))
[16:13:42.218]     }, error = function(ex) {
[16:13:42.218]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:42.218]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.218]                 ...future.rng), started = ...future.startTime, 
[16:13:42.218]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:42.218]             version = "1.8"), class = "FutureResult")
[16:13:42.218]     }, finally = {
[16:13:42.218]         if (!identical(...future.workdir, getwd())) 
[16:13:42.218]             setwd(...future.workdir)
[16:13:42.218]         {
[16:13:42.218]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:42.218]                 ...future.oldOptions$nwarnings <- NULL
[16:13:42.218]             }
[16:13:42.218]             base::options(...future.oldOptions)
[16:13:42.218]             if (.Platform$OS.type == "windows") {
[16:13:42.218]                 old_names <- names(...future.oldEnvVars)
[16:13:42.218]                 envs <- base::Sys.getenv()
[16:13:42.218]                 names <- names(envs)
[16:13:42.218]                 common <- intersect(names, old_names)
[16:13:42.218]                 added <- setdiff(names, old_names)
[16:13:42.218]                 removed <- setdiff(old_names, names)
[16:13:42.218]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:42.218]                   envs[common]]
[16:13:42.218]                 NAMES <- toupper(changed)
[16:13:42.218]                 args <- list()
[16:13:42.218]                 for (kk in seq_along(NAMES)) {
[16:13:42.218]                   name <- changed[[kk]]
[16:13:42.218]                   NAME <- NAMES[[kk]]
[16:13:42.218]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.218]                     next
[16:13:42.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.218]                 }
[16:13:42.218]                 NAMES <- toupper(added)
[16:13:42.218]                 for (kk in seq_along(NAMES)) {
[16:13:42.218]                   name <- added[[kk]]
[16:13:42.218]                   NAME <- NAMES[[kk]]
[16:13:42.218]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.218]                     next
[16:13:42.218]                   args[[name]] <- ""
[16:13:42.218]                 }
[16:13:42.218]                 NAMES <- toupper(removed)
[16:13:42.218]                 for (kk in seq_along(NAMES)) {
[16:13:42.218]                   name <- removed[[kk]]
[16:13:42.218]                   NAME <- NAMES[[kk]]
[16:13:42.218]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.218]                     next
[16:13:42.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.218]                 }
[16:13:42.218]                 if (length(args) > 0) 
[16:13:42.218]                   base::do.call(base::Sys.setenv, args = args)
[16:13:42.218]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:42.218]             }
[16:13:42.218]             else {
[16:13:42.218]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:42.218]             }
[16:13:42.218]             {
[16:13:42.218]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:42.218]                   0L) {
[16:13:42.218]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:42.218]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:42.218]                   base::options(opts)
[16:13:42.218]                 }
[16:13:42.218]                 {
[16:13:42.218]                   {
[16:13:42.218]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:42.218]                     NULL
[16:13:42.218]                   }
[16:13:42.218]                   options(future.plan = NULL)
[16:13:42.218]                   if (is.na(NA_character_)) 
[16:13:42.218]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.218]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:42.218]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:42.218]                     envir = parent.frame()) 
[16:13:42.218]                   {
[16:13:42.218]                     default_workers <- missing(workers)
[16:13:42.218]                     if (is.function(workers)) 
[16:13:42.218]                       workers <- workers()
[16:13:42.218]                     workers <- structure(as.integer(workers), 
[16:13:42.218]                       class = class(workers))
[16:13:42.218]                     stop_if_not(is.finite(workers), workers >= 
[16:13:42.218]                       1L)
[16:13:42.218]                     if ((workers == 1L && !inherits(workers, 
[16:13:42.218]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:42.218]                       if (default_workers) 
[16:13:42.218]                         supportsMulticore(warn = TRUE)
[16:13:42.218]                       return(sequential(..., envir = envir))
[16:13:42.218]                     }
[16:13:42.218]                     oopts <- options(mc.cores = workers)
[16:13:42.218]                     on.exit(options(oopts))
[16:13:42.218]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:42.218]                       envir = envir)
[16:13:42.218]                     if (!future$lazy) 
[16:13:42.218]                       future <- run(future)
[16:13:42.218]                     invisible(future)
[16:13:42.218]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:42.218]                 }
[16:13:42.218]             }
[16:13:42.218]         }
[16:13:42.218]     })
[16:13:42.218]     if (TRUE) {
[16:13:42.218]         base::sink(type = "output", split = FALSE)
[16:13:42.218]         if (TRUE) {
[16:13:42.218]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:42.218]         }
[16:13:42.218]         else {
[16:13:42.218]             ...future.result["stdout"] <- base::list(NULL)
[16:13:42.218]         }
[16:13:42.218]         base::close(...future.stdout)
[16:13:42.218]         ...future.stdout <- NULL
[16:13:42.218]     }
[16:13:42.218]     ...future.result$conditions <- ...future.conditions
[16:13:42.218]     ...future.result$finished <- base::Sys.time()
[16:13:42.218]     ...future.result
[16:13:42.218] }
[16:13:42.222] requestCore(): workers = 2
[16:13:42.222] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:42.235] MulticoreFuture started
[16:13:42.236] - Launch lazy future ... done
[16:13:42.236] run() for ‘MulticoreFuture’ ... done
[16:13:42.237] plan(): Setting new future strategy stack:
[16:13:42.237] List of future strategies:
[16:13:42.237] 1. sequential:
[16:13:42.237]    - args: function (..., envir = parent.frame())
[16:13:42.237]    - tweaked: FALSE
[16:13:42.237]    - call: NULL
[16:13:42.238] plan(): nbrOfWorkers() = 1
[16:13:42.239] resolve() on environment ...
[16:13:42.239]  recursive: 0
[16:13:42.240]  elements: [3] ‘a’
[16:13:42.241] Future #1
[16:13:42.241]  length: 2 (resolved future 1)
[16:13:42.241] plan(): Setting new future strategy stack:
[16:13:42.241] List of future strategies:
[16:13:42.241] 1. multicore:
[16:13:42.241]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:42.241]    - tweaked: FALSE
[16:13:42.241]    - call: plan(strategy)
[16:13:42.246] plan(): nbrOfWorkers() = 2
[16:13:42.247] Future #2
[16:13:42.247]  length: 1 (resolved future 2)
[16:13:42.247]  length: 0 (resolved future 3)
[16:13:42.247] resolve() on environment ... DONE
[16:13:42.249] resolve() on environment ...
[16:13:42.249]  recursive: 0
[16:13:42.250]  elements: [3] ‘b’
[16:13:42.250] Future #1
[16:13:42.250]  length: 2 (resolved future 1)
[16:13:42.251] Future #2
[16:13:42.251]  length: 1 (resolved future 2)
[16:13:42.251]  length: 0 (resolved future 3)
[16:13:42.251] resolve() on environment ... DONE
[16:13:42.252] resolve() on environment ...
[16:13:42.252]  recursive: 0
[16:13:42.253]  elements: [3] ‘c’
[16:13:42.253] Future #1
[16:13:42.253]  length: 2 (resolved future 1)
[16:13:42.254] Future #2
[16:13:42.254]  length: 1 (resolved future 2)
[16:13:42.254]  length: 0 (resolved future 3)
[16:13:42.254] resolve() on environment ... DONE
[16:13:42.255] resolve() on environment ...
[16:13:42.255]  recursive: 0
[16:13:42.256]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[16:13:42.256] Future #1
[16:13:42.257]  length: 2 (resolved future 1)
[16:13:42.261] Future #2
[16:13:42.263]  length: 1 (resolved future 2)
[16:13:42.263]  length: 0 (resolved future 3)
[16:13:42.263] resolve() on environment ... DONE
[16:13:42.264] resolve() on environment ...
[16:13:42.264]  recursive: 99
[16:13:42.265]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[16:13:42.265] Future #1
[16:13:42.265] A MulticoreFuture was resolved
[16:13:42.266]  length: 2 (resolved future 1)
[16:13:42.266] Future #2
[16:13:42.266] A MulticoreFuture was resolved
[16:13:42.266]  length: 1 (resolved future 2)
[16:13:42.266]  length: 0 (resolved future 3)
[16:13:42.266] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[16:13:42.267] resolve() on list environment ...
[16:13:42.267]  recursive: 0
[16:13:42.268]  length: 2
[16:13:42.268]  elements: ‘a’, ‘b’
[16:13:42.268]  length: 1 (resolved future 1)
[16:13:42.269]  length: 0 (resolved future 2)
[16:13:42.269] resolve() on list environment ... DONE
[16:13:42.269] getGlobalsAndPackages() ...
[16:13:42.269] Searching for globals...
[16:13:42.269] 
[16:13:42.270] Searching for globals ... DONE
[16:13:42.270] - globals: [0] <none>
[16:13:42.270] getGlobalsAndPackages() ... DONE
[16:13:42.270] run() for ‘Future’ ...
[16:13:42.270] - state: ‘created’
[16:13:42.270] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:42.274] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:42.275] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:42.275]   - Field: ‘label’
[16:13:42.275]   - Field: ‘local’
[16:13:42.275]   - Field: ‘owner’
[16:13:42.275]   - Field: ‘envir’
[16:13:42.275]   - Field: ‘workers’
[16:13:42.275]   - Field: ‘packages’
[16:13:42.275]   - Field: ‘gc’
[16:13:42.275]   - Field: ‘job’
[16:13:42.276]   - Field: ‘conditions’
[16:13:42.276]   - Field: ‘expr’
[16:13:42.276]   - Field: ‘uuid’
[16:13:42.276]   - Field: ‘seed’
[16:13:42.276]   - Field: ‘version’
[16:13:42.276]   - Field: ‘result’
[16:13:42.276]   - Field: ‘asynchronous’
[16:13:42.276]   - Field: ‘calls’
[16:13:42.276]   - Field: ‘globals’
[16:13:42.277]   - Field: ‘stdout’
[16:13:42.277]   - Field: ‘earlySignal’
[16:13:42.277]   - Field: ‘lazy’
[16:13:42.277]   - Field: ‘state’
[16:13:42.277] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:42.277] - Launch lazy future ...
[16:13:42.277] Packages needed by the future expression (n = 0): <none>
[16:13:42.278] Packages needed by future strategies (n = 0): <none>
[16:13:42.278] {
[16:13:42.278]     {
[16:13:42.278]         {
[16:13:42.278]             ...future.startTime <- base::Sys.time()
[16:13:42.278]             {
[16:13:42.278]                 {
[16:13:42.278]                   {
[16:13:42.278]                     {
[16:13:42.278]                       base::local({
[16:13:42.278]                         has_future <- base::requireNamespace("future", 
[16:13:42.278]                           quietly = TRUE)
[16:13:42.278]                         if (has_future) {
[16:13:42.278]                           ns <- base::getNamespace("future")
[16:13:42.278]                           version <- ns[[".package"]][["version"]]
[16:13:42.278]                           if (is.null(version)) 
[16:13:42.278]                             version <- utils::packageVersion("future")
[16:13:42.278]                         }
[16:13:42.278]                         else {
[16:13:42.278]                           version <- NULL
[16:13:42.278]                         }
[16:13:42.278]                         if (!has_future || version < "1.8.0") {
[16:13:42.278]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:42.278]                             "", base::R.version$version.string), 
[16:13:42.278]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:42.278]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:42.278]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:42.278]                               "release", "version")], collapse = " "), 
[16:13:42.278]                             hostname = base::Sys.info()[["nodename"]])
[16:13:42.278]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:42.278]                             info)
[16:13:42.278]                           info <- base::paste(info, collapse = "; ")
[16:13:42.278]                           if (!has_future) {
[16:13:42.278]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:42.278]                               info)
[16:13:42.278]                           }
[16:13:42.278]                           else {
[16:13:42.278]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:42.278]                               info, version)
[16:13:42.278]                           }
[16:13:42.278]                           base::stop(msg)
[16:13:42.278]                         }
[16:13:42.278]                       })
[16:13:42.278]                     }
[16:13:42.278]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:42.278]                     base::options(mc.cores = 1L)
[16:13:42.278]                   }
[16:13:42.278]                   options(future.plan = NULL)
[16:13:42.278]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.278]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:42.278]                 }
[16:13:42.278]                 ...future.workdir <- getwd()
[16:13:42.278]             }
[16:13:42.278]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:42.278]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:42.278]         }
[16:13:42.278]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:42.278]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:42.278]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:42.278]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:42.278]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:42.278]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:42.278]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:42.278]             base::names(...future.oldOptions))
[16:13:42.278]     }
[16:13:42.278]     if (FALSE) {
[16:13:42.278]     }
[16:13:42.278]     else {
[16:13:42.278]         if (TRUE) {
[16:13:42.278]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:42.278]                 open = "w")
[16:13:42.278]         }
[16:13:42.278]         else {
[16:13:42.278]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:42.278]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:42.278]         }
[16:13:42.278]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:42.278]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:42.278]             base::sink(type = "output", split = FALSE)
[16:13:42.278]             base::close(...future.stdout)
[16:13:42.278]         }, add = TRUE)
[16:13:42.278]     }
[16:13:42.278]     ...future.frame <- base::sys.nframe()
[16:13:42.278]     ...future.conditions <- base::list()
[16:13:42.278]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:42.278]     if (FALSE) {
[16:13:42.278]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:42.278]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:42.278]     }
[16:13:42.278]     ...future.result <- base::tryCatch({
[16:13:42.278]         base::withCallingHandlers({
[16:13:42.278]             ...future.value <- base::withVisible(base::local({
[16:13:42.278]                 withCallingHandlers({
[16:13:42.278]                   1
[16:13:42.278]                 }, immediateCondition = function(cond) {
[16:13:42.278]                   save_rds <- function (object, pathname, ...) 
[16:13:42.278]                   {
[16:13:42.278]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:42.278]                     if (file_test("-f", pathname_tmp)) {
[16:13:42.278]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.278]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:42.278]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.278]                         fi_tmp[["mtime"]])
[16:13:42.278]                     }
[16:13:42.278]                     tryCatch({
[16:13:42.278]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:42.278]                     }, error = function(ex) {
[16:13:42.278]                       msg <- conditionMessage(ex)
[16:13:42.278]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.278]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:42.278]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.278]                         fi_tmp[["mtime"]], msg)
[16:13:42.278]                       ex$message <- msg
[16:13:42.278]                       stop(ex)
[16:13:42.278]                     })
[16:13:42.278]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:42.278]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:42.278]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:42.278]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.278]                       fi <- file.info(pathname)
[16:13:42.278]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:42.278]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.278]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:42.278]                         fi[["size"]], fi[["mtime"]])
[16:13:42.278]                       stop(msg)
[16:13:42.278]                     }
[16:13:42.278]                     invisible(pathname)
[16:13:42.278]                   }
[16:13:42.278]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:42.278]                     rootPath = tempdir()) 
[16:13:42.278]                   {
[16:13:42.278]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:42.278]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:42.278]                       tmpdir = path, fileext = ".rds")
[16:13:42.278]                     save_rds(obj, file)
[16:13:42.278]                   }
[16:13:42.278]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:42.278]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.278]                   {
[16:13:42.278]                     inherits <- base::inherits
[16:13:42.278]                     invokeRestart <- base::invokeRestart
[16:13:42.278]                     is.null <- base::is.null
[16:13:42.278]                     muffled <- FALSE
[16:13:42.278]                     if (inherits(cond, "message")) {
[16:13:42.278]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:42.278]                       if (muffled) 
[16:13:42.278]                         invokeRestart("muffleMessage")
[16:13:42.278]                     }
[16:13:42.278]                     else if (inherits(cond, "warning")) {
[16:13:42.278]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:42.278]                       if (muffled) 
[16:13:42.278]                         invokeRestart("muffleWarning")
[16:13:42.278]                     }
[16:13:42.278]                     else if (inherits(cond, "condition")) {
[16:13:42.278]                       if (!is.null(pattern)) {
[16:13:42.278]                         computeRestarts <- base::computeRestarts
[16:13:42.278]                         grepl <- base::grepl
[16:13:42.278]                         restarts <- computeRestarts(cond)
[16:13:42.278]                         for (restart in restarts) {
[16:13:42.278]                           name <- restart$name
[16:13:42.278]                           if (is.null(name)) 
[16:13:42.278]                             next
[16:13:42.278]                           if (!grepl(pattern, name)) 
[16:13:42.278]                             next
[16:13:42.278]                           invokeRestart(restart)
[16:13:42.278]                           muffled <- TRUE
[16:13:42.278]                           break
[16:13:42.278]                         }
[16:13:42.278]                       }
[16:13:42.278]                     }
[16:13:42.278]                     invisible(muffled)
[16:13:42.278]                   }
[16:13:42.278]                   muffleCondition(cond)
[16:13:42.278]                 })
[16:13:42.278]             }))
[16:13:42.278]             future::FutureResult(value = ...future.value$value, 
[16:13:42.278]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.278]                   ...future.rng), globalenv = if (FALSE) 
[16:13:42.278]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:42.278]                     ...future.globalenv.names))
[16:13:42.278]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:42.278]         }, condition = base::local({
[16:13:42.278]             c <- base::c
[16:13:42.278]             inherits <- base::inherits
[16:13:42.278]             invokeRestart <- base::invokeRestart
[16:13:42.278]             length <- base::length
[16:13:42.278]             list <- base::list
[16:13:42.278]             seq.int <- base::seq.int
[16:13:42.278]             signalCondition <- base::signalCondition
[16:13:42.278]             sys.calls <- base::sys.calls
[16:13:42.278]             `[[` <- base::`[[`
[16:13:42.278]             `+` <- base::`+`
[16:13:42.278]             `<<-` <- base::`<<-`
[16:13:42.278]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:42.278]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:42.278]                   3L)]
[16:13:42.278]             }
[16:13:42.278]             function(cond) {
[16:13:42.278]                 is_error <- inherits(cond, "error")
[16:13:42.278]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:42.278]                   NULL)
[16:13:42.278]                 if (is_error) {
[16:13:42.278]                   sessionInformation <- function() {
[16:13:42.278]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:42.278]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:42.278]                       search = base::search(), system = base::Sys.info())
[16:13:42.278]                   }
[16:13:42.278]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.278]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:42.278]                     cond$call), session = sessionInformation(), 
[16:13:42.278]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:42.278]                   signalCondition(cond)
[16:13:42.278]                 }
[16:13:42.278]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:42.278]                 "immediateCondition"))) {
[16:13:42.278]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:42.278]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.278]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:42.278]                   if (TRUE && !signal) {
[16:13:42.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.278]                     {
[16:13:42.278]                       inherits <- base::inherits
[16:13:42.278]                       invokeRestart <- base::invokeRestart
[16:13:42.278]                       is.null <- base::is.null
[16:13:42.278]                       muffled <- FALSE
[16:13:42.278]                       if (inherits(cond, "message")) {
[16:13:42.278]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.278]                         if (muffled) 
[16:13:42.278]                           invokeRestart("muffleMessage")
[16:13:42.278]                       }
[16:13:42.278]                       else if (inherits(cond, "warning")) {
[16:13:42.278]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.278]                         if (muffled) 
[16:13:42.278]                           invokeRestart("muffleWarning")
[16:13:42.278]                       }
[16:13:42.278]                       else if (inherits(cond, "condition")) {
[16:13:42.278]                         if (!is.null(pattern)) {
[16:13:42.278]                           computeRestarts <- base::computeRestarts
[16:13:42.278]                           grepl <- base::grepl
[16:13:42.278]                           restarts <- computeRestarts(cond)
[16:13:42.278]                           for (restart in restarts) {
[16:13:42.278]                             name <- restart$name
[16:13:42.278]                             if (is.null(name)) 
[16:13:42.278]                               next
[16:13:42.278]                             if (!grepl(pattern, name)) 
[16:13:42.278]                               next
[16:13:42.278]                             invokeRestart(restart)
[16:13:42.278]                             muffled <- TRUE
[16:13:42.278]                             break
[16:13:42.278]                           }
[16:13:42.278]                         }
[16:13:42.278]                       }
[16:13:42.278]                       invisible(muffled)
[16:13:42.278]                     }
[16:13:42.278]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.278]                   }
[16:13:42.278]                 }
[16:13:42.278]                 else {
[16:13:42.278]                   if (TRUE) {
[16:13:42.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.278]                     {
[16:13:42.278]                       inherits <- base::inherits
[16:13:42.278]                       invokeRestart <- base::invokeRestart
[16:13:42.278]                       is.null <- base::is.null
[16:13:42.278]                       muffled <- FALSE
[16:13:42.278]                       if (inherits(cond, "message")) {
[16:13:42.278]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.278]                         if (muffled) 
[16:13:42.278]                           invokeRestart("muffleMessage")
[16:13:42.278]                       }
[16:13:42.278]                       else if (inherits(cond, "warning")) {
[16:13:42.278]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.278]                         if (muffled) 
[16:13:42.278]                           invokeRestart("muffleWarning")
[16:13:42.278]                       }
[16:13:42.278]                       else if (inherits(cond, "condition")) {
[16:13:42.278]                         if (!is.null(pattern)) {
[16:13:42.278]                           computeRestarts <- base::computeRestarts
[16:13:42.278]                           grepl <- base::grepl
[16:13:42.278]                           restarts <- computeRestarts(cond)
[16:13:42.278]                           for (restart in restarts) {
[16:13:42.278]                             name <- restart$name
[16:13:42.278]                             if (is.null(name)) 
[16:13:42.278]                               next
[16:13:42.278]                             if (!grepl(pattern, name)) 
[16:13:42.278]                               next
[16:13:42.278]                             invokeRestart(restart)
[16:13:42.278]                             muffled <- TRUE
[16:13:42.278]                             break
[16:13:42.278]                           }
[16:13:42.278]                         }
[16:13:42.278]                       }
[16:13:42.278]                       invisible(muffled)
[16:13:42.278]                     }
[16:13:42.278]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.278]                   }
[16:13:42.278]                 }
[16:13:42.278]             }
[16:13:42.278]         }))
[16:13:42.278]     }, error = function(ex) {
[16:13:42.278]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:42.278]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.278]                 ...future.rng), started = ...future.startTime, 
[16:13:42.278]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:42.278]             version = "1.8"), class = "FutureResult")
[16:13:42.278]     }, finally = {
[16:13:42.278]         if (!identical(...future.workdir, getwd())) 
[16:13:42.278]             setwd(...future.workdir)
[16:13:42.278]         {
[16:13:42.278]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:42.278]                 ...future.oldOptions$nwarnings <- NULL
[16:13:42.278]             }
[16:13:42.278]             base::options(...future.oldOptions)
[16:13:42.278]             if (.Platform$OS.type == "windows") {
[16:13:42.278]                 old_names <- names(...future.oldEnvVars)
[16:13:42.278]                 envs <- base::Sys.getenv()
[16:13:42.278]                 names <- names(envs)
[16:13:42.278]                 common <- intersect(names, old_names)
[16:13:42.278]                 added <- setdiff(names, old_names)
[16:13:42.278]                 removed <- setdiff(old_names, names)
[16:13:42.278]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:42.278]                   envs[common]]
[16:13:42.278]                 NAMES <- toupper(changed)
[16:13:42.278]                 args <- list()
[16:13:42.278]                 for (kk in seq_along(NAMES)) {
[16:13:42.278]                   name <- changed[[kk]]
[16:13:42.278]                   NAME <- NAMES[[kk]]
[16:13:42.278]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.278]                     next
[16:13:42.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.278]                 }
[16:13:42.278]                 NAMES <- toupper(added)
[16:13:42.278]                 for (kk in seq_along(NAMES)) {
[16:13:42.278]                   name <- added[[kk]]
[16:13:42.278]                   NAME <- NAMES[[kk]]
[16:13:42.278]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.278]                     next
[16:13:42.278]                   args[[name]] <- ""
[16:13:42.278]                 }
[16:13:42.278]                 NAMES <- toupper(removed)
[16:13:42.278]                 for (kk in seq_along(NAMES)) {
[16:13:42.278]                   name <- removed[[kk]]
[16:13:42.278]                   NAME <- NAMES[[kk]]
[16:13:42.278]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.278]                     next
[16:13:42.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.278]                 }
[16:13:42.278]                 if (length(args) > 0) 
[16:13:42.278]                   base::do.call(base::Sys.setenv, args = args)
[16:13:42.278]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:42.278]             }
[16:13:42.278]             else {
[16:13:42.278]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:42.278]             }
[16:13:42.278]             {
[16:13:42.278]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:42.278]                   0L) {
[16:13:42.278]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:42.278]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:42.278]                   base::options(opts)
[16:13:42.278]                 }
[16:13:42.278]                 {
[16:13:42.278]                   {
[16:13:42.278]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:42.278]                     NULL
[16:13:42.278]                   }
[16:13:42.278]                   options(future.plan = NULL)
[16:13:42.278]                   if (is.na(NA_character_)) 
[16:13:42.278]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.278]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:42.278]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:42.278]                     envir = parent.frame()) 
[16:13:42.278]                   {
[16:13:42.278]                     default_workers <- missing(workers)
[16:13:42.278]                     if (is.function(workers)) 
[16:13:42.278]                       workers <- workers()
[16:13:42.278]                     workers <- structure(as.integer(workers), 
[16:13:42.278]                       class = class(workers))
[16:13:42.278]                     stop_if_not(is.finite(workers), workers >= 
[16:13:42.278]                       1L)
[16:13:42.278]                     if ((workers == 1L && !inherits(workers, 
[16:13:42.278]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:42.278]                       if (default_workers) 
[16:13:42.278]                         supportsMulticore(warn = TRUE)
[16:13:42.278]                       return(sequential(..., envir = envir))
[16:13:42.278]                     }
[16:13:42.278]                     oopts <- options(mc.cores = workers)
[16:13:42.278]                     on.exit(options(oopts))
[16:13:42.278]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:42.278]                       envir = envir)
[16:13:42.278]                     if (!future$lazy) 
[16:13:42.278]                       future <- run(future)
[16:13:42.278]                     invisible(future)
[16:13:42.278]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:42.278]                 }
[16:13:42.278]             }
[16:13:42.278]         }
[16:13:42.278]     })
[16:13:42.278]     if (TRUE) {
[16:13:42.278]         base::sink(type = "output", split = FALSE)
[16:13:42.278]         if (TRUE) {
[16:13:42.278]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:42.278]         }
[16:13:42.278]         else {
[16:13:42.278]             ...future.result["stdout"] <- base::list(NULL)
[16:13:42.278]         }
[16:13:42.278]         base::close(...future.stdout)
[16:13:42.278]         ...future.stdout <- NULL
[16:13:42.278]     }
[16:13:42.278]     ...future.result$conditions <- ...future.conditions
[16:13:42.278]     ...future.result$finished <- base::Sys.time()
[16:13:42.278]     ...future.result
[16:13:42.278] }
[16:13:42.280] requestCore(): workers = 2
[16:13:42.282] MulticoreFuture started
[16:13:42.283] - Launch lazy future ... done
[16:13:42.283] run() for ‘MulticoreFuture’ ... done
[16:13:42.283] getGlobalsAndPackages() ...
[16:13:42.283] plan(): Setting new future strategy stack:
[16:13:42.283] Searching for globals...
[16:13:42.284] List of future strategies:
[16:13:42.284] 1. sequential:
[16:13:42.284]    - args: function (..., envir = parent.frame())
[16:13:42.284]    - tweaked: FALSE
[16:13:42.284]    - call: NULL
[16:13:42.284] 
[16:13:42.284] Searching for globals ... DONE
[16:13:42.285] plan(): nbrOfWorkers() = 1
[16:13:42.285] - globals: [0] <none>
[16:13:42.285] getGlobalsAndPackages() ... DONE
[16:13:42.285] run() for ‘Future’ ...
[16:13:42.285] - state: ‘created’
[16:13:42.286] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:42.286] plan(): Setting new future strategy stack:
[16:13:42.287] List of future strategies:
[16:13:42.287] 1. multicore:
[16:13:42.287]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:42.287]    - tweaked: FALSE
[16:13:42.287]    - call: plan(strategy)
[16:13:42.291] plan(): nbrOfWorkers() = 2
[16:13:42.291] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:42.291] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:42.291]   - Field: ‘label’
[16:13:42.292]   - Field: ‘local’
[16:13:42.292]   - Field: ‘owner’
[16:13:42.292]   - Field: ‘envir’
[16:13:42.292]   - Field: ‘workers’
[16:13:42.292]   - Field: ‘packages’
[16:13:42.292]   - Field: ‘gc’
[16:13:42.293]   - Field: ‘job’
[16:13:42.293]   - Field: ‘conditions’
[16:13:42.293]   - Field: ‘expr’
[16:13:42.293]   - Field: ‘uuid’
[16:13:42.293]   - Field: ‘seed’
[16:13:42.293]   - Field: ‘version’
[16:13:42.294]   - Field: ‘result’
[16:13:42.294]   - Field: ‘asynchronous’
[16:13:42.294]   - Field: ‘calls’
[16:13:42.294]   - Field: ‘globals’
[16:13:42.294]   - Field: ‘stdout’
[16:13:42.294]   - Field: ‘earlySignal’
[16:13:42.294]   - Field: ‘lazy’
[16:13:42.295]   - Field: ‘state’
[16:13:42.295] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:42.295] - Launch lazy future ...
[16:13:42.295] Packages needed by the future expression (n = 0): <none>
[16:13:42.296] Packages needed by future strategies (n = 0): <none>
[16:13:42.296] {
[16:13:42.296]     {
[16:13:42.296]         {
[16:13:42.296]             ...future.startTime <- base::Sys.time()
[16:13:42.296]             {
[16:13:42.296]                 {
[16:13:42.296]                   {
[16:13:42.296]                     {
[16:13:42.296]                       base::local({
[16:13:42.296]                         has_future <- base::requireNamespace("future", 
[16:13:42.296]                           quietly = TRUE)
[16:13:42.296]                         if (has_future) {
[16:13:42.296]                           ns <- base::getNamespace("future")
[16:13:42.296]                           version <- ns[[".package"]][["version"]]
[16:13:42.296]                           if (is.null(version)) 
[16:13:42.296]                             version <- utils::packageVersion("future")
[16:13:42.296]                         }
[16:13:42.296]                         else {
[16:13:42.296]                           version <- NULL
[16:13:42.296]                         }
[16:13:42.296]                         if (!has_future || version < "1.8.0") {
[16:13:42.296]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:42.296]                             "", base::R.version$version.string), 
[16:13:42.296]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:42.296]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:42.296]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:42.296]                               "release", "version")], collapse = " "), 
[16:13:42.296]                             hostname = base::Sys.info()[["nodename"]])
[16:13:42.296]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:42.296]                             info)
[16:13:42.296]                           info <- base::paste(info, collapse = "; ")
[16:13:42.296]                           if (!has_future) {
[16:13:42.296]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:42.296]                               info)
[16:13:42.296]                           }
[16:13:42.296]                           else {
[16:13:42.296]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:42.296]                               info, version)
[16:13:42.296]                           }
[16:13:42.296]                           base::stop(msg)
[16:13:42.296]                         }
[16:13:42.296]                       })
[16:13:42.296]                     }
[16:13:42.296]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:42.296]                     base::options(mc.cores = 1L)
[16:13:42.296]                   }
[16:13:42.296]                   options(future.plan = NULL)
[16:13:42.296]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.296]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:42.296]                 }
[16:13:42.296]                 ...future.workdir <- getwd()
[16:13:42.296]             }
[16:13:42.296]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:42.296]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:42.296]         }
[16:13:42.296]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:42.296]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:42.296]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:42.296]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:42.296]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:42.296]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:42.296]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:42.296]             base::names(...future.oldOptions))
[16:13:42.296]     }
[16:13:42.296]     if (FALSE) {
[16:13:42.296]     }
[16:13:42.296]     else {
[16:13:42.296]         if (TRUE) {
[16:13:42.296]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:42.296]                 open = "w")
[16:13:42.296]         }
[16:13:42.296]         else {
[16:13:42.296]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:42.296]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:42.296]         }
[16:13:42.296]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:42.296]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:42.296]             base::sink(type = "output", split = FALSE)
[16:13:42.296]             base::close(...future.stdout)
[16:13:42.296]         }, add = TRUE)
[16:13:42.296]     }
[16:13:42.296]     ...future.frame <- base::sys.nframe()
[16:13:42.296]     ...future.conditions <- base::list()
[16:13:42.296]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:42.296]     if (FALSE) {
[16:13:42.296]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:42.296]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:42.296]     }
[16:13:42.296]     ...future.result <- base::tryCatch({
[16:13:42.296]         base::withCallingHandlers({
[16:13:42.296]             ...future.value <- base::withVisible(base::local({
[16:13:42.296]                 withCallingHandlers({
[16:13:42.296]                   2
[16:13:42.296]                 }, immediateCondition = function(cond) {
[16:13:42.296]                   save_rds <- function (object, pathname, ...) 
[16:13:42.296]                   {
[16:13:42.296]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:42.296]                     if (file_test("-f", pathname_tmp)) {
[16:13:42.296]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.296]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:42.296]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.296]                         fi_tmp[["mtime"]])
[16:13:42.296]                     }
[16:13:42.296]                     tryCatch({
[16:13:42.296]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:42.296]                     }, error = function(ex) {
[16:13:42.296]                       msg <- conditionMessage(ex)
[16:13:42.296]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.296]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:42.296]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.296]                         fi_tmp[["mtime"]], msg)
[16:13:42.296]                       ex$message <- msg
[16:13:42.296]                       stop(ex)
[16:13:42.296]                     })
[16:13:42.296]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:42.296]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:42.296]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:42.296]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.296]                       fi <- file.info(pathname)
[16:13:42.296]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:42.296]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.296]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:42.296]                         fi[["size"]], fi[["mtime"]])
[16:13:42.296]                       stop(msg)
[16:13:42.296]                     }
[16:13:42.296]                     invisible(pathname)
[16:13:42.296]                   }
[16:13:42.296]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:42.296]                     rootPath = tempdir()) 
[16:13:42.296]                   {
[16:13:42.296]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:42.296]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:42.296]                       tmpdir = path, fileext = ".rds")
[16:13:42.296]                     save_rds(obj, file)
[16:13:42.296]                   }
[16:13:42.296]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:42.296]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.296]                   {
[16:13:42.296]                     inherits <- base::inherits
[16:13:42.296]                     invokeRestart <- base::invokeRestart
[16:13:42.296]                     is.null <- base::is.null
[16:13:42.296]                     muffled <- FALSE
[16:13:42.296]                     if (inherits(cond, "message")) {
[16:13:42.296]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:42.296]                       if (muffled) 
[16:13:42.296]                         invokeRestart("muffleMessage")
[16:13:42.296]                     }
[16:13:42.296]                     else if (inherits(cond, "warning")) {
[16:13:42.296]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:42.296]                       if (muffled) 
[16:13:42.296]                         invokeRestart("muffleWarning")
[16:13:42.296]                     }
[16:13:42.296]                     else if (inherits(cond, "condition")) {
[16:13:42.296]                       if (!is.null(pattern)) {
[16:13:42.296]                         computeRestarts <- base::computeRestarts
[16:13:42.296]                         grepl <- base::grepl
[16:13:42.296]                         restarts <- computeRestarts(cond)
[16:13:42.296]                         for (restart in restarts) {
[16:13:42.296]                           name <- restart$name
[16:13:42.296]                           if (is.null(name)) 
[16:13:42.296]                             next
[16:13:42.296]                           if (!grepl(pattern, name)) 
[16:13:42.296]                             next
[16:13:42.296]                           invokeRestart(restart)
[16:13:42.296]                           muffled <- TRUE
[16:13:42.296]                           break
[16:13:42.296]                         }
[16:13:42.296]                       }
[16:13:42.296]                     }
[16:13:42.296]                     invisible(muffled)
[16:13:42.296]                   }
[16:13:42.296]                   muffleCondition(cond)
[16:13:42.296]                 })
[16:13:42.296]             }))
[16:13:42.296]             future::FutureResult(value = ...future.value$value, 
[16:13:42.296]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.296]                   ...future.rng), globalenv = if (FALSE) 
[16:13:42.296]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:42.296]                     ...future.globalenv.names))
[16:13:42.296]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:42.296]         }, condition = base::local({
[16:13:42.296]             c <- base::c
[16:13:42.296]             inherits <- base::inherits
[16:13:42.296]             invokeRestart <- base::invokeRestart
[16:13:42.296]             length <- base::length
[16:13:42.296]             list <- base::list
[16:13:42.296]             seq.int <- base::seq.int
[16:13:42.296]             signalCondition <- base::signalCondition
[16:13:42.296]             sys.calls <- base::sys.calls
[16:13:42.296]             `[[` <- base::`[[`
[16:13:42.296]             `+` <- base::`+`
[16:13:42.296]             `<<-` <- base::`<<-`
[16:13:42.296]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:42.296]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:42.296]                   3L)]
[16:13:42.296]             }
[16:13:42.296]             function(cond) {
[16:13:42.296]                 is_error <- inherits(cond, "error")
[16:13:42.296]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:42.296]                   NULL)
[16:13:42.296]                 if (is_error) {
[16:13:42.296]                   sessionInformation <- function() {
[16:13:42.296]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:42.296]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:42.296]                       search = base::search(), system = base::Sys.info())
[16:13:42.296]                   }
[16:13:42.296]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.296]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:42.296]                     cond$call), session = sessionInformation(), 
[16:13:42.296]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:42.296]                   signalCondition(cond)
[16:13:42.296]                 }
[16:13:42.296]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:42.296]                 "immediateCondition"))) {
[16:13:42.296]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:42.296]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.296]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:42.296]                   if (TRUE && !signal) {
[16:13:42.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.296]                     {
[16:13:42.296]                       inherits <- base::inherits
[16:13:42.296]                       invokeRestart <- base::invokeRestart
[16:13:42.296]                       is.null <- base::is.null
[16:13:42.296]                       muffled <- FALSE
[16:13:42.296]                       if (inherits(cond, "message")) {
[16:13:42.296]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.296]                         if (muffled) 
[16:13:42.296]                           invokeRestart("muffleMessage")
[16:13:42.296]                       }
[16:13:42.296]                       else if (inherits(cond, "warning")) {
[16:13:42.296]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.296]                         if (muffled) 
[16:13:42.296]                           invokeRestart("muffleWarning")
[16:13:42.296]                       }
[16:13:42.296]                       else if (inherits(cond, "condition")) {
[16:13:42.296]                         if (!is.null(pattern)) {
[16:13:42.296]                           computeRestarts <- base::computeRestarts
[16:13:42.296]                           grepl <- base::grepl
[16:13:42.296]                           restarts <- computeRestarts(cond)
[16:13:42.296]                           for (restart in restarts) {
[16:13:42.296]                             name <- restart$name
[16:13:42.296]                             if (is.null(name)) 
[16:13:42.296]                               next
[16:13:42.296]                             if (!grepl(pattern, name)) 
[16:13:42.296]                               next
[16:13:42.296]                             invokeRestart(restart)
[16:13:42.296]                             muffled <- TRUE
[16:13:42.296]                             break
[16:13:42.296]                           }
[16:13:42.296]                         }
[16:13:42.296]                       }
[16:13:42.296]                       invisible(muffled)
[16:13:42.296]                     }
[16:13:42.296]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.296]                   }
[16:13:42.296]                 }
[16:13:42.296]                 else {
[16:13:42.296]                   if (TRUE) {
[16:13:42.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.296]                     {
[16:13:42.296]                       inherits <- base::inherits
[16:13:42.296]                       invokeRestart <- base::invokeRestart
[16:13:42.296]                       is.null <- base::is.null
[16:13:42.296]                       muffled <- FALSE
[16:13:42.296]                       if (inherits(cond, "message")) {
[16:13:42.296]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.296]                         if (muffled) 
[16:13:42.296]                           invokeRestart("muffleMessage")
[16:13:42.296]                       }
[16:13:42.296]                       else if (inherits(cond, "warning")) {
[16:13:42.296]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.296]                         if (muffled) 
[16:13:42.296]                           invokeRestart("muffleWarning")
[16:13:42.296]                       }
[16:13:42.296]                       else if (inherits(cond, "condition")) {
[16:13:42.296]                         if (!is.null(pattern)) {
[16:13:42.296]                           computeRestarts <- base::computeRestarts
[16:13:42.296]                           grepl <- base::grepl
[16:13:42.296]                           restarts <- computeRestarts(cond)
[16:13:42.296]                           for (restart in restarts) {
[16:13:42.296]                             name <- restart$name
[16:13:42.296]                             if (is.null(name)) 
[16:13:42.296]                               next
[16:13:42.296]                             if (!grepl(pattern, name)) 
[16:13:42.296]                               next
[16:13:42.296]                             invokeRestart(restart)
[16:13:42.296]                             muffled <- TRUE
[16:13:42.296]                             break
[16:13:42.296]                           }
[16:13:42.296]                         }
[16:13:42.296]                       }
[16:13:42.296]                       invisible(muffled)
[16:13:42.296]                     }
[16:13:42.296]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.296]                   }
[16:13:42.296]                 }
[16:13:42.296]             }
[16:13:42.296]         }))
[16:13:42.296]     }, error = function(ex) {
[16:13:42.296]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:42.296]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.296]                 ...future.rng), started = ...future.startTime, 
[16:13:42.296]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:42.296]             version = "1.8"), class = "FutureResult")
[16:13:42.296]     }, finally = {
[16:13:42.296]         if (!identical(...future.workdir, getwd())) 
[16:13:42.296]             setwd(...future.workdir)
[16:13:42.296]         {
[16:13:42.296]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:42.296]                 ...future.oldOptions$nwarnings <- NULL
[16:13:42.296]             }
[16:13:42.296]             base::options(...future.oldOptions)
[16:13:42.296]             if (.Platform$OS.type == "windows") {
[16:13:42.296]                 old_names <- names(...future.oldEnvVars)
[16:13:42.296]                 envs <- base::Sys.getenv()
[16:13:42.296]                 names <- names(envs)
[16:13:42.296]                 common <- intersect(names, old_names)
[16:13:42.296]                 added <- setdiff(names, old_names)
[16:13:42.296]                 removed <- setdiff(old_names, names)
[16:13:42.296]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:42.296]                   envs[common]]
[16:13:42.296]                 NAMES <- toupper(changed)
[16:13:42.296]                 args <- list()
[16:13:42.296]                 for (kk in seq_along(NAMES)) {
[16:13:42.296]                   name <- changed[[kk]]
[16:13:42.296]                   NAME <- NAMES[[kk]]
[16:13:42.296]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.296]                     next
[16:13:42.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.296]                 }
[16:13:42.296]                 NAMES <- toupper(added)
[16:13:42.296]                 for (kk in seq_along(NAMES)) {
[16:13:42.296]                   name <- added[[kk]]
[16:13:42.296]                   NAME <- NAMES[[kk]]
[16:13:42.296]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.296]                     next
[16:13:42.296]                   args[[name]] <- ""
[16:13:42.296]                 }
[16:13:42.296]                 NAMES <- toupper(removed)
[16:13:42.296]                 for (kk in seq_along(NAMES)) {
[16:13:42.296]                   name <- removed[[kk]]
[16:13:42.296]                   NAME <- NAMES[[kk]]
[16:13:42.296]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.296]                     next
[16:13:42.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.296]                 }
[16:13:42.296]                 if (length(args) > 0) 
[16:13:42.296]                   base::do.call(base::Sys.setenv, args = args)
[16:13:42.296]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:42.296]             }
[16:13:42.296]             else {
[16:13:42.296]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:42.296]             }
[16:13:42.296]             {
[16:13:42.296]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:42.296]                   0L) {
[16:13:42.296]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:42.296]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:42.296]                   base::options(opts)
[16:13:42.296]                 }
[16:13:42.296]                 {
[16:13:42.296]                   {
[16:13:42.296]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:42.296]                     NULL
[16:13:42.296]                   }
[16:13:42.296]                   options(future.plan = NULL)
[16:13:42.296]                   if (is.na(NA_character_)) 
[16:13:42.296]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.296]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:42.296]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:42.296]                     envir = parent.frame()) 
[16:13:42.296]                   {
[16:13:42.296]                     default_workers <- missing(workers)
[16:13:42.296]                     if (is.function(workers)) 
[16:13:42.296]                       workers <- workers()
[16:13:42.296]                     workers <- structure(as.integer(workers), 
[16:13:42.296]                       class = class(workers))
[16:13:42.296]                     stop_if_not(is.finite(workers), workers >= 
[16:13:42.296]                       1L)
[16:13:42.296]                     if ((workers == 1L && !inherits(workers, 
[16:13:42.296]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:42.296]                       if (default_workers) 
[16:13:42.296]                         supportsMulticore(warn = TRUE)
[16:13:42.296]                       return(sequential(..., envir = envir))
[16:13:42.296]                     }
[16:13:42.296]                     oopts <- options(mc.cores = workers)
[16:13:42.296]                     on.exit(options(oopts))
[16:13:42.296]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:42.296]                       envir = envir)
[16:13:42.296]                     if (!future$lazy) 
[16:13:42.296]                       future <- run(future)
[16:13:42.296]                     invisible(future)
[16:13:42.296]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:42.296]                 }
[16:13:42.296]             }
[16:13:42.296]         }
[16:13:42.296]     })
[16:13:42.296]     if (TRUE) {
[16:13:42.296]         base::sink(type = "output", split = FALSE)
[16:13:42.296]         if (TRUE) {
[16:13:42.296]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:42.296]         }
[16:13:42.296]         else {
[16:13:42.296]             ...future.result["stdout"] <- base::list(NULL)
[16:13:42.296]         }
[16:13:42.296]         base::close(...future.stdout)
[16:13:42.296]         ...future.stdout <- NULL
[16:13:42.296]     }
[16:13:42.296]     ...future.result$conditions <- ...future.conditions
[16:13:42.296]     ...future.result$finished <- base::Sys.time()
[16:13:42.296]     ...future.result
[16:13:42.296] }
[16:13:42.300] requestCore(): workers = 2
[16:13:42.302] MulticoreFuture started
[16:13:42.302] - Launch lazy future ... done
[16:13:42.303] run() for ‘MulticoreFuture’ ... done
[16:13:42.303] plan(): Setting new future strategy stack:
[16:13:42.304] resolve() on list environment ...
[16:13:42.304]  recursive: 0
[16:13:42.303] List of future strategies:
[16:13:42.303] 1. sequential:
[16:13:42.303]    - args: function (..., envir = parent.frame())
[16:13:42.303]    - tweaked: FALSE
[16:13:42.303]    - call: NULL
[16:13:42.304] plan(): nbrOfWorkers() = 1
[16:13:42.305]  length: 3
[16:13:42.305]  elements: ‘a’, ‘b’, ‘c’
[16:13:42.306] Future #1
[16:13:42.306]  length: 2 (resolved future 1)
[16:13:42.306] plan(): Setting new future strategy stack:
[16:13:42.307] List of future strategies:
[16:13:42.307] 1. multicore:
[16:13:42.307]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:42.307]    - tweaked: FALSE
[16:13:42.307]    - call: plan(strategy)
[16:13:42.312] plan(): nbrOfWorkers() = 2
[16:13:42.312] Future #2
[16:13:42.312]  length: 1 (resolved future 2)
[16:13:42.312]  length: 0 (resolved future 3)
[16:13:42.313] resolve() on list environment ... DONE
[16:13:42.314] getGlobalsAndPackages() ...
[16:13:42.314] Searching for globals...
[16:13:42.315] - globals found: [1] ‘{’
[16:13:42.315] Searching for globals ... DONE
[16:13:42.316] Resolving globals: FALSE
[16:13:42.320] 
[16:13:42.320] 
[16:13:42.321] getGlobalsAndPackages() ... DONE
[16:13:42.321] run() for ‘Future’ ...
[16:13:42.322] - state: ‘created’
[16:13:42.322] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:42.328] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:42.328] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:42.328]   - Field: ‘label’
[16:13:42.328]   - Field: ‘local’
[16:13:42.328]   - Field: ‘owner’
[16:13:42.329]   - Field: ‘envir’
[16:13:42.329]   - Field: ‘workers’
[16:13:42.329]   - Field: ‘packages’
[16:13:42.329]   - Field: ‘gc’
[16:13:42.329]   - Field: ‘job’
[16:13:42.329]   - Field: ‘conditions’
[16:13:42.330]   - Field: ‘expr’
[16:13:42.330]   - Field: ‘uuid’
[16:13:42.330]   - Field: ‘seed’
[16:13:42.330]   - Field: ‘version’
[16:13:42.330]   - Field: ‘result’
[16:13:42.330]   - Field: ‘asynchronous’
[16:13:42.330]   - Field: ‘calls’
[16:13:42.331]   - Field: ‘globals’
[16:13:42.331]   - Field: ‘stdout’
[16:13:42.331]   - Field: ‘earlySignal’
[16:13:42.331]   - Field: ‘lazy’
[16:13:42.331]   - Field: ‘state’
[16:13:42.331] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:42.332] - Launch lazy future ...
[16:13:42.332] Packages needed by the future expression (n = 0): <none>
[16:13:42.333] Packages needed by future strategies (n = 0): <none>
[16:13:42.333] {
[16:13:42.333]     {
[16:13:42.333]         {
[16:13:42.333]             ...future.startTime <- base::Sys.time()
[16:13:42.333]             {
[16:13:42.333]                 {
[16:13:42.333]                   {
[16:13:42.333]                     {
[16:13:42.333]                       base::local({
[16:13:42.333]                         has_future <- base::requireNamespace("future", 
[16:13:42.333]                           quietly = TRUE)
[16:13:42.333]                         if (has_future) {
[16:13:42.333]                           ns <- base::getNamespace("future")
[16:13:42.333]                           version <- ns[[".package"]][["version"]]
[16:13:42.333]                           if (is.null(version)) 
[16:13:42.333]                             version <- utils::packageVersion("future")
[16:13:42.333]                         }
[16:13:42.333]                         else {
[16:13:42.333]                           version <- NULL
[16:13:42.333]                         }
[16:13:42.333]                         if (!has_future || version < "1.8.0") {
[16:13:42.333]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:42.333]                             "", base::R.version$version.string), 
[16:13:42.333]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:42.333]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:42.333]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:42.333]                               "release", "version")], collapse = " "), 
[16:13:42.333]                             hostname = base::Sys.info()[["nodename"]])
[16:13:42.333]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:42.333]                             info)
[16:13:42.333]                           info <- base::paste(info, collapse = "; ")
[16:13:42.333]                           if (!has_future) {
[16:13:42.333]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:42.333]                               info)
[16:13:42.333]                           }
[16:13:42.333]                           else {
[16:13:42.333]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:42.333]                               info, version)
[16:13:42.333]                           }
[16:13:42.333]                           base::stop(msg)
[16:13:42.333]                         }
[16:13:42.333]                       })
[16:13:42.333]                     }
[16:13:42.333]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:42.333]                     base::options(mc.cores = 1L)
[16:13:42.333]                   }
[16:13:42.333]                   options(future.plan = NULL)
[16:13:42.333]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.333]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:42.333]                 }
[16:13:42.333]                 ...future.workdir <- getwd()
[16:13:42.333]             }
[16:13:42.333]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:42.333]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:42.333]         }
[16:13:42.333]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:42.333]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:42.333]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:42.333]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:42.333]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:42.333]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:42.333]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:42.333]             base::names(...future.oldOptions))
[16:13:42.333]     }
[16:13:42.333]     if (FALSE) {
[16:13:42.333]     }
[16:13:42.333]     else {
[16:13:42.333]         if (TRUE) {
[16:13:42.333]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:42.333]                 open = "w")
[16:13:42.333]         }
[16:13:42.333]         else {
[16:13:42.333]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:42.333]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:42.333]         }
[16:13:42.333]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:42.333]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:42.333]             base::sink(type = "output", split = FALSE)
[16:13:42.333]             base::close(...future.stdout)
[16:13:42.333]         }, add = TRUE)
[16:13:42.333]     }
[16:13:42.333]     ...future.frame <- base::sys.nframe()
[16:13:42.333]     ...future.conditions <- base::list()
[16:13:42.333]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:42.333]     if (FALSE) {
[16:13:42.333]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:42.333]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:42.333]     }
[16:13:42.333]     ...future.result <- base::tryCatch({
[16:13:42.333]         base::withCallingHandlers({
[16:13:42.333]             ...future.value <- base::withVisible(base::local({
[16:13:42.333]                 withCallingHandlers({
[16:13:42.333]                   {
[16:13:42.333]                     1
[16:13:42.333]                   }
[16:13:42.333]                 }, immediateCondition = function(cond) {
[16:13:42.333]                   save_rds <- function (object, pathname, ...) 
[16:13:42.333]                   {
[16:13:42.333]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:42.333]                     if (file_test("-f", pathname_tmp)) {
[16:13:42.333]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.333]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:42.333]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.333]                         fi_tmp[["mtime"]])
[16:13:42.333]                     }
[16:13:42.333]                     tryCatch({
[16:13:42.333]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:42.333]                     }, error = function(ex) {
[16:13:42.333]                       msg <- conditionMessage(ex)
[16:13:42.333]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.333]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:42.333]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.333]                         fi_tmp[["mtime"]], msg)
[16:13:42.333]                       ex$message <- msg
[16:13:42.333]                       stop(ex)
[16:13:42.333]                     })
[16:13:42.333]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:42.333]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:42.333]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:42.333]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.333]                       fi <- file.info(pathname)
[16:13:42.333]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:42.333]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.333]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:42.333]                         fi[["size"]], fi[["mtime"]])
[16:13:42.333]                       stop(msg)
[16:13:42.333]                     }
[16:13:42.333]                     invisible(pathname)
[16:13:42.333]                   }
[16:13:42.333]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:42.333]                     rootPath = tempdir()) 
[16:13:42.333]                   {
[16:13:42.333]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:42.333]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:42.333]                       tmpdir = path, fileext = ".rds")
[16:13:42.333]                     save_rds(obj, file)
[16:13:42.333]                   }
[16:13:42.333]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:42.333]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.333]                   {
[16:13:42.333]                     inherits <- base::inherits
[16:13:42.333]                     invokeRestart <- base::invokeRestart
[16:13:42.333]                     is.null <- base::is.null
[16:13:42.333]                     muffled <- FALSE
[16:13:42.333]                     if (inherits(cond, "message")) {
[16:13:42.333]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:42.333]                       if (muffled) 
[16:13:42.333]                         invokeRestart("muffleMessage")
[16:13:42.333]                     }
[16:13:42.333]                     else if (inherits(cond, "warning")) {
[16:13:42.333]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:42.333]                       if (muffled) 
[16:13:42.333]                         invokeRestart("muffleWarning")
[16:13:42.333]                     }
[16:13:42.333]                     else if (inherits(cond, "condition")) {
[16:13:42.333]                       if (!is.null(pattern)) {
[16:13:42.333]                         computeRestarts <- base::computeRestarts
[16:13:42.333]                         grepl <- base::grepl
[16:13:42.333]                         restarts <- computeRestarts(cond)
[16:13:42.333]                         for (restart in restarts) {
[16:13:42.333]                           name <- restart$name
[16:13:42.333]                           if (is.null(name)) 
[16:13:42.333]                             next
[16:13:42.333]                           if (!grepl(pattern, name)) 
[16:13:42.333]                             next
[16:13:42.333]                           invokeRestart(restart)
[16:13:42.333]                           muffled <- TRUE
[16:13:42.333]                           break
[16:13:42.333]                         }
[16:13:42.333]                       }
[16:13:42.333]                     }
[16:13:42.333]                     invisible(muffled)
[16:13:42.333]                   }
[16:13:42.333]                   muffleCondition(cond)
[16:13:42.333]                 })
[16:13:42.333]             }))
[16:13:42.333]             future::FutureResult(value = ...future.value$value, 
[16:13:42.333]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.333]                   ...future.rng), globalenv = if (FALSE) 
[16:13:42.333]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:42.333]                     ...future.globalenv.names))
[16:13:42.333]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:42.333]         }, condition = base::local({
[16:13:42.333]             c <- base::c
[16:13:42.333]             inherits <- base::inherits
[16:13:42.333]             invokeRestart <- base::invokeRestart
[16:13:42.333]             length <- base::length
[16:13:42.333]             list <- base::list
[16:13:42.333]             seq.int <- base::seq.int
[16:13:42.333]             signalCondition <- base::signalCondition
[16:13:42.333]             sys.calls <- base::sys.calls
[16:13:42.333]             `[[` <- base::`[[`
[16:13:42.333]             `+` <- base::`+`
[16:13:42.333]             `<<-` <- base::`<<-`
[16:13:42.333]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:42.333]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:42.333]                   3L)]
[16:13:42.333]             }
[16:13:42.333]             function(cond) {
[16:13:42.333]                 is_error <- inherits(cond, "error")
[16:13:42.333]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:42.333]                   NULL)
[16:13:42.333]                 if (is_error) {
[16:13:42.333]                   sessionInformation <- function() {
[16:13:42.333]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:42.333]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:42.333]                       search = base::search(), system = base::Sys.info())
[16:13:42.333]                   }
[16:13:42.333]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.333]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:42.333]                     cond$call), session = sessionInformation(), 
[16:13:42.333]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:42.333]                   signalCondition(cond)
[16:13:42.333]                 }
[16:13:42.333]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:42.333]                 "immediateCondition"))) {
[16:13:42.333]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:42.333]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.333]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:42.333]                   if (TRUE && !signal) {
[16:13:42.333]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.333]                     {
[16:13:42.333]                       inherits <- base::inherits
[16:13:42.333]                       invokeRestart <- base::invokeRestart
[16:13:42.333]                       is.null <- base::is.null
[16:13:42.333]                       muffled <- FALSE
[16:13:42.333]                       if (inherits(cond, "message")) {
[16:13:42.333]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.333]                         if (muffled) 
[16:13:42.333]                           invokeRestart("muffleMessage")
[16:13:42.333]                       }
[16:13:42.333]                       else if (inherits(cond, "warning")) {
[16:13:42.333]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.333]                         if (muffled) 
[16:13:42.333]                           invokeRestart("muffleWarning")
[16:13:42.333]                       }
[16:13:42.333]                       else if (inherits(cond, "condition")) {
[16:13:42.333]                         if (!is.null(pattern)) {
[16:13:42.333]                           computeRestarts <- base::computeRestarts
[16:13:42.333]                           grepl <- base::grepl
[16:13:42.333]                           restarts <- computeRestarts(cond)
[16:13:42.333]                           for (restart in restarts) {
[16:13:42.333]                             name <- restart$name
[16:13:42.333]                             if (is.null(name)) 
[16:13:42.333]                               next
[16:13:42.333]                             if (!grepl(pattern, name)) 
[16:13:42.333]                               next
[16:13:42.333]                             invokeRestart(restart)
[16:13:42.333]                             muffled <- TRUE
[16:13:42.333]                             break
[16:13:42.333]                           }
[16:13:42.333]                         }
[16:13:42.333]                       }
[16:13:42.333]                       invisible(muffled)
[16:13:42.333]                     }
[16:13:42.333]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.333]                   }
[16:13:42.333]                 }
[16:13:42.333]                 else {
[16:13:42.333]                   if (TRUE) {
[16:13:42.333]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.333]                     {
[16:13:42.333]                       inherits <- base::inherits
[16:13:42.333]                       invokeRestart <- base::invokeRestart
[16:13:42.333]                       is.null <- base::is.null
[16:13:42.333]                       muffled <- FALSE
[16:13:42.333]                       if (inherits(cond, "message")) {
[16:13:42.333]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.333]                         if (muffled) 
[16:13:42.333]                           invokeRestart("muffleMessage")
[16:13:42.333]                       }
[16:13:42.333]                       else if (inherits(cond, "warning")) {
[16:13:42.333]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.333]                         if (muffled) 
[16:13:42.333]                           invokeRestart("muffleWarning")
[16:13:42.333]                       }
[16:13:42.333]                       else if (inherits(cond, "condition")) {
[16:13:42.333]                         if (!is.null(pattern)) {
[16:13:42.333]                           computeRestarts <- base::computeRestarts
[16:13:42.333]                           grepl <- base::grepl
[16:13:42.333]                           restarts <- computeRestarts(cond)
[16:13:42.333]                           for (restart in restarts) {
[16:13:42.333]                             name <- restart$name
[16:13:42.333]                             if (is.null(name)) 
[16:13:42.333]                               next
[16:13:42.333]                             if (!grepl(pattern, name)) 
[16:13:42.333]                               next
[16:13:42.333]                             invokeRestart(restart)
[16:13:42.333]                             muffled <- TRUE
[16:13:42.333]                             break
[16:13:42.333]                           }
[16:13:42.333]                         }
[16:13:42.333]                       }
[16:13:42.333]                       invisible(muffled)
[16:13:42.333]                     }
[16:13:42.333]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.333]                   }
[16:13:42.333]                 }
[16:13:42.333]             }
[16:13:42.333]         }))
[16:13:42.333]     }, error = function(ex) {
[16:13:42.333]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:42.333]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.333]                 ...future.rng), started = ...future.startTime, 
[16:13:42.333]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:42.333]             version = "1.8"), class = "FutureResult")
[16:13:42.333]     }, finally = {
[16:13:42.333]         if (!identical(...future.workdir, getwd())) 
[16:13:42.333]             setwd(...future.workdir)
[16:13:42.333]         {
[16:13:42.333]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:42.333]                 ...future.oldOptions$nwarnings <- NULL
[16:13:42.333]             }
[16:13:42.333]             base::options(...future.oldOptions)
[16:13:42.333]             if (.Platform$OS.type == "windows") {
[16:13:42.333]                 old_names <- names(...future.oldEnvVars)
[16:13:42.333]                 envs <- base::Sys.getenv()
[16:13:42.333]                 names <- names(envs)
[16:13:42.333]                 common <- intersect(names, old_names)
[16:13:42.333]                 added <- setdiff(names, old_names)
[16:13:42.333]                 removed <- setdiff(old_names, names)
[16:13:42.333]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:42.333]                   envs[common]]
[16:13:42.333]                 NAMES <- toupper(changed)
[16:13:42.333]                 args <- list()
[16:13:42.333]                 for (kk in seq_along(NAMES)) {
[16:13:42.333]                   name <- changed[[kk]]
[16:13:42.333]                   NAME <- NAMES[[kk]]
[16:13:42.333]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.333]                     next
[16:13:42.333]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.333]                 }
[16:13:42.333]                 NAMES <- toupper(added)
[16:13:42.333]                 for (kk in seq_along(NAMES)) {
[16:13:42.333]                   name <- added[[kk]]
[16:13:42.333]                   NAME <- NAMES[[kk]]
[16:13:42.333]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.333]                     next
[16:13:42.333]                   args[[name]] <- ""
[16:13:42.333]                 }
[16:13:42.333]                 NAMES <- toupper(removed)
[16:13:42.333]                 for (kk in seq_along(NAMES)) {
[16:13:42.333]                   name <- removed[[kk]]
[16:13:42.333]                   NAME <- NAMES[[kk]]
[16:13:42.333]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.333]                     next
[16:13:42.333]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.333]                 }
[16:13:42.333]                 if (length(args) > 0) 
[16:13:42.333]                   base::do.call(base::Sys.setenv, args = args)
[16:13:42.333]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:42.333]             }
[16:13:42.333]             else {
[16:13:42.333]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:42.333]             }
[16:13:42.333]             {
[16:13:42.333]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:42.333]                   0L) {
[16:13:42.333]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:42.333]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:42.333]                   base::options(opts)
[16:13:42.333]                 }
[16:13:42.333]                 {
[16:13:42.333]                   {
[16:13:42.333]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:42.333]                     NULL
[16:13:42.333]                   }
[16:13:42.333]                   options(future.plan = NULL)
[16:13:42.333]                   if (is.na(NA_character_)) 
[16:13:42.333]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.333]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:42.333]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:42.333]                     envir = parent.frame()) 
[16:13:42.333]                   {
[16:13:42.333]                     default_workers <- missing(workers)
[16:13:42.333]                     if (is.function(workers)) 
[16:13:42.333]                       workers <- workers()
[16:13:42.333]                     workers <- structure(as.integer(workers), 
[16:13:42.333]                       class = class(workers))
[16:13:42.333]                     stop_if_not(is.finite(workers), workers >= 
[16:13:42.333]                       1L)
[16:13:42.333]                     if ((workers == 1L && !inherits(workers, 
[16:13:42.333]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:42.333]                       if (default_workers) 
[16:13:42.333]                         supportsMulticore(warn = TRUE)
[16:13:42.333]                       return(sequential(..., envir = envir))
[16:13:42.333]                     }
[16:13:42.333]                     oopts <- options(mc.cores = workers)
[16:13:42.333]                     on.exit(options(oopts))
[16:13:42.333]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:42.333]                       envir = envir)
[16:13:42.333]                     if (!future$lazy) 
[16:13:42.333]                       future <- run(future)
[16:13:42.333]                     invisible(future)
[16:13:42.333]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:42.333]                 }
[16:13:42.333]             }
[16:13:42.333]         }
[16:13:42.333]     })
[16:13:42.333]     if (TRUE) {
[16:13:42.333]         base::sink(type = "output", split = FALSE)
[16:13:42.333]         if (TRUE) {
[16:13:42.333]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:42.333]         }
[16:13:42.333]         else {
[16:13:42.333]             ...future.result["stdout"] <- base::list(NULL)
[16:13:42.333]         }
[16:13:42.333]         base::close(...future.stdout)
[16:13:42.333]         ...future.stdout <- NULL
[16:13:42.333]     }
[16:13:42.333]     ...future.result$conditions <- ...future.conditions
[16:13:42.333]     ...future.result$finished <- base::Sys.time()
[16:13:42.333]     ...future.result
[16:13:42.333] }
[16:13:42.336] requestCore(): workers = 2
[16:13:42.336] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:42.350] MulticoreFuture started
[16:13:42.351] - Launch lazy future ... done
[16:13:42.351] run() for ‘MulticoreFuture’ ... done
[16:13:42.351] plan(): Setting new future strategy stack:
[16:13:42.352] getGlobalsAndPackages() ...
[16:13:42.352] List of future strategies:
[16:13:42.352] 1. sequential:
[16:13:42.352]    - args: function (..., envir = parent.frame())
[16:13:42.352]    - tweaked: FALSE
[16:13:42.352]    - call: NULL
[16:13:42.353] Searching for globals...
[16:13:42.353] plan(): nbrOfWorkers() = 1
[16:13:42.355] - globals found: [1] ‘{’
[16:13:42.355] Searching for globals ... DONE
[16:13:42.355] Resolving globals: FALSE
[16:13:42.356] plan(): Setting new future strategy stack:
[16:13:42.356] 
[16:13:42.356] 
[16:13:42.357] getGlobalsAndPackages() ... DONE
[16:13:42.356] List of future strategies:
[16:13:42.356] 1. multicore:
[16:13:42.356]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:42.356]    - tweaked: FALSE
[16:13:42.356]    - call: plan(strategy)
[16:13:42.357] run() for ‘Future’ ...
[16:13:42.357] - state: ‘created’
[16:13:42.358] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:42.363] plan(): nbrOfWorkers() = 2
[16:13:42.363] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:42.363] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:42.364]   - Field: ‘label’
[16:13:42.364]   - Field: ‘local’
[16:13:42.364]   - Field: ‘owner’
[16:13:42.364]   - Field: ‘envir’
[16:13:42.364]   - Field: ‘workers’
[16:13:42.365]   - Field: ‘packages’
[16:13:42.365]   - Field: ‘gc’
[16:13:42.365]   - Field: ‘job’
[16:13:42.365]   - Field: ‘conditions’
[16:13:42.365]   - Field: ‘expr’
[16:13:42.365]   - Field: ‘uuid’
[16:13:42.365]   - Field: ‘seed’
[16:13:42.366]   - Field: ‘version’
[16:13:42.366]   - Field: ‘result’
[16:13:42.366]   - Field: ‘asynchronous’
[16:13:42.366]   - Field: ‘calls’
[16:13:42.366]   - Field: ‘globals’
[16:13:42.366]   - Field: ‘stdout’
[16:13:42.366]   - Field: ‘earlySignal’
[16:13:42.367]   - Field: ‘lazy’
[16:13:42.367]   - Field: ‘state’
[16:13:42.367] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:42.367] - Launch lazy future ...
[16:13:42.368] Packages needed by the future expression (n = 0): <none>
[16:13:42.368] Packages needed by future strategies (n = 0): <none>
[16:13:42.368] {
[16:13:42.368]     {
[16:13:42.368]         {
[16:13:42.368]             ...future.startTime <- base::Sys.time()
[16:13:42.368]             {
[16:13:42.368]                 {
[16:13:42.368]                   {
[16:13:42.368]                     {
[16:13:42.368]                       base::local({
[16:13:42.368]                         has_future <- base::requireNamespace("future", 
[16:13:42.368]                           quietly = TRUE)
[16:13:42.368]                         if (has_future) {
[16:13:42.368]                           ns <- base::getNamespace("future")
[16:13:42.368]                           version <- ns[[".package"]][["version"]]
[16:13:42.368]                           if (is.null(version)) 
[16:13:42.368]                             version <- utils::packageVersion("future")
[16:13:42.368]                         }
[16:13:42.368]                         else {
[16:13:42.368]                           version <- NULL
[16:13:42.368]                         }
[16:13:42.368]                         if (!has_future || version < "1.8.0") {
[16:13:42.368]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:42.368]                             "", base::R.version$version.string), 
[16:13:42.368]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:42.368]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:42.368]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:42.368]                               "release", "version")], collapse = " "), 
[16:13:42.368]                             hostname = base::Sys.info()[["nodename"]])
[16:13:42.368]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:42.368]                             info)
[16:13:42.368]                           info <- base::paste(info, collapse = "; ")
[16:13:42.368]                           if (!has_future) {
[16:13:42.368]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:42.368]                               info)
[16:13:42.368]                           }
[16:13:42.368]                           else {
[16:13:42.368]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:42.368]                               info, version)
[16:13:42.368]                           }
[16:13:42.368]                           base::stop(msg)
[16:13:42.368]                         }
[16:13:42.368]                       })
[16:13:42.368]                     }
[16:13:42.368]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:42.368]                     base::options(mc.cores = 1L)
[16:13:42.368]                   }
[16:13:42.368]                   options(future.plan = NULL)
[16:13:42.368]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.368]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:42.368]                 }
[16:13:42.368]                 ...future.workdir <- getwd()
[16:13:42.368]             }
[16:13:42.368]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:42.368]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:42.368]         }
[16:13:42.368]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:42.368]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:42.368]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:42.368]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:42.368]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:42.368]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:42.368]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:42.368]             base::names(...future.oldOptions))
[16:13:42.368]     }
[16:13:42.368]     if (FALSE) {
[16:13:42.368]     }
[16:13:42.368]     else {
[16:13:42.368]         if (TRUE) {
[16:13:42.368]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:42.368]                 open = "w")
[16:13:42.368]         }
[16:13:42.368]         else {
[16:13:42.368]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:42.368]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:42.368]         }
[16:13:42.368]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:42.368]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:42.368]             base::sink(type = "output", split = FALSE)
[16:13:42.368]             base::close(...future.stdout)
[16:13:42.368]         }, add = TRUE)
[16:13:42.368]     }
[16:13:42.368]     ...future.frame <- base::sys.nframe()
[16:13:42.368]     ...future.conditions <- base::list()
[16:13:42.368]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:42.368]     if (FALSE) {
[16:13:42.368]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:42.368]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:42.368]     }
[16:13:42.368]     ...future.result <- base::tryCatch({
[16:13:42.368]         base::withCallingHandlers({
[16:13:42.368]             ...future.value <- base::withVisible(base::local({
[16:13:42.368]                 withCallingHandlers({
[16:13:42.368]                   {
[16:13:42.368]                     2
[16:13:42.368]                   }
[16:13:42.368]                 }, immediateCondition = function(cond) {
[16:13:42.368]                   save_rds <- function (object, pathname, ...) 
[16:13:42.368]                   {
[16:13:42.368]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:42.368]                     if (file_test("-f", pathname_tmp)) {
[16:13:42.368]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.368]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:42.368]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.368]                         fi_tmp[["mtime"]])
[16:13:42.368]                     }
[16:13:42.368]                     tryCatch({
[16:13:42.368]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:42.368]                     }, error = function(ex) {
[16:13:42.368]                       msg <- conditionMessage(ex)
[16:13:42.368]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.368]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:42.368]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.368]                         fi_tmp[["mtime"]], msg)
[16:13:42.368]                       ex$message <- msg
[16:13:42.368]                       stop(ex)
[16:13:42.368]                     })
[16:13:42.368]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:42.368]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:42.368]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:42.368]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.368]                       fi <- file.info(pathname)
[16:13:42.368]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:42.368]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.368]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:42.368]                         fi[["size"]], fi[["mtime"]])
[16:13:42.368]                       stop(msg)
[16:13:42.368]                     }
[16:13:42.368]                     invisible(pathname)
[16:13:42.368]                   }
[16:13:42.368]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:42.368]                     rootPath = tempdir()) 
[16:13:42.368]                   {
[16:13:42.368]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:42.368]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:42.368]                       tmpdir = path, fileext = ".rds")
[16:13:42.368]                     save_rds(obj, file)
[16:13:42.368]                   }
[16:13:42.368]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:42.368]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.368]                   {
[16:13:42.368]                     inherits <- base::inherits
[16:13:42.368]                     invokeRestart <- base::invokeRestart
[16:13:42.368]                     is.null <- base::is.null
[16:13:42.368]                     muffled <- FALSE
[16:13:42.368]                     if (inherits(cond, "message")) {
[16:13:42.368]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:42.368]                       if (muffled) 
[16:13:42.368]                         invokeRestart("muffleMessage")
[16:13:42.368]                     }
[16:13:42.368]                     else if (inherits(cond, "warning")) {
[16:13:42.368]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:42.368]                       if (muffled) 
[16:13:42.368]                         invokeRestart("muffleWarning")
[16:13:42.368]                     }
[16:13:42.368]                     else if (inherits(cond, "condition")) {
[16:13:42.368]                       if (!is.null(pattern)) {
[16:13:42.368]                         computeRestarts <- base::computeRestarts
[16:13:42.368]                         grepl <- base::grepl
[16:13:42.368]                         restarts <- computeRestarts(cond)
[16:13:42.368]                         for (restart in restarts) {
[16:13:42.368]                           name <- restart$name
[16:13:42.368]                           if (is.null(name)) 
[16:13:42.368]                             next
[16:13:42.368]                           if (!grepl(pattern, name)) 
[16:13:42.368]                             next
[16:13:42.368]                           invokeRestart(restart)
[16:13:42.368]                           muffled <- TRUE
[16:13:42.368]                           break
[16:13:42.368]                         }
[16:13:42.368]                       }
[16:13:42.368]                     }
[16:13:42.368]                     invisible(muffled)
[16:13:42.368]                   }
[16:13:42.368]                   muffleCondition(cond)
[16:13:42.368]                 })
[16:13:42.368]             }))
[16:13:42.368]             future::FutureResult(value = ...future.value$value, 
[16:13:42.368]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.368]                   ...future.rng), globalenv = if (FALSE) 
[16:13:42.368]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:42.368]                     ...future.globalenv.names))
[16:13:42.368]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:42.368]         }, condition = base::local({
[16:13:42.368]             c <- base::c
[16:13:42.368]             inherits <- base::inherits
[16:13:42.368]             invokeRestart <- base::invokeRestart
[16:13:42.368]             length <- base::length
[16:13:42.368]             list <- base::list
[16:13:42.368]             seq.int <- base::seq.int
[16:13:42.368]             signalCondition <- base::signalCondition
[16:13:42.368]             sys.calls <- base::sys.calls
[16:13:42.368]             `[[` <- base::`[[`
[16:13:42.368]             `+` <- base::`+`
[16:13:42.368]             `<<-` <- base::`<<-`
[16:13:42.368]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:42.368]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:42.368]                   3L)]
[16:13:42.368]             }
[16:13:42.368]             function(cond) {
[16:13:42.368]                 is_error <- inherits(cond, "error")
[16:13:42.368]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:42.368]                   NULL)
[16:13:42.368]                 if (is_error) {
[16:13:42.368]                   sessionInformation <- function() {
[16:13:42.368]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:42.368]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:42.368]                       search = base::search(), system = base::Sys.info())
[16:13:42.368]                   }
[16:13:42.368]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.368]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:42.368]                     cond$call), session = sessionInformation(), 
[16:13:42.368]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:42.368]                   signalCondition(cond)
[16:13:42.368]                 }
[16:13:42.368]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:42.368]                 "immediateCondition"))) {
[16:13:42.368]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:42.368]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.368]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:42.368]                   if (TRUE && !signal) {
[16:13:42.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.368]                     {
[16:13:42.368]                       inherits <- base::inherits
[16:13:42.368]                       invokeRestart <- base::invokeRestart
[16:13:42.368]                       is.null <- base::is.null
[16:13:42.368]                       muffled <- FALSE
[16:13:42.368]                       if (inherits(cond, "message")) {
[16:13:42.368]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.368]                         if (muffled) 
[16:13:42.368]                           invokeRestart("muffleMessage")
[16:13:42.368]                       }
[16:13:42.368]                       else if (inherits(cond, "warning")) {
[16:13:42.368]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.368]                         if (muffled) 
[16:13:42.368]                           invokeRestart("muffleWarning")
[16:13:42.368]                       }
[16:13:42.368]                       else if (inherits(cond, "condition")) {
[16:13:42.368]                         if (!is.null(pattern)) {
[16:13:42.368]                           computeRestarts <- base::computeRestarts
[16:13:42.368]                           grepl <- base::grepl
[16:13:42.368]                           restarts <- computeRestarts(cond)
[16:13:42.368]                           for (restart in restarts) {
[16:13:42.368]                             name <- restart$name
[16:13:42.368]                             if (is.null(name)) 
[16:13:42.368]                               next
[16:13:42.368]                             if (!grepl(pattern, name)) 
[16:13:42.368]                               next
[16:13:42.368]                             invokeRestart(restart)
[16:13:42.368]                             muffled <- TRUE
[16:13:42.368]                             break
[16:13:42.368]                           }
[16:13:42.368]                         }
[16:13:42.368]                       }
[16:13:42.368]                       invisible(muffled)
[16:13:42.368]                     }
[16:13:42.368]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.368]                   }
[16:13:42.368]                 }
[16:13:42.368]                 else {
[16:13:42.368]                   if (TRUE) {
[16:13:42.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.368]                     {
[16:13:42.368]                       inherits <- base::inherits
[16:13:42.368]                       invokeRestart <- base::invokeRestart
[16:13:42.368]                       is.null <- base::is.null
[16:13:42.368]                       muffled <- FALSE
[16:13:42.368]                       if (inherits(cond, "message")) {
[16:13:42.368]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.368]                         if (muffled) 
[16:13:42.368]                           invokeRestart("muffleMessage")
[16:13:42.368]                       }
[16:13:42.368]                       else if (inherits(cond, "warning")) {
[16:13:42.368]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.368]                         if (muffled) 
[16:13:42.368]                           invokeRestart("muffleWarning")
[16:13:42.368]                       }
[16:13:42.368]                       else if (inherits(cond, "condition")) {
[16:13:42.368]                         if (!is.null(pattern)) {
[16:13:42.368]                           computeRestarts <- base::computeRestarts
[16:13:42.368]                           grepl <- base::grepl
[16:13:42.368]                           restarts <- computeRestarts(cond)
[16:13:42.368]                           for (restart in restarts) {
[16:13:42.368]                             name <- restart$name
[16:13:42.368]                             if (is.null(name)) 
[16:13:42.368]                               next
[16:13:42.368]                             if (!grepl(pattern, name)) 
[16:13:42.368]                               next
[16:13:42.368]                             invokeRestart(restart)
[16:13:42.368]                             muffled <- TRUE
[16:13:42.368]                             break
[16:13:42.368]                           }
[16:13:42.368]                         }
[16:13:42.368]                       }
[16:13:42.368]                       invisible(muffled)
[16:13:42.368]                     }
[16:13:42.368]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.368]                   }
[16:13:42.368]                 }
[16:13:42.368]             }
[16:13:42.368]         }))
[16:13:42.368]     }, error = function(ex) {
[16:13:42.368]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:42.368]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.368]                 ...future.rng), started = ...future.startTime, 
[16:13:42.368]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:42.368]             version = "1.8"), class = "FutureResult")
[16:13:42.368]     }, finally = {
[16:13:42.368]         if (!identical(...future.workdir, getwd())) 
[16:13:42.368]             setwd(...future.workdir)
[16:13:42.368]         {
[16:13:42.368]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:42.368]                 ...future.oldOptions$nwarnings <- NULL
[16:13:42.368]             }
[16:13:42.368]             base::options(...future.oldOptions)
[16:13:42.368]             if (.Platform$OS.type == "windows") {
[16:13:42.368]                 old_names <- names(...future.oldEnvVars)
[16:13:42.368]                 envs <- base::Sys.getenv()
[16:13:42.368]                 names <- names(envs)
[16:13:42.368]                 common <- intersect(names, old_names)
[16:13:42.368]                 added <- setdiff(names, old_names)
[16:13:42.368]                 removed <- setdiff(old_names, names)
[16:13:42.368]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:42.368]                   envs[common]]
[16:13:42.368]                 NAMES <- toupper(changed)
[16:13:42.368]                 args <- list()
[16:13:42.368]                 for (kk in seq_along(NAMES)) {
[16:13:42.368]                   name <- changed[[kk]]
[16:13:42.368]                   NAME <- NAMES[[kk]]
[16:13:42.368]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.368]                     next
[16:13:42.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.368]                 }
[16:13:42.368]                 NAMES <- toupper(added)
[16:13:42.368]                 for (kk in seq_along(NAMES)) {
[16:13:42.368]                   name <- added[[kk]]
[16:13:42.368]                   NAME <- NAMES[[kk]]
[16:13:42.368]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.368]                     next
[16:13:42.368]                   args[[name]] <- ""
[16:13:42.368]                 }
[16:13:42.368]                 NAMES <- toupper(removed)
[16:13:42.368]                 for (kk in seq_along(NAMES)) {
[16:13:42.368]                   name <- removed[[kk]]
[16:13:42.368]                   NAME <- NAMES[[kk]]
[16:13:42.368]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.368]                     next
[16:13:42.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.368]                 }
[16:13:42.368]                 if (length(args) > 0) 
[16:13:42.368]                   base::do.call(base::Sys.setenv, args = args)
[16:13:42.368]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:42.368]             }
[16:13:42.368]             else {
[16:13:42.368]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:42.368]             }
[16:13:42.368]             {
[16:13:42.368]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:42.368]                   0L) {
[16:13:42.368]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:42.368]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:42.368]                   base::options(opts)
[16:13:42.368]                 }
[16:13:42.368]                 {
[16:13:42.368]                   {
[16:13:42.368]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:42.368]                     NULL
[16:13:42.368]                   }
[16:13:42.368]                   options(future.plan = NULL)
[16:13:42.368]                   if (is.na(NA_character_)) 
[16:13:42.368]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.368]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:42.368]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:42.368]                     envir = parent.frame()) 
[16:13:42.368]                   {
[16:13:42.368]                     default_workers <- missing(workers)
[16:13:42.368]                     if (is.function(workers)) 
[16:13:42.368]                       workers <- workers()
[16:13:42.368]                     workers <- structure(as.integer(workers), 
[16:13:42.368]                       class = class(workers))
[16:13:42.368]                     stop_if_not(is.finite(workers), workers >= 
[16:13:42.368]                       1L)
[16:13:42.368]                     if ((workers == 1L && !inherits(workers, 
[16:13:42.368]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:42.368]                       if (default_workers) 
[16:13:42.368]                         supportsMulticore(warn = TRUE)
[16:13:42.368]                       return(sequential(..., envir = envir))
[16:13:42.368]                     }
[16:13:42.368]                     oopts <- options(mc.cores = workers)
[16:13:42.368]                     on.exit(options(oopts))
[16:13:42.368]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:42.368]                       envir = envir)
[16:13:42.368]                     if (!future$lazy) 
[16:13:42.368]                       future <- run(future)
[16:13:42.368]                     invisible(future)
[16:13:42.368]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:42.368]                 }
[16:13:42.368]             }
[16:13:42.368]         }
[16:13:42.368]     })
[16:13:42.368]     if (TRUE) {
[16:13:42.368]         base::sink(type = "output", split = FALSE)
[16:13:42.368]         if (TRUE) {
[16:13:42.368]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:42.368]         }
[16:13:42.368]         else {
[16:13:42.368]             ...future.result["stdout"] <- base::list(NULL)
[16:13:42.368]         }
[16:13:42.368]         base::close(...future.stdout)
[16:13:42.368]         ...future.stdout <- NULL
[16:13:42.368]     }
[16:13:42.368]     ...future.result$conditions <- ...future.conditions
[16:13:42.368]     ...future.result$finished <- base::Sys.time()
[16:13:42.368]     ...future.result
[16:13:42.368] }
[16:13:42.372] requestCore(): workers = 2
[16:13:42.372] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:42.386] MulticoreFuture started
[16:13:42.386] - Launch lazy future ... done
[16:13:42.387] run() for ‘MulticoreFuture’ ... done
[16:13:42.387] plan(): Setting new future strategy stack:
[16:13:42.388] List of future strategies:
[16:13:42.388] 1. sequential:
[16:13:42.388]    - args: function (..., envir = parent.frame())
[16:13:42.388]    - tweaked: FALSE
[16:13:42.388]    - call: NULL
[16:13:42.389] resolve() on list environment ...
[16:13:42.389]  recursive: 0
[16:13:42.389] plan(): nbrOfWorkers() = 1
[16:13:42.390]  length: 3
[16:13:42.390]  elements: ‘a’, ‘b’, ‘c’
[16:13:42.391] Future #1
[16:13:42.391]  length: 2 (resolved future 1)
[16:13:42.392] plan(): Setting new future strategy stack:
[16:13:42.392] List of future strategies:
[16:13:42.392] 1. multicore:
[16:13:42.392]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:42.392]    - tweaked: FALSE
[16:13:42.392]    - call: plan(strategy)
[16:13:42.397] plan(): nbrOfWorkers() = 2
[16:13:42.397] Future #2
[16:13:42.398]  length: 1 (resolved future 2)
[16:13:42.398]  length: 0 (resolved future 3)
[16:13:42.398] resolve() on list environment ... DONE
[16:13:42.399] getGlobalsAndPackages() ...
[16:13:42.399] Searching for globals...
[16:13:42.400] - globals found: [1] ‘{’
[16:13:42.400] Searching for globals ... DONE
[16:13:42.401] Resolving globals: FALSE
[16:13:42.401] 
[16:13:42.401] 
[16:13:42.401] getGlobalsAndPackages() ... DONE
[16:13:42.402] run() for ‘Future’ ...
[16:13:42.402] - state: ‘created’
[16:13:42.402] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:42.407] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:42.407] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:42.407]   - Field: ‘label’
[16:13:42.407]   - Field: ‘local’
[16:13:42.407]   - Field: ‘owner’
[16:13:42.408]   - Field: ‘envir’
[16:13:42.408]   - Field: ‘workers’
[16:13:42.408]   - Field: ‘packages’
[16:13:42.408]   - Field: ‘gc’
[16:13:42.408]   - Field: ‘job’
[16:13:42.408]   - Field: ‘conditions’
[16:13:42.409]   - Field: ‘expr’
[16:13:42.409]   - Field: ‘uuid’
[16:13:42.413]   - Field: ‘seed’
[16:13:42.413]   - Field: ‘version’
[16:13:42.413]   - Field: ‘result’
[16:13:42.414]   - Field: ‘asynchronous’
[16:13:42.414]   - Field: ‘calls’
[16:13:42.414]   - Field: ‘globals’
[16:13:42.415]   - Field: ‘stdout’
[16:13:42.415]   - Field: ‘earlySignal’
[16:13:42.415]   - Field: ‘lazy’
[16:13:42.416]   - Field: ‘state’
[16:13:42.416] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:42.416] - Launch lazy future ...
[16:13:42.417] Packages needed by the future expression (n = 0): <none>
[16:13:42.417] Packages needed by future strategies (n = 0): <none>
[16:13:42.418] {
[16:13:42.418]     {
[16:13:42.418]         {
[16:13:42.418]             ...future.startTime <- base::Sys.time()
[16:13:42.418]             {
[16:13:42.418]                 {
[16:13:42.418]                   {
[16:13:42.418]                     {
[16:13:42.418]                       base::local({
[16:13:42.418]                         has_future <- base::requireNamespace("future", 
[16:13:42.418]                           quietly = TRUE)
[16:13:42.418]                         if (has_future) {
[16:13:42.418]                           ns <- base::getNamespace("future")
[16:13:42.418]                           version <- ns[[".package"]][["version"]]
[16:13:42.418]                           if (is.null(version)) 
[16:13:42.418]                             version <- utils::packageVersion("future")
[16:13:42.418]                         }
[16:13:42.418]                         else {
[16:13:42.418]                           version <- NULL
[16:13:42.418]                         }
[16:13:42.418]                         if (!has_future || version < "1.8.0") {
[16:13:42.418]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:42.418]                             "", base::R.version$version.string), 
[16:13:42.418]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:42.418]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:42.418]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:42.418]                               "release", "version")], collapse = " "), 
[16:13:42.418]                             hostname = base::Sys.info()[["nodename"]])
[16:13:42.418]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:42.418]                             info)
[16:13:42.418]                           info <- base::paste(info, collapse = "; ")
[16:13:42.418]                           if (!has_future) {
[16:13:42.418]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:42.418]                               info)
[16:13:42.418]                           }
[16:13:42.418]                           else {
[16:13:42.418]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:42.418]                               info, version)
[16:13:42.418]                           }
[16:13:42.418]                           base::stop(msg)
[16:13:42.418]                         }
[16:13:42.418]                       })
[16:13:42.418]                     }
[16:13:42.418]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:42.418]                     base::options(mc.cores = 1L)
[16:13:42.418]                   }
[16:13:42.418]                   options(future.plan = NULL)
[16:13:42.418]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.418]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:42.418]                 }
[16:13:42.418]                 ...future.workdir <- getwd()
[16:13:42.418]             }
[16:13:42.418]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:42.418]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:42.418]         }
[16:13:42.418]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:42.418]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:42.418]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:42.418]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:42.418]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:42.418]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:42.418]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:42.418]             base::names(...future.oldOptions))
[16:13:42.418]     }
[16:13:42.418]     if (FALSE) {
[16:13:42.418]     }
[16:13:42.418]     else {
[16:13:42.418]         if (TRUE) {
[16:13:42.418]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:42.418]                 open = "w")
[16:13:42.418]         }
[16:13:42.418]         else {
[16:13:42.418]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:42.418]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:42.418]         }
[16:13:42.418]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:42.418]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:42.418]             base::sink(type = "output", split = FALSE)
[16:13:42.418]             base::close(...future.stdout)
[16:13:42.418]         }, add = TRUE)
[16:13:42.418]     }
[16:13:42.418]     ...future.frame <- base::sys.nframe()
[16:13:42.418]     ...future.conditions <- base::list()
[16:13:42.418]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:42.418]     if (FALSE) {
[16:13:42.418]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:42.418]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:42.418]     }
[16:13:42.418]     ...future.result <- base::tryCatch({
[16:13:42.418]         base::withCallingHandlers({
[16:13:42.418]             ...future.value <- base::withVisible(base::local({
[16:13:42.418]                 withCallingHandlers({
[16:13:42.418]                   {
[16:13:42.418]                     1
[16:13:42.418]                   }
[16:13:42.418]                 }, immediateCondition = function(cond) {
[16:13:42.418]                   save_rds <- function (object, pathname, ...) 
[16:13:42.418]                   {
[16:13:42.418]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:42.418]                     if (file_test("-f", pathname_tmp)) {
[16:13:42.418]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.418]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:42.418]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.418]                         fi_tmp[["mtime"]])
[16:13:42.418]                     }
[16:13:42.418]                     tryCatch({
[16:13:42.418]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:42.418]                     }, error = function(ex) {
[16:13:42.418]                       msg <- conditionMessage(ex)
[16:13:42.418]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.418]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:42.418]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.418]                         fi_tmp[["mtime"]], msg)
[16:13:42.418]                       ex$message <- msg
[16:13:42.418]                       stop(ex)
[16:13:42.418]                     })
[16:13:42.418]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:42.418]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:42.418]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:42.418]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.418]                       fi <- file.info(pathname)
[16:13:42.418]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:42.418]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.418]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:42.418]                         fi[["size"]], fi[["mtime"]])
[16:13:42.418]                       stop(msg)
[16:13:42.418]                     }
[16:13:42.418]                     invisible(pathname)
[16:13:42.418]                   }
[16:13:42.418]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:42.418]                     rootPath = tempdir()) 
[16:13:42.418]                   {
[16:13:42.418]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:42.418]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:42.418]                       tmpdir = path, fileext = ".rds")
[16:13:42.418]                     save_rds(obj, file)
[16:13:42.418]                   }
[16:13:42.418]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:42.418]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.418]                   {
[16:13:42.418]                     inherits <- base::inherits
[16:13:42.418]                     invokeRestart <- base::invokeRestart
[16:13:42.418]                     is.null <- base::is.null
[16:13:42.418]                     muffled <- FALSE
[16:13:42.418]                     if (inherits(cond, "message")) {
[16:13:42.418]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:42.418]                       if (muffled) 
[16:13:42.418]                         invokeRestart("muffleMessage")
[16:13:42.418]                     }
[16:13:42.418]                     else if (inherits(cond, "warning")) {
[16:13:42.418]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:42.418]                       if (muffled) 
[16:13:42.418]                         invokeRestart("muffleWarning")
[16:13:42.418]                     }
[16:13:42.418]                     else if (inherits(cond, "condition")) {
[16:13:42.418]                       if (!is.null(pattern)) {
[16:13:42.418]                         computeRestarts <- base::computeRestarts
[16:13:42.418]                         grepl <- base::grepl
[16:13:42.418]                         restarts <- computeRestarts(cond)
[16:13:42.418]                         for (restart in restarts) {
[16:13:42.418]                           name <- restart$name
[16:13:42.418]                           if (is.null(name)) 
[16:13:42.418]                             next
[16:13:42.418]                           if (!grepl(pattern, name)) 
[16:13:42.418]                             next
[16:13:42.418]                           invokeRestart(restart)
[16:13:42.418]                           muffled <- TRUE
[16:13:42.418]                           break
[16:13:42.418]                         }
[16:13:42.418]                       }
[16:13:42.418]                     }
[16:13:42.418]                     invisible(muffled)
[16:13:42.418]                   }
[16:13:42.418]                   muffleCondition(cond)
[16:13:42.418]                 })
[16:13:42.418]             }))
[16:13:42.418]             future::FutureResult(value = ...future.value$value, 
[16:13:42.418]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.418]                   ...future.rng), globalenv = if (FALSE) 
[16:13:42.418]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:42.418]                     ...future.globalenv.names))
[16:13:42.418]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:42.418]         }, condition = base::local({
[16:13:42.418]             c <- base::c
[16:13:42.418]             inherits <- base::inherits
[16:13:42.418]             invokeRestart <- base::invokeRestart
[16:13:42.418]             length <- base::length
[16:13:42.418]             list <- base::list
[16:13:42.418]             seq.int <- base::seq.int
[16:13:42.418]             signalCondition <- base::signalCondition
[16:13:42.418]             sys.calls <- base::sys.calls
[16:13:42.418]             `[[` <- base::`[[`
[16:13:42.418]             `+` <- base::`+`
[16:13:42.418]             `<<-` <- base::`<<-`
[16:13:42.418]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:42.418]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:42.418]                   3L)]
[16:13:42.418]             }
[16:13:42.418]             function(cond) {
[16:13:42.418]                 is_error <- inherits(cond, "error")
[16:13:42.418]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:42.418]                   NULL)
[16:13:42.418]                 if (is_error) {
[16:13:42.418]                   sessionInformation <- function() {
[16:13:42.418]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:42.418]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:42.418]                       search = base::search(), system = base::Sys.info())
[16:13:42.418]                   }
[16:13:42.418]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.418]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:42.418]                     cond$call), session = sessionInformation(), 
[16:13:42.418]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:42.418]                   signalCondition(cond)
[16:13:42.418]                 }
[16:13:42.418]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:42.418]                 "immediateCondition"))) {
[16:13:42.418]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:42.418]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.418]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:42.418]                   if (TRUE && !signal) {
[16:13:42.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.418]                     {
[16:13:42.418]                       inherits <- base::inherits
[16:13:42.418]                       invokeRestart <- base::invokeRestart
[16:13:42.418]                       is.null <- base::is.null
[16:13:42.418]                       muffled <- FALSE
[16:13:42.418]                       if (inherits(cond, "message")) {
[16:13:42.418]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.418]                         if (muffled) 
[16:13:42.418]                           invokeRestart("muffleMessage")
[16:13:42.418]                       }
[16:13:42.418]                       else if (inherits(cond, "warning")) {
[16:13:42.418]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.418]                         if (muffled) 
[16:13:42.418]                           invokeRestart("muffleWarning")
[16:13:42.418]                       }
[16:13:42.418]                       else if (inherits(cond, "condition")) {
[16:13:42.418]                         if (!is.null(pattern)) {
[16:13:42.418]                           computeRestarts <- base::computeRestarts
[16:13:42.418]                           grepl <- base::grepl
[16:13:42.418]                           restarts <- computeRestarts(cond)
[16:13:42.418]                           for (restart in restarts) {
[16:13:42.418]                             name <- restart$name
[16:13:42.418]                             if (is.null(name)) 
[16:13:42.418]                               next
[16:13:42.418]                             if (!grepl(pattern, name)) 
[16:13:42.418]                               next
[16:13:42.418]                             invokeRestart(restart)
[16:13:42.418]                             muffled <- TRUE
[16:13:42.418]                             break
[16:13:42.418]                           }
[16:13:42.418]                         }
[16:13:42.418]                       }
[16:13:42.418]                       invisible(muffled)
[16:13:42.418]                     }
[16:13:42.418]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.418]                   }
[16:13:42.418]                 }
[16:13:42.418]                 else {
[16:13:42.418]                   if (TRUE) {
[16:13:42.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.418]                     {
[16:13:42.418]                       inherits <- base::inherits
[16:13:42.418]                       invokeRestart <- base::invokeRestart
[16:13:42.418]                       is.null <- base::is.null
[16:13:42.418]                       muffled <- FALSE
[16:13:42.418]                       if (inherits(cond, "message")) {
[16:13:42.418]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.418]                         if (muffled) 
[16:13:42.418]                           invokeRestart("muffleMessage")
[16:13:42.418]                       }
[16:13:42.418]                       else if (inherits(cond, "warning")) {
[16:13:42.418]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.418]                         if (muffled) 
[16:13:42.418]                           invokeRestart("muffleWarning")
[16:13:42.418]                       }
[16:13:42.418]                       else if (inherits(cond, "condition")) {
[16:13:42.418]                         if (!is.null(pattern)) {
[16:13:42.418]                           computeRestarts <- base::computeRestarts
[16:13:42.418]                           grepl <- base::grepl
[16:13:42.418]                           restarts <- computeRestarts(cond)
[16:13:42.418]                           for (restart in restarts) {
[16:13:42.418]                             name <- restart$name
[16:13:42.418]                             if (is.null(name)) 
[16:13:42.418]                               next
[16:13:42.418]                             if (!grepl(pattern, name)) 
[16:13:42.418]                               next
[16:13:42.418]                             invokeRestart(restart)
[16:13:42.418]                             muffled <- TRUE
[16:13:42.418]                             break
[16:13:42.418]                           }
[16:13:42.418]                         }
[16:13:42.418]                       }
[16:13:42.418]                       invisible(muffled)
[16:13:42.418]                     }
[16:13:42.418]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.418]                   }
[16:13:42.418]                 }
[16:13:42.418]             }
[16:13:42.418]         }))
[16:13:42.418]     }, error = function(ex) {
[16:13:42.418]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:42.418]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.418]                 ...future.rng), started = ...future.startTime, 
[16:13:42.418]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:42.418]             version = "1.8"), class = "FutureResult")
[16:13:42.418]     }, finally = {
[16:13:42.418]         if (!identical(...future.workdir, getwd())) 
[16:13:42.418]             setwd(...future.workdir)
[16:13:42.418]         {
[16:13:42.418]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:42.418]                 ...future.oldOptions$nwarnings <- NULL
[16:13:42.418]             }
[16:13:42.418]             base::options(...future.oldOptions)
[16:13:42.418]             if (.Platform$OS.type == "windows") {
[16:13:42.418]                 old_names <- names(...future.oldEnvVars)
[16:13:42.418]                 envs <- base::Sys.getenv()
[16:13:42.418]                 names <- names(envs)
[16:13:42.418]                 common <- intersect(names, old_names)
[16:13:42.418]                 added <- setdiff(names, old_names)
[16:13:42.418]                 removed <- setdiff(old_names, names)
[16:13:42.418]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:42.418]                   envs[common]]
[16:13:42.418]                 NAMES <- toupper(changed)
[16:13:42.418]                 args <- list()
[16:13:42.418]                 for (kk in seq_along(NAMES)) {
[16:13:42.418]                   name <- changed[[kk]]
[16:13:42.418]                   NAME <- NAMES[[kk]]
[16:13:42.418]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.418]                     next
[16:13:42.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.418]                 }
[16:13:42.418]                 NAMES <- toupper(added)
[16:13:42.418]                 for (kk in seq_along(NAMES)) {
[16:13:42.418]                   name <- added[[kk]]
[16:13:42.418]                   NAME <- NAMES[[kk]]
[16:13:42.418]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.418]                     next
[16:13:42.418]                   args[[name]] <- ""
[16:13:42.418]                 }
[16:13:42.418]                 NAMES <- toupper(removed)
[16:13:42.418]                 for (kk in seq_along(NAMES)) {
[16:13:42.418]                   name <- removed[[kk]]
[16:13:42.418]                   NAME <- NAMES[[kk]]
[16:13:42.418]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.418]                     next
[16:13:42.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.418]                 }
[16:13:42.418]                 if (length(args) > 0) 
[16:13:42.418]                   base::do.call(base::Sys.setenv, args = args)
[16:13:42.418]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:42.418]             }
[16:13:42.418]             else {
[16:13:42.418]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:42.418]             }
[16:13:42.418]             {
[16:13:42.418]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:42.418]                   0L) {
[16:13:42.418]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:42.418]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:42.418]                   base::options(opts)
[16:13:42.418]                 }
[16:13:42.418]                 {
[16:13:42.418]                   {
[16:13:42.418]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:42.418]                     NULL
[16:13:42.418]                   }
[16:13:42.418]                   options(future.plan = NULL)
[16:13:42.418]                   if (is.na(NA_character_)) 
[16:13:42.418]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.418]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:42.418]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:42.418]                     envir = parent.frame()) 
[16:13:42.418]                   {
[16:13:42.418]                     default_workers <- missing(workers)
[16:13:42.418]                     if (is.function(workers)) 
[16:13:42.418]                       workers <- workers()
[16:13:42.418]                     workers <- structure(as.integer(workers), 
[16:13:42.418]                       class = class(workers))
[16:13:42.418]                     stop_if_not(is.finite(workers), workers >= 
[16:13:42.418]                       1L)
[16:13:42.418]                     if ((workers == 1L && !inherits(workers, 
[16:13:42.418]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:42.418]                       if (default_workers) 
[16:13:42.418]                         supportsMulticore(warn = TRUE)
[16:13:42.418]                       return(sequential(..., envir = envir))
[16:13:42.418]                     }
[16:13:42.418]                     oopts <- options(mc.cores = workers)
[16:13:42.418]                     on.exit(options(oopts))
[16:13:42.418]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:42.418]                       envir = envir)
[16:13:42.418]                     if (!future$lazy) 
[16:13:42.418]                       future <- run(future)
[16:13:42.418]                     invisible(future)
[16:13:42.418]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:42.418]                 }
[16:13:42.418]             }
[16:13:42.418]         }
[16:13:42.418]     })
[16:13:42.418]     if (TRUE) {
[16:13:42.418]         base::sink(type = "output", split = FALSE)
[16:13:42.418]         if (TRUE) {
[16:13:42.418]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:42.418]         }
[16:13:42.418]         else {
[16:13:42.418]             ...future.result["stdout"] <- base::list(NULL)
[16:13:42.418]         }
[16:13:42.418]         base::close(...future.stdout)
[16:13:42.418]         ...future.stdout <- NULL
[16:13:42.418]     }
[16:13:42.418]     ...future.result$conditions <- ...future.conditions
[16:13:42.418]     ...future.result$finished <- base::Sys.time()
[16:13:42.418]     ...future.result
[16:13:42.418] }
[16:13:42.421] requestCore(): workers = 2
[16:13:42.421] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:42.435] MulticoreFuture started
[16:13:42.435] - Launch lazy future ... done
[16:13:42.436] run() for ‘MulticoreFuture’ ... done
[16:13:42.436] plan(): Setting new future strategy stack:
[16:13:42.437] getGlobalsAndPackages() ...
[16:13:42.436] List of future strategies:
[16:13:42.436] 1. sequential:
[16:13:42.436]    - args: function (..., envir = parent.frame())
[16:13:42.436]    - tweaked: FALSE
[16:13:42.436]    - call: NULL
[16:13:42.438] Searching for globals...
[16:13:42.438] plan(): nbrOfWorkers() = 1
[16:13:42.441] plan(): Setting new future strategy stack:
[16:13:42.442] - globals found: [2] ‘{’, ‘Sys.sleep’
[16:13:42.442] Searching for globals ... DONE
[16:13:42.441] List of future strategies:
[16:13:42.441] 1. multicore:
[16:13:42.441]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:42.441]    - tweaked: FALSE
[16:13:42.441]    - call: plan(strategy)
[16:13:42.442] Resolving globals: FALSE
[16:13:42.443] 
[16:13:42.443] 
[16:13:42.444] getGlobalsAndPackages() ... DONE
[16:13:42.444] run() for ‘Future’ ...
[16:13:42.445] - state: ‘created’
[16:13:42.445] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:42.448] plan(): nbrOfWorkers() = 2
[16:13:42.450] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:42.450] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:42.450]   - Field: ‘label’
[16:13:42.450]   - Field: ‘local’
[16:13:42.451]   - Field: ‘owner’
[16:13:42.451]   - Field: ‘envir’
[16:13:42.451]   - Field: ‘workers’
[16:13:42.451]   - Field: ‘packages’
[16:13:42.451]   - Field: ‘gc’
[16:13:42.451]   - Field: ‘job’
[16:13:42.452]   - Field: ‘conditions’
[16:13:42.452]   - Field: ‘expr’
[16:13:42.452]   - Field: ‘uuid’
[16:13:42.452]   - Field: ‘seed’
[16:13:42.452]   - Field: ‘version’
[16:13:42.452]   - Field: ‘result’
[16:13:42.452]   - Field: ‘asynchronous’
[16:13:42.453]   - Field: ‘calls’
[16:13:42.453]   - Field: ‘globals’
[16:13:42.453]   - Field: ‘stdout’
[16:13:42.453]   - Field: ‘earlySignal’
[16:13:42.453]   - Field: ‘lazy’
[16:13:42.453]   - Field: ‘state’
[16:13:42.454] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:42.454] - Launch lazy future ...
[16:13:42.454] Packages needed by the future expression (n = 0): <none>
[16:13:42.454] Packages needed by future strategies (n = 0): <none>
[16:13:42.455] {
[16:13:42.455]     {
[16:13:42.455]         {
[16:13:42.455]             ...future.startTime <- base::Sys.time()
[16:13:42.455]             {
[16:13:42.455]                 {
[16:13:42.455]                   {
[16:13:42.455]                     {
[16:13:42.455]                       base::local({
[16:13:42.455]                         has_future <- base::requireNamespace("future", 
[16:13:42.455]                           quietly = TRUE)
[16:13:42.455]                         if (has_future) {
[16:13:42.455]                           ns <- base::getNamespace("future")
[16:13:42.455]                           version <- ns[[".package"]][["version"]]
[16:13:42.455]                           if (is.null(version)) 
[16:13:42.455]                             version <- utils::packageVersion("future")
[16:13:42.455]                         }
[16:13:42.455]                         else {
[16:13:42.455]                           version <- NULL
[16:13:42.455]                         }
[16:13:42.455]                         if (!has_future || version < "1.8.0") {
[16:13:42.455]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:42.455]                             "", base::R.version$version.string), 
[16:13:42.455]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:42.455]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:42.455]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:42.455]                               "release", "version")], collapse = " "), 
[16:13:42.455]                             hostname = base::Sys.info()[["nodename"]])
[16:13:42.455]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:42.455]                             info)
[16:13:42.455]                           info <- base::paste(info, collapse = "; ")
[16:13:42.455]                           if (!has_future) {
[16:13:42.455]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:42.455]                               info)
[16:13:42.455]                           }
[16:13:42.455]                           else {
[16:13:42.455]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:42.455]                               info, version)
[16:13:42.455]                           }
[16:13:42.455]                           base::stop(msg)
[16:13:42.455]                         }
[16:13:42.455]                       })
[16:13:42.455]                     }
[16:13:42.455]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:42.455]                     base::options(mc.cores = 1L)
[16:13:42.455]                   }
[16:13:42.455]                   options(future.plan = NULL)
[16:13:42.455]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.455]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:42.455]                 }
[16:13:42.455]                 ...future.workdir <- getwd()
[16:13:42.455]             }
[16:13:42.455]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:42.455]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:42.455]         }
[16:13:42.455]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:42.455]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:42.455]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:42.455]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:42.455]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:42.455]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:42.455]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:42.455]             base::names(...future.oldOptions))
[16:13:42.455]     }
[16:13:42.455]     if (FALSE) {
[16:13:42.455]     }
[16:13:42.455]     else {
[16:13:42.455]         if (TRUE) {
[16:13:42.455]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:42.455]                 open = "w")
[16:13:42.455]         }
[16:13:42.455]         else {
[16:13:42.455]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:42.455]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:42.455]         }
[16:13:42.455]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:42.455]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:42.455]             base::sink(type = "output", split = FALSE)
[16:13:42.455]             base::close(...future.stdout)
[16:13:42.455]         }, add = TRUE)
[16:13:42.455]     }
[16:13:42.455]     ...future.frame <- base::sys.nframe()
[16:13:42.455]     ...future.conditions <- base::list()
[16:13:42.455]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:42.455]     if (FALSE) {
[16:13:42.455]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:42.455]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:42.455]     }
[16:13:42.455]     ...future.result <- base::tryCatch({
[16:13:42.455]         base::withCallingHandlers({
[16:13:42.455]             ...future.value <- base::withVisible(base::local({
[16:13:42.455]                 withCallingHandlers({
[16:13:42.455]                   {
[16:13:42.455]                     Sys.sleep(0.5)
[16:13:42.455]                     2
[16:13:42.455]                   }
[16:13:42.455]                 }, immediateCondition = function(cond) {
[16:13:42.455]                   save_rds <- function (object, pathname, ...) 
[16:13:42.455]                   {
[16:13:42.455]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:42.455]                     if (file_test("-f", pathname_tmp)) {
[16:13:42.455]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.455]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:42.455]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.455]                         fi_tmp[["mtime"]])
[16:13:42.455]                     }
[16:13:42.455]                     tryCatch({
[16:13:42.455]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:42.455]                     }, error = function(ex) {
[16:13:42.455]                       msg <- conditionMessage(ex)
[16:13:42.455]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.455]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:42.455]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.455]                         fi_tmp[["mtime"]], msg)
[16:13:42.455]                       ex$message <- msg
[16:13:42.455]                       stop(ex)
[16:13:42.455]                     })
[16:13:42.455]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:42.455]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:42.455]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:42.455]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.455]                       fi <- file.info(pathname)
[16:13:42.455]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:42.455]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.455]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:42.455]                         fi[["size"]], fi[["mtime"]])
[16:13:42.455]                       stop(msg)
[16:13:42.455]                     }
[16:13:42.455]                     invisible(pathname)
[16:13:42.455]                   }
[16:13:42.455]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:42.455]                     rootPath = tempdir()) 
[16:13:42.455]                   {
[16:13:42.455]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:42.455]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:42.455]                       tmpdir = path, fileext = ".rds")
[16:13:42.455]                     save_rds(obj, file)
[16:13:42.455]                   }
[16:13:42.455]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:42.455]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.455]                   {
[16:13:42.455]                     inherits <- base::inherits
[16:13:42.455]                     invokeRestart <- base::invokeRestart
[16:13:42.455]                     is.null <- base::is.null
[16:13:42.455]                     muffled <- FALSE
[16:13:42.455]                     if (inherits(cond, "message")) {
[16:13:42.455]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:42.455]                       if (muffled) 
[16:13:42.455]                         invokeRestart("muffleMessage")
[16:13:42.455]                     }
[16:13:42.455]                     else if (inherits(cond, "warning")) {
[16:13:42.455]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:42.455]                       if (muffled) 
[16:13:42.455]                         invokeRestart("muffleWarning")
[16:13:42.455]                     }
[16:13:42.455]                     else if (inherits(cond, "condition")) {
[16:13:42.455]                       if (!is.null(pattern)) {
[16:13:42.455]                         computeRestarts <- base::computeRestarts
[16:13:42.455]                         grepl <- base::grepl
[16:13:42.455]                         restarts <- computeRestarts(cond)
[16:13:42.455]                         for (restart in restarts) {
[16:13:42.455]                           name <- restart$name
[16:13:42.455]                           if (is.null(name)) 
[16:13:42.455]                             next
[16:13:42.455]                           if (!grepl(pattern, name)) 
[16:13:42.455]                             next
[16:13:42.455]                           invokeRestart(restart)
[16:13:42.455]                           muffled <- TRUE
[16:13:42.455]                           break
[16:13:42.455]                         }
[16:13:42.455]                       }
[16:13:42.455]                     }
[16:13:42.455]                     invisible(muffled)
[16:13:42.455]                   }
[16:13:42.455]                   muffleCondition(cond)
[16:13:42.455]                 })
[16:13:42.455]             }))
[16:13:42.455]             future::FutureResult(value = ...future.value$value, 
[16:13:42.455]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.455]                   ...future.rng), globalenv = if (FALSE) 
[16:13:42.455]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:42.455]                     ...future.globalenv.names))
[16:13:42.455]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:42.455]         }, condition = base::local({
[16:13:42.455]             c <- base::c
[16:13:42.455]             inherits <- base::inherits
[16:13:42.455]             invokeRestart <- base::invokeRestart
[16:13:42.455]             length <- base::length
[16:13:42.455]             list <- base::list
[16:13:42.455]             seq.int <- base::seq.int
[16:13:42.455]             signalCondition <- base::signalCondition
[16:13:42.455]             sys.calls <- base::sys.calls
[16:13:42.455]             `[[` <- base::`[[`
[16:13:42.455]             `+` <- base::`+`
[16:13:42.455]             `<<-` <- base::`<<-`
[16:13:42.455]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:42.455]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:42.455]                   3L)]
[16:13:42.455]             }
[16:13:42.455]             function(cond) {
[16:13:42.455]                 is_error <- inherits(cond, "error")
[16:13:42.455]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:42.455]                   NULL)
[16:13:42.455]                 if (is_error) {
[16:13:42.455]                   sessionInformation <- function() {
[16:13:42.455]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:42.455]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:42.455]                       search = base::search(), system = base::Sys.info())
[16:13:42.455]                   }
[16:13:42.455]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.455]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:42.455]                     cond$call), session = sessionInformation(), 
[16:13:42.455]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:42.455]                   signalCondition(cond)
[16:13:42.455]                 }
[16:13:42.455]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:42.455]                 "immediateCondition"))) {
[16:13:42.455]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:42.455]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.455]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:42.455]                   if (TRUE && !signal) {
[16:13:42.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.455]                     {
[16:13:42.455]                       inherits <- base::inherits
[16:13:42.455]                       invokeRestart <- base::invokeRestart
[16:13:42.455]                       is.null <- base::is.null
[16:13:42.455]                       muffled <- FALSE
[16:13:42.455]                       if (inherits(cond, "message")) {
[16:13:42.455]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.455]                         if (muffled) 
[16:13:42.455]                           invokeRestart("muffleMessage")
[16:13:42.455]                       }
[16:13:42.455]                       else if (inherits(cond, "warning")) {
[16:13:42.455]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.455]                         if (muffled) 
[16:13:42.455]                           invokeRestart("muffleWarning")
[16:13:42.455]                       }
[16:13:42.455]                       else if (inherits(cond, "condition")) {
[16:13:42.455]                         if (!is.null(pattern)) {
[16:13:42.455]                           computeRestarts <- base::computeRestarts
[16:13:42.455]                           grepl <- base::grepl
[16:13:42.455]                           restarts <- computeRestarts(cond)
[16:13:42.455]                           for (restart in restarts) {
[16:13:42.455]                             name <- restart$name
[16:13:42.455]                             if (is.null(name)) 
[16:13:42.455]                               next
[16:13:42.455]                             if (!grepl(pattern, name)) 
[16:13:42.455]                               next
[16:13:42.455]                             invokeRestart(restart)
[16:13:42.455]                             muffled <- TRUE
[16:13:42.455]                             break
[16:13:42.455]                           }
[16:13:42.455]                         }
[16:13:42.455]                       }
[16:13:42.455]                       invisible(muffled)
[16:13:42.455]                     }
[16:13:42.455]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.455]                   }
[16:13:42.455]                 }
[16:13:42.455]                 else {
[16:13:42.455]                   if (TRUE) {
[16:13:42.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.455]                     {
[16:13:42.455]                       inherits <- base::inherits
[16:13:42.455]                       invokeRestart <- base::invokeRestart
[16:13:42.455]                       is.null <- base::is.null
[16:13:42.455]                       muffled <- FALSE
[16:13:42.455]                       if (inherits(cond, "message")) {
[16:13:42.455]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.455]                         if (muffled) 
[16:13:42.455]                           invokeRestart("muffleMessage")
[16:13:42.455]                       }
[16:13:42.455]                       else if (inherits(cond, "warning")) {
[16:13:42.455]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.455]                         if (muffled) 
[16:13:42.455]                           invokeRestart("muffleWarning")
[16:13:42.455]                       }
[16:13:42.455]                       else if (inherits(cond, "condition")) {
[16:13:42.455]                         if (!is.null(pattern)) {
[16:13:42.455]                           computeRestarts <- base::computeRestarts
[16:13:42.455]                           grepl <- base::grepl
[16:13:42.455]                           restarts <- computeRestarts(cond)
[16:13:42.455]                           for (restart in restarts) {
[16:13:42.455]                             name <- restart$name
[16:13:42.455]                             if (is.null(name)) 
[16:13:42.455]                               next
[16:13:42.455]                             if (!grepl(pattern, name)) 
[16:13:42.455]                               next
[16:13:42.455]                             invokeRestart(restart)
[16:13:42.455]                             muffled <- TRUE
[16:13:42.455]                             break
[16:13:42.455]                           }
[16:13:42.455]                         }
[16:13:42.455]                       }
[16:13:42.455]                       invisible(muffled)
[16:13:42.455]                     }
[16:13:42.455]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.455]                   }
[16:13:42.455]                 }
[16:13:42.455]             }
[16:13:42.455]         }))
[16:13:42.455]     }, error = function(ex) {
[16:13:42.455]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:42.455]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.455]                 ...future.rng), started = ...future.startTime, 
[16:13:42.455]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:42.455]             version = "1.8"), class = "FutureResult")
[16:13:42.455]     }, finally = {
[16:13:42.455]         if (!identical(...future.workdir, getwd())) 
[16:13:42.455]             setwd(...future.workdir)
[16:13:42.455]         {
[16:13:42.455]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:42.455]                 ...future.oldOptions$nwarnings <- NULL
[16:13:42.455]             }
[16:13:42.455]             base::options(...future.oldOptions)
[16:13:42.455]             if (.Platform$OS.type == "windows") {
[16:13:42.455]                 old_names <- names(...future.oldEnvVars)
[16:13:42.455]                 envs <- base::Sys.getenv()
[16:13:42.455]                 names <- names(envs)
[16:13:42.455]                 common <- intersect(names, old_names)
[16:13:42.455]                 added <- setdiff(names, old_names)
[16:13:42.455]                 removed <- setdiff(old_names, names)
[16:13:42.455]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:42.455]                   envs[common]]
[16:13:42.455]                 NAMES <- toupper(changed)
[16:13:42.455]                 args <- list()
[16:13:42.455]                 for (kk in seq_along(NAMES)) {
[16:13:42.455]                   name <- changed[[kk]]
[16:13:42.455]                   NAME <- NAMES[[kk]]
[16:13:42.455]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.455]                     next
[16:13:42.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.455]                 }
[16:13:42.455]                 NAMES <- toupper(added)
[16:13:42.455]                 for (kk in seq_along(NAMES)) {
[16:13:42.455]                   name <- added[[kk]]
[16:13:42.455]                   NAME <- NAMES[[kk]]
[16:13:42.455]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.455]                     next
[16:13:42.455]                   args[[name]] <- ""
[16:13:42.455]                 }
[16:13:42.455]                 NAMES <- toupper(removed)
[16:13:42.455]                 for (kk in seq_along(NAMES)) {
[16:13:42.455]                   name <- removed[[kk]]
[16:13:42.455]                   NAME <- NAMES[[kk]]
[16:13:42.455]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.455]                     next
[16:13:42.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.455]                 }
[16:13:42.455]                 if (length(args) > 0) 
[16:13:42.455]                   base::do.call(base::Sys.setenv, args = args)
[16:13:42.455]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:42.455]             }
[16:13:42.455]             else {
[16:13:42.455]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:42.455]             }
[16:13:42.455]             {
[16:13:42.455]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:42.455]                   0L) {
[16:13:42.455]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:42.455]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:42.455]                   base::options(opts)
[16:13:42.455]                 }
[16:13:42.455]                 {
[16:13:42.455]                   {
[16:13:42.455]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:42.455]                     NULL
[16:13:42.455]                   }
[16:13:42.455]                   options(future.plan = NULL)
[16:13:42.455]                   if (is.na(NA_character_)) 
[16:13:42.455]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.455]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:42.455]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:42.455]                     envir = parent.frame()) 
[16:13:42.455]                   {
[16:13:42.455]                     default_workers <- missing(workers)
[16:13:42.455]                     if (is.function(workers)) 
[16:13:42.455]                       workers <- workers()
[16:13:42.455]                     workers <- structure(as.integer(workers), 
[16:13:42.455]                       class = class(workers))
[16:13:42.455]                     stop_if_not(is.finite(workers), workers >= 
[16:13:42.455]                       1L)
[16:13:42.455]                     if ((workers == 1L && !inherits(workers, 
[16:13:42.455]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:42.455]                       if (default_workers) 
[16:13:42.455]                         supportsMulticore(warn = TRUE)
[16:13:42.455]                       return(sequential(..., envir = envir))
[16:13:42.455]                     }
[16:13:42.455]                     oopts <- options(mc.cores = workers)
[16:13:42.455]                     on.exit(options(oopts))
[16:13:42.455]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:42.455]                       envir = envir)
[16:13:42.455]                     if (!future$lazy) 
[16:13:42.455]                       future <- run(future)
[16:13:42.455]                     invisible(future)
[16:13:42.455]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:42.455]                 }
[16:13:42.455]             }
[16:13:42.455]         }
[16:13:42.455]     })
[16:13:42.455]     if (TRUE) {
[16:13:42.455]         base::sink(type = "output", split = FALSE)
[16:13:42.455]         if (TRUE) {
[16:13:42.455]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:42.455]         }
[16:13:42.455]         else {
[16:13:42.455]             ...future.result["stdout"] <- base::list(NULL)
[16:13:42.455]         }
[16:13:42.455]         base::close(...future.stdout)
[16:13:42.455]         ...future.stdout <- NULL
[16:13:42.455]     }
[16:13:42.455]     ...future.result$conditions <- ...future.conditions
[16:13:42.455]     ...future.result$finished <- base::Sys.time()
[16:13:42.455]     ...future.result
[16:13:42.455] }
[16:13:42.459] requestCore(): workers = 2
[16:13:42.459] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:42.473] MulticoreFuture started
[16:13:42.473] - Launch lazy future ... done
[16:13:42.473] run() for ‘MulticoreFuture’ ... done
[16:13:42.474] plan(): Setting new future strategy stack:
[16:13:42.475] getGlobalsAndPackages() ...
[16:13:42.475] Searching for globals...
[16:13:42.474] List of future strategies:
[16:13:42.474] 1. sequential:
[16:13:42.474]    - args: function (..., envir = parent.frame())
[16:13:42.474]    - tweaked: FALSE
[16:13:42.474]    - call: NULL
[16:13:42.476] plan(): nbrOfWorkers() = 1
[16:13:42.477] - globals found: [1] ‘{’
[16:13:42.477] Searching for globals ... DONE
[16:13:42.477] Resolving globals: FALSE
[16:13:42.478] 
[16:13:42.478] 
[16:13:42.478] getGlobalsAndPackages() ... DONE
[16:13:42.479] run() for ‘Future’ ...
[16:13:42.479] - state: ‘created’
[16:13:42.479] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:42.484] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:42.484] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:42.485]   - Field: ‘label’
[16:13:42.485]   - Field: ‘local’
[16:13:42.485]   - Field: ‘owner’
[16:13:42.485]   - Field: ‘envir’
[16:13:42.485]   - Field: ‘workers’
[16:13:42.485]   - Field: ‘packages’
[16:13:42.485]   - Field: ‘gc’
[16:13:42.486]   - Field: ‘job’
[16:13:42.486]   - Field: ‘conditions’
[16:13:42.486]   - Field: ‘expr’
[16:13:42.486]   - Field: ‘uuid’
[16:13:42.486]   - Field: ‘seed’
[16:13:42.486]   - Field: ‘version’
[16:13:42.486]   - Field: ‘result’
[16:13:42.487]   - Field: ‘asynchronous’
[16:13:42.487]   - Field: ‘calls’
[16:13:42.487]   - Field: ‘globals’
[16:13:42.487]   - Field: ‘stdout’
[16:13:42.487]   - Field: ‘earlySignal’
[16:13:42.487]   - Field: ‘lazy’
[16:13:42.487]   - Field: ‘state’
[16:13:42.488] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:42.488] - Launch lazy future ...
[16:13:42.488] Packages needed by the future expression (n = 0): <none>
[16:13:42.488] Packages needed by future strategies (n = 0): <none>
[16:13:42.489] {
[16:13:42.489]     {
[16:13:42.489]         {
[16:13:42.489]             ...future.startTime <- base::Sys.time()
[16:13:42.489]             {
[16:13:42.489]                 {
[16:13:42.489]                   {
[16:13:42.489]                     {
[16:13:42.489]                       base::local({
[16:13:42.489]                         has_future <- base::requireNamespace("future", 
[16:13:42.489]                           quietly = TRUE)
[16:13:42.489]                         if (has_future) {
[16:13:42.489]                           ns <- base::getNamespace("future")
[16:13:42.489]                           version <- ns[[".package"]][["version"]]
[16:13:42.489]                           if (is.null(version)) 
[16:13:42.489]                             version <- utils::packageVersion("future")
[16:13:42.489]                         }
[16:13:42.489]                         else {
[16:13:42.489]                           version <- NULL
[16:13:42.489]                         }
[16:13:42.489]                         if (!has_future || version < "1.8.0") {
[16:13:42.489]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:42.489]                             "", base::R.version$version.string), 
[16:13:42.489]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:42.489]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:42.489]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:42.489]                               "release", "version")], collapse = " "), 
[16:13:42.489]                             hostname = base::Sys.info()[["nodename"]])
[16:13:42.489]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:42.489]                             info)
[16:13:42.489]                           info <- base::paste(info, collapse = "; ")
[16:13:42.489]                           if (!has_future) {
[16:13:42.489]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:42.489]                               info)
[16:13:42.489]                           }
[16:13:42.489]                           else {
[16:13:42.489]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:42.489]                               info, version)
[16:13:42.489]                           }
[16:13:42.489]                           base::stop(msg)
[16:13:42.489]                         }
[16:13:42.489]                       })
[16:13:42.489]                     }
[16:13:42.489]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:42.489]                     base::options(mc.cores = 1L)
[16:13:42.489]                   }
[16:13:42.489]                   options(future.plan = NULL)
[16:13:42.489]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.489]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:42.489]                 }
[16:13:42.489]                 ...future.workdir <- getwd()
[16:13:42.489]             }
[16:13:42.489]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:42.489]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:42.489]         }
[16:13:42.489]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:42.489]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:42.489]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:42.489]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:42.489]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:42.489]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:42.489]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:42.489]             base::names(...future.oldOptions))
[16:13:42.489]     }
[16:13:42.489]     if (FALSE) {
[16:13:42.489]     }
[16:13:42.489]     else {
[16:13:42.489]         if (TRUE) {
[16:13:42.489]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:42.489]                 open = "w")
[16:13:42.489]         }
[16:13:42.489]         else {
[16:13:42.489]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:42.489]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:42.489]         }
[16:13:42.489]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:42.489]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:42.489]             base::sink(type = "output", split = FALSE)
[16:13:42.489]             base::close(...future.stdout)
[16:13:42.489]         }, add = TRUE)
[16:13:42.489]     }
[16:13:42.489]     ...future.frame <- base::sys.nframe()
[16:13:42.489]     ...future.conditions <- base::list()
[16:13:42.489]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:42.489]     if (FALSE) {
[16:13:42.489]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:42.489]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:42.489]     }
[16:13:42.489]     ...future.result <- base::tryCatch({
[16:13:42.489]         base::withCallingHandlers({
[16:13:42.489]             ...future.value <- base::withVisible(base::local({
[16:13:42.489]                 withCallingHandlers({
[16:13:42.489]                   {
[16:13:42.489]                     3
[16:13:42.489]                   }
[16:13:42.489]                 }, immediateCondition = function(cond) {
[16:13:42.489]                   save_rds <- function (object, pathname, ...) 
[16:13:42.489]                   {
[16:13:42.489]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:42.489]                     if (file_test("-f", pathname_tmp)) {
[16:13:42.489]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.489]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:42.489]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.489]                         fi_tmp[["mtime"]])
[16:13:42.489]                     }
[16:13:42.489]                     tryCatch({
[16:13:42.489]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:42.489]                     }, error = function(ex) {
[16:13:42.489]                       msg <- conditionMessage(ex)
[16:13:42.489]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.489]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:42.489]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.489]                         fi_tmp[["mtime"]], msg)
[16:13:42.489]                       ex$message <- msg
[16:13:42.489]                       stop(ex)
[16:13:42.489]                     })
[16:13:42.489]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:42.489]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:42.489]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:42.489]                       fi_tmp <- file.info(pathname_tmp)
[16:13:42.489]                       fi <- file.info(pathname)
[16:13:42.489]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:42.489]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:42.489]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:42.489]                         fi[["size"]], fi[["mtime"]])
[16:13:42.489]                       stop(msg)
[16:13:42.489]                     }
[16:13:42.489]                     invisible(pathname)
[16:13:42.489]                   }
[16:13:42.489]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:42.489]                     rootPath = tempdir()) 
[16:13:42.489]                   {
[16:13:42.489]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:42.489]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:42.489]                       tmpdir = path, fileext = ".rds")
[16:13:42.489]                     save_rds(obj, file)
[16:13:42.489]                   }
[16:13:42.489]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9IrRs7/.future/immediateConditions")
[16:13:42.489]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.489]                   {
[16:13:42.489]                     inherits <- base::inherits
[16:13:42.489]                     invokeRestart <- base::invokeRestart
[16:13:42.489]                     is.null <- base::is.null
[16:13:42.489]                     muffled <- FALSE
[16:13:42.489]                     if (inherits(cond, "message")) {
[16:13:42.489]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:42.489]                       if (muffled) 
[16:13:42.489]                         invokeRestart("muffleMessage")
[16:13:42.489]                     }
[16:13:42.489]                     else if (inherits(cond, "warning")) {
[16:13:42.489]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:42.489]                       if (muffled) 
[16:13:42.489]                         invokeRestart("muffleWarning")
[16:13:42.489]                     }
[16:13:42.489]                     else if (inherits(cond, "condition")) {
[16:13:42.489]                       if (!is.null(pattern)) {
[16:13:42.489]                         computeRestarts <- base::computeRestarts
[16:13:42.489]                         grepl <- base::grepl
[16:13:42.489]                         restarts <- computeRestarts(cond)
[16:13:42.489]                         for (restart in restarts) {
[16:13:42.489]                           name <- restart$name
[16:13:42.489]                           if (is.null(name)) 
[16:13:42.489]                             next
[16:13:42.489]                           if (!grepl(pattern, name)) 
[16:13:42.489]                             next
[16:13:42.489]                           invokeRestart(restart)
[16:13:42.489]                           muffled <- TRUE
[16:13:42.489]                           break
[16:13:42.489]                         }
[16:13:42.489]                       }
[16:13:42.489]                     }
[16:13:42.489]                     invisible(muffled)
[16:13:42.489]                   }
[16:13:42.489]                   muffleCondition(cond)
[16:13:42.489]                 })
[16:13:42.489]             }))
[16:13:42.489]             future::FutureResult(value = ...future.value$value, 
[16:13:42.489]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.489]                   ...future.rng), globalenv = if (FALSE) 
[16:13:42.489]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:42.489]                     ...future.globalenv.names))
[16:13:42.489]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:42.489]         }, condition = base::local({
[16:13:42.489]             c <- base::c
[16:13:42.489]             inherits <- base::inherits
[16:13:42.489]             invokeRestart <- base::invokeRestart
[16:13:42.489]             length <- base::length
[16:13:42.489]             list <- base::list
[16:13:42.489]             seq.int <- base::seq.int
[16:13:42.489]             signalCondition <- base::signalCondition
[16:13:42.489]             sys.calls <- base::sys.calls
[16:13:42.489]             `[[` <- base::`[[`
[16:13:42.489]             `+` <- base::`+`
[16:13:42.489]             `<<-` <- base::`<<-`
[16:13:42.489]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:42.489]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:42.489]                   3L)]
[16:13:42.489]             }
[16:13:42.489]             function(cond) {
[16:13:42.489]                 is_error <- inherits(cond, "error")
[16:13:42.489]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:42.489]                   NULL)
[16:13:42.489]                 if (is_error) {
[16:13:42.489]                   sessionInformation <- function() {
[16:13:42.489]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:42.489]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:42.489]                       search = base::search(), system = base::Sys.info())
[16:13:42.489]                   }
[16:13:42.489]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.489]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:42.489]                     cond$call), session = sessionInformation(), 
[16:13:42.489]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:42.489]                   signalCondition(cond)
[16:13:42.489]                 }
[16:13:42.489]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:42.489]                 "immediateCondition"))) {
[16:13:42.489]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:42.489]                   ...future.conditions[[length(...future.conditions) + 
[16:13:42.489]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:42.489]                   if (TRUE && !signal) {
[16:13:42.489]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.489]                     {
[16:13:42.489]                       inherits <- base::inherits
[16:13:42.489]                       invokeRestart <- base::invokeRestart
[16:13:42.489]                       is.null <- base::is.null
[16:13:42.489]                       muffled <- FALSE
[16:13:42.489]                       if (inherits(cond, "message")) {
[16:13:42.489]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.489]                         if (muffled) 
[16:13:42.489]                           invokeRestart("muffleMessage")
[16:13:42.489]                       }
[16:13:42.489]                       else if (inherits(cond, "warning")) {
[16:13:42.489]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.489]                         if (muffled) 
[16:13:42.489]                           invokeRestart("muffleWarning")
[16:13:42.489]                       }
[16:13:42.489]                       else if (inherits(cond, "condition")) {
[16:13:42.489]                         if (!is.null(pattern)) {
[16:13:42.489]                           computeRestarts <- base::computeRestarts
[16:13:42.489]                           grepl <- base::grepl
[16:13:42.489]                           restarts <- computeRestarts(cond)
[16:13:42.489]                           for (restart in restarts) {
[16:13:42.489]                             name <- restart$name
[16:13:42.489]                             if (is.null(name)) 
[16:13:42.489]                               next
[16:13:42.489]                             if (!grepl(pattern, name)) 
[16:13:42.489]                               next
[16:13:42.489]                             invokeRestart(restart)
[16:13:42.489]                             muffled <- TRUE
[16:13:42.489]                             break
[16:13:42.489]                           }
[16:13:42.489]                         }
[16:13:42.489]                       }
[16:13:42.489]                       invisible(muffled)
[16:13:42.489]                     }
[16:13:42.489]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.489]                   }
[16:13:42.489]                 }
[16:13:42.489]                 else {
[16:13:42.489]                   if (TRUE) {
[16:13:42.489]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:42.489]                     {
[16:13:42.489]                       inherits <- base::inherits
[16:13:42.489]                       invokeRestart <- base::invokeRestart
[16:13:42.489]                       is.null <- base::is.null
[16:13:42.489]                       muffled <- FALSE
[16:13:42.489]                       if (inherits(cond, "message")) {
[16:13:42.489]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:42.489]                         if (muffled) 
[16:13:42.489]                           invokeRestart("muffleMessage")
[16:13:42.489]                       }
[16:13:42.489]                       else if (inherits(cond, "warning")) {
[16:13:42.489]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:42.489]                         if (muffled) 
[16:13:42.489]                           invokeRestart("muffleWarning")
[16:13:42.489]                       }
[16:13:42.489]                       else if (inherits(cond, "condition")) {
[16:13:42.489]                         if (!is.null(pattern)) {
[16:13:42.489]                           computeRestarts <- base::computeRestarts
[16:13:42.489]                           grepl <- base::grepl
[16:13:42.489]                           restarts <- computeRestarts(cond)
[16:13:42.489]                           for (restart in restarts) {
[16:13:42.489]                             name <- restart$name
[16:13:42.489]                             if (is.null(name)) 
[16:13:42.489]                               next
[16:13:42.489]                             if (!grepl(pattern, name)) 
[16:13:42.489]                               next
[16:13:42.489]                             invokeRestart(restart)
[16:13:42.489]                             muffled <- TRUE
[16:13:42.489]                             break
[16:13:42.489]                           }
[16:13:42.489]                         }
[16:13:42.489]                       }
[16:13:42.489]                       invisible(muffled)
[16:13:42.489]                     }
[16:13:42.489]                     muffleCondition(cond, pattern = "^muffle")
[16:13:42.489]                   }
[16:13:42.489]                 }
[16:13:42.489]             }
[16:13:42.489]         }))
[16:13:42.489]     }, error = function(ex) {
[16:13:42.489]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:42.489]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:42.489]                 ...future.rng), started = ...future.startTime, 
[16:13:42.489]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:42.489]             version = "1.8"), class = "FutureResult")
[16:13:42.489]     }, finally = {
[16:13:42.489]         if (!identical(...future.workdir, getwd())) 
[16:13:42.489]             setwd(...future.workdir)
[16:13:42.489]         {
[16:13:42.489]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:42.489]                 ...future.oldOptions$nwarnings <- NULL
[16:13:42.489]             }
[16:13:42.489]             base::options(...future.oldOptions)
[16:13:42.489]             if (.Platform$OS.type == "windows") {
[16:13:42.489]                 old_names <- names(...future.oldEnvVars)
[16:13:42.489]                 envs <- base::Sys.getenv()
[16:13:42.489]                 names <- names(envs)
[16:13:42.489]                 common <- intersect(names, old_names)
[16:13:42.489]                 added <- setdiff(names, old_names)
[16:13:42.489]                 removed <- setdiff(old_names, names)
[16:13:42.489]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:42.489]                   envs[common]]
[16:13:42.489]                 NAMES <- toupper(changed)
[16:13:42.489]                 args <- list()
[16:13:42.489]                 for (kk in seq_along(NAMES)) {
[16:13:42.489]                   name <- changed[[kk]]
[16:13:42.489]                   NAME <- NAMES[[kk]]
[16:13:42.489]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.489]                     next
[16:13:42.489]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.489]                 }
[16:13:42.489]                 NAMES <- toupper(added)
[16:13:42.489]                 for (kk in seq_along(NAMES)) {
[16:13:42.489]                   name <- added[[kk]]
[16:13:42.489]                   NAME <- NAMES[[kk]]
[16:13:42.489]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.489]                     next
[16:13:42.489]                   args[[name]] <- ""
[16:13:42.489]                 }
[16:13:42.489]                 NAMES <- toupper(removed)
[16:13:42.489]                 for (kk in seq_along(NAMES)) {
[16:13:42.489]                   name <- removed[[kk]]
[16:13:42.489]                   NAME <- NAMES[[kk]]
[16:13:42.489]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:42.489]                     next
[16:13:42.489]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:42.489]                 }
[16:13:42.489]                 if (length(args) > 0) 
[16:13:42.489]                   base::do.call(base::Sys.setenv, args = args)
[16:13:42.489]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:42.489]             }
[16:13:42.489]             else {
[16:13:42.489]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:42.489]             }
[16:13:42.489]             {
[16:13:42.489]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:42.489]                   0L) {
[16:13:42.489]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:42.489]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:42.489]                   base::options(opts)
[16:13:42.489]                 }
[16:13:42.489]                 {
[16:13:42.489]                   {
[16:13:42.489]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:42.489]                     NULL
[16:13:42.489]                   }
[16:13:42.489]                   options(future.plan = NULL)
[16:13:42.489]                   if (is.na(NA_character_)) 
[16:13:42.489]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:42.489]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:42.489]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:13:42.489]                     envir = parent.frame()) 
[16:13:42.489]                   {
[16:13:42.489]                     default_workers <- missing(workers)
[16:13:42.489]                     if (is.function(workers)) 
[16:13:42.489]                       workers <- workers()
[16:13:42.489]                     workers <- structure(as.integer(workers), 
[16:13:42.489]                       class = class(workers))
[16:13:42.489]                     stop_if_not(is.finite(workers), workers >= 
[16:13:42.489]                       1L)
[16:13:42.489]                     if ((workers == 1L && !inherits(workers, 
[16:13:42.489]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:42.489]                       if (default_workers) 
[16:13:42.489]                         supportsMulticore(warn = TRUE)
[16:13:42.489]                       return(sequential(..., envir = envir))
[16:13:42.489]                     }
[16:13:42.489]                     oopts <- options(mc.cores = workers)
[16:13:42.489]                     on.exit(options(oopts))
[16:13:42.489]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:42.489]                       envir = envir)
[16:13:42.489]                     if (!future$lazy) 
[16:13:42.489]                       future <- run(future)
[16:13:42.489]                     invisible(future)
[16:13:42.489]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:42.489]                 }
[16:13:42.489]             }
[16:13:42.489]         }
[16:13:42.489]     })
[16:13:42.489]     if (TRUE) {
[16:13:42.489]         base::sink(type = "output", split = FALSE)
[16:13:42.489]         if (TRUE) {
[16:13:42.489]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:42.489]         }
[16:13:42.489]         else {
[16:13:42.489]             ...future.result["stdout"] <- base::list(NULL)
[16:13:42.489]         }
[16:13:42.489]         base::close(...future.stdout)
[16:13:42.489]         ...future.stdout <- NULL
[16:13:42.489]     }
[16:13:42.489]     ...future.result$conditions <- ...future.conditions
[16:13:42.489]     ...future.result$finished <- base::Sys.time()
[16:13:42.489]     ...future.result
[16:13:42.489] }
[16:13:42.493] requestCore(): workers = 2
[16:13:42.493] Poll #1 (0): usedCores() = 2, workers = 2
[16:13:42.507] MulticoreFuture started
[16:13:42.507] - Launch lazy future ... done
[16:13:42.508] run() for ‘MulticoreFuture’ ... done
[16:13:42.508] plan(): Setting new future strategy stack:
[16:13:42.509] List of future strategies:
[16:13:42.509] 1. sequential:
[16:13:42.509]    - args: function (..., envir = parent.frame())
[16:13:42.509]    - tweaked: FALSE
[16:13:42.509]    - call: NULL
[16:13:42.510] plan(): nbrOfWorkers() = 1
[16:13:42.510] resolve() on list environment ...
[16:13:42.510]  recursive: 0
[16:13:42.511] plan(): Setting new future strategy stack:
[16:13:42.512] List of future strategies:
[16:13:42.512] 1. multicore:
[16:13:42.512]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:42.512]    - tweaked: FALSE
[16:13:42.512]    - call: plan(strategy)
[16:13:42.516]  length: 4
[16:13:42.517]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:13:42.517] Future #1
[16:13:42.518]  length: 3 (resolved future 1)
[16:13:42.522] plan(): nbrOfWorkers() = 2
[16:13:42.529] Future #3
[16:13:42.529]  length: 2 (resolved future 3)
[16:13:42.530]  length: 1 (resolved future 4)
[16:13:42.979] plan(): Setting new future strategy stack:
[16:13:42.979] List of future strategies:
[16:13:42.979] 1. multicore:
[16:13:42.979]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:42.979]    - tweaked: FALSE
[16:13:42.979]    - call: plan(strategy)
[16:13:42.984] plan(): nbrOfWorkers() = 2
[16:13:42.990] Future #2
[16:13:42.990]  length: 0 (resolved future 2)
[16:13:42.990] resolve() on list environment ... DONE
[16:13:42.991] resolve() on list environment ...
[16:13:42.991]  recursive: 0
[16:13:42.993]  length: 4
[16:13:42.993]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:13:42.993] Future #1
[16:13:42.993]  length: 3 (resolved future 1)
[16:13:42.994] Future #2
[16:13:42.994]  length: 2 (resolved future 2)
[16:13:42.994] Future #3
[16:13:42.995]  length: 1 (resolved future 3)
[16:13:42.995]  length: 0 (resolved future 4)
[16:13:42.995] resolve() on list environment ... DONE
[16:13:42.996] resolve() on list environment ...
[16:13:42.996]  recursive: 0
[16:13:42.997]  length: 4
[16:13:42.997]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:13:42.997] Future #1
[16:13:42.998]  length: 3 (resolved future 1)
[16:13:42.998] Future #2
[16:13:42.998]  length: 2 (resolved future 2)
[16:13:42.998] Future #3
[16:13:42.998]  length: 1 (resolved future 3)
[16:13:42.999]  length: 0 (resolved future 4)
[16:13:42.999] resolve() on list environment ... DONE
[16:13:42.999] resolve() on list environment ...
[16:13:42.999]  recursive: 0
[16:13:43.000]  length: 4
[16:13:43.001]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:13:43.001] Future #1
[16:13:43.001]  length: 3 (resolved future 1)
[16:13:43.001] Future #2
[16:13:43.001]  length: 2 (resolved future 2)
[16:13:43.002] Future #3
[16:13:43.002]  length: 1 (resolved future 3)
[16:13:43.002]  length: 0 (resolved future 4)
[16:13:43.002] resolve() on list environment ... DONE
[16:13:43.003] resolve() on list environment ...
[16:13:43.003]  recursive: 0
[16:13:43.004]  length: 4
[16:13:43.004]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:13:43.004] Future #1
[16:13:43.004]  length: 3 (resolved future 1)
[16:13:43.005] Future #2
[16:13:43.006]  length: 2 (resolved future 2)
[16:13:43.006] Future #3
[16:13:43.007]  length: 1 (resolved future 3)
[16:13:43.007]  length: 0 (resolved future 4)
[16:13:43.007] resolve() on list environment ... DONE
[16:13:43.008] resolve() on list environment ...
[16:13:43.008]  recursive: 99
[16:13:43.009]  length: 4
[16:13:43.010]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:13:43.010] Future #1
[16:13:43.010] A MulticoreFuture was resolved
[16:13:43.010]  length: 3 (resolved future 1)
[16:13:43.010] Future #2
[16:13:43.010] A MulticoreFuture was resolved
[16:13:43.011]  length: 2 (resolved future 2)
[16:13:43.011] Future #3
[16:13:43.011] A MulticoreFuture was resolved
[16:13:43.011]  length: 1 (resolved future 3)
[16:13:43.011]  length: 0 (resolved future 4)
[16:13:43.011] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multicore') ...
- plan('multisession') ...
[16:13:43.012] plan(): Setting new future strategy stack:
[16:13:43.012] List of future strategies:
[16:13:43.012] 1. multisession:
[16:13:43.012]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:13:43.012]    - tweaked: FALSE
[16:13:43.012]    - call: plan(strategy)
[16:13:43.012] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:13:43.013] multisession:
[16:13:43.013] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:13:43.013] - tweaked: FALSE
[16:13:43.013] - call: plan(strategy)
[16:13:43.019] getGlobalsAndPackages() ...
[16:13:43.019] Not searching for globals
[16:13:43.019] - globals: [0] <none>
[16:13:43.019] getGlobalsAndPackages() ... DONE
[16:13:43.022] [local output] makeClusterPSOCK() ...
[16:13:43.056] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:13:43.062] [local output] Base port: 11047
[16:13:43.062] [local output] Getting setup options for 2 cluster nodes ...
[16:13:43.062] [local output]  - Node 1 of 2 ...
[16:13:43.062] [local output] localMachine=TRUE => revtunnel=FALSE

[16:13:43.063] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp9IrRs7/worker.rank=1.parallelly.parent=90299.160bb2bb9a071.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp9IrRs7/worker.rank=1.parallelly.parent=90299.160bb2bb9a071.pid")'’
[16:13:43.264] - Possible to infer worker's PID: TRUE
[16:13:43.265] [local output] Rscript port: 11047

[16:13:43.265] [local output]  - Node 2 of 2 ...
[16:13:43.265] [local output] localMachine=TRUE => revtunnel=FALSE

[16:13:43.266] [local output] Rscript port: 11047

[16:13:43.266] [local output] Getting setup options for 2 cluster nodes ... done
[16:13:43.266] [local output]  - Parallel setup requested for some PSOCK nodes
[16:13:43.267] [local output] Setting up PSOCK nodes in parallel
[16:13:43.267] List of 36
[16:13:43.267]  $ worker          : chr "localhost"
[16:13:43.267]   ..- attr(*, "localhost")= logi TRUE
[16:13:43.267]  $ master          : chr "localhost"
[16:13:43.267]  $ port            : int 11047
[16:13:43.267]  $ connectTimeout  : num 120
[16:13:43.267]  $ timeout         : num 2592000
[16:13:43.267]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:13:43.267]  $ homogeneous     : logi TRUE
[16:13:43.267]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:13:43.267]  $ rscript_envs    : NULL
[16:13:43.267]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:13:43.267]  $ rscript_startup : NULL
[16:13:43.267]  $ rscript_sh      : chr "sh"
[16:13:43.267]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:13:43.267]  $ methods         : logi TRUE
[16:13:43.267]  $ socketOptions   : chr "no-delay"
[16:13:43.267]  $ useXDR          : logi FALSE
[16:13:43.267]  $ outfile         : chr "/dev/null"
[16:13:43.267]  $ renice          : int NA
[16:13:43.267]  $ rshcmd          : NULL
[16:13:43.267]  $ user            : chr(0) 
[16:13:43.267]  $ revtunnel       : logi FALSE
[16:13:43.267]  $ rshlogfile      : NULL
[16:13:43.267]  $ rshopts         : chr(0) 
[16:13:43.267]  $ rank            : int 1
[16:13:43.267]  $ manual          : logi FALSE
[16:13:43.267]  $ dryrun          : logi FALSE
[16:13:43.267]  $ quiet           : logi FALSE
[16:13:43.267]  $ setup_strategy  : chr "parallel"
[16:13:43.267]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:13:43.267]  $ pidfile         : chr "/tmp/Rtmp9IrRs7/worker.rank=1.parallelly.parent=90299.160bb2bb9a071.pid"
[16:13:43.267]  $ rshcmd_label    : NULL
[16:13:43.267]  $ rsh_call        : NULL
[16:13:43.267]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:13:43.267]  $ localMachine    : logi TRUE
[16:13:43.267]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:13:43.267]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:13:43.267]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:13:43.267]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:13:43.267]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:13:43.267]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:13:43.267]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:13:43.267]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:13:43.267]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:13:43.267]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:13:43.267]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:13:43.267]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:13:43.267]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:13:43.267]  $ arguments       :List of 28
[16:13:43.267]   ..$ worker          : chr "localhost"
[16:13:43.267]   ..$ master          : NULL
[16:13:43.267]   ..$ port            : int 11047
[16:13:43.267]   ..$ connectTimeout  : num 120
[16:13:43.267]   ..$ timeout         : num 2592000
[16:13:43.267]   ..$ rscript         : NULL
[16:13:43.267]   ..$ homogeneous     : NULL
[16:13:43.267]   ..$ rscript_args    : NULL
[16:13:43.267]   ..$ rscript_envs    : NULL
[16:13:43.267]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:13:43.267]   ..$ rscript_startup : NULL
[16:13:43.267]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:13:43.267]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:13:43.267]   ..$ methods         : logi TRUE
[16:13:43.267]   ..$ socketOptions   : chr "no-delay"
[16:13:43.267]   ..$ useXDR          : logi FALSE
[16:13:43.267]   ..$ outfile         : chr "/dev/null"
[16:13:43.267]   ..$ renice          : int NA
[16:13:43.267]   ..$ rshcmd          : NULL
[16:13:43.267]   ..$ user            : NULL
[16:13:43.267]   ..$ revtunnel       : logi NA
[16:13:43.267]   ..$ rshlogfile      : NULL
[16:13:43.267]   ..$ rshopts         : NULL
[16:13:43.267]   ..$ rank            : int 1
[16:13:43.267]   ..$ manual          : logi FALSE
[16:13:43.267]   ..$ dryrun          : logi FALSE
[16:13:43.267]   ..$ quiet           : logi FALSE
[16:13:43.267]   ..$ setup_strategy  : chr "parallel"
[16:13:43.267]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:13:43.284] [local output] System call to launch all workers:
[16:13:43.284] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp9IrRs7/worker.rank=1.parallelly.parent=90299.160bb2bb9a071.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11047 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:13:43.284] [local output] Starting PSOCK main server
[16:13:43.285] [local output] Workers launched
[16:13:43.286] [local output] Waiting for workers to connect back
[16:13:43.286]  - [local output] 0 workers out of 2 ready
[16:13:43.529]  - [local output] 0 workers out of 2 ready
[16:13:43.530]  - [local output] 1 workers out of 2 ready
[16:13:43.535]  - [local output] 1 workers out of 2 ready
[16:13:43.535]  - [local output] 2 workers out of 2 ready
[16:13:43.535] [local output] Launching of workers completed
[16:13:43.535] [local output] Collecting session information from workers
[16:13:43.536] [local output]  - Worker #1 of 2
[16:13:43.537] [local output]  - Worker #2 of 2
[16:13:43.537] [local output] makeClusterPSOCK() ... done
[16:13:43.549] Packages needed by the future expression (n = 0): <none>
[16:13:43.549] Packages needed by future strategies (n = 0): <none>
[16:13:43.549] {
[16:13:43.549]     {
[16:13:43.549]         {
[16:13:43.549]             ...future.startTime <- base::Sys.time()
[16:13:43.549]             {
[16:13:43.549]                 {
[16:13:43.549]                   {
[16:13:43.549]                     {
[16:13:43.549]                       base::local({
[16:13:43.549]                         has_future <- base::requireNamespace("future", 
[16:13:43.549]                           quietly = TRUE)
[16:13:43.549]                         if (has_future) {
[16:13:43.549]                           ns <- base::getNamespace("future")
[16:13:43.549]                           version <- ns[[".package"]][["version"]]
[16:13:43.549]                           if (is.null(version)) 
[16:13:43.549]                             version <- utils::packageVersion("future")
[16:13:43.549]                         }
[16:13:43.549]                         else {
[16:13:43.549]                           version <- NULL
[16:13:43.549]                         }
[16:13:43.549]                         if (!has_future || version < "1.8.0") {
[16:13:43.549]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:43.549]                             "", base::R.version$version.string), 
[16:13:43.549]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:43.549]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:43.549]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:43.549]                               "release", "version")], collapse = " "), 
[16:13:43.549]                             hostname = base::Sys.info()[["nodename"]])
[16:13:43.549]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:43.549]                             info)
[16:13:43.549]                           info <- base::paste(info, collapse = "; ")
[16:13:43.549]                           if (!has_future) {
[16:13:43.549]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:43.549]                               info)
[16:13:43.549]                           }
[16:13:43.549]                           else {
[16:13:43.549]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:43.549]                               info, version)
[16:13:43.549]                           }
[16:13:43.549]                           base::stop(msg)
[16:13:43.549]                         }
[16:13:43.549]                       })
[16:13:43.549]                     }
[16:13:43.549]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:43.549]                     base::options(mc.cores = 1L)
[16:13:43.549]                   }
[16:13:43.549]                   options(future.plan = NULL)
[16:13:43.549]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:43.549]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:43.549]                 }
[16:13:43.549]                 ...future.workdir <- getwd()
[16:13:43.549]             }
[16:13:43.549]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:43.549]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:43.549]         }
[16:13:43.549]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:43.549]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:43.549]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:43.549]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:43.549]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:43.549]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:43.549]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:43.549]             base::names(...future.oldOptions))
[16:13:43.549]     }
[16:13:43.549]     if (FALSE) {
[16:13:43.549]     }
[16:13:43.549]     else {
[16:13:43.549]         if (TRUE) {
[16:13:43.549]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:43.549]                 open = "w")
[16:13:43.549]         }
[16:13:43.549]         else {
[16:13:43.549]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:43.549]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:43.549]         }
[16:13:43.549]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:43.549]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:43.549]             base::sink(type = "output", split = FALSE)
[16:13:43.549]             base::close(...future.stdout)
[16:13:43.549]         }, add = TRUE)
[16:13:43.549]     }
[16:13:43.549]     ...future.frame <- base::sys.nframe()
[16:13:43.549]     ...future.conditions <- base::list()
[16:13:43.549]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:43.549]     if (FALSE) {
[16:13:43.549]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:43.549]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:43.549]     }
[16:13:43.549]     ...future.result <- base::tryCatch({
[16:13:43.549]         base::withCallingHandlers({
[16:13:43.549]             ...future.value <- base::withVisible(base::local({
[16:13:43.549]                 ...future.makeSendCondition <- local({
[16:13:43.549]                   sendCondition <- NULL
[16:13:43.549]                   function(frame = 1L) {
[16:13:43.549]                     if (is.function(sendCondition)) 
[16:13:43.549]                       return(sendCondition)
[16:13:43.549]                     ns <- getNamespace("parallel")
[16:13:43.549]                     if (exists("sendData", mode = "function", 
[16:13:43.549]                       envir = ns)) {
[16:13:43.549]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:43.549]                         envir = ns)
[16:13:43.549]                       envir <- sys.frame(frame)
[16:13:43.549]                       master <- NULL
[16:13:43.549]                       while (!identical(envir, .GlobalEnv) && 
[16:13:43.549]                         !identical(envir, emptyenv())) {
[16:13:43.549]                         if (exists("master", mode = "list", envir = envir, 
[16:13:43.549]                           inherits = FALSE)) {
[16:13:43.549]                           master <- get("master", mode = "list", 
[16:13:43.549]                             envir = envir, inherits = FALSE)
[16:13:43.549]                           if (inherits(master, c("SOCKnode", 
[16:13:43.549]                             "SOCK0node"))) {
[16:13:43.549]                             sendCondition <<- function(cond) {
[16:13:43.549]                               data <- list(type = "VALUE", value = cond, 
[16:13:43.549]                                 success = TRUE)
[16:13:43.549]                               parallel_sendData(master, data)
[16:13:43.549]                             }
[16:13:43.549]                             return(sendCondition)
[16:13:43.549]                           }
[16:13:43.549]                         }
[16:13:43.549]                         frame <- frame + 1L
[16:13:43.549]                         envir <- sys.frame(frame)
[16:13:43.549]                       }
[16:13:43.549]                     }
[16:13:43.549]                     sendCondition <<- function(cond) NULL
[16:13:43.549]                   }
[16:13:43.549]                 })
[16:13:43.549]                 withCallingHandlers({
[16:13:43.549]                   NA
[16:13:43.549]                 }, immediateCondition = function(cond) {
[16:13:43.549]                   sendCondition <- ...future.makeSendCondition()
[16:13:43.549]                   sendCondition(cond)
[16:13:43.549]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:43.549]                   {
[16:13:43.549]                     inherits <- base::inherits
[16:13:43.549]                     invokeRestart <- base::invokeRestart
[16:13:43.549]                     is.null <- base::is.null
[16:13:43.549]                     muffled <- FALSE
[16:13:43.549]                     if (inherits(cond, "message")) {
[16:13:43.549]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:43.549]                       if (muffled) 
[16:13:43.549]                         invokeRestart("muffleMessage")
[16:13:43.549]                     }
[16:13:43.549]                     else if (inherits(cond, "warning")) {
[16:13:43.549]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:43.549]                       if (muffled) 
[16:13:43.549]                         invokeRestart("muffleWarning")
[16:13:43.549]                     }
[16:13:43.549]                     else if (inherits(cond, "condition")) {
[16:13:43.549]                       if (!is.null(pattern)) {
[16:13:43.549]                         computeRestarts <- base::computeRestarts
[16:13:43.549]                         grepl <- base::grepl
[16:13:43.549]                         restarts <- computeRestarts(cond)
[16:13:43.549]                         for (restart in restarts) {
[16:13:43.549]                           name <- restart$name
[16:13:43.549]                           if (is.null(name)) 
[16:13:43.549]                             next
[16:13:43.549]                           if (!grepl(pattern, name)) 
[16:13:43.549]                             next
[16:13:43.549]                           invokeRestart(restart)
[16:13:43.549]                           muffled <- TRUE
[16:13:43.549]                           break
[16:13:43.549]                         }
[16:13:43.549]                       }
[16:13:43.549]                     }
[16:13:43.549]                     invisible(muffled)
[16:13:43.549]                   }
[16:13:43.549]                   muffleCondition(cond)
[16:13:43.549]                 })
[16:13:43.549]             }))
[16:13:43.549]             future::FutureResult(value = ...future.value$value, 
[16:13:43.549]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:43.549]                   ...future.rng), globalenv = if (FALSE) 
[16:13:43.549]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:43.549]                     ...future.globalenv.names))
[16:13:43.549]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:43.549]         }, condition = base::local({
[16:13:43.549]             c <- base::c
[16:13:43.549]             inherits <- base::inherits
[16:13:43.549]             invokeRestart <- base::invokeRestart
[16:13:43.549]             length <- base::length
[16:13:43.549]             list <- base::list
[16:13:43.549]             seq.int <- base::seq.int
[16:13:43.549]             signalCondition <- base::signalCondition
[16:13:43.549]             sys.calls <- base::sys.calls
[16:13:43.549]             `[[` <- base::`[[`
[16:13:43.549]             `+` <- base::`+`
[16:13:43.549]             `<<-` <- base::`<<-`
[16:13:43.549]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:43.549]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:43.549]                   3L)]
[16:13:43.549]             }
[16:13:43.549]             function(cond) {
[16:13:43.549]                 is_error <- inherits(cond, "error")
[16:13:43.549]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:43.549]                   NULL)
[16:13:43.549]                 if (is_error) {
[16:13:43.549]                   sessionInformation <- function() {
[16:13:43.549]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:43.549]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:43.549]                       search = base::search(), system = base::Sys.info())
[16:13:43.549]                   }
[16:13:43.549]                   ...future.conditions[[length(...future.conditions) + 
[16:13:43.549]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:43.549]                     cond$call), session = sessionInformation(), 
[16:13:43.549]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:43.549]                   signalCondition(cond)
[16:13:43.549]                 }
[16:13:43.549]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:43.549]                 "immediateCondition"))) {
[16:13:43.549]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:43.549]                   ...future.conditions[[length(...future.conditions) + 
[16:13:43.549]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:43.549]                   if (TRUE && !signal) {
[16:13:43.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:43.549]                     {
[16:13:43.549]                       inherits <- base::inherits
[16:13:43.549]                       invokeRestart <- base::invokeRestart
[16:13:43.549]                       is.null <- base::is.null
[16:13:43.549]                       muffled <- FALSE
[16:13:43.549]                       if (inherits(cond, "message")) {
[16:13:43.549]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:43.549]                         if (muffled) 
[16:13:43.549]                           invokeRestart("muffleMessage")
[16:13:43.549]                       }
[16:13:43.549]                       else if (inherits(cond, "warning")) {
[16:13:43.549]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:43.549]                         if (muffled) 
[16:13:43.549]                           invokeRestart("muffleWarning")
[16:13:43.549]                       }
[16:13:43.549]                       else if (inherits(cond, "condition")) {
[16:13:43.549]                         if (!is.null(pattern)) {
[16:13:43.549]                           computeRestarts <- base::computeRestarts
[16:13:43.549]                           grepl <- base::grepl
[16:13:43.549]                           restarts <- computeRestarts(cond)
[16:13:43.549]                           for (restart in restarts) {
[16:13:43.549]                             name <- restart$name
[16:13:43.549]                             if (is.null(name)) 
[16:13:43.549]                               next
[16:13:43.549]                             if (!grepl(pattern, name)) 
[16:13:43.549]                               next
[16:13:43.549]                             invokeRestart(restart)
[16:13:43.549]                             muffled <- TRUE
[16:13:43.549]                             break
[16:13:43.549]                           }
[16:13:43.549]                         }
[16:13:43.549]                       }
[16:13:43.549]                       invisible(muffled)
[16:13:43.549]                     }
[16:13:43.549]                     muffleCondition(cond, pattern = "^muffle")
[16:13:43.549]                   }
[16:13:43.549]                 }
[16:13:43.549]                 else {
[16:13:43.549]                   if (TRUE) {
[16:13:43.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:43.549]                     {
[16:13:43.549]                       inherits <- base::inherits
[16:13:43.549]                       invokeRestart <- base::invokeRestart
[16:13:43.549]                       is.null <- base::is.null
[16:13:43.549]                       muffled <- FALSE
[16:13:43.549]                       if (inherits(cond, "message")) {
[16:13:43.549]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:43.549]                         if (muffled) 
[16:13:43.549]                           invokeRestart("muffleMessage")
[16:13:43.549]                       }
[16:13:43.549]                       else if (inherits(cond, "warning")) {
[16:13:43.549]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:43.549]                         if (muffled) 
[16:13:43.549]                           invokeRestart("muffleWarning")
[16:13:43.549]                       }
[16:13:43.549]                       else if (inherits(cond, "condition")) {
[16:13:43.549]                         if (!is.null(pattern)) {
[16:13:43.549]                           computeRestarts <- base::computeRestarts
[16:13:43.549]                           grepl <- base::grepl
[16:13:43.549]                           restarts <- computeRestarts(cond)
[16:13:43.549]                           for (restart in restarts) {
[16:13:43.549]                             name <- restart$name
[16:13:43.549]                             if (is.null(name)) 
[16:13:43.549]                               next
[16:13:43.549]                             if (!grepl(pattern, name)) 
[16:13:43.549]                               next
[16:13:43.549]                             invokeRestart(restart)
[16:13:43.549]                             muffled <- TRUE
[16:13:43.549]                             break
[16:13:43.549]                           }
[16:13:43.549]                         }
[16:13:43.549]                       }
[16:13:43.549]                       invisible(muffled)
[16:13:43.549]                     }
[16:13:43.549]                     muffleCondition(cond, pattern = "^muffle")
[16:13:43.549]                   }
[16:13:43.549]                 }
[16:13:43.549]             }
[16:13:43.549]         }))
[16:13:43.549]     }, error = function(ex) {
[16:13:43.549]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:43.549]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:43.549]                 ...future.rng), started = ...future.startTime, 
[16:13:43.549]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:43.549]             version = "1.8"), class = "FutureResult")
[16:13:43.549]     }, finally = {
[16:13:43.549]         if (!identical(...future.workdir, getwd())) 
[16:13:43.549]             setwd(...future.workdir)
[16:13:43.549]         {
[16:13:43.549]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:43.549]                 ...future.oldOptions$nwarnings <- NULL
[16:13:43.549]             }
[16:13:43.549]             base::options(...future.oldOptions)
[16:13:43.549]             if (.Platform$OS.type == "windows") {
[16:13:43.549]                 old_names <- names(...future.oldEnvVars)
[16:13:43.549]                 envs <- base::Sys.getenv()
[16:13:43.549]                 names <- names(envs)
[16:13:43.549]                 common <- intersect(names, old_names)
[16:13:43.549]                 added <- setdiff(names, old_names)
[16:13:43.549]                 removed <- setdiff(old_names, names)
[16:13:43.549]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:43.549]                   envs[common]]
[16:13:43.549]                 NAMES <- toupper(changed)
[16:13:43.549]                 args <- list()
[16:13:43.549]                 for (kk in seq_along(NAMES)) {
[16:13:43.549]                   name <- changed[[kk]]
[16:13:43.549]                   NAME <- NAMES[[kk]]
[16:13:43.549]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:43.549]                     next
[16:13:43.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:43.549]                 }
[16:13:43.549]                 NAMES <- toupper(added)
[16:13:43.549]                 for (kk in seq_along(NAMES)) {
[16:13:43.549]                   name <- added[[kk]]
[16:13:43.549]                   NAME <- NAMES[[kk]]
[16:13:43.549]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:43.549]                     next
[16:13:43.549]                   args[[name]] <- ""
[16:13:43.549]                 }
[16:13:43.549]                 NAMES <- toupper(removed)
[16:13:43.549]                 for (kk in seq_along(NAMES)) {
[16:13:43.549]                   name <- removed[[kk]]
[16:13:43.549]                   NAME <- NAMES[[kk]]
[16:13:43.549]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:43.549]                     next
[16:13:43.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:43.549]                 }
[16:13:43.549]                 if (length(args) > 0) 
[16:13:43.549]                   base::do.call(base::Sys.setenv, args = args)
[16:13:43.549]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:43.549]             }
[16:13:43.549]             else {
[16:13:43.549]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:43.549]             }
[16:13:43.549]             {
[16:13:43.549]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:43.549]                   0L) {
[16:13:43.549]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:43.549]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:43.549]                   base::options(opts)
[16:13:43.549]                 }
[16:13:43.549]                 {
[16:13:43.549]                   {
[16:13:43.549]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:43.549]                     NULL
[16:13:43.549]                   }
[16:13:43.549]                   options(future.plan = NULL)
[16:13:43.549]                   if (is.na(NA_character_)) 
[16:13:43.549]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:43.549]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:43.549]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:43.549]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:43.549]                     envir = parent.frame()) 
[16:13:43.549]                   {
[16:13:43.549]                     if (is.function(workers)) 
[16:13:43.549]                       workers <- workers()
[16:13:43.549]                     workers <- structure(as.integer(workers), 
[16:13:43.549]                       class = class(workers))
[16:13:43.549]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:43.549]                       workers >= 1)
[16:13:43.549]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:43.549]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:43.549]                     }
[16:13:43.549]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:43.549]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:43.549]                       envir = envir)
[16:13:43.549]                     if (!future$lazy) 
[16:13:43.549]                       future <- run(future)
[16:13:43.549]                     invisible(future)
[16:13:43.549]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:43.549]                 }
[16:13:43.549]             }
[16:13:43.549]         }
[16:13:43.549]     })
[16:13:43.549]     if (TRUE) {
[16:13:43.549]         base::sink(type = "output", split = FALSE)
[16:13:43.549]         if (TRUE) {
[16:13:43.549]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:43.549]         }
[16:13:43.549]         else {
[16:13:43.549]             ...future.result["stdout"] <- base::list(NULL)
[16:13:43.549]         }
[16:13:43.549]         base::close(...future.stdout)
[16:13:43.549]         ...future.stdout <- NULL
[16:13:43.549]     }
[16:13:43.549]     ...future.result$conditions <- ...future.conditions
[16:13:43.549]     ...future.result$finished <- base::Sys.time()
[16:13:43.549]     ...future.result
[16:13:43.549] }
[16:13:43.620] MultisessionFuture started
[16:13:43.620] result() for ClusterFuture ...
[16:13:43.621] receiveMessageFromWorker() for ClusterFuture ...
[16:13:43.621] - Validating connection of MultisessionFuture
[16:13:43.652] - received message: FutureResult
[16:13:43.652] - Received FutureResult
[16:13:43.652] - Erased future from FutureRegistry
[16:13:43.652] result() for ClusterFuture ...
[16:13:43.652] - result already collected: FutureResult
[16:13:43.652] result() for ClusterFuture ... done
[16:13:43.652] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:43.653] result() for ClusterFuture ... done
[16:13:43.653] result() for ClusterFuture ...
[16:13:43.653] - result already collected: FutureResult
[16:13:43.653] result() for ClusterFuture ... done
[16:13:43.653] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:13:43.657] plan(): nbrOfWorkers() = 2
*** resolve() for Future objects ...
- result = FALSE, recursive = FALSE ...
[16:13:43.660] getGlobalsAndPackages() ...
[16:13:43.660] Searching for globals...
[16:13:43.662] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:43.662] Searching for globals ... DONE
[16:13:43.662] Resolving globals: FALSE
[16:13:43.663] 
[16:13:43.663] 
[16:13:43.663] getGlobalsAndPackages() ... DONE
[16:13:43.663] run() for ‘Future’ ...
[16:13:43.663] - state: ‘created’
[16:13:43.663] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:43.678] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:43.678] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:43.678]   - Field: ‘node’
[16:13:43.679]   - Field: ‘label’
[16:13:43.679]   - Field: ‘local’
[16:13:43.679]   - Field: ‘owner’
[16:13:43.679]   - Field: ‘envir’
[16:13:43.679]   - Field: ‘workers’
[16:13:43.679]   - Field: ‘packages’
[16:13:43.679]   - Field: ‘gc’
[16:13:43.679]   - Field: ‘conditions’
[16:13:43.679]   - Field: ‘persistent’
[16:13:43.680]   - Field: ‘expr’
[16:13:43.680]   - Field: ‘uuid’
[16:13:43.680]   - Field: ‘seed’
[16:13:43.680]   - Field: ‘version’
[16:13:43.680]   - Field: ‘result’
[16:13:43.680]   - Field: ‘asynchronous’
[16:13:43.680]   - Field: ‘calls’
[16:13:43.680]   - Field: ‘globals’
[16:13:43.681]   - Field: ‘stdout’
[16:13:43.681]   - Field: ‘earlySignal’
[16:13:43.681]   - Field: ‘lazy’
[16:13:43.681]   - Field: ‘state’
[16:13:43.681] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:43.681] - Launch lazy future ...
[16:13:43.681] Packages needed by the future expression (n = 0): <none>
[16:13:43.682] Packages needed by future strategies (n = 0): <none>
[16:13:43.682] {
[16:13:43.682]     {
[16:13:43.682]         {
[16:13:43.682]             ...future.startTime <- base::Sys.time()
[16:13:43.682]             {
[16:13:43.682]                 {
[16:13:43.682]                   {
[16:13:43.682]                     {
[16:13:43.682]                       base::local({
[16:13:43.682]                         has_future <- base::requireNamespace("future", 
[16:13:43.682]                           quietly = TRUE)
[16:13:43.682]                         if (has_future) {
[16:13:43.682]                           ns <- base::getNamespace("future")
[16:13:43.682]                           version <- ns[[".package"]][["version"]]
[16:13:43.682]                           if (is.null(version)) 
[16:13:43.682]                             version <- utils::packageVersion("future")
[16:13:43.682]                         }
[16:13:43.682]                         else {
[16:13:43.682]                           version <- NULL
[16:13:43.682]                         }
[16:13:43.682]                         if (!has_future || version < "1.8.0") {
[16:13:43.682]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:43.682]                             "", base::R.version$version.string), 
[16:13:43.682]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:43.682]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:43.682]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:43.682]                               "release", "version")], collapse = " "), 
[16:13:43.682]                             hostname = base::Sys.info()[["nodename"]])
[16:13:43.682]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:43.682]                             info)
[16:13:43.682]                           info <- base::paste(info, collapse = "; ")
[16:13:43.682]                           if (!has_future) {
[16:13:43.682]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:43.682]                               info)
[16:13:43.682]                           }
[16:13:43.682]                           else {
[16:13:43.682]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:43.682]                               info, version)
[16:13:43.682]                           }
[16:13:43.682]                           base::stop(msg)
[16:13:43.682]                         }
[16:13:43.682]                       })
[16:13:43.682]                     }
[16:13:43.682]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:43.682]                     base::options(mc.cores = 1L)
[16:13:43.682]                   }
[16:13:43.682]                   options(future.plan = NULL)
[16:13:43.682]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:43.682]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:43.682]                 }
[16:13:43.682]                 ...future.workdir <- getwd()
[16:13:43.682]             }
[16:13:43.682]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:43.682]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:43.682]         }
[16:13:43.682]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:43.682]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:43.682]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:43.682]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:43.682]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:43.682]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:43.682]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:43.682]             base::names(...future.oldOptions))
[16:13:43.682]     }
[16:13:43.682]     if (FALSE) {
[16:13:43.682]     }
[16:13:43.682]     else {
[16:13:43.682]         if (TRUE) {
[16:13:43.682]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:43.682]                 open = "w")
[16:13:43.682]         }
[16:13:43.682]         else {
[16:13:43.682]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:43.682]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:43.682]         }
[16:13:43.682]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:43.682]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:43.682]             base::sink(type = "output", split = FALSE)
[16:13:43.682]             base::close(...future.stdout)
[16:13:43.682]         }, add = TRUE)
[16:13:43.682]     }
[16:13:43.682]     ...future.frame <- base::sys.nframe()
[16:13:43.682]     ...future.conditions <- base::list()
[16:13:43.682]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:43.682]     if (FALSE) {
[16:13:43.682]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:43.682]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:43.682]     }
[16:13:43.682]     ...future.result <- base::tryCatch({
[16:13:43.682]         base::withCallingHandlers({
[16:13:43.682]             ...future.value <- base::withVisible(base::local({
[16:13:43.682]                 ...future.makeSendCondition <- local({
[16:13:43.682]                   sendCondition <- NULL
[16:13:43.682]                   function(frame = 1L) {
[16:13:43.682]                     if (is.function(sendCondition)) 
[16:13:43.682]                       return(sendCondition)
[16:13:43.682]                     ns <- getNamespace("parallel")
[16:13:43.682]                     if (exists("sendData", mode = "function", 
[16:13:43.682]                       envir = ns)) {
[16:13:43.682]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:43.682]                         envir = ns)
[16:13:43.682]                       envir <- sys.frame(frame)
[16:13:43.682]                       master <- NULL
[16:13:43.682]                       while (!identical(envir, .GlobalEnv) && 
[16:13:43.682]                         !identical(envir, emptyenv())) {
[16:13:43.682]                         if (exists("master", mode = "list", envir = envir, 
[16:13:43.682]                           inherits = FALSE)) {
[16:13:43.682]                           master <- get("master", mode = "list", 
[16:13:43.682]                             envir = envir, inherits = FALSE)
[16:13:43.682]                           if (inherits(master, c("SOCKnode", 
[16:13:43.682]                             "SOCK0node"))) {
[16:13:43.682]                             sendCondition <<- function(cond) {
[16:13:43.682]                               data <- list(type = "VALUE", value = cond, 
[16:13:43.682]                                 success = TRUE)
[16:13:43.682]                               parallel_sendData(master, data)
[16:13:43.682]                             }
[16:13:43.682]                             return(sendCondition)
[16:13:43.682]                           }
[16:13:43.682]                         }
[16:13:43.682]                         frame <- frame + 1L
[16:13:43.682]                         envir <- sys.frame(frame)
[16:13:43.682]                       }
[16:13:43.682]                     }
[16:13:43.682]                     sendCondition <<- function(cond) NULL
[16:13:43.682]                   }
[16:13:43.682]                 })
[16:13:43.682]                 withCallingHandlers({
[16:13:43.682]                   {
[16:13:43.682]                     Sys.sleep(0.5)
[16:13:43.682]                     list(a = 1, b = 42L)
[16:13:43.682]                   }
[16:13:43.682]                 }, immediateCondition = function(cond) {
[16:13:43.682]                   sendCondition <- ...future.makeSendCondition()
[16:13:43.682]                   sendCondition(cond)
[16:13:43.682]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:43.682]                   {
[16:13:43.682]                     inherits <- base::inherits
[16:13:43.682]                     invokeRestart <- base::invokeRestart
[16:13:43.682]                     is.null <- base::is.null
[16:13:43.682]                     muffled <- FALSE
[16:13:43.682]                     if (inherits(cond, "message")) {
[16:13:43.682]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:43.682]                       if (muffled) 
[16:13:43.682]                         invokeRestart("muffleMessage")
[16:13:43.682]                     }
[16:13:43.682]                     else if (inherits(cond, "warning")) {
[16:13:43.682]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:43.682]                       if (muffled) 
[16:13:43.682]                         invokeRestart("muffleWarning")
[16:13:43.682]                     }
[16:13:43.682]                     else if (inherits(cond, "condition")) {
[16:13:43.682]                       if (!is.null(pattern)) {
[16:13:43.682]                         computeRestarts <- base::computeRestarts
[16:13:43.682]                         grepl <- base::grepl
[16:13:43.682]                         restarts <- computeRestarts(cond)
[16:13:43.682]                         for (restart in restarts) {
[16:13:43.682]                           name <- restart$name
[16:13:43.682]                           if (is.null(name)) 
[16:13:43.682]                             next
[16:13:43.682]                           if (!grepl(pattern, name)) 
[16:13:43.682]                             next
[16:13:43.682]                           invokeRestart(restart)
[16:13:43.682]                           muffled <- TRUE
[16:13:43.682]                           break
[16:13:43.682]                         }
[16:13:43.682]                       }
[16:13:43.682]                     }
[16:13:43.682]                     invisible(muffled)
[16:13:43.682]                   }
[16:13:43.682]                   muffleCondition(cond)
[16:13:43.682]                 })
[16:13:43.682]             }))
[16:13:43.682]             future::FutureResult(value = ...future.value$value, 
[16:13:43.682]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:43.682]                   ...future.rng), globalenv = if (FALSE) 
[16:13:43.682]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:43.682]                     ...future.globalenv.names))
[16:13:43.682]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:43.682]         }, condition = base::local({
[16:13:43.682]             c <- base::c
[16:13:43.682]             inherits <- base::inherits
[16:13:43.682]             invokeRestart <- base::invokeRestart
[16:13:43.682]             length <- base::length
[16:13:43.682]             list <- base::list
[16:13:43.682]             seq.int <- base::seq.int
[16:13:43.682]             signalCondition <- base::signalCondition
[16:13:43.682]             sys.calls <- base::sys.calls
[16:13:43.682]             `[[` <- base::`[[`
[16:13:43.682]             `+` <- base::`+`
[16:13:43.682]             `<<-` <- base::`<<-`
[16:13:43.682]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:43.682]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:43.682]                   3L)]
[16:13:43.682]             }
[16:13:43.682]             function(cond) {
[16:13:43.682]                 is_error <- inherits(cond, "error")
[16:13:43.682]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:43.682]                   NULL)
[16:13:43.682]                 if (is_error) {
[16:13:43.682]                   sessionInformation <- function() {
[16:13:43.682]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:43.682]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:43.682]                       search = base::search(), system = base::Sys.info())
[16:13:43.682]                   }
[16:13:43.682]                   ...future.conditions[[length(...future.conditions) + 
[16:13:43.682]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:43.682]                     cond$call), session = sessionInformation(), 
[16:13:43.682]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:43.682]                   signalCondition(cond)
[16:13:43.682]                 }
[16:13:43.682]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:43.682]                 "immediateCondition"))) {
[16:13:43.682]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:43.682]                   ...future.conditions[[length(...future.conditions) + 
[16:13:43.682]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:43.682]                   if (TRUE && !signal) {
[16:13:43.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:43.682]                     {
[16:13:43.682]                       inherits <- base::inherits
[16:13:43.682]                       invokeRestart <- base::invokeRestart
[16:13:43.682]                       is.null <- base::is.null
[16:13:43.682]                       muffled <- FALSE
[16:13:43.682]                       if (inherits(cond, "message")) {
[16:13:43.682]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:43.682]                         if (muffled) 
[16:13:43.682]                           invokeRestart("muffleMessage")
[16:13:43.682]                       }
[16:13:43.682]                       else if (inherits(cond, "warning")) {
[16:13:43.682]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:43.682]                         if (muffled) 
[16:13:43.682]                           invokeRestart("muffleWarning")
[16:13:43.682]                       }
[16:13:43.682]                       else if (inherits(cond, "condition")) {
[16:13:43.682]                         if (!is.null(pattern)) {
[16:13:43.682]                           computeRestarts <- base::computeRestarts
[16:13:43.682]                           grepl <- base::grepl
[16:13:43.682]                           restarts <- computeRestarts(cond)
[16:13:43.682]                           for (restart in restarts) {
[16:13:43.682]                             name <- restart$name
[16:13:43.682]                             if (is.null(name)) 
[16:13:43.682]                               next
[16:13:43.682]                             if (!grepl(pattern, name)) 
[16:13:43.682]                               next
[16:13:43.682]                             invokeRestart(restart)
[16:13:43.682]                             muffled <- TRUE
[16:13:43.682]                             break
[16:13:43.682]                           }
[16:13:43.682]                         }
[16:13:43.682]                       }
[16:13:43.682]                       invisible(muffled)
[16:13:43.682]                     }
[16:13:43.682]                     muffleCondition(cond, pattern = "^muffle")
[16:13:43.682]                   }
[16:13:43.682]                 }
[16:13:43.682]                 else {
[16:13:43.682]                   if (TRUE) {
[16:13:43.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:43.682]                     {
[16:13:43.682]                       inherits <- base::inherits
[16:13:43.682]                       invokeRestart <- base::invokeRestart
[16:13:43.682]                       is.null <- base::is.null
[16:13:43.682]                       muffled <- FALSE
[16:13:43.682]                       if (inherits(cond, "message")) {
[16:13:43.682]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:43.682]                         if (muffled) 
[16:13:43.682]                           invokeRestart("muffleMessage")
[16:13:43.682]                       }
[16:13:43.682]                       else if (inherits(cond, "warning")) {
[16:13:43.682]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:43.682]                         if (muffled) 
[16:13:43.682]                           invokeRestart("muffleWarning")
[16:13:43.682]                       }
[16:13:43.682]                       else if (inherits(cond, "condition")) {
[16:13:43.682]                         if (!is.null(pattern)) {
[16:13:43.682]                           computeRestarts <- base::computeRestarts
[16:13:43.682]                           grepl <- base::grepl
[16:13:43.682]                           restarts <- computeRestarts(cond)
[16:13:43.682]                           for (restart in restarts) {
[16:13:43.682]                             name <- restart$name
[16:13:43.682]                             if (is.null(name)) 
[16:13:43.682]                               next
[16:13:43.682]                             if (!grepl(pattern, name)) 
[16:13:43.682]                               next
[16:13:43.682]                             invokeRestart(restart)
[16:13:43.682]                             muffled <- TRUE
[16:13:43.682]                             break
[16:13:43.682]                           }
[16:13:43.682]                         }
[16:13:43.682]                       }
[16:13:43.682]                       invisible(muffled)
[16:13:43.682]                     }
[16:13:43.682]                     muffleCondition(cond, pattern = "^muffle")
[16:13:43.682]                   }
[16:13:43.682]                 }
[16:13:43.682]             }
[16:13:43.682]         }))
[16:13:43.682]     }, error = function(ex) {
[16:13:43.682]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:43.682]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:43.682]                 ...future.rng), started = ...future.startTime, 
[16:13:43.682]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:43.682]             version = "1.8"), class = "FutureResult")
[16:13:43.682]     }, finally = {
[16:13:43.682]         if (!identical(...future.workdir, getwd())) 
[16:13:43.682]             setwd(...future.workdir)
[16:13:43.682]         {
[16:13:43.682]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:43.682]                 ...future.oldOptions$nwarnings <- NULL
[16:13:43.682]             }
[16:13:43.682]             base::options(...future.oldOptions)
[16:13:43.682]             if (.Platform$OS.type == "windows") {
[16:13:43.682]                 old_names <- names(...future.oldEnvVars)
[16:13:43.682]                 envs <- base::Sys.getenv()
[16:13:43.682]                 names <- names(envs)
[16:13:43.682]                 common <- intersect(names, old_names)
[16:13:43.682]                 added <- setdiff(names, old_names)
[16:13:43.682]                 removed <- setdiff(old_names, names)
[16:13:43.682]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:43.682]                   envs[common]]
[16:13:43.682]                 NAMES <- toupper(changed)
[16:13:43.682]                 args <- list()
[16:13:43.682]                 for (kk in seq_along(NAMES)) {
[16:13:43.682]                   name <- changed[[kk]]
[16:13:43.682]                   NAME <- NAMES[[kk]]
[16:13:43.682]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:43.682]                     next
[16:13:43.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:43.682]                 }
[16:13:43.682]                 NAMES <- toupper(added)
[16:13:43.682]                 for (kk in seq_along(NAMES)) {
[16:13:43.682]                   name <- added[[kk]]
[16:13:43.682]                   NAME <- NAMES[[kk]]
[16:13:43.682]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:43.682]                     next
[16:13:43.682]                   args[[name]] <- ""
[16:13:43.682]                 }
[16:13:43.682]                 NAMES <- toupper(removed)
[16:13:43.682]                 for (kk in seq_along(NAMES)) {
[16:13:43.682]                   name <- removed[[kk]]
[16:13:43.682]                   NAME <- NAMES[[kk]]
[16:13:43.682]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:43.682]                     next
[16:13:43.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:43.682]                 }
[16:13:43.682]                 if (length(args) > 0) 
[16:13:43.682]                   base::do.call(base::Sys.setenv, args = args)
[16:13:43.682]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:43.682]             }
[16:13:43.682]             else {
[16:13:43.682]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:43.682]             }
[16:13:43.682]             {
[16:13:43.682]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:43.682]                   0L) {
[16:13:43.682]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:43.682]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:43.682]                   base::options(opts)
[16:13:43.682]                 }
[16:13:43.682]                 {
[16:13:43.682]                   {
[16:13:43.682]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:43.682]                     NULL
[16:13:43.682]                   }
[16:13:43.682]                   options(future.plan = NULL)
[16:13:43.682]                   if (is.na(NA_character_)) 
[16:13:43.682]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:43.682]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:43.682]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:43.682]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:43.682]                     envir = parent.frame()) 
[16:13:43.682]                   {
[16:13:43.682]                     if (is.function(workers)) 
[16:13:43.682]                       workers <- workers()
[16:13:43.682]                     workers <- structure(as.integer(workers), 
[16:13:43.682]                       class = class(workers))
[16:13:43.682]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:43.682]                       workers >= 1)
[16:13:43.682]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:43.682]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:43.682]                     }
[16:13:43.682]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:43.682]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:43.682]                       envir = envir)
[16:13:43.682]                     if (!future$lazy) 
[16:13:43.682]                       future <- run(future)
[16:13:43.682]                     invisible(future)
[16:13:43.682]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:43.682]                 }
[16:13:43.682]             }
[16:13:43.682]         }
[16:13:43.682]     })
[16:13:43.682]     if (TRUE) {
[16:13:43.682]         base::sink(type = "output", split = FALSE)
[16:13:43.682]         if (TRUE) {
[16:13:43.682]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:43.682]         }
[16:13:43.682]         else {
[16:13:43.682]             ...future.result["stdout"] <- base::list(NULL)
[16:13:43.682]         }
[16:13:43.682]         base::close(...future.stdout)
[16:13:43.682]         ...future.stdout <- NULL
[16:13:43.682]     }
[16:13:43.682]     ...future.result$conditions <- ...future.conditions
[16:13:43.682]     ...future.result$finished <- base::Sys.time()
[16:13:43.682]     ...future.result
[16:13:43.682] }
[16:13:43.686] MultisessionFuture started
[16:13:43.686] - Launch lazy future ... done
[16:13:43.686] run() for ‘MultisessionFuture’ ... done
[16:13:44.234] receiveMessageFromWorker() for ClusterFuture ...
[16:13:44.234] - Validating connection of MultisessionFuture
[16:13:44.234] - received message: FutureResult
[16:13:44.234] - Received FutureResult
[16:13:44.234] - Erased future from FutureRegistry
[16:13:44.235] result() for ClusterFuture ...
[16:13:44.235] - result already collected: FutureResult
[16:13:44.235] result() for ClusterFuture ... done
[16:13:44.235] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:44.235] A MultisessionFuture was resolved (result was not collected)
[16:13:44.235] getGlobalsAndPackages() ...
[16:13:44.235] Searching for globals...
[16:13:44.237] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:44.237] Searching for globals ... DONE
[16:13:44.237] Resolving globals: FALSE
[16:13:44.237] 
[16:13:44.238] 
[16:13:44.238] getGlobalsAndPackages() ... DONE
[16:13:44.238] run() for ‘Future’ ...
[16:13:44.238] - state: ‘created’
[16:13:44.238] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:44.253] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:44.253] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:44.253]   - Field: ‘node’
[16:13:44.254]   - Field: ‘label’
[16:13:44.254]   - Field: ‘local’
[16:13:44.254]   - Field: ‘owner’
[16:13:44.254]   - Field: ‘envir’
[16:13:44.254]   - Field: ‘workers’
[16:13:44.254]   - Field: ‘packages’
[16:13:44.254]   - Field: ‘gc’
[16:13:44.254]   - Field: ‘conditions’
[16:13:44.254]   - Field: ‘persistent’
[16:13:44.254]   - Field: ‘expr’
[16:13:44.255]   - Field: ‘uuid’
[16:13:44.255]   - Field: ‘seed’
[16:13:44.255]   - Field: ‘version’
[16:13:44.255]   - Field: ‘result’
[16:13:44.255]   - Field: ‘asynchronous’
[16:13:44.255]   - Field: ‘calls’
[16:13:44.255]   - Field: ‘globals’
[16:13:44.255]   - Field: ‘stdout’
[16:13:44.255]   - Field: ‘earlySignal’
[16:13:44.256]   - Field: ‘lazy’
[16:13:44.256]   - Field: ‘state’
[16:13:44.256] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:44.256] - Launch lazy future ...
[16:13:44.256] Packages needed by the future expression (n = 0): <none>
[16:13:44.256] Packages needed by future strategies (n = 0): <none>
[16:13:44.257] {
[16:13:44.257]     {
[16:13:44.257]         {
[16:13:44.257]             ...future.startTime <- base::Sys.time()
[16:13:44.257]             {
[16:13:44.257]                 {
[16:13:44.257]                   {
[16:13:44.257]                     {
[16:13:44.257]                       base::local({
[16:13:44.257]                         has_future <- base::requireNamespace("future", 
[16:13:44.257]                           quietly = TRUE)
[16:13:44.257]                         if (has_future) {
[16:13:44.257]                           ns <- base::getNamespace("future")
[16:13:44.257]                           version <- ns[[".package"]][["version"]]
[16:13:44.257]                           if (is.null(version)) 
[16:13:44.257]                             version <- utils::packageVersion("future")
[16:13:44.257]                         }
[16:13:44.257]                         else {
[16:13:44.257]                           version <- NULL
[16:13:44.257]                         }
[16:13:44.257]                         if (!has_future || version < "1.8.0") {
[16:13:44.257]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:44.257]                             "", base::R.version$version.string), 
[16:13:44.257]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:44.257]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:44.257]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:44.257]                               "release", "version")], collapse = " "), 
[16:13:44.257]                             hostname = base::Sys.info()[["nodename"]])
[16:13:44.257]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:44.257]                             info)
[16:13:44.257]                           info <- base::paste(info, collapse = "; ")
[16:13:44.257]                           if (!has_future) {
[16:13:44.257]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:44.257]                               info)
[16:13:44.257]                           }
[16:13:44.257]                           else {
[16:13:44.257]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:44.257]                               info, version)
[16:13:44.257]                           }
[16:13:44.257]                           base::stop(msg)
[16:13:44.257]                         }
[16:13:44.257]                       })
[16:13:44.257]                     }
[16:13:44.257]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:44.257]                     base::options(mc.cores = 1L)
[16:13:44.257]                   }
[16:13:44.257]                   options(future.plan = NULL)
[16:13:44.257]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:44.257]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:44.257]                 }
[16:13:44.257]                 ...future.workdir <- getwd()
[16:13:44.257]             }
[16:13:44.257]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:44.257]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:44.257]         }
[16:13:44.257]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:44.257]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:44.257]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:44.257]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:44.257]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:44.257]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:44.257]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:44.257]             base::names(...future.oldOptions))
[16:13:44.257]     }
[16:13:44.257]     if (FALSE) {
[16:13:44.257]     }
[16:13:44.257]     else {
[16:13:44.257]         if (TRUE) {
[16:13:44.257]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:44.257]                 open = "w")
[16:13:44.257]         }
[16:13:44.257]         else {
[16:13:44.257]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:44.257]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:44.257]         }
[16:13:44.257]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:44.257]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:44.257]             base::sink(type = "output", split = FALSE)
[16:13:44.257]             base::close(...future.stdout)
[16:13:44.257]         }, add = TRUE)
[16:13:44.257]     }
[16:13:44.257]     ...future.frame <- base::sys.nframe()
[16:13:44.257]     ...future.conditions <- base::list()
[16:13:44.257]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:44.257]     if (FALSE) {
[16:13:44.257]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:44.257]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:44.257]     }
[16:13:44.257]     ...future.result <- base::tryCatch({
[16:13:44.257]         base::withCallingHandlers({
[16:13:44.257]             ...future.value <- base::withVisible(base::local({
[16:13:44.257]                 ...future.makeSendCondition <- local({
[16:13:44.257]                   sendCondition <- NULL
[16:13:44.257]                   function(frame = 1L) {
[16:13:44.257]                     if (is.function(sendCondition)) 
[16:13:44.257]                       return(sendCondition)
[16:13:44.257]                     ns <- getNamespace("parallel")
[16:13:44.257]                     if (exists("sendData", mode = "function", 
[16:13:44.257]                       envir = ns)) {
[16:13:44.257]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:44.257]                         envir = ns)
[16:13:44.257]                       envir <- sys.frame(frame)
[16:13:44.257]                       master <- NULL
[16:13:44.257]                       while (!identical(envir, .GlobalEnv) && 
[16:13:44.257]                         !identical(envir, emptyenv())) {
[16:13:44.257]                         if (exists("master", mode = "list", envir = envir, 
[16:13:44.257]                           inherits = FALSE)) {
[16:13:44.257]                           master <- get("master", mode = "list", 
[16:13:44.257]                             envir = envir, inherits = FALSE)
[16:13:44.257]                           if (inherits(master, c("SOCKnode", 
[16:13:44.257]                             "SOCK0node"))) {
[16:13:44.257]                             sendCondition <<- function(cond) {
[16:13:44.257]                               data <- list(type = "VALUE", value = cond, 
[16:13:44.257]                                 success = TRUE)
[16:13:44.257]                               parallel_sendData(master, data)
[16:13:44.257]                             }
[16:13:44.257]                             return(sendCondition)
[16:13:44.257]                           }
[16:13:44.257]                         }
[16:13:44.257]                         frame <- frame + 1L
[16:13:44.257]                         envir <- sys.frame(frame)
[16:13:44.257]                       }
[16:13:44.257]                     }
[16:13:44.257]                     sendCondition <<- function(cond) NULL
[16:13:44.257]                   }
[16:13:44.257]                 })
[16:13:44.257]                 withCallingHandlers({
[16:13:44.257]                   {
[16:13:44.257]                     Sys.sleep(0.5)
[16:13:44.257]                     list(a = 1, b = 42L)
[16:13:44.257]                   }
[16:13:44.257]                 }, immediateCondition = function(cond) {
[16:13:44.257]                   sendCondition <- ...future.makeSendCondition()
[16:13:44.257]                   sendCondition(cond)
[16:13:44.257]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:44.257]                   {
[16:13:44.257]                     inherits <- base::inherits
[16:13:44.257]                     invokeRestart <- base::invokeRestart
[16:13:44.257]                     is.null <- base::is.null
[16:13:44.257]                     muffled <- FALSE
[16:13:44.257]                     if (inherits(cond, "message")) {
[16:13:44.257]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:44.257]                       if (muffled) 
[16:13:44.257]                         invokeRestart("muffleMessage")
[16:13:44.257]                     }
[16:13:44.257]                     else if (inherits(cond, "warning")) {
[16:13:44.257]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:44.257]                       if (muffled) 
[16:13:44.257]                         invokeRestart("muffleWarning")
[16:13:44.257]                     }
[16:13:44.257]                     else if (inherits(cond, "condition")) {
[16:13:44.257]                       if (!is.null(pattern)) {
[16:13:44.257]                         computeRestarts <- base::computeRestarts
[16:13:44.257]                         grepl <- base::grepl
[16:13:44.257]                         restarts <- computeRestarts(cond)
[16:13:44.257]                         for (restart in restarts) {
[16:13:44.257]                           name <- restart$name
[16:13:44.257]                           if (is.null(name)) 
[16:13:44.257]                             next
[16:13:44.257]                           if (!grepl(pattern, name)) 
[16:13:44.257]                             next
[16:13:44.257]                           invokeRestart(restart)
[16:13:44.257]                           muffled <- TRUE
[16:13:44.257]                           break
[16:13:44.257]                         }
[16:13:44.257]                       }
[16:13:44.257]                     }
[16:13:44.257]                     invisible(muffled)
[16:13:44.257]                   }
[16:13:44.257]                   muffleCondition(cond)
[16:13:44.257]                 })
[16:13:44.257]             }))
[16:13:44.257]             future::FutureResult(value = ...future.value$value, 
[16:13:44.257]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:44.257]                   ...future.rng), globalenv = if (FALSE) 
[16:13:44.257]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:44.257]                     ...future.globalenv.names))
[16:13:44.257]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:44.257]         }, condition = base::local({
[16:13:44.257]             c <- base::c
[16:13:44.257]             inherits <- base::inherits
[16:13:44.257]             invokeRestart <- base::invokeRestart
[16:13:44.257]             length <- base::length
[16:13:44.257]             list <- base::list
[16:13:44.257]             seq.int <- base::seq.int
[16:13:44.257]             signalCondition <- base::signalCondition
[16:13:44.257]             sys.calls <- base::sys.calls
[16:13:44.257]             `[[` <- base::`[[`
[16:13:44.257]             `+` <- base::`+`
[16:13:44.257]             `<<-` <- base::`<<-`
[16:13:44.257]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:44.257]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:44.257]                   3L)]
[16:13:44.257]             }
[16:13:44.257]             function(cond) {
[16:13:44.257]                 is_error <- inherits(cond, "error")
[16:13:44.257]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:44.257]                   NULL)
[16:13:44.257]                 if (is_error) {
[16:13:44.257]                   sessionInformation <- function() {
[16:13:44.257]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:44.257]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:44.257]                       search = base::search(), system = base::Sys.info())
[16:13:44.257]                   }
[16:13:44.257]                   ...future.conditions[[length(...future.conditions) + 
[16:13:44.257]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:44.257]                     cond$call), session = sessionInformation(), 
[16:13:44.257]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:44.257]                   signalCondition(cond)
[16:13:44.257]                 }
[16:13:44.257]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:44.257]                 "immediateCondition"))) {
[16:13:44.257]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:44.257]                   ...future.conditions[[length(...future.conditions) + 
[16:13:44.257]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:44.257]                   if (TRUE && !signal) {
[16:13:44.257]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:44.257]                     {
[16:13:44.257]                       inherits <- base::inherits
[16:13:44.257]                       invokeRestart <- base::invokeRestart
[16:13:44.257]                       is.null <- base::is.null
[16:13:44.257]                       muffled <- FALSE
[16:13:44.257]                       if (inherits(cond, "message")) {
[16:13:44.257]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:44.257]                         if (muffled) 
[16:13:44.257]                           invokeRestart("muffleMessage")
[16:13:44.257]                       }
[16:13:44.257]                       else if (inherits(cond, "warning")) {
[16:13:44.257]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:44.257]                         if (muffled) 
[16:13:44.257]                           invokeRestart("muffleWarning")
[16:13:44.257]                       }
[16:13:44.257]                       else if (inherits(cond, "condition")) {
[16:13:44.257]                         if (!is.null(pattern)) {
[16:13:44.257]                           computeRestarts <- base::computeRestarts
[16:13:44.257]                           grepl <- base::grepl
[16:13:44.257]                           restarts <- computeRestarts(cond)
[16:13:44.257]                           for (restart in restarts) {
[16:13:44.257]                             name <- restart$name
[16:13:44.257]                             if (is.null(name)) 
[16:13:44.257]                               next
[16:13:44.257]                             if (!grepl(pattern, name)) 
[16:13:44.257]                               next
[16:13:44.257]                             invokeRestart(restart)
[16:13:44.257]                             muffled <- TRUE
[16:13:44.257]                             break
[16:13:44.257]                           }
[16:13:44.257]                         }
[16:13:44.257]                       }
[16:13:44.257]                       invisible(muffled)
[16:13:44.257]                     }
[16:13:44.257]                     muffleCondition(cond, pattern = "^muffle")
[16:13:44.257]                   }
[16:13:44.257]                 }
[16:13:44.257]                 else {
[16:13:44.257]                   if (TRUE) {
[16:13:44.257]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:44.257]                     {
[16:13:44.257]                       inherits <- base::inherits
[16:13:44.257]                       invokeRestart <- base::invokeRestart
[16:13:44.257]                       is.null <- base::is.null
[16:13:44.257]                       muffled <- FALSE
[16:13:44.257]                       if (inherits(cond, "message")) {
[16:13:44.257]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:44.257]                         if (muffled) 
[16:13:44.257]                           invokeRestart("muffleMessage")
[16:13:44.257]                       }
[16:13:44.257]                       else if (inherits(cond, "warning")) {
[16:13:44.257]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:44.257]                         if (muffled) 
[16:13:44.257]                           invokeRestart("muffleWarning")
[16:13:44.257]                       }
[16:13:44.257]                       else if (inherits(cond, "condition")) {
[16:13:44.257]                         if (!is.null(pattern)) {
[16:13:44.257]                           computeRestarts <- base::computeRestarts
[16:13:44.257]                           grepl <- base::grepl
[16:13:44.257]                           restarts <- computeRestarts(cond)
[16:13:44.257]                           for (restart in restarts) {
[16:13:44.257]                             name <- restart$name
[16:13:44.257]                             if (is.null(name)) 
[16:13:44.257]                               next
[16:13:44.257]                             if (!grepl(pattern, name)) 
[16:13:44.257]                               next
[16:13:44.257]                             invokeRestart(restart)
[16:13:44.257]                             muffled <- TRUE
[16:13:44.257]                             break
[16:13:44.257]                           }
[16:13:44.257]                         }
[16:13:44.257]                       }
[16:13:44.257]                       invisible(muffled)
[16:13:44.257]                     }
[16:13:44.257]                     muffleCondition(cond, pattern = "^muffle")
[16:13:44.257]                   }
[16:13:44.257]                 }
[16:13:44.257]             }
[16:13:44.257]         }))
[16:13:44.257]     }, error = function(ex) {
[16:13:44.257]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:44.257]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:44.257]                 ...future.rng), started = ...future.startTime, 
[16:13:44.257]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:44.257]             version = "1.8"), class = "FutureResult")
[16:13:44.257]     }, finally = {
[16:13:44.257]         if (!identical(...future.workdir, getwd())) 
[16:13:44.257]             setwd(...future.workdir)
[16:13:44.257]         {
[16:13:44.257]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:44.257]                 ...future.oldOptions$nwarnings <- NULL
[16:13:44.257]             }
[16:13:44.257]             base::options(...future.oldOptions)
[16:13:44.257]             if (.Platform$OS.type == "windows") {
[16:13:44.257]                 old_names <- names(...future.oldEnvVars)
[16:13:44.257]                 envs <- base::Sys.getenv()
[16:13:44.257]                 names <- names(envs)
[16:13:44.257]                 common <- intersect(names, old_names)
[16:13:44.257]                 added <- setdiff(names, old_names)
[16:13:44.257]                 removed <- setdiff(old_names, names)
[16:13:44.257]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:44.257]                   envs[common]]
[16:13:44.257]                 NAMES <- toupper(changed)
[16:13:44.257]                 args <- list()
[16:13:44.257]                 for (kk in seq_along(NAMES)) {
[16:13:44.257]                   name <- changed[[kk]]
[16:13:44.257]                   NAME <- NAMES[[kk]]
[16:13:44.257]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:44.257]                     next
[16:13:44.257]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:44.257]                 }
[16:13:44.257]                 NAMES <- toupper(added)
[16:13:44.257]                 for (kk in seq_along(NAMES)) {
[16:13:44.257]                   name <- added[[kk]]
[16:13:44.257]                   NAME <- NAMES[[kk]]
[16:13:44.257]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:44.257]                     next
[16:13:44.257]                   args[[name]] <- ""
[16:13:44.257]                 }
[16:13:44.257]                 NAMES <- toupper(removed)
[16:13:44.257]                 for (kk in seq_along(NAMES)) {
[16:13:44.257]                   name <- removed[[kk]]
[16:13:44.257]                   NAME <- NAMES[[kk]]
[16:13:44.257]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:44.257]                     next
[16:13:44.257]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:44.257]                 }
[16:13:44.257]                 if (length(args) > 0) 
[16:13:44.257]                   base::do.call(base::Sys.setenv, args = args)
[16:13:44.257]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:44.257]             }
[16:13:44.257]             else {
[16:13:44.257]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:44.257]             }
[16:13:44.257]             {
[16:13:44.257]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:44.257]                   0L) {
[16:13:44.257]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:44.257]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:44.257]                   base::options(opts)
[16:13:44.257]                 }
[16:13:44.257]                 {
[16:13:44.257]                   {
[16:13:44.257]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:44.257]                     NULL
[16:13:44.257]                   }
[16:13:44.257]                   options(future.plan = NULL)
[16:13:44.257]                   if (is.na(NA_character_)) 
[16:13:44.257]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:44.257]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:44.257]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:44.257]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:44.257]                     envir = parent.frame()) 
[16:13:44.257]                   {
[16:13:44.257]                     if (is.function(workers)) 
[16:13:44.257]                       workers <- workers()
[16:13:44.257]                     workers <- structure(as.integer(workers), 
[16:13:44.257]                       class = class(workers))
[16:13:44.257]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:44.257]                       workers >= 1)
[16:13:44.257]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:44.257]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:44.257]                     }
[16:13:44.257]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:44.257]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:44.257]                       envir = envir)
[16:13:44.257]                     if (!future$lazy) 
[16:13:44.257]                       future <- run(future)
[16:13:44.257]                     invisible(future)
[16:13:44.257]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:44.257]                 }
[16:13:44.257]             }
[16:13:44.257]         }
[16:13:44.257]     })
[16:13:44.257]     if (TRUE) {
[16:13:44.257]         base::sink(type = "output", split = FALSE)
[16:13:44.257]         if (TRUE) {
[16:13:44.257]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:44.257]         }
[16:13:44.257]         else {
[16:13:44.257]             ...future.result["stdout"] <- base::list(NULL)
[16:13:44.257]         }
[16:13:44.257]         base::close(...future.stdout)
[16:13:44.257]         ...future.stdout <- NULL
[16:13:44.257]     }
[16:13:44.257]     ...future.result$conditions <- ...future.conditions
[16:13:44.257]     ...future.result$finished <- base::Sys.time()
[16:13:44.257]     ...future.result
[16:13:44.257] }
[16:13:44.260] MultisessionFuture started
[16:13:44.261] - Launch lazy future ... done
[16:13:44.261] run() for ‘MultisessionFuture’ ... done
[16:13:44.820] receiveMessageFromWorker() for ClusterFuture ...
[16:13:44.820] - Validating connection of MultisessionFuture
[16:13:44.820] - received message: FutureResult
[16:13:44.820] - Received FutureResult
[16:13:44.820] - Erased future from FutureRegistry
[16:13:44.821] result() for ClusterFuture ...
[16:13:44.821] - result already collected: FutureResult
[16:13:44.821] result() for ClusterFuture ... done
[16:13:44.821] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:44.821] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[16:13:44.821] getGlobalsAndPackages() ...
[16:13:44.821] Searching for globals...
[16:13:44.822] - globals found: [2] ‘list’, ‘stop’
[16:13:44.822] Searching for globals ... DONE
[16:13:44.823] Resolving globals: FALSE
[16:13:44.823] 
[16:13:44.823] 
[16:13:44.823] getGlobalsAndPackages() ... DONE
[16:13:44.823] run() for ‘Future’ ...
[16:13:44.824] - state: ‘created’
[16:13:44.824] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:44.840] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:44.840] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:44.840]   - Field: ‘node’
[16:13:44.840]   - Field: ‘label’
[16:13:44.840]   - Field: ‘local’
[16:13:44.840]   - Field: ‘owner’
[16:13:44.840]   - Field: ‘envir’
[16:13:44.841]   - Field: ‘workers’
[16:13:44.841]   - Field: ‘packages’
[16:13:44.841]   - Field: ‘gc’
[16:13:44.841]   - Field: ‘conditions’
[16:13:44.841]   - Field: ‘persistent’
[16:13:44.841]   - Field: ‘expr’
[16:13:44.841]   - Field: ‘uuid’
[16:13:44.841]   - Field: ‘seed’
[16:13:44.841]   - Field: ‘version’
[16:13:44.841]   - Field: ‘result’
[16:13:44.841]   - Field: ‘asynchronous’
[16:13:44.842]   - Field: ‘calls’
[16:13:44.842]   - Field: ‘globals’
[16:13:44.842]   - Field: ‘stdout’
[16:13:44.842]   - Field: ‘earlySignal’
[16:13:44.842]   - Field: ‘lazy’
[16:13:44.842]   - Field: ‘state’
[16:13:44.842] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:44.842] - Launch lazy future ...
[16:13:44.842] Packages needed by the future expression (n = 0): <none>
[16:13:44.843] Packages needed by future strategies (n = 0): <none>
[16:13:44.843] {
[16:13:44.843]     {
[16:13:44.843]         {
[16:13:44.843]             ...future.startTime <- base::Sys.time()
[16:13:44.843]             {
[16:13:44.843]                 {
[16:13:44.843]                   {
[16:13:44.843]                     {
[16:13:44.843]                       base::local({
[16:13:44.843]                         has_future <- base::requireNamespace("future", 
[16:13:44.843]                           quietly = TRUE)
[16:13:44.843]                         if (has_future) {
[16:13:44.843]                           ns <- base::getNamespace("future")
[16:13:44.843]                           version <- ns[[".package"]][["version"]]
[16:13:44.843]                           if (is.null(version)) 
[16:13:44.843]                             version <- utils::packageVersion("future")
[16:13:44.843]                         }
[16:13:44.843]                         else {
[16:13:44.843]                           version <- NULL
[16:13:44.843]                         }
[16:13:44.843]                         if (!has_future || version < "1.8.0") {
[16:13:44.843]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:44.843]                             "", base::R.version$version.string), 
[16:13:44.843]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:44.843]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:44.843]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:44.843]                               "release", "version")], collapse = " "), 
[16:13:44.843]                             hostname = base::Sys.info()[["nodename"]])
[16:13:44.843]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:44.843]                             info)
[16:13:44.843]                           info <- base::paste(info, collapse = "; ")
[16:13:44.843]                           if (!has_future) {
[16:13:44.843]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:44.843]                               info)
[16:13:44.843]                           }
[16:13:44.843]                           else {
[16:13:44.843]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:44.843]                               info, version)
[16:13:44.843]                           }
[16:13:44.843]                           base::stop(msg)
[16:13:44.843]                         }
[16:13:44.843]                       })
[16:13:44.843]                     }
[16:13:44.843]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:44.843]                     base::options(mc.cores = 1L)
[16:13:44.843]                   }
[16:13:44.843]                   options(future.plan = NULL)
[16:13:44.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:44.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:44.843]                 }
[16:13:44.843]                 ...future.workdir <- getwd()
[16:13:44.843]             }
[16:13:44.843]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:44.843]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:44.843]         }
[16:13:44.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:44.843]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:44.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:44.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:44.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:44.843]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:44.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:44.843]             base::names(...future.oldOptions))
[16:13:44.843]     }
[16:13:44.843]     if (FALSE) {
[16:13:44.843]     }
[16:13:44.843]     else {
[16:13:44.843]         if (TRUE) {
[16:13:44.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:44.843]                 open = "w")
[16:13:44.843]         }
[16:13:44.843]         else {
[16:13:44.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:44.843]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:44.843]         }
[16:13:44.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:44.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:44.843]             base::sink(type = "output", split = FALSE)
[16:13:44.843]             base::close(...future.stdout)
[16:13:44.843]         }, add = TRUE)
[16:13:44.843]     }
[16:13:44.843]     ...future.frame <- base::sys.nframe()
[16:13:44.843]     ...future.conditions <- base::list()
[16:13:44.843]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:44.843]     if (FALSE) {
[16:13:44.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:44.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:44.843]     }
[16:13:44.843]     ...future.result <- base::tryCatch({
[16:13:44.843]         base::withCallingHandlers({
[16:13:44.843]             ...future.value <- base::withVisible(base::local({
[16:13:44.843]                 ...future.makeSendCondition <- local({
[16:13:44.843]                   sendCondition <- NULL
[16:13:44.843]                   function(frame = 1L) {
[16:13:44.843]                     if (is.function(sendCondition)) 
[16:13:44.843]                       return(sendCondition)
[16:13:44.843]                     ns <- getNamespace("parallel")
[16:13:44.843]                     if (exists("sendData", mode = "function", 
[16:13:44.843]                       envir = ns)) {
[16:13:44.843]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:44.843]                         envir = ns)
[16:13:44.843]                       envir <- sys.frame(frame)
[16:13:44.843]                       master <- NULL
[16:13:44.843]                       while (!identical(envir, .GlobalEnv) && 
[16:13:44.843]                         !identical(envir, emptyenv())) {
[16:13:44.843]                         if (exists("master", mode = "list", envir = envir, 
[16:13:44.843]                           inherits = FALSE)) {
[16:13:44.843]                           master <- get("master", mode = "list", 
[16:13:44.843]                             envir = envir, inherits = FALSE)
[16:13:44.843]                           if (inherits(master, c("SOCKnode", 
[16:13:44.843]                             "SOCK0node"))) {
[16:13:44.843]                             sendCondition <<- function(cond) {
[16:13:44.843]                               data <- list(type = "VALUE", value = cond, 
[16:13:44.843]                                 success = TRUE)
[16:13:44.843]                               parallel_sendData(master, data)
[16:13:44.843]                             }
[16:13:44.843]                             return(sendCondition)
[16:13:44.843]                           }
[16:13:44.843]                         }
[16:13:44.843]                         frame <- frame + 1L
[16:13:44.843]                         envir <- sys.frame(frame)
[16:13:44.843]                       }
[16:13:44.843]                     }
[16:13:44.843]                     sendCondition <<- function(cond) NULL
[16:13:44.843]                   }
[16:13:44.843]                 })
[16:13:44.843]                 withCallingHandlers({
[16:13:44.843]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:44.843]                 }, immediateCondition = function(cond) {
[16:13:44.843]                   sendCondition <- ...future.makeSendCondition()
[16:13:44.843]                   sendCondition(cond)
[16:13:44.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:44.843]                   {
[16:13:44.843]                     inherits <- base::inherits
[16:13:44.843]                     invokeRestart <- base::invokeRestart
[16:13:44.843]                     is.null <- base::is.null
[16:13:44.843]                     muffled <- FALSE
[16:13:44.843]                     if (inherits(cond, "message")) {
[16:13:44.843]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:44.843]                       if (muffled) 
[16:13:44.843]                         invokeRestart("muffleMessage")
[16:13:44.843]                     }
[16:13:44.843]                     else if (inherits(cond, "warning")) {
[16:13:44.843]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:44.843]                       if (muffled) 
[16:13:44.843]                         invokeRestart("muffleWarning")
[16:13:44.843]                     }
[16:13:44.843]                     else if (inherits(cond, "condition")) {
[16:13:44.843]                       if (!is.null(pattern)) {
[16:13:44.843]                         computeRestarts <- base::computeRestarts
[16:13:44.843]                         grepl <- base::grepl
[16:13:44.843]                         restarts <- computeRestarts(cond)
[16:13:44.843]                         for (restart in restarts) {
[16:13:44.843]                           name <- restart$name
[16:13:44.843]                           if (is.null(name)) 
[16:13:44.843]                             next
[16:13:44.843]                           if (!grepl(pattern, name)) 
[16:13:44.843]                             next
[16:13:44.843]                           invokeRestart(restart)
[16:13:44.843]                           muffled <- TRUE
[16:13:44.843]                           break
[16:13:44.843]                         }
[16:13:44.843]                       }
[16:13:44.843]                     }
[16:13:44.843]                     invisible(muffled)
[16:13:44.843]                   }
[16:13:44.843]                   muffleCondition(cond)
[16:13:44.843]                 })
[16:13:44.843]             }))
[16:13:44.843]             future::FutureResult(value = ...future.value$value, 
[16:13:44.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:44.843]                   ...future.rng), globalenv = if (FALSE) 
[16:13:44.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:44.843]                     ...future.globalenv.names))
[16:13:44.843]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:44.843]         }, condition = base::local({
[16:13:44.843]             c <- base::c
[16:13:44.843]             inherits <- base::inherits
[16:13:44.843]             invokeRestart <- base::invokeRestart
[16:13:44.843]             length <- base::length
[16:13:44.843]             list <- base::list
[16:13:44.843]             seq.int <- base::seq.int
[16:13:44.843]             signalCondition <- base::signalCondition
[16:13:44.843]             sys.calls <- base::sys.calls
[16:13:44.843]             `[[` <- base::`[[`
[16:13:44.843]             `+` <- base::`+`
[16:13:44.843]             `<<-` <- base::`<<-`
[16:13:44.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:44.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:44.843]                   3L)]
[16:13:44.843]             }
[16:13:44.843]             function(cond) {
[16:13:44.843]                 is_error <- inherits(cond, "error")
[16:13:44.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:44.843]                   NULL)
[16:13:44.843]                 if (is_error) {
[16:13:44.843]                   sessionInformation <- function() {
[16:13:44.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:44.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:44.843]                       search = base::search(), system = base::Sys.info())
[16:13:44.843]                   }
[16:13:44.843]                   ...future.conditions[[length(...future.conditions) + 
[16:13:44.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:44.843]                     cond$call), session = sessionInformation(), 
[16:13:44.843]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:44.843]                   signalCondition(cond)
[16:13:44.843]                 }
[16:13:44.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:44.843]                 "immediateCondition"))) {
[16:13:44.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:44.843]                   ...future.conditions[[length(...future.conditions) + 
[16:13:44.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:44.843]                   if (TRUE && !signal) {
[16:13:44.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:44.843]                     {
[16:13:44.843]                       inherits <- base::inherits
[16:13:44.843]                       invokeRestart <- base::invokeRestart
[16:13:44.843]                       is.null <- base::is.null
[16:13:44.843]                       muffled <- FALSE
[16:13:44.843]                       if (inherits(cond, "message")) {
[16:13:44.843]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:44.843]                         if (muffled) 
[16:13:44.843]                           invokeRestart("muffleMessage")
[16:13:44.843]                       }
[16:13:44.843]                       else if (inherits(cond, "warning")) {
[16:13:44.843]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:44.843]                         if (muffled) 
[16:13:44.843]                           invokeRestart("muffleWarning")
[16:13:44.843]                       }
[16:13:44.843]                       else if (inherits(cond, "condition")) {
[16:13:44.843]                         if (!is.null(pattern)) {
[16:13:44.843]                           computeRestarts <- base::computeRestarts
[16:13:44.843]                           grepl <- base::grepl
[16:13:44.843]                           restarts <- computeRestarts(cond)
[16:13:44.843]                           for (restart in restarts) {
[16:13:44.843]                             name <- restart$name
[16:13:44.843]                             if (is.null(name)) 
[16:13:44.843]                               next
[16:13:44.843]                             if (!grepl(pattern, name)) 
[16:13:44.843]                               next
[16:13:44.843]                             invokeRestart(restart)
[16:13:44.843]                             muffled <- TRUE
[16:13:44.843]                             break
[16:13:44.843]                           }
[16:13:44.843]                         }
[16:13:44.843]                       }
[16:13:44.843]                       invisible(muffled)
[16:13:44.843]                     }
[16:13:44.843]                     muffleCondition(cond, pattern = "^muffle")
[16:13:44.843]                   }
[16:13:44.843]                 }
[16:13:44.843]                 else {
[16:13:44.843]                   if (TRUE) {
[16:13:44.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:44.843]                     {
[16:13:44.843]                       inherits <- base::inherits
[16:13:44.843]                       invokeRestart <- base::invokeRestart
[16:13:44.843]                       is.null <- base::is.null
[16:13:44.843]                       muffled <- FALSE
[16:13:44.843]                       if (inherits(cond, "message")) {
[16:13:44.843]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:44.843]                         if (muffled) 
[16:13:44.843]                           invokeRestart("muffleMessage")
[16:13:44.843]                       }
[16:13:44.843]                       else if (inherits(cond, "warning")) {
[16:13:44.843]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:44.843]                         if (muffled) 
[16:13:44.843]                           invokeRestart("muffleWarning")
[16:13:44.843]                       }
[16:13:44.843]                       else if (inherits(cond, "condition")) {
[16:13:44.843]                         if (!is.null(pattern)) {
[16:13:44.843]                           computeRestarts <- base::computeRestarts
[16:13:44.843]                           grepl <- base::grepl
[16:13:44.843]                           restarts <- computeRestarts(cond)
[16:13:44.843]                           for (restart in restarts) {
[16:13:44.843]                             name <- restart$name
[16:13:44.843]                             if (is.null(name)) 
[16:13:44.843]                               next
[16:13:44.843]                             if (!grepl(pattern, name)) 
[16:13:44.843]                               next
[16:13:44.843]                             invokeRestart(restart)
[16:13:44.843]                             muffled <- TRUE
[16:13:44.843]                             break
[16:13:44.843]                           }
[16:13:44.843]                         }
[16:13:44.843]                       }
[16:13:44.843]                       invisible(muffled)
[16:13:44.843]                     }
[16:13:44.843]                     muffleCondition(cond, pattern = "^muffle")
[16:13:44.843]                   }
[16:13:44.843]                 }
[16:13:44.843]             }
[16:13:44.843]         }))
[16:13:44.843]     }, error = function(ex) {
[16:13:44.843]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:44.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:44.843]                 ...future.rng), started = ...future.startTime, 
[16:13:44.843]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:44.843]             version = "1.8"), class = "FutureResult")
[16:13:44.843]     }, finally = {
[16:13:44.843]         if (!identical(...future.workdir, getwd())) 
[16:13:44.843]             setwd(...future.workdir)
[16:13:44.843]         {
[16:13:44.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:44.843]                 ...future.oldOptions$nwarnings <- NULL
[16:13:44.843]             }
[16:13:44.843]             base::options(...future.oldOptions)
[16:13:44.843]             if (.Platform$OS.type == "windows") {
[16:13:44.843]                 old_names <- names(...future.oldEnvVars)
[16:13:44.843]                 envs <- base::Sys.getenv()
[16:13:44.843]                 names <- names(envs)
[16:13:44.843]                 common <- intersect(names, old_names)
[16:13:44.843]                 added <- setdiff(names, old_names)
[16:13:44.843]                 removed <- setdiff(old_names, names)
[16:13:44.843]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:44.843]                   envs[common]]
[16:13:44.843]                 NAMES <- toupper(changed)
[16:13:44.843]                 args <- list()
[16:13:44.843]                 for (kk in seq_along(NAMES)) {
[16:13:44.843]                   name <- changed[[kk]]
[16:13:44.843]                   NAME <- NAMES[[kk]]
[16:13:44.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:44.843]                     next
[16:13:44.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:44.843]                 }
[16:13:44.843]                 NAMES <- toupper(added)
[16:13:44.843]                 for (kk in seq_along(NAMES)) {
[16:13:44.843]                   name <- added[[kk]]
[16:13:44.843]                   NAME <- NAMES[[kk]]
[16:13:44.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:44.843]                     next
[16:13:44.843]                   args[[name]] <- ""
[16:13:44.843]                 }
[16:13:44.843]                 NAMES <- toupper(removed)
[16:13:44.843]                 for (kk in seq_along(NAMES)) {
[16:13:44.843]                   name <- removed[[kk]]
[16:13:44.843]                   NAME <- NAMES[[kk]]
[16:13:44.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:44.843]                     next
[16:13:44.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:44.843]                 }
[16:13:44.843]                 if (length(args) > 0) 
[16:13:44.843]                   base::do.call(base::Sys.setenv, args = args)
[16:13:44.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:44.843]             }
[16:13:44.843]             else {
[16:13:44.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:44.843]             }
[16:13:44.843]             {
[16:13:44.843]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:44.843]                   0L) {
[16:13:44.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:44.843]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:44.843]                   base::options(opts)
[16:13:44.843]                 }
[16:13:44.843]                 {
[16:13:44.843]                   {
[16:13:44.843]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:44.843]                     NULL
[16:13:44.843]                   }
[16:13:44.843]                   options(future.plan = NULL)
[16:13:44.843]                   if (is.na(NA_character_)) 
[16:13:44.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:44.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:44.843]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:44.843]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:44.843]                     envir = parent.frame()) 
[16:13:44.843]                   {
[16:13:44.843]                     if (is.function(workers)) 
[16:13:44.843]                       workers <- workers()
[16:13:44.843]                     workers <- structure(as.integer(workers), 
[16:13:44.843]                       class = class(workers))
[16:13:44.843]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:44.843]                       workers >= 1)
[16:13:44.843]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:44.843]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:44.843]                     }
[16:13:44.843]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:44.843]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:44.843]                       envir = envir)
[16:13:44.843]                     if (!future$lazy) 
[16:13:44.843]                       future <- run(future)
[16:13:44.843]                     invisible(future)
[16:13:44.843]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:44.843]                 }
[16:13:44.843]             }
[16:13:44.843]         }
[16:13:44.843]     })
[16:13:44.843]     if (TRUE) {
[16:13:44.843]         base::sink(type = "output", split = FALSE)
[16:13:44.843]         if (TRUE) {
[16:13:44.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:44.843]         }
[16:13:44.843]         else {
[16:13:44.843]             ...future.result["stdout"] <- base::list(NULL)
[16:13:44.843]         }
[16:13:44.843]         base::close(...future.stdout)
[16:13:44.843]         ...future.stdout <- NULL
[16:13:44.843]     }
[16:13:44.843]     ...future.result$conditions <- ...future.conditions
[16:13:44.843]     ...future.result$finished <- base::Sys.time()
[16:13:44.843]     ...future.result
[16:13:44.843] }
[16:13:44.846] MultisessionFuture started
[16:13:44.846] - Launch lazy future ... done
[16:13:44.846] run() for ‘MultisessionFuture’ ... done
[16:13:44.893] receiveMessageFromWorker() for ClusterFuture ...
[16:13:44.893] - Validating connection of MultisessionFuture
[16:13:44.894] - received message: FutureResult
[16:13:44.894] - Received FutureResult
[16:13:44.894] - Erased future from FutureRegistry
[16:13:44.894] result() for ClusterFuture ...
[16:13:44.894] - result already collected: FutureResult
[16:13:44.894] result() for ClusterFuture ... done
[16:13:44.894] signalConditions() ...
[16:13:44.894]  - include = ‘immediateCondition’
[16:13:44.895]  - exclude = 
[16:13:44.895]  - resignal = FALSE
[16:13:44.895]  - Number of conditions: 1
[16:13:44.895] signalConditions() ... done
[16:13:44.895] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:44.895] A MultisessionFuture was resolved (result was not collected)
[16:13:44.895] getGlobalsAndPackages() ...
[16:13:44.895] Searching for globals...
[16:13:44.896] - globals found: [2] ‘list’, ‘stop’
[16:13:44.896] Searching for globals ... DONE
[16:13:44.896] Resolving globals: FALSE
[16:13:44.896] 
[16:13:44.897] 
[16:13:44.897] getGlobalsAndPackages() ... DONE
[16:13:44.897] run() for ‘Future’ ...
[16:13:44.897] - state: ‘created’
[16:13:44.897] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:44.912] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:44.912] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:44.912]   - Field: ‘node’
[16:13:44.912]   - Field: ‘label’
[16:13:44.912]   - Field: ‘local’
[16:13:44.912]   - Field: ‘owner’
[16:13:44.913]   - Field: ‘envir’
[16:13:44.913]   - Field: ‘workers’
[16:13:44.913]   - Field: ‘packages’
[16:13:44.913]   - Field: ‘gc’
[16:13:44.913]   - Field: ‘conditions’
[16:13:44.913]   - Field: ‘persistent’
[16:13:44.913]   - Field: ‘expr’
[16:13:44.913]   - Field: ‘uuid’
[16:13:44.913]   - Field: ‘seed’
[16:13:44.913]   - Field: ‘version’
[16:13:44.914]   - Field: ‘result’
[16:13:44.914]   - Field: ‘asynchronous’
[16:13:44.914]   - Field: ‘calls’
[16:13:44.914]   - Field: ‘globals’
[16:13:44.914]   - Field: ‘stdout’
[16:13:44.914]   - Field: ‘earlySignal’
[16:13:44.914]   - Field: ‘lazy’
[16:13:44.914]   - Field: ‘state’
[16:13:44.914] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:44.914] - Launch lazy future ...
[16:13:44.915] Packages needed by the future expression (n = 0): <none>
[16:13:44.915] Packages needed by future strategies (n = 0): <none>
[16:13:44.915] {
[16:13:44.915]     {
[16:13:44.915]         {
[16:13:44.915]             ...future.startTime <- base::Sys.time()
[16:13:44.915]             {
[16:13:44.915]                 {
[16:13:44.915]                   {
[16:13:44.915]                     {
[16:13:44.915]                       base::local({
[16:13:44.915]                         has_future <- base::requireNamespace("future", 
[16:13:44.915]                           quietly = TRUE)
[16:13:44.915]                         if (has_future) {
[16:13:44.915]                           ns <- base::getNamespace("future")
[16:13:44.915]                           version <- ns[[".package"]][["version"]]
[16:13:44.915]                           if (is.null(version)) 
[16:13:44.915]                             version <- utils::packageVersion("future")
[16:13:44.915]                         }
[16:13:44.915]                         else {
[16:13:44.915]                           version <- NULL
[16:13:44.915]                         }
[16:13:44.915]                         if (!has_future || version < "1.8.0") {
[16:13:44.915]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:44.915]                             "", base::R.version$version.string), 
[16:13:44.915]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:44.915]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:44.915]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:44.915]                               "release", "version")], collapse = " "), 
[16:13:44.915]                             hostname = base::Sys.info()[["nodename"]])
[16:13:44.915]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:44.915]                             info)
[16:13:44.915]                           info <- base::paste(info, collapse = "; ")
[16:13:44.915]                           if (!has_future) {
[16:13:44.915]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:44.915]                               info)
[16:13:44.915]                           }
[16:13:44.915]                           else {
[16:13:44.915]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:44.915]                               info, version)
[16:13:44.915]                           }
[16:13:44.915]                           base::stop(msg)
[16:13:44.915]                         }
[16:13:44.915]                       })
[16:13:44.915]                     }
[16:13:44.915]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:44.915]                     base::options(mc.cores = 1L)
[16:13:44.915]                   }
[16:13:44.915]                   options(future.plan = NULL)
[16:13:44.915]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:44.915]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:44.915]                 }
[16:13:44.915]                 ...future.workdir <- getwd()
[16:13:44.915]             }
[16:13:44.915]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:44.915]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:44.915]         }
[16:13:44.915]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:44.915]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:44.915]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:44.915]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:44.915]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:44.915]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:44.915]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:44.915]             base::names(...future.oldOptions))
[16:13:44.915]     }
[16:13:44.915]     if (FALSE) {
[16:13:44.915]     }
[16:13:44.915]     else {
[16:13:44.915]         if (TRUE) {
[16:13:44.915]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:44.915]                 open = "w")
[16:13:44.915]         }
[16:13:44.915]         else {
[16:13:44.915]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:44.915]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:44.915]         }
[16:13:44.915]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:44.915]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:44.915]             base::sink(type = "output", split = FALSE)
[16:13:44.915]             base::close(...future.stdout)
[16:13:44.915]         }, add = TRUE)
[16:13:44.915]     }
[16:13:44.915]     ...future.frame <- base::sys.nframe()
[16:13:44.915]     ...future.conditions <- base::list()
[16:13:44.915]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:44.915]     if (FALSE) {
[16:13:44.915]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:44.915]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:44.915]     }
[16:13:44.915]     ...future.result <- base::tryCatch({
[16:13:44.915]         base::withCallingHandlers({
[16:13:44.915]             ...future.value <- base::withVisible(base::local({
[16:13:44.915]                 ...future.makeSendCondition <- local({
[16:13:44.915]                   sendCondition <- NULL
[16:13:44.915]                   function(frame = 1L) {
[16:13:44.915]                     if (is.function(sendCondition)) 
[16:13:44.915]                       return(sendCondition)
[16:13:44.915]                     ns <- getNamespace("parallel")
[16:13:44.915]                     if (exists("sendData", mode = "function", 
[16:13:44.915]                       envir = ns)) {
[16:13:44.915]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:44.915]                         envir = ns)
[16:13:44.915]                       envir <- sys.frame(frame)
[16:13:44.915]                       master <- NULL
[16:13:44.915]                       while (!identical(envir, .GlobalEnv) && 
[16:13:44.915]                         !identical(envir, emptyenv())) {
[16:13:44.915]                         if (exists("master", mode = "list", envir = envir, 
[16:13:44.915]                           inherits = FALSE)) {
[16:13:44.915]                           master <- get("master", mode = "list", 
[16:13:44.915]                             envir = envir, inherits = FALSE)
[16:13:44.915]                           if (inherits(master, c("SOCKnode", 
[16:13:44.915]                             "SOCK0node"))) {
[16:13:44.915]                             sendCondition <<- function(cond) {
[16:13:44.915]                               data <- list(type = "VALUE", value = cond, 
[16:13:44.915]                                 success = TRUE)
[16:13:44.915]                               parallel_sendData(master, data)
[16:13:44.915]                             }
[16:13:44.915]                             return(sendCondition)
[16:13:44.915]                           }
[16:13:44.915]                         }
[16:13:44.915]                         frame <- frame + 1L
[16:13:44.915]                         envir <- sys.frame(frame)
[16:13:44.915]                       }
[16:13:44.915]                     }
[16:13:44.915]                     sendCondition <<- function(cond) NULL
[16:13:44.915]                   }
[16:13:44.915]                 })
[16:13:44.915]                 withCallingHandlers({
[16:13:44.915]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:44.915]                 }, immediateCondition = function(cond) {
[16:13:44.915]                   sendCondition <- ...future.makeSendCondition()
[16:13:44.915]                   sendCondition(cond)
[16:13:44.915]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:44.915]                   {
[16:13:44.915]                     inherits <- base::inherits
[16:13:44.915]                     invokeRestart <- base::invokeRestart
[16:13:44.915]                     is.null <- base::is.null
[16:13:44.915]                     muffled <- FALSE
[16:13:44.915]                     if (inherits(cond, "message")) {
[16:13:44.915]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:44.915]                       if (muffled) 
[16:13:44.915]                         invokeRestart("muffleMessage")
[16:13:44.915]                     }
[16:13:44.915]                     else if (inherits(cond, "warning")) {
[16:13:44.915]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:44.915]                       if (muffled) 
[16:13:44.915]                         invokeRestart("muffleWarning")
[16:13:44.915]                     }
[16:13:44.915]                     else if (inherits(cond, "condition")) {
[16:13:44.915]                       if (!is.null(pattern)) {
[16:13:44.915]                         computeRestarts <- base::computeRestarts
[16:13:44.915]                         grepl <- base::grepl
[16:13:44.915]                         restarts <- computeRestarts(cond)
[16:13:44.915]                         for (restart in restarts) {
[16:13:44.915]                           name <- restart$name
[16:13:44.915]                           if (is.null(name)) 
[16:13:44.915]                             next
[16:13:44.915]                           if (!grepl(pattern, name)) 
[16:13:44.915]                             next
[16:13:44.915]                           invokeRestart(restart)
[16:13:44.915]                           muffled <- TRUE
[16:13:44.915]                           break
[16:13:44.915]                         }
[16:13:44.915]                       }
[16:13:44.915]                     }
[16:13:44.915]                     invisible(muffled)
[16:13:44.915]                   }
[16:13:44.915]                   muffleCondition(cond)
[16:13:44.915]                 })
[16:13:44.915]             }))
[16:13:44.915]             future::FutureResult(value = ...future.value$value, 
[16:13:44.915]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:44.915]                   ...future.rng), globalenv = if (FALSE) 
[16:13:44.915]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:44.915]                     ...future.globalenv.names))
[16:13:44.915]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:44.915]         }, condition = base::local({
[16:13:44.915]             c <- base::c
[16:13:44.915]             inherits <- base::inherits
[16:13:44.915]             invokeRestart <- base::invokeRestart
[16:13:44.915]             length <- base::length
[16:13:44.915]             list <- base::list
[16:13:44.915]             seq.int <- base::seq.int
[16:13:44.915]             signalCondition <- base::signalCondition
[16:13:44.915]             sys.calls <- base::sys.calls
[16:13:44.915]             `[[` <- base::`[[`
[16:13:44.915]             `+` <- base::`+`
[16:13:44.915]             `<<-` <- base::`<<-`
[16:13:44.915]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:44.915]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:44.915]                   3L)]
[16:13:44.915]             }
[16:13:44.915]             function(cond) {
[16:13:44.915]                 is_error <- inherits(cond, "error")
[16:13:44.915]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:44.915]                   NULL)
[16:13:44.915]                 if (is_error) {
[16:13:44.915]                   sessionInformation <- function() {
[16:13:44.915]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:44.915]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:44.915]                       search = base::search(), system = base::Sys.info())
[16:13:44.915]                   }
[16:13:44.915]                   ...future.conditions[[length(...future.conditions) + 
[16:13:44.915]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:44.915]                     cond$call), session = sessionInformation(), 
[16:13:44.915]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:44.915]                   signalCondition(cond)
[16:13:44.915]                 }
[16:13:44.915]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:44.915]                 "immediateCondition"))) {
[16:13:44.915]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:44.915]                   ...future.conditions[[length(...future.conditions) + 
[16:13:44.915]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:44.915]                   if (TRUE && !signal) {
[16:13:44.915]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:44.915]                     {
[16:13:44.915]                       inherits <- base::inherits
[16:13:44.915]                       invokeRestart <- base::invokeRestart
[16:13:44.915]                       is.null <- base::is.null
[16:13:44.915]                       muffled <- FALSE
[16:13:44.915]                       if (inherits(cond, "message")) {
[16:13:44.915]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:44.915]                         if (muffled) 
[16:13:44.915]                           invokeRestart("muffleMessage")
[16:13:44.915]                       }
[16:13:44.915]                       else if (inherits(cond, "warning")) {
[16:13:44.915]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:44.915]                         if (muffled) 
[16:13:44.915]                           invokeRestart("muffleWarning")
[16:13:44.915]                       }
[16:13:44.915]                       else if (inherits(cond, "condition")) {
[16:13:44.915]                         if (!is.null(pattern)) {
[16:13:44.915]                           computeRestarts <- base::computeRestarts
[16:13:44.915]                           grepl <- base::grepl
[16:13:44.915]                           restarts <- computeRestarts(cond)
[16:13:44.915]                           for (restart in restarts) {
[16:13:44.915]                             name <- restart$name
[16:13:44.915]                             if (is.null(name)) 
[16:13:44.915]                               next
[16:13:44.915]                             if (!grepl(pattern, name)) 
[16:13:44.915]                               next
[16:13:44.915]                             invokeRestart(restart)
[16:13:44.915]                             muffled <- TRUE
[16:13:44.915]                             break
[16:13:44.915]                           }
[16:13:44.915]                         }
[16:13:44.915]                       }
[16:13:44.915]                       invisible(muffled)
[16:13:44.915]                     }
[16:13:44.915]                     muffleCondition(cond, pattern = "^muffle")
[16:13:44.915]                   }
[16:13:44.915]                 }
[16:13:44.915]                 else {
[16:13:44.915]                   if (TRUE) {
[16:13:44.915]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:44.915]                     {
[16:13:44.915]                       inherits <- base::inherits
[16:13:44.915]                       invokeRestart <- base::invokeRestart
[16:13:44.915]                       is.null <- base::is.null
[16:13:44.915]                       muffled <- FALSE
[16:13:44.915]                       if (inherits(cond, "message")) {
[16:13:44.915]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:44.915]                         if (muffled) 
[16:13:44.915]                           invokeRestart("muffleMessage")
[16:13:44.915]                       }
[16:13:44.915]                       else if (inherits(cond, "warning")) {
[16:13:44.915]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:44.915]                         if (muffled) 
[16:13:44.915]                           invokeRestart("muffleWarning")
[16:13:44.915]                       }
[16:13:44.915]                       else if (inherits(cond, "condition")) {
[16:13:44.915]                         if (!is.null(pattern)) {
[16:13:44.915]                           computeRestarts <- base::computeRestarts
[16:13:44.915]                           grepl <- base::grepl
[16:13:44.915]                           restarts <- computeRestarts(cond)
[16:13:44.915]                           for (restart in restarts) {
[16:13:44.915]                             name <- restart$name
[16:13:44.915]                             if (is.null(name)) 
[16:13:44.915]                               next
[16:13:44.915]                             if (!grepl(pattern, name)) 
[16:13:44.915]                               next
[16:13:44.915]                             invokeRestart(restart)
[16:13:44.915]                             muffled <- TRUE
[16:13:44.915]                             break
[16:13:44.915]                           }
[16:13:44.915]                         }
[16:13:44.915]                       }
[16:13:44.915]                       invisible(muffled)
[16:13:44.915]                     }
[16:13:44.915]                     muffleCondition(cond, pattern = "^muffle")
[16:13:44.915]                   }
[16:13:44.915]                 }
[16:13:44.915]             }
[16:13:44.915]         }))
[16:13:44.915]     }, error = function(ex) {
[16:13:44.915]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:44.915]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:44.915]                 ...future.rng), started = ...future.startTime, 
[16:13:44.915]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:44.915]             version = "1.8"), class = "FutureResult")
[16:13:44.915]     }, finally = {
[16:13:44.915]         if (!identical(...future.workdir, getwd())) 
[16:13:44.915]             setwd(...future.workdir)
[16:13:44.915]         {
[16:13:44.915]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:44.915]                 ...future.oldOptions$nwarnings <- NULL
[16:13:44.915]             }
[16:13:44.915]             base::options(...future.oldOptions)
[16:13:44.915]             if (.Platform$OS.type == "windows") {
[16:13:44.915]                 old_names <- names(...future.oldEnvVars)
[16:13:44.915]                 envs <- base::Sys.getenv()
[16:13:44.915]                 names <- names(envs)
[16:13:44.915]                 common <- intersect(names, old_names)
[16:13:44.915]                 added <- setdiff(names, old_names)
[16:13:44.915]                 removed <- setdiff(old_names, names)
[16:13:44.915]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:44.915]                   envs[common]]
[16:13:44.915]                 NAMES <- toupper(changed)
[16:13:44.915]                 args <- list()
[16:13:44.915]                 for (kk in seq_along(NAMES)) {
[16:13:44.915]                   name <- changed[[kk]]
[16:13:44.915]                   NAME <- NAMES[[kk]]
[16:13:44.915]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:44.915]                     next
[16:13:44.915]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:44.915]                 }
[16:13:44.915]                 NAMES <- toupper(added)
[16:13:44.915]                 for (kk in seq_along(NAMES)) {
[16:13:44.915]                   name <- added[[kk]]
[16:13:44.915]                   NAME <- NAMES[[kk]]
[16:13:44.915]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:44.915]                     next
[16:13:44.915]                   args[[name]] <- ""
[16:13:44.915]                 }
[16:13:44.915]                 NAMES <- toupper(removed)
[16:13:44.915]                 for (kk in seq_along(NAMES)) {
[16:13:44.915]                   name <- removed[[kk]]
[16:13:44.915]                   NAME <- NAMES[[kk]]
[16:13:44.915]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:44.915]                     next
[16:13:44.915]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:44.915]                 }
[16:13:44.915]                 if (length(args) > 0) 
[16:13:44.915]                   base::do.call(base::Sys.setenv, args = args)
[16:13:44.915]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:44.915]             }
[16:13:44.915]             else {
[16:13:44.915]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:44.915]             }
[16:13:44.915]             {
[16:13:44.915]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:44.915]                   0L) {
[16:13:44.915]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:44.915]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:44.915]                   base::options(opts)
[16:13:44.915]                 }
[16:13:44.915]                 {
[16:13:44.915]                   {
[16:13:44.915]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:44.915]                     NULL
[16:13:44.915]                   }
[16:13:44.915]                   options(future.plan = NULL)
[16:13:44.915]                   if (is.na(NA_character_)) 
[16:13:44.915]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:44.915]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:44.915]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:44.915]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:44.915]                     envir = parent.frame()) 
[16:13:44.915]                   {
[16:13:44.915]                     if (is.function(workers)) 
[16:13:44.915]                       workers <- workers()
[16:13:44.915]                     workers <- structure(as.integer(workers), 
[16:13:44.915]                       class = class(workers))
[16:13:44.915]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:44.915]                       workers >= 1)
[16:13:44.915]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:44.915]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:44.915]                     }
[16:13:44.915]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:44.915]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:44.915]                       envir = envir)
[16:13:44.915]                     if (!future$lazy) 
[16:13:44.915]                       future <- run(future)
[16:13:44.915]                     invisible(future)
[16:13:44.915]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:44.915]                 }
[16:13:44.915]             }
[16:13:44.915]         }
[16:13:44.915]     })
[16:13:44.915]     if (TRUE) {
[16:13:44.915]         base::sink(type = "output", split = FALSE)
[16:13:44.915]         if (TRUE) {
[16:13:44.915]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:44.915]         }
[16:13:44.915]         else {
[16:13:44.915]             ...future.result["stdout"] <- base::list(NULL)
[16:13:44.915]         }
[16:13:44.915]         base::close(...future.stdout)
[16:13:44.915]         ...future.stdout <- NULL
[16:13:44.915]     }
[16:13:44.915]     ...future.result$conditions <- ...future.conditions
[16:13:44.915]     ...future.result$finished <- base::Sys.time()
[16:13:44.915]     ...future.result
[16:13:44.915] }
[16:13:44.918] MultisessionFuture started
[16:13:44.919] - Launch lazy future ... done
[16:13:44.919] run() for ‘MultisessionFuture’ ... done
[16:13:44.965] receiveMessageFromWorker() for ClusterFuture ...
[16:13:44.965] - Validating connection of MultisessionFuture
[16:13:44.966] - received message: FutureResult
[16:13:44.966] - Received FutureResult
[16:13:44.966] - Erased future from FutureRegistry
[16:13:44.966] result() for ClusterFuture ...
[16:13:44.966] - result already collected: FutureResult
[16:13:44.966] result() for ClusterFuture ... done
[16:13:44.966] signalConditions() ...
[16:13:44.966]  - include = ‘immediateCondition’
[16:13:44.967]  - exclude = 
[16:13:44.967]  - resignal = FALSE
[16:13:44.967]  - Number of conditions: 1
[16:13:44.967] signalConditions() ... done
[16:13:44.967] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:44.967] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = FALSE ... DONE
- result = FALSE, recursive = TRUE ...
[16:13:44.967] getGlobalsAndPackages() ...
[16:13:44.967] Searching for globals...
[16:13:44.969] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:44.969] Searching for globals ... DONE
[16:13:44.969] Resolving globals: FALSE
[16:13:44.969] 
[16:13:44.969] 
[16:13:44.969] getGlobalsAndPackages() ... DONE
[16:13:44.970] run() for ‘Future’ ...
[16:13:44.970] - state: ‘created’
[16:13:44.970] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:44.985] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:44.985] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:44.985]   - Field: ‘node’
[16:13:44.985]   - Field: ‘label’
[16:13:44.985]   - Field: ‘local’
[16:13:44.985]   - Field: ‘owner’
[16:13:44.985]   - Field: ‘envir’
[16:13:44.986]   - Field: ‘workers’
[16:13:44.986]   - Field: ‘packages’
[16:13:44.986]   - Field: ‘gc’
[16:13:44.986]   - Field: ‘conditions’
[16:13:44.986]   - Field: ‘persistent’
[16:13:44.986]   - Field: ‘expr’
[16:13:44.986]   - Field: ‘uuid’
[16:13:44.986]   - Field: ‘seed’
[16:13:44.986]   - Field: ‘version’
[16:13:44.986]   - Field: ‘result’
[16:13:44.986]   - Field: ‘asynchronous’
[16:13:44.987]   - Field: ‘calls’
[16:13:44.987]   - Field: ‘globals’
[16:13:44.987]   - Field: ‘stdout’
[16:13:44.987]   - Field: ‘earlySignal’
[16:13:44.987]   - Field: ‘lazy’
[16:13:44.987]   - Field: ‘state’
[16:13:44.987] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:44.987] - Launch lazy future ...
[16:13:44.988] Packages needed by the future expression (n = 0): <none>
[16:13:44.988] Packages needed by future strategies (n = 0): <none>
[16:13:44.988] {
[16:13:44.988]     {
[16:13:44.988]         {
[16:13:44.988]             ...future.startTime <- base::Sys.time()
[16:13:44.988]             {
[16:13:44.988]                 {
[16:13:44.988]                   {
[16:13:44.988]                     {
[16:13:44.988]                       base::local({
[16:13:44.988]                         has_future <- base::requireNamespace("future", 
[16:13:44.988]                           quietly = TRUE)
[16:13:44.988]                         if (has_future) {
[16:13:44.988]                           ns <- base::getNamespace("future")
[16:13:44.988]                           version <- ns[[".package"]][["version"]]
[16:13:44.988]                           if (is.null(version)) 
[16:13:44.988]                             version <- utils::packageVersion("future")
[16:13:44.988]                         }
[16:13:44.988]                         else {
[16:13:44.988]                           version <- NULL
[16:13:44.988]                         }
[16:13:44.988]                         if (!has_future || version < "1.8.0") {
[16:13:44.988]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:44.988]                             "", base::R.version$version.string), 
[16:13:44.988]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:44.988]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:44.988]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:44.988]                               "release", "version")], collapse = " "), 
[16:13:44.988]                             hostname = base::Sys.info()[["nodename"]])
[16:13:44.988]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:44.988]                             info)
[16:13:44.988]                           info <- base::paste(info, collapse = "; ")
[16:13:44.988]                           if (!has_future) {
[16:13:44.988]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:44.988]                               info)
[16:13:44.988]                           }
[16:13:44.988]                           else {
[16:13:44.988]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:44.988]                               info, version)
[16:13:44.988]                           }
[16:13:44.988]                           base::stop(msg)
[16:13:44.988]                         }
[16:13:44.988]                       })
[16:13:44.988]                     }
[16:13:44.988]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:44.988]                     base::options(mc.cores = 1L)
[16:13:44.988]                   }
[16:13:44.988]                   options(future.plan = NULL)
[16:13:44.988]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:44.988]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:44.988]                 }
[16:13:44.988]                 ...future.workdir <- getwd()
[16:13:44.988]             }
[16:13:44.988]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:44.988]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:44.988]         }
[16:13:44.988]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:44.988]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:44.988]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:44.988]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:44.988]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:44.988]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:44.988]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:44.988]             base::names(...future.oldOptions))
[16:13:44.988]     }
[16:13:44.988]     if (FALSE) {
[16:13:44.988]     }
[16:13:44.988]     else {
[16:13:44.988]         if (TRUE) {
[16:13:44.988]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:44.988]                 open = "w")
[16:13:44.988]         }
[16:13:44.988]         else {
[16:13:44.988]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:44.988]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:44.988]         }
[16:13:44.988]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:44.988]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:44.988]             base::sink(type = "output", split = FALSE)
[16:13:44.988]             base::close(...future.stdout)
[16:13:44.988]         }, add = TRUE)
[16:13:44.988]     }
[16:13:44.988]     ...future.frame <- base::sys.nframe()
[16:13:44.988]     ...future.conditions <- base::list()
[16:13:44.988]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:44.988]     if (FALSE) {
[16:13:44.988]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:44.988]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:44.988]     }
[16:13:44.988]     ...future.result <- base::tryCatch({
[16:13:44.988]         base::withCallingHandlers({
[16:13:44.988]             ...future.value <- base::withVisible(base::local({
[16:13:44.988]                 ...future.makeSendCondition <- local({
[16:13:44.988]                   sendCondition <- NULL
[16:13:44.988]                   function(frame = 1L) {
[16:13:44.988]                     if (is.function(sendCondition)) 
[16:13:44.988]                       return(sendCondition)
[16:13:44.988]                     ns <- getNamespace("parallel")
[16:13:44.988]                     if (exists("sendData", mode = "function", 
[16:13:44.988]                       envir = ns)) {
[16:13:44.988]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:44.988]                         envir = ns)
[16:13:44.988]                       envir <- sys.frame(frame)
[16:13:44.988]                       master <- NULL
[16:13:44.988]                       while (!identical(envir, .GlobalEnv) && 
[16:13:44.988]                         !identical(envir, emptyenv())) {
[16:13:44.988]                         if (exists("master", mode = "list", envir = envir, 
[16:13:44.988]                           inherits = FALSE)) {
[16:13:44.988]                           master <- get("master", mode = "list", 
[16:13:44.988]                             envir = envir, inherits = FALSE)
[16:13:44.988]                           if (inherits(master, c("SOCKnode", 
[16:13:44.988]                             "SOCK0node"))) {
[16:13:44.988]                             sendCondition <<- function(cond) {
[16:13:44.988]                               data <- list(type = "VALUE", value = cond, 
[16:13:44.988]                                 success = TRUE)
[16:13:44.988]                               parallel_sendData(master, data)
[16:13:44.988]                             }
[16:13:44.988]                             return(sendCondition)
[16:13:44.988]                           }
[16:13:44.988]                         }
[16:13:44.988]                         frame <- frame + 1L
[16:13:44.988]                         envir <- sys.frame(frame)
[16:13:44.988]                       }
[16:13:44.988]                     }
[16:13:44.988]                     sendCondition <<- function(cond) NULL
[16:13:44.988]                   }
[16:13:44.988]                 })
[16:13:44.988]                 withCallingHandlers({
[16:13:44.988]                   {
[16:13:44.988]                     Sys.sleep(0.5)
[16:13:44.988]                     list(a = 1, b = 42L)
[16:13:44.988]                   }
[16:13:44.988]                 }, immediateCondition = function(cond) {
[16:13:44.988]                   sendCondition <- ...future.makeSendCondition()
[16:13:44.988]                   sendCondition(cond)
[16:13:44.988]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:44.988]                   {
[16:13:44.988]                     inherits <- base::inherits
[16:13:44.988]                     invokeRestart <- base::invokeRestart
[16:13:44.988]                     is.null <- base::is.null
[16:13:44.988]                     muffled <- FALSE
[16:13:44.988]                     if (inherits(cond, "message")) {
[16:13:44.988]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:44.988]                       if (muffled) 
[16:13:44.988]                         invokeRestart("muffleMessage")
[16:13:44.988]                     }
[16:13:44.988]                     else if (inherits(cond, "warning")) {
[16:13:44.988]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:44.988]                       if (muffled) 
[16:13:44.988]                         invokeRestart("muffleWarning")
[16:13:44.988]                     }
[16:13:44.988]                     else if (inherits(cond, "condition")) {
[16:13:44.988]                       if (!is.null(pattern)) {
[16:13:44.988]                         computeRestarts <- base::computeRestarts
[16:13:44.988]                         grepl <- base::grepl
[16:13:44.988]                         restarts <- computeRestarts(cond)
[16:13:44.988]                         for (restart in restarts) {
[16:13:44.988]                           name <- restart$name
[16:13:44.988]                           if (is.null(name)) 
[16:13:44.988]                             next
[16:13:44.988]                           if (!grepl(pattern, name)) 
[16:13:44.988]                             next
[16:13:44.988]                           invokeRestart(restart)
[16:13:44.988]                           muffled <- TRUE
[16:13:44.988]                           break
[16:13:44.988]                         }
[16:13:44.988]                       }
[16:13:44.988]                     }
[16:13:44.988]                     invisible(muffled)
[16:13:44.988]                   }
[16:13:44.988]                   muffleCondition(cond)
[16:13:44.988]                 })
[16:13:44.988]             }))
[16:13:44.988]             future::FutureResult(value = ...future.value$value, 
[16:13:44.988]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:44.988]                   ...future.rng), globalenv = if (FALSE) 
[16:13:44.988]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:44.988]                     ...future.globalenv.names))
[16:13:44.988]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:44.988]         }, condition = base::local({
[16:13:44.988]             c <- base::c
[16:13:44.988]             inherits <- base::inherits
[16:13:44.988]             invokeRestart <- base::invokeRestart
[16:13:44.988]             length <- base::length
[16:13:44.988]             list <- base::list
[16:13:44.988]             seq.int <- base::seq.int
[16:13:44.988]             signalCondition <- base::signalCondition
[16:13:44.988]             sys.calls <- base::sys.calls
[16:13:44.988]             `[[` <- base::`[[`
[16:13:44.988]             `+` <- base::`+`
[16:13:44.988]             `<<-` <- base::`<<-`
[16:13:44.988]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:44.988]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:44.988]                   3L)]
[16:13:44.988]             }
[16:13:44.988]             function(cond) {
[16:13:44.988]                 is_error <- inherits(cond, "error")
[16:13:44.988]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:44.988]                   NULL)
[16:13:44.988]                 if (is_error) {
[16:13:44.988]                   sessionInformation <- function() {
[16:13:44.988]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:44.988]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:44.988]                       search = base::search(), system = base::Sys.info())
[16:13:44.988]                   }
[16:13:44.988]                   ...future.conditions[[length(...future.conditions) + 
[16:13:44.988]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:44.988]                     cond$call), session = sessionInformation(), 
[16:13:44.988]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:44.988]                   signalCondition(cond)
[16:13:44.988]                 }
[16:13:44.988]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:44.988]                 "immediateCondition"))) {
[16:13:44.988]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:44.988]                   ...future.conditions[[length(...future.conditions) + 
[16:13:44.988]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:44.988]                   if (TRUE && !signal) {
[16:13:44.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:44.988]                     {
[16:13:44.988]                       inherits <- base::inherits
[16:13:44.988]                       invokeRestart <- base::invokeRestart
[16:13:44.988]                       is.null <- base::is.null
[16:13:44.988]                       muffled <- FALSE
[16:13:44.988]                       if (inherits(cond, "message")) {
[16:13:44.988]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:44.988]                         if (muffled) 
[16:13:44.988]                           invokeRestart("muffleMessage")
[16:13:44.988]                       }
[16:13:44.988]                       else if (inherits(cond, "warning")) {
[16:13:44.988]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:44.988]                         if (muffled) 
[16:13:44.988]                           invokeRestart("muffleWarning")
[16:13:44.988]                       }
[16:13:44.988]                       else if (inherits(cond, "condition")) {
[16:13:44.988]                         if (!is.null(pattern)) {
[16:13:44.988]                           computeRestarts <- base::computeRestarts
[16:13:44.988]                           grepl <- base::grepl
[16:13:44.988]                           restarts <- computeRestarts(cond)
[16:13:44.988]                           for (restart in restarts) {
[16:13:44.988]                             name <- restart$name
[16:13:44.988]                             if (is.null(name)) 
[16:13:44.988]                               next
[16:13:44.988]                             if (!grepl(pattern, name)) 
[16:13:44.988]                               next
[16:13:44.988]                             invokeRestart(restart)
[16:13:44.988]                             muffled <- TRUE
[16:13:44.988]                             break
[16:13:44.988]                           }
[16:13:44.988]                         }
[16:13:44.988]                       }
[16:13:44.988]                       invisible(muffled)
[16:13:44.988]                     }
[16:13:44.988]                     muffleCondition(cond, pattern = "^muffle")
[16:13:44.988]                   }
[16:13:44.988]                 }
[16:13:44.988]                 else {
[16:13:44.988]                   if (TRUE) {
[16:13:44.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:44.988]                     {
[16:13:44.988]                       inherits <- base::inherits
[16:13:44.988]                       invokeRestart <- base::invokeRestart
[16:13:44.988]                       is.null <- base::is.null
[16:13:44.988]                       muffled <- FALSE
[16:13:44.988]                       if (inherits(cond, "message")) {
[16:13:44.988]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:44.988]                         if (muffled) 
[16:13:44.988]                           invokeRestart("muffleMessage")
[16:13:44.988]                       }
[16:13:44.988]                       else if (inherits(cond, "warning")) {
[16:13:44.988]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:44.988]                         if (muffled) 
[16:13:44.988]                           invokeRestart("muffleWarning")
[16:13:44.988]                       }
[16:13:44.988]                       else if (inherits(cond, "condition")) {
[16:13:44.988]                         if (!is.null(pattern)) {
[16:13:44.988]                           computeRestarts <- base::computeRestarts
[16:13:44.988]                           grepl <- base::grepl
[16:13:44.988]                           restarts <- computeRestarts(cond)
[16:13:44.988]                           for (restart in restarts) {
[16:13:44.988]                             name <- restart$name
[16:13:44.988]                             if (is.null(name)) 
[16:13:44.988]                               next
[16:13:44.988]                             if (!grepl(pattern, name)) 
[16:13:44.988]                               next
[16:13:44.988]                             invokeRestart(restart)
[16:13:44.988]                             muffled <- TRUE
[16:13:44.988]                             break
[16:13:44.988]                           }
[16:13:44.988]                         }
[16:13:44.988]                       }
[16:13:44.988]                       invisible(muffled)
[16:13:44.988]                     }
[16:13:44.988]                     muffleCondition(cond, pattern = "^muffle")
[16:13:44.988]                   }
[16:13:44.988]                 }
[16:13:44.988]             }
[16:13:44.988]         }))
[16:13:44.988]     }, error = function(ex) {
[16:13:44.988]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:44.988]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:44.988]                 ...future.rng), started = ...future.startTime, 
[16:13:44.988]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:44.988]             version = "1.8"), class = "FutureResult")
[16:13:44.988]     }, finally = {
[16:13:44.988]         if (!identical(...future.workdir, getwd())) 
[16:13:44.988]             setwd(...future.workdir)
[16:13:44.988]         {
[16:13:44.988]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:44.988]                 ...future.oldOptions$nwarnings <- NULL
[16:13:44.988]             }
[16:13:44.988]             base::options(...future.oldOptions)
[16:13:44.988]             if (.Platform$OS.type == "windows") {
[16:13:44.988]                 old_names <- names(...future.oldEnvVars)
[16:13:44.988]                 envs <- base::Sys.getenv()
[16:13:44.988]                 names <- names(envs)
[16:13:44.988]                 common <- intersect(names, old_names)
[16:13:44.988]                 added <- setdiff(names, old_names)
[16:13:44.988]                 removed <- setdiff(old_names, names)
[16:13:44.988]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:44.988]                   envs[common]]
[16:13:44.988]                 NAMES <- toupper(changed)
[16:13:44.988]                 args <- list()
[16:13:44.988]                 for (kk in seq_along(NAMES)) {
[16:13:44.988]                   name <- changed[[kk]]
[16:13:44.988]                   NAME <- NAMES[[kk]]
[16:13:44.988]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:44.988]                     next
[16:13:44.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:44.988]                 }
[16:13:44.988]                 NAMES <- toupper(added)
[16:13:44.988]                 for (kk in seq_along(NAMES)) {
[16:13:44.988]                   name <- added[[kk]]
[16:13:44.988]                   NAME <- NAMES[[kk]]
[16:13:44.988]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:44.988]                     next
[16:13:44.988]                   args[[name]] <- ""
[16:13:44.988]                 }
[16:13:44.988]                 NAMES <- toupper(removed)
[16:13:44.988]                 for (kk in seq_along(NAMES)) {
[16:13:44.988]                   name <- removed[[kk]]
[16:13:44.988]                   NAME <- NAMES[[kk]]
[16:13:44.988]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:44.988]                     next
[16:13:44.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:44.988]                 }
[16:13:44.988]                 if (length(args) > 0) 
[16:13:44.988]                   base::do.call(base::Sys.setenv, args = args)
[16:13:44.988]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:44.988]             }
[16:13:44.988]             else {
[16:13:44.988]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:44.988]             }
[16:13:44.988]             {
[16:13:44.988]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:44.988]                   0L) {
[16:13:44.988]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:44.988]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:44.988]                   base::options(opts)
[16:13:44.988]                 }
[16:13:44.988]                 {
[16:13:44.988]                   {
[16:13:44.988]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:44.988]                     NULL
[16:13:44.988]                   }
[16:13:44.988]                   options(future.plan = NULL)
[16:13:44.988]                   if (is.na(NA_character_)) 
[16:13:44.988]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:44.988]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:44.988]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:44.988]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:44.988]                     envir = parent.frame()) 
[16:13:44.988]                   {
[16:13:44.988]                     if (is.function(workers)) 
[16:13:44.988]                       workers <- workers()
[16:13:44.988]                     workers <- structure(as.integer(workers), 
[16:13:44.988]                       class = class(workers))
[16:13:44.988]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:44.988]                       workers >= 1)
[16:13:44.988]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:44.988]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:44.988]                     }
[16:13:44.988]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:44.988]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:44.988]                       envir = envir)
[16:13:44.988]                     if (!future$lazy) 
[16:13:44.988]                       future <- run(future)
[16:13:44.988]                     invisible(future)
[16:13:44.988]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:44.988]                 }
[16:13:44.988]             }
[16:13:44.988]         }
[16:13:44.988]     })
[16:13:44.988]     if (TRUE) {
[16:13:44.988]         base::sink(type = "output", split = FALSE)
[16:13:44.988]         if (TRUE) {
[16:13:44.988]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:44.988]         }
[16:13:44.988]         else {
[16:13:44.988]             ...future.result["stdout"] <- base::list(NULL)
[16:13:44.988]         }
[16:13:44.988]         base::close(...future.stdout)
[16:13:44.988]         ...future.stdout <- NULL
[16:13:44.988]     }
[16:13:44.988]     ...future.result$conditions <- ...future.conditions
[16:13:44.988]     ...future.result$finished <- base::Sys.time()
[16:13:44.988]     ...future.result
[16:13:44.988] }
[16:13:44.991] MultisessionFuture started
[16:13:44.991] - Launch lazy future ... done
[16:13:44.991] run() for ‘MultisessionFuture’ ... done
[16:13:45.537] receiveMessageFromWorker() for ClusterFuture ...
[16:13:45.538] - Validating connection of MultisessionFuture
[16:13:45.538] - received message: FutureResult
[16:13:45.538] - Received FutureResult
[16:13:45.538] - Erased future from FutureRegistry
[16:13:45.538] result() for ClusterFuture ...
[16:13:45.539] - result already collected: FutureResult
[16:13:45.539] result() for ClusterFuture ... done
[16:13:45.539] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:45.539] A MultisessionFuture was resolved (result was not collected)
[16:13:45.539] getGlobalsAndPackages() ...
[16:13:45.539] Searching for globals...
[16:13:45.540] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:45.540] Searching for globals ... DONE
[16:13:45.541] Resolving globals: FALSE
[16:13:45.541] 
[16:13:45.541] 
[16:13:45.541] getGlobalsAndPackages() ... DONE
[16:13:45.541] run() for ‘Future’ ...
[16:13:45.541] - state: ‘created’
[16:13:45.542] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:45.556] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:45.556] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:45.556]   - Field: ‘node’
[16:13:45.556]   - Field: ‘label’
[16:13:45.557]   - Field: ‘local’
[16:13:45.557]   - Field: ‘owner’
[16:13:45.557]   - Field: ‘envir’
[16:13:45.557]   - Field: ‘workers’
[16:13:45.557]   - Field: ‘packages’
[16:13:45.557]   - Field: ‘gc’
[16:13:45.557]   - Field: ‘conditions’
[16:13:45.557]   - Field: ‘persistent’
[16:13:45.557]   - Field: ‘expr’
[16:13:45.557]   - Field: ‘uuid’
[16:13:45.558]   - Field: ‘seed’
[16:13:45.558]   - Field: ‘version’
[16:13:45.558]   - Field: ‘result’
[16:13:45.558]   - Field: ‘asynchronous’
[16:13:45.558]   - Field: ‘calls’
[16:13:45.558]   - Field: ‘globals’
[16:13:45.558]   - Field: ‘stdout’
[16:13:45.558]   - Field: ‘earlySignal’
[16:13:45.558]   - Field: ‘lazy’
[16:13:45.558]   - Field: ‘state’
[16:13:45.558] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:45.559] - Launch lazy future ...
[16:13:45.559] Packages needed by the future expression (n = 0): <none>
[16:13:45.559] Packages needed by future strategies (n = 0): <none>
[16:13:45.559] {
[16:13:45.559]     {
[16:13:45.559]         {
[16:13:45.559]             ...future.startTime <- base::Sys.time()
[16:13:45.559]             {
[16:13:45.559]                 {
[16:13:45.559]                   {
[16:13:45.559]                     {
[16:13:45.559]                       base::local({
[16:13:45.559]                         has_future <- base::requireNamespace("future", 
[16:13:45.559]                           quietly = TRUE)
[16:13:45.559]                         if (has_future) {
[16:13:45.559]                           ns <- base::getNamespace("future")
[16:13:45.559]                           version <- ns[[".package"]][["version"]]
[16:13:45.559]                           if (is.null(version)) 
[16:13:45.559]                             version <- utils::packageVersion("future")
[16:13:45.559]                         }
[16:13:45.559]                         else {
[16:13:45.559]                           version <- NULL
[16:13:45.559]                         }
[16:13:45.559]                         if (!has_future || version < "1.8.0") {
[16:13:45.559]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:45.559]                             "", base::R.version$version.string), 
[16:13:45.559]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:45.559]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:45.559]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:45.559]                               "release", "version")], collapse = " "), 
[16:13:45.559]                             hostname = base::Sys.info()[["nodename"]])
[16:13:45.559]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:45.559]                             info)
[16:13:45.559]                           info <- base::paste(info, collapse = "; ")
[16:13:45.559]                           if (!has_future) {
[16:13:45.559]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:45.559]                               info)
[16:13:45.559]                           }
[16:13:45.559]                           else {
[16:13:45.559]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:45.559]                               info, version)
[16:13:45.559]                           }
[16:13:45.559]                           base::stop(msg)
[16:13:45.559]                         }
[16:13:45.559]                       })
[16:13:45.559]                     }
[16:13:45.559]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:45.559]                     base::options(mc.cores = 1L)
[16:13:45.559]                   }
[16:13:45.559]                   options(future.plan = NULL)
[16:13:45.559]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:45.559]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:45.559]                 }
[16:13:45.559]                 ...future.workdir <- getwd()
[16:13:45.559]             }
[16:13:45.559]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:45.559]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:45.559]         }
[16:13:45.559]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:45.559]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:45.559]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:45.559]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:45.559]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:45.559]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:45.559]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:45.559]             base::names(...future.oldOptions))
[16:13:45.559]     }
[16:13:45.559]     if (FALSE) {
[16:13:45.559]     }
[16:13:45.559]     else {
[16:13:45.559]         if (TRUE) {
[16:13:45.559]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:45.559]                 open = "w")
[16:13:45.559]         }
[16:13:45.559]         else {
[16:13:45.559]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:45.559]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:45.559]         }
[16:13:45.559]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:45.559]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:45.559]             base::sink(type = "output", split = FALSE)
[16:13:45.559]             base::close(...future.stdout)
[16:13:45.559]         }, add = TRUE)
[16:13:45.559]     }
[16:13:45.559]     ...future.frame <- base::sys.nframe()
[16:13:45.559]     ...future.conditions <- base::list()
[16:13:45.559]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:45.559]     if (FALSE) {
[16:13:45.559]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:45.559]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:45.559]     }
[16:13:45.559]     ...future.result <- base::tryCatch({
[16:13:45.559]         base::withCallingHandlers({
[16:13:45.559]             ...future.value <- base::withVisible(base::local({
[16:13:45.559]                 ...future.makeSendCondition <- local({
[16:13:45.559]                   sendCondition <- NULL
[16:13:45.559]                   function(frame = 1L) {
[16:13:45.559]                     if (is.function(sendCondition)) 
[16:13:45.559]                       return(sendCondition)
[16:13:45.559]                     ns <- getNamespace("parallel")
[16:13:45.559]                     if (exists("sendData", mode = "function", 
[16:13:45.559]                       envir = ns)) {
[16:13:45.559]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:45.559]                         envir = ns)
[16:13:45.559]                       envir <- sys.frame(frame)
[16:13:45.559]                       master <- NULL
[16:13:45.559]                       while (!identical(envir, .GlobalEnv) && 
[16:13:45.559]                         !identical(envir, emptyenv())) {
[16:13:45.559]                         if (exists("master", mode = "list", envir = envir, 
[16:13:45.559]                           inherits = FALSE)) {
[16:13:45.559]                           master <- get("master", mode = "list", 
[16:13:45.559]                             envir = envir, inherits = FALSE)
[16:13:45.559]                           if (inherits(master, c("SOCKnode", 
[16:13:45.559]                             "SOCK0node"))) {
[16:13:45.559]                             sendCondition <<- function(cond) {
[16:13:45.559]                               data <- list(type = "VALUE", value = cond, 
[16:13:45.559]                                 success = TRUE)
[16:13:45.559]                               parallel_sendData(master, data)
[16:13:45.559]                             }
[16:13:45.559]                             return(sendCondition)
[16:13:45.559]                           }
[16:13:45.559]                         }
[16:13:45.559]                         frame <- frame + 1L
[16:13:45.559]                         envir <- sys.frame(frame)
[16:13:45.559]                       }
[16:13:45.559]                     }
[16:13:45.559]                     sendCondition <<- function(cond) NULL
[16:13:45.559]                   }
[16:13:45.559]                 })
[16:13:45.559]                 withCallingHandlers({
[16:13:45.559]                   {
[16:13:45.559]                     Sys.sleep(0.5)
[16:13:45.559]                     list(a = 1, b = 42L)
[16:13:45.559]                   }
[16:13:45.559]                 }, immediateCondition = function(cond) {
[16:13:45.559]                   sendCondition <- ...future.makeSendCondition()
[16:13:45.559]                   sendCondition(cond)
[16:13:45.559]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:45.559]                   {
[16:13:45.559]                     inherits <- base::inherits
[16:13:45.559]                     invokeRestart <- base::invokeRestart
[16:13:45.559]                     is.null <- base::is.null
[16:13:45.559]                     muffled <- FALSE
[16:13:45.559]                     if (inherits(cond, "message")) {
[16:13:45.559]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:45.559]                       if (muffled) 
[16:13:45.559]                         invokeRestart("muffleMessage")
[16:13:45.559]                     }
[16:13:45.559]                     else if (inherits(cond, "warning")) {
[16:13:45.559]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:45.559]                       if (muffled) 
[16:13:45.559]                         invokeRestart("muffleWarning")
[16:13:45.559]                     }
[16:13:45.559]                     else if (inherits(cond, "condition")) {
[16:13:45.559]                       if (!is.null(pattern)) {
[16:13:45.559]                         computeRestarts <- base::computeRestarts
[16:13:45.559]                         grepl <- base::grepl
[16:13:45.559]                         restarts <- computeRestarts(cond)
[16:13:45.559]                         for (restart in restarts) {
[16:13:45.559]                           name <- restart$name
[16:13:45.559]                           if (is.null(name)) 
[16:13:45.559]                             next
[16:13:45.559]                           if (!grepl(pattern, name)) 
[16:13:45.559]                             next
[16:13:45.559]                           invokeRestart(restart)
[16:13:45.559]                           muffled <- TRUE
[16:13:45.559]                           break
[16:13:45.559]                         }
[16:13:45.559]                       }
[16:13:45.559]                     }
[16:13:45.559]                     invisible(muffled)
[16:13:45.559]                   }
[16:13:45.559]                   muffleCondition(cond)
[16:13:45.559]                 })
[16:13:45.559]             }))
[16:13:45.559]             future::FutureResult(value = ...future.value$value, 
[16:13:45.559]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:45.559]                   ...future.rng), globalenv = if (FALSE) 
[16:13:45.559]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:45.559]                     ...future.globalenv.names))
[16:13:45.559]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:45.559]         }, condition = base::local({
[16:13:45.559]             c <- base::c
[16:13:45.559]             inherits <- base::inherits
[16:13:45.559]             invokeRestart <- base::invokeRestart
[16:13:45.559]             length <- base::length
[16:13:45.559]             list <- base::list
[16:13:45.559]             seq.int <- base::seq.int
[16:13:45.559]             signalCondition <- base::signalCondition
[16:13:45.559]             sys.calls <- base::sys.calls
[16:13:45.559]             `[[` <- base::`[[`
[16:13:45.559]             `+` <- base::`+`
[16:13:45.559]             `<<-` <- base::`<<-`
[16:13:45.559]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:45.559]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:45.559]                   3L)]
[16:13:45.559]             }
[16:13:45.559]             function(cond) {
[16:13:45.559]                 is_error <- inherits(cond, "error")
[16:13:45.559]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:45.559]                   NULL)
[16:13:45.559]                 if (is_error) {
[16:13:45.559]                   sessionInformation <- function() {
[16:13:45.559]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:45.559]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:45.559]                       search = base::search(), system = base::Sys.info())
[16:13:45.559]                   }
[16:13:45.559]                   ...future.conditions[[length(...future.conditions) + 
[16:13:45.559]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:45.559]                     cond$call), session = sessionInformation(), 
[16:13:45.559]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:45.559]                   signalCondition(cond)
[16:13:45.559]                 }
[16:13:45.559]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:45.559]                 "immediateCondition"))) {
[16:13:45.559]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:45.559]                   ...future.conditions[[length(...future.conditions) + 
[16:13:45.559]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:45.559]                   if (TRUE && !signal) {
[16:13:45.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:45.559]                     {
[16:13:45.559]                       inherits <- base::inherits
[16:13:45.559]                       invokeRestart <- base::invokeRestart
[16:13:45.559]                       is.null <- base::is.null
[16:13:45.559]                       muffled <- FALSE
[16:13:45.559]                       if (inherits(cond, "message")) {
[16:13:45.559]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:45.559]                         if (muffled) 
[16:13:45.559]                           invokeRestart("muffleMessage")
[16:13:45.559]                       }
[16:13:45.559]                       else if (inherits(cond, "warning")) {
[16:13:45.559]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:45.559]                         if (muffled) 
[16:13:45.559]                           invokeRestart("muffleWarning")
[16:13:45.559]                       }
[16:13:45.559]                       else if (inherits(cond, "condition")) {
[16:13:45.559]                         if (!is.null(pattern)) {
[16:13:45.559]                           computeRestarts <- base::computeRestarts
[16:13:45.559]                           grepl <- base::grepl
[16:13:45.559]                           restarts <- computeRestarts(cond)
[16:13:45.559]                           for (restart in restarts) {
[16:13:45.559]                             name <- restart$name
[16:13:45.559]                             if (is.null(name)) 
[16:13:45.559]                               next
[16:13:45.559]                             if (!grepl(pattern, name)) 
[16:13:45.559]                               next
[16:13:45.559]                             invokeRestart(restart)
[16:13:45.559]                             muffled <- TRUE
[16:13:45.559]                             break
[16:13:45.559]                           }
[16:13:45.559]                         }
[16:13:45.559]                       }
[16:13:45.559]                       invisible(muffled)
[16:13:45.559]                     }
[16:13:45.559]                     muffleCondition(cond, pattern = "^muffle")
[16:13:45.559]                   }
[16:13:45.559]                 }
[16:13:45.559]                 else {
[16:13:45.559]                   if (TRUE) {
[16:13:45.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:45.559]                     {
[16:13:45.559]                       inherits <- base::inherits
[16:13:45.559]                       invokeRestart <- base::invokeRestart
[16:13:45.559]                       is.null <- base::is.null
[16:13:45.559]                       muffled <- FALSE
[16:13:45.559]                       if (inherits(cond, "message")) {
[16:13:45.559]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:45.559]                         if (muffled) 
[16:13:45.559]                           invokeRestart("muffleMessage")
[16:13:45.559]                       }
[16:13:45.559]                       else if (inherits(cond, "warning")) {
[16:13:45.559]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:45.559]                         if (muffled) 
[16:13:45.559]                           invokeRestart("muffleWarning")
[16:13:45.559]                       }
[16:13:45.559]                       else if (inherits(cond, "condition")) {
[16:13:45.559]                         if (!is.null(pattern)) {
[16:13:45.559]                           computeRestarts <- base::computeRestarts
[16:13:45.559]                           grepl <- base::grepl
[16:13:45.559]                           restarts <- computeRestarts(cond)
[16:13:45.559]                           for (restart in restarts) {
[16:13:45.559]                             name <- restart$name
[16:13:45.559]                             if (is.null(name)) 
[16:13:45.559]                               next
[16:13:45.559]                             if (!grepl(pattern, name)) 
[16:13:45.559]                               next
[16:13:45.559]                             invokeRestart(restart)
[16:13:45.559]                             muffled <- TRUE
[16:13:45.559]                             break
[16:13:45.559]                           }
[16:13:45.559]                         }
[16:13:45.559]                       }
[16:13:45.559]                       invisible(muffled)
[16:13:45.559]                     }
[16:13:45.559]                     muffleCondition(cond, pattern = "^muffle")
[16:13:45.559]                   }
[16:13:45.559]                 }
[16:13:45.559]             }
[16:13:45.559]         }))
[16:13:45.559]     }, error = function(ex) {
[16:13:45.559]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:45.559]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:45.559]                 ...future.rng), started = ...future.startTime, 
[16:13:45.559]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:45.559]             version = "1.8"), class = "FutureResult")
[16:13:45.559]     }, finally = {
[16:13:45.559]         if (!identical(...future.workdir, getwd())) 
[16:13:45.559]             setwd(...future.workdir)
[16:13:45.559]         {
[16:13:45.559]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:45.559]                 ...future.oldOptions$nwarnings <- NULL
[16:13:45.559]             }
[16:13:45.559]             base::options(...future.oldOptions)
[16:13:45.559]             if (.Platform$OS.type == "windows") {
[16:13:45.559]                 old_names <- names(...future.oldEnvVars)
[16:13:45.559]                 envs <- base::Sys.getenv()
[16:13:45.559]                 names <- names(envs)
[16:13:45.559]                 common <- intersect(names, old_names)
[16:13:45.559]                 added <- setdiff(names, old_names)
[16:13:45.559]                 removed <- setdiff(old_names, names)
[16:13:45.559]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:45.559]                   envs[common]]
[16:13:45.559]                 NAMES <- toupper(changed)
[16:13:45.559]                 args <- list()
[16:13:45.559]                 for (kk in seq_along(NAMES)) {
[16:13:45.559]                   name <- changed[[kk]]
[16:13:45.559]                   NAME <- NAMES[[kk]]
[16:13:45.559]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:45.559]                     next
[16:13:45.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:45.559]                 }
[16:13:45.559]                 NAMES <- toupper(added)
[16:13:45.559]                 for (kk in seq_along(NAMES)) {
[16:13:45.559]                   name <- added[[kk]]
[16:13:45.559]                   NAME <- NAMES[[kk]]
[16:13:45.559]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:45.559]                     next
[16:13:45.559]                   args[[name]] <- ""
[16:13:45.559]                 }
[16:13:45.559]                 NAMES <- toupper(removed)
[16:13:45.559]                 for (kk in seq_along(NAMES)) {
[16:13:45.559]                   name <- removed[[kk]]
[16:13:45.559]                   NAME <- NAMES[[kk]]
[16:13:45.559]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:45.559]                     next
[16:13:45.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:45.559]                 }
[16:13:45.559]                 if (length(args) > 0) 
[16:13:45.559]                   base::do.call(base::Sys.setenv, args = args)
[16:13:45.559]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:45.559]             }
[16:13:45.559]             else {
[16:13:45.559]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:45.559]             }
[16:13:45.559]             {
[16:13:45.559]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:45.559]                   0L) {
[16:13:45.559]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:45.559]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:45.559]                   base::options(opts)
[16:13:45.559]                 }
[16:13:45.559]                 {
[16:13:45.559]                   {
[16:13:45.559]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:45.559]                     NULL
[16:13:45.559]                   }
[16:13:45.559]                   options(future.plan = NULL)
[16:13:45.559]                   if (is.na(NA_character_)) 
[16:13:45.559]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:45.559]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:45.559]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:45.559]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:45.559]                     envir = parent.frame()) 
[16:13:45.559]                   {
[16:13:45.559]                     if (is.function(workers)) 
[16:13:45.559]                       workers <- workers()
[16:13:45.559]                     workers <- structure(as.integer(workers), 
[16:13:45.559]                       class = class(workers))
[16:13:45.559]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:45.559]                       workers >= 1)
[16:13:45.559]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:45.559]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:45.559]                     }
[16:13:45.559]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:45.559]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:45.559]                       envir = envir)
[16:13:45.559]                     if (!future$lazy) 
[16:13:45.559]                       future <- run(future)
[16:13:45.559]                     invisible(future)
[16:13:45.559]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:45.559]                 }
[16:13:45.559]             }
[16:13:45.559]         }
[16:13:45.559]     })
[16:13:45.559]     if (TRUE) {
[16:13:45.559]         base::sink(type = "output", split = FALSE)
[16:13:45.559]         if (TRUE) {
[16:13:45.559]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:45.559]         }
[16:13:45.559]         else {
[16:13:45.559]             ...future.result["stdout"] <- base::list(NULL)
[16:13:45.559]         }
[16:13:45.559]         base::close(...future.stdout)
[16:13:45.559]         ...future.stdout <- NULL
[16:13:45.559]     }
[16:13:45.559]     ...future.result$conditions <- ...future.conditions
[16:13:45.559]     ...future.result$finished <- base::Sys.time()
[16:13:45.559]     ...future.result
[16:13:45.559] }
[16:13:45.563] MultisessionFuture started
[16:13:45.563] - Launch lazy future ... done
[16:13:45.563] run() for ‘MultisessionFuture’ ... done
[16:13:46.109] receiveMessageFromWorker() for ClusterFuture ...
[16:13:46.110] - Validating connection of MultisessionFuture
[16:13:46.110] - received message: FutureResult
[16:13:46.110] - Received FutureResult
[16:13:46.110] - Erased future from FutureRegistry
[16:13:46.110] result() for ClusterFuture ...
[16:13:46.111] - result already collected: FutureResult
[16:13:46.111] result() for ClusterFuture ... done
[16:13:46.111] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:46.111] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[16:13:46.111] getGlobalsAndPackages() ...
[16:13:46.111] Searching for globals...
[16:13:46.112] - globals found: [2] ‘list’, ‘stop’
[16:13:46.112] Searching for globals ... DONE
[16:13:46.112] Resolving globals: FALSE
[16:13:46.112] 
[16:13:46.113] 
[16:13:46.113] getGlobalsAndPackages() ... DONE
[16:13:46.113] run() for ‘Future’ ...
[16:13:46.113] - state: ‘created’
[16:13:46.113] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:46.128] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:46.128] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:46.128]   - Field: ‘node’
[16:13:46.128]   - Field: ‘label’
[16:13:46.128]   - Field: ‘local’
[16:13:46.128]   - Field: ‘owner’
[16:13:46.128]   - Field: ‘envir’
[16:13:46.128]   - Field: ‘workers’
[16:13:46.128]   - Field: ‘packages’
[16:13:46.129]   - Field: ‘gc’
[16:13:46.129]   - Field: ‘conditions’
[16:13:46.129]   - Field: ‘persistent’
[16:13:46.129]   - Field: ‘expr’
[16:13:46.129]   - Field: ‘uuid’
[16:13:46.129]   - Field: ‘seed’
[16:13:46.129]   - Field: ‘version’
[16:13:46.129]   - Field: ‘result’
[16:13:46.129]   - Field: ‘asynchronous’
[16:13:46.129]   - Field: ‘calls’
[16:13:46.129]   - Field: ‘globals’
[16:13:46.130]   - Field: ‘stdout’
[16:13:46.130]   - Field: ‘earlySignal’
[16:13:46.130]   - Field: ‘lazy’
[16:13:46.130]   - Field: ‘state’
[16:13:46.130] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:46.130] - Launch lazy future ...
[16:13:46.130] Packages needed by the future expression (n = 0): <none>
[16:13:46.130] Packages needed by future strategies (n = 0): <none>
[16:13:46.131] {
[16:13:46.131]     {
[16:13:46.131]         {
[16:13:46.131]             ...future.startTime <- base::Sys.time()
[16:13:46.131]             {
[16:13:46.131]                 {
[16:13:46.131]                   {
[16:13:46.131]                     {
[16:13:46.131]                       base::local({
[16:13:46.131]                         has_future <- base::requireNamespace("future", 
[16:13:46.131]                           quietly = TRUE)
[16:13:46.131]                         if (has_future) {
[16:13:46.131]                           ns <- base::getNamespace("future")
[16:13:46.131]                           version <- ns[[".package"]][["version"]]
[16:13:46.131]                           if (is.null(version)) 
[16:13:46.131]                             version <- utils::packageVersion("future")
[16:13:46.131]                         }
[16:13:46.131]                         else {
[16:13:46.131]                           version <- NULL
[16:13:46.131]                         }
[16:13:46.131]                         if (!has_future || version < "1.8.0") {
[16:13:46.131]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:46.131]                             "", base::R.version$version.string), 
[16:13:46.131]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:46.131]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:46.131]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:46.131]                               "release", "version")], collapse = " "), 
[16:13:46.131]                             hostname = base::Sys.info()[["nodename"]])
[16:13:46.131]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:46.131]                             info)
[16:13:46.131]                           info <- base::paste(info, collapse = "; ")
[16:13:46.131]                           if (!has_future) {
[16:13:46.131]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:46.131]                               info)
[16:13:46.131]                           }
[16:13:46.131]                           else {
[16:13:46.131]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:46.131]                               info, version)
[16:13:46.131]                           }
[16:13:46.131]                           base::stop(msg)
[16:13:46.131]                         }
[16:13:46.131]                       })
[16:13:46.131]                     }
[16:13:46.131]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:46.131]                     base::options(mc.cores = 1L)
[16:13:46.131]                   }
[16:13:46.131]                   options(future.plan = NULL)
[16:13:46.131]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:46.131]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:46.131]                 }
[16:13:46.131]                 ...future.workdir <- getwd()
[16:13:46.131]             }
[16:13:46.131]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:46.131]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:46.131]         }
[16:13:46.131]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:46.131]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:46.131]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:46.131]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:46.131]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:46.131]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:46.131]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:46.131]             base::names(...future.oldOptions))
[16:13:46.131]     }
[16:13:46.131]     if (FALSE) {
[16:13:46.131]     }
[16:13:46.131]     else {
[16:13:46.131]         if (TRUE) {
[16:13:46.131]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:46.131]                 open = "w")
[16:13:46.131]         }
[16:13:46.131]         else {
[16:13:46.131]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:46.131]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:46.131]         }
[16:13:46.131]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:46.131]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:46.131]             base::sink(type = "output", split = FALSE)
[16:13:46.131]             base::close(...future.stdout)
[16:13:46.131]         }, add = TRUE)
[16:13:46.131]     }
[16:13:46.131]     ...future.frame <- base::sys.nframe()
[16:13:46.131]     ...future.conditions <- base::list()
[16:13:46.131]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:46.131]     if (FALSE) {
[16:13:46.131]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:46.131]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:46.131]     }
[16:13:46.131]     ...future.result <- base::tryCatch({
[16:13:46.131]         base::withCallingHandlers({
[16:13:46.131]             ...future.value <- base::withVisible(base::local({
[16:13:46.131]                 ...future.makeSendCondition <- local({
[16:13:46.131]                   sendCondition <- NULL
[16:13:46.131]                   function(frame = 1L) {
[16:13:46.131]                     if (is.function(sendCondition)) 
[16:13:46.131]                       return(sendCondition)
[16:13:46.131]                     ns <- getNamespace("parallel")
[16:13:46.131]                     if (exists("sendData", mode = "function", 
[16:13:46.131]                       envir = ns)) {
[16:13:46.131]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:46.131]                         envir = ns)
[16:13:46.131]                       envir <- sys.frame(frame)
[16:13:46.131]                       master <- NULL
[16:13:46.131]                       while (!identical(envir, .GlobalEnv) && 
[16:13:46.131]                         !identical(envir, emptyenv())) {
[16:13:46.131]                         if (exists("master", mode = "list", envir = envir, 
[16:13:46.131]                           inherits = FALSE)) {
[16:13:46.131]                           master <- get("master", mode = "list", 
[16:13:46.131]                             envir = envir, inherits = FALSE)
[16:13:46.131]                           if (inherits(master, c("SOCKnode", 
[16:13:46.131]                             "SOCK0node"))) {
[16:13:46.131]                             sendCondition <<- function(cond) {
[16:13:46.131]                               data <- list(type = "VALUE", value = cond, 
[16:13:46.131]                                 success = TRUE)
[16:13:46.131]                               parallel_sendData(master, data)
[16:13:46.131]                             }
[16:13:46.131]                             return(sendCondition)
[16:13:46.131]                           }
[16:13:46.131]                         }
[16:13:46.131]                         frame <- frame + 1L
[16:13:46.131]                         envir <- sys.frame(frame)
[16:13:46.131]                       }
[16:13:46.131]                     }
[16:13:46.131]                     sendCondition <<- function(cond) NULL
[16:13:46.131]                   }
[16:13:46.131]                 })
[16:13:46.131]                 withCallingHandlers({
[16:13:46.131]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:46.131]                 }, immediateCondition = function(cond) {
[16:13:46.131]                   sendCondition <- ...future.makeSendCondition()
[16:13:46.131]                   sendCondition(cond)
[16:13:46.131]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:46.131]                   {
[16:13:46.131]                     inherits <- base::inherits
[16:13:46.131]                     invokeRestart <- base::invokeRestart
[16:13:46.131]                     is.null <- base::is.null
[16:13:46.131]                     muffled <- FALSE
[16:13:46.131]                     if (inherits(cond, "message")) {
[16:13:46.131]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:46.131]                       if (muffled) 
[16:13:46.131]                         invokeRestart("muffleMessage")
[16:13:46.131]                     }
[16:13:46.131]                     else if (inherits(cond, "warning")) {
[16:13:46.131]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:46.131]                       if (muffled) 
[16:13:46.131]                         invokeRestart("muffleWarning")
[16:13:46.131]                     }
[16:13:46.131]                     else if (inherits(cond, "condition")) {
[16:13:46.131]                       if (!is.null(pattern)) {
[16:13:46.131]                         computeRestarts <- base::computeRestarts
[16:13:46.131]                         grepl <- base::grepl
[16:13:46.131]                         restarts <- computeRestarts(cond)
[16:13:46.131]                         for (restart in restarts) {
[16:13:46.131]                           name <- restart$name
[16:13:46.131]                           if (is.null(name)) 
[16:13:46.131]                             next
[16:13:46.131]                           if (!grepl(pattern, name)) 
[16:13:46.131]                             next
[16:13:46.131]                           invokeRestart(restart)
[16:13:46.131]                           muffled <- TRUE
[16:13:46.131]                           break
[16:13:46.131]                         }
[16:13:46.131]                       }
[16:13:46.131]                     }
[16:13:46.131]                     invisible(muffled)
[16:13:46.131]                   }
[16:13:46.131]                   muffleCondition(cond)
[16:13:46.131]                 })
[16:13:46.131]             }))
[16:13:46.131]             future::FutureResult(value = ...future.value$value, 
[16:13:46.131]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:46.131]                   ...future.rng), globalenv = if (FALSE) 
[16:13:46.131]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:46.131]                     ...future.globalenv.names))
[16:13:46.131]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:46.131]         }, condition = base::local({
[16:13:46.131]             c <- base::c
[16:13:46.131]             inherits <- base::inherits
[16:13:46.131]             invokeRestart <- base::invokeRestart
[16:13:46.131]             length <- base::length
[16:13:46.131]             list <- base::list
[16:13:46.131]             seq.int <- base::seq.int
[16:13:46.131]             signalCondition <- base::signalCondition
[16:13:46.131]             sys.calls <- base::sys.calls
[16:13:46.131]             `[[` <- base::`[[`
[16:13:46.131]             `+` <- base::`+`
[16:13:46.131]             `<<-` <- base::`<<-`
[16:13:46.131]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:46.131]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:46.131]                   3L)]
[16:13:46.131]             }
[16:13:46.131]             function(cond) {
[16:13:46.131]                 is_error <- inherits(cond, "error")
[16:13:46.131]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:46.131]                   NULL)
[16:13:46.131]                 if (is_error) {
[16:13:46.131]                   sessionInformation <- function() {
[16:13:46.131]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:46.131]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:46.131]                       search = base::search(), system = base::Sys.info())
[16:13:46.131]                   }
[16:13:46.131]                   ...future.conditions[[length(...future.conditions) + 
[16:13:46.131]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:46.131]                     cond$call), session = sessionInformation(), 
[16:13:46.131]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:46.131]                   signalCondition(cond)
[16:13:46.131]                 }
[16:13:46.131]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:46.131]                 "immediateCondition"))) {
[16:13:46.131]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:46.131]                   ...future.conditions[[length(...future.conditions) + 
[16:13:46.131]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:46.131]                   if (TRUE && !signal) {
[16:13:46.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:46.131]                     {
[16:13:46.131]                       inherits <- base::inherits
[16:13:46.131]                       invokeRestart <- base::invokeRestart
[16:13:46.131]                       is.null <- base::is.null
[16:13:46.131]                       muffled <- FALSE
[16:13:46.131]                       if (inherits(cond, "message")) {
[16:13:46.131]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:46.131]                         if (muffled) 
[16:13:46.131]                           invokeRestart("muffleMessage")
[16:13:46.131]                       }
[16:13:46.131]                       else if (inherits(cond, "warning")) {
[16:13:46.131]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:46.131]                         if (muffled) 
[16:13:46.131]                           invokeRestart("muffleWarning")
[16:13:46.131]                       }
[16:13:46.131]                       else if (inherits(cond, "condition")) {
[16:13:46.131]                         if (!is.null(pattern)) {
[16:13:46.131]                           computeRestarts <- base::computeRestarts
[16:13:46.131]                           grepl <- base::grepl
[16:13:46.131]                           restarts <- computeRestarts(cond)
[16:13:46.131]                           for (restart in restarts) {
[16:13:46.131]                             name <- restart$name
[16:13:46.131]                             if (is.null(name)) 
[16:13:46.131]                               next
[16:13:46.131]                             if (!grepl(pattern, name)) 
[16:13:46.131]                               next
[16:13:46.131]                             invokeRestart(restart)
[16:13:46.131]                             muffled <- TRUE
[16:13:46.131]                             break
[16:13:46.131]                           }
[16:13:46.131]                         }
[16:13:46.131]                       }
[16:13:46.131]                       invisible(muffled)
[16:13:46.131]                     }
[16:13:46.131]                     muffleCondition(cond, pattern = "^muffle")
[16:13:46.131]                   }
[16:13:46.131]                 }
[16:13:46.131]                 else {
[16:13:46.131]                   if (TRUE) {
[16:13:46.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:46.131]                     {
[16:13:46.131]                       inherits <- base::inherits
[16:13:46.131]                       invokeRestart <- base::invokeRestart
[16:13:46.131]                       is.null <- base::is.null
[16:13:46.131]                       muffled <- FALSE
[16:13:46.131]                       if (inherits(cond, "message")) {
[16:13:46.131]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:46.131]                         if (muffled) 
[16:13:46.131]                           invokeRestart("muffleMessage")
[16:13:46.131]                       }
[16:13:46.131]                       else if (inherits(cond, "warning")) {
[16:13:46.131]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:46.131]                         if (muffled) 
[16:13:46.131]                           invokeRestart("muffleWarning")
[16:13:46.131]                       }
[16:13:46.131]                       else if (inherits(cond, "condition")) {
[16:13:46.131]                         if (!is.null(pattern)) {
[16:13:46.131]                           computeRestarts <- base::computeRestarts
[16:13:46.131]                           grepl <- base::grepl
[16:13:46.131]                           restarts <- computeRestarts(cond)
[16:13:46.131]                           for (restart in restarts) {
[16:13:46.131]                             name <- restart$name
[16:13:46.131]                             if (is.null(name)) 
[16:13:46.131]                               next
[16:13:46.131]                             if (!grepl(pattern, name)) 
[16:13:46.131]                               next
[16:13:46.131]                             invokeRestart(restart)
[16:13:46.131]                             muffled <- TRUE
[16:13:46.131]                             break
[16:13:46.131]                           }
[16:13:46.131]                         }
[16:13:46.131]                       }
[16:13:46.131]                       invisible(muffled)
[16:13:46.131]                     }
[16:13:46.131]                     muffleCondition(cond, pattern = "^muffle")
[16:13:46.131]                   }
[16:13:46.131]                 }
[16:13:46.131]             }
[16:13:46.131]         }))
[16:13:46.131]     }, error = function(ex) {
[16:13:46.131]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:46.131]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:46.131]                 ...future.rng), started = ...future.startTime, 
[16:13:46.131]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:46.131]             version = "1.8"), class = "FutureResult")
[16:13:46.131]     }, finally = {
[16:13:46.131]         if (!identical(...future.workdir, getwd())) 
[16:13:46.131]             setwd(...future.workdir)
[16:13:46.131]         {
[16:13:46.131]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:46.131]                 ...future.oldOptions$nwarnings <- NULL
[16:13:46.131]             }
[16:13:46.131]             base::options(...future.oldOptions)
[16:13:46.131]             if (.Platform$OS.type == "windows") {
[16:13:46.131]                 old_names <- names(...future.oldEnvVars)
[16:13:46.131]                 envs <- base::Sys.getenv()
[16:13:46.131]                 names <- names(envs)
[16:13:46.131]                 common <- intersect(names, old_names)
[16:13:46.131]                 added <- setdiff(names, old_names)
[16:13:46.131]                 removed <- setdiff(old_names, names)
[16:13:46.131]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:46.131]                   envs[common]]
[16:13:46.131]                 NAMES <- toupper(changed)
[16:13:46.131]                 args <- list()
[16:13:46.131]                 for (kk in seq_along(NAMES)) {
[16:13:46.131]                   name <- changed[[kk]]
[16:13:46.131]                   NAME <- NAMES[[kk]]
[16:13:46.131]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:46.131]                     next
[16:13:46.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:46.131]                 }
[16:13:46.131]                 NAMES <- toupper(added)
[16:13:46.131]                 for (kk in seq_along(NAMES)) {
[16:13:46.131]                   name <- added[[kk]]
[16:13:46.131]                   NAME <- NAMES[[kk]]
[16:13:46.131]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:46.131]                     next
[16:13:46.131]                   args[[name]] <- ""
[16:13:46.131]                 }
[16:13:46.131]                 NAMES <- toupper(removed)
[16:13:46.131]                 for (kk in seq_along(NAMES)) {
[16:13:46.131]                   name <- removed[[kk]]
[16:13:46.131]                   NAME <- NAMES[[kk]]
[16:13:46.131]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:46.131]                     next
[16:13:46.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:46.131]                 }
[16:13:46.131]                 if (length(args) > 0) 
[16:13:46.131]                   base::do.call(base::Sys.setenv, args = args)
[16:13:46.131]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:46.131]             }
[16:13:46.131]             else {
[16:13:46.131]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:46.131]             }
[16:13:46.131]             {
[16:13:46.131]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:46.131]                   0L) {
[16:13:46.131]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:46.131]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:46.131]                   base::options(opts)
[16:13:46.131]                 }
[16:13:46.131]                 {
[16:13:46.131]                   {
[16:13:46.131]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:46.131]                     NULL
[16:13:46.131]                   }
[16:13:46.131]                   options(future.plan = NULL)
[16:13:46.131]                   if (is.na(NA_character_)) 
[16:13:46.131]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:46.131]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:46.131]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:46.131]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:46.131]                     envir = parent.frame()) 
[16:13:46.131]                   {
[16:13:46.131]                     if (is.function(workers)) 
[16:13:46.131]                       workers <- workers()
[16:13:46.131]                     workers <- structure(as.integer(workers), 
[16:13:46.131]                       class = class(workers))
[16:13:46.131]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:46.131]                       workers >= 1)
[16:13:46.131]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:46.131]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:46.131]                     }
[16:13:46.131]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:46.131]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:46.131]                       envir = envir)
[16:13:46.131]                     if (!future$lazy) 
[16:13:46.131]                       future <- run(future)
[16:13:46.131]                     invisible(future)
[16:13:46.131]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:46.131]                 }
[16:13:46.131]             }
[16:13:46.131]         }
[16:13:46.131]     })
[16:13:46.131]     if (TRUE) {
[16:13:46.131]         base::sink(type = "output", split = FALSE)
[16:13:46.131]         if (TRUE) {
[16:13:46.131]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:46.131]         }
[16:13:46.131]         else {
[16:13:46.131]             ...future.result["stdout"] <- base::list(NULL)
[16:13:46.131]         }
[16:13:46.131]         base::close(...future.stdout)
[16:13:46.131]         ...future.stdout <- NULL
[16:13:46.131]     }
[16:13:46.131]     ...future.result$conditions <- ...future.conditions
[16:13:46.131]     ...future.result$finished <- base::Sys.time()
[16:13:46.131]     ...future.result
[16:13:46.131] }
[16:13:46.134] MultisessionFuture started
[16:13:46.134] - Launch lazy future ... done
[16:13:46.134] run() for ‘MultisessionFuture’ ... done
[16:13:46.180] receiveMessageFromWorker() for ClusterFuture ...
[16:13:46.180] - Validating connection of MultisessionFuture
[16:13:46.181] - received message: FutureResult
[16:13:46.181] - Received FutureResult
[16:13:46.181] - Erased future from FutureRegistry
[16:13:46.181] result() for ClusterFuture ...
[16:13:46.181] - result already collected: FutureResult
[16:13:46.182] result() for ClusterFuture ... done
[16:13:46.182] signalConditions() ...
[16:13:46.182]  - include = ‘immediateCondition’
[16:13:46.182]  - exclude = 
[16:13:46.182]  - resignal = FALSE
[16:13:46.182]  - Number of conditions: 1
[16:13:46.182] signalConditions() ... done
[16:13:46.182] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:46.182] A MultisessionFuture was resolved (result was not collected)
[16:13:46.183] getGlobalsAndPackages() ...
[16:13:46.183] Searching for globals...
[16:13:46.183] - globals found: [2] ‘list’, ‘stop’
[16:13:46.184] Searching for globals ... DONE
[16:13:46.184] Resolving globals: FALSE
[16:13:46.184] 
[16:13:46.184] 
[16:13:46.184] getGlobalsAndPackages() ... DONE
[16:13:46.184] run() for ‘Future’ ...
[16:13:46.185] - state: ‘created’
[16:13:46.185] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:46.200] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:46.200] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:46.202]   - Field: ‘node’
[16:13:46.202]   - Field: ‘label’
[16:13:46.202]   - Field: ‘local’
[16:13:46.202]   - Field: ‘owner’
[16:13:46.202]   - Field: ‘envir’
[16:13:46.202]   - Field: ‘workers’
[16:13:46.202]   - Field: ‘packages’
[16:13:46.203]   - Field: ‘gc’
[16:13:46.203]   - Field: ‘conditions’
[16:13:46.203]   - Field: ‘persistent’
[16:13:46.203]   - Field: ‘expr’
[16:13:46.203]   - Field: ‘uuid’
[16:13:46.203]   - Field: ‘seed’
[16:13:46.203]   - Field: ‘version’
[16:13:46.203]   - Field: ‘result’
[16:13:46.203]   - Field: ‘asynchronous’
[16:13:46.203]   - Field: ‘calls’
[16:13:46.203]   - Field: ‘globals’
[16:13:46.203]   - Field: ‘stdout’
[16:13:46.204]   - Field: ‘earlySignal’
[16:13:46.204]   - Field: ‘lazy’
[16:13:46.204]   - Field: ‘state’
[16:13:46.204] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:46.204] - Launch lazy future ...
[16:13:46.204] Packages needed by the future expression (n = 0): <none>
[16:13:46.204] Packages needed by future strategies (n = 0): <none>
[16:13:46.205] {
[16:13:46.205]     {
[16:13:46.205]         {
[16:13:46.205]             ...future.startTime <- base::Sys.time()
[16:13:46.205]             {
[16:13:46.205]                 {
[16:13:46.205]                   {
[16:13:46.205]                     {
[16:13:46.205]                       base::local({
[16:13:46.205]                         has_future <- base::requireNamespace("future", 
[16:13:46.205]                           quietly = TRUE)
[16:13:46.205]                         if (has_future) {
[16:13:46.205]                           ns <- base::getNamespace("future")
[16:13:46.205]                           version <- ns[[".package"]][["version"]]
[16:13:46.205]                           if (is.null(version)) 
[16:13:46.205]                             version <- utils::packageVersion("future")
[16:13:46.205]                         }
[16:13:46.205]                         else {
[16:13:46.205]                           version <- NULL
[16:13:46.205]                         }
[16:13:46.205]                         if (!has_future || version < "1.8.0") {
[16:13:46.205]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:46.205]                             "", base::R.version$version.string), 
[16:13:46.205]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:46.205]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:46.205]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:46.205]                               "release", "version")], collapse = " "), 
[16:13:46.205]                             hostname = base::Sys.info()[["nodename"]])
[16:13:46.205]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:46.205]                             info)
[16:13:46.205]                           info <- base::paste(info, collapse = "; ")
[16:13:46.205]                           if (!has_future) {
[16:13:46.205]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:46.205]                               info)
[16:13:46.205]                           }
[16:13:46.205]                           else {
[16:13:46.205]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:46.205]                               info, version)
[16:13:46.205]                           }
[16:13:46.205]                           base::stop(msg)
[16:13:46.205]                         }
[16:13:46.205]                       })
[16:13:46.205]                     }
[16:13:46.205]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:46.205]                     base::options(mc.cores = 1L)
[16:13:46.205]                   }
[16:13:46.205]                   options(future.plan = NULL)
[16:13:46.205]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:46.205]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:46.205]                 }
[16:13:46.205]                 ...future.workdir <- getwd()
[16:13:46.205]             }
[16:13:46.205]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:46.205]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:46.205]         }
[16:13:46.205]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:46.205]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:46.205]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:46.205]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:46.205]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:46.205]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:46.205]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:46.205]             base::names(...future.oldOptions))
[16:13:46.205]     }
[16:13:46.205]     if (FALSE) {
[16:13:46.205]     }
[16:13:46.205]     else {
[16:13:46.205]         if (TRUE) {
[16:13:46.205]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:46.205]                 open = "w")
[16:13:46.205]         }
[16:13:46.205]         else {
[16:13:46.205]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:46.205]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:46.205]         }
[16:13:46.205]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:46.205]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:46.205]             base::sink(type = "output", split = FALSE)
[16:13:46.205]             base::close(...future.stdout)
[16:13:46.205]         }, add = TRUE)
[16:13:46.205]     }
[16:13:46.205]     ...future.frame <- base::sys.nframe()
[16:13:46.205]     ...future.conditions <- base::list()
[16:13:46.205]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:46.205]     if (FALSE) {
[16:13:46.205]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:46.205]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:46.205]     }
[16:13:46.205]     ...future.result <- base::tryCatch({
[16:13:46.205]         base::withCallingHandlers({
[16:13:46.205]             ...future.value <- base::withVisible(base::local({
[16:13:46.205]                 ...future.makeSendCondition <- local({
[16:13:46.205]                   sendCondition <- NULL
[16:13:46.205]                   function(frame = 1L) {
[16:13:46.205]                     if (is.function(sendCondition)) 
[16:13:46.205]                       return(sendCondition)
[16:13:46.205]                     ns <- getNamespace("parallel")
[16:13:46.205]                     if (exists("sendData", mode = "function", 
[16:13:46.205]                       envir = ns)) {
[16:13:46.205]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:46.205]                         envir = ns)
[16:13:46.205]                       envir <- sys.frame(frame)
[16:13:46.205]                       master <- NULL
[16:13:46.205]                       while (!identical(envir, .GlobalEnv) && 
[16:13:46.205]                         !identical(envir, emptyenv())) {
[16:13:46.205]                         if (exists("master", mode = "list", envir = envir, 
[16:13:46.205]                           inherits = FALSE)) {
[16:13:46.205]                           master <- get("master", mode = "list", 
[16:13:46.205]                             envir = envir, inherits = FALSE)
[16:13:46.205]                           if (inherits(master, c("SOCKnode", 
[16:13:46.205]                             "SOCK0node"))) {
[16:13:46.205]                             sendCondition <<- function(cond) {
[16:13:46.205]                               data <- list(type = "VALUE", value = cond, 
[16:13:46.205]                                 success = TRUE)
[16:13:46.205]                               parallel_sendData(master, data)
[16:13:46.205]                             }
[16:13:46.205]                             return(sendCondition)
[16:13:46.205]                           }
[16:13:46.205]                         }
[16:13:46.205]                         frame <- frame + 1L
[16:13:46.205]                         envir <- sys.frame(frame)
[16:13:46.205]                       }
[16:13:46.205]                     }
[16:13:46.205]                     sendCondition <<- function(cond) NULL
[16:13:46.205]                   }
[16:13:46.205]                 })
[16:13:46.205]                 withCallingHandlers({
[16:13:46.205]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:46.205]                 }, immediateCondition = function(cond) {
[16:13:46.205]                   sendCondition <- ...future.makeSendCondition()
[16:13:46.205]                   sendCondition(cond)
[16:13:46.205]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:46.205]                   {
[16:13:46.205]                     inherits <- base::inherits
[16:13:46.205]                     invokeRestart <- base::invokeRestart
[16:13:46.205]                     is.null <- base::is.null
[16:13:46.205]                     muffled <- FALSE
[16:13:46.205]                     if (inherits(cond, "message")) {
[16:13:46.205]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:46.205]                       if (muffled) 
[16:13:46.205]                         invokeRestart("muffleMessage")
[16:13:46.205]                     }
[16:13:46.205]                     else if (inherits(cond, "warning")) {
[16:13:46.205]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:46.205]                       if (muffled) 
[16:13:46.205]                         invokeRestart("muffleWarning")
[16:13:46.205]                     }
[16:13:46.205]                     else if (inherits(cond, "condition")) {
[16:13:46.205]                       if (!is.null(pattern)) {
[16:13:46.205]                         computeRestarts <- base::computeRestarts
[16:13:46.205]                         grepl <- base::grepl
[16:13:46.205]                         restarts <- computeRestarts(cond)
[16:13:46.205]                         for (restart in restarts) {
[16:13:46.205]                           name <- restart$name
[16:13:46.205]                           if (is.null(name)) 
[16:13:46.205]                             next
[16:13:46.205]                           if (!grepl(pattern, name)) 
[16:13:46.205]                             next
[16:13:46.205]                           invokeRestart(restart)
[16:13:46.205]                           muffled <- TRUE
[16:13:46.205]                           break
[16:13:46.205]                         }
[16:13:46.205]                       }
[16:13:46.205]                     }
[16:13:46.205]                     invisible(muffled)
[16:13:46.205]                   }
[16:13:46.205]                   muffleCondition(cond)
[16:13:46.205]                 })
[16:13:46.205]             }))
[16:13:46.205]             future::FutureResult(value = ...future.value$value, 
[16:13:46.205]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:46.205]                   ...future.rng), globalenv = if (FALSE) 
[16:13:46.205]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:46.205]                     ...future.globalenv.names))
[16:13:46.205]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:46.205]         }, condition = base::local({
[16:13:46.205]             c <- base::c
[16:13:46.205]             inherits <- base::inherits
[16:13:46.205]             invokeRestart <- base::invokeRestart
[16:13:46.205]             length <- base::length
[16:13:46.205]             list <- base::list
[16:13:46.205]             seq.int <- base::seq.int
[16:13:46.205]             signalCondition <- base::signalCondition
[16:13:46.205]             sys.calls <- base::sys.calls
[16:13:46.205]             `[[` <- base::`[[`
[16:13:46.205]             `+` <- base::`+`
[16:13:46.205]             `<<-` <- base::`<<-`
[16:13:46.205]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:46.205]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:46.205]                   3L)]
[16:13:46.205]             }
[16:13:46.205]             function(cond) {
[16:13:46.205]                 is_error <- inherits(cond, "error")
[16:13:46.205]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:46.205]                   NULL)
[16:13:46.205]                 if (is_error) {
[16:13:46.205]                   sessionInformation <- function() {
[16:13:46.205]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:46.205]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:46.205]                       search = base::search(), system = base::Sys.info())
[16:13:46.205]                   }
[16:13:46.205]                   ...future.conditions[[length(...future.conditions) + 
[16:13:46.205]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:46.205]                     cond$call), session = sessionInformation(), 
[16:13:46.205]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:46.205]                   signalCondition(cond)
[16:13:46.205]                 }
[16:13:46.205]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:46.205]                 "immediateCondition"))) {
[16:13:46.205]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:46.205]                   ...future.conditions[[length(...future.conditions) + 
[16:13:46.205]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:46.205]                   if (TRUE && !signal) {
[16:13:46.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:46.205]                     {
[16:13:46.205]                       inherits <- base::inherits
[16:13:46.205]                       invokeRestart <- base::invokeRestart
[16:13:46.205]                       is.null <- base::is.null
[16:13:46.205]                       muffled <- FALSE
[16:13:46.205]                       if (inherits(cond, "message")) {
[16:13:46.205]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:46.205]                         if (muffled) 
[16:13:46.205]                           invokeRestart("muffleMessage")
[16:13:46.205]                       }
[16:13:46.205]                       else if (inherits(cond, "warning")) {
[16:13:46.205]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:46.205]                         if (muffled) 
[16:13:46.205]                           invokeRestart("muffleWarning")
[16:13:46.205]                       }
[16:13:46.205]                       else if (inherits(cond, "condition")) {
[16:13:46.205]                         if (!is.null(pattern)) {
[16:13:46.205]                           computeRestarts <- base::computeRestarts
[16:13:46.205]                           grepl <- base::grepl
[16:13:46.205]                           restarts <- computeRestarts(cond)
[16:13:46.205]                           for (restart in restarts) {
[16:13:46.205]                             name <- restart$name
[16:13:46.205]                             if (is.null(name)) 
[16:13:46.205]                               next
[16:13:46.205]                             if (!grepl(pattern, name)) 
[16:13:46.205]                               next
[16:13:46.205]                             invokeRestart(restart)
[16:13:46.205]                             muffled <- TRUE
[16:13:46.205]                             break
[16:13:46.205]                           }
[16:13:46.205]                         }
[16:13:46.205]                       }
[16:13:46.205]                       invisible(muffled)
[16:13:46.205]                     }
[16:13:46.205]                     muffleCondition(cond, pattern = "^muffle")
[16:13:46.205]                   }
[16:13:46.205]                 }
[16:13:46.205]                 else {
[16:13:46.205]                   if (TRUE) {
[16:13:46.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:46.205]                     {
[16:13:46.205]                       inherits <- base::inherits
[16:13:46.205]                       invokeRestart <- base::invokeRestart
[16:13:46.205]                       is.null <- base::is.null
[16:13:46.205]                       muffled <- FALSE
[16:13:46.205]                       if (inherits(cond, "message")) {
[16:13:46.205]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:46.205]                         if (muffled) 
[16:13:46.205]                           invokeRestart("muffleMessage")
[16:13:46.205]                       }
[16:13:46.205]                       else if (inherits(cond, "warning")) {
[16:13:46.205]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:46.205]                         if (muffled) 
[16:13:46.205]                           invokeRestart("muffleWarning")
[16:13:46.205]                       }
[16:13:46.205]                       else if (inherits(cond, "condition")) {
[16:13:46.205]                         if (!is.null(pattern)) {
[16:13:46.205]                           computeRestarts <- base::computeRestarts
[16:13:46.205]                           grepl <- base::grepl
[16:13:46.205]                           restarts <- computeRestarts(cond)
[16:13:46.205]                           for (restart in restarts) {
[16:13:46.205]                             name <- restart$name
[16:13:46.205]                             if (is.null(name)) 
[16:13:46.205]                               next
[16:13:46.205]                             if (!grepl(pattern, name)) 
[16:13:46.205]                               next
[16:13:46.205]                             invokeRestart(restart)
[16:13:46.205]                             muffled <- TRUE
[16:13:46.205]                             break
[16:13:46.205]                           }
[16:13:46.205]                         }
[16:13:46.205]                       }
[16:13:46.205]                       invisible(muffled)
[16:13:46.205]                     }
[16:13:46.205]                     muffleCondition(cond, pattern = "^muffle")
[16:13:46.205]                   }
[16:13:46.205]                 }
[16:13:46.205]             }
[16:13:46.205]         }))
[16:13:46.205]     }, error = function(ex) {
[16:13:46.205]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:46.205]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:46.205]                 ...future.rng), started = ...future.startTime, 
[16:13:46.205]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:46.205]             version = "1.8"), class = "FutureResult")
[16:13:46.205]     }, finally = {
[16:13:46.205]         if (!identical(...future.workdir, getwd())) 
[16:13:46.205]             setwd(...future.workdir)
[16:13:46.205]         {
[16:13:46.205]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:46.205]                 ...future.oldOptions$nwarnings <- NULL
[16:13:46.205]             }
[16:13:46.205]             base::options(...future.oldOptions)
[16:13:46.205]             if (.Platform$OS.type == "windows") {
[16:13:46.205]                 old_names <- names(...future.oldEnvVars)
[16:13:46.205]                 envs <- base::Sys.getenv()
[16:13:46.205]                 names <- names(envs)
[16:13:46.205]                 common <- intersect(names, old_names)
[16:13:46.205]                 added <- setdiff(names, old_names)
[16:13:46.205]                 removed <- setdiff(old_names, names)
[16:13:46.205]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:46.205]                   envs[common]]
[16:13:46.205]                 NAMES <- toupper(changed)
[16:13:46.205]                 args <- list()
[16:13:46.205]                 for (kk in seq_along(NAMES)) {
[16:13:46.205]                   name <- changed[[kk]]
[16:13:46.205]                   NAME <- NAMES[[kk]]
[16:13:46.205]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:46.205]                     next
[16:13:46.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:46.205]                 }
[16:13:46.205]                 NAMES <- toupper(added)
[16:13:46.205]                 for (kk in seq_along(NAMES)) {
[16:13:46.205]                   name <- added[[kk]]
[16:13:46.205]                   NAME <- NAMES[[kk]]
[16:13:46.205]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:46.205]                     next
[16:13:46.205]                   args[[name]] <- ""
[16:13:46.205]                 }
[16:13:46.205]                 NAMES <- toupper(removed)
[16:13:46.205]                 for (kk in seq_along(NAMES)) {
[16:13:46.205]                   name <- removed[[kk]]
[16:13:46.205]                   NAME <- NAMES[[kk]]
[16:13:46.205]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:46.205]                     next
[16:13:46.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:46.205]                 }
[16:13:46.205]                 if (length(args) > 0) 
[16:13:46.205]                   base::do.call(base::Sys.setenv, args = args)
[16:13:46.205]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:46.205]             }
[16:13:46.205]             else {
[16:13:46.205]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:46.205]             }
[16:13:46.205]             {
[16:13:46.205]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:46.205]                   0L) {
[16:13:46.205]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:46.205]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:46.205]                   base::options(opts)
[16:13:46.205]                 }
[16:13:46.205]                 {
[16:13:46.205]                   {
[16:13:46.205]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:46.205]                     NULL
[16:13:46.205]                   }
[16:13:46.205]                   options(future.plan = NULL)
[16:13:46.205]                   if (is.na(NA_character_)) 
[16:13:46.205]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:46.205]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:46.205]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:46.205]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:46.205]                     envir = parent.frame()) 
[16:13:46.205]                   {
[16:13:46.205]                     if (is.function(workers)) 
[16:13:46.205]                       workers <- workers()
[16:13:46.205]                     workers <- structure(as.integer(workers), 
[16:13:46.205]                       class = class(workers))
[16:13:46.205]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:46.205]                       workers >= 1)
[16:13:46.205]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:46.205]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:46.205]                     }
[16:13:46.205]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:46.205]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:46.205]                       envir = envir)
[16:13:46.205]                     if (!future$lazy) 
[16:13:46.205]                       future <- run(future)
[16:13:46.205]                     invisible(future)
[16:13:46.205]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:46.205]                 }
[16:13:46.205]             }
[16:13:46.205]         }
[16:13:46.205]     })
[16:13:46.205]     if (TRUE) {
[16:13:46.205]         base::sink(type = "output", split = FALSE)
[16:13:46.205]         if (TRUE) {
[16:13:46.205]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:46.205]         }
[16:13:46.205]         else {
[16:13:46.205]             ...future.result["stdout"] <- base::list(NULL)
[16:13:46.205]         }
[16:13:46.205]         base::close(...future.stdout)
[16:13:46.205]         ...future.stdout <- NULL
[16:13:46.205]     }
[16:13:46.205]     ...future.result$conditions <- ...future.conditions
[16:13:46.205]     ...future.result$finished <- base::Sys.time()
[16:13:46.205]     ...future.result
[16:13:46.205] }
[16:13:46.208] MultisessionFuture started
[16:13:46.208] - Launch lazy future ... done
[16:13:46.208] run() for ‘MultisessionFuture’ ... done
[16:13:46.256] receiveMessageFromWorker() for ClusterFuture ...
[16:13:46.257] - Validating connection of MultisessionFuture
[16:13:46.257] - received message: FutureResult
[16:13:46.257] - Received FutureResult
[16:13:46.257] - Erased future from FutureRegistry
[16:13:46.257] result() for ClusterFuture ...
[16:13:46.257] - result already collected: FutureResult
[16:13:46.257] result() for ClusterFuture ... done
[16:13:46.258] signalConditions() ...
[16:13:46.258]  - include = ‘immediateCondition’
[16:13:46.258]  - exclude = 
[16:13:46.258]  - resignal = FALSE
[16:13:46.258]  - Number of conditions: 1
[16:13:46.258] signalConditions() ... done
[16:13:46.258] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:46.258] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = TRUE ... DONE
- result = FALSE, recursive = -1 ...
[16:13:46.258] getGlobalsAndPackages() ...
[16:13:46.259] Searching for globals...
[16:13:46.260] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:46.260] Searching for globals ... DONE
[16:13:46.260] Resolving globals: FALSE
[16:13:46.260] 
[16:13:46.260] 
[16:13:46.260] getGlobalsAndPackages() ... DONE
[16:13:46.261] run() for ‘Future’ ...
[16:13:46.261] - state: ‘created’
[16:13:46.261] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:46.275] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:46.275] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:46.275]   - Field: ‘node’
[16:13:46.275]   - Field: ‘label’
[16:13:46.275]   - Field: ‘local’
[16:13:46.275]   - Field: ‘owner’
[16:13:46.275]   - Field: ‘envir’
[16:13:46.276]   - Field: ‘workers’
[16:13:46.276]   - Field: ‘packages’
[16:13:46.276]   - Field: ‘gc’
[16:13:46.276]   - Field: ‘conditions’
[16:13:46.276]   - Field: ‘persistent’
[16:13:46.276]   - Field: ‘expr’
[16:13:46.276]   - Field: ‘uuid’
[16:13:46.276]   - Field: ‘seed’
[16:13:46.276]   - Field: ‘version’
[16:13:46.276]   - Field: ‘result’
[16:13:46.277]   - Field: ‘asynchronous’
[16:13:46.277]   - Field: ‘calls’
[16:13:46.277]   - Field: ‘globals’
[16:13:46.277]   - Field: ‘stdout’
[16:13:46.277]   - Field: ‘earlySignal’
[16:13:46.277]   - Field: ‘lazy’
[16:13:46.277]   - Field: ‘state’
[16:13:46.277] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:46.277] - Launch lazy future ...
[16:13:46.278] Packages needed by the future expression (n = 0): <none>
[16:13:46.278] Packages needed by future strategies (n = 0): <none>
[16:13:46.278] {
[16:13:46.278]     {
[16:13:46.278]         {
[16:13:46.278]             ...future.startTime <- base::Sys.time()
[16:13:46.278]             {
[16:13:46.278]                 {
[16:13:46.278]                   {
[16:13:46.278]                     {
[16:13:46.278]                       base::local({
[16:13:46.278]                         has_future <- base::requireNamespace("future", 
[16:13:46.278]                           quietly = TRUE)
[16:13:46.278]                         if (has_future) {
[16:13:46.278]                           ns <- base::getNamespace("future")
[16:13:46.278]                           version <- ns[[".package"]][["version"]]
[16:13:46.278]                           if (is.null(version)) 
[16:13:46.278]                             version <- utils::packageVersion("future")
[16:13:46.278]                         }
[16:13:46.278]                         else {
[16:13:46.278]                           version <- NULL
[16:13:46.278]                         }
[16:13:46.278]                         if (!has_future || version < "1.8.0") {
[16:13:46.278]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:46.278]                             "", base::R.version$version.string), 
[16:13:46.278]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:46.278]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:46.278]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:46.278]                               "release", "version")], collapse = " "), 
[16:13:46.278]                             hostname = base::Sys.info()[["nodename"]])
[16:13:46.278]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:46.278]                             info)
[16:13:46.278]                           info <- base::paste(info, collapse = "; ")
[16:13:46.278]                           if (!has_future) {
[16:13:46.278]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:46.278]                               info)
[16:13:46.278]                           }
[16:13:46.278]                           else {
[16:13:46.278]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:46.278]                               info, version)
[16:13:46.278]                           }
[16:13:46.278]                           base::stop(msg)
[16:13:46.278]                         }
[16:13:46.278]                       })
[16:13:46.278]                     }
[16:13:46.278]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:46.278]                     base::options(mc.cores = 1L)
[16:13:46.278]                   }
[16:13:46.278]                   options(future.plan = NULL)
[16:13:46.278]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:46.278]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:46.278]                 }
[16:13:46.278]                 ...future.workdir <- getwd()
[16:13:46.278]             }
[16:13:46.278]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:46.278]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:46.278]         }
[16:13:46.278]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:46.278]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:46.278]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:46.278]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:46.278]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:46.278]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:46.278]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:46.278]             base::names(...future.oldOptions))
[16:13:46.278]     }
[16:13:46.278]     if (FALSE) {
[16:13:46.278]     }
[16:13:46.278]     else {
[16:13:46.278]         if (TRUE) {
[16:13:46.278]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:46.278]                 open = "w")
[16:13:46.278]         }
[16:13:46.278]         else {
[16:13:46.278]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:46.278]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:46.278]         }
[16:13:46.278]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:46.278]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:46.278]             base::sink(type = "output", split = FALSE)
[16:13:46.278]             base::close(...future.stdout)
[16:13:46.278]         }, add = TRUE)
[16:13:46.278]     }
[16:13:46.278]     ...future.frame <- base::sys.nframe()
[16:13:46.278]     ...future.conditions <- base::list()
[16:13:46.278]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:46.278]     if (FALSE) {
[16:13:46.278]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:46.278]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:46.278]     }
[16:13:46.278]     ...future.result <- base::tryCatch({
[16:13:46.278]         base::withCallingHandlers({
[16:13:46.278]             ...future.value <- base::withVisible(base::local({
[16:13:46.278]                 ...future.makeSendCondition <- local({
[16:13:46.278]                   sendCondition <- NULL
[16:13:46.278]                   function(frame = 1L) {
[16:13:46.278]                     if (is.function(sendCondition)) 
[16:13:46.278]                       return(sendCondition)
[16:13:46.278]                     ns <- getNamespace("parallel")
[16:13:46.278]                     if (exists("sendData", mode = "function", 
[16:13:46.278]                       envir = ns)) {
[16:13:46.278]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:46.278]                         envir = ns)
[16:13:46.278]                       envir <- sys.frame(frame)
[16:13:46.278]                       master <- NULL
[16:13:46.278]                       while (!identical(envir, .GlobalEnv) && 
[16:13:46.278]                         !identical(envir, emptyenv())) {
[16:13:46.278]                         if (exists("master", mode = "list", envir = envir, 
[16:13:46.278]                           inherits = FALSE)) {
[16:13:46.278]                           master <- get("master", mode = "list", 
[16:13:46.278]                             envir = envir, inherits = FALSE)
[16:13:46.278]                           if (inherits(master, c("SOCKnode", 
[16:13:46.278]                             "SOCK0node"))) {
[16:13:46.278]                             sendCondition <<- function(cond) {
[16:13:46.278]                               data <- list(type = "VALUE", value = cond, 
[16:13:46.278]                                 success = TRUE)
[16:13:46.278]                               parallel_sendData(master, data)
[16:13:46.278]                             }
[16:13:46.278]                             return(sendCondition)
[16:13:46.278]                           }
[16:13:46.278]                         }
[16:13:46.278]                         frame <- frame + 1L
[16:13:46.278]                         envir <- sys.frame(frame)
[16:13:46.278]                       }
[16:13:46.278]                     }
[16:13:46.278]                     sendCondition <<- function(cond) NULL
[16:13:46.278]                   }
[16:13:46.278]                 })
[16:13:46.278]                 withCallingHandlers({
[16:13:46.278]                   {
[16:13:46.278]                     Sys.sleep(0.5)
[16:13:46.278]                     list(a = 1, b = 42L)
[16:13:46.278]                   }
[16:13:46.278]                 }, immediateCondition = function(cond) {
[16:13:46.278]                   sendCondition <- ...future.makeSendCondition()
[16:13:46.278]                   sendCondition(cond)
[16:13:46.278]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:46.278]                   {
[16:13:46.278]                     inherits <- base::inherits
[16:13:46.278]                     invokeRestart <- base::invokeRestart
[16:13:46.278]                     is.null <- base::is.null
[16:13:46.278]                     muffled <- FALSE
[16:13:46.278]                     if (inherits(cond, "message")) {
[16:13:46.278]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:46.278]                       if (muffled) 
[16:13:46.278]                         invokeRestart("muffleMessage")
[16:13:46.278]                     }
[16:13:46.278]                     else if (inherits(cond, "warning")) {
[16:13:46.278]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:46.278]                       if (muffled) 
[16:13:46.278]                         invokeRestart("muffleWarning")
[16:13:46.278]                     }
[16:13:46.278]                     else if (inherits(cond, "condition")) {
[16:13:46.278]                       if (!is.null(pattern)) {
[16:13:46.278]                         computeRestarts <- base::computeRestarts
[16:13:46.278]                         grepl <- base::grepl
[16:13:46.278]                         restarts <- computeRestarts(cond)
[16:13:46.278]                         for (restart in restarts) {
[16:13:46.278]                           name <- restart$name
[16:13:46.278]                           if (is.null(name)) 
[16:13:46.278]                             next
[16:13:46.278]                           if (!grepl(pattern, name)) 
[16:13:46.278]                             next
[16:13:46.278]                           invokeRestart(restart)
[16:13:46.278]                           muffled <- TRUE
[16:13:46.278]                           break
[16:13:46.278]                         }
[16:13:46.278]                       }
[16:13:46.278]                     }
[16:13:46.278]                     invisible(muffled)
[16:13:46.278]                   }
[16:13:46.278]                   muffleCondition(cond)
[16:13:46.278]                 })
[16:13:46.278]             }))
[16:13:46.278]             future::FutureResult(value = ...future.value$value, 
[16:13:46.278]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:46.278]                   ...future.rng), globalenv = if (FALSE) 
[16:13:46.278]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:46.278]                     ...future.globalenv.names))
[16:13:46.278]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:46.278]         }, condition = base::local({
[16:13:46.278]             c <- base::c
[16:13:46.278]             inherits <- base::inherits
[16:13:46.278]             invokeRestart <- base::invokeRestart
[16:13:46.278]             length <- base::length
[16:13:46.278]             list <- base::list
[16:13:46.278]             seq.int <- base::seq.int
[16:13:46.278]             signalCondition <- base::signalCondition
[16:13:46.278]             sys.calls <- base::sys.calls
[16:13:46.278]             `[[` <- base::`[[`
[16:13:46.278]             `+` <- base::`+`
[16:13:46.278]             `<<-` <- base::`<<-`
[16:13:46.278]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:46.278]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:46.278]                   3L)]
[16:13:46.278]             }
[16:13:46.278]             function(cond) {
[16:13:46.278]                 is_error <- inherits(cond, "error")
[16:13:46.278]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:46.278]                   NULL)
[16:13:46.278]                 if (is_error) {
[16:13:46.278]                   sessionInformation <- function() {
[16:13:46.278]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:46.278]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:46.278]                       search = base::search(), system = base::Sys.info())
[16:13:46.278]                   }
[16:13:46.278]                   ...future.conditions[[length(...future.conditions) + 
[16:13:46.278]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:46.278]                     cond$call), session = sessionInformation(), 
[16:13:46.278]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:46.278]                   signalCondition(cond)
[16:13:46.278]                 }
[16:13:46.278]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:46.278]                 "immediateCondition"))) {
[16:13:46.278]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:46.278]                   ...future.conditions[[length(...future.conditions) + 
[16:13:46.278]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:46.278]                   if (TRUE && !signal) {
[16:13:46.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:46.278]                     {
[16:13:46.278]                       inherits <- base::inherits
[16:13:46.278]                       invokeRestart <- base::invokeRestart
[16:13:46.278]                       is.null <- base::is.null
[16:13:46.278]                       muffled <- FALSE
[16:13:46.278]                       if (inherits(cond, "message")) {
[16:13:46.278]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:46.278]                         if (muffled) 
[16:13:46.278]                           invokeRestart("muffleMessage")
[16:13:46.278]                       }
[16:13:46.278]                       else if (inherits(cond, "warning")) {
[16:13:46.278]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:46.278]                         if (muffled) 
[16:13:46.278]                           invokeRestart("muffleWarning")
[16:13:46.278]                       }
[16:13:46.278]                       else if (inherits(cond, "condition")) {
[16:13:46.278]                         if (!is.null(pattern)) {
[16:13:46.278]                           computeRestarts <- base::computeRestarts
[16:13:46.278]                           grepl <- base::grepl
[16:13:46.278]                           restarts <- computeRestarts(cond)
[16:13:46.278]                           for (restart in restarts) {
[16:13:46.278]                             name <- restart$name
[16:13:46.278]                             if (is.null(name)) 
[16:13:46.278]                               next
[16:13:46.278]                             if (!grepl(pattern, name)) 
[16:13:46.278]                               next
[16:13:46.278]                             invokeRestart(restart)
[16:13:46.278]                             muffled <- TRUE
[16:13:46.278]                             break
[16:13:46.278]                           }
[16:13:46.278]                         }
[16:13:46.278]                       }
[16:13:46.278]                       invisible(muffled)
[16:13:46.278]                     }
[16:13:46.278]                     muffleCondition(cond, pattern = "^muffle")
[16:13:46.278]                   }
[16:13:46.278]                 }
[16:13:46.278]                 else {
[16:13:46.278]                   if (TRUE) {
[16:13:46.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:46.278]                     {
[16:13:46.278]                       inherits <- base::inherits
[16:13:46.278]                       invokeRestart <- base::invokeRestart
[16:13:46.278]                       is.null <- base::is.null
[16:13:46.278]                       muffled <- FALSE
[16:13:46.278]                       if (inherits(cond, "message")) {
[16:13:46.278]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:46.278]                         if (muffled) 
[16:13:46.278]                           invokeRestart("muffleMessage")
[16:13:46.278]                       }
[16:13:46.278]                       else if (inherits(cond, "warning")) {
[16:13:46.278]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:46.278]                         if (muffled) 
[16:13:46.278]                           invokeRestart("muffleWarning")
[16:13:46.278]                       }
[16:13:46.278]                       else if (inherits(cond, "condition")) {
[16:13:46.278]                         if (!is.null(pattern)) {
[16:13:46.278]                           computeRestarts <- base::computeRestarts
[16:13:46.278]                           grepl <- base::grepl
[16:13:46.278]                           restarts <- computeRestarts(cond)
[16:13:46.278]                           for (restart in restarts) {
[16:13:46.278]                             name <- restart$name
[16:13:46.278]                             if (is.null(name)) 
[16:13:46.278]                               next
[16:13:46.278]                             if (!grepl(pattern, name)) 
[16:13:46.278]                               next
[16:13:46.278]                             invokeRestart(restart)
[16:13:46.278]                             muffled <- TRUE
[16:13:46.278]                             break
[16:13:46.278]                           }
[16:13:46.278]                         }
[16:13:46.278]                       }
[16:13:46.278]                       invisible(muffled)
[16:13:46.278]                     }
[16:13:46.278]                     muffleCondition(cond, pattern = "^muffle")
[16:13:46.278]                   }
[16:13:46.278]                 }
[16:13:46.278]             }
[16:13:46.278]         }))
[16:13:46.278]     }, error = function(ex) {
[16:13:46.278]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:46.278]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:46.278]                 ...future.rng), started = ...future.startTime, 
[16:13:46.278]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:46.278]             version = "1.8"), class = "FutureResult")
[16:13:46.278]     }, finally = {
[16:13:46.278]         if (!identical(...future.workdir, getwd())) 
[16:13:46.278]             setwd(...future.workdir)
[16:13:46.278]         {
[16:13:46.278]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:46.278]                 ...future.oldOptions$nwarnings <- NULL
[16:13:46.278]             }
[16:13:46.278]             base::options(...future.oldOptions)
[16:13:46.278]             if (.Platform$OS.type == "windows") {
[16:13:46.278]                 old_names <- names(...future.oldEnvVars)
[16:13:46.278]                 envs <- base::Sys.getenv()
[16:13:46.278]                 names <- names(envs)
[16:13:46.278]                 common <- intersect(names, old_names)
[16:13:46.278]                 added <- setdiff(names, old_names)
[16:13:46.278]                 removed <- setdiff(old_names, names)
[16:13:46.278]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:46.278]                   envs[common]]
[16:13:46.278]                 NAMES <- toupper(changed)
[16:13:46.278]                 args <- list()
[16:13:46.278]                 for (kk in seq_along(NAMES)) {
[16:13:46.278]                   name <- changed[[kk]]
[16:13:46.278]                   NAME <- NAMES[[kk]]
[16:13:46.278]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:46.278]                     next
[16:13:46.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:46.278]                 }
[16:13:46.278]                 NAMES <- toupper(added)
[16:13:46.278]                 for (kk in seq_along(NAMES)) {
[16:13:46.278]                   name <- added[[kk]]
[16:13:46.278]                   NAME <- NAMES[[kk]]
[16:13:46.278]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:46.278]                     next
[16:13:46.278]                   args[[name]] <- ""
[16:13:46.278]                 }
[16:13:46.278]                 NAMES <- toupper(removed)
[16:13:46.278]                 for (kk in seq_along(NAMES)) {
[16:13:46.278]                   name <- removed[[kk]]
[16:13:46.278]                   NAME <- NAMES[[kk]]
[16:13:46.278]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:46.278]                     next
[16:13:46.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:46.278]                 }
[16:13:46.278]                 if (length(args) > 0) 
[16:13:46.278]                   base::do.call(base::Sys.setenv, args = args)
[16:13:46.278]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:46.278]             }
[16:13:46.278]             else {
[16:13:46.278]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:46.278]             }
[16:13:46.278]             {
[16:13:46.278]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:46.278]                   0L) {
[16:13:46.278]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:46.278]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:46.278]                   base::options(opts)
[16:13:46.278]                 }
[16:13:46.278]                 {
[16:13:46.278]                   {
[16:13:46.278]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:46.278]                     NULL
[16:13:46.278]                   }
[16:13:46.278]                   options(future.plan = NULL)
[16:13:46.278]                   if (is.na(NA_character_)) 
[16:13:46.278]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:46.278]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:46.278]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:46.278]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:46.278]                     envir = parent.frame()) 
[16:13:46.278]                   {
[16:13:46.278]                     if (is.function(workers)) 
[16:13:46.278]                       workers <- workers()
[16:13:46.278]                     workers <- structure(as.integer(workers), 
[16:13:46.278]                       class = class(workers))
[16:13:46.278]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:46.278]                       workers >= 1)
[16:13:46.278]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:46.278]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:46.278]                     }
[16:13:46.278]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:46.278]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:46.278]                       envir = envir)
[16:13:46.278]                     if (!future$lazy) 
[16:13:46.278]                       future <- run(future)
[16:13:46.278]                     invisible(future)
[16:13:46.278]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:46.278]                 }
[16:13:46.278]             }
[16:13:46.278]         }
[16:13:46.278]     })
[16:13:46.278]     if (TRUE) {
[16:13:46.278]         base::sink(type = "output", split = FALSE)
[16:13:46.278]         if (TRUE) {
[16:13:46.278]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:46.278]         }
[16:13:46.278]         else {
[16:13:46.278]             ...future.result["stdout"] <- base::list(NULL)
[16:13:46.278]         }
[16:13:46.278]         base::close(...future.stdout)
[16:13:46.278]         ...future.stdout <- NULL
[16:13:46.278]     }
[16:13:46.278]     ...future.result$conditions <- ...future.conditions
[16:13:46.278]     ...future.result$finished <- base::Sys.time()
[16:13:46.278]     ...future.result
[16:13:46.278] }
[16:13:46.281] MultisessionFuture started
[16:13:46.281] - Launch lazy future ... done
[16:13:46.281] run() for ‘MultisessionFuture’ ... done
[16:13:46.281] getGlobalsAndPackages() ...
[16:13:46.281] Searching for globals...
[16:13:46.282] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:46.283] Searching for globals ... DONE
[16:13:46.283] Resolving globals: FALSE
[16:13:46.283] 
[16:13:46.283] 
[16:13:46.283] getGlobalsAndPackages() ... DONE
- w/ exception ...
[16:13:46.283] getGlobalsAndPackages() ...
[16:13:46.284] Searching for globals...
[16:13:46.284] - globals found: [2] ‘list’, ‘stop’
[16:13:46.284] Searching for globals ... DONE
[16:13:46.284] Resolving globals: FALSE
[16:13:46.285] 
[16:13:46.285] 
[16:13:46.285] getGlobalsAndPackages() ... DONE
[16:13:46.285] run() for ‘Future’ ...
[16:13:46.285] - state: ‘created’
[16:13:46.285] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:46.300] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:46.300] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:46.300]   - Field: ‘node’
[16:13:46.301]   - Field: ‘label’
[16:13:46.301]   - Field: ‘local’
[16:13:46.301]   - Field: ‘owner’
[16:13:46.301]   - Field: ‘envir’
[16:13:46.301]   - Field: ‘workers’
[16:13:46.301]   - Field: ‘packages’
[16:13:46.301]   - Field: ‘gc’
[16:13:46.301]   - Field: ‘conditions’
[16:13:46.301]   - Field: ‘persistent’
[16:13:46.301]   - Field: ‘expr’
[16:13:46.301]   - Field: ‘uuid’
[16:13:46.302]   - Field: ‘seed’
[16:13:46.302]   - Field: ‘version’
[16:13:46.302]   - Field: ‘result’
[16:13:46.302]   - Field: ‘asynchronous’
[16:13:46.302]   - Field: ‘calls’
[16:13:46.302]   - Field: ‘globals’
[16:13:46.302]   - Field: ‘stdout’
[16:13:46.302]   - Field: ‘earlySignal’
[16:13:46.302]   - Field: ‘lazy’
[16:13:46.302]   - Field: ‘state’
[16:13:46.302] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:46.303] - Launch lazy future ...
[16:13:46.303] Packages needed by the future expression (n = 0): <none>
[16:13:46.303] Packages needed by future strategies (n = 0): <none>
[16:13:46.303] {
[16:13:46.303]     {
[16:13:46.303]         {
[16:13:46.303]             ...future.startTime <- base::Sys.time()
[16:13:46.303]             {
[16:13:46.303]                 {
[16:13:46.303]                   {
[16:13:46.303]                     {
[16:13:46.303]                       base::local({
[16:13:46.303]                         has_future <- base::requireNamespace("future", 
[16:13:46.303]                           quietly = TRUE)
[16:13:46.303]                         if (has_future) {
[16:13:46.303]                           ns <- base::getNamespace("future")
[16:13:46.303]                           version <- ns[[".package"]][["version"]]
[16:13:46.303]                           if (is.null(version)) 
[16:13:46.303]                             version <- utils::packageVersion("future")
[16:13:46.303]                         }
[16:13:46.303]                         else {
[16:13:46.303]                           version <- NULL
[16:13:46.303]                         }
[16:13:46.303]                         if (!has_future || version < "1.8.0") {
[16:13:46.303]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:46.303]                             "", base::R.version$version.string), 
[16:13:46.303]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:46.303]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:46.303]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:46.303]                               "release", "version")], collapse = " "), 
[16:13:46.303]                             hostname = base::Sys.info()[["nodename"]])
[16:13:46.303]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:46.303]                             info)
[16:13:46.303]                           info <- base::paste(info, collapse = "; ")
[16:13:46.303]                           if (!has_future) {
[16:13:46.303]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:46.303]                               info)
[16:13:46.303]                           }
[16:13:46.303]                           else {
[16:13:46.303]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:46.303]                               info, version)
[16:13:46.303]                           }
[16:13:46.303]                           base::stop(msg)
[16:13:46.303]                         }
[16:13:46.303]                       })
[16:13:46.303]                     }
[16:13:46.303]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:46.303]                     base::options(mc.cores = 1L)
[16:13:46.303]                   }
[16:13:46.303]                   options(future.plan = NULL)
[16:13:46.303]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:46.303]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:46.303]                 }
[16:13:46.303]                 ...future.workdir <- getwd()
[16:13:46.303]             }
[16:13:46.303]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:46.303]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:46.303]         }
[16:13:46.303]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:46.303]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:46.303]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:46.303]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:46.303]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:46.303]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:46.303]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:46.303]             base::names(...future.oldOptions))
[16:13:46.303]     }
[16:13:46.303]     if (FALSE) {
[16:13:46.303]     }
[16:13:46.303]     else {
[16:13:46.303]         if (TRUE) {
[16:13:46.303]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:46.303]                 open = "w")
[16:13:46.303]         }
[16:13:46.303]         else {
[16:13:46.303]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:46.303]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:46.303]         }
[16:13:46.303]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:46.303]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:46.303]             base::sink(type = "output", split = FALSE)
[16:13:46.303]             base::close(...future.stdout)
[16:13:46.303]         }, add = TRUE)
[16:13:46.303]     }
[16:13:46.303]     ...future.frame <- base::sys.nframe()
[16:13:46.303]     ...future.conditions <- base::list()
[16:13:46.303]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:46.303]     if (FALSE) {
[16:13:46.303]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:46.303]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:46.303]     }
[16:13:46.303]     ...future.result <- base::tryCatch({
[16:13:46.303]         base::withCallingHandlers({
[16:13:46.303]             ...future.value <- base::withVisible(base::local({
[16:13:46.303]                 ...future.makeSendCondition <- local({
[16:13:46.303]                   sendCondition <- NULL
[16:13:46.303]                   function(frame = 1L) {
[16:13:46.303]                     if (is.function(sendCondition)) 
[16:13:46.303]                       return(sendCondition)
[16:13:46.303]                     ns <- getNamespace("parallel")
[16:13:46.303]                     if (exists("sendData", mode = "function", 
[16:13:46.303]                       envir = ns)) {
[16:13:46.303]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:46.303]                         envir = ns)
[16:13:46.303]                       envir <- sys.frame(frame)
[16:13:46.303]                       master <- NULL
[16:13:46.303]                       while (!identical(envir, .GlobalEnv) && 
[16:13:46.303]                         !identical(envir, emptyenv())) {
[16:13:46.303]                         if (exists("master", mode = "list", envir = envir, 
[16:13:46.303]                           inherits = FALSE)) {
[16:13:46.303]                           master <- get("master", mode = "list", 
[16:13:46.303]                             envir = envir, inherits = FALSE)
[16:13:46.303]                           if (inherits(master, c("SOCKnode", 
[16:13:46.303]                             "SOCK0node"))) {
[16:13:46.303]                             sendCondition <<- function(cond) {
[16:13:46.303]                               data <- list(type = "VALUE", value = cond, 
[16:13:46.303]                                 success = TRUE)
[16:13:46.303]                               parallel_sendData(master, data)
[16:13:46.303]                             }
[16:13:46.303]                             return(sendCondition)
[16:13:46.303]                           }
[16:13:46.303]                         }
[16:13:46.303]                         frame <- frame + 1L
[16:13:46.303]                         envir <- sys.frame(frame)
[16:13:46.303]                       }
[16:13:46.303]                     }
[16:13:46.303]                     sendCondition <<- function(cond) NULL
[16:13:46.303]                   }
[16:13:46.303]                 })
[16:13:46.303]                 withCallingHandlers({
[16:13:46.303]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:46.303]                 }, immediateCondition = function(cond) {
[16:13:46.303]                   sendCondition <- ...future.makeSendCondition()
[16:13:46.303]                   sendCondition(cond)
[16:13:46.303]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:46.303]                   {
[16:13:46.303]                     inherits <- base::inherits
[16:13:46.303]                     invokeRestart <- base::invokeRestart
[16:13:46.303]                     is.null <- base::is.null
[16:13:46.303]                     muffled <- FALSE
[16:13:46.303]                     if (inherits(cond, "message")) {
[16:13:46.303]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:46.303]                       if (muffled) 
[16:13:46.303]                         invokeRestart("muffleMessage")
[16:13:46.303]                     }
[16:13:46.303]                     else if (inherits(cond, "warning")) {
[16:13:46.303]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:46.303]                       if (muffled) 
[16:13:46.303]                         invokeRestart("muffleWarning")
[16:13:46.303]                     }
[16:13:46.303]                     else if (inherits(cond, "condition")) {
[16:13:46.303]                       if (!is.null(pattern)) {
[16:13:46.303]                         computeRestarts <- base::computeRestarts
[16:13:46.303]                         grepl <- base::grepl
[16:13:46.303]                         restarts <- computeRestarts(cond)
[16:13:46.303]                         for (restart in restarts) {
[16:13:46.303]                           name <- restart$name
[16:13:46.303]                           if (is.null(name)) 
[16:13:46.303]                             next
[16:13:46.303]                           if (!grepl(pattern, name)) 
[16:13:46.303]                             next
[16:13:46.303]                           invokeRestart(restart)
[16:13:46.303]                           muffled <- TRUE
[16:13:46.303]                           break
[16:13:46.303]                         }
[16:13:46.303]                       }
[16:13:46.303]                     }
[16:13:46.303]                     invisible(muffled)
[16:13:46.303]                   }
[16:13:46.303]                   muffleCondition(cond)
[16:13:46.303]                 })
[16:13:46.303]             }))
[16:13:46.303]             future::FutureResult(value = ...future.value$value, 
[16:13:46.303]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:46.303]                   ...future.rng), globalenv = if (FALSE) 
[16:13:46.303]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:46.303]                     ...future.globalenv.names))
[16:13:46.303]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:46.303]         }, condition = base::local({
[16:13:46.303]             c <- base::c
[16:13:46.303]             inherits <- base::inherits
[16:13:46.303]             invokeRestart <- base::invokeRestart
[16:13:46.303]             length <- base::length
[16:13:46.303]             list <- base::list
[16:13:46.303]             seq.int <- base::seq.int
[16:13:46.303]             signalCondition <- base::signalCondition
[16:13:46.303]             sys.calls <- base::sys.calls
[16:13:46.303]             `[[` <- base::`[[`
[16:13:46.303]             `+` <- base::`+`
[16:13:46.303]             `<<-` <- base::`<<-`
[16:13:46.303]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:46.303]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:46.303]                   3L)]
[16:13:46.303]             }
[16:13:46.303]             function(cond) {
[16:13:46.303]                 is_error <- inherits(cond, "error")
[16:13:46.303]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:46.303]                   NULL)
[16:13:46.303]                 if (is_error) {
[16:13:46.303]                   sessionInformation <- function() {
[16:13:46.303]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:46.303]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:46.303]                       search = base::search(), system = base::Sys.info())
[16:13:46.303]                   }
[16:13:46.303]                   ...future.conditions[[length(...future.conditions) + 
[16:13:46.303]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:46.303]                     cond$call), session = sessionInformation(), 
[16:13:46.303]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:46.303]                   signalCondition(cond)
[16:13:46.303]                 }
[16:13:46.303]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:46.303]                 "immediateCondition"))) {
[16:13:46.303]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:46.303]                   ...future.conditions[[length(...future.conditions) + 
[16:13:46.303]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:46.303]                   if (TRUE && !signal) {
[16:13:46.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:46.303]                     {
[16:13:46.303]                       inherits <- base::inherits
[16:13:46.303]                       invokeRestart <- base::invokeRestart
[16:13:46.303]                       is.null <- base::is.null
[16:13:46.303]                       muffled <- FALSE
[16:13:46.303]                       if (inherits(cond, "message")) {
[16:13:46.303]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:46.303]                         if (muffled) 
[16:13:46.303]                           invokeRestart("muffleMessage")
[16:13:46.303]                       }
[16:13:46.303]                       else if (inherits(cond, "warning")) {
[16:13:46.303]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:46.303]                         if (muffled) 
[16:13:46.303]                           invokeRestart("muffleWarning")
[16:13:46.303]                       }
[16:13:46.303]                       else if (inherits(cond, "condition")) {
[16:13:46.303]                         if (!is.null(pattern)) {
[16:13:46.303]                           computeRestarts <- base::computeRestarts
[16:13:46.303]                           grepl <- base::grepl
[16:13:46.303]                           restarts <- computeRestarts(cond)
[16:13:46.303]                           for (restart in restarts) {
[16:13:46.303]                             name <- restart$name
[16:13:46.303]                             if (is.null(name)) 
[16:13:46.303]                               next
[16:13:46.303]                             if (!grepl(pattern, name)) 
[16:13:46.303]                               next
[16:13:46.303]                             invokeRestart(restart)
[16:13:46.303]                             muffled <- TRUE
[16:13:46.303]                             break
[16:13:46.303]                           }
[16:13:46.303]                         }
[16:13:46.303]                       }
[16:13:46.303]                       invisible(muffled)
[16:13:46.303]                     }
[16:13:46.303]                     muffleCondition(cond, pattern = "^muffle")
[16:13:46.303]                   }
[16:13:46.303]                 }
[16:13:46.303]                 else {
[16:13:46.303]                   if (TRUE) {
[16:13:46.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:46.303]                     {
[16:13:46.303]                       inherits <- base::inherits
[16:13:46.303]                       invokeRestart <- base::invokeRestart
[16:13:46.303]                       is.null <- base::is.null
[16:13:46.303]                       muffled <- FALSE
[16:13:46.303]                       if (inherits(cond, "message")) {
[16:13:46.303]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:46.303]                         if (muffled) 
[16:13:46.303]                           invokeRestart("muffleMessage")
[16:13:46.303]                       }
[16:13:46.303]                       else if (inherits(cond, "warning")) {
[16:13:46.303]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:46.303]                         if (muffled) 
[16:13:46.303]                           invokeRestart("muffleWarning")
[16:13:46.303]                       }
[16:13:46.303]                       else if (inherits(cond, "condition")) {
[16:13:46.303]                         if (!is.null(pattern)) {
[16:13:46.303]                           computeRestarts <- base::computeRestarts
[16:13:46.303]                           grepl <- base::grepl
[16:13:46.303]                           restarts <- computeRestarts(cond)
[16:13:46.303]                           for (restart in restarts) {
[16:13:46.303]                             name <- restart$name
[16:13:46.303]                             if (is.null(name)) 
[16:13:46.303]                               next
[16:13:46.303]                             if (!grepl(pattern, name)) 
[16:13:46.303]                               next
[16:13:46.303]                             invokeRestart(restart)
[16:13:46.303]                             muffled <- TRUE
[16:13:46.303]                             break
[16:13:46.303]                           }
[16:13:46.303]                         }
[16:13:46.303]                       }
[16:13:46.303]                       invisible(muffled)
[16:13:46.303]                     }
[16:13:46.303]                     muffleCondition(cond, pattern = "^muffle")
[16:13:46.303]                   }
[16:13:46.303]                 }
[16:13:46.303]             }
[16:13:46.303]         }))
[16:13:46.303]     }, error = function(ex) {
[16:13:46.303]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:46.303]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:46.303]                 ...future.rng), started = ...future.startTime, 
[16:13:46.303]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:46.303]             version = "1.8"), class = "FutureResult")
[16:13:46.303]     }, finally = {
[16:13:46.303]         if (!identical(...future.workdir, getwd())) 
[16:13:46.303]             setwd(...future.workdir)
[16:13:46.303]         {
[16:13:46.303]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:46.303]                 ...future.oldOptions$nwarnings <- NULL
[16:13:46.303]             }
[16:13:46.303]             base::options(...future.oldOptions)
[16:13:46.303]             if (.Platform$OS.type == "windows") {
[16:13:46.303]                 old_names <- names(...future.oldEnvVars)
[16:13:46.303]                 envs <- base::Sys.getenv()
[16:13:46.303]                 names <- names(envs)
[16:13:46.303]                 common <- intersect(names, old_names)
[16:13:46.303]                 added <- setdiff(names, old_names)
[16:13:46.303]                 removed <- setdiff(old_names, names)
[16:13:46.303]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:46.303]                   envs[common]]
[16:13:46.303]                 NAMES <- toupper(changed)
[16:13:46.303]                 args <- list()
[16:13:46.303]                 for (kk in seq_along(NAMES)) {
[16:13:46.303]                   name <- changed[[kk]]
[16:13:46.303]                   NAME <- NAMES[[kk]]
[16:13:46.303]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:46.303]                     next
[16:13:46.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:46.303]                 }
[16:13:46.303]                 NAMES <- toupper(added)
[16:13:46.303]                 for (kk in seq_along(NAMES)) {
[16:13:46.303]                   name <- added[[kk]]
[16:13:46.303]                   NAME <- NAMES[[kk]]
[16:13:46.303]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:46.303]                     next
[16:13:46.303]                   args[[name]] <- ""
[16:13:46.303]                 }
[16:13:46.303]                 NAMES <- toupper(removed)
[16:13:46.303]                 for (kk in seq_along(NAMES)) {
[16:13:46.303]                   name <- removed[[kk]]
[16:13:46.303]                   NAME <- NAMES[[kk]]
[16:13:46.303]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:46.303]                     next
[16:13:46.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:46.303]                 }
[16:13:46.303]                 if (length(args) > 0) 
[16:13:46.303]                   base::do.call(base::Sys.setenv, args = args)
[16:13:46.303]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:46.303]             }
[16:13:46.303]             else {
[16:13:46.303]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:46.303]             }
[16:13:46.303]             {
[16:13:46.303]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:46.303]                   0L) {
[16:13:46.303]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:46.303]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:46.303]                   base::options(opts)
[16:13:46.303]                 }
[16:13:46.303]                 {
[16:13:46.303]                   {
[16:13:46.303]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:46.303]                     NULL
[16:13:46.303]                   }
[16:13:46.303]                   options(future.plan = NULL)
[16:13:46.303]                   if (is.na(NA_character_)) 
[16:13:46.303]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:46.303]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:46.303]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:46.303]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:46.303]                     envir = parent.frame()) 
[16:13:46.303]                   {
[16:13:46.303]                     if (is.function(workers)) 
[16:13:46.303]                       workers <- workers()
[16:13:46.303]                     workers <- structure(as.integer(workers), 
[16:13:46.303]                       class = class(workers))
[16:13:46.303]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:46.303]                       workers >= 1)
[16:13:46.303]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:46.303]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:46.303]                     }
[16:13:46.303]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:46.303]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:46.303]                       envir = envir)
[16:13:46.303]                     if (!future$lazy) 
[16:13:46.303]                       future <- run(future)
[16:13:46.303]                     invisible(future)
[16:13:46.303]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:46.303]                 }
[16:13:46.303]             }
[16:13:46.303]         }
[16:13:46.303]     })
[16:13:46.303]     if (TRUE) {
[16:13:46.303]         base::sink(type = "output", split = FALSE)
[16:13:46.303]         if (TRUE) {
[16:13:46.303]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:46.303]         }
[16:13:46.303]         else {
[16:13:46.303]             ...future.result["stdout"] <- base::list(NULL)
[16:13:46.303]         }
[16:13:46.303]         base::close(...future.stdout)
[16:13:46.303]         ...future.stdout <- NULL
[16:13:46.303]     }
[16:13:46.303]     ...future.result$conditions <- ...future.conditions
[16:13:46.303]     ...future.result$finished <- base::Sys.time()
[16:13:46.303]     ...future.result
[16:13:46.303] }
[16:13:46.373] MultisessionFuture started
[16:13:46.374] - Launch lazy future ... done
[16:13:46.374] run() for ‘MultisessionFuture’ ... done
[16:13:46.374] getGlobalsAndPackages() ...
[16:13:46.374] Searching for globals...
[16:13:46.375] - globals found: [2] ‘list’, ‘stop’
[16:13:46.375] Searching for globals ... DONE
[16:13:46.375] Resolving globals: FALSE
[16:13:46.375] 
[16:13:46.375] 
[16:13:46.375] getGlobalsAndPackages() ... DONE
- result = FALSE, recursive = -1 ... DONE
- result = FALSE, recursive = 0 ...
[16:13:46.376] getGlobalsAndPackages() ...
[16:13:46.376] Searching for globals...
[16:13:46.377] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:46.377] Searching for globals ... DONE
[16:13:46.377] Resolving globals: FALSE
[16:13:46.377] 
[16:13:46.378] 
[16:13:46.378] getGlobalsAndPackages() ... DONE
[16:13:46.378] run() for ‘Future’ ...
[16:13:46.378] - state: ‘created’
[16:13:46.378] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:46.395] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:46.396] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:46.396]   - Field: ‘node’
[16:13:46.396]   - Field: ‘label’
[16:13:46.396]   - Field: ‘local’
[16:13:46.396]   - Field: ‘owner’
[16:13:46.397]   - Field: ‘envir’
[16:13:46.397]   - Field: ‘workers’
[16:13:46.397]   - Field: ‘packages’
[16:13:46.397]   - Field: ‘gc’
[16:13:46.397]   - Field: ‘conditions’
[16:13:46.397]   - Field: ‘persistent’
[16:13:46.398]   - Field: ‘expr’
[16:13:46.398]   - Field: ‘uuid’
[16:13:46.398]   - Field: ‘seed’
[16:13:46.398]   - Field: ‘version’
[16:13:46.398]   - Field: ‘result’
[16:13:46.398]   - Field: ‘asynchronous’
[16:13:46.398]   - Field: ‘calls’
[16:13:46.399]   - Field: ‘globals’
[16:13:46.399]   - Field: ‘stdout’
[16:13:46.399]   - Field: ‘earlySignal’
[16:13:46.399]   - Field: ‘lazy’
[16:13:46.399]   - Field: ‘state’
[16:13:46.399] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:46.400] - Launch lazy future ...
[16:13:46.400] Packages needed by the future expression (n = 0): <none>
[16:13:46.400] Packages needed by future strategies (n = 0): <none>
[16:13:46.401] {
[16:13:46.401]     {
[16:13:46.401]         {
[16:13:46.401]             ...future.startTime <- base::Sys.time()
[16:13:46.401]             {
[16:13:46.401]                 {
[16:13:46.401]                   {
[16:13:46.401]                     {
[16:13:46.401]                       base::local({
[16:13:46.401]                         has_future <- base::requireNamespace("future", 
[16:13:46.401]                           quietly = TRUE)
[16:13:46.401]                         if (has_future) {
[16:13:46.401]                           ns <- base::getNamespace("future")
[16:13:46.401]                           version <- ns[[".package"]][["version"]]
[16:13:46.401]                           if (is.null(version)) 
[16:13:46.401]                             version <- utils::packageVersion("future")
[16:13:46.401]                         }
[16:13:46.401]                         else {
[16:13:46.401]                           version <- NULL
[16:13:46.401]                         }
[16:13:46.401]                         if (!has_future || version < "1.8.0") {
[16:13:46.401]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:46.401]                             "", base::R.version$version.string), 
[16:13:46.401]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:46.401]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:46.401]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:46.401]                               "release", "version")], collapse = " "), 
[16:13:46.401]                             hostname = base::Sys.info()[["nodename"]])
[16:13:46.401]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:46.401]                             info)
[16:13:46.401]                           info <- base::paste(info, collapse = "; ")
[16:13:46.401]                           if (!has_future) {
[16:13:46.401]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:46.401]                               info)
[16:13:46.401]                           }
[16:13:46.401]                           else {
[16:13:46.401]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:46.401]                               info, version)
[16:13:46.401]                           }
[16:13:46.401]                           base::stop(msg)
[16:13:46.401]                         }
[16:13:46.401]                       })
[16:13:46.401]                     }
[16:13:46.401]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:46.401]                     base::options(mc.cores = 1L)
[16:13:46.401]                   }
[16:13:46.401]                   options(future.plan = NULL)
[16:13:46.401]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:46.401]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:46.401]                 }
[16:13:46.401]                 ...future.workdir <- getwd()
[16:13:46.401]             }
[16:13:46.401]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:46.401]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:46.401]         }
[16:13:46.401]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:46.401]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:46.401]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:46.401]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:46.401]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:46.401]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:46.401]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:46.401]             base::names(...future.oldOptions))
[16:13:46.401]     }
[16:13:46.401]     if (FALSE) {
[16:13:46.401]     }
[16:13:46.401]     else {
[16:13:46.401]         if (TRUE) {
[16:13:46.401]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:46.401]                 open = "w")
[16:13:46.401]         }
[16:13:46.401]         else {
[16:13:46.401]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:46.401]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:46.401]         }
[16:13:46.401]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:46.401]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:46.401]             base::sink(type = "output", split = FALSE)
[16:13:46.401]             base::close(...future.stdout)
[16:13:46.401]         }, add = TRUE)
[16:13:46.401]     }
[16:13:46.401]     ...future.frame <- base::sys.nframe()
[16:13:46.401]     ...future.conditions <- base::list()
[16:13:46.401]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:46.401]     if (FALSE) {
[16:13:46.401]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:46.401]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:46.401]     }
[16:13:46.401]     ...future.result <- base::tryCatch({
[16:13:46.401]         base::withCallingHandlers({
[16:13:46.401]             ...future.value <- base::withVisible(base::local({
[16:13:46.401]                 ...future.makeSendCondition <- local({
[16:13:46.401]                   sendCondition <- NULL
[16:13:46.401]                   function(frame = 1L) {
[16:13:46.401]                     if (is.function(sendCondition)) 
[16:13:46.401]                       return(sendCondition)
[16:13:46.401]                     ns <- getNamespace("parallel")
[16:13:46.401]                     if (exists("sendData", mode = "function", 
[16:13:46.401]                       envir = ns)) {
[16:13:46.401]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:46.401]                         envir = ns)
[16:13:46.401]                       envir <- sys.frame(frame)
[16:13:46.401]                       master <- NULL
[16:13:46.401]                       while (!identical(envir, .GlobalEnv) && 
[16:13:46.401]                         !identical(envir, emptyenv())) {
[16:13:46.401]                         if (exists("master", mode = "list", envir = envir, 
[16:13:46.401]                           inherits = FALSE)) {
[16:13:46.401]                           master <- get("master", mode = "list", 
[16:13:46.401]                             envir = envir, inherits = FALSE)
[16:13:46.401]                           if (inherits(master, c("SOCKnode", 
[16:13:46.401]                             "SOCK0node"))) {
[16:13:46.401]                             sendCondition <<- function(cond) {
[16:13:46.401]                               data <- list(type = "VALUE", value = cond, 
[16:13:46.401]                                 success = TRUE)
[16:13:46.401]                               parallel_sendData(master, data)
[16:13:46.401]                             }
[16:13:46.401]                             return(sendCondition)
[16:13:46.401]                           }
[16:13:46.401]                         }
[16:13:46.401]                         frame <- frame + 1L
[16:13:46.401]                         envir <- sys.frame(frame)
[16:13:46.401]                       }
[16:13:46.401]                     }
[16:13:46.401]                     sendCondition <<- function(cond) NULL
[16:13:46.401]                   }
[16:13:46.401]                 })
[16:13:46.401]                 withCallingHandlers({
[16:13:46.401]                   {
[16:13:46.401]                     Sys.sleep(0.5)
[16:13:46.401]                     list(a = 1, b = 42L)
[16:13:46.401]                   }
[16:13:46.401]                 }, immediateCondition = function(cond) {
[16:13:46.401]                   sendCondition <- ...future.makeSendCondition()
[16:13:46.401]                   sendCondition(cond)
[16:13:46.401]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:46.401]                   {
[16:13:46.401]                     inherits <- base::inherits
[16:13:46.401]                     invokeRestart <- base::invokeRestart
[16:13:46.401]                     is.null <- base::is.null
[16:13:46.401]                     muffled <- FALSE
[16:13:46.401]                     if (inherits(cond, "message")) {
[16:13:46.401]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:46.401]                       if (muffled) 
[16:13:46.401]                         invokeRestart("muffleMessage")
[16:13:46.401]                     }
[16:13:46.401]                     else if (inherits(cond, "warning")) {
[16:13:46.401]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:46.401]                       if (muffled) 
[16:13:46.401]                         invokeRestart("muffleWarning")
[16:13:46.401]                     }
[16:13:46.401]                     else if (inherits(cond, "condition")) {
[16:13:46.401]                       if (!is.null(pattern)) {
[16:13:46.401]                         computeRestarts <- base::computeRestarts
[16:13:46.401]                         grepl <- base::grepl
[16:13:46.401]                         restarts <- computeRestarts(cond)
[16:13:46.401]                         for (restart in restarts) {
[16:13:46.401]                           name <- restart$name
[16:13:46.401]                           if (is.null(name)) 
[16:13:46.401]                             next
[16:13:46.401]                           if (!grepl(pattern, name)) 
[16:13:46.401]                             next
[16:13:46.401]                           invokeRestart(restart)
[16:13:46.401]                           muffled <- TRUE
[16:13:46.401]                           break
[16:13:46.401]                         }
[16:13:46.401]                       }
[16:13:46.401]                     }
[16:13:46.401]                     invisible(muffled)
[16:13:46.401]                   }
[16:13:46.401]                   muffleCondition(cond)
[16:13:46.401]                 })
[16:13:46.401]             }))
[16:13:46.401]             future::FutureResult(value = ...future.value$value, 
[16:13:46.401]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:46.401]                   ...future.rng), globalenv = if (FALSE) 
[16:13:46.401]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:46.401]                     ...future.globalenv.names))
[16:13:46.401]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:46.401]         }, condition = base::local({
[16:13:46.401]             c <- base::c
[16:13:46.401]             inherits <- base::inherits
[16:13:46.401]             invokeRestart <- base::invokeRestart
[16:13:46.401]             length <- base::length
[16:13:46.401]             list <- base::list
[16:13:46.401]             seq.int <- base::seq.int
[16:13:46.401]             signalCondition <- base::signalCondition
[16:13:46.401]             sys.calls <- base::sys.calls
[16:13:46.401]             `[[` <- base::`[[`
[16:13:46.401]             `+` <- base::`+`
[16:13:46.401]             `<<-` <- base::`<<-`
[16:13:46.401]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:46.401]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:46.401]                   3L)]
[16:13:46.401]             }
[16:13:46.401]             function(cond) {
[16:13:46.401]                 is_error <- inherits(cond, "error")
[16:13:46.401]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:46.401]                   NULL)
[16:13:46.401]                 if (is_error) {
[16:13:46.401]                   sessionInformation <- function() {
[16:13:46.401]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:46.401]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:46.401]                       search = base::search(), system = base::Sys.info())
[16:13:46.401]                   }
[16:13:46.401]                   ...future.conditions[[length(...future.conditions) + 
[16:13:46.401]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:46.401]                     cond$call), session = sessionInformation(), 
[16:13:46.401]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:46.401]                   signalCondition(cond)
[16:13:46.401]                 }
[16:13:46.401]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:46.401]                 "immediateCondition"))) {
[16:13:46.401]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:46.401]                   ...future.conditions[[length(...future.conditions) + 
[16:13:46.401]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:46.401]                   if (TRUE && !signal) {
[16:13:46.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:46.401]                     {
[16:13:46.401]                       inherits <- base::inherits
[16:13:46.401]                       invokeRestart <- base::invokeRestart
[16:13:46.401]                       is.null <- base::is.null
[16:13:46.401]                       muffled <- FALSE
[16:13:46.401]                       if (inherits(cond, "message")) {
[16:13:46.401]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:46.401]                         if (muffled) 
[16:13:46.401]                           invokeRestart("muffleMessage")
[16:13:46.401]                       }
[16:13:46.401]                       else if (inherits(cond, "warning")) {
[16:13:46.401]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:46.401]                         if (muffled) 
[16:13:46.401]                           invokeRestart("muffleWarning")
[16:13:46.401]                       }
[16:13:46.401]                       else if (inherits(cond, "condition")) {
[16:13:46.401]                         if (!is.null(pattern)) {
[16:13:46.401]                           computeRestarts <- base::computeRestarts
[16:13:46.401]                           grepl <- base::grepl
[16:13:46.401]                           restarts <- computeRestarts(cond)
[16:13:46.401]                           for (restart in restarts) {
[16:13:46.401]                             name <- restart$name
[16:13:46.401]                             if (is.null(name)) 
[16:13:46.401]                               next
[16:13:46.401]                             if (!grepl(pattern, name)) 
[16:13:46.401]                               next
[16:13:46.401]                             invokeRestart(restart)
[16:13:46.401]                             muffled <- TRUE
[16:13:46.401]                             break
[16:13:46.401]                           }
[16:13:46.401]                         }
[16:13:46.401]                       }
[16:13:46.401]                       invisible(muffled)
[16:13:46.401]                     }
[16:13:46.401]                     muffleCondition(cond, pattern = "^muffle")
[16:13:46.401]                   }
[16:13:46.401]                 }
[16:13:46.401]                 else {
[16:13:46.401]                   if (TRUE) {
[16:13:46.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:46.401]                     {
[16:13:46.401]                       inherits <- base::inherits
[16:13:46.401]                       invokeRestart <- base::invokeRestart
[16:13:46.401]                       is.null <- base::is.null
[16:13:46.401]                       muffled <- FALSE
[16:13:46.401]                       if (inherits(cond, "message")) {
[16:13:46.401]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:46.401]                         if (muffled) 
[16:13:46.401]                           invokeRestart("muffleMessage")
[16:13:46.401]                       }
[16:13:46.401]                       else if (inherits(cond, "warning")) {
[16:13:46.401]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:46.401]                         if (muffled) 
[16:13:46.401]                           invokeRestart("muffleWarning")
[16:13:46.401]                       }
[16:13:46.401]                       else if (inherits(cond, "condition")) {
[16:13:46.401]                         if (!is.null(pattern)) {
[16:13:46.401]                           computeRestarts <- base::computeRestarts
[16:13:46.401]                           grepl <- base::grepl
[16:13:46.401]                           restarts <- computeRestarts(cond)
[16:13:46.401]                           for (restart in restarts) {
[16:13:46.401]                             name <- restart$name
[16:13:46.401]                             if (is.null(name)) 
[16:13:46.401]                               next
[16:13:46.401]                             if (!grepl(pattern, name)) 
[16:13:46.401]                               next
[16:13:46.401]                             invokeRestart(restart)
[16:13:46.401]                             muffled <- TRUE
[16:13:46.401]                             break
[16:13:46.401]                           }
[16:13:46.401]                         }
[16:13:46.401]                       }
[16:13:46.401]                       invisible(muffled)
[16:13:46.401]                     }
[16:13:46.401]                     muffleCondition(cond, pattern = "^muffle")
[16:13:46.401]                   }
[16:13:46.401]                 }
[16:13:46.401]             }
[16:13:46.401]         }))
[16:13:46.401]     }, error = function(ex) {
[16:13:46.401]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:46.401]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:46.401]                 ...future.rng), started = ...future.startTime, 
[16:13:46.401]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:46.401]             version = "1.8"), class = "FutureResult")
[16:13:46.401]     }, finally = {
[16:13:46.401]         if (!identical(...future.workdir, getwd())) 
[16:13:46.401]             setwd(...future.workdir)
[16:13:46.401]         {
[16:13:46.401]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:46.401]                 ...future.oldOptions$nwarnings <- NULL
[16:13:46.401]             }
[16:13:46.401]             base::options(...future.oldOptions)
[16:13:46.401]             if (.Platform$OS.type == "windows") {
[16:13:46.401]                 old_names <- names(...future.oldEnvVars)
[16:13:46.401]                 envs <- base::Sys.getenv()
[16:13:46.401]                 names <- names(envs)
[16:13:46.401]                 common <- intersect(names, old_names)
[16:13:46.401]                 added <- setdiff(names, old_names)
[16:13:46.401]                 removed <- setdiff(old_names, names)
[16:13:46.401]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:46.401]                   envs[common]]
[16:13:46.401]                 NAMES <- toupper(changed)
[16:13:46.401]                 args <- list()
[16:13:46.401]                 for (kk in seq_along(NAMES)) {
[16:13:46.401]                   name <- changed[[kk]]
[16:13:46.401]                   NAME <- NAMES[[kk]]
[16:13:46.401]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:46.401]                     next
[16:13:46.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:46.401]                 }
[16:13:46.401]                 NAMES <- toupper(added)
[16:13:46.401]                 for (kk in seq_along(NAMES)) {
[16:13:46.401]                   name <- added[[kk]]
[16:13:46.401]                   NAME <- NAMES[[kk]]
[16:13:46.401]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:46.401]                     next
[16:13:46.401]                   args[[name]] <- ""
[16:13:46.401]                 }
[16:13:46.401]                 NAMES <- toupper(removed)
[16:13:46.401]                 for (kk in seq_along(NAMES)) {
[16:13:46.401]                   name <- removed[[kk]]
[16:13:46.401]                   NAME <- NAMES[[kk]]
[16:13:46.401]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:46.401]                     next
[16:13:46.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:46.401]                 }
[16:13:46.401]                 if (length(args) > 0) 
[16:13:46.401]                   base::do.call(base::Sys.setenv, args = args)
[16:13:46.401]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:46.401]             }
[16:13:46.401]             else {
[16:13:46.401]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:46.401]             }
[16:13:46.401]             {
[16:13:46.401]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:46.401]                   0L) {
[16:13:46.401]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:46.401]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:46.401]                   base::options(opts)
[16:13:46.401]                 }
[16:13:46.401]                 {
[16:13:46.401]                   {
[16:13:46.401]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:46.401]                     NULL
[16:13:46.401]                   }
[16:13:46.401]                   options(future.plan = NULL)
[16:13:46.401]                   if (is.na(NA_character_)) 
[16:13:46.401]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:46.401]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:46.401]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:46.401]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:46.401]                     envir = parent.frame()) 
[16:13:46.401]                   {
[16:13:46.401]                     if (is.function(workers)) 
[16:13:46.401]                       workers <- workers()
[16:13:46.401]                     workers <- structure(as.integer(workers), 
[16:13:46.401]                       class = class(workers))
[16:13:46.401]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:46.401]                       workers >= 1)
[16:13:46.401]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:46.401]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:46.401]                     }
[16:13:46.401]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:46.401]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:46.401]                       envir = envir)
[16:13:46.401]                     if (!future$lazy) 
[16:13:46.401]                       future <- run(future)
[16:13:46.401]                     invisible(future)
[16:13:46.401]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:46.401]                 }
[16:13:46.401]             }
[16:13:46.401]         }
[16:13:46.401]     })
[16:13:46.401]     if (TRUE) {
[16:13:46.401]         base::sink(type = "output", split = FALSE)
[16:13:46.401]         if (TRUE) {
[16:13:46.401]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:46.401]         }
[16:13:46.401]         else {
[16:13:46.401]             ...future.result["stdout"] <- base::list(NULL)
[16:13:46.401]         }
[16:13:46.401]         base::close(...future.stdout)
[16:13:46.401]         ...future.stdout <- NULL
[16:13:46.401]     }
[16:13:46.401]     ...future.result$conditions <- ...future.conditions
[16:13:46.401]     ...future.result$finished <- base::Sys.time()
[16:13:46.401]     ...future.result
[16:13:46.401] }
[16:13:46.405] Poll #1 (0): usedNodes() = 2, workers = 2
[16:13:46.426] receiveMessageFromWorker() for ClusterFuture ...
[16:13:46.426] - Validating connection of MultisessionFuture
[16:13:46.427] - received message: FutureResult
[16:13:46.427] - Received FutureResult
[16:13:46.427] - Erased future from FutureRegistry
[16:13:46.427] result() for ClusterFuture ...
[16:13:46.427] - result already collected: FutureResult
[16:13:46.427] result() for ClusterFuture ... done
[16:13:46.428] signalConditions() ...
[16:13:46.428]  - include = ‘immediateCondition’
[16:13:46.428]  - exclude = 
[16:13:46.428]  - resignal = FALSE
[16:13:46.428]  - Number of conditions: 1
[16:13:46.428] signalConditions() ... done
[16:13:46.428] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:46.428] result() for ClusterFuture ...
[16:13:46.428] - result already collected: FutureResult
[16:13:46.429] result() for ClusterFuture ... done
[16:13:46.429] result() for ClusterFuture ...
[16:13:46.429] - result already collected: FutureResult
[16:13:46.429] result() for ClusterFuture ... done
[16:13:46.429] signalConditions() ...
[16:13:46.429]  - include = ‘immediateCondition’
[16:13:46.429]  - exclude = 
[16:13:46.429]  - resignal = FALSE
[16:13:46.429]  - Number of conditions: 1
[16:13:46.429] signalConditions() ... done
[16:13:46.430] MultisessionFuture started
[16:13:46.431] - Launch lazy future ... done
[16:13:46.431] run() for ‘MultisessionFuture’ ... done
[16:13:46.987] receiveMessageFromWorker() for ClusterFuture ...
[16:13:46.988] - Validating connection of MultisessionFuture
[16:13:46.988] - received message: FutureResult
[16:13:46.988] - Received FutureResult
[16:13:46.988] - Erased future from FutureRegistry
[16:13:46.988] result() for ClusterFuture ...
[16:13:46.988] - result already collected: FutureResult
[16:13:46.988] result() for ClusterFuture ... done
[16:13:46.988] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:46.989] A MultisessionFuture was resolved (result was not collected)
[16:13:46.989] getGlobalsAndPackages() ...
[16:13:46.989] Searching for globals...
[16:13:46.990] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:46.990] Searching for globals ... DONE
[16:13:46.990] Resolving globals: FALSE
[16:13:46.990] 
[16:13:46.991] 
[16:13:46.991] getGlobalsAndPackages() ... DONE
[16:13:46.991] run() for ‘Future’ ...
[16:13:46.991] - state: ‘created’
[16:13:46.991] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:47.005] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:47.005] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:47.006]   - Field: ‘node’
[16:13:47.006]   - Field: ‘label’
[16:13:47.006]   - Field: ‘local’
[16:13:47.006]   - Field: ‘owner’
[16:13:47.006]   - Field: ‘envir’
[16:13:47.006]   - Field: ‘workers’
[16:13:47.006]   - Field: ‘packages’
[16:13:47.006]   - Field: ‘gc’
[16:13:47.006]   - Field: ‘conditions’
[16:13:47.006]   - Field: ‘persistent’
[16:13:47.006]   - Field: ‘expr’
[16:13:47.007]   - Field: ‘uuid’
[16:13:47.007]   - Field: ‘seed’
[16:13:47.007]   - Field: ‘version’
[16:13:47.007]   - Field: ‘result’
[16:13:47.007]   - Field: ‘asynchronous’
[16:13:47.007]   - Field: ‘calls’
[16:13:47.007]   - Field: ‘globals’
[16:13:47.007]   - Field: ‘stdout’
[16:13:47.007]   - Field: ‘earlySignal’
[16:13:47.007]   - Field: ‘lazy’
[16:13:47.007]   - Field: ‘state’
[16:13:47.008] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:47.008] - Launch lazy future ...
[16:13:47.008] Packages needed by the future expression (n = 0): <none>
[16:13:47.008] Packages needed by future strategies (n = 0): <none>
[16:13:47.009] {
[16:13:47.009]     {
[16:13:47.009]         {
[16:13:47.009]             ...future.startTime <- base::Sys.time()
[16:13:47.009]             {
[16:13:47.009]                 {
[16:13:47.009]                   {
[16:13:47.009]                     {
[16:13:47.009]                       base::local({
[16:13:47.009]                         has_future <- base::requireNamespace("future", 
[16:13:47.009]                           quietly = TRUE)
[16:13:47.009]                         if (has_future) {
[16:13:47.009]                           ns <- base::getNamespace("future")
[16:13:47.009]                           version <- ns[[".package"]][["version"]]
[16:13:47.009]                           if (is.null(version)) 
[16:13:47.009]                             version <- utils::packageVersion("future")
[16:13:47.009]                         }
[16:13:47.009]                         else {
[16:13:47.009]                           version <- NULL
[16:13:47.009]                         }
[16:13:47.009]                         if (!has_future || version < "1.8.0") {
[16:13:47.009]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:47.009]                             "", base::R.version$version.string), 
[16:13:47.009]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:47.009]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:47.009]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:47.009]                               "release", "version")], collapse = " "), 
[16:13:47.009]                             hostname = base::Sys.info()[["nodename"]])
[16:13:47.009]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:47.009]                             info)
[16:13:47.009]                           info <- base::paste(info, collapse = "; ")
[16:13:47.009]                           if (!has_future) {
[16:13:47.009]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:47.009]                               info)
[16:13:47.009]                           }
[16:13:47.009]                           else {
[16:13:47.009]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:47.009]                               info, version)
[16:13:47.009]                           }
[16:13:47.009]                           base::stop(msg)
[16:13:47.009]                         }
[16:13:47.009]                       })
[16:13:47.009]                     }
[16:13:47.009]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:47.009]                     base::options(mc.cores = 1L)
[16:13:47.009]                   }
[16:13:47.009]                   options(future.plan = NULL)
[16:13:47.009]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:47.009]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:47.009]                 }
[16:13:47.009]                 ...future.workdir <- getwd()
[16:13:47.009]             }
[16:13:47.009]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:47.009]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:47.009]         }
[16:13:47.009]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:47.009]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:47.009]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:47.009]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:47.009]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:47.009]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:47.009]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:47.009]             base::names(...future.oldOptions))
[16:13:47.009]     }
[16:13:47.009]     if (FALSE) {
[16:13:47.009]     }
[16:13:47.009]     else {
[16:13:47.009]         if (TRUE) {
[16:13:47.009]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:47.009]                 open = "w")
[16:13:47.009]         }
[16:13:47.009]         else {
[16:13:47.009]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:47.009]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:47.009]         }
[16:13:47.009]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:47.009]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:47.009]             base::sink(type = "output", split = FALSE)
[16:13:47.009]             base::close(...future.stdout)
[16:13:47.009]         }, add = TRUE)
[16:13:47.009]     }
[16:13:47.009]     ...future.frame <- base::sys.nframe()
[16:13:47.009]     ...future.conditions <- base::list()
[16:13:47.009]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:47.009]     if (FALSE) {
[16:13:47.009]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:47.009]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:47.009]     }
[16:13:47.009]     ...future.result <- base::tryCatch({
[16:13:47.009]         base::withCallingHandlers({
[16:13:47.009]             ...future.value <- base::withVisible(base::local({
[16:13:47.009]                 ...future.makeSendCondition <- local({
[16:13:47.009]                   sendCondition <- NULL
[16:13:47.009]                   function(frame = 1L) {
[16:13:47.009]                     if (is.function(sendCondition)) 
[16:13:47.009]                       return(sendCondition)
[16:13:47.009]                     ns <- getNamespace("parallel")
[16:13:47.009]                     if (exists("sendData", mode = "function", 
[16:13:47.009]                       envir = ns)) {
[16:13:47.009]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:47.009]                         envir = ns)
[16:13:47.009]                       envir <- sys.frame(frame)
[16:13:47.009]                       master <- NULL
[16:13:47.009]                       while (!identical(envir, .GlobalEnv) && 
[16:13:47.009]                         !identical(envir, emptyenv())) {
[16:13:47.009]                         if (exists("master", mode = "list", envir = envir, 
[16:13:47.009]                           inherits = FALSE)) {
[16:13:47.009]                           master <- get("master", mode = "list", 
[16:13:47.009]                             envir = envir, inherits = FALSE)
[16:13:47.009]                           if (inherits(master, c("SOCKnode", 
[16:13:47.009]                             "SOCK0node"))) {
[16:13:47.009]                             sendCondition <<- function(cond) {
[16:13:47.009]                               data <- list(type = "VALUE", value = cond, 
[16:13:47.009]                                 success = TRUE)
[16:13:47.009]                               parallel_sendData(master, data)
[16:13:47.009]                             }
[16:13:47.009]                             return(sendCondition)
[16:13:47.009]                           }
[16:13:47.009]                         }
[16:13:47.009]                         frame <- frame + 1L
[16:13:47.009]                         envir <- sys.frame(frame)
[16:13:47.009]                       }
[16:13:47.009]                     }
[16:13:47.009]                     sendCondition <<- function(cond) NULL
[16:13:47.009]                   }
[16:13:47.009]                 })
[16:13:47.009]                 withCallingHandlers({
[16:13:47.009]                   {
[16:13:47.009]                     Sys.sleep(0.5)
[16:13:47.009]                     list(a = 1, b = 42L)
[16:13:47.009]                   }
[16:13:47.009]                 }, immediateCondition = function(cond) {
[16:13:47.009]                   sendCondition <- ...future.makeSendCondition()
[16:13:47.009]                   sendCondition(cond)
[16:13:47.009]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:47.009]                   {
[16:13:47.009]                     inherits <- base::inherits
[16:13:47.009]                     invokeRestart <- base::invokeRestart
[16:13:47.009]                     is.null <- base::is.null
[16:13:47.009]                     muffled <- FALSE
[16:13:47.009]                     if (inherits(cond, "message")) {
[16:13:47.009]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:47.009]                       if (muffled) 
[16:13:47.009]                         invokeRestart("muffleMessage")
[16:13:47.009]                     }
[16:13:47.009]                     else if (inherits(cond, "warning")) {
[16:13:47.009]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:47.009]                       if (muffled) 
[16:13:47.009]                         invokeRestart("muffleWarning")
[16:13:47.009]                     }
[16:13:47.009]                     else if (inherits(cond, "condition")) {
[16:13:47.009]                       if (!is.null(pattern)) {
[16:13:47.009]                         computeRestarts <- base::computeRestarts
[16:13:47.009]                         grepl <- base::grepl
[16:13:47.009]                         restarts <- computeRestarts(cond)
[16:13:47.009]                         for (restart in restarts) {
[16:13:47.009]                           name <- restart$name
[16:13:47.009]                           if (is.null(name)) 
[16:13:47.009]                             next
[16:13:47.009]                           if (!grepl(pattern, name)) 
[16:13:47.009]                             next
[16:13:47.009]                           invokeRestart(restart)
[16:13:47.009]                           muffled <- TRUE
[16:13:47.009]                           break
[16:13:47.009]                         }
[16:13:47.009]                       }
[16:13:47.009]                     }
[16:13:47.009]                     invisible(muffled)
[16:13:47.009]                   }
[16:13:47.009]                   muffleCondition(cond)
[16:13:47.009]                 })
[16:13:47.009]             }))
[16:13:47.009]             future::FutureResult(value = ...future.value$value, 
[16:13:47.009]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:47.009]                   ...future.rng), globalenv = if (FALSE) 
[16:13:47.009]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:47.009]                     ...future.globalenv.names))
[16:13:47.009]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:47.009]         }, condition = base::local({
[16:13:47.009]             c <- base::c
[16:13:47.009]             inherits <- base::inherits
[16:13:47.009]             invokeRestart <- base::invokeRestart
[16:13:47.009]             length <- base::length
[16:13:47.009]             list <- base::list
[16:13:47.009]             seq.int <- base::seq.int
[16:13:47.009]             signalCondition <- base::signalCondition
[16:13:47.009]             sys.calls <- base::sys.calls
[16:13:47.009]             `[[` <- base::`[[`
[16:13:47.009]             `+` <- base::`+`
[16:13:47.009]             `<<-` <- base::`<<-`
[16:13:47.009]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:47.009]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:47.009]                   3L)]
[16:13:47.009]             }
[16:13:47.009]             function(cond) {
[16:13:47.009]                 is_error <- inherits(cond, "error")
[16:13:47.009]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:47.009]                   NULL)
[16:13:47.009]                 if (is_error) {
[16:13:47.009]                   sessionInformation <- function() {
[16:13:47.009]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:47.009]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:47.009]                       search = base::search(), system = base::Sys.info())
[16:13:47.009]                   }
[16:13:47.009]                   ...future.conditions[[length(...future.conditions) + 
[16:13:47.009]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:47.009]                     cond$call), session = sessionInformation(), 
[16:13:47.009]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:47.009]                   signalCondition(cond)
[16:13:47.009]                 }
[16:13:47.009]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:47.009]                 "immediateCondition"))) {
[16:13:47.009]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:47.009]                   ...future.conditions[[length(...future.conditions) + 
[16:13:47.009]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:47.009]                   if (TRUE && !signal) {
[16:13:47.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:47.009]                     {
[16:13:47.009]                       inherits <- base::inherits
[16:13:47.009]                       invokeRestart <- base::invokeRestart
[16:13:47.009]                       is.null <- base::is.null
[16:13:47.009]                       muffled <- FALSE
[16:13:47.009]                       if (inherits(cond, "message")) {
[16:13:47.009]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:47.009]                         if (muffled) 
[16:13:47.009]                           invokeRestart("muffleMessage")
[16:13:47.009]                       }
[16:13:47.009]                       else if (inherits(cond, "warning")) {
[16:13:47.009]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:47.009]                         if (muffled) 
[16:13:47.009]                           invokeRestart("muffleWarning")
[16:13:47.009]                       }
[16:13:47.009]                       else if (inherits(cond, "condition")) {
[16:13:47.009]                         if (!is.null(pattern)) {
[16:13:47.009]                           computeRestarts <- base::computeRestarts
[16:13:47.009]                           grepl <- base::grepl
[16:13:47.009]                           restarts <- computeRestarts(cond)
[16:13:47.009]                           for (restart in restarts) {
[16:13:47.009]                             name <- restart$name
[16:13:47.009]                             if (is.null(name)) 
[16:13:47.009]                               next
[16:13:47.009]                             if (!grepl(pattern, name)) 
[16:13:47.009]                               next
[16:13:47.009]                             invokeRestart(restart)
[16:13:47.009]                             muffled <- TRUE
[16:13:47.009]                             break
[16:13:47.009]                           }
[16:13:47.009]                         }
[16:13:47.009]                       }
[16:13:47.009]                       invisible(muffled)
[16:13:47.009]                     }
[16:13:47.009]                     muffleCondition(cond, pattern = "^muffle")
[16:13:47.009]                   }
[16:13:47.009]                 }
[16:13:47.009]                 else {
[16:13:47.009]                   if (TRUE) {
[16:13:47.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:47.009]                     {
[16:13:47.009]                       inherits <- base::inherits
[16:13:47.009]                       invokeRestart <- base::invokeRestart
[16:13:47.009]                       is.null <- base::is.null
[16:13:47.009]                       muffled <- FALSE
[16:13:47.009]                       if (inherits(cond, "message")) {
[16:13:47.009]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:47.009]                         if (muffled) 
[16:13:47.009]                           invokeRestart("muffleMessage")
[16:13:47.009]                       }
[16:13:47.009]                       else if (inherits(cond, "warning")) {
[16:13:47.009]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:47.009]                         if (muffled) 
[16:13:47.009]                           invokeRestart("muffleWarning")
[16:13:47.009]                       }
[16:13:47.009]                       else if (inherits(cond, "condition")) {
[16:13:47.009]                         if (!is.null(pattern)) {
[16:13:47.009]                           computeRestarts <- base::computeRestarts
[16:13:47.009]                           grepl <- base::grepl
[16:13:47.009]                           restarts <- computeRestarts(cond)
[16:13:47.009]                           for (restart in restarts) {
[16:13:47.009]                             name <- restart$name
[16:13:47.009]                             if (is.null(name)) 
[16:13:47.009]                               next
[16:13:47.009]                             if (!grepl(pattern, name)) 
[16:13:47.009]                               next
[16:13:47.009]                             invokeRestart(restart)
[16:13:47.009]                             muffled <- TRUE
[16:13:47.009]                             break
[16:13:47.009]                           }
[16:13:47.009]                         }
[16:13:47.009]                       }
[16:13:47.009]                       invisible(muffled)
[16:13:47.009]                     }
[16:13:47.009]                     muffleCondition(cond, pattern = "^muffle")
[16:13:47.009]                   }
[16:13:47.009]                 }
[16:13:47.009]             }
[16:13:47.009]         }))
[16:13:47.009]     }, error = function(ex) {
[16:13:47.009]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:47.009]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:47.009]                 ...future.rng), started = ...future.startTime, 
[16:13:47.009]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:47.009]             version = "1.8"), class = "FutureResult")
[16:13:47.009]     }, finally = {
[16:13:47.009]         if (!identical(...future.workdir, getwd())) 
[16:13:47.009]             setwd(...future.workdir)
[16:13:47.009]         {
[16:13:47.009]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:47.009]                 ...future.oldOptions$nwarnings <- NULL
[16:13:47.009]             }
[16:13:47.009]             base::options(...future.oldOptions)
[16:13:47.009]             if (.Platform$OS.type == "windows") {
[16:13:47.009]                 old_names <- names(...future.oldEnvVars)
[16:13:47.009]                 envs <- base::Sys.getenv()
[16:13:47.009]                 names <- names(envs)
[16:13:47.009]                 common <- intersect(names, old_names)
[16:13:47.009]                 added <- setdiff(names, old_names)
[16:13:47.009]                 removed <- setdiff(old_names, names)
[16:13:47.009]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:47.009]                   envs[common]]
[16:13:47.009]                 NAMES <- toupper(changed)
[16:13:47.009]                 args <- list()
[16:13:47.009]                 for (kk in seq_along(NAMES)) {
[16:13:47.009]                   name <- changed[[kk]]
[16:13:47.009]                   NAME <- NAMES[[kk]]
[16:13:47.009]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:47.009]                     next
[16:13:47.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:47.009]                 }
[16:13:47.009]                 NAMES <- toupper(added)
[16:13:47.009]                 for (kk in seq_along(NAMES)) {
[16:13:47.009]                   name <- added[[kk]]
[16:13:47.009]                   NAME <- NAMES[[kk]]
[16:13:47.009]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:47.009]                     next
[16:13:47.009]                   args[[name]] <- ""
[16:13:47.009]                 }
[16:13:47.009]                 NAMES <- toupper(removed)
[16:13:47.009]                 for (kk in seq_along(NAMES)) {
[16:13:47.009]                   name <- removed[[kk]]
[16:13:47.009]                   NAME <- NAMES[[kk]]
[16:13:47.009]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:47.009]                     next
[16:13:47.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:47.009]                 }
[16:13:47.009]                 if (length(args) > 0) 
[16:13:47.009]                   base::do.call(base::Sys.setenv, args = args)
[16:13:47.009]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:47.009]             }
[16:13:47.009]             else {
[16:13:47.009]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:47.009]             }
[16:13:47.009]             {
[16:13:47.009]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:47.009]                   0L) {
[16:13:47.009]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:47.009]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:47.009]                   base::options(opts)
[16:13:47.009]                 }
[16:13:47.009]                 {
[16:13:47.009]                   {
[16:13:47.009]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:47.009]                     NULL
[16:13:47.009]                   }
[16:13:47.009]                   options(future.plan = NULL)
[16:13:47.009]                   if (is.na(NA_character_)) 
[16:13:47.009]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:47.009]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:47.009]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:47.009]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:47.009]                     envir = parent.frame()) 
[16:13:47.009]                   {
[16:13:47.009]                     if (is.function(workers)) 
[16:13:47.009]                       workers <- workers()
[16:13:47.009]                     workers <- structure(as.integer(workers), 
[16:13:47.009]                       class = class(workers))
[16:13:47.009]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:47.009]                       workers >= 1)
[16:13:47.009]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:47.009]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:47.009]                     }
[16:13:47.009]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:47.009]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:47.009]                       envir = envir)
[16:13:47.009]                     if (!future$lazy) 
[16:13:47.009]                       future <- run(future)
[16:13:47.009]                     invisible(future)
[16:13:47.009]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:47.009]                 }
[16:13:47.009]             }
[16:13:47.009]         }
[16:13:47.009]     })
[16:13:47.009]     if (TRUE) {
[16:13:47.009]         base::sink(type = "output", split = FALSE)
[16:13:47.009]         if (TRUE) {
[16:13:47.009]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:47.009]         }
[16:13:47.009]         else {
[16:13:47.009]             ...future.result["stdout"] <- base::list(NULL)
[16:13:47.009]         }
[16:13:47.009]         base::close(...future.stdout)
[16:13:47.009]         ...future.stdout <- NULL
[16:13:47.009]     }
[16:13:47.009]     ...future.result$conditions <- ...future.conditions
[16:13:47.009]     ...future.result$finished <- base::Sys.time()
[16:13:47.009]     ...future.result
[16:13:47.009] }
[16:13:47.011] MultisessionFuture started
[16:13:47.012] - Launch lazy future ... done
[16:13:47.012] run() for ‘MultisessionFuture’ ... done
[16:13:47.557] receiveMessageFromWorker() for ClusterFuture ...
[16:13:47.558] - Validating connection of MultisessionFuture
[16:13:47.558] - received message: FutureResult
[16:13:47.558] - Received FutureResult
[16:13:47.558] - Erased future from FutureRegistry
[16:13:47.558] result() for ClusterFuture ...
[16:13:47.558] - result already collected: FutureResult
[16:13:47.558] result() for ClusterFuture ... done
[16:13:47.559] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:47.559] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[16:13:47.559] getGlobalsAndPackages() ...
[16:13:47.559] Searching for globals...
[16:13:47.560] - globals found: [2] ‘list’, ‘stop’
[16:13:47.560] Searching for globals ... DONE
[16:13:47.560] Resolving globals: FALSE
[16:13:47.560] 
[16:13:47.560] 
[16:13:47.560] getGlobalsAndPackages() ... DONE
[16:13:47.561] run() for ‘Future’ ...
[16:13:47.561] - state: ‘created’
[16:13:47.561] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:47.577] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:47.577] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:47.577]   - Field: ‘node’
[16:13:47.577]   - Field: ‘label’
[16:13:47.578]   - Field: ‘local’
[16:13:47.578]   - Field: ‘owner’
[16:13:47.578]   - Field: ‘envir’
[16:13:47.578]   - Field: ‘workers’
[16:13:47.578]   - Field: ‘packages’
[16:13:47.578]   - Field: ‘gc’
[16:13:47.578]   - Field: ‘conditions’
[16:13:47.578]   - Field: ‘persistent’
[16:13:47.578]   - Field: ‘expr’
[16:13:47.578]   - Field: ‘uuid’
[16:13:47.578]   - Field: ‘seed’
[16:13:47.578]   - Field: ‘version’
[16:13:47.579]   - Field: ‘result’
[16:13:47.579]   - Field: ‘asynchronous’
[16:13:47.579]   - Field: ‘calls’
[16:13:47.579]   - Field: ‘globals’
[16:13:47.579]   - Field: ‘stdout’
[16:13:47.579]   - Field: ‘earlySignal’
[16:13:47.579]   - Field: ‘lazy’
[16:13:47.579]   - Field: ‘state’
[16:13:47.579] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:47.579] - Launch lazy future ...
[16:13:47.580] Packages needed by the future expression (n = 0): <none>
[16:13:47.580] Packages needed by future strategies (n = 0): <none>
[16:13:47.580] {
[16:13:47.580]     {
[16:13:47.580]         {
[16:13:47.580]             ...future.startTime <- base::Sys.time()
[16:13:47.580]             {
[16:13:47.580]                 {
[16:13:47.580]                   {
[16:13:47.580]                     {
[16:13:47.580]                       base::local({
[16:13:47.580]                         has_future <- base::requireNamespace("future", 
[16:13:47.580]                           quietly = TRUE)
[16:13:47.580]                         if (has_future) {
[16:13:47.580]                           ns <- base::getNamespace("future")
[16:13:47.580]                           version <- ns[[".package"]][["version"]]
[16:13:47.580]                           if (is.null(version)) 
[16:13:47.580]                             version <- utils::packageVersion("future")
[16:13:47.580]                         }
[16:13:47.580]                         else {
[16:13:47.580]                           version <- NULL
[16:13:47.580]                         }
[16:13:47.580]                         if (!has_future || version < "1.8.0") {
[16:13:47.580]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:47.580]                             "", base::R.version$version.string), 
[16:13:47.580]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:47.580]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:47.580]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:47.580]                               "release", "version")], collapse = " "), 
[16:13:47.580]                             hostname = base::Sys.info()[["nodename"]])
[16:13:47.580]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:47.580]                             info)
[16:13:47.580]                           info <- base::paste(info, collapse = "; ")
[16:13:47.580]                           if (!has_future) {
[16:13:47.580]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:47.580]                               info)
[16:13:47.580]                           }
[16:13:47.580]                           else {
[16:13:47.580]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:47.580]                               info, version)
[16:13:47.580]                           }
[16:13:47.580]                           base::stop(msg)
[16:13:47.580]                         }
[16:13:47.580]                       })
[16:13:47.580]                     }
[16:13:47.580]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:47.580]                     base::options(mc.cores = 1L)
[16:13:47.580]                   }
[16:13:47.580]                   options(future.plan = NULL)
[16:13:47.580]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:47.580]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:47.580]                 }
[16:13:47.580]                 ...future.workdir <- getwd()
[16:13:47.580]             }
[16:13:47.580]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:47.580]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:47.580]         }
[16:13:47.580]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:47.580]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:47.580]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:47.580]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:47.580]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:47.580]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:47.580]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:47.580]             base::names(...future.oldOptions))
[16:13:47.580]     }
[16:13:47.580]     if (FALSE) {
[16:13:47.580]     }
[16:13:47.580]     else {
[16:13:47.580]         if (TRUE) {
[16:13:47.580]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:47.580]                 open = "w")
[16:13:47.580]         }
[16:13:47.580]         else {
[16:13:47.580]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:47.580]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:47.580]         }
[16:13:47.580]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:47.580]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:47.580]             base::sink(type = "output", split = FALSE)
[16:13:47.580]             base::close(...future.stdout)
[16:13:47.580]         }, add = TRUE)
[16:13:47.580]     }
[16:13:47.580]     ...future.frame <- base::sys.nframe()
[16:13:47.580]     ...future.conditions <- base::list()
[16:13:47.580]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:47.580]     if (FALSE) {
[16:13:47.580]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:47.580]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:47.580]     }
[16:13:47.580]     ...future.result <- base::tryCatch({
[16:13:47.580]         base::withCallingHandlers({
[16:13:47.580]             ...future.value <- base::withVisible(base::local({
[16:13:47.580]                 ...future.makeSendCondition <- local({
[16:13:47.580]                   sendCondition <- NULL
[16:13:47.580]                   function(frame = 1L) {
[16:13:47.580]                     if (is.function(sendCondition)) 
[16:13:47.580]                       return(sendCondition)
[16:13:47.580]                     ns <- getNamespace("parallel")
[16:13:47.580]                     if (exists("sendData", mode = "function", 
[16:13:47.580]                       envir = ns)) {
[16:13:47.580]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:47.580]                         envir = ns)
[16:13:47.580]                       envir <- sys.frame(frame)
[16:13:47.580]                       master <- NULL
[16:13:47.580]                       while (!identical(envir, .GlobalEnv) && 
[16:13:47.580]                         !identical(envir, emptyenv())) {
[16:13:47.580]                         if (exists("master", mode = "list", envir = envir, 
[16:13:47.580]                           inherits = FALSE)) {
[16:13:47.580]                           master <- get("master", mode = "list", 
[16:13:47.580]                             envir = envir, inherits = FALSE)
[16:13:47.580]                           if (inherits(master, c("SOCKnode", 
[16:13:47.580]                             "SOCK0node"))) {
[16:13:47.580]                             sendCondition <<- function(cond) {
[16:13:47.580]                               data <- list(type = "VALUE", value = cond, 
[16:13:47.580]                                 success = TRUE)
[16:13:47.580]                               parallel_sendData(master, data)
[16:13:47.580]                             }
[16:13:47.580]                             return(sendCondition)
[16:13:47.580]                           }
[16:13:47.580]                         }
[16:13:47.580]                         frame <- frame + 1L
[16:13:47.580]                         envir <- sys.frame(frame)
[16:13:47.580]                       }
[16:13:47.580]                     }
[16:13:47.580]                     sendCondition <<- function(cond) NULL
[16:13:47.580]                   }
[16:13:47.580]                 })
[16:13:47.580]                 withCallingHandlers({
[16:13:47.580]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:47.580]                 }, immediateCondition = function(cond) {
[16:13:47.580]                   sendCondition <- ...future.makeSendCondition()
[16:13:47.580]                   sendCondition(cond)
[16:13:47.580]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:47.580]                   {
[16:13:47.580]                     inherits <- base::inherits
[16:13:47.580]                     invokeRestart <- base::invokeRestart
[16:13:47.580]                     is.null <- base::is.null
[16:13:47.580]                     muffled <- FALSE
[16:13:47.580]                     if (inherits(cond, "message")) {
[16:13:47.580]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:47.580]                       if (muffled) 
[16:13:47.580]                         invokeRestart("muffleMessage")
[16:13:47.580]                     }
[16:13:47.580]                     else if (inherits(cond, "warning")) {
[16:13:47.580]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:47.580]                       if (muffled) 
[16:13:47.580]                         invokeRestart("muffleWarning")
[16:13:47.580]                     }
[16:13:47.580]                     else if (inherits(cond, "condition")) {
[16:13:47.580]                       if (!is.null(pattern)) {
[16:13:47.580]                         computeRestarts <- base::computeRestarts
[16:13:47.580]                         grepl <- base::grepl
[16:13:47.580]                         restarts <- computeRestarts(cond)
[16:13:47.580]                         for (restart in restarts) {
[16:13:47.580]                           name <- restart$name
[16:13:47.580]                           if (is.null(name)) 
[16:13:47.580]                             next
[16:13:47.580]                           if (!grepl(pattern, name)) 
[16:13:47.580]                             next
[16:13:47.580]                           invokeRestart(restart)
[16:13:47.580]                           muffled <- TRUE
[16:13:47.580]                           break
[16:13:47.580]                         }
[16:13:47.580]                       }
[16:13:47.580]                     }
[16:13:47.580]                     invisible(muffled)
[16:13:47.580]                   }
[16:13:47.580]                   muffleCondition(cond)
[16:13:47.580]                 })
[16:13:47.580]             }))
[16:13:47.580]             future::FutureResult(value = ...future.value$value, 
[16:13:47.580]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:47.580]                   ...future.rng), globalenv = if (FALSE) 
[16:13:47.580]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:47.580]                     ...future.globalenv.names))
[16:13:47.580]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:47.580]         }, condition = base::local({
[16:13:47.580]             c <- base::c
[16:13:47.580]             inherits <- base::inherits
[16:13:47.580]             invokeRestart <- base::invokeRestart
[16:13:47.580]             length <- base::length
[16:13:47.580]             list <- base::list
[16:13:47.580]             seq.int <- base::seq.int
[16:13:47.580]             signalCondition <- base::signalCondition
[16:13:47.580]             sys.calls <- base::sys.calls
[16:13:47.580]             `[[` <- base::`[[`
[16:13:47.580]             `+` <- base::`+`
[16:13:47.580]             `<<-` <- base::`<<-`
[16:13:47.580]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:47.580]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:47.580]                   3L)]
[16:13:47.580]             }
[16:13:47.580]             function(cond) {
[16:13:47.580]                 is_error <- inherits(cond, "error")
[16:13:47.580]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:47.580]                   NULL)
[16:13:47.580]                 if (is_error) {
[16:13:47.580]                   sessionInformation <- function() {
[16:13:47.580]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:47.580]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:47.580]                       search = base::search(), system = base::Sys.info())
[16:13:47.580]                   }
[16:13:47.580]                   ...future.conditions[[length(...future.conditions) + 
[16:13:47.580]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:47.580]                     cond$call), session = sessionInformation(), 
[16:13:47.580]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:47.580]                   signalCondition(cond)
[16:13:47.580]                 }
[16:13:47.580]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:47.580]                 "immediateCondition"))) {
[16:13:47.580]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:47.580]                   ...future.conditions[[length(...future.conditions) + 
[16:13:47.580]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:47.580]                   if (TRUE && !signal) {
[16:13:47.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:47.580]                     {
[16:13:47.580]                       inherits <- base::inherits
[16:13:47.580]                       invokeRestart <- base::invokeRestart
[16:13:47.580]                       is.null <- base::is.null
[16:13:47.580]                       muffled <- FALSE
[16:13:47.580]                       if (inherits(cond, "message")) {
[16:13:47.580]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:47.580]                         if (muffled) 
[16:13:47.580]                           invokeRestart("muffleMessage")
[16:13:47.580]                       }
[16:13:47.580]                       else if (inherits(cond, "warning")) {
[16:13:47.580]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:47.580]                         if (muffled) 
[16:13:47.580]                           invokeRestart("muffleWarning")
[16:13:47.580]                       }
[16:13:47.580]                       else if (inherits(cond, "condition")) {
[16:13:47.580]                         if (!is.null(pattern)) {
[16:13:47.580]                           computeRestarts <- base::computeRestarts
[16:13:47.580]                           grepl <- base::grepl
[16:13:47.580]                           restarts <- computeRestarts(cond)
[16:13:47.580]                           for (restart in restarts) {
[16:13:47.580]                             name <- restart$name
[16:13:47.580]                             if (is.null(name)) 
[16:13:47.580]                               next
[16:13:47.580]                             if (!grepl(pattern, name)) 
[16:13:47.580]                               next
[16:13:47.580]                             invokeRestart(restart)
[16:13:47.580]                             muffled <- TRUE
[16:13:47.580]                             break
[16:13:47.580]                           }
[16:13:47.580]                         }
[16:13:47.580]                       }
[16:13:47.580]                       invisible(muffled)
[16:13:47.580]                     }
[16:13:47.580]                     muffleCondition(cond, pattern = "^muffle")
[16:13:47.580]                   }
[16:13:47.580]                 }
[16:13:47.580]                 else {
[16:13:47.580]                   if (TRUE) {
[16:13:47.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:47.580]                     {
[16:13:47.580]                       inherits <- base::inherits
[16:13:47.580]                       invokeRestart <- base::invokeRestart
[16:13:47.580]                       is.null <- base::is.null
[16:13:47.580]                       muffled <- FALSE
[16:13:47.580]                       if (inherits(cond, "message")) {
[16:13:47.580]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:47.580]                         if (muffled) 
[16:13:47.580]                           invokeRestart("muffleMessage")
[16:13:47.580]                       }
[16:13:47.580]                       else if (inherits(cond, "warning")) {
[16:13:47.580]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:47.580]                         if (muffled) 
[16:13:47.580]                           invokeRestart("muffleWarning")
[16:13:47.580]                       }
[16:13:47.580]                       else if (inherits(cond, "condition")) {
[16:13:47.580]                         if (!is.null(pattern)) {
[16:13:47.580]                           computeRestarts <- base::computeRestarts
[16:13:47.580]                           grepl <- base::grepl
[16:13:47.580]                           restarts <- computeRestarts(cond)
[16:13:47.580]                           for (restart in restarts) {
[16:13:47.580]                             name <- restart$name
[16:13:47.580]                             if (is.null(name)) 
[16:13:47.580]                               next
[16:13:47.580]                             if (!grepl(pattern, name)) 
[16:13:47.580]                               next
[16:13:47.580]                             invokeRestart(restart)
[16:13:47.580]                             muffled <- TRUE
[16:13:47.580]                             break
[16:13:47.580]                           }
[16:13:47.580]                         }
[16:13:47.580]                       }
[16:13:47.580]                       invisible(muffled)
[16:13:47.580]                     }
[16:13:47.580]                     muffleCondition(cond, pattern = "^muffle")
[16:13:47.580]                   }
[16:13:47.580]                 }
[16:13:47.580]             }
[16:13:47.580]         }))
[16:13:47.580]     }, error = function(ex) {
[16:13:47.580]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:47.580]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:47.580]                 ...future.rng), started = ...future.startTime, 
[16:13:47.580]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:47.580]             version = "1.8"), class = "FutureResult")
[16:13:47.580]     }, finally = {
[16:13:47.580]         if (!identical(...future.workdir, getwd())) 
[16:13:47.580]             setwd(...future.workdir)
[16:13:47.580]         {
[16:13:47.580]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:47.580]                 ...future.oldOptions$nwarnings <- NULL
[16:13:47.580]             }
[16:13:47.580]             base::options(...future.oldOptions)
[16:13:47.580]             if (.Platform$OS.type == "windows") {
[16:13:47.580]                 old_names <- names(...future.oldEnvVars)
[16:13:47.580]                 envs <- base::Sys.getenv()
[16:13:47.580]                 names <- names(envs)
[16:13:47.580]                 common <- intersect(names, old_names)
[16:13:47.580]                 added <- setdiff(names, old_names)
[16:13:47.580]                 removed <- setdiff(old_names, names)
[16:13:47.580]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:47.580]                   envs[common]]
[16:13:47.580]                 NAMES <- toupper(changed)
[16:13:47.580]                 args <- list()
[16:13:47.580]                 for (kk in seq_along(NAMES)) {
[16:13:47.580]                   name <- changed[[kk]]
[16:13:47.580]                   NAME <- NAMES[[kk]]
[16:13:47.580]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:47.580]                     next
[16:13:47.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:47.580]                 }
[16:13:47.580]                 NAMES <- toupper(added)
[16:13:47.580]                 for (kk in seq_along(NAMES)) {
[16:13:47.580]                   name <- added[[kk]]
[16:13:47.580]                   NAME <- NAMES[[kk]]
[16:13:47.580]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:47.580]                     next
[16:13:47.580]                   args[[name]] <- ""
[16:13:47.580]                 }
[16:13:47.580]                 NAMES <- toupper(removed)
[16:13:47.580]                 for (kk in seq_along(NAMES)) {
[16:13:47.580]                   name <- removed[[kk]]
[16:13:47.580]                   NAME <- NAMES[[kk]]
[16:13:47.580]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:47.580]                     next
[16:13:47.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:47.580]                 }
[16:13:47.580]                 if (length(args) > 0) 
[16:13:47.580]                   base::do.call(base::Sys.setenv, args = args)
[16:13:47.580]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:47.580]             }
[16:13:47.580]             else {
[16:13:47.580]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:47.580]             }
[16:13:47.580]             {
[16:13:47.580]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:47.580]                   0L) {
[16:13:47.580]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:47.580]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:47.580]                   base::options(opts)
[16:13:47.580]                 }
[16:13:47.580]                 {
[16:13:47.580]                   {
[16:13:47.580]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:47.580]                     NULL
[16:13:47.580]                   }
[16:13:47.580]                   options(future.plan = NULL)
[16:13:47.580]                   if (is.na(NA_character_)) 
[16:13:47.580]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:47.580]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:47.580]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:47.580]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:47.580]                     envir = parent.frame()) 
[16:13:47.580]                   {
[16:13:47.580]                     if (is.function(workers)) 
[16:13:47.580]                       workers <- workers()
[16:13:47.580]                     workers <- structure(as.integer(workers), 
[16:13:47.580]                       class = class(workers))
[16:13:47.580]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:47.580]                       workers >= 1)
[16:13:47.580]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:47.580]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:47.580]                     }
[16:13:47.580]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:47.580]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:47.580]                       envir = envir)
[16:13:47.580]                     if (!future$lazy) 
[16:13:47.580]                       future <- run(future)
[16:13:47.580]                     invisible(future)
[16:13:47.580]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:47.580]                 }
[16:13:47.580]             }
[16:13:47.580]         }
[16:13:47.580]     })
[16:13:47.580]     if (TRUE) {
[16:13:47.580]         base::sink(type = "output", split = FALSE)
[16:13:47.580]         if (TRUE) {
[16:13:47.580]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:47.580]         }
[16:13:47.580]         else {
[16:13:47.580]             ...future.result["stdout"] <- base::list(NULL)
[16:13:47.580]         }
[16:13:47.580]         base::close(...future.stdout)
[16:13:47.580]         ...future.stdout <- NULL
[16:13:47.580]     }
[16:13:47.580]     ...future.result$conditions <- ...future.conditions
[16:13:47.580]     ...future.result$finished <- base::Sys.time()
[16:13:47.580]     ...future.result
[16:13:47.580] }
[16:13:47.583] MultisessionFuture started
[16:13:47.583] - Launch lazy future ... done
[16:13:47.584] run() for ‘MultisessionFuture’ ... done
[16:13:47.629] receiveMessageFromWorker() for ClusterFuture ...
[16:13:47.629] - Validating connection of MultisessionFuture
[16:13:47.629] - received message: FutureResult
[16:13:47.629] - Received FutureResult
[16:13:47.629] - Erased future from FutureRegistry
[16:13:47.629] result() for ClusterFuture ...
[16:13:47.630] - result already collected: FutureResult
[16:13:47.630] result() for ClusterFuture ... done
[16:13:47.630] signalConditions() ...
[16:13:47.630]  - include = ‘immediateCondition’
[16:13:47.630]  - exclude = 
[16:13:47.630]  - resignal = FALSE
[16:13:47.630]  - Number of conditions: 1
[16:13:47.630] signalConditions() ... done
[16:13:47.630] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:47.630] A MultisessionFuture was resolved (result was not collected)
[16:13:47.630] getGlobalsAndPackages() ...
[16:13:47.631] Searching for globals...
[16:13:47.631] - globals found: [2] ‘list’, ‘stop’
[16:13:47.631] Searching for globals ... DONE
[16:13:47.631] Resolving globals: FALSE
[16:13:47.632] 
[16:13:47.632] 
[16:13:47.632] getGlobalsAndPackages() ... DONE
[16:13:47.632] run() for ‘Future’ ...
[16:13:47.632] - state: ‘created’
[16:13:47.632] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:47.647] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:47.647] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:47.647]   - Field: ‘node’
[16:13:47.647]   - Field: ‘label’
[16:13:47.647]   - Field: ‘local’
[16:13:47.647]   - Field: ‘owner’
[16:13:47.647]   - Field: ‘envir’
[16:13:47.647]   - Field: ‘workers’
[16:13:47.648]   - Field: ‘packages’
[16:13:47.648]   - Field: ‘gc’
[16:13:47.648]   - Field: ‘conditions’
[16:13:47.648]   - Field: ‘persistent’
[16:13:47.648]   - Field: ‘expr’
[16:13:47.648]   - Field: ‘uuid’
[16:13:47.648]   - Field: ‘seed’
[16:13:47.648]   - Field: ‘version’
[16:13:47.648]   - Field: ‘result’
[16:13:47.648]   - Field: ‘asynchronous’
[16:13:47.648]   - Field: ‘calls’
[16:13:47.649]   - Field: ‘globals’
[16:13:47.649]   - Field: ‘stdout’
[16:13:47.649]   - Field: ‘earlySignal’
[16:13:47.649]   - Field: ‘lazy’
[16:13:47.649]   - Field: ‘state’
[16:13:47.649] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:47.649] - Launch lazy future ...
[16:13:47.649] Packages needed by the future expression (n = 0): <none>
[16:13:47.649] Packages needed by future strategies (n = 0): <none>
[16:13:47.650] {
[16:13:47.650]     {
[16:13:47.650]         {
[16:13:47.650]             ...future.startTime <- base::Sys.time()
[16:13:47.650]             {
[16:13:47.650]                 {
[16:13:47.650]                   {
[16:13:47.650]                     {
[16:13:47.650]                       base::local({
[16:13:47.650]                         has_future <- base::requireNamespace("future", 
[16:13:47.650]                           quietly = TRUE)
[16:13:47.650]                         if (has_future) {
[16:13:47.650]                           ns <- base::getNamespace("future")
[16:13:47.650]                           version <- ns[[".package"]][["version"]]
[16:13:47.650]                           if (is.null(version)) 
[16:13:47.650]                             version <- utils::packageVersion("future")
[16:13:47.650]                         }
[16:13:47.650]                         else {
[16:13:47.650]                           version <- NULL
[16:13:47.650]                         }
[16:13:47.650]                         if (!has_future || version < "1.8.0") {
[16:13:47.650]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:47.650]                             "", base::R.version$version.string), 
[16:13:47.650]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:47.650]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:47.650]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:47.650]                               "release", "version")], collapse = " "), 
[16:13:47.650]                             hostname = base::Sys.info()[["nodename"]])
[16:13:47.650]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:47.650]                             info)
[16:13:47.650]                           info <- base::paste(info, collapse = "; ")
[16:13:47.650]                           if (!has_future) {
[16:13:47.650]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:47.650]                               info)
[16:13:47.650]                           }
[16:13:47.650]                           else {
[16:13:47.650]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:47.650]                               info, version)
[16:13:47.650]                           }
[16:13:47.650]                           base::stop(msg)
[16:13:47.650]                         }
[16:13:47.650]                       })
[16:13:47.650]                     }
[16:13:47.650]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:47.650]                     base::options(mc.cores = 1L)
[16:13:47.650]                   }
[16:13:47.650]                   options(future.plan = NULL)
[16:13:47.650]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:47.650]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:47.650]                 }
[16:13:47.650]                 ...future.workdir <- getwd()
[16:13:47.650]             }
[16:13:47.650]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:47.650]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:47.650]         }
[16:13:47.650]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:47.650]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:47.650]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:47.650]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:47.650]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:47.650]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:47.650]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:47.650]             base::names(...future.oldOptions))
[16:13:47.650]     }
[16:13:47.650]     if (FALSE) {
[16:13:47.650]     }
[16:13:47.650]     else {
[16:13:47.650]         if (TRUE) {
[16:13:47.650]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:47.650]                 open = "w")
[16:13:47.650]         }
[16:13:47.650]         else {
[16:13:47.650]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:47.650]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:47.650]         }
[16:13:47.650]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:47.650]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:47.650]             base::sink(type = "output", split = FALSE)
[16:13:47.650]             base::close(...future.stdout)
[16:13:47.650]         }, add = TRUE)
[16:13:47.650]     }
[16:13:47.650]     ...future.frame <- base::sys.nframe()
[16:13:47.650]     ...future.conditions <- base::list()
[16:13:47.650]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:47.650]     if (FALSE) {
[16:13:47.650]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:47.650]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:47.650]     }
[16:13:47.650]     ...future.result <- base::tryCatch({
[16:13:47.650]         base::withCallingHandlers({
[16:13:47.650]             ...future.value <- base::withVisible(base::local({
[16:13:47.650]                 ...future.makeSendCondition <- local({
[16:13:47.650]                   sendCondition <- NULL
[16:13:47.650]                   function(frame = 1L) {
[16:13:47.650]                     if (is.function(sendCondition)) 
[16:13:47.650]                       return(sendCondition)
[16:13:47.650]                     ns <- getNamespace("parallel")
[16:13:47.650]                     if (exists("sendData", mode = "function", 
[16:13:47.650]                       envir = ns)) {
[16:13:47.650]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:47.650]                         envir = ns)
[16:13:47.650]                       envir <- sys.frame(frame)
[16:13:47.650]                       master <- NULL
[16:13:47.650]                       while (!identical(envir, .GlobalEnv) && 
[16:13:47.650]                         !identical(envir, emptyenv())) {
[16:13:47.650]                         if (exists("master", mode = "list", envir = envir, 
[16:13:47.650]                           inherits = FALSE)) {
[16:13:47.650]                           master <- get("master", mode = "list", 
[16:13:47.650]                             envir = envir, inherits = FALSE)
[16:13:47.650]                           if (inherits(master, c("SOCKnode", 
[16:13:47.650]                             "SOCK0node"))) {
[16:13:47.650]                             sendCondition <<- function(cond) {
[16:13:47.650]                               data <- list(type = "VALUE", value = cond, 
[16:13:47.650]                                 success = TRUE)
[16:13:47.650]                               parallel_sendData(master, data)
[16:13:47.650]                             }
[16:13:47.650]                             return(sendCondition)
[16:13:47.650]                           }
[16:13:47.650]                         }
[16:13:47.650]                         frame <- frame + 1L
[16:13:47.650]                         envir <- sys.frame(frame)
[16:13:47.650]                       }
[16:13:47.650]                     }
[16:13:47.650]                     sendCondition <<- function(cond) NULL
[16:13:47.650]                   }
[16:13:47.650]                 })
[16:13:47.650]                 withCallingHandlers({
[16:13:47.650]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:47.650]                 }, immediateCondition = function(cond) {
[16:13:47.650]                   sendCondition <- ...future.makeSendCondition()
[16:13:47.650]                   sendCondition(cond)
[16:13:47.650]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:47.650]                   {
[16:13:47.650]                     inherits <- base::inherits
[16:13:47.650]                     invokeRestart <- base::invokeRestart
[16:13:47.650]                     is.null <- base::is.null
[16:13:47.650]                     muffled <- FALSE
[16:13:47.650]                     if (inherits(cond, "message")) {
[16:13:47.650]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:47.650]                       if (muffled) 
[16:13:47.650]                         invokeRestart("muffleMessage")
[16:13:47.650]                     }
[16:13:47.650]                     else if (inherits(cond, "warning")) {
[16:13:47.650]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:47.650]                       if (muffled) 
[16:13:47.650]                         invokeRestart("muffleWarning")
[16:13:47.650]                     }
[16:13:47.650]                     else if (inherits(cond, "condition")) {
[16:13:47.650]                       if (!is.null(pattern)) {
[16:13:47.650]                         computeRestarts <- base::computeRestarts
[16:13:47.650]                         grepl <- base::grepl
[16:13:47.650]                         restarts <- computeRestarts(cond)
[16:13:47.650]                         for (restart in restarts) {
[16:13:47.650]                           name <- restart$name
[16:13:47.650]                           if (is.null(name)) 
[16:13:47.650]                             next
[16:13:47.650]                           if (!grepl(pattern, name)) 
[16:13:47.650]                             next
[16:13:47.650]                           invokeRestart(restart)
[16:13:47.650]                           muffled <- TRUE
[16:13:47.650]                           break
[16:13:47.650]                         }
[16:13:47.650]                       }
[16:13:47.650]                     }
[16:13:47.650]                     invisible(muffled)
[16:13:47.650]                   }
[16:13:47.650]                   muffleCondition(cond)
[16:13:47.650]                 })
[16:13:47.650]             }))
[16:13:47.650]             future::FutureResult(value = ...future.value$value, 
[16:13:47.650]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:47.650]                   ...future.rng), globalenv = if (FALSE) 
[16:13:47.650]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:47.650]                     ...future.globalenv.names))
[16:13:47.650]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:47.650]         }, condition = base::local({
[16:13:47.650]             c <- base::c
[16:13:47.650]             inherits <- base::inherits
[16:13:47.650]             invokeRestart <- base::invokeRestart
[16:13:47.650]             length <- base::length
[16:13:47.650]             list <- base::list
[16:13:47.650]             seq.int <- base::seq.int
[16:13:47.650]             signalCondition <- base::signalCondition
[16:13:47.650]             sys.calls <- base::sys.calls
[16:13:47.650]             `[[` <- base::`[[`
[16:13:47.650]             `+` <- base::`+`
[16:13:47.650]             `<<-` <- base::`<<-`
[16:13:47.650]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:47.650]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:47.650]                   3L)]
[16:13:47.650]             }
[16:13:47.650]             function(cond) {
[16:13:47.650]                 is_error <- inherits(cond, "error")
[16:13:47.650]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:47.650]                   NULL)
[16:13:47.650]                 if (is_error) {
[16:13:47.650]                   sessionInformation <- function() {
[16:13:47.650]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:47.650]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:47.650]                       search = base::search(), system = base::Sys.info())
[16:13:47.650]                   }
[16:13:47.650]                   ...future.conditions[[length(...future.conditions) + 
[16:13:47.650]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:47.650]                     cond$call), session = sessionInformation(), 
[16:13:47.650]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:47.650]                   signalCondition(cond)
[16:13:47.650]                 }
[16:13:47.650]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:47.650]                 "immediateCondition"))) {
[16:13:47.650]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:47.650]                   ...future.conditions[[length(...future.conditions) + 
[16:13:47.650]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:47.650]                   if (TRUE && !signal) {
[16:13:47.650]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:47.650]                     {
[16:13:47.650]                       inherits <- base::inherits
[16:13:47.650]                       invokeRestart <- base::invokeRestart
[16:13:47.650]                       is.null <- base::is.null
[16:13:47.650]                       muffled <- FALSE
[16:13:47.650]                       if (inherits(cond, "message")) {
[16:13:47.650]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:47.650]                         if (muffled) 
[16:13:47.650]                           invokeRestart("muffleMessage")
[16:13:47.650]                       }
[16:13:47.650]                       else if (inherits(cond, "warning")) {
[16:13:47.650]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:47.650]                         if (muffled) 
[16:13:47.650]                           invokeRestart("muffleWarning")
[16:13:47.650]                       }
[16:13:47.650]                       else if (inherits(cond, "condition")) {
[16:13:47.650]                         if (!is.null(pattern)) {
[16:13:47.650]                           computeRestarts <- base::computeRestarts
[16:13:47.650]                           grepl <- base::grepl
[16:13:47.650]                           restarts <- computeRestarts(cond)
[16:13:47.650]                           for (restart in restarts) {
[16:13:47.650]                             name <- restart$name
[16:13:47.650]                             if (is.null(name)) 
[16:13:47.650]                               next
[16:13:47.650]                             if (!grepl(pattern, name)) 
[16:13:47.650]                               next
[16:13:47.650]                             invokeRestart(restart)
[16:13:47.650]                             muffled <- TRUE
[16:13:47.650]                             break
[16:13:47.650]                           }
[16:13:47.650]                         }
[16:13:47.650]                       }
[16:13:47.650]                       invisible(muffled)
[16:13:47.650]                     }
[16:13:47.650]                     muffleCondition(cond, pattern = "^muffle")
[16:13:47.650]                   }
[16:13:47.650]                 }
[16:13:47.650]                 else {
[16:13:47.650]                   if (TRUE) {
[16:13:47.650]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:47.650]                     {
[16:13:47.650]                       inherits <- base::inherits
[16:13:47.650]                       invokeRestart <- base::invokeRestart
[16:13:47.650]                       is.null <- base::is.null
[16:13:47.650]                       muffled <- FALSE
[16:13:47.650]                       if (inherits(cond, "message")) {
[16:13:47.650]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:47.650]                         if (muffled) 
[16:13:47.650]                           invokeRestart("muffleMessage")
[16:13:47.650]                       }
[16:13:47.650]                       else if (inherits(cond, "warning")) {
[16:13:47.650]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:47.650]                         if (muffled) 
[16:13:47.650]                           invokeRestart("muffleWarning")
[16:13:47.650]                       }
[16:13:47.650]                       else if (inherits(cond, "condition")) {
[16:13:47.650]                         if (!is.null(pattern)) {
[16:13:47.650]                           computeRestarts <- base::computeRestarts
[16:13:47.650]                           grepl <- base::grepl
[16:13:47.650]                           restarts <- computeRestarts(cond)
[16:13:47.650]                           for (restart in restarts) {
[16:13:47.650]                             name <- restart$name
[16:13:47.650]                             if (is.null(name)) 
[16:13:47.650]                               next
[16:13:47.650]                             if (!grepl(pattern, name)) 
[16:13:47.650]                               next
[16:13:47.650]                             invokeRestart(restart)
[16:13:47.650]                             muffled <- TRUE
[16:13:47.650]                             break
[16:13:47.650]                           }
[16:13:47.650]                         }
[16:13:47.650]                       }
[16:13:47.650]                       invisible(muffled)
[16:13:47.650]                     }
[16:13:47.650]                     muffleCondition(cond, pattern = "^muffle")
[16:13:47.650]                   }
[16:13:47.650]                 }
[16:13:47.650]             }
[16:13:47.650]         }))
[16:13:47.650]     }, error = function(ex) {
[16:13:47.650]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:47.650]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:47.650]                 ...future.rng), started = ...future.startTime, 
[16:13:47.650]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:47.650]             version = "1.8"), class = "FutureResult")
[16:13:47.650]     }, finally = {
[16:13:47.650]         if (!identical(...future.workdir, getwd())) 
[16:13:47.650]             setwd(...future.workdir)
[16:13:47.650]         {
[16:13:47.650]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:47.650]                 ...future.oldOptions$nwarnings <- NULL
[16:13:47.650]             }
[16:13:47.650]             base::options(...future.oldOptions)
[16:13:47.650]             if (.Platform$OS.type == "windows") {
[16:13:47.650]                 old_names <- names(...future.oldEnvVars)
[16:13:47.650]                 envs <- base::Sys.getenv()
[16:13:47.650]                 names <- names(envs)
[16:13:47.650]                 common <- intersect(names, old_names)
[16:13:47.650]                 added <- setdiff(names, old_names)
[16:13:47.650]                 removed <- setdiff(old_names, names)
[16:13:47.650]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:47.650]                   envs[common]]
[16:13:47.650]                 NAMES <- toupper(changed)
[16:13:47.650]                 args <- list()
[16:13:47.650]                 for (kk in seq_along(NAMES)) {
[16:13:47.650]                   name <- changed[[kk]]
[16:13:47.650]                   NAME <- NAMES[[kk]]
[16:13:47.650]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:47.650]                     next
[16:13:47.650]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:47.650]                 }
[16:13:47.650]                 NAMES <- toupper(added)
[16:13:47.650]                 for (kk in seq_along(NAMES)) {
[16:13:47.650]                   name <- added[[kk]]
[16:13:47.650]                   NAME <- NAMES[[kk]]
[16:13:47.650]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:47.650]                     next
[16:13:47.650]                   args[[name]] <- ""
[16:13:47.650]                 }
[16:13:47.650]                 NAMES <- toupper(removed)
[16:13:47.650]                 for (kk in seq_along(NAMES)) {
[16:13:47.650]                   name <- removed[[kk]]
[16:13:47.650]                   NAME <- NAMES[[kk]]
[16:13:47.650]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:47.650]                     next
[16:13:47.650]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:47.650]                 }
[16:13:47.650]                 if (length(args) > 0) 
[16:13:47.650]                   base::do.call(base::Sys.setenv, args = args)
[16:13:47.650]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:47.650]             }
[16:13:47.650]             else {
[16:13:47.650]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:47.650]             }
[16:13:47.650]             {
[16:13:47.650]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:47.650]                   0L) {
[16:13:47.650]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:47.650]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:47.650]                   base::options(opts)
[16:13:47.650]                 }
[16:13:47.650]                 {
[16:13:47.650]                   {
[16:13:47.650]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:47.650]                     NULL
[16:13:47.650]                   }
[16:13:47.650]                   options(future.plan = NULL)
[16:13:47.650]                   if (is.na(NA_character_)) 
[16:13:47.650]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:47.650]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:47.650]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:47.650]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:47.650]                     envir = parent.frame()) 
[16:13:47.650]                   {
[16:13:47.650]                     if (is.function(workers)) 
[16:13:47.650]                       workers <- workers()
[16:13:47.650]                     workers <- structure(as.integer(workers), 
[16:13:47.650]                       class = class(workers))
[16:13:47.650]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:47.650]                       workers >= 1)
[16:13:47.650]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:47.650]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:47.650]                     }
[16:13:47.650]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:47.650]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:47.650]                       envir = envir)
[16:13:47.650]                     if (!future$lazy) 
[16:13:47.650]                       future <- run(future)
[16:13:47.650]                     invisible(future)
[16:13:47.650]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:47.650]                 }
[16:13:47.650]             }
[16:13:47.650]         }
[16:13:47.650]     })
[16:13:47.650]     if (TRUE) {
[16:13:47.650]         base::sink(type = "output", split = FALSE)
[16:13:47.650]         if (TRUE) {
[16:13:47.650]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:47.650]         }
[16:13:47.650]         else {
[16:13:47.650]             ...future.result["stdout"] <- base::list(NULL)
[16:13:47.650]         }
[16:13:47.650]         base::close(...future.stdout)
[16:13:47.650]         ...future.stdout <- NULL
[16:13:47.650]     }
[16:13:47.650]     ...future.result$conditions <- ...future.conditions
[16:13:47.650]     ...future.result$finished <- base::Sys.time()
[16:13:47.650]     ...future.result
[16:13:47.650] }
[16:13:47.653] MultisessionFuture started
[16:13:47.653] - Launch lazy future ... done
[16:13:47.653] run() for ‘MultisessionFuture’ ... done
[16:13:47.700] receiveMessageFromWorker() for ClusterFuture ...
[16:13:47.700] - Validating connection of MultisessionFuture
[16:13:47.701] - received message: FutureResult
[16:13:47.701] - Received FutureResult
[16:13:47.701] - Erased future from FutureRegistry
[16:13:47.702] result() for ClusterFuture ...
[16:13:47.702] - result already collected: FutureResult
[16:13:47.702] result() for ClusterFuture ... done
[16:13:47.702] signalConditions() ...
[16:13:47.702]  - include = ‘immediateCondition’
[16:13:47.702]  - exclude = 
[16:13:47.702]  - resignal = FALSE
[16:13:47.702]  - Number of conditions: 1
[16:13:47.702] signalConditions() ... done
[16:13:47.702] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:47.703] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 0 ... DONE
- result = FALSE, recursive = 1 ...
[16:13:47.703] getGlobalsAndPackages() ...
[16:13:47.703] Searching for globals...
[16:13:47.704] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:47.704] Searching for globals ... DONE
[16:13:47.704] Resolving globals: FALSE
[16:13:47.705] 
[16:13:47.705] 
[16:13:47.705] getGlobalsAndPackages() ... DONE
[16:13:47.705] run() for ‘Future’ ...
[16:13:47.705] - state: ‘created’
[16:13:47.705] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:47.721] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:47.721] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:47.721]   - Field: ‘node’
[16:13:47.721]   - Field: ‘label’
[16:13:47.721]   - Field: ‘local’
[16:13:47.721]   - Field: ‘owner’
[16:13:47.722]   - Field: ‘envir’
[16:13:47.722]   - Field: ‘workers’
[16:13:47.722]   - Field: ‘packages’
[16:13:47.722]   - Field: ‘gc’
[16:13:47.722]   - Field: ‘conditions’
[16:13:47.722]   - Field: ‘persistent’
[16:13:47.722]   - Field: ‘expr’
[16:13:47.722]   - Field: ‘uuid’
[16:13:47.722]   - Field: ‘seed’
[16:13:47.722]   - Field: ‘version’
[16:13:47.722]   - Field: ‘result’
[16:13:47.723]   - Field: ‘asynchronous’
[16:13:47.723]   - Field: ‘calls’
[16:13:47.723]   - Field: ‘globals’
[16:13:47.723]   - Field: ‘stdout’
[16:13:47.723]   - Field: ‘earlySignal’
[16:13:47.723]   - Field: ‘lazy’
[16:13:47.723]   - Field: ‘state’
[16:13:47.723] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:47.723] - Launch lazy future ...
[16:13:47.724] Packages needed by the future expression (n = 0): <none>
[16:13:47.724] Packages needed by future strategies (n = 0): <none>
[16:13:47.724] {
[16:13:47.724]     {
[16:13:47.724]         {
[16:13:47.724]             ...future.startTime <- base::Sys.time()
[16:13:47.724]             {
[16:13:47.724]                 {
[16:13:47.724]                   {
[16:13:47.724]                     {
[16:13:47.724]                       base::local({
[16:13:47.724]                         has_future <- base::requireNamespace("future", 
[16:13:47.724]                           quietly = TRUE)
[16:13:47.724]                         if (has_future) {
[16:13:47.724]                           ns <- base::getNamespace("future")
[16:13:47.724]                           version <- ns[[".package"]][["version"]]
[16:13:47.724]                           if (is.null(version)) 
[16:13:47.724]                             version <- utils::packageVersion("future")
[16:13:47.724]                         }
[16:13:47.724]                         else {
[16:13:47.724]                           version <- NULL
[16:13:47.724]                         }
[16:13:47.724]                         if (!has_future || version < "1.8.0") {
[16:13:47.724]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:47.724]                             "", base::R.version$version.string), 
[16:13:47.724]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:47.724]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:47.724]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:47.724]                               "release", "version")], collapse = " "), 
[16:13:47.724]                             hostname = base::Sys.info()[["nodename"]])
[16:13:47.724]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:47.724]                             info)
[16:13:47.724]                           info <- base::paste(info, collapse = "; ")
[16:13:47.724]                           if (!has_future) {
[16:13:47.724]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:47.724]                               info)
[16:13:47.724]                           }
[16:13:47.724]                           else {
[16:13:47.724]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:47.724]                               info, version)
[16:13:47.724]                           }
[16:13:47.724]                           base::stop(msg)
[16:13:47.724]                         }
[16:13:47.724]                       })
[16:13:47.724]                     }
[16:13:47.724]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:47.724]                     base::options(mc.cores = 1L)
[16:13:47.724]                   }
[16:13:47.724]                   options(future.plan = NULL)
[16:13:47.724]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:47.724]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:47.724]                 }
[16:13:47.724]                 ...future.workdir <- getwd()
[16:13:47.724]             }
[16:13:47.724]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:47.724]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:47.724]         }
[16:13:47.724]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:47.724]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:47.724]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:47.724]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:47.724]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:47.724]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:47.724]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:47.724]             base::names(...future.oldOptions))
[16:13:47.724]     }
[16:13:47.724]     if (FALSE) {
[16:13:47.724]     }
[16:13:47.724]     else {
[16:13:47.724]         if (TRUE) {
[16:13:47.724]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:47.724]                 open = "w")
[16:13:47.724]         }
[16:13:47.724]         else {
[16:13:47.724]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:47.724]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:47.724]         }
[16:13:47.724]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:47.724]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:47.724]             base::sink(type = "output", split = FALSE)
[16:13:47.724]             base::close(...future.stdout)
[16:13:47.724]         }, add = TRUE)
[16:13:47.724]     }
[16:13:47.724]     ...future.frame <- base::sys.nframe()
[16:13:47.724]     ...future.conditions <- base::list()
[16:13:47.724]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:47.724]     if (FALSE) {
[16:13:47.724]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:47.724]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:47.724]     }
[16:13:47.724]     ...future.result <- base::tryCatch({
[16:13:47.724]         base::withCallingHandlers({
[16:13:47.724]             ...future.value <- base::withVisible(base::local({
[16:13:47.724]                 ...future.makeSendCondition <- local({
[16:13:47.724]                   sendCondition <- NULL
[16:13:47.724]                   function(frame = 1L) {
[16:13:47.724]                     if (is.function(sendCondition)) 
[16:13:47.724]                       return(sendCondition)
[16:13:47.724]                     ns <- getNamespace("parallel")
[16:13:47.724]                     if (exists("sendData", mode = "function", 
[16:13:47.724]                       envir = ns)) {
[16:13:47.724]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:47.724]                         envir = ns)
[16:13:47.724]                       envir <- sys.frame(frame)
[16:13:47.724]                       master <- NULL
[16:13:47.724]                       while (!identical(envir, .GlobalEnv) && 
[16:13:47.724]                         !identical(envir, emptyenv())) {
[16:13:47.724]                         if (exists("master", mode = "list", envir = envir, 
[16:13:47.724]                           inherits = FALSE)) {
[16:13:47.724]                           master <- get("master", mode = "list", 
[16:13:47.724]                             envir = envir, inherits = FALSE)
[16:13:47.724]                           if (inherits(master, c("SOCKnode", 
[16:13:47.724]                             "SOCK0node"))) {
[16:13:47.724]                             sendCondition <<- function(cond) {
[16:13:47.724]                               data <- list(type = "VALUE", value = cond, 
[16:13:47.724]                                 success = TRUE)
[16:13:47.724]                               parallel_sendData(master, data)
[16:13:47.724]                             }
[16:13:47.724]                             return(sendCondition)
[16:13:47.724]                           }
[16:13:47.724]                         }
[16:13:47.724]                         frame <- frame + 1L
[16:13:47.724]                         envir <- sys.frame(frame)
[16:13:47.724]                       }
[16:13:47.724]                     }
[16:13:47.724]                     sendCondition <<- function(cond) NULL
[16:13:47.724]                   }
[16:13:47.724]                 })
[16:13:47.724]                 withCallingHandlers({
[16:13:47.724]                   {
[16:13:47.724]                     Sys.sleep(0.5)
[16:13:47.724]                     list(a = 1, b = 42L)
[16:13:47.724]                   }
[16:13:47.724]                 }, immediateCondition = function(cond) {
[16:13:47.724]                   sendCondition <- ...future.makeSendCondition()
[16:13:47.724]                   sendCondition(cond)
[16:13:47.724]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:47.724]                   {
[16:13:47.724]                     inherits <- base::inherits
[16:13:47.724]                     invokeRestart <- base::invokeRestart
[16:13:47.724]                     is.null <- base::is.null
[16:13:47.724]                     muffled <- FALSE
[16:13:47.724]                     if (inherits(cond, "message")) {
[16:13:47.724]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:47.724]                       if (muffled) 
[16:13:47.724]                         invokeRestart("muffleMessage")
[16:13:47.724]                     }
[16:13:47.724]                     else if (inherits(cond, "warning")) {
[16:13:47.724]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:47.724]                       if (muffled) 
[16:13:47.724]                         invokeRestart("muffleWarning")
[16:13:47.724]                     }
[16:13:47.724]                     else if (inherits(cond, "condition")) {
[16:13:47.724]                       if (!is.null(pattern)) {
[16:13:47.724]                         computeRestarts <- base::computeRestarts
[16:13:47.724]                         grepl <- base::grepl
[16:13:47.724]                         restarts <- computeRestarts(cond)
[16:13:47.724]                         for (restart in restarts) {
[16:13:47.724]                           name <- restart$name
[16:13:47.724]                           if (is.null(name)) 
[16:13:47.724]                             next
[16:13:47.724]                           if (!grepl(pattern, name)) 
[16:13:47.724]                             next
[16:13:47.724]                           invokeRestart(restart)
[16:13:47.724]                           muffled <- TRUE
[16:13:47.724]                           break
[16:13:47.724]                         }
[16:13:47.724]                       }
[16:13:47.724]                     }
[16:13:47.724]                     invisible(muffled)
[16:13:47.724]                   }
[16:13:47.724]                   muffleCondition(cond)
[16:13:47.724]                 })
[16:13:47.724]             }))
[16:13:47.724]             future::FutureResult(value = ...future.value$value, 
[16:13:47.724]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:47.724]                   ...future.rng), globalenv = if (FALSE) 
[16:13:47.724]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:47.724]                     ...future.globalenv.names))
[16:13:47.724]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:47.724]         }, condition = base::local({
[16:13:47.724]             c <- base::c
[16:13:47.724]             inherits <- base::inherits
[16:13:47.724]             invokeRestart <- base::invokeRestart
[16:13:47.724]             length <- base::length
[16:13:47.724]             list <- base::list
[16:13:47.724]             seq.int <- base::seq.int
[16:13:47.724]             signalCondition <- base::signalCondition
[16:13:47.724]             sys.calls <- base::sys.calls
[16:13:47.724]             `[[` <- base::`[[`
[16:13:47.724]             `+` <- base::`+`
[16:13:47.724]             `<<-` <- base::`<<-`
[16:13:47.724]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:47.724]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:47.724]                   3L)]
[16:13:47.724]             }
[16:13:47.724]             function(cond) {
[16:13:47.724]                 is_error <- inherits(cond, "error")
[16:13:47.724]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:47.724]                   NULL)
[16:13:47.724]                 if (is_error) {
[16:13:47.724]                   sessionInformation <- function() {
[16:13:47.724]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:47.724]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:47.724]                       search = base::search(), system = base::Sys.info())
[16:13:47.724]                   }
[16:13:47.724]                   ...future.conditions[[length(...future.conditions) + 
[16:13:47.724]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:47.724]                     cond$call), session = sessionInformation(), 
[16:13:47.724]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:47.724]                   signalCondition(cond)
[16:13:47.724]                 }
[16:13:47.724]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:47.724]                 "immediateCondition"))) {
[16:13:47.724]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:47.724]                   ...future.conditions[[length(...future.conditions) + 
[16:13:47.724]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:47.724]                   if (TRUE && !signal) {
[16:13:47.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:47.724]                     {
[16:13:47.724]                       inherits <- base::inherits
[16:13:47.724]                       invokeRestart <- base::invokeRestart
[16:13:47.724]                       is.null <- base::is.null
[16:13:47.724]                       muffled <- FALSE
[16:13:47.724]                       if (inherits(cond, "message")) {
[16:13:47.724]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:47.724]                         if (muffled) 
[16:13:47.724]                           invokeRestart("muffleMessage")
[16:13:47.724]                       }
[16:13:47.724]                       else if (inherits(cond, "warning")) {
[16:13:47.724]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:47.724]                         if (muffled) 
[16:13:47.724]                           invokeRestart("muffleWarning")
[16:13:47.724]                       }
[16:13:47.724]                       else if (inherits(cond, "condition")) {
[16:13:47.724]                         if (!is.null(pattern)) {
[16:13:47.724]                           computeRestarts <- base::computeRestarts
[16:13:47.724]                           grepl <- base::grepl
[16:13:47.724]                           restarts <- computeRestarts(cond)
[16:13:47.724]                           for (restart in restarts) {
[16:13:47.724]                             name <- restart$name
[16:13:47.724]                             if (is.null(name)) 
[16:13:47.724]                               next
[16:13:47.724]                             if (!grepl(pattern, name)) 
[16:13:47.724]                               next
[16:13:47.724]                             invokeRestart(restart)
[16:13:47.724]                             muffled <- TRUE
[16:13:47.724]                             break
[16:13:47.724]                           }
[16:13:47.724]                         }
[16:13:47.724]                       }
[16:13:47.724]                       invisible(muffled)
[16:13:47.724]                     }
[16:13:47.724]                     muffleCondition(cond, pattern = "^muffle")
[16:13:47.724]                   }
[16:13:47.724]                 }
[16:13:47.724]                 else {
[16:13:47.724]                   if (TRUE) {
[16:13:47.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:47.724]                     {
[16:13:47.724]                       inherits <- base::inherits
[16:13:47.724]                       invokeRestart <- base::invokeRestart
[16:13:47.724]                       is.null <- base::is.null
[16:13:47.724]                       muffled <- FALSE
[16:13:47.724]                       if (inherits(cond, "message")) {
[16:13:47.724]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:47.724]                         if (muffled) 
[16:13:47.724]                           invokeRestart("muffleMessage")
[16:13:47.724]                       }
[16:13:47.724]                       else if (inherits(cond, "warning")) {
[16:13:47.724]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:47.724]                         if (muffled) 
[16:13:47.724]                           invokeRestart("muffleWarning")
[16:13:47.724]                       }
[16:13:47.724]                       else if (inherits(cond, "condition")) {
[16:13:47.724]                         if (!is.null(pattern)) {
[16:13:47.724]                           computeRestarts <- base::computeRestarts
[16:13:47.724]                           grepl <- base::grepl
[16:13:47.724]                           restarts <- computeRestarts(cond)
[16:13:47.724]                           for (restart in restarts) {
[16:13:47.724]                             name <- restart$name
[16:13:47.724]                             if (is.null(name)) 
[16:13:47.724]                               next
[16:13:47.724]                             if (!grepl(pattern, name)) 
[16:13:47.724]                               next
[16:13:47.724]                             invokeRestart(restart)
[16:13:47.724]                             muffled <- TRUE
[16:13:47.724]                             break
[16:13:47.724]                           }
[16:13:47.724]                         }
[16:13:47.724]                       }
[16:13:47.724]                       invisible(muffled)
[16:13:47.724]                     }
[16:13:47.724]                     muffleCondition(cond, pattern = "^muffle")
[16:13:47.724]                   }
[16:13:47.724]                 }
[16:13:47.724]             }
[16:13:47.724]         }))
[16:13:47.724]     }, error = function(ex) {
[16:13:47.724]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:47.724]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:47.724]                 ...future.rng), started = ...future.startTime, 
[16:13:47.724]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:47.724]             version = "1.8"), class = "FutureResult")
[16:13:47.724]     }, finally = {
[16:13:47.724]         if (!identical(...future.workdir, getwd())) 
[16:13:47.724]             setwd(...future.workdir)
[16:13:47.724]         {
[16:13:47.724]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:47.724]                 ...future.oldOptions$nwarnings <- NULL
[16:13:47.724]             }
[16:13:47.724]             base::options(...future.oldOptions)
[16:13:47.724]             if (.Platform$OS.type == "windows") {
[16:13:47.724]                 old_names <- names(...future.oldEnvVars)
[16:13:47.724]                 envs <- base::Sys.getenv()
[16:13:47.724]                 names <- names(envs)
[16:13:47.724]                 common <- intersect(names, old_names)
[16:13:47.724]                 added <- setdiff(names, old_names)
[16:13:47.724]                 removed <- setdiff(old_names, names)
[16:13:47.724]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:47.724]                   envs[common]]
[16:13:47.724]                 NAMES <- toupper(changed)
[16:13:47.724]                 args <- list()
[16:13:47.724]                 for (kk in seq_along(NAMES)) {
[16:13:47.724]                   name <- changed[[kk]]
[16:13:47.724]                   NAME <- NAMES[[kk]]
[16:13:47.724]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:47.724]                     next
[16:13:47.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:47.724]                 }
[16:13:47.724]                 NAMES <- toupper(added)
[16:13:47.724]                 for (kk in seq_along(NAMES)) {
[16:13:47.724]                   name <- added[[kk]]
[16:13:47.724]                   NAME <- NAMES[[kk]]
[16:13:47.724]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:47.724]                     next
[16:13:47.724]                   args[[name]] <- ""
[16:13:47.724]                 }
[16:13:47.724]                 NAMES <- toupper(removed)
[16:13:47.724]                 for (kk in seq_along(NAMES)) {
[16:13:47.724]                   name <- removed[[kk]]
[16:13:47.724]                   NAME <- NAMES[[kk]]
[16:13:47.724]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:47.724]                     next
[16:13:47.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:47.724]                 }
[16:13:47.724]                 if (length(args) > 0) 
[16:13:47.724]                   base::do.call(base::Sys.setenv, args = args)
[16:13:47.724]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:47.724]             }
[16:13:47.724]             else {
[16:13:47.724]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:47.724]             }
[16:13:47.724]             {
[16:13:47.724]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:47.724]                   0L) {
[16:13:47.724]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:47.724]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:47.724]                   base::options(opts)
[16:13:47.724]                 }
[16:13:47.724]                 {
[16:13:47.724]                   {
[16:13:47.724]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:47.724]                     NULL
[16:13:47.724]                   }
[16:13:47.724]                   options(future.plan = NULL)
[16:13:47.724]                   if (is.na(NA_character_)) 
[16:13:47.724]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:47.724]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:47.724]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:47.724]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:47.724]                     envir = parent.frame()) 
[16:13:47.724]                   {
[16:13:47.724]                     if (is.function(workers)) 
[16:13:47.724]                       workers <- workers()
[16:13:47.724]                     workers <- structure(as.integer(workers), 
[16:13:47.724]                       class = class(workers))
[16:13:47.724]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:47.724]                       workers >= 1)
[16:13:47.724]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:47.724]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:47.724]                     }
[16:13:47.724]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:47.724]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:47.724]                       envir = envir)
[16:13:47.724]                     if (!future$lazy) 
[16:13:47.724]                       future <- run(future)
[16:13:47.724]                     invisible(future)
[16:13:47.724]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:47.724]                 }
[16:13:47.724]             }
[16:13:47.724]         }
[16:13:47.724]     })
[16:13:47.724]     if (TRUE) {
[16:13:47.724]         base::sink(type = "output", split = FALSE)
[16:13:47.724]         if (TRUE) {
[16:13:47.724]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:47.724]         }
[16:13:47.724]         else {
[16:13:47.724]             ...future.result["stdout"] <- base::list(NULL)
[16:13:47.724]         }
[16:13:47.724]         base::close(...future.stdout)
[16:13:47.724]         ...future.stdout <- NULL
[16:13:47.724]     }
[16:13:47.724]     ...future.result$conditions <- ...future.conditions
[16:13:47.724]     ...future.result$finished <- base::Sys.time()
[16:13:47.724]     ...future.result
[16:13:47.724] }
[16:13:47.727] MultisessionFuture started
[16:13:47.727] - Launch lazy future ... done
[16:13:47.727] run() for ‘MultisessionFuture’ ... done
[16:13:48.273] receiveMessageFromWorker() for ClusterFuture ...
[16:13:48.274] - Validating connection of MultisessionFuture
[16:13:48.274] - received message: FutureResult
[16:13:48.274] - Received FutureResult
[16:13:48.274] - Erased future from FutureRegistry
[16:13:48.274] result() for ClusterFuture ...
[16:13:48.274] - result already collected: FutureResult
[16:13:48.274] result() for ClusterFuture ... done
[16:13:48.274] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:48.274] A MultisessionFuture was resolved (result was not collected)
[16:13:48.275] getGlobalsAndPackages() ...
[16:13:48.275] Searching for globals...
[16:13:48.276] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:48.276] Searching for globals ... DONE
[16:13:48.276] Resolving globals: FALSE
[16:13:48.276] 
[16:13:48.276] 
[16:13:48.277] getGlobalsAndPackages() ... DONE
[16:13:48.277] run() for ‘Future’ ...
[16:13:48.277] - state: ‘created’
[16:13:48.277] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:48.291] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:48.291] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:48.291]   - Field: ‘node’
[16:13:48.292]   - Field: ‘label’
[16:13:48.292]   - Field: ‘local’
[16:13:48.292]   - Field: ‘owner’
[16:13:48.292]   - Field: ‘envir’
[16:13:48.292]   - Field: ‘workers’
[16:13:48.292]   - Field: ‘packages’
[16:13:48.292]   - Field: ‘gc’
[16:13:48.292]   - Field: ‘conditions’
[16:13:48.292]   - Field: ‘persistent’
[16:13:48.292]   - Field: ‘expr’
[16:13:48.292]   - Field: ‘uuid’
[16:13:48.293]   - Field: ‘seed’
[16:13:48.293]   - Field: ‘version’
[16:13:48.293]   - Field: ‘result’
[16:13:48.293]   - Field: ‘asynchronous’
[16:13:48.293]   - Field: ‘calls’
[16:13:48.293]   - Field: ‘globals’
[16:13:48.293]   - Field: ‘stdout’
[16:13:48.293]   - Field: ‘earlySignal’
[16:13:48.293]   - Field: ‘lazy’
[16:13:48.293]   - Field: ‘state’
[16:13:48.293] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:48.294] - Launch lazy future ...
[16:13:48.294] Packages needed by the future expression (n = 0): <none>
[16:13:48.294] Packages needed by future strategies (n = 0): <none>
[16:13:48.294] {
[16:13:48.294]     {
[16:13:48.294]         {
[16:13:48.294]             ...future.startTime <- base::Sys.time()
[16:13:48.294]             {
[16:13:48.294]                 {
[16:13:48.294]                   {
[16:13:48.294]                     {
[16:13:48.294]                       base::local({
[16:13:48.294]                         has_future <- base::requireNamespace("future", 
[16:13:48.294]                           quietly = TRUE)
[16:13:48.294]                         if (has_future) {
[16:13:48.294]                           ns <- base::getNamespace("future")
[16:13:48.294]                           version <- ns[[".package"]][["version"]]
[16:13:48.294]                           if (is.null(version)) 
[16:13:48.294]                             version <- utils::packageVersion("future")
[16:13:48.294]                         }
[16:13:48.294]                         else {
[16:13:48.294]                           version <- NULL
[16:13:48.294]                         }
[16:13:48.294]                         if (!has_future || version < "1.8.0") {
[16:13:48.294]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:48.294]                             "", base::R.version$version.string), 
[16:13:48.294]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:48.294]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:48.294]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:48.294]                               "release", "version")], collapse = " "), 
[16:13:48.294]                             hostname = base::Sys.info()[["nodename"]])
[16:13:48.294]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:48.294]                             info)
[16:13:48.294]                           info <- base::paste(info, collapse = "; ")
[16:13:48.294]                           if (!has_future) {
[16:13:48.294]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:48.294]                               info)
[16:13:48.294]                           }
[16:13:48.294]                           else {
[16:13:48.294]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:48.294]                               info, version)
[16:13:48.294]                           }
[16:13:48.294]                           base::stop(msg)
[16:13:48.294]                         }
[16:13:48.294]                       })
[16:13:48.294]                     }
[16:13:48.294]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:48.294]                     base::options(mc.cores = 1L)
[16:13:48.294]                   }
[16:13:48.294]                   options(future.plan = NULL)
[16:13:48.294]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:48.294]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:48.294]                 }
[16:13:48.294]                 ...future.workdir <- getwd()
[16:13:48.294]             }
[16:13:48.294]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:48.294]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:48.294]         }
[16:13:48.294]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:48.294]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:48.294]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:48.294]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:48.294]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:48.294]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:48.294]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:48.294]             base::names(...future.oldOptions))
[16:13:48.294]     }
[16:13:48.294]     if (FALSE) {
[16:13:48.294]     }
[16:13:48.294]     else {
[16:13:48.294]         if (TRUE) {
[16:13:48.294]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:48.294]                 open = "w")
[16:13:48.294]         }
[16:13:48.294]         else {
[16:13:48.294]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:48.294]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:48.294]         }
[16:13:48.294]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:48.294]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:48.294]             base::sink(type = "output", split = FALSE)
[16:13:48.294]             base::close(...future.stdout)
[16:13:48.294]         }, add = TRUE)
[16:13:48.294]     }
[16:13:48.294]     ...future.frame <- base::sys.nframe()
[16:13:48.294]     ...future.conditions <- base::list()
[16:13:48.294]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:48.294]     if (FALSE) {
[16:13:48.294]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:48.294]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:48.294]     }
[16:13:48.294]     ...future.result <- base::tryCatch({
[16:13:48.294]         base::withCallingHandlers({
[16:13:48.294]             ...future.value <- base::withVisible(base::local({
[16:13:48.294]                 ...future.makeSendCondition <- local({
[16:13:48.294]                   sendCondition <- NULL
[16:13:48.294]                   function(frame = 1L) {
[16:13:48.294]                     if (is.function(sendCondition)) 
[16:13:48.294]                       return(sendCondition)
[16:13:48.294]                     ns <- getNamespace("parallel")
[16:13:48.294]                     if (exists("sendData", mode = "function", 
[16:13:48.294]                       envir = ns)) {
[16:13:48.294]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:48.294]                         envir = ns)
[16:13:48.294]                       envir <- sys.frame(frame)
[16:13:48.294]                       master <- NULL
[16:13:48.294]                       while (!identical(envir, .GlobalEnv) && 
[16:13:48.294]                         !identical(envir, emptyenv())) {
[16:13:48.294]                         if (exists("master", mode = "list", envir = envir, 
[16:13:48.294]                           inherits = FALSE)) {
[16:13:48.294]                           master <- get("master", mode = "list", 
[16:13:48.294]                             envir = envir, inherits = FALSE)
[16:13:48.294]                           if (inherits(master, c("SOCKnode", 
[16:13:48.294]                             "SOCK0node"))) {
[16:13:48.294]                             sendCondition <<- function(cond) {
[16:13:48.294]                               data <- list(type = "VALUE", value = cond, 
[16:13:48.294]                                 success = TRUE)
[16:13:48.294]                               parallel_sendData(master, data)
[16:13:48.294]                             }
[16:13:48.294]                             return(sendCondition)
[16:13:48.294]                           }
[16:13:48.294]                         }
[16:13:48.294]                         frame <- frame + 1L
[16:13:48.294]                         envir <- sys.frame(frame)
[16:13:48.294]                       }
[16:13:48.294]                     }
[16:13:48.294]                     sendCondition <<- function(cond) NULL
[16:13:48.294]                   }
[16:13:48.294]                 })
[16:13:48.294]                 withCallingHandlers({
[16:13:48.294]                   {
[16:13:48.294]                     Sys.sleep(0.5)
[16:13:48.294]                     list(a = 1, b = 42L)
[16:13:48.294]                   }
[16:13:48.294]                 }, immediateCondition = function(cond) {
[16:13:48.294]                   sendCondition <- ...future.makeSendCondition()
[16:13:48.294]                   sendCondition(cond)
[16:13:48.294]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:48.294]                   {
[16:13:48.294]                     inherits <- base::inherits
[16:13:48.294]                     invokeRestart <- base::invokeRestart
[16:13:48.294]                     is.null <- base::is.null
[16:13:48.294]                     muffled <- FALSE
[16:13:48.294]                     if (inherits(cond, "message")) {
[16:13:48.294]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:48.294]                       if (muffled) 
[16:13:48.294]                         invokeRestart("muffleMessage")
[16:13:48.294]                     }
[16:13:48.294]                     else if (inherits(cond, "warning")) {
[16:13:48.294]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:48.294]                       if (muffled) 
[16:13:48.294]                         invokeRestart("muffleWarning")
[16:13:48.294]                     }
[16:13:48.294]                     else if (inherits(cond, "condition")) {
[16:13:48.294]                       if (!is.null(pattern)) {
[16:13:48.294]                         computeRestarts <- base::computeRestarts
[16:13:48.294]                         grepl <- base::grepl
[16:13:48.294]                         restarts <- computeRestarts(cond)
[16:13:48.294]                         for (restart in restarts) {
[16:13:48.294]                           name <- restart$name
[16:13:48.294]                           if (is.null(name)) 
[16:13:48.294]                             next
[16:13:48.294]                           if (!grepl(pattern, name)) 
[16:13:48.294]                             next
[16:13:48.294]                           invokeRestart(restart)
[16:13:48.294]                           muffled <- TRUE
[16:13:48.294]                           break
[16:13:48.294]                         }
[16:13:48.294]                       }
[16:13:48.294]                     }
[16:13:48.294]                     invisible(muffled)
[16:13:48.294]                   }
[16:13:48.294]                   muffleCondition(cond)
[16:13:48.294]                 })
[16:13:48.294]             }))
[16:13:48.294]             future::FutureResult(value = ...future.value$value, 
[16:13:48.294]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:48.294]                   ...future.rng), globalenv = if (FALSE) 
[16:13:48.294]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:48.294]                     ...future.globalenv.names))
[16:13:48.294]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:48.294]         }, condition = base::local({
[16:13:48.294]             c <- base::c
[16:13:48.294]             inherits <- base::inherits
[16:13:48.294]             invokeRestart <- base::invokeRestart
[16:13:48.294]             length <- base::length
[16:13:48.294]             list <- base::list
[16:13:48.294]             seq.int <- base::seq.int
[16:13:48.294]             signalCondition <- base::signalCondition
[16:13:48.294]             sys.calls <- base::sys.calls
[16:13:48.294]             `[[` <- base::`[[`
[16:13:48.294]             `+` <- base::`+`
[16:13:48.294]             `<<-` <- base::`<<-`
[16:13:48.294]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:48.294]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:48.294]                   3L)]
[16:13:48.294]             }
[16:13:48.294]             function(cond) {
[16:13:48.294]                 is_error <- inherits(cond, "error")
[16:13:48.294]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:48.294]                   NULL)
[16:13:48.294]                 if (is_error) {
[16:13:48.294]                   sessionInformation <- function() {
[16:13:48.294]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:48.294]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:48.294]                       search = base::search(), system = base::Sys.info())
[16:13:48.294]                   }
[16:13:48.294]                   ...future.conditions[[length(...future.conditions) + 
[16:13:48.294]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:48.294]                     cond$call), session = sessionInformation(), 
[16:13:48.294]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:48.294]                   signalCondition(cond)
[16:13:48.294]                 }
[16:13:48.294]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:48.294]                 "immediateCondition"))) {
[16:13:48.294]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:48.294]                   ...future.conditions[[length(...future.conditions) + 
[16:13:48.294]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:48.294]                   if (TRUE && !signal) {
[16:13:48.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:48.294]                     {
[16:13:48.294]                       inherits <- base::inherits
[16:13:48.294]                       invokeRestart <- base::invokeRestart
[16:13:48.294]                       is.null <- base::is.null
[16:13:48.294]                       muffled <- FALSE
[16:13:48.294]                       if (inherits(cond, "message")) {
[16:13:48.294]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:48.294]                         if (muffled) 
[16:13:48.294]                           invokeRestart("muffleMessage")
[16:13:48.294]                       }
[16:13:48.294]                       else if (inherits(cond, "warning")) {
[16:13:48.294]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:48.294]                         if (muffled) 
[16:13:48.294]                           invokeRestart("muffleWarning")
[16:13:48.294]                       }
[16:13:48.294]                       else if (inherits(cond, "condition")) {
[16:13:48.294]                         if (!is.null(pattern)) {
[16:13:48.294]                           computeRestarts <- base::computeRestarts
[16:13:48.294]                           grepl <- base::grepl
[16:13:48.294]                           restarts <- computeRestarts(cond)
[16:13:48.294]                           for (restart in restarts) {
[16:13:48.294]                             name <- restart$name
[16:13:48.294]                             if (is.null(name)) 
[16:13:48.294]                               next
[16:13:48.294]                             if (!grepl(pattern, name)) 
[16:13:48.294]                               next
[16:13:48.294]                             invokeRestart(restart)
[16:13:48.294]                             muffled <- TRUE
[16:13:48.294]                             break
[16:13:48.294]                           }
[16:13:48.294]                         }
[16:13:48.294]                       }
[16:13:48.294]                       invisible(muffled)
[16:13:48.294]                     }
[16:13:48.294]                     muffleCondition(cond, pattern = "^muffle")
[16:13:48.294]                   }
[16:13:48.294]                 }
[16:13:48.294]                 else {
[16:13:48.294]                   if (TRUE) {
[16:13:48.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:48.294]                     {
[16:13:48.294]                       inherits <- base::inherits
[16:13:48.294]                       invokeRestart <- base::invokeRestart
[16:13:48.294]                       is.null <- base::is.null
[16:13:48.294]                       muffled <- FALSE
[16:13:48.294]                       if (inherits(cond, "message")) {
[16:13:48.294]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:48.294]                         if (muffled) 
[16:13:48.294]                           invokeRestart("muffleMessage")
[16:13:48.294]                       }
[16:13:48.294]                       else if (inherits(cond, "warning")) {
[16:13:48.294]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:48.294]                         if (muffled) 
[16:13:48.294]                           invokeRestart("muffleWarning")
[16:13:48.294]                       }
[16:13:48.294]                       else if (inherits(cond, "condition")) {
[16:13:48.294]                         if (!is.null(pattern)) {
[16:13:48.294]                           computeRestarts <- base::computeRestarts
[16:13:48.294]                           grepl <- base::grepl
[16:13:48.294]                           restarts <- computeRestarts(cond)
[16:13:48.294]                           for (restart in restarts) {
[16:13:48.294]                             name <- restart$name
[16:13:48.294]                             if (is.null(name)) 
[16:13:48.294]                               next
[16:13:48.294]                             if (!grepl(pattern, name)) 
[16:13:48.294]                               next
[16:13:48.294]                             invokeRestart(restart)
[16:13:48.294]                             muffled <- TRUE
[16:13:48.294]                             break
[16:13:48.294]                           }
[16:13:48.294]                         }
[16:13:48.294]                       }
[16:13:48.294]                       invisible(muffled)
[16:13:48.294]                     }
[16:13:48.294]                     muffleCondition(cond, pattern = "^muffle")
[16:13:48.294]                   }
[16:13:48.294]                 }
[16:13:48.294]             }
[16:13:48.294]         }))
[16:13:48.294]     }, error = function(ex) {
[16:13:48.294]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:48.294]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:48.294]                 ...future.rng), started = ...future.startTime, 
[16:13:48.294]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:48.294]             version = "1.8"), class = "FutureResult")
[16:13:48.294]     }, finally = {
[16:13:48.294]         if (!identical(...future.workdir, getwd())) 
[16:13:48.294]             setwd(...future.workdir)
[16:13:48.294]         {
[16:13:48.294]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:48.294]                 ...future.oldOptions$nwarnings <- NULL
[16:13:48.294]             }
[16:13:48.294]             base::options(...future.oldOptions)
[16:13:48.294]             if (.Platform$OS.type == "windows") {
[16:13:48.294]                 old_names <- names(...future.oldEnvVars)
[16:13:48.294]                 envs <- base::Sys.getenv()
[16:13:48.294]                 names <- names(envs)
[16:13:48.294]                 common <- intersect(names, old_names)
[16:13:48.294]                 added <- setdiff(names, old_names)
[16:13:48.294]                 removed <- setdiff(old_names, names)
[16:13:48.294]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:48.294]                   envs[common]]
[16:13:48.294]                 NAMES <- toupper(changed)
[16:13:48.294]                 args <- list()
[16:13:48.294]                 for (kk in seq_along(NAMES)) {
[16:13:48.294]                   name <- changed[[kk]]
[16:13:48.294]                   NAME <- NAMES[[kk]]
[16:13:48.294]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:48.294]                     next
[16:13:48.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:48.294]                 }
[16:13:48.294]                 NAMES <- toupper(added)
[16:13:48.294]                 for (kk in seq_along(NAMES)) {
[16:13:48.294]                   name <- added[[kk]]
[16:13:48.294]                   NAME <- NAMES[[kk]]
[16:13:48.294]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:48.294]                     next
[16:13:48.294]                   args[[name]] <- ""
[16:13:48.294]                 }
[16:13:48.294]                 NAMES <- toupper(removed)
[16:13:48.294]                 for (kk in seq_along(NAMES)) {
[16:13:48.294]                   name <- removed[[kk]]
[16:13:48.294]                   NAME <- NAMES[[kk]]
[16:13:48.294]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:48.294]                     next
[16:13:48.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:48.294]                 }
[16:13:48.294]                 if (length(args) > 0) 
[16:13:48.294]                   base::do.call(base::Sys.setenv, args = args)
[16:13:48.294]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:48.294]             }
[16:13:48.294]             else {
[16:13:48.294]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:48.294]             }
[16:13:48.294]             {
[16:13:48.294]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:48.294]                   0L) {
[16:13:48.294]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:48.294]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:48.294]                   base::options(opts)
[16:13:48.294]                 }
[16:13:48.294]                 {
[16:13:48.294]                   {
[16:13:48.294]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:48.294]                     NULL
[16:13:48.294]                   }
[16:13:48.294]                   options(future.plan = NULL)
[16:13:48.294]                   if (is.na(NA_character_)) 
[16:13:48.294]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:48.294]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:48.294]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:48.294]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:48.294]                     envir = parent.frame()) 
[16:13:48.294]                   {
[16:13:48.294]                     if (is.function(workers)) 
[16:13:48.294]                       workers <- workers()
[16:13:48.294]                     workers <- structure(as.integer(workers), 
[16:13:48.294]                       class = class(workers))
[16:13:48.294]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:48.294]                       workers >= 1)
[16:13:48.294]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:48.294]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:48.294]                     }
[16:13:48.294]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:48.294]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:48.294]                       envir = envir)
[16:13:48.294]                     if (!future$lazy) 
[16:13:48.294]                       future <- run(future)
[16:13:48.294]                     invisible(future)
[16:13:48.294]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:48.294]                 }
[16:13:48.294]             }
[16:13:48.294]         }
[16:13:48.294]     })
[16:13:48.294]     if (TRUE) {
[16:13:48.294]         base::sink(type = "output", split = FALSE)
[16:13:48.294]         if (TRUE) {
[16:13:48.294]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:48.294]         }
[16:13:48.294]         else {
[16:13:48.294]             ...future.result["stdout"] <- base::list(NULL)
[16:13:48.294]         }
[16:13:48.294]         base::close(...future.stdout)
[16:13:48.294]         ...future.stdout <- NULL
[16:13:48.294]     }
[16:13:48.294]     ...future.result$conditions <- ...future.conditions
[16:13:48.294]     ...future.result$finished <- base::Sys.time()
[16:13:48.294]     ...future.result
[16:13:48.294] }
[16:13:48.297] MultisessionFuture started
[16:13:48.298] - Launch lazy future ... done
[16:13:48.298] run() for ‘MultisessionFuture’ ... done
[16:13:48.855] receiveMessageFromWorker() for ClusterFuture ...
[16:13:48.855] - Validating connection of MultisessionFuture
[16:13:48.855] - received message: FutureResult
[16:13:48.855] - Received FutureResult
[16:13:48.855] - Erased future from FutureRegistry
[16:13:48.855] result() for ClusterFuture ...
[16:13:48.856] - result already collected: FutureResult
[16:13:48.856] result() for ClusterFuture ... done
[16:13:48.856] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:48.856] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[16:13:48.856] getGlobalsAndPackages() ...
[16:13:48.856] Searching for globals...
[16:13:48.857] - globals found: [2] ‘list’, ‘stop’
[16:13:48.857] Searching for globals ... DONE
[16:13:48.857] Resolving globals: FALSE
[16:13:48.857] 
[16:13:48.857] 
[16:13:48.858] getGlobalsAndPackages() ... DONE
[16:13:48.858] run() for ‘Future’ ...
[16:13:48.858] - state: ‘created’
[16:13:48.858] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:48.872] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:48.872] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:48.872]   - Field: ‘node’
[16:13:48.872]   - Field: ‘label’
[16:13:48.873]   - Field: ‘local’
[16:13:48.873]   - Field: ‘owner’
[16:13:48.873]   - Field: ‘envir’
[16:13:48.873]   - Field: ‘workers’
[16:13:48.873]   - Field: ‘packages’
[16:13:48.873]   - Field: ‘gc’
[16:13:48.873]   - Field: ‘conditions’
[16:13:48.873]   - Field: ‘persistent’
[16:13:48.873]   - Field: ‘expr’
[16:13:48.873]   - Field: ‘uuid’
[16:13:48.873]   - Field: ‘seed’
[16:13:48.874]   - Field: ‘version’
[16:13:48.874]   - Field: ‘result’
[16:13:48.874]   - Field: ‘asynchronous’
[16:13:48.874]   - Field: ‘calls’
[16:13:48.874]   - Field: ‘globals’
[16:13:48.874]   - Field: ‘stdout’
[16:13:48.874]   - Field: ‘earlySignal’
[16:13:48.874]   - Field: ‘lazy’
[16:13:48.874]   - Field: ‘state’
[16:13:48.874] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:48.874] - Launch lazy future ...
[16:13:48.875] Packages needed by the future expression (n = 0): <none>
[16:13:48.875] Packages needed by future strategies (n = 0): <none>
[16:13:48.875] {
[16:13:48.875]     {
[16:13:48.875]         {
[16:13:48.875]             ...future.startTime <- base::Sys.time()
[16:13:48.875]             {
[16:13:48.875]                 {
[16:13:48.875]                   {
[16:13:48.875]                     {
[16:13:48.875]                       base::local({
[16:13:48.875]                         has_future <- base::requireNamespace("future", 
[16:13:48.875]                           quietly = TRUE)
[16:13:48.875]                         if (has_future) {
[16:13:48.875]                           ns <- base::getNamespace("future")
[16:13:48.875]                           version <- ns[[".package"]][["version"]]
[16:13:48.875]                           if (is.null(version)) 
[16:13:48.875]                             version <- utils::packageVersion("future")
[16:13:48.875]                         }
[16:13:48.875]                         else {
[16:13:48.875]                           version <- NULL
[16:13:48.875]                         }
[16:13:48.875]                         if (!has_future || version < "1.8.0") {
[16:13:48.875]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:48.875]                             "", base::R.version$version.string), 
[16:13:48.875]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:48.875]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:48.875]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:48.875]                               "release", "version")], collapse = " "), 
[16:13:48.875]                             hostname = base::Sys.info()[["nodename"]])
[16:13:48.875]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:48.875]                             info)
[16:13:48.875]                           info <- base::paste(info, collapse = "; ")
[16:13:48.875]                           if (!has_future) {
[16:13:48.875]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:48.875]                               info)
[16:13:48.875]                           }
[16:13:48.875]                           else {
[16:13:48.875]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:48.875]                               info, version)
[16:13:48.875]                           }
[16:13:48.875]                           base::stop(msg)
[16:13:48.875]                         }
[16:13:48.875]                       })
[16:13:48.875]                     }
[16:13:48.875]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:48.875]                     base::options(mc.cores = 1L)
[16:13:48.875]                   }
[16:13:48.875]                   options(future.plan = NULL)
[16:13:48.875]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:48.875]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:48.875]                 }
[16:13:48.875]                 ...future.workdir <- getwd()
[16:13:48.875]             }
[16:13:48.875]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:48.875]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:48.875]         }
[16:13:48.875]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:48.875]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:48.875]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:48.875]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:48.875]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:48.875]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:48.875]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:48.875]             base::names(...future.oldOptions))
[16:13:48.875]     }
[16:13:48.875]     if (FALSE) {
[16:13:48.875]     }
[16:13:48.875]     else {
[16:13:48.875]         if (TRUE) {
[16:13:48.875]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:48.875]                 open = "w")
[16:13:48.875]         }
[16:13:48.875]         else {
[16:13:48.875]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:48.875]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:48.875]         }
[16:13:48.875]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:48.875]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:48.875]             base::sink(type = "output", split = FALSE)
[16:13:48.875]             base::close(...future.stdout)
[16:13:48.875]         }, add = TRUE)
[16:13:48.875]     }
[16:13:48.875]     ...future.frame <- base::sys.nframe()
[16:13:48.875]     ...future.conditions <- base::list()
[16:13:48.875]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:48.875]     if (FALSE) {
[16:13:48.875]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:48.875]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:48.875]     }
[16:13:48.875]     ...future.result <- base::tryCatch({
[16:13:48.875]         base::withCallingHandlers({
[16:13:48.875]             ...future.value <- base::withVisible(base::local({
[16:13:48.875]                 ...future.makeSendCondition <- local({
[16:13:48.875]                   sendCondition <- NULL
[16:13:48.875]                   function(frame = 1L) {
[16:13:48.875]                     if (is.function(sendCondition)) 
[16:13:48.875]                       return(sendCondition)
[16:13:48.875]                     ns <- getNamespace("parallel")
[16:13:48.875]                     if (exists("sendData", mode = "function", 
[16:13:48.875]                       envir = ns)) {
[16:13:48.875]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:48.875]                         envir = ns)
[16:13:48.875]                       envir <- sys.frame(frame)
[16:13:48.875]                       master <- NULL
[16:13:48.875]                       while (!identical(envir, .GlobalEnv) && 
[16:13:48.875]                         !identical(envir, emptyenv())) {
[16:13:48.875]                         if (exists("master", mode = "list", envir = envir, 
[16:13:48.875]                           inherits = FALSE)) {
[16:13:48.875]                           master <- get("master", mode = "list", 
[16:13:48.875]                             envir = envir, inherits = FALSE)
[16:13:48.875]                           if (inherits(master, c("SOCKnode", 
[16:13:48.875]                             "SOCK0node"))) {
[16:13:48.875]                             sendCondition <<- function(cond) {
[16:13:48.875]                               data <- list(type = "VALUE", value = cond, 
[16:13:48.875]                                 success = TRUE)
[16:13:48.875]                               parallel_sendData(master, data)
[16:13:48.875]                             }
[16:13:48.875]                             return(sendCondition)
[16:13:48.875]                           }
[16:13:48.875]                         }
[16:13:48.875]                         frame <- frame + 1L
[16:13:48.875]                         envir <- sys.frame(frame)
[16:13:48.875]                       }
[16:13:48.875]                     }
[16:13:48.875]                     sendCondition <<- function(cond) NULL
[16:13:48.875]                   }
[16:13:48.875]                 })
[16:13:48.875]                 withCallingHandlers({
[16:13:48.875]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:48.875]                 }, immediateCondition = function(cond) {
[16:13:48.875]                   sendCondition <- ...future.makeSendCondition()
[16:13:48.875]                   sendCondition(cond)
[16:13:48.875]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:48.875]                   {
[16:13:48.875]                     inherits <- base::inherits
[16:13:48.875]                     invokeRestart <- base::invokeRestart
[16:13:48.875]                     is.null <- base::is.null
[16:13:48.875]                     muffled <- FALSE
[16:13:48.875]                     if (inherits(cond, "message")) {
[16:13:48.875]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:48.875]                       if (muffled) 
[16:13:48.875]                         invokeRestart("muffleMessage")
[16:13:48.875]                     }
[16:13:48.875]                     else if (inherits(cond, "warning")) {
[16:13:48.875]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:48.875]                       if (muffled) 
[16:13:48.875]                         invokeRestart("muffleWarning")
[16:13:48.875]                     }
[16:13:48.875]                     else if (inherits(cond, "condition")) {
[16:13:48.875]                       if (!is.null(pattern)) {
[16:13:48.875]                         computeRestarts <- base::computeRestarts
[16:13:48.875]                         grepl <- base::grepl
[16:13:48.875]                         restarts <- computeRestarts(cond)
[16:13:48.875]                         for (restart in restarts) {
[16:13:48.875]                           name <- restart$name
[16:13:48.875]                           if (is.null(name)) 
[16:13:48.875]                             next
[16:13:48.875]                           if (!grepl(pattern, name)) 
[16:13:48.875]                             next
[16:13:48.875]                           invokeRestart(restart)
[16:13:48.875]                           muffled <- TRUE
[16:13:48.875]                           break
[16:13:48.875]                         }
[16:13:48.875]                       }
[16:13:48.875]                     }
[16:13:48.875]                     invisible(muffled)
[16:13:48.875]                   }
[16:13:48.875]                   muffleCondition(cond)
[16:13:48.875]                 })
[16:13:48.875]             }))
[16:13:48.875]             future::FutureResult(value = ...future.value$value, 
[16:13:48.875]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:48.875]                   ...future.rng), globalenv = if (FALSE) 
[16:13:48.875]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:48.875]                     ...future.globalenv.names))
[16:13:48.875]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:48.875]         }, condition = base::local({
[16:13:48.875]             c <- base::c
[16:13:48.875]             inherits <- base::inherits
[16:13:48.875]             invokeRestart <- base::invokeRestart
[16:13:48.875]             length <- base::length
[16:13:48.875]             list <- base::list
[16:13:48.875]             seq.int <- base::seq.int
[16:13:48.875]             signalCondition <- base::signalCondition
[16:13:48.875]             sys.calls <- base::sys.calls
[16:13:48.875]             `[[` <- base::`[[`
[16:13:48.875]             `+` <- base::`+`
[16:13:48.875]             `<<-` <- base::`<<-`
[16:13:48.875]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:48.875]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:48.875]                   3L)]
[16:13:48.875]             }
[16:13:48.875]             function(cond) {
[16:13:48.875]                 is_error <- inherits(cond, "error")
[16:13:48.875]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:48.875]                   NULL)
[16:13:48.875]                 if (is_error) {
[16:13:48.875]                   sessionInformation <- function() {
[16:13:48.875]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:48.875]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:48.875]                       search = base::search(), system = base::Sys.info())
[16:13:48.875]                   }
[16:13:48.875]                   ...future.conditions[[length(...future.conditions) + 
[16:13:48.875]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:48.875]                     cond$call), session = sessionInformation(), 
[16:13:48.875]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:48.875]                   signalCondition(cond)
[16:13:48.875]                 }
[16:13:48.875]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:48.875]                 "immediateCondition"))) {
[16:13:48.875]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:48.875]                   ...future.conditions[[length(...future.conditions) + 
[16:13:48.875]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:48.875]                   if (TRUE && !signal) {
[16:13:48.875]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:48.875]                     {
[16:13:48.875]                       inherits <- base::inherits
[16:13:48.875]                       invokeRestart <- base::invokeRestart
[16:13:48.875]                       is.null <- base::is.null
[16:13:48.875]                       muffled <- FALSE
[16:13:48.875]                       if (inherits(cond, "message")) {
[16:13:48.875]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:48.875]                         if (muffled) 
[16:13:48.875]                           invokeRestart("muffleMessage")
[16:13:48.875]                       }
[16:13:48.875]                       else if (inherits(cond, "warning")) {
[16:13:48.875]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:48.875]                         if (muffled) 
[16:13:48.875]                           invokeRestart("muffleWarning")
[16:13:48.875]                       }
[16:13:48.875]                       else if (inherits(cond, "condition")) {
[16:13:48.875]                         if (!is.null(pattern)) {
[16:13:48.875]                           computeRestarts <- base::computeRestarts
[16:13:48.875]                           grepl <- base::grepl
[16:13:48.875]                           restarts <- computeRestarts(cond)
[16:13:48.875]                           for (restart in restarts) {
[16:13:48.875]                             name <- restart$name
[16:13:48.875]                             if (is.null(name)) 
[16:13:48.875]                               next
[16:13:48.875]                             if (!grepl(pattern, name)) 
[16:13:48.875]                               next
[16:13:48.875]                             invokeRestart(restart)
[16:13:48.875]                             muffled <- TRUE
[16:13:48.875]                             break
[16:13:48.875]                           }
[16:13:48.875]                         }
[16:13:48.875]                       }
[16:13:48.875]                       invisible(muffled)
[16:13:48.875]                     }
[16:13:48.875]                     muffleCondition(cond, pattern = "^muffle")
[16:13:48.875]                   }
[16:13:48.875]                 }
[16:13:48.875]                 else {
[16:13:48.875]                   if (TRUE) {
[16:13:48.875]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:48.875]                     {
[16:13:48.875]                       inherits <- base::inherits
[16:13:48.875]                       invokeRestart <- base::invokeRestart
[16:13:48.875]                       is.null <- base::is.null
[16:13:48.875]                       muffled <- FALSE
[16:13:48.875]                       if (inherits(cond, "message")) {
[16:13:48.875]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:48.875]                         if (muffled) 
[16:13:48.875]                           invokeRestart("muffleMessage")
[16:13:48.875]                       }
[16:13:48.875]                       else if (inherits(cond, "warning")) {
[16:13:48.875]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:48.875]                         if (muffled) 
[16:13:48.875]                           invokeRestart("muffleWarning")
[16:13:48.875]                       }
[16:13:48.875]                       else if (inherits(cond, "condition")) {
[16:13:48.875]                         if (!is.null(pattern)) {
[16:13:48.875]                           computeRestarts <- base::computeRestarts
[16:13:48.875]                           grepl <- base::grepl
[16:13:48.875]                           restarts <- computeRestarts(cond)
[16:13:48.875]                           for (restart in restarts) {
[16:13:48.875]                             name <- restart$name
[16:13:48.875]                             if (is.null(name)) 
[16:13:48.875]                               next
[16:13:48.875]                             if (!grepl(pattern, name)) 
[16:13:48.875]                               next
[16:13:48.875]                             invokeRestart(restart)
[16:13:48.875]                             muffled <- TRUE
[16:13:48.875]                             break
[16:13:48.875]                           }
[16:13:48.875]                         }
[16:13:48.875]                       }
[16:13:48.875]                       invisible(muffled)
[16:13:48.875]                     }
[16:13:48.875]                     muffleCondition(cond, pattern = "^muffle")
[16:13:48.875]                   }
[16:13:48.875]                 }
[16:13:48.875]             }
[16:13:48.875]         }))
[16:13:48.875]     }, error = function(ex) {
[16:13:48.875]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:48.875]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:48.875]                 ...future.rng), started = ...future.startTime, 
[16:13:48.875]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:48.875]             version = "1.8"), class = "FutureResult")
[16:13:48.875]     }, finally = {
[16:13:48.875]         if (!identical(...future.workdir, getwd())) 
[16:13:48.875]             setwd(...future.workdir)
[16:13:48.875]         {
[16:13:48.875]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:48.875]                 ...future.oldOptions$nwarnings <- NULL
[16:13:48.875]             }
[16:13:48.875]             base::options(...future.oldOptions)
[16:13:48.875]             if (.Platform$OS.type == "windows") {
[16:13:48.875]                 old_names <- names(...future.oldEnvVars)
[16:13:48.875]                 envs <- base::Sys.getenv()
[16:13:48.875]                 names <- names(envs)
[16:13:48.875]                 common <- intersect(names, old_names)
[16:13:48.875]                 added <- setdiff(names, old_names)
[16:13:48.875]                 removed <- setdiff(old_names, names)
[16:13:48.875]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:48.875]                   envs[common]]
[16:13:48.875]                 NAMES <- toupper(changed)
[16:13:48.875]                 args <- list()
[16:13:48.875]                 for (kk in seq_along(NAMES)) {
[16:13:48.875]                   name <- changed[[kk]]
[16:13:48.875]                   NAME <- NAMES[[kk]]
[16:13:48.875]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:48.875]                     next
[16:13:48.875]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:48.875]                 }
[16:13:48.875]                 NAMES <- toupper(added)
[16:13:48.875]                 for (kk in seq_along(NAMES)) {
[16:13:48.875]                   name <- added[[kk]]
[16:13:48.875]                   NAME <- NAMES[[kk]]
[16:13:48.875]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:48.875]                     next
[16:13:48.875]                   args[[name]] <- ""
[16:13:48.875]                 }
[16:13:48.875]                 NAMES <- toupper(removed)
[16:13:48.875]                 for (kk in seq_along(NAMES)) {
[16:13:48.875]                   name <- removed[[kk]]
[16:13:48.875]                   NAME <- NAMES[[kk]]
[16:13:48.875]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:48.875]                     next
[16:13:48.875]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:48.875]                 }
[16:13:48.875]                 if (length(args) > 0) 
[16:13:48.875]                   base::do.call(base::Sys.setenv, args = args)
[16:13:48.875]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:48.875]             }
[16:13:48.875]             else {
[16:13:48.875]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:48.875]             }
[16:13:48.875]             {
[16:13:48.875]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:48.875]                   0L) {
[16:13:48.875]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:48.875]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:48.875]                   base::options(opts)
[16:13:48.875]                 }
[16:13:48.875]                 {
[16:13:48.875]                   {
[16:13:48.875]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:48.875]                     NULL
[16:13:48.875]                   }
[16:13:48.875]                   options(future.plan = NULL)
[16:13:48.875]                   if (is.na(NA_character_)) 
[16:13:48.875]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:48.875]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:48.875]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:48.875]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:48.875]                     envir = parent.frame()) 
[16:13:48.875]                   {
[16:13:48.875]                     if (is.function(workers)) 
[16:13:48.875]                       workers <- workers()
[16:13:48.875]                     workers <- structure(as.integer(workers), 
[16:13:48.875]                       class = class(workers))
[16:13:48.875]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:48.875]                       workers >= 1)
[16:13:48.875]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:48.875]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:48.875]                     }
[16:13:48.875]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:48.875]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:48.875]                       envir = envir)
[16:13:48.875]                     if (!future$lazy) 
[16:13:48.875]                       future <- run(future)
[16:13:48.875]                     invisible(future)
[16:13:48.875]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:48.875]                 }
[16:13:48.875]             }
[16:13:48.875]         }
[16:13:48.875]     })
[16:13:48.875]     if (TRUE) {
[16:13:48.875]         base::sink(type = "output", split = FALSE)
[16:13:48.875]         if (TRUE) {
[16:13:48.875]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:48.875]         }
[16:13:48.875]         else {
[16:13:48.875]             ...future.result["stdout"] <- base::list(NULL)
[16:13:48.875]         }
[16:13:48.875]         base::close(...future.stdout)
[16:13:48.875]         ...future.stdout <- NULL
[16:13:48.875]     }
[16:13:48.875]     ...future.result$conditions <- ...future.conditions
[16:13:48.875]     ...future.result$finished <- base::Sys.time()
[16:13:48.875]     ...future.result
[16:13:48.875] }
[16:13:48.878] MultisessionFuture started
[16:13:48.878] - Launch lazy future ... done
[16:13:48.879] run() for ‘MultisessionFuture’ ... done
[16:13:48.925] receiveMessageFromWorker() for ClusterFuture ...
[16:13:48.925] - Validating connection of MultisessionFuture
[16:13:48.926] - received message: FutureResult
[16:13:48.926] - Received FutureResult
[16:13:48.926] - Erased future from FutureRegistry
[16:13:48.926] result() for ClusterFuture ...
[16:13:48.926] - result already collected: FutureResult
[16:13:48.926] result() for ClusterFuture ... done
[16:13:48.926] signalConditions() ...
[16:13:48.926]  - include = ‘immediateCondition’
[16:13:48.926]  - exclude = 
[16:13:48.926]  - resignal = FALSE
[16:13:48.927]  - Number of conditions: 1
[16:13:48.927] signalConditions() ... done
[16:13:48.927] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:48.927] A MultisessionFuture was resolved (result was not collected)
[16:13:48.927] getGlobalsAndPackages() ...
[16:13:48.927] Searching for globals...
[16:13:48.928] - globals found: [2] ‘list’, ‘stop’
[16:13:48.928] Searching for globals ... DONE
[16:13:48.928] Resolving globals: FALSE
[16:13:48.928] 
[16:13:48.928] 
[16:13:48.928] getGlobalsAndPackages() ... DONE
[16:13:48.929] run() for ‘Future’ ...
[16:13:48.929] - state: ‘created’
[16:13:48.929] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:48.945] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:48.945] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:48.945]   - Field: ‘node’
[16:13:48.945]   - Field: ‘label’
[16:13:48.945]   - Field: ‘local’
[16:13:48.945]   - Field: ‘owner’
[16:13:48.946]   - Field: ‘envir’
[16:13:48.946]   - Field: ‘workers’
[16:13:48.946]   - Field: ‘packages’
[16:13:48.946]   - Field: ‘gc’
[16:13:48.946]   - Field: ‘conditions’
[16:13:48.946]   - Field: ‘persistent’
[16:13:48.946]   - Field: ‘expr’
[16:13:48.946]   - Field: ‘uuid’
[16:13:48.946]   - Field: ‘seed’
[16:13:48.946]   - Field: ‘version’
[16:13:48.946]   - Field: ‘result’
[16:13:48.947]   - Field: ‘asynchronous’
[16:13:48.947]   - Field: ‘calls’
[16:13:48.947]   - Field: ‘globals’
[16:13:48.947]   - Field: ‘stdout’
[16:13:48.947]   - Field: ‘earlySignal’
[16:13:48.947]   - Field: ‘lazy’
[16:13:48.947]   - Field: ‘state’
[16:13:48.947] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:48.947] - Launch lazy future ...
[16:13:48.947] Packages needed by the future expression (n = 0): <none>
[16:13:48.948] Packages needed by future strategies (n = 0): <none>
[16:13:48.948] {
[16:13:48.948]     {
[16:13:48.948]         {
[16:13:48.948]             ...future.startTime <- base::Sys.time()
[16:13:48.948]             {
[16:13:48.948]                 {
[16:13:48.948]                   {
[16:13:48.948]                     {
[16:13:48.948]                       base::local({
[16:13:48.948]                         has_future <- base::requireNamespace("future", 
[16:13:48.948]                           quietly = TRUE)
[16:13:48.948]                         if (has_future) {
[16:13:48.948]                           ns <- base::getNamespace("future")
[16:13:48.948]                           version <- ns[[".package"]][["version"]]
[16:13:48.948]                           if (is.null(version)) 
[16:13:48.948]                             version <- utils::packageVersion("future")
[16:13:48.948]                         }
[16:13:48.948]                         else {
[16:13:48.948]                           version <- NULL
[16:13:48.948]                         }
[16:13:48.948]                         if (!has_future || version < "1.8.0") {
[16:13:48.948]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:48.948]                             "", base::R.version$version.string), 
[16:13:48.948]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:48.948]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:48.948]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:48.948]                               "release", "version")], collapse = " "), 
[16:13:48.948]                             hostname = base::Sys.info()[["nodename"]])
[16:13:48.948]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:48.948]                             info)
[16:13:48.948]                           info <- base::paste(info, collapse = "; ")
[16:13:48.948]                           if (!has_future) {
[16:13:48.948]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:48.948]                               info)
[16:13:48.948]                           }
[16:13:48.948]                           else {
[16:13:48.948]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:48.948]                               info, version)
[16:13:48.948]                           }
[16:13:48.948]                           base::stop(msg)
[16:13:48.948]                         }
[16:13:48.948]                       })
[16:13:48.948]                     }
[16:13:48.948]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:48.948]                     base::options(mc.cores = 1L)
[16:13:48.948]                   }
[16:13:48.948]                   options(future.plan = NULL)
[16:13:48.948]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:48.948]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:48.948]                 }
[16:13:48.948]                 ...future.workdir <- getwd()
[16:13:48.948]             }
[16:13:48.948]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:48.948]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:48.948]         }
[16:13:48.948]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:48.948]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:48.948]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:48.948]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:48.948]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:48.948]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:48.948]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:48.948]             base::names(...future.oldOptions))
[16:13:48.948]     }
[16:13:48.948]     if (FALSE) {
[16:13:48.948]     }
[16:13:48.948]     else {
[16:13:48.948]         if (TRUE) {
[16:13:48.948]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:48.948]                 open = "w")
[16:13:48.948]         }
[16:13:48.948]         else {
[16:13:48.948]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:48.948]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:48.948]         }
[16:13:48.948]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:48.948]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:48.948]             base::sink(type = "output", split = FALSE)
[16:13:48.948]             base::close(...future.stdout)
[16:13:48.948]         }, add = TRUE)
[16:13:48.948]     }
[16:13:48.948]     ...future.frame <- base::sys.nframe()
[16:13:48.948]     ...future.conditions <- base::list()
[16:13:48.948]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:48.948]     if (FALSE) {
[16:13:48.948]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:48.948]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:48.948]     }
[16:13:48.948]     ...future.result <- base::tryCatch({
[16:13:48.948]         base::withCallingHandlers({
[16:13:48.948]             ...future.value <- base::withVisible(base::local({
[16:13:48.948]                 ...future.makeSendCondition <- local({
[16:13:48.948]                   sendCondition <- NULL
[16:13:48.948]                   function(frame = 1L) {
[16:13:48.948]                     if (is.function(sendCondition)) 
[16:13:48.948]                       return(sendCondition)
[16:13:48.948]                     ns <- getNamespace("parallel")
[16:13:48.948]                     if (exists("sendData", mode = "function", 
[16:13:48.948]                       envir = ns)) {
[16:13:48.948]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:48.948]                         envir = ns)
[16:13:48.948]                       envir <- sys.frame(frame)
[16:13:48.948]                       master <- NULL
[16:13:48.948]                       while (!identical(envir, .GlobalEnv) && 
[16:13:48.948]                         !identical(envir, emptyenv())) {
[16:13:48.948]                         if (exists("master", mode = "list", envir = envir, 
[16:13:48.948]                           inherits = FALSE)) {
[16:13:48.948]                           master <- get("master", mode = "list", 
[16:13:48.948]                             envir = envir, inherits = FALSE)
[16:13:48.948]                           if (inherits(master, c("SOCKnode", 
[16:13:48.948]                             "SOCK0node"))) {
[16:13:48.948]                             sendCondition <<- function(cond) {
[16:13:48.948]                               data <- list(type = "VALUE", value = cond, 
[16:13:48.948]                                 success = TRUE)
[16:13:48.948]                               parallel_sendData(master, data)
[16:13:48.948]                             }
[16:13:48.948]                             return(sendCondition)
[16:13:48.948]                           }
[16:13:48.948]                         }
[16:13:48.948]                         frame <- frame + 1L
[16:13:48.948]                         envir <- sys.frame(frame)
[16:13:48.948]                       }
[16:13:48.948]                     }
[16:13:48.948]                     sendCondition <<- function(cond) NULL
[16:13:48.948]                   }
[16:13:48.948]                 })
[16:13:48.948]                 withCallingHandlers({
[16:13:48.948]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:48.948]                 }, immediateCondition = function(cond) {
[16:13:48.948]                   sendCondition <- ...future.makeSendCondition()
[16:13:48.948]                   sendCondition(cond)
[16:13:48.948]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:48.948]                   {
[16:13:48.948]                     inherits <- base::inherits
[16:13:48.948]                     invokeRestart <- base::invokeRestart
[16:13:48.948]                     is.null <- base::is.null
[16:13:48.948]                     muffled <- FALSE
[16:13:48.948]                     if (inherits(cond, "message")) {
[16:13:48.948]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:48.948]                       if (muffled) 
[16:13:48.948]                         invokeRestart("muffleMessage")
[16:13:48.948]                     }
[16:13:48.948]                     else if (inherits(cond, "warning")) {
[16:13:48.948]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:48.948]                       if (muffled) 
[16:13:48.948]                         invokeRestart("muffleWarning")
[16:13:48.948]                     }
[16:13:48.948]                     else if (inherits(cond, "condition")) {
[16:13:48.948]                       if (!is.null(pattern)) {
[16:13:48.948]                         computeRestarts <- base::computeRestarts
[16:13:48.948]                         grepl <- base::grepl
[16:13:48.948]                         restarts <- computeRestarts(cond)
[16:13:48.948]                         for (restart in restarts) {
[16:13:48.948]                           name <- restart$name
[16:13:48.948]                           if (is.null(name)) 
[16:13:48.948]                             next
[16:13:48.948]                           if (!grepl(pattern, name)) 
[16:13:48.948]                             next
[16:13:48.948]                           invokeRestart(restart)
[16:13:48.948]                           muffled <- TRUE
[16:13:48.948]                           break
[16:13:48.948]                         }
[16:13:48.948]                       }
[16:13:48.948]                     }
[16:13:48.948]                     invisible(muffled)
[16:13:48.948]                   }
[16:13:48.948]                   muffleCondition(cond)
[16:13:48.948]                 })
[16:13:48.948]             }))
[16:13:48.948]             future::FutureResult(value = ...future.value$value, 
[16:13:48.948]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:48.948]                   ...future.rng), globalenv = if (FALSE) 
[16:13:48.948]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:48.948]                     ...future.globalenv.names))
[16:13:48.948]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:48.948]         }, condition = base::local({
[16:13:48.948]             c <- base::c
[16:13:48.948]             inherits <- base::inherits
[16:13:48.948]             invokeRestart <- base::invokeRestart
[16:13:48.948]             length <- base::length
[16:13:48.948]             list <- base::list
[16:13:48.948]             seq.int <- base::seq.int
[16:13:48.948]             signalCondition <- base::signalCondition
[16:13:48.948]             sys.calls <- base::sys.calls
[16:13:48.948]             `[[` <- base::`[[`
[16:13:48.948]             `+` <- base::`+`
[16:13:48.948]             `<<-` <- base::`<<-`
[16:13:48.948]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:48.948]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:48.948]                   3L)]
[16:13:48.948]             }
[16:13:48.948]             function(cond) {
[16:13:48.948]                 is_error <- inherits(cond, "error")
[16:13:48.948]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:48.948]                   NULL)
[16:13:48.948]                 if (is_error) {
[16:13:48.948]                   sessionInformation <- function() {
[16:13:48.948]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:48.948]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:48.948]                       search = base::search(), system = base::Sys.info())
[16:13:48.948]                   }
[16:13:48.948]                   ...future.conditions[[length(...future.conditions) + 
[16:13:48.948]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:48.948]                     cond$call), session = sessionInformation(), 
[16:13:48.948]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:48.948]                   signalCondition(cond)
[16:13:48.948]                 }
[16:13:48.948]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:48.948]                 "immediateCondition"))) {
[16:13:48.948]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:48.948]                   ...future.conditions[[length(...future.conditions) + 
[16:13:48.948]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:48.948]                   if (TRUE && !signal) {
[16:13:48.948]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:48.948]                     {
[16:13:48.948]                       inherits <- base::inherits
[16:13:48.948]                       invokeRestart <- base::invokeRestart
[16:13:48.948]                       is.null <- base::is.null
[16:13:48.948]                       muffled <- FALSE
[16:13:48.948]                       if (inherits(cond, "message")) {
[16:13:48.948]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:48.948]                         if (muffled) 
[16:13:48.948]                           invokeRestart("muffleMessage")
[16:13:48.948]                       }
[16:13:48.948]                       else if (inherits(cond, "warning")) {
[16:13:48.948]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:48.948]                         if (muffled) 
[16:13:48.948]                           invokeRestart("muffleWarning")
[16:13:48.948]                       }
[16:13:48.948]                       else if (inherits(cond, "condition")) {
[16:13:48.948]                         if (!is.null(pattern)) {
[16:13:48.948]                           computeRestarts <- base::computeRestarts
[16:13:48.948]                           grepl <- base::grepl
[16:13:48.948]                           restarts <- computeRestarts(cond)
[16:13:48.948]                           for (restart in restarts) {
[16:13:48.948]                             name <- restart$name
[16:13:48.948]                             if (is.null(name)) 
[16:13:48.948]                               next
[16:13:48.948]                             if (!grepl(pattern, name)) 
[16:13:48.948]                               next
[16:13:48.948]                             invokeRestart(restart)
[16:13:48.948]                             muffled <- TRUE
[16:13:48.948]                             break
[16:13:48.948]                           }
[16:13:48.948]                         }
[16:13:48.948]                       }
[16:13:48.948]                       invisible(muffled)
[16:13:48.948]                     }
[16:13:48.948]                     muffleCondition(cond, pattern = "^muffle")
[16:13:48.948]                   }
[16:13:48.948]                 }
[16:13:48.948]                 else {
[16:13:48.948]                   if (TRUE) {
[16:13:48.948]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:48.948]                     {
[16:13:48.948]                       inherits <- base::inherits
[16:13:48.948]                       invokeRestart <- base::invokeRestart
[16:13:48.948]                       is.null <- base::is.null
[16:13:48.948]                       muffled <- FALSE
[16:13:48.948]                       if (inherits(cond, "message")) {
[16:13:48.948]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:48.948]                         if (muffled) 
[16:13:48.948]                           invokeRestart("muffleMessage")
[16:13:48.948]                       }
[16:13:48.948]                       else if (inherits(cond, "warning")) {
[16:13:48.948]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:48.948]                         if (muffled) 
[16:13:48.948]                           invokeRestart("muffleWarning")
[16:13:48.948]                       }
[16:13:48.948]                       else if (inherits(cond, "condition")) {
[16:13:48.948]                         if (!is.null(pattern)) {
[16:13:48.948]                           computeRestarts <- base::computeRestarts
[16:13:48.948]                           grepl <- base::grepl
[16:13:48.948]                           restarts <- computeRestarts(cond)
[16:13:48.948]                           for (restart in restarts) {
[16:13:48.948]                             name <- restart$name
[16:13:48.948]                             if (is.null(name)) 
[16:13:48.948]                               next
[16:13:48.948]                             if (!grepl(pattern, name)) 
[16:13:48.948]                               next
[16:13:48.948]                             invokeRestart(restart)
[16:13:48.948]                             muffled <- TRUE
[16:13:48.948]                             break
[16:13:48.948]                           }
[16:13:48.948]                         }
[16:13:48.948]                       }
[16:13:48.948]                       invisible(muffled)
[16:13:48.948]                     }
[16:13:48.948]                     muffleCondition(cond, pattern = "^muffle")
[16:13:48.948]                   }
[16:13:48.948]                 }
[16:13:48.948]             }
[16:13:48.948]         }))
[16:13:48.948]     }, error = function(ex) {
[16:13:48.948]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:48.948]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:48.948]                 ...future.rng), started = ...future.startTime, 
[16:13:48.948]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:48.948]             version = "1.8"), class = "FutureResult")
[16:13:48.948]     }, finally = {
[16:13:48.948]         if (!identical(...future.workdir, getwd())) 
[16:13:48.948]             setwd(...future.workdir)
[16:13:48.948]         {
[16:13:48.948]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:48.948]                 ...future.oldOptions$nwarnings <- NULL
[16:13:48.948]             }
[16:13:48.948]             base::options(...future.oldOptions)
[16:13:48.948]             if (.Platform$OS.type == "windows") {
[16:13:48.948]                 old_names <- names(...future.oldEnvVars)
[16:13:48.948]                 envs <- base::Sys.getenv()
[16:13:48.948]                 names <- names(envs)
[16:13:48.948]                 common <- intersect(names, old_names)
[16:13:48.948]                 added <- setdiff(names, old_names)
[16:13:48.948]                 removed <- setdiff(old_names, names)
[16:13:48.948]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:48.948]                   envs[common]]
[16:13:48.948]                 NAMES <- toupper(changed)
[16:13:48.948]                 args <- list()
[16:13:48.948]                 for (kk in seq_along(NAMES)) {
[16:13:48.948]                   name <- changed[[kk]]
[16:13:48.948]                   NAME <- NAMES[[kk]]
[16:13:48.948]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:48.948]                     next
[16:13:48.948]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:48.948]                 }
[16:13:48.948]                 NAMES <- toupper(added)
[16:13:48.948]                 for (kk in seq_along(NAMES)) {
[16:13:48.948]                   name <- added[[kk]]
[16:13:48.948]                   NAME <- NAMES[[kk]]
[16:13:48.948]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:48.948]                     next
[16:13:48.948]                   args[[name]] <- ""
[16:13:48.948]                 }
[16:13:48.948]                 NAMES <- toupper(removed)
[16:13:48.948]                 for (kk in seq_along(NAMES)) {
[16:13:48.948]                   name <- removed[[kk]]
[16:13:48.948]                   NAME <- NAMES[[kk]]
[16:13:48.948]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:48.948]                     next
[16:13:48.948]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:48.948]                 }
[16:13:48.948]                 if (length(args) > 0) 
[16:13:48.948]                   base::do.call(base::Sys.setenv, args = args)
[16:13:48.948]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:48.948]             }
[16:13:48.948]             else {
[16:13:48.948]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:48.948]             }
[16:13:48.948]             {
[16:13:48.948]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:48.948]                   0L) {
[16:13:48.948]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:48.948]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:48.948]                   base::options(opts)
[16:13:48.948]                 }
[16:13:48.948]                 {
[16:13:48.948]                   {
[16:13:48.948]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:48.948]                     NULL
[16:13:48.948]                   }
[16:13:48.948]                   options(future.plan = NULL)
[16:13:48.948]                   if (is.na(NA_character_)) 
[16:13:48.948]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:48.948]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:48.948]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:48.948]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:48.948]                     envir = parent.frame()) 
[16:13:48.948]                   {
[16:13:48.948]                     if (is.function(workers)) 
[16:13:48.948]                       workers <- workers()
[16:13:48.948]                     workers <- structure(as.integer(workers), 
[16:13:48.948]                       class = class(workers))
[16:13:48.948]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:48.948]                       workers >= 1)
[16:13:48.948]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:48.948]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:48.948]                     }
[16:13:48.948]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:48.948]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:48.948]                       envir = envir)
[16:13:48.948]                     if (!future$lazy) 
[16:13:48.948]                       future <- run(future)
[16:13:48.948]                     invisible(future)
[16:13:48.948]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:48.948]                 }
[16:13:48.948]             }
[16:13:48.948]         }
[16:13:48.948]     })
[16:13:48.948]     if (TRUE) {
[16:13:48.948]         base::sink(type = "output", split = FALSE)
[16:13:48.948]         if (TRUE) {
[16:13:48.948]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:48.948]         }
[16:13:48.948]         else {
[16:13:48.948]             ...future.result["stdout"] <- base::list(NULL)
[16:13:48.948]         }
[16:13:48.948]         base::close(...future.stdout)
[16:13:48.948]         ...future.stdout <- NULL
[16:13:48.948]     }
[16:13:48.948]     ...future.result$conditions <- ...future.conditions
[16:13:48.948]     ...future.result$finished <- base::Sys.time()
[16:13:48.948]     ...future.result
[16:13:48.948] }
[16:13:48.951] MultisessionFuture started
[16:13:48.951] - Launch lazy future ... done
[16:13:48.951] run() for ‘MultisessionFuture’ ... done
[16:13:48.996] receiveMessageFromWorker() for ClusterFuture ...
[16:13:48.996] - Validating connection of MultisessionFuture
[16:13:48.997] - received message: FutureResult
[16:13:48.997] - Received FutureResult
[16:13:48.997] - Erased future from FutureRegistry
[16:13:48.997] result() for ClusterFuture ...
[16:13:48.997] - result already collected: FutureResult
[16:13:48.997] result() for ClusterFuture ... done
[16:13:48.998] signalConditions() ...
[16:13:48.998]  - include = ‘immediateCondition’
[16:13:48.998]  - exclude = 
[16:13:48.998]  - resignal = FALSE
[16:13:48.998]  - Number of conditions: 1
[16:13:48.998] signalConditions() ... done
[16:13:48.998] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:48.998] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 1 ... DONE
- result = FALSE, recursive = 2 ...
[16:13:48.998] getGlobalsAndPackages() ...
[16:13:48.998] Searching for globals...
[16:13:49.000] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:49.000] Searching for globals ... DONE
[16:13:49.000] Resolving globals: FALSE
[16:13:49.000] 
[16:13:49.000] 
[16:13:49.000] getGlobalsAndPackages() ... DONE
[16:13:49.001] run() for ‘Future’ ...
[16:13:49.001] - state: ‘created’
[16:13:49.001] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:49.015] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:49.015] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:49.015]   - Field: ‘node’
[16:13:49.015]   - Field: ‘label’
[16:13:49.015]   - Field: ‘local’
[16:13:49.015]   - Field: ‘owner’
[16:13:49.016]   - Field: ‘envir’
[16:13:49.016]   - Field: ‘workers’
[16:13:49.016]   - Field: ‘packages’
[16:13:49.016]   - Field: ‘gc’
[16:13:49.016]   - Field: ‘conditions’
[16:13:49.016]   - Field: ‘persistent’
[16:13:49.016]   - Field: ‘expr’
[16:13:49.016]   - Field: ‘uuid’
[16:13:49.016]   - Field: ‘seed’
[16:13:49.016]   - Field: ‘version’
[16:13:49.016]   - Field: ‘result’
[16:13:49.017]   - Field: ‘asynchronous’
[16:13:49.017]   - Field: ‘calls’
[16:13:49.017]   - Field: ‘globals’
[16:13:49.017]   - Field: ‘stdout’
[16:13:49.017]   - Field: ‘earlySignal’
[16:13:49.017]   - Field: ‘lazy’
[16:13:49.017]   - Field: ‘state’
[16:13:49.017] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:49.017] - Launch lazy future ...
[16:13:49.018] Packages needed by the future expression (n = 0): <none>
[16:13:49.018] Packages needed by future strategies (n = 0): <none>
[16:13:49.018] {
[16:13:49.018]     {
[16:13:49.018]         {
[16:13:49.018]             ...future.startTime <- base::Sys.time()
[16:13:49.018]             {
[16:13:49.018]                 {
[16:13:49.018]                   {
[16:13:49.018]                     {
[16:13:49.018]                       base::local({
[16:13:49.018]                         has_future <- base::requireNamespace("future", 
[16:13:49.018]                           quietly = TRUE)
[16:13:49.018]                         if (has_future) {
[16:13:49.018]                           ns <- base::getNamespace("future")
[16:13:49.018]                           version <- ns[[".package"]][["version"]]
[16:13:49.018]                           if (is.null(version)) 
[16:13:49.018]                             version <- utils::packageVersion("future")
[16:13:49.018]                         }
[16:13:49.018]                         else {
[16:13:49.018]                           version <- NULL
[16:13:49.018]                         }
[16:13:49.018]                         if (!has_future || version < "1.8.0") {
[16:13:49.018]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:49.018]                             "", base::R.version$version.string), 
[16:13:49.018]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:49.018]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:49.018]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:49.018]                               "release", "version")], collapse = " "), 
[16:13:49.018]                             hostname = base::Sys.info()[["nodename"]])
[16:13:49.018]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:49.018]                             info)
[16:13:49.018]                           info <- base::paste(info, collapse = "; ")
[16:13:49.018]                           if (!has_future) {
[16:13:49.018]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:49.018]                               info)
[16:13:49.018]                           }
[16:13:49.018]                           else {
[16:13:49.018]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:49.018]                               info, version)
[16:13:49.018]                           }
[16:13:49.018]                           base::stop(msg)
[16:13:49.018]                         }
[16:13:49.018]                       })
[16:13:49.018]                     }
[16:13:49.018]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:49.018]                     base::options(mc.cores = 1L)
[16:13:49.018]                   }
[16:13:49.018]                   options(future.plan = NULL)
[16:13:49.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:49.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:49.018]                 }
[16:13:49.018]                 ...future.workdir <- getwd()
[16:13:49.018]             }
[16:13:49.018]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:49.018]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:49.018]         }
[16:13:49.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:49.018]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:49.018]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:49.018]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:49.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:49.018]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:49.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:49.018]             base::names(...future.oldOptions))
[16:13:49.018]     }
[16:13:49.018]     if (FALSE) {
[16:13:49.018]     }
[16:13:49.018]     else {
[16:13:49.018]         if (TRUE) {
[16:13:49.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:49.018]                 open = "w")
[16:13:49.018]         }
[16:13:49.018]         else {
[16:13:49.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:49.018]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:49.018]         }
[16:13:49.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:49.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:49.018]             base::sink(type = "output", split = FALSE)
[16:13:49.018]             base::close(...future.stdout)
[16:13:49.018]         }, add = TRUE)
[16:13:49.018]     }
[16:13:49.018]     ...future.frame <- base::sys.nframe()
[16:13:49.018]     ...future.conditions <- base::list()
[16:13:49.018]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:49.018]     if (FALSE) {
[16:13:49.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:49.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:49.018]     }
[16:13:49.018]     ...future.result <- base::tryCatch({
[16:13:49.018]         base::withCallingHandlers({
[16:13:49.018]             ...future.value <- base::withVisible(base::local({
[16:13:49.018]                 ...future.makeSendCondition <- local({
[16:13:49.018]                   sendCondition <- NULL
[16:13:49.018]                   function(frame = 1L) {
[16:13:49.018]                     if (is.function(sendCondition)) 
[16:13:49.018]                       return(sendCondition)
[16:13:49.018]                     ns <- getNamespace("parallel")
[16:13:49.018]                     if (exists("sendData", mode = "function", 
[16:13:49.018]                       envir = ns)) {
[16:13:49.018]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:49.018]                         envir = ns)
[16:13:49.018]                       envir <- sys.frame(frame)
[16:13:49.018]                       master <- NULL
[16:13:49.018]                       while (!identical(envir, .GlobalEnv) && 
[16:13:49.018]                         !identical(envir, emptyenv())) {
[16:13:49.018]                         if (exists("master", mode = "list", envir = envir, 
[16:13:49.018]                           inherits = FALSE)) {
[16:13:49.018]                           master <- get("master", mode = "list", 
[16:13:49.018]                             envir = envir, inherits = FALSE)
[16:13:49.018]                           if (inherits(master, c("SOCKnode", 
[16:13:49.018]                             "SOCK0node"))) {
[16:13:49.018]                             sendCondition <<- function(cond) {
[16:13:49.018]                               data <- list(type = "VALUE", value = cond, 
[16:13:49.018]                                 success = TRUE)
[16:13:49.018]                               parallel_sendData(master, data)
[16:13:49.018]                             }
[16:13:49.018]                             return(sendCondition)
[16:13:49.018]                           }
[16:13:49.018]                         }
[16:13:49.018]                         frame <- frame + 1L
[16:13:49.018]                         envir <- sys.frame(frame)
[16:13:49.018]                       }
[16:13:49.018]                     }
[16:13:49.018]                     sendCondition <<- function(cond) NULL
[16:13:49.018]                   }
[16:13:49.018]                 })
[16:13:49.018]                 withCallingHandlers({
[16:13:49.018]                   {
[16:13:49.018]                     Sys.sleep(0.5)
[16:13:49.018]                     list(a = 1, b = 42L)
[16:13:49.018]                   }
[16:13:49.018]                 }, immediateCondition = function(cond) {
[16:13:49.018]                   sendCondition <- ...future.makeSendCondition()
[16:13:49.018]                   sendCondition(cond)
[16:13:49.018]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:49.018]                   {
[16:13:49.018]                     inherits <- base::inherits
[16:13:49.018]                     invokeRestart <- base::invokeRestart
[16:13:49.018]                     is.null <- base::is.null
[16:13:49.018]                     muffled <- FALSE
[16:13:49.018]                     if (inherits(cond, "message")) {
[16:13:49.018]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:49.018]                       if (muffled) 
[16:13:49.018]                         invokeRestart("muffleMessage")
[16:13:49.018]                     }
[16:13:49.018]                     else if (inherits(cond, "warning")) {
[16:13:49.018]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:49.018]                       if (muffled) 
[16:13:49.018]                         invokeRestart("muffleWarning")
[16:13:49.018]                     }
[16:13:49.018]                     else if (inherits(cond, "condition")) {
[16:13:49.018]                       if (!is.null(pattern)) {
[16:13:49.018]                         computeRestarts <- base::computeRestarts
[16:13:49.018]                         grepl <- base::grepl
[16:13:49.018]                         restarts <- computeRestarts(cond)
[16:13:49.018]                         for (restart in restarts) {
[16:13:49.018]                           name <- restart$name
[16:13:49.018]                           if (is.null(name)) 
[16:13:49.018]                             next
[16:13:49.018]                           if (!grepl(pattern, name)) 
[16:13:49.018]                             next
[16:13:49.018]                           invokeRestart(restart)
[16:13:49.018]                           muffled <- TRUE
[16:13:49.018]                           break
[16:13:49.018]                         }
[16:13:49.018]                       }
[16:13:49.018]                     }
[16:13:49.018]                     invisible(muffled)
[16:13:49.018]                   }
[16:13:49.018]                   muffleCondition(cond)
[16:13:49.018]                 })
[16:13:49.018]             }))
[16:13:49.018]             future::FutureResult(value = ...future.value$value, 
[16:13:49.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:49.018]                   ...future.rng), globalenv = if (FALSE) 
[16:13:49.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:49.018]                     ...future.globalenv.names))
[16:13:49.018]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:49.018]         }, condition = base::local({
[16:13:49.018]             c <- base::c
[16:13:49.018]             inherits <- base::inherits
[16:13:49.018]             invokeRestart <- base::invokeRestart
[16:13:49.018]             length <- base::length
[16:13:49.018]             list <- base::list
[16:13:49.018]             seq.int <- base::seq.int
[16:13:49.018]             signalCondition <- base::signalCondition
[16:13:49.018]             sys.calls <- base::sys.calls
[16:13:49.018]             `[[` <- base::`[[`
[16:13:49.018]             `+` <- base::`+`
[16:13:49.018]             `<<-` <- base::`<<-`
[16:13:49.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:49.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:49.018]                   3L)]
[16:13:49.018]             }
[16:13:49.018]             function(cond) {
[16:13:49.018]                 is_error <- inherits(cond, "error")
[16:13:49.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:49.018]                   NULL)
[16:13:49.018]                 if (is_error) {
[16:13:49.018]                   sessionInformation <- function() {
[16:13:49.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:49.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:49.018]                       search = base::search(), system = base::Sys.info())
[16:13:49.018]                   }
[16:13:49.018]                   ...future.conditions[[length(...future.conditions) + 
[16:13:49.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:49.018]                     cond$call), session = sessionInformation(), 
[16:13:49.018]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:49.018]                   signalCondition(cond)
[16:13:49.018]                 }
[16:13:49.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:49.018]                 "immediateCondition"))) {
[16:13:49.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:49.018]                   ...future.conditions[[length(...future.conditions) + 
[16:13:49.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:49.018]                   if (TRUE && !signal) {
[16:13:49.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:49.018]                     {
[16:13:49.018]                       inherits <- base::inherits
[16:13:49.018]                       invokeRestart <- base::invokeRestart
[16:13:49.018]                       is.null <- base::is.null
[16:13:49.018]                       muffled <- FALSE
[16:13:49.018]                       if (inherits(cond, "message")) {
[16:13:49.018]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:49.018]                         if (muffled) 
[16:13:49.018]                           invokeRestart("muffleMessage")
[16:13:49.018]                       }
[16:13:49.018]                       else if (inherits(cond, "warning")) {
[16:13:49.018]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:49.018]                         if (muffled) 
[16:13:49.018]                           invokeRestart("muffleWarning")
[16:13:49.018]                       }
[16:13:49.018]                       else if (inherits(cond, "condition")) {
[16:13:49.018]                         if (!is.null(pattern)) {
[16:13:49.018]                           computeRestarts <- base::computeRestarts
[16:13:49.018]                           grepl <- base::grepl
[16:13:49.018]                           restarts <- computeRestarts(cond)
[16:13:49.018]                           for (restart in restarts) {
[16:13:49.018]                             name <- restart$name
[16:13:49.018]                             if (is.null(name)) 
[16:13:49.018]                               next
[16:13:49.018]                             if (!grepl(pattern, name)) 
[16:13:49.018]                               next
[16:13:49.018]                             invokeRestart(restart)
[16:13:49.018]                             muffled <- TRUE
[16:13:49.018]                             break
[16:13:49.018]                           }
[16:13:49.018]                         }
[16:13:49.018]                       }
[16:13:49.018]                       invisible(muffled)
[16:13:49.018]                     }
[16:13:49.018]                     muffleCondition(cond, pattern = "^muffle")
[16:13:49.018]                   }
[16:13:49.018]                 }
[16:13:49.018]                 else {
[16:13:49.018]                   if (TRUE) {
[16:13:49.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:49.018]                     {
[16:13:49.018]                       inherits <- base::inherits
[16:13:49.018]                       invokeRestart <- base::invokeRestart
[16:13:49.018]                       is.null <- base::is.null
[16:13:49.018]                       muffled <- FALSE
[16:13:49.018]                       if (inherits(cond, "message")) {
[16:13:49.018]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:49.018]                         if (muffled) 
[16:13:49.018]                           invokeRestart("muffleMessage")
[16:13:49.018]                       }
[16:13:49.018]                       else if (inherits(cond, "warning")) {
[16:13:49.018]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:49.018]                         if (muffled) 
[16:13:49.018]                           invokeRestart("muffleWarning")
[16:13:49.018]                       }
[16:13:49.018]                       else if (inherits(cond, "condition")) {
[16:13:49.018]                         if (!is.null(pattern)) {
[16:13:49.018]                           computeRestarts <- base::computeRestarts
[16:13:49.018]                           grepl <- base::grepl
[16:13:49.018]                           restarts <- computeRestarts(cond)
[16:13:49.018]                           for (restart in restarts) {
[16:13:49.018]                             name <- restart$name
[16:13:49.018]                             if (is.null(name)) 
[16:13:49.018]                               next
[16:13:49.018]                             if (!grepl(pattern, name)) 
[16:13:49.018]                               next
[16:13:49.018]                             invokeRestart(restart)
[16:13:49.018]                             muffled <- TRUE
[16:13:49.018]                             break
[16:13:49.018]                           }
[16:13:49.018]                         }
[16:13:49.018]                       }
[16:13:49.018]                       invisible(muffled)
[16:13:49.018]                     }
[16:13:49.018]                     muffleCondition(cond, pattern = "^muffle")
[16:13:49.018]                   }
[16:13:49.018]                 }
[16:13:49.018]             }
[16:13:49.018]         }))
[16:13:49.018]     }, error = function(ex) {
[16:13:49.018]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:49.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:49.018]                 ...future.rng), started = ...future.startTime, 
[16:13:49.018]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:49.018]             version = "1.8"), class = "FutureResult")
[16:13:49.018]     }, finally = {
[16:13:49.018]         if (!identical(...future.workdir, getwd())) 
[16:13:49.018]             setwd(...future.workdir)
[16:13:49.018]         {
[16:13:49.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:49.018]                 ...future.oldOptions$nwarnings <- NULL
[16:13:49.018]             }
[16:13:49.018]             base::options(...future.oldOptions)
[16:13:49.018]             if (.Platform$OS.type == "windows") {
[16:13:49.018]                 old_names <- names(...future.oldEnvVars)
[16:13:49.018]                 envs <- base::Sys.getenv()
[16:13:49.018]                 names <- names(envs)
[16:13:49.018]                 common <- intersect(names, old_names)
[16:13:49.018]                 added <- setdiff(names, old_names)
[16:13:49.018]                 removed <- setdiff(old_names, names)
[16:13:49.018]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:49.018]                   envs[common]]
[16:13:49.018]                 NAMES <- toupper(changed)
[16:13:49.018]                 args <- list()
[16:13:49.018]                 for (kk in seq_along(NAMES)) {
[16:13:49.018]                   name <- changed[[kk]]
[16:13:49.018]                   NAME <- NAMES[[kk]]
[16:13:49.018]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:49.018]                     next
[16:13:49.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:49.018]                 }
[16:13:49.018]                 NAMES <- toupper(added)
[16:13:49.018]                 for (kk in seq_along(NAMES)) {
[16:13:49.018]                   name <- added[[kk]]
[16:13:49.018]                   NAME <- NAMES[[kk]]
[16:13:49.018]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:49.018]                     next
[16:13:49.018]                   args[[name]] <- ""
[16:13:49.018]                 }
[16:13:49.018]                 NAMES <- toupper(removed)
[16:13:49.018]                 for (kk in seq_along(NAMES)) {
[16:13:49.018]                   name <- removed[[kk]]
[16:13:49.018]                   NAME <- NAMES[[kk]]
[16:13:49.018]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:49.018]                     next
[16:13:49.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:49.018]                 }
[16:13:49.018]                 if (length(args) > 0) 
[16:13:49.018]                   base::do.call(base::Sys.setenv, args = args)
[16:13:49.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:49.018]             }
[16:13:49.018]             else {
[16:13:49.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:49.018]             }
[16:13:49.018]             {
[16:13:49.018]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:49.018]                   0L) {
[16:13:49.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:49.018]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:49.018]                   base::options(opts)
[16:13:49.018]                 }
[16:13:49.018]                 {
[16:13:49.018]                   {
[16:13:49.018]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:49.018]                     NULL
[16:13:49.018]                   }
[16:13:49.018]                   options(future.plan = NULL)
[16:13:49.018]                   if (is.na(NA_character_)) 
[16:13:49.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:49.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:49.018]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:49.018]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:49.018]                     envir = parent.frame()) 
[16:13:49.018]                   {
[16:13:49.018]                     if (is.function(workers)) 
[16:13:49.018]                       workers <- workers()
[16:13:49.018]                     workers <- structure(as.integer(workers), 
[16:13:49.018]                       class = class(workers))
[16:13:49.018]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:49.018]                       workers >= 1)
[16:13:49.018]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:49.018]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:49.018]                     }
[16:13:49.018]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:49.018]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:49.018]                       envir = envir)
[16:13:49.018]                     if (!future$lazy) 
[16:13:49.018]                       future <- run(future)
[16:13:49.018]                     invisible(future)
[16:13:49.018]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:49.018]                 }
[16:13:49.018]             }
[16:13:49.018]         }
[16:13:49.018]     })
[16:13:49.018]     if (TRUE) {
[16:13:49.018]         base::sink(type = "output", split = FALSE)
[16:13:49.018]         if (TRUE) {
[16:13:49.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:49.018]         }
[16:13:49.018]         else {
[16:13:49.018]             ...future.result["stdout"] <- base::list(NULL)
[16:13:49.018]         }
[16:13:49.018]         base::close(...future.stdout)
[16:13:49.018]         ...future.stdout <- NULL
[16:13:49.018]     }
[16:13:49.018]     ...future.result$conditions <- ...future.conditions
[16:13:49.018]     ...future.result$finished <- base::Sys.time()
[16:13:49.018]     ...future.result
[16:13:49.018] }
[16:13:49.021] MultisessionFuture started
[16:13:49.021] - Launch lazy future ... done
[16:13:49.021] run() for ‘MultisessionFuture’ ... done
[16:13:49.578] receiveMessageFromWorker() for ClusterFuture ...
[16:13:49.578] - Validating connection of MultisessionFuture
[16:13:49.579] - received message: FutureResult
[16:13:49.579] - Received FutureResult
[16:13:49.579] - Erased future from FutureRegistry
[16:13:49.579] result() for ClusterFuture ...
[16:13:49.579] - result already collected: FutureResult
[16:13:49.579] result() for ClusterFuture ... done
[16:13:49.579] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:49.579] A MultisessionFuture was resolved (result was not collected)
[16:13:49.579] getGlobalsAndPackages() ...
[16:13:49.580] Searching for globals...
[16:13:49.581] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:49.581] Searching for globals ... DONE
[16:13:49.581] Resolving globals: FALSE
[16:13:49.581] 
[16:13:49.581] 
[16:13:49.582] getGlobalsAndPackages() ... DONE
[16:13:49.582] run() for ‘Future’ ...
[16:13:49.582] - state: ‘created’
[16:13:49.582] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:49.596] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:49.597] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:49.597]   - Field: ‘node’
[16:13:49.597]   - Field: ‘label’
[16:13:49.597]   - Field: ‘local’
[16:13:49.597]   - Field: ‘owner’
[16:13:49.597]   - Field: ‘envir’
[16:13:49.597]   - Field: ‘workers’
[16:13:49.597]   - Field: ‘packages’
[16:13:49.597]   - Field: ‘gc’
[16:13:49.597]   - Field: ‘conditions’
[16:13:49.598]   - Field: ‘persistent’
[16:13:49.598]   - Field: ‘expr’
[16:13:49.598]   - Field: ‘uuid’
[16:13:49.598]   - Field: ‘seed’
[16:13:49.598]   - Field: ‘version’
[16:13:49.598]   - Field: ‘result’
[16:13:49.598]   - Field: ‘asynchronous’
[16:13:49.598]   - Field: ‘calls’
[16:13:49.598]   - Field: ‘globals’
[16:13:49.598]   - Field: ‘stdout’
[16:13:49.598]   - Field: ‘earlySignal’
[16:13:49.598]   - Field: ‘lazy’
[16:13:49.599]   - Field: ‘state’
[16:13:49.599] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:49.599] - Launch lazy future ...
[16:13:49.599] Packages needed by the future expression (n = 0): <none>
[16:13:49.599] Packages needed by future strategies (n = 0): <none>
[16:13:49.600] {
[16:13:49.600]     {
[16:13:49.600]         {
[16:13:49.600]             ...future.startTime <- base::Sys.time()
[16:13:49.600]             {
[16:13:49.600]                 {
[16:13:49.600]                   {
[16:13:49.600]                     {
[16:13:49.600]                       base::local({
[16:13:49.600]                         has_future <- base::requireNamespace("future", 
[16:13:49.600]                           quietly = TRUE)
[16:13:49.600]                         if (has_future) {
[16:13:49.600]                           ns <- base::getNamespace("future")
[16:13:49.600]                           version <- ns[[".package"]][["version"]]
[16:13:49.600]                           if (is.null(version)) 
[16:13:49.600]                             version <- utils::packageVersion("future")
[16:13:49.600]                         }
[16:13:49.600]                         else {
[16:13:49.600]                           version <- NULL
[16:13:49.600]                         }
[16:13:49.600]                         if (!has_future || version < "1.8.0") {
[16:13:49.600]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:49.600]                             "", base::R.version$version.string), 
[16:13:49.600]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:49.600]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:49.600]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:49.600]                               "release", "version")], collapse = " "), 
[16:13:49.600]                             hostname = base::Sys.info()[["nodename"]])
[16:13:49.600]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:49.600]                             info)
[16:13:49.600]                           info <- base::paste(info, collapse = "; ")
[16:13:49.600]                           if (!has_future) {
[16:13:49.600]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:49.600]                               info)
[16:13:49.600]                           }
[16:13:49.600]                           else {
[16:13:49.600]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:49.600]                               info, version)
[16:13:49.600]                           }
[16:13:49.600]                           base::stop(msg)
[16:13:49.600]                         }
[16:13:49.600]                       })
[16:13:49.600]                     }
[16:13:49.600]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:49.600]                     base::options(mc.cores = 1L)
[16:13:49.600]                   }
[16:13:49.600]                   options(future.plan = NULL)
[16:13:49.600]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:49.600]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:49.600]                 }
[16:13:49.600]                 ...future.workdir <- getwd()
[16:13:49.600]             }
[16:13:49.600]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:49.600]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:49.600]         }
[16:13:49.600]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:49.600]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:49.600]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:49.600]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:49.600]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:49.600]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:49.600]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:49.600]             base::names(...future.oldOptions))
[16:13:49.600]     }
[16:13:49.600]     if (FALSE) {
[16:13:49.600]     }
[16:13:49.600]     else {
[16:13:49.600]         if (TRUE) {
[16:13:49.600]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:49.600]                 open = "w")
[16:13:49.600]         }
[16:13:49.600]         else {
[16:13:49.600]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:49.600]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:49.600]         }
[16:13:49.600]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:49.600]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:49.600]             base::sink(type = "output", split = FALSE)
[16:13:49.600]             base::close(...future.stdout)
[16:13:49.600]         }, add = TRUE)
[16:13:49.600]     }
[16:13:49.600]     ...future.frame <- base::sys.nframe()
[16:13:49.600]     ...future.conditions <- base::list()
[16:13:49.600]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:49.600]     if (FALSE) {
[16:13:49.600]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:49.600]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:49.600]     }
[16:13:49.600]     ...future.result <- base::tryCatch({
[16:13:49.600]         base::withCallingHandlers({
[16:13:49.600]             ...future.value <- base::withVisible(base::local({
[16:13:49.600]                 ...future.makeSendCondition <- local({
[16:13:49.600]                   sendCondition <- NULL
[16:13:49.600]                   function(frame = 1L) {
[16:13:49.600]                     if (is.function(sendCondition)) 
[16:13:49.600]                       return(sendCondition)
[16:13:49.600]                     ns <- getNamespace("parallel")
[16:13:49.600]                     if (exists("sendData", mode = "function", 
[16:13:49.600]                       envir = ns)) {
[16:13:49.600]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:49.600]                         envir = ns)
[16:13:49.600]                       envir <- sys.frame(frame)
[16:13:49.600]                       master <- NULL
[16:13:49.600]                       while (!identical(envir, .GlobalEnv) && 
[16:13:49.600]                         !identical(envir, emptyenv())) {
[16:13:49.600]                         if (exists("master", mode = "list", envir = envir, 
[16:13:49.600]                           inherits = FALSE)) {
[16:13:49.600]                           master <- get("master", mode = "list", 
[16:13:49.600]                             envir = envir, inherits = FALSE)
[16:13:49.600]                           if (inherits(master, c("SOCKnode", 
[16:13:49.600]                             "SOCK0node"))) {
[16:13:49.600]                             sendCondition <<- function(cond) {
[16:13:49.600]                               data <- list(type = "VALUE", value = cond, 
[16:13:49.600]                                 success = TRUE)
[16:13:49.600]                               parallel_sendData(master, data)
[16:13:49.600]                             }
[16:13:49.600]                             return(sendCondition)
[16:13:49.600]                           }
[16:13:49.600]                         }
[16:13:49.600]                         frame <- frame + 1L
[16:13:49.600]                         envir <- sys.frame(frame)
[16:13:49.600]                       }
[16:13:49.600]                     }
[16:13:49.600]                     sendCondition <<- function(cond) NULL
[16:13:49.600]                   }
[16:13:49.600]                 })
[16:13:49.600]                 withCallingHandlers({
[16:13:49.600]                   {
[16:13:49.600]                     Sys.sleep(0.5)
[16:13:49.600]                     list(a = 1, b = 42L)
[16:13:49.600]                   }
[16:13:49.600]                 }, immediateCondition = function(cond) {
[16:13:49.600]                   sendCondition <- ...future.makeSendCondition()
[16:13:49.600]                   sendCondition(cond)
[16:13:49.600]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:49.600]                   {
[16:13:49.600]                     inherits <- base::inherits
[16:13:49.600]                     invokeRestart <- base::invokeRestart
[16:13:49.600]                     is.null <- base::is.null
[16:13:49.600]                     muffled <- FALSE
[16:13:49.600]                     if (inherits(cond, "message")) {
[16:13:49.600]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:49.600]                       if (muffled) 
[16:13:49.600]                         invokeRestart("muffleMessage")
[16:13:49.600]                     }
[16:13:49.600]                     else if (inherits(cond, "warning")) {
[16:13:49.600]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:49.600]                       if (muffled) 
[16:13:49.600]                         invokeRestart("muffleWarning")
[16:13:49.600]                     }
[16:13:49.600]                     else if (inherits(cond, "condition")) {
[16:13:49.600]                       if (!is.null(pattern)) {
[16:13:49.600]                         computeRestarts <- base::computeRestarts
[16:13:49.600]                         grepl <- base::grepl
[16:13:49.600]                         restarts <- computeRestarts(cond)
[16:13:49.600]                         for (restart in restarts) {
[16:13:49.600]                           name <- restart$name
[16:13:49.600]                           if (is.null(name)) 
[16:13:49.600]                             next
[16:13:49.600]                           if (!grepl(pattern, name)) 
[16:13:49.600]                             next
[16:13:49.600]                           invokeRestart(restart)
[16:13:49.600]                           muffled <- TRUE
[16:13:49.600]                           break
[16:13:49.600]                         }
[16:13:49.600]                       }
[16:13:49.600]                     }
[16:13:49.600]                     invisible(muffled)
[16:13:49.600]                   }
[16:13:49.600]                   muffleCondition(cond)
[16:13:49.600]                 })
[16:13:49.600]             }))
[16:13:49.600]             future::FutureResult(value = ...future.value$value, 
[16:13:49.600]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:49.600]                   ...future.rng), globalenv = if (FALSE) 
[16:13:49.600]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:49.600]                     ...future.globalenv.names))
[16:13:49.600]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:49.600]         }, condition = base::local({
[16:13:49.600]             c <- base::c
[16:13:49.600]             inherits <- base::inherits
[16:13:49.600]             invokeRestart <- base::invokeRestart
[16:13:49.600]             length <- base::length
[16:13:49.600]             list <- base::list
[16:13:49.600]             seq.int <- base::seq.int
[16:13:49.600]             signalCondition <- base::signalCondition
[16:13:49.600]             sys.calls <- base::sys.calls
[16:13:49.600]             `[[` <- base::`[[`
[16:13:49.600]             `+` <- base::`+`
[16:13:49.600]             `<<-` <- base::`<<-`
[16:13:49.600]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:49.600]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:49.600]                   3L)]
[16:13:49.600]             }
[16:13:49.600]             function(cond) {
[16:13:49.600]                 is_error <- inherits(cond, "error")
[16:13:49.600]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:49.600]                   NULL)
[16:13:49.600]                 if (is_error) {
[16:13:49.600]                   sessionInformation <- function() {
[16:13:49.600]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:49.600]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:49.600]                       search = base::search(), system = base::Sys.info())
[16:13:49.600]                   }
[16:13:49.600]                   ...future.conditions[[length(...future.conditions) + 
[16:13:49.600]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:49.600]                     cond$call), session = sessionInformation(), 
[16:13:49.600]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:49.600]                   signalCondition(cond)
[16:13:49.600]                 }
[16:13:49.600]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:49.600]                 "immediateCondition"))) {
[16:13:49.600]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:49.600]                   ...future.conditions[[length(...future.conditions) + 
[16:13:49.600]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:49.600]                   if (TRUE && !signal) {
[16:13:49.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:49.600]                     {
[16:13:49.600]                       inherits <- base::inherits
[16:13:49.600]                       invokeRestart <- base::invokeRestart
[16:13:49.600]                       is.null <- base::is.null
[16:13:49.600]                       muffled <- FALSE
[16:13:49.600]                       if (inherits(cond, "message")) {
[16:13:49.600]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:49.600]                         if (muffled) 
[16:13:49.600]                           invokeRestart("muffleMessage")
[16:13:49.600]                       }
[16:13:49.600]                       else if (inherits(cond, "warning")) {
[16:13:49.600]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:49.600]                         if (muffled) 
[16:13:49.600]                           invokeRestart("muffleWarning")
[16:13:49.600]                       }
[16:13:49.600]                       else if (inherits(cond, "condition")) {
[16:13:49.600]                         if (!is.null(pattern)) {
[16:13:49.600]                           computeRestarts <- base::computeRestarts
[16:13:49.600]                           grepl <- base::grepl
[16:13:49.600]                           restarts <- computeRestarts(cond)
[16:13:49.600]                           for (restart in restarts) {
[16:13:49.600]                             name <- restart$name
[16:13:49.600]                             if (is.null(name)) 
[16:13:49.600]                               next
[16:13:49.600]                             if (!grepl(pattern, name)) 
[16:13:49.600]                               next
[16:13:49.600]                             invokeRestart(restart)
[16:13:49.600]                             muffled <- TRUE
[16:13:49.600]                             break
[16:13:49.600]                           }
[16:13:49.600]                         }
[16:13:49.600]                       }
[16:13:49.600]                       invisible(muffled)
[16:13:49.600]                     }
[16:13:49.600]                     muffleCondition(cond, pattern = "^muffle")
[16:13:49.600]                   }
[16:13:49.600]                 }
[16:13:49.600]                 else {
[16:13:49.600]                   if (TRUE) {
[16:13:49.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:49.600]                     {
[16:13:49.600]                       inherits <- base::inherits
[16:13:49.600]                       invokeRestart <- base::invokeRestart
[16:13:49.600]                       is.null <- base::is.null
[16:13:49.600]                       muffled <- FALSE
[16:13:49.600]                       if (inherits(cond, "message")) {
[16:13:49.600]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:49.600]                         if (muffled) 
[16:13:49.600]                           invokeRestart("muffleMessage")
[16:13:49.600]                       }
[16:13:49.600]                       else if (inherits(cond, "warning")) {
[16:13:49.600]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:49.600]                         if (muffled) 
[16:13:49.600]                           invokeRestart("muffleWarning")
[16:13:49.600]                       }
[16:13:49.600]                       else if (inherits(cond, "condition")) {
[16:13:49.600]                         if (!is.null(pattern)) {
[16:13:49.600]                           computeRestarts <- base::computeRestarts
[16:13:49.600]                           grepl <- base::grepl
[16:13:49.600]                           restarts <- computeRestarts(cond)
[16:13:49.600]                           for (restart in restarts) {
[16:13:49.600]                             name <- restart$name
[16:13:49.600]                             if (is.null(name)) 
[16:13:49.600]                               next
[16:13:49.600]                             if (!grepl(pattern, name)) 
[16:13:49.600]                               next
[16:13:49.600]                             invokeRestart(restart)
[16:13:49.600]                             muffled <- TRUE
[16:13:49.600]                             break
[16:13:49.600]                           }
[16:13:49.600]                         }
[16:13:49.600]                       }
[16:13:49.600]                       invisible(muffled)
[16:13:49.600]                     }
[16:13:49.600]                     muffleCondition(cond, pattern = "^muffle")
[16:13:49.600]                   }
[16:13:49.600]                 }
[16:13:49.600]             }
[16:13:49.600]         }))
[16:13:49.600]     }, error = function(ex) {
[16:13:49.600]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:49.600]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:49.600]                 ...future.rng), started = ...future.startTime, 
[16:13:49.600]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:49.600]             version = "1.8"), class = "FutureResult")
[16:13:49.600]     }, finally = {
[16:13:49.600]         if (!identical(...future.workdir, getwd())) 
[16:13:49.600]             setwd(...future.workdir)
[16:13:49.600]         {
[16:13:49.600]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:49.600]                 ...future.oldOptions$nwarnings <- NULL
[16:13:49.600]             }
[16:13:49.600]             base::options(...future.oldOptions)
[16:13:49.600]             if (.Platform$OS.type == "windows") {
[16:13:49.600]                 old_names <- names(...future.oldEnvVars)
[16:13:49.600]                 envs <- base::Sys.getenv()
[16:13:49.600]                 names <- names(envs)
[16:13:49.600]                 common <- intersect(names, old_names)
[16:13:49.600]                 added <- setdiff(names, old_names)
[16:13:49.600]                 removed <- setdiff(old_names, names)
[16:13:49.600]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:49.600]                   envs[common]]
[16:13:49.600]                 NAMES <- toupper(changed)
[16:13:49.600]                 args <- list()
[16:13:49.600]                 for (kk in seq_along(NAMES)) {
[16:13:49.600]                   name <- changed[[kk]]
[16:13:49.600]                   NAME <- NAMES[[kk]]
[16:13:49.600]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:49.600]                     next
[16:13:49.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:49.600]                 }
[16:13:49.600]                 NAMES <- toupper(added)
[16:13:49.600]                 for (kk in seq_along(NAMES)) {
[16:13:49.600]                   name <- added[[kk]]
[16:13:49.600]                   NAME <- NAMES[[kk]]
[16:13:49.600]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:49.600]                     next
[16:13:49.600]                   args[[name]] <- ""
[16:13:49.600]                 }
[16:13:49.600]                 NAMES <- toupper(removed)
[16:13:49.600]                 for (kk in seq_along(NAMES)) {
[16:13:49.600]                   name <- removed[[kk]]
[16:13:49.600]                   NAME <- NAMES[[kk]]
[16:13:49.600]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:49.600]                     next
[16:13:49.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:49.600]                 }
[16:13:49.600]                 if (length(args) > 0) 
[16:13:49.600]                   base::do.call(base::Sys.setenv, args = args)
[16:13:49.600]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:49.600]             }
[16:13:49.600]             else {
[16:13:49.600]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:49.600]             }
[16:13:49.600]             {
[16:13:49.600]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:49.600]                   0L) {
[16:13:49.600]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:49.600]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:49.600]                   base::options(opts)
[16:13:49.600]                 }
[16:13:49.600]                 {
[16:13:49.600]                   {
[16:13:49.600]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:49.600]                     NULL
[16:13:49.600]                   }
[16:13:49.600]                   options(future.plan = NULL)
[16:13:49.600]                   if (is.na(NA_character_)) 
[16:13:49.600]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:49.600]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:49.600]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:49.600]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:49.600]                     envir = parent.frame()) 
[16:13:49.600]                   {
[16:13:49.600]                     if (is.function(workers)) 
[16:13:49.600]                       workers <- workers()
[16:13:49.600]                     workers <- structure(as.integer(workers), 
[16:13:49.600]                       class = class(workers))
[16:13:49.600]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:49.600]                       workers >= 1)
[16:13:49.600]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:49.600]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:49.600]                     }
[16:13:49.600]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:49.600]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:49.600]                       envir = envir)
[16:13:49.600]                     if (!future$lazy) 
[16:13:49.600]                       future <- run(future)
[16:13:49.600]                     invisible(future)
[16:13:49.600]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:49.600]                 }
[16:13:49.600]             }
[16:13:49.600]         }
[16:13:49.600]     })
[16:13:49.600]     if (TRUE) {
[16:13:49.600]         base::sink(type = "output", split = FALSE)
[16:13:49.600]         if (TRUE) {
[16:13:49.600]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:49.600]         }
[16:13:49.600]         else {
[16:13:49.600]             ...future.result["stdout"] <- base::list(NULL)
[16:13:49.600]         }
[16:13:49.600]         base::close(...future.stdout)
[16:13:49.600]         ...future.stdout <- NULL
[16:13:49.600]     }
[16:13:49.600]     ...future.result$conditions <- ...future.conditions
[16:13:49.600]     ...future.result$finished <- base::Sys.time()
[16:13:49.600]     ...future.result
[16:13:49.600] }
[16:13:49.603] MultisessionFuture started
[16:13:49.603] - Launch lazy future ... done
[16:13:49.603] run() for ‘MultisessionFuture’ ... done
[16:13:50.150] receiveMessageFromWorker() for ClusterFuture ...
[16:13:50.150] - Validating connection of MultisessionFuture
[16:13:50.150] - received message: FutureResult
[16:13:50.150] - Received FutureResult
[16:13:50.150] - Erased future from FutureRegistry
[16:13:50.151] result() for ClusterFuture ...
[16:13:50.151] - result already collected: FutureResult
[16:13:50.151] result() for ClusterFuture ... done
[16:13:50.151] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:50.151] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[16:13:50.151] getGlobalsAndPackages() ...
[16:13:50.151] Searching for globals...
[16:13:50.152] - globals found: [2] ‘list’, ‘stop’
[16:13:50.152] Searching for globals ... DONE
[16:13:50.152] Resolving globals: FALSE
[16:13:50.153] 
[16:13:50.153] 
[16:13:50.153] getGlobalsAndPackages() ... DONE
[16:13:50.153] run() for ‘Future’ ...
[16:13:50.153] - state: ‘created’
[16:13:50.153] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:50.168] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:50.168] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:50.168]   - Field: ‘node’
[16:13:50.168]   - Field: ‘label’
[16:13:50.168]   - Field: ‘local’
[16:13:50.168]   - Field: ‘owner’
[16:13:50.168]   - Field: ‘envir’
[16:13:50.168]   - Field: ‘workers’
[16:13:50.168]   - Field: ‘packages’
[16:13:50.169]   - Field: ‘gc’
[16:13:50.169]   - Field: ‘conditions’
[16:13:50.169]   - Field: ‘persistent’
[16:13:50.169]   - Field: ‘expr’
[16:13:50.169]   - Field: ‘uuid’
[16:13:50.169]   - Field: ‘seed’
[16:13:50.169]   - Field: ‘version’
[16:13:50.169]   - Field: ‘result’
[16:13:50.169]   - Field: ‘asynchronous’
[16:13:50.169]   - Field: ‘calls’
[16:13:50.169]   - Field: ‘globals’
[16:13:50.170]   - Field: ‘stdout’
[16:13:50.170]   - Field: ‘earlySignal’
[16:13:50.170]   - Field: ‘lazy’
[16:13:50.170]   - Field: ‘state’
[16:13:50.170] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:50.170] - Launch lazy future ...
[16:13:50.170] Packages needed by the future expression (n = 0): <none>
[16:13:50.170] Packages needed by future strategies (n = 0): <none>
[16:13:50.171] {
[16:13:50.171]     {
[16:13:50.171]         {
[16:13:50.171]             ...future.startTime <- base::Sys.time()
[16:13:50.171]             {
[16:13:50.171]                 {
[16:13:50.171]                   {
[16:13:50.171]                     {
[16:13:50.171]                       base::local({
[16:13:50.171]                         has_future <- base::requireNamespace("future", 
[16:13:50.171]                           quietly = TRUE)
[16:13:50.171]                         if (has_future) {
[16:13:50.171]                           ns <- base::getNamespace("future")
[16:13:50.171]                           version <- ns[[".package"]][["version"]]
[16:13:50.171]                           if (is.null(version)) 
[16:13:50.171]                             version <- utils::packageVersion("future")
[16:13:50.171]                         }
[16:13:50.171]                         else {
[16:13:50.171]                           version <- NULL
[16:13:50.171]                         }
[16:13:50.171]                         if (!has_future || version < "1.8.0") {
[16:13:50.171]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:50.171]                             "", base::R.version$version.string), 
[16:13:50.171]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:50.171]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:50.171]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:50.171]                               "release", "version")], collapse = " "), 
[16:13:50.171]                             hostname = base::Sys.info()[["nodename"]])
[16:13:50.171]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:50.171]                             info)
[16:13:50.171]                           info <- base::paste(info, collapse = "; ")
[16:13:50.171]                           if (!has_future) {
[16:13:50.171]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:50.171]                               info)
[16:13:50.171]                           }
[16:13:50.171]                           else {
[16:13:50.171]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:50.171]                               info, version)
[16:13:50.171]                           }
[16:13:50.171]                           base::stop(msg)
[16:13:50.171]                         }
[16:13:50.171]                       })
[16:13:50.171]                     }
[16:13:50.171]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:50.171]                     base::options(mc.cores = 1L)
[16:13:50.171]                   }
[16:13:50.171]                   options(future.plan = NULL)
[16:13:50.171]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:50.171]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:50.171]                 }
[16:13:50.171]                 ...future.workdir <- getwd()
[16:13:50.171]             }
[16:13:50.171]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:50.171]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:50.171]         }
[16:13:50.171]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:50.171]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:50.171]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:50.171]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:50.171]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:50.171]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:50.171]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:50.171]             base::names(...future.oldOptions))
[16:13:50.171]     }
[16:13:50.171]     if (FALSE) {
[16:13:50.171]     }
[16:13:50.171]     else {
[16:13:50.171]         if (TRUE) {
[16:13:50.171]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:50.171]                 open = "w")
[16:13:50.171]         }
[16:13:50.171]         else {
[16:13:50.171]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:50.171]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:50.171]         }
[16:13:50.171]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:50.171]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:50.171]             base::sink(type = "output", split = FALSE)
[16:13:50.171]             base::close(...future.stdout)
[16:13:50.171]         }, add = TRUE)
[16:13:50.171]     }
[16:13:50.171]     ...future.frame <- base::sys.nframe()
[16:13:50.171]     ...future.conditions <- base::list()
[16:13:50.171]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:50.171]     if (FALSE) {
[16:13:50.171]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:50.171]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:50.171]     }
[16:13:50.171]     ...future.result <- base::tryCatch({
[16:13:50.171]         base::withCallingHandlers({
[16:13:50.171]             ...future.value <- base::withVisible(base::local({
[16:13:50.171]                 ...future.makeSendCondition <- local({
[16:13:50.171]                   sendCondition <- NULL
[16:13:50.171]                   function(frame = 1L) {
[16:13:50.171]                     if (is.function(sendCondition)) 
[16:13:50.171]                       return(sendCondition)
[16:13:50.171]                     ns <- getNamespace("parallel")
[16:13:50.171]                     if (exists("sendData", mode = "function", 
[16:13:50.171]                       envir = ns)) {
[16:13:50.171]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:50.171]                         envir = ns)
[16:13:50.171]                       envir <- sys.frame(frame)
[16:13:50.171]                       master <- NULL
[16:13:50.171]                       while (!identical(envir, .GlobalEnv) && 
[16:13:50.171]                         !identical(envir, emptyenv())) {
[16:13:50.171]                         if (exists("master", mode = "list", envir = envir, 
[16:13:50.171]                           inherits = FALSE)) {
[16:13:50.171]                           master <- get("master", mode = "list", 
[16:13:50.171]                             envir = envir, inherits = FALSE)
[16:13:50.171]                           if (inherits(master, c("SOCKnode", 
[16:13:50.171]                             "SOCK0node"))) {
[16:13:50.171]                             sendCondition <<- function(cond) {
[16:13:50.171]                               data <- list(type = "VALUE", value = cond, 
[16:13:50.171]                                 success = TRUE)
[16:13:50.171]                               parallel_sendData(master, data)
[16:13:50.171]                             }
[16:13:50.171]                             return(sendCondition)
[16:13:50.171]                           }
[16:13:50.171]                         }
[16:13:50.171]                         frame <- frame + 1L
[16:13:50.171]                         envir <- sys.frame(frame)
[16:13:50.171]                       }
[16:13:50.171]                     }
[16:13:50.171]                     sendCondition <<- function(cond) NULL
[16:13:50.171]                   }
[16:13:50.171]                 })
[16:13:50.171]                 withCallingHandlers({
[16:13:50.171]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:50.171]                 }, immediateCondition = function(cond) {
[16:13:50.171]                   sendCondition <- ...future.makeSendCondition()
[16:13:50.171]                   sendCondition(cond)
[16:13:50.171]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:50.171]                   {
[16:13:50.171]                     inherits <- base::inherits
[16:13:50.171]                     invokeRestart <- base::invokeRestart
[16:13:50.171]                     is.null <- base::is.null
[16:13:50.171]                     muffled <- FALSE
[16:13:50.171]                     if (inherits(cond, "message")) {
[16:13:50.171]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:50.171]                       if (muffled) 
[16:13:50.171]                         invokeRestart("muffleMessage")
[16:13:50.171]                     }
[16:13:50.171]                     else if (inherits(cond, "warning")) {
[16:13:50.171]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:50.171]                       if (muffled) 
[16:13:50.171]                         invokeRestart("muffleWarning")
[16:13:50.171]                     }
[16:13:50.171]                     else if (inherits(cond, "condition")) {
[16:13:50.171]                       if (!is.null(pattern)) {
[16:13:50.171]                         computeRestarts <- base::computeRestarts
[16:13:50.171]                         grepl <- base::grepl
[16:13:50.171]                         restarts <- computeRestarts(cond)
[16:13:50.171]                         for (restart in restarts) {
[16:13:50.171]                           name <- restart$name
[16:13:50.171]                           if (is.null(name)) 
[16:13:50.171]                             next
[16:13:50.171]                           if (!grepl(pattern, name)) 
[16:13:50.171]                             next
[16:13:50.171]                           invokeRestart(restart)
[16:13:50.171]                           muffled <- TRUE
[16:13:50.171]                           break
[16:13:50.171]                         }
[16:13:50.171]                       }
[16:13:50.171]                     }
[16:13:50.171]                     invisible(muffled)
[16:13:50.171]                   }
[16:13:50.171]                   muffleCondition(cond)
[16:13:50.171]                 })
[16:13:50.171]             }))
[16:13:50.171]             future::FutureResult(value = ...future.value$value, 
[16:13:50.171]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:50.171]                   ...future.rng), globalenv = if (FALSE) 
[16:13:50.171]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:50.171]                     ...future.globalenv.names))
[16:13:50.171]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:50.171]         }, condition = base::local({
[16:13:50.171]             c <- base::c
[16:13:50.171]             inherits <- base::inherits
[16:13:50.171]             invokeRestart <- base::invokeRestart
[16:13:50.171]             length <- base::length
[16:13:50.171]             list <- base::list
[16:13:50.171]             seq.int <- base::seq.int
[16:13:50.171]             signalCondition <- base::signalCondition
[16:13:50.171]             sys.calls <- base::sys.calls
[16:13:50.171]             `[[` <- base::`[[`
[16:13:50.171]             `+` <- base::`+`
[16:13:50.171]             `<<-` <- base::`<<-`
[16:13:50.171]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:50.171]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:50.171]                   3L)]
[16:13:50.171]             }
[16:13:50.171]             function(cond) {
[16:13:50.171]                 is_error <- inherits(cond, "error")
[16:13:50.171]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:50.171]                   NULL)
[16:13:50.171]                 if (is_error) {
[16:13:50.171]                   sessionInformation <- function() {
[16:13:50.171]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:50.171]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:50.171]                       search = base::search(), system = base::Sys.info())
[16:13:50.171]                   }
[16:13:50.171]                   ...future.conditions[[length(...future.conditions) + 
[16:13:50.171]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:50.171]                     cond$call), session = sessionInformation(), 
[16:13:50.171]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:50.171]                   signalCondition(cond)
[16:13:50.171]                 }
[16:13:50.171]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:50.171]                 "immediateCondition"))) {
[16:13:50.171]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:50.171]                   ...future.conditions[[length(...future.conditions) + 
[16:13:50.171]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:50.171]                   if (TRUE && !signal) {
[16:13:50.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:50.171]                     {
[16:13:50.171]                       inherits <- base::inherits
[16:13:50.171]                       invokeRestart <- base::invokeRestart
[16:13:50.171]                       is.null <- base::is.null
[16:13:50.171]                       muffled <- FALSE
[16:13:50.171]                       if (inherits(cond, "message")) {
[16:13:50.171]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:50.171]                         if (muffled) 
[16:13:50.171]                           invokeRestart("muffleMessage")
[16:13:50.171]                       }
[16:13:50.171]                       else if (inherits(cond, "warning")) {
[16:13:50.171]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:50.171]                         if (muffled) 
[16:13:50.171]                           invokeRestart("muffleWarning")
[16:13:50.171]                       }
[16:13:50.171]                       else if (inherits(cond, "condition")) {
[16:13:50.171]                         if (!is.null(pattern)) {
[16:13:50.171]                           computeRestarts <- base::computeRestarts
[16:13:50.171]                           grepl <- base::grepl
[16:13:50.171]                           restarts <- computeRestarts(cond)
[16:13:50.171]                           for (restart in restarts) {
[16:13:50.171]                             name <- restart$name
[16:13:50.171]                             if (is.null(name)) 
[16:13:50.171]                               next
[16:13:50.171]                             if (!grepl(pattern, name)) 
[16:13:50.171]                               next
[16:13:50.171]                             invokeRestart(restart)
[16:13:50.171]                             muffled <- TRUE
[16:13:50.171]                             break
[16:13:50.171]                           }
[16:13:50.171]                         }
[16:13:50.171]                       }
[16:13:50.171]                       invisible(muffled)
[16:13:50.171]                     }
[16:13:50.171]                     muffleCondition(cond, pattern = "^muffle")
[16:13:50.171]                   }
[16:13:50.171]                 }
[16:13:50.171]                 else {
[16:13:50.171]                   if (TRUE) {
[16:13:50.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:50.171]                     {
[16:13:50.171]                       inherits <- base::inherits
[16:13:50.171]                       invokeRestart <- base::invokeRestart
[16:13:50.171]                       is.null <- base::is.null
[16:13:50.171]                       muffled <- FALSE
[16:13:50.171]                       if (inherits(cond, "message")) {
[16:13:50.171]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:50.171]                         if (muffled) 
[16:13:50.171]                           invokeRestart("muffleMessage")
[16:13:50.171]                       }
[16:13:50.171]                       else if (inherits(cond, "warning")) {
[16:13:50.171]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:50.171]                         if (muffled) 
[16:13:50.171]                           invokeRestart("muffleWarning")
[16:13:50.171]                       }
[16:13:50.171]                       else if (inherits(cond, "condition")) {
[16:13:50.171]                         if (!is.null(pattern)) {
[16:13:50.171]                           computeRestarts <- base::computeRestarts
[16:13:50.171]                           grepl <- base::grepl
[16:13:50.171]                           restarts <- computeRestarts(cond)
[16:13:50.171]                           for (restart in restarts) {
[16:13:50.171]                             name <- restart$name
[16:13:50.171]                             if (is.null(name)) 
[16:13:50.171]                               next
[16:13:50.171]                             if (!grepl(pattern, name)) 
[16:13:50.171]                               next
[16:13:50.171]                             invokeRestart(restart)
[16:13:50.171]                             muffled <- TRUE
[16:13:50.171]                             break
[16:13:50.171]                           }
[16:13:50.171]                         }
[16:13:50.171]                       }
[16:13:50.171]                       invisible(muffled)
[16:13:50.171]                     }
[16:13:50.171]                     muffleCondition(cond, pattern = "^muffle")
[16:13:50.171]                   }
[16:13:50.171]                 }
[16:13:50.171]             }
[16:13:50.171]         }))
[16:13:50.171]     }, error = function(ex) {
[16:13:50.171]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:50.171]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:50.171]                 ...future.rng), started = ...future.startTime, 
[16:13:50.171]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:50.171]             version = "1.8"), class = "FutureResult")
[16:13:50.171]     }, finally = {
[16:13:50.171]         if (!identical(...future.workdir, getwd())) 
[16:13:50.171]             setwd(...future.workdir)
[16:13:50.171]         {
[16:13:50.171]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:50.171]                 ...future.oldOptions$nwarnings <- NULL
[16:13:50.171]             }
[16:13:50.171]             base::options(...future.oldOptions)
[16:13:50.171]             if (.Platform$OS.type == "windows") {
[16:13:50.171]                 old_names <- names(...future.oldEnvVars)
[16:13:50.171]                 envs <- base::Sys.getenv()
[16:13:50.171]                 names <- names(envs)
[16:13:50.171]                 common <- intersect(names, old_names)
[16:13:50.171]                 added <- setdiff(names, old_names)
[16:13:50.171]                 removed <- setdiff(old_names, names)
[16:13:50.171]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:50.171]                   envs[common]]
[16:13:50.171]                 NAMES <- toupper(changed)
[16:13:50.171]                 args <- list()
[16:13:50.171]                 for (kk in seq_along(NAMES)) {
[16:13:50.171]                   name <- changed[[kk]]
[16:13:50.171]                   NAME <- NAMES[[kk]]
[16:13:50.171]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:50.171]                     next
[16:13:50.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:50.171]                 }
[16:13:50.171]                 NAMES <- toupper(added)
[16:13:50.171]                 for (kk in seq_along(NAMES)) {
[16:13:50.171]                   name <- added[[kk]]
[16:13:50.171]                   NAME <- NAMES[[kk]]
[16:13:50.171]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:50.171]                     next
[16:13:50.171]                   args[[name]] <- ""
[16:13:50.171]                 }
[16:13:50.171]                 NAMES <- toupper(removed)
[16:13:50.171]                 for (kk in seq_along(NAMES)) {
[16:13:50.171]                   name <- removed[[kk]]
[16:13:50.171]                   NAME <- NAMES[[kk]]
[16:13:50.171]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:50.171]                     next
[16:13:50.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:50.171]                 }
[16:13:50.171]                 if (length(args) > 0) 
[16:13:50.171]                   base::do.call(base::Sys.setenv, args = args)
[16:13:50.171]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:50.171]             }
[16:13:50.171]             else {
[16:13:50.171]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:50.171]             }
[16:13:50.171]             {
[16:13:50.171]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:50.171]                   0L) {
[16:13:50.171]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:50.171]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:50.171]                   base::options(opts)
[16:13:50.171]                 }
[16:13:50.171]                 {
[16:13:50.171]                   {
[16:13:50.171]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:50.171]                     NULL
[16:13:50.171]                   }
[16:13:50.171]                   options(future.plan = NULL)
[16:13:50.171]                   if (is.na(NA_character_)) 
[16:13:50.171]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:50.171]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:50.171]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:50.171]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:50.171]                     envir = parent.frame()) 
[16:13:50.171]                   {
[16:13:50.171]                     if (is.function(workers)) 
[16:13:50.171]                       workers <- workers()
[16:13:50.171]                     workers <- structure(as.integer(workers), 
[16:13:50.171]                       class = class(workers))
[16:13:50.171]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:50.171]                       workers >= 1)
[16:13:50.171]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:50.171]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:50.171]                     }
[16:13:50.171]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:50.171]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:50.171]                       envir = envir)
[16:13:50.171]                     if (!future$lazy) 
[16:13:50.171]                       future <- run(future)
[16:13:50.171]                     invisible(future)
[16:13:50.171]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:50.171]                 }
[16:13:50.171]             }
[16:13:50.171]         }
[16:13:50.171]     })
[16:13:50.171]     if (TRUE) {
[16:13:50.171]         base::sink(type = "output", split = FALSE)
[16:13:50.171]         if (TRUE) {
[16:13:50.171]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:50.171]         }
[16:13:50.171]         else {
[16:13:50.171]             ...future.result["stdout"] <- base::list(NULL)
[16:13:50.171]         }
[16:13:50.171]         base::close(...future.stdout)
[16:13:50.171]         ...future.stdout <- NULL
[16:13:50.171]     }
[16:13:50.171]     ...future.result$conditions <- ...future.conditions
[16:13:50.171]     ...future.result$finished <- base::Sys.time()
[16:13:50.171]     ...future.result
[16:13:50.171] }
[16:13:50.174] MultisessionFuture started
[16:13:50.174] - Launch lazy future ... done
[16:13:50.174] run() for ‘MultisessionFuture’ ... done
[16:13:50.222] receiveMessageFromWorker() for ClusterFuture ...
[16:13:50.223] - Validating connection of MultisessionFuture
[16:13:50.223] - received message: FutureResult
[16:13:50.223] - Received FutureResult
[16:13:50.223] - Erased future from FutureRegistry
[16:13:50.223] result() for ClusterFuture ...
[16:13:50.223] - result already collected: FutureResult
[16:13:50.224] result() for ClusterFuture ... done
[16:13:50.224] signalConditions() ...
[16:13:50.224]  - include = ‘immediateCondition’
[16:13:50.224]  - exclude = 
[16:13:50.224]  - resignal = FALSE
[16:13:50.224]  - Number of conditions: 1
[16:13:50.224] signalConditions() ... done
[16:13:50.224] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:50.224] A MultisessionFuture was resolved (result was not collected)
[16:13:50.225] getGlobalsAndPackages() ...
[16:13:50.225] Searching for globals...
[16:13:50.225] - globals found: [2] ‘list’, ‘stop’
[16:13:50.225] Searching for globals ... DONE
[16:13:50.225] Resolving globals: FALSE
[16:13:50.226] 
[16:13:50.226] 
[16:13:50.226] getGlobalsAndPackages() ... DONE
[16:13:50.226] run() for ‘Future’ ...
[16:13:50.226] - state: ‘created’
[16:13:50.226] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:50.241] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:50.241] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:50.241]   - Field: ‘node’
[16:13:50.241]   - Field: ‘label’
[16:13:50.241]   - Field: ‘local’
[16:13:50.241]   - Field: ‘owner’
[16:13:50.242]   - Field: ‘envir’
[16:13:50.242]   - Field: ‘workers’
[16:13:50.242]   - Field: ‘packages’
[16:13:50.242]   - Field: ‘gc’
[16:13:50.242]   - Field: ‘conditions’
[16:13:50.242]   - Field: ‘persistent’
[16:13:50.242]   - Field: ‘expr’
[16:13:50.242]   - Field: ‘uuid’
[16:13:50.242]   - Field: ‘seed’
[16:13:50.242]   - Field: ‘version’
[16:13:50.242]   - Field: ‘result’
[16:13:50.243]   - Field: ‘asynchronous’
[16:13:50.243]   - Field: ‘calls’
[16:13:50.243]   - Field: ‘globals’
[16:13:50.243]   - Field: ‘stdout’
[16:13:50.243]   - Field: ‘earlySignal’
[16:13:50.243]   - Field: ‘lazy’
[16:13:50.243]   - Field: ‘state’
[16:13:50.243] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:50.243] - Launch lazy future ...
[16:13:50.244] Packages needed by the future expression (n = 0): <none>
[16:13:50.244] Packages needed by future strategies (n = 0): <none>
[16:13:50.244] {
[16:13:50.244]     {
[16:13:50.244]         {
[16:13:50.244]             ...future.startTime <- base::Sys.time()
[16:13:50.244]             {
[16:13:50.244]                 {
[16:13:50.244]                   {
[16:13:50.244]                     {
[16:13:50.244]                       base::local({
[16:13:50.244]                         has_future <- base::requireNamespace("future", 
[16:13:50.244]                           quietly = TRUE)
[16:13:50.244]                         if (has_future) {
[16:13:50.244]                           ns <- base::getNamespace("future")
[16:13:50.244]                           version <- ns[[".package"]][["version"]]
[16:13:50.244]                           if (is.null(version)) 
[16:13:50.244]                             version <- utils::packageVersion("future")
[16:13:50.244]                         }
[16:13:50.244]                         else {
[16:13:50.244]                           version <- NULL
[16:13:50.244]                         }
[16:13:50.244]                         if (!has_future || version < "1.8.0") {
[16:13:50.244]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:50.244]                             "", base::R.version$version.string), 
[16:13:50.244]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:50.244]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:50.244]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:50.244]                               "release", "version")], collapse = " "), 
[16:13:50.244]                             hostname = base::Sys.info()[["nodename"]])
[16:13:50.244]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:50.244]                             info)
[16:13:50.244]                           info <- base::paste(info, collapse = "; ")
[16:13:50.244]                           if (!has_future) {
[16:13:50.244]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:50.244]                               info)
[16:13:50.244]                           }
[16:13:50.244]                           else {
[16:13:50.244]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:50.244]                               info, version)
[16:13:50.244]                           }
[16:13:50.244]                           base::stop(msg)
[16:13:50.244]                         }
[16:13:50.244]                       })
[16:13:50.244]                     }
[16:13:50.244]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:50.244]                     base::options(mc.cores = 1L)
[16:13:50.244]                   }
[16:13:50.244]                   options(future.plan = NULL)
[16:13:50.244]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:50.244]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:50.244]                 }
[16:13:50.244]                 ...future.workdir <- getwd()
[16:13:50.244]             }
[16:13:50.244]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:50.244]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:50.244]         }
[16:13:50.244]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:50.244]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:50.244]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:50.244]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:50.244]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:50.244]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:50.244]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:50.244]             base::names(...future.oldOptions))
[16:13:50.244]     }
[16:13:50.244]     if (FALSE) {
[16:13:50.244]     }
[16:13:50.244]     else {
[16:13:50.244]         if (TRUE) {
[16:13:50.244]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:50.244]                 open = "w")
[16:13:50.244]         }
[16:13:50.244]         else {
[16:13:50.244]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:50.244]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:50.244]         }
[16:13:50.244]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:50.244]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:50.244]             base::sink(type = "output", split = FALSE)
[16:13:50.244]             base::close(...future.stdout)
[16:13:50.244]         }, add = TRUE)
[16:13:50.244]     }
[16:13:50.244]     ...future.frame <- base::sys.nframe()
[16:13:50.244]     ...future.conditions <- base::list()
[16:13:50.244]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:50.244]     if (FALSE) {
[16:13:50.244]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:50.244]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:50.244]     }
[16:13:50.244]     ...future.result <- base::tryCatch({
[16:13:50.244]         base::withCallingHandlers({
[16:13:50.244]             ...future.value <- base::withVisible(base::local({
[16:13:50.244]                 ...future.makeSendCondition <- local({
[16:13:50.244]                   sendCondition <- NULL
[16:13:50.244]                   function(frame = 1L) {
[16:13:50.244]                     if (is.function(sendCondition)) 
[16:13:50.244]                       return(sendCondition)
[16:13:50.244]                     ns <- getNamespace("parallel")
[16:13:50.244]                     if (exists("sendData", mode = "function", 
[16:13:50.244]                       envir = ns)) {
[16:13:50.244]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:50.244]                         envir = ns)
[16:13:50.244]                       envir <- sys.frame(frame)
[16:13:50.244]                       master <- NULL
[16:13:50.244]                       while (!identical(envir, .GlobalEnv) && 
[16:13:50.244]                         !identical(envir, emptyenv())) {
[16:13:50.244]                         if (exists("master", mode = "list", envir = envir, 
[16:13:50.244]                           inherits = FALSE)) {
[16:13:50.244]                           master <- get("master", mode = "list", 
[16:13:50.244]                             envir = envir, inherits = FALSE)
[16:13:50.244]                           if (inherits(master, c("SOCKnode", 
[16:13:50.244]                             "SOCK0node"))) {
[16:13:50.244]                             sendCondition <<- function(cond) {
[16:13:50.244]                               data <- list(type = "VALUE", value = cond, 
[16:13:50.244]                                 success = TRUE)
[16:13:50.244]                               parallel_sendData(master, data)
[16:13:50.244]                             }
[16:13:50.244]                             return(sendCondition)
[16:13:50.244]                           }
[16:13:50.244]                         }
[16:13:50.244]                         frame <- frame + 1L
[16:13:50.244]                         envir <- sys.frame(frame)
[16:13:50.244]                       }
[16:13:50.244]                     }
[16:13:50.244]                     sendCondition <<- function(cond) NULL
[16:13:50.244]                   }
[16:13:50.244]                 })
[16:13:50.244]                 withCallingHandlers({
[16:13:50.244]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:50.244]                 }, immediateCondition = function(cond) {
[16:13:50.244]                   sendCondition <- ...future.makeSendCondition()
[16:13:50.244]                   sendCondition(cond)
[16:13:50.244]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:50.244]                   {
[16:13:50.244]                     inherits <- base::inherits
[16:13:50.244]                     invokeRestart <- base::invokeRestart
[16:13:50.244]                     is.null <- base::is.null
[16:13:50.244]                     muffled <- FALSE
[16:13:50.244]                     if (inherits(cond, "message")) {
[16:13:50.244]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:50.244]                       if (muffled) 
[16:13:50.244]                         invokeRestart("muffleMessage")
[16:13:50.244]                     }
[16:13:50.244]                     else if (inherits(cond, "warning")) {
[16:13:50.244]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:50.244]                       if (muffled) 
[16:13:50.244]                         invokeRestart("muffleWarning")
[16:13:50.244]                     }
[16:13:50.244]                     else if (inherits(cond, "condition")) {
[16:13:50.244]                       if (!is.null(pattern)) {
[16:13:50.244]                         computeRestarts <- base::computeRestarts
[16:13:50.244]                         grepl <- base::grepl
[16:13:50.244]                         restarts <- computeRestarts(cond)
[16:13:50.244]                         for (restart in restarts) {
[16:13:50.244]                           name <- restart$name
[16:13:50.244]                           if (is.null(name)) 
[16:13:50.244]                             next
[16:13:50.244]                           if (!grepl(pattern, name)) 
[16:13:50.244]                             next
[16:13:50.244]                           invokeRestart(restart)
[16:13:50.244]                           muffled <- TRUE
[16:13:50.244]                           break
[16:13:50.244]                         }
[16:13:50.244]                       }
[16:13:50.244]                     }
[16:13:50.244]                     invisible(muffled)
[16:13:50.244]                   }
[16:13:50.244]                   muffleCondition(cond)
[16:13:50.244]                 })
[16:13:50.244]             }))
[16:13:50.244]             future::FutureResult(value = ...future.value$value, 
[16:13:50.244]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:50.244]                   ...future.rng), globalenv = if (FALSE) 
[16:13:50.244]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:50.244]                     ...future.globalenv.names))
[16:13:50.244]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:50.244]         }, condition = base::local({
[16:13:50.244]             c <- base::c
[16:13:50.244]             inherits <- base::inherits
[16:13:50.244]             invokeRestart <- base::invokeRestart
[16:13:50.244]             length <- base::length
[16:13:50.244]             list <- base::list
[16:13:50.244]             seq.int <- base::seq.int
[16:13:50.244]             signalCondition <- base::signalCondition
[16:13:50.244]             sys.calls <- base::sys.calls
[16:13:50.244]             `[[` <- base::`[[`
[16:13:50.244]             `+` <- base::`+`
[16:13:50.244]             `<<-` <- base::`<<-`
[16:13:50.244]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:50.244]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:50.244]                   3L)]
[16:13:50.244]             }
[16:13:50.244]             function(cond) {
[16:13:50.244]                 is_error <- inherits(cond, "error")
[16:13:50.244]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:50.244]                   NULL)
[16:13:50.244]                 if (is_error) {
[16:13:50.244]                   sessionInformation <- function() {
[16:13:50.244]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:50.244]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:50.244]                       search = base::search(), system = base::Sys.info())
[16:13:50.244]                   }
[16:13:50.244]                   ...future.conditions[[length(...future.conditions) + 
[16:13:50.244]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:50.244]                     cond$call), session = sessionInformation(), 
[16:13:50.244]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:50.244]                   signalCondition(cond)
[16:13:50.244]                 }
[16:13:50.244]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:50.244]                 "immediateCondition"))) {
[16:13:50.244]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:50.244]                   ...future.conditions[[length(...future.conditions) + 
[16:13:50.244]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:50.244]                   if (TRUE && !signal) {
[16:13:50.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:50.244]                     {
[16:13:50.244]                       inherits <- base::inherits
[16:13:50.244]                       invokeRestart <- base::invokeRestart
[16:13:50.244]                       is.null <- base::is.null
[16:13:50.244]                       muffled <- FALSE
[16:13:50.244]                       if (inherits(cond, "message")) {
[16:13:50.244]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:50.244]                         if (muffled) 
[16:13:50.244]                           invokeRestart("muffleMessage")
[16:13:50.244]                       }
[16:13:50.244]                       else if (inherits(cond, "warning")) {
[16:13:50.244]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:50.244]                         if (muffled) 
[16:13:50.244]                           invokeRestart("muffleWarning")
[16:13:50.244]                       }
[16:13:50.244]                       else if (inherits(cond, "condition")) {
[16:13:50.244]                         if (!is.null(pattern)) {
[16:13:50.244]                           computeRestarts <- base::computeRestarts
[16:13:50.244]                           grepl <- base::grepl
[16:13:50.244]                           restarts <- computeRestarts(cond)
[16:13:50.244]                           for (restart in restarts) {
[16:13:50.244]                             name <- restart$name
[16:13:50.244]                             if (is.null(name)) 
[16:13:50.244]                               next
[16:13:50.244]                             if (!grepl(pattern, name)) 
[16:13:50.244]                               next
[16:13:50.244]                             invokeRestart(restart)
[16:13:50.244]                             muffled <- TRUE
[16:13:50.244]                             break
[16:13:50.244]                           }
[16:13:50.244]                         }
[16:13:50.244]                       }
[16:13:50.244]                       invisible(muffled)
[16:13:50.244]                     }
[16:13:50.244]                     muffleCondition(cond, pattern = "^muffle")
[16:13:50.244]                   }
[16:13:50.244]                 }
[16:13:50.244]                 else {
[16:13:50.244]                   if (TRUE) {
[16:13:50.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:50.244]                     {
[16:13:50.244]                       inherits <- base::inherits
[16:13:50.244]                       invokeRestart <- base::invokeRestart
[16:13:50.244]                       is.null <- base::is.null
[16:13:50.244]                       muffled <- FALSE
[16:13:50.244]                       if (inherits(cond, "message")) {
[16:13:50.244]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:50.244]                         if (muffled) 
[16:13:50.244]                           invokeRestart("muffleMessage")
[16:13:50.244]                       }
[16:13:50.244]                       else if (inherits(cond, "warning")) {
[16:13:50.244]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:50.244]                         if (muffled) 
[16:13:50.244]                           invokeRestart("muffleWarning")
[16:13:50.244]                       }
[16:13:50.244]                       else if (inherits(cond, "condition")) {
[16:13:50.244]                         if (!is.null(pattern)) {
[16:13:50.244]                           computeRestarts <- base::computeRestarts
[16:13:50.244]                           grepl <- base::grepl
[16:13:50.244]                           restarts <- computeRestarts(cond)
[16:13:50.244]                           for (restart in restarts) {
[16:13:50.244]                             name <- restart$name
[16:13:50.244]                             if (is.null(name)) 
[16:13:50.244]                               next
[16:13:50.244]                             if (!grepl(pattern, name)) 
[16:13:50.244]                               next
[16:13:50.244]                             invokeRestart(restart)
[16:13:50.244]                             muffled <- TRUE
[16:13:50.244]                             break
[16:13:50.244]                           }
[16:13:50.244]                         }
[16:13:50.244]                       }
[16:13:50.244]                       invisible(muffled)
[16:13:50.244]                     }
[16:13:50.244]                     muffleCondition(cond, pattern = "^muffle")
[16:13:50.244]                   }
[16:13:50.244]                 }
[16:13:50.244]             }
[16:13:50.244]         }))
[16:13:50.244]     }, error = function(ex) {
[16:13:50.244]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:50.244]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:50.244]                 ...future.rng), started = ...future.startTime, 
[16:13:50.244]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:50.244]             version = "1.8"), class = "FutureResult")
[16:13:50.244]     }, finally = {
[16:13:50.244]         if (!identical(...future.workdir, getwd())) 
[16:13:50.244]             setwd(...future.workdir)
[16:13:50.244]         {
[16:13:50.244]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:50.244]                 ...future.oldOptions$nwarnings <- NULL
[16:13:50.244]             }
[16:13:50.244]             base::options(...future.oldOptions)
[16:13:50.244]             if (.Platform$OS.type == "windows") {
[16:13:50.244]                 old_names <- names(...future.oldEnvVars)
[16:13:50.244]                 envs <- base::Sys.getenv()
[16:13:50.244]                 names <- names(envs)
[16:13:50.244]                 common <- intersect(names, old_names)
[16:13:50.244]                 added <- setdiff(names, old_names)
[16:13:50.244]                 removed <- setdiff(old_names, names)
[16:13:50.244]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:50.244]                   envs[common]]
[16:13:50.244]                 NAMES <- toupper(changed)
[16:13:50.244]                 args <- list()
[16:13:50.244]                 for (kk in seq_along(NAMES)) {
[16:13:50.244]                   name <- changed[[kk]]
[16:13:50.244]                   NAME <- NAMES[[kk]]
[16:13:50.244]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:50.244]                     next
[16:13:50.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:50.244]                 }
[16:13:50.244]                 NAMES <- toupper(added)
[16:13:50.244]                 for (kk in seq_along(NAMES)) {
[16:13:50.244]                   name <- added[[kk]]
[16:13:50.244]                   NAME <- NAMES[[kk]]
[16:13:50.244]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:50.244]                     next
[16:13:50.244]                   args[[name]] <- ""
[16:13:50.244]                 }
[16:13:50.244]                 NAMES <- toupper(removed)
[16:13:50.244]                 for (kk in seq_along(NAMES)) {
[16:13:50.244]                   name <- removed[[kk]]
[16:13:50.244]                   NAME <- NAMES[[kk]]
[16:13:50.244]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:50.244]                     next
[16:13:50.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:50.244]                 }
[16:13:50.244]                 if (length(args) > 0) 
[16:13:50.244]                   base::do.call(base::Sys.setenv, args = args)
[16:13:50.244]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:50.244]             }
[16:13:50.244]             else {
[16:13:50.244]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:50.244]             }
[16:13:50.244]             {
[16:13:50.244]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:50.244]                   0L) {
[16:13:50.244]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:50.244]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:50.244]                   base::options(opts)
[16:13:50.244]                 }
[16:13:50.244]                 {
[16:13:50.244]                   {
[16:13:50.244]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:50.244]                     NULL
[16:13:50.244]                   }
[16:13:50.244]                   options(future.plan = NULL)
[16:13:50.244]                   if (is.na(NA_character_)) 
[16:13:50.244]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:50.244]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:50.244]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:50.244]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:50.244]                     envir = parent.frame()) 
[16:13:50.244]                   {
[16:13:50.244]                     if (is.function(workers)) 
[16:13:50.244]                       workers <- workers()
[16:13:50.244]                     workers <- structure(as.integer(workers), 
[16:13:50.244]                       class = class(workers))
[16:13:50.244]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:50.244]                       workers >= 1)
[16:13:50.244]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:50.244]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:50.244]                     }
[16:13:50.244]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:50.244]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:50.244]                       envir = envir)
[16:13:50.244]                     if (!future$lazy) 
[16:13:50.244]                       future <- run(future)
[16:13:50.244]                     invisible(future)
[16:13:50.244]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:50.244]                 }
[16:13:50.244]             }
[16:13:50.244]         }
[16:13:50.244]     })
[16:13:50.244]     if (TRUE) {
[16:13:50.244]         base::sink(type = "output", split = FALSE)
[16:13:50.244]         if (TRUE) {
[16:13:50.244]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:50.244]         }
[16:13:50.244]         else {
[16:13:50.244]             ...future.result["stdout"] <- base::list(NULL)
[16:13:50.244]         }
[16:13:50.244]         base::close(...future.stdout)
[16:13:50.244]         ...future.stdout <- NULL
[16:13:50.244]     }
[16:13:50.244]     ...future.result$conditions <- ...future.conditions
[16:13:50.244]     ...future.result$finished <- base::Sys.time()
[16:13:50.244]     ...future.result
[16:13:50.244] }
[16:13:50.247] MultisessionFuture started
[16:13:50.247] - Launch lazy future ... done
[16:13:50.247] run() for ‘MultisessionFuture’ ... done
[16:13:50.292] receiveMessageFromWorker() for ClusterFuture ...
[16:13:50.292] - Validating connection of MultisessionFuture
[16:13:50.293] - received message: FutureResult
[16:13:50.293] - Received FutureResult
[16:13:50.293] - Erased future from FutureRegistry
[16:13:50.293] result() for ClusterFuture ...
[16:13:50.294] - result already collected: FutureResult
[16:13:50.294] result() for ClusterFuture ... done
[16:13:50.294] signalConditions() ...
[16:13:50.294]  - include = ‘immediateCondition’
[16:13:50.294]  - exclude = 
[16:13:50.294]  - resignal = FALSE
[16:13:50.294]  - Number of conditions: 1
[16:13:50.294] signalConditions() ... done
[16:13:50.294] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:50.294] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 2 ... DONE
- result = FALSE, recursive = Inf ...
[16:13:50.295] getGlobalsAndPackages() ...
[16:13:50.295] Searching for globals...
[16:13:50.296] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:50.296] Searching for globals ... DONE
[16:13:50.296] Resolving globals: FALSE
[16:13:50.297] 
[16:13:50.297] 
[16:13:50.297] getGlobalsAndPackages() ... DONE
[16:13:50.297] run() for ‘Future’ ...
[16:13:50.297] - state: ‘created’
[16:13:50.297] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:50.313] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:50.314] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:50.314]   - Field: ‘node’
[16:13:50.314]   - Field: ‘label’
[16:13:50.314]   - Field: ‘local’
[16:13:50.314]   - Field: ‘owner’
[16:13:50.314]   - Field: ‘envir’
[16:13:50.314]   - Field: ‘workers’
[16:13:50.314]   - Field: ‘packages’
[16:13:50.314]   - Field: ‘gc’
[16:13:50.314]   - Field: ‘conditions’
[16:13:50.315]   - Field: ‘persistent’
[16:13:50.315]   - Field: ‘expr’
[16:13:50.315]   - Field: ‘uuid’
[16:13:50.315]   - Field: ‘seed’
[16:13:50.315]   - Field: ‘version’
[16:13:50.315]   - Field: ‘result’
[16:13:50.315]   - Field: ‘asynchronous’
[16:13:50.315]   - Field: ‘calls’
[16:13:50.315]   - Field: ‘globals’
[16:13:50.315]   - Field: ‘stdout’
[16:13:50.315]   - Field: ‘earlySignal’
[16:13:50.316]   - Field: ‘lazy’
[16:13:50.316]   - Field: ‘state’
[16:13:50.316] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:50.316] - Launch lazy future ...
[16:13:50.316] Packages needed by the future expression (n = 0): <none>
[16:13:50.316] Packages needed by future strategies (n = 0): <none>
[16:13:50.317] {
[16:13:50.317]     {
[16:13:50.317]         {
[16:13:50.317]             ...future.startTime <- base::Sys.time()
[16:13:50.317]             {
[16:13:50.317]                 {
[16:13:50.317]                   {
[16:13:50.317]                     {
[16:13:50.317]                       base::local({
[16:13:50.317]                         has_future <- base::requireNamespace("future", 
[16:13:50.317]                           quietly = TRUE)
[16:13:50.317]                         if (has_future) {
[16:13:50.317]                           ns <- base::getNamespace("future")
[16:13:50.317]                           version <- ns[[".package"]][["version"]]
[16:13:50.317]                           if (is.null(version)) 
[16:13:50.317]                             version <- utils::packageVersion("future")
[16:13:50.317]                         }
[16:13:50.317]                         else {
[16:13:50.317]                           version <- NULL
[16:13:50.317]                         }
[16:13:50.317]                         if (!has_future || version < "1.8.0") {
[16:13:50.317]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:50.317]                             "", base::R.version$version.string), 
[16:13:50.317]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:50.317]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:50.317]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:50.317]                               "release", "version")], collapse = " "), 
[16:13:50.317]                             hostname = base::Sys.info()[["nodename"]])
[16:13:50.317]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:50.317]                             info)
[16:13:50.317]                           info <- base::paste(info, collapse = "; ")
[16:13:50.317]                           if (!has_future) {
[16:13:50.317]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:50.317]                               info)
[16:13:50.317]                           }
[16:13:50.317]                           else {
[16:13:50.317]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:50.317]                               info, version)
[16:13:50.317]                           }
[16:13:50.317]                           base::stop(msg)
[16:13:50.317]                         }
[16:13:50.317]                       })
[16:13:50.317]                     }
[16:13:50.317]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:50.317]                     base::options(mc.cores = 1L)
[16:13:50.317]                   }
[16:13:50.317]                   options(future.plan = NULL)
[16:13:50.317]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:50.317]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:50.317]                 }
[16:13:50.317]                 ...future.workdir <- getwd()
[16:13:50.317]             }
[16:13:50.317]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:50.317]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:50.317]         }
[16:13:50.317]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:50.317]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:50.317]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:50.317]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:50.317]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:50.317]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:50.317]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:50.317]             base::names(...future.oldOptions))
[16:13:50.317]     }
[16:13:50.317]     if (FALSE) {
[16:13:50.317]     }
[16:13:50.317]     else {
[16:13:50.317]         if (TRUE) {
[16:13:50.317]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:50.317]                 open = "w")
[16:13:50.317]         }
[16:13:50.317]         else {
[16:13:50.317]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:50.317]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:50.317]         }
[16:13:50.317]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:50.317]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:50.317]             base::sink(type = "output", split = FALSE)
[16:13:50.317]             base::close(...future.stdout)
[16:13:50.317]         }, add = TRUE)
[16:13:50.317]     }
[16:13:50.317]     ...future.frame <- base::sys.nframe()
[16:13:50.317]     ...future.conditions <- base::list()
[16:13:50.317]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:50.317]     if (FALSE) {
[16:13:50.317]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:50.317]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:50.317]     }
[16:13:50.317]     ...future.result <- base::tryCatch({
[16:13:50.317]         base::withCallingHandlers({
[16:13:50.317]             ...future.value <- base::withVisible(base::local({
[16:13:50.317]                 ...future.makeSendCondition <- local({
[16:13:50.317]                   sendCondition <- NULL
[16:13:50.317]                   function(frame = 1L) {
[16:13:50.317]                     if (is.function(sendCondition)) 
[16:13:50.317]                       return(sendCondition)
[16:13:50.317]                     ns <- getNamespace("parallel")
[16:13:50.317]                     if (exists("sendData", mode = "function", 
[16:13:50.317]                       envir = ns)) {
[16:13:50.317]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:50.317]                         envir = ns)
[16:13:50.317]                       envir <- sys.frame(frame)
[16:13:50.317]                       master <- NULL
[16:13:50.317]                       while (!identical(envir, .GlobalEnv) && 
[16:13:50.317]                         !identical(envir, emptyenv())) {
[16:13:50.317]                         if (exists("master", mode = "list", envir = envir, 
[16:13:50.317]                           inherits = FALSE)) {
[16:13:50.317]                           master <- get("master", mode = "list", 
[16:13:50.317]                             envir = envir, inherits = FALSE)
[16:13:50.317]                           if (inherits(master, c("SOCKnode", 
[16:13:50.317]                             "SOCK0node"))) {
[16:13:50.317]                             sendCondition <<- function(cond) {
[16:13:50.317]                               data <- list(type = "VALUE", value = cond, 
[16:13:50.317]                                 success = TRUE)
[16:13:50.317]                               parallel_sendData(master, data)
[16:13:50.317]                             }
[16:13:50.317]                             return(sendCondition)
[16:13:50.317]                           }
[16:13:50.317]                         }
[16:13:50.317]                         frame <- frame + 1L
[16:13:50.317]                         envir <- sys.frame(frame)
[16:13:50.317]                       }
[16:13:50.317]                     }
[16:13:50.317]                     sendCondition <<- function(cond) NULL
[16:13:50.317]                   }
[16:13:50.317]                 })
[16:13:50.317]                 withCallingHandlers({
[16:13:50.317]                   {
[16:13:50.317]                     Sys.sleep(0.5)
[16:13:50.317]                     list(a = 1, b = 42L)
[16:13:50.317]                   }
[16:13:50.317]                 }, immediateCondition = function(cond) {
[16:13:50.317]                   sendCondition <- ...future.makeSendCondition()
[16:13:50.317]                   sendCondition(cond)
[16:13:50.317]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:50.317]                   {
[16:13:50.317]                     inherits <- base::inherits
[16:13:50.317]                     invokeRestart <- base::invokeRestart
[16:13:50.317]                     is.null <- base::is.null
[16:13:50.317]                     muffled <- FALSE
[16:13:50.317]                     if (inherits(cond, "message")) {
[16:13:50.317]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:50.317]                       if (muffled) 
[16:13:50.317]                         invokeRestart("muffleMessage")
[16:13:50.317]                     }
[16:13:50.317]                     else if (inherits(cond, "warning")) {
[16:13:50.317]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:50.317]                       if (muffled) 
[16:13:50.317]                         invokeRestart("muffleWarning")
[16:13:50.317]                     }
[16:13:50.317]                     else if (inherits(cond, "condition")) {
[16:13:50.317]                       if (!is.null(pattern)) {
[16:13:50.317]                         computeRestarts <- base::computeRestarts
[16:13:50.317]                         grepl <- base::grepl
[16:13:50.317]                         restarts <- computeRestarts(cond)
[16:13:50.317]                         for (restart in restarts) {
[16:13:50.317]                           name <- restart$name
[16:13:50.317]                           if (is.null(name)) 
[16:13:50.317]                             next
[16:13:50.317]                           if (!grepl(pattern, name)) 
[16:13:50.317]                             next
[16:13:50.317]                           invokeRestart(restart)
[16:13:50.317]                           muffled <- TRUE
[16:13:50.317]                           break
[16:13:50.317]                         }
[16:13:50.317]                       }
[16:13:50.317]                     }
[16:13:50.317]                     invisible(muffled)
[16:13:50.317]                   }
[16:13:50.317]                   muffleCondition(cond)
[16:13:50.317]                 })
[16:13:50.317]             }))
[16:13:50.317]             future::FutureResult(value = ...future.value$value, 
[16:13:50.317]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:50.317]                   ...future.rng), globalenv = if (FALSE) 
[16:13:50.317]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:50.317]                     ...future.globalenv.names))
[16:13:50.317]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:50.317]         }, condition = base::local({
[16:13:50.317]             c <- base::c
[16:13:50.317]             inherits <- base::inherits
[16:13:50.317]             invokeRestart <- base::invokeRestart
[16:13:50.317]             length <- base::length
[16:13:50.317]             list <- base::list
[16:13:50.317]             seq.int <- base::seq.int
[16:13:50.317]             signalCondition <- base::signalCondition
[16:13:50.317]             sys.calls <- base::sys.calls
[16:13:50.317]             `[[` <- base::`[[`
[16:13:50.317]             `+` <- base::`+`
[16:13:50.317]             `<<-` <- base::`<<-`
[16:13:50.317]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:50.317]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:50.317]                   3L)]
[16:13:50.317]             }
[16:13:50.317]             function(cond) {
[16:13:50.317]                 is_error <- inherits(cond, "error")
[16:13:50.317]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:50.317]                   NULL)
[16:13:50.317]                 if (is_error) {
[16:13:50.317]                   sessionInformation <- function() {
[16:13:50.317]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:50.317]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:50.317]                       search = base::search(), system = base::Sys.info())
[16:13:50.317]                   }
[16:13:50.317]                   ...future.conditions[[length(...future.conditions) + 
[16:13:50.317]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:50.317]                     cond$call), session = sessionInformation(), 
[16:13:50.317]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:50.317]                   signalCondition(cond)
[16:13:50.317]                 }
[16:13:50.317]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:50.317]                 "immediateCondition"))) {
[16:13:50.317]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:50.317]                   ...future.conditions[[length(...future.conditions) + 
[16:13:50.317]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:50.317]                   if (TRUE && !signal) {
[16:13:50.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:50.317]                     {
[16:13:50.317]                       inherits <- base::inherits
[16:13:50.317]                       invokeRestart <- base::invokeRestart
[16:13:50.317]                       is.null <- base::is.null
[16:13:50.317]                       muffled <- FALSE
[16:13:50.317]                       if (inherits(cond, "message")) {
[16:13:50.317]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:50.317]                         if (muffled) 
[16:13:50.317]                           invokeRestart("muffleMessage")
[16:13:50.317]                       }
[16:13:50.317]                       else if (inherits(cond, "warning")) {
[16:13:50.317]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:50.317]                         if (muffled) 
[16:13:50.317]                           invokeRestart("muffleWarning")
[16:13:50.317]                       }
[16:13:50.317]                       else if (inherits(cond, "condition")) {
[16:13:50.317]                         if (!is.null(pattern)) {
[16:13:50.317]                           computeRestarts <- base::computeRestarts
[16:13:50.317]                           grepl <- base::grepl
[16:13:50.317]                           restarts <- computeRestarts(cond)
[16:13:50.317]                           for (restart in restarts) {
[16:13:50.317]                             name <- restart$name
[16:13:50.317]                             if (is.null(name)) 
[16:13:50.317]                               next
[16:13:50.317]                             if (!grepl(pattern, name)) 
[16:13:50.317]                               next
[16:13:50.317]                             invokeRestart(restart)
[16:13:50.317]                             muffled <- TRUE
[16:13:50.317]                             break
[16:13:50.317]                           }
[16:13:50.317]                         }
[16:13:50.317]                       }
[16:13:50.317]                       invisible(muffled)
[16:13:50.317]                     }
[16:13:50.317]                     muffleCondition(cond, pattern = "^muffle")
[16:13:50.317]                   }
[16:13:50.317]                 }
[16:13:50.317]                 else {
[16:13:50.317]                   if (TRUE) {
[16:13:50.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:50.317]                     {
[16:13:50.317]                       inherits <- base::inherits
[16:13:50.317]                       invokeRestart <- base::invokeRestart
[16:13:50.317]                       is.null <- base::is.null
[16:13:50.317]                       muffled <- FALSE
[16:13:50.317]                       if (inherits(cond, "message")) {
[16:13:50.317]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:50.317]                         if (muffled) 
[16:13:50.317]                           invokeRestart("muffleMessage")
[16:13:50.317]                       }
[16:13:50.317]                       else if (inherits(cond, "warning")) {
[16:13:50.317]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:50.317]                         if (muffled) 
[16:13:50.317]                           invokeRestart("muffleWarning")
[16:13:50.317]                       }
[16:13:50.317]                       else if (inherits(cond, "condition")) {
[16:13:50.317]                         if (!is.null(pattern)) {
[16:13:50.317]                           computeRestarts <- base::computeRestarts
[16:13:50.317]                           grepl <- base::grepl
[16:13:50.317]                           restarts <- computeRestarts(cond)
[16:13:50.317]                           for (restart in restarts) {
[16:13:50.317]                             name <- restart$name
[16:13:50.317]                             if (is.null(name)) 
[16:13:50.317]                               next
[16:13:50.317]                             if (!grepl(pattern, name)) 
[16:13:50.317]                               next
[16:13:50.317]                             invokeRestart(restart)
[16:13:50.317]                             muffled <- TRUE
[16:13:50.317]                             break
[16:13:50.317]                           }
[16:13:50.317]                         }
[16:13:50.317]                       }
[16:13:50.317]                       invisible(muffled)
[16:13:50.317]                     }
[16:13:50.317]                     muffleCondition(cond, pattern = "^muffle")
[16:13:50.317]                   }
[16:13:50.317]                 }
[16:13:50.317]             }
[16:13:50.317]         }))
[16:13:50.317]     }, error = function(ex) {
[16:13:50.317]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:50.317]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:50.317]                 ...future.rng), started = ...future.startTime, 
[16:13:50.317]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:50.317]             version = "1.8"), class = "FutureResult")
[16:13:50.317]     }, finally = {
[16:13:50.317]         if (!identical(...future.workdir, getwd())) 
[16:13:50.317]             setwd(...future.workdir)
[16:13:50.317]         {
[16:13:50.317]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:50.317]                 ...future.oldOptions$nwarnings <- NULL
[16:13:50.317]             }
[16:13:50.317]             base::options(...future.oldOptions)
[16:13:50.317]             if (.Platform$OS.type == "windows") {
[16:13:50.317]                 old_names <- names(...future.oldEnvVars)
[16:13:50.317]                 envs <- base::Sys.getenv()
[16:13:50.317]                 names <- names(envs)
[16:13:50.317]                 common <- intersect(names, old_names)
[16:13:50.317]                 added <- setdiff(names, old_names)
[16:13:50.317]                 removed <- setdiff(old_names, names)
[16:13:50.317]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:50.317]                   envs[common]]
[16:13:50.317]                 NAMES <- toupper(changed)
[16:13:50.317]                 args <- list()
[16:13:50.317]                 for (kk in seq_along(NAMES)) {
[16:13:50.317]                   name <- changed[[kk]]
[16:13:50.317]                   NAME <- NAMES[[kk]]
[16:13:50.317]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:50.317]                     next
[16:13:50.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:50.317]                 }
[16:13:50.317]                 NAMES <- toupper(added)
[16:13:50.317]                 for (kk in seq_along(NAMES)) {
[16:13:50.317]                   name <- added[[kk]]
[16:13:50.317]                   NAME <- NAMES[[kk]]
[16:13:50.317]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:50.317]                     next
[16:13:50.317]                   args[[name]] <- ""
[16:13:50.317]                 }
[16:13:50.317]                 NAMES <- toupper(removed)
[16:13:50.317]                 for (kk in seq_along(NAMES)) {
[16:13:50.317]                   name <- removed[[kk]]
[16:13:50.317]                   NAME <- NAMES[[kk]]
[16:13:50.317]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:50.317]                     next
[16:13:50.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:50.317]                 }
[16:13:50.317]                 if (length(args) > 0) 
[16:13:50.317]                   base::do.call(base::Sys.setenv, args = args)
[16:13:50.317]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:50.317]             }
[16:13:50.317]             else {
[16:13:50.317]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:50.317]             }
[16:13:50.317]             {
[16:13:50.317]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:50.317]                   0L) {
[16:13:50.317]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:50.317]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:50.317]                   base::options(opts)
[16:13:50.317]                 }
[16:13:50.317]                 {
[16:13:50.317]                   {
[16:13:50.317]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:50.317]                     NULL
[16:13:50.317]                   }
[16:13:50.317]                   options(future.plan = NULL)
[16:13:50.317]                   if (is.na(NA_character_)) 
[16:13:50.317]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:50.317]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:50.317]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:50.317]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:50.317]                     envir = parent.frame()) 
[16:13:50.317]                   {
[16:13:50.317]                     if (is.function(workers)) 
[16:13:50.317]                       workers <- workers()
[16:13:50.317]                     workers <- structure(as.integer(workers), 
[16:13:50.317]                       class = class(workers))
[16:13:50.317]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:50.317]                       workers >= 1)
[16:13:50.317]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:50.317]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:50.317]                     }
[16:13:50.317]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:50.317]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:50.317]                       envir = envir)
[16:13:50.317]                     if (!future$lazy) 
[16:13:50.317]                       future <- run(future)
[16:13:50.317]                     invisible(future)
[16:13:50.317]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:50.317]                 }
[16:13:50.317]             }
[16:13:50.317]         }
[16:13:50.317]     })
[16:13:50.317]     if (TRUE) {
[16:13:50.317]         base::sink(type = "output", split = FALSE)
[16:13:50.317]         if (TRUE) {
[16:13:50.317]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:50.317]         }
[16:13:50.317]         else {
[16:13:50.317]             ...future.result["stdout"] <- base::list(NULL)
[16:13:50.317]         }
[16:13:50.317]         base::close(...future.stdout)
[16:13:50.317]         ...future.stdout <- NULL
[16:13:50.317]     }
[16:13:50.317]     ...future.result$conditions <- ...future.conditions
[16:13:50.317]     ...future.result$finished <- base::Sys.time()
[16:13:50.317]     ...future.result
[16:13:50.317] }
[16:13:50.320] MultisessionFuture started
[16:13:50.320] - Launch lazy future ... done
[16:13:50.320] run() for ‘MultisessionFuture’ ... done
[16:13:50.865] receiveMessageFromWorker() for ClusterFuture ...
[16:13:50.866] - Validating connection of MultisessionFuture
[16:13:50.866] - received message: FutureResult
[16:13:50.866] - Received FutureResult
[16:13:50.866] - Erased future from FutureRegistry
[16:13:50.866] result() for ClusterFuture ...
[16:13:50.866] - result already collected: FutureResult
[16:13:50.866] result() for ClusterFuture ... done
[16:13:50.867] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:50.867] A MultisessionFuture was resolved (result was not collected)
[16:13:50.867] getGlobalsAndPackages() ...
[16:13:50.867] Searching for globals...
[16:13:50.868] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:50.868] Searching for globals ... DONE
[16:13:50.868] Resolving globals: FALSE
[16:13:50.869] 
[16:13:50.869] 
[16:13:50.869] getGlobalsAndPackages() ... DONE
[16:13:50.869] run() for ‘Future’ ...
[16:13:50.869] - state: ‘created’
[16:13:50.869] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:50.884] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:50.884] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:50.884]   - Field: ‘node’
[16:13:50.884]   - Field: ‘label’
[16:13:50.884]   - Field: ‘local’
[16:13:50.884]   - Field: ‘owner’
[16:13:50.885]   - Field: ‘envir’
[16:13:50.885]   - Field: ‘workers’
[16:13:50.885]   - Field: ‘packages’
[16:13:50.885]   - Field: ‘gc’
[16:13:50.885]   - Field: ‘conditions’
[16:13:50.885]   - Field: ‘persistent’
[16:13:50.885]   - Field: ‘expr’
[16:13:50.885]   - Field: ‘uuid’
[16:13:50.885]   - Field: ‘seed’
[16:13:50.885]   - Field: ‘version’
[16:13:50.885]   - Field: ‘result’
[16:13:50.886]   - Field: ‘asynchronous’
[16:13:50.886]   - Field: ‘calls’
[16:13:50.886]   - Field: ‘globals’
[16:13:50.886]   - Field: ‘stdout’
[16:13:50.886]   - Field: ‘earlySignal’
[16:13:50.886]   - Field: ‘lazy’
[16:13:50.886]   - Field: ‘state’
[16:13:50.886] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:50.886] - Launch lazy future ...
[16:13:50.887] Packages needed by the future expression (n = 0): <none>
[16:13:50.887] Packages needed by future strategies (n = 0): <none>
[16:13:50.887] {
[16:13:50.887]     {
[16:13:50.887]         {
[16:13:50.887]             ...future.startTime <- base::Sys.time()
[16:13:50.887]             {
[16:13:50.887]                 {
[16:13:50.887]                   {
[16:13:50.887]                     {
[16:13:50.887]                       base::local({
[16:13:50.887]                         has_future <- base::requireNamespace("future", 
[16:13:50.887]                           quietly = TRUE)
[16:13:50.887]                         if (has_future) {
[16:13:50.887]                           ns <- base::getNamespace("future")
[16:13:50.887]                           version <- ns[[".package"]][["version"]]
[16:13:50.887]                           if (is.null(version)) 
[16:13:50.887]                             version <- utils::packageVersion("future")
[16:13:50.887]                         }
[16:13:50.887]                         else {
[16:13:50.887]                           version <- NULL
[16:13:50.887]                         }
[16:13:50.887]                         if (!has_future || version < "1.8.0") {
[16:13:50.887]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:50.887]                             "", base::R.version$version.string), 
[16:13:50.887]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:50.887]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:50.887]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:50.887]                               "release", "version")], collapse = " "), 
[16:13:50.887]                             hostname = base::Sys.info()[["nodename"]])
[16:13:50.887]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:50.887]                             info)
[16:13:50.887]                           info <- base::paste(info, collapse = "; ")
[16:13:50.887]                           if (!has_future) {
[16:13:50.887]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:50.887]                               info)
[16:13:50.887]                           }
[16:13:50.887]                           else {
[16:13:50.887]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:50.887]                               info, version)
[16:13:50.887]                           }
[16:13:50.887]                           base::stop(msg)
[16:13:50.887]                         }
[16:13:50.887]                       })
[16:13:50.887]                     }
[16:13:50.887]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:50.887]                     base::options(mc.cores = 1L)
[16:13:50.887]                   }
[16:13:50.887]                   options(future.plan = NULL)
[16:13:50.887]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:50.887]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:50.887]                 }
[16:13:50.887]                 ...future.workdir <- getwd()
[16:13:50.887]             }
[16:13:50.887]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:50.887]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:50.887]         }
[16:13:50.887]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:50.887]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:50.887]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:50.887]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:50.887]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:50.887]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:50.887]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:50.887]             base::names(...future.oldOptions))
[16:13:50.887]     }
[16:13:50.887]     if (FALSE) {
[16:13:50.887]     }
[16:13:50.887]     else {
[16:13:50.887]         if (TRUE) {
[16:13:50.887]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:50.887]                 open = "w")
[16:13:50.887]         }
[16:13:50.887]         else {
[16:13:50.887]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:50.887]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:50.887]         }
[16:13:50.887]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:50.887]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:50.887]             base::sink(type = "output", split = FALSE)
[16:13:50.887]             base::close(...future.stdout)
[16:13:50.887]         }, add = TRUE)
[16:13:50.887]     }
[16:13:50.887]     ...future.frame <- base::sys.nframe()
[16:13:50.887]     ...future.conditions <- base::list()
[16:13:50.887]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:50.887]     if (FALSE) {
[16:13:50.887]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:50.887]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:50.887]     }
[16:13:50.887]     ...future.result <- base::tryCatch({
[16:13:50.887]         base::withCallingHandlers({
[16:13:50.887]             ...future.value <- base::withVisible(base::local({
[16:13:50.887]                 ...future.makeSendCondition <- local({
[16:13:50.887]                   sendCondition <- NULL
[16:13:50.887]                   function(frame = 1L) {
[16:13:50.887]                     if (is.function(sendCondition)) 
[16:13:50.887]                       return(sendCondition)
[16:13:50.887]                     ns <- getNamespace("parallel")
[16:13:50.887]                     if (exists("sendData", mode = "function", 
[16:13:50.887]                       envir = ns)) {
[16:13:50.887]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:50.887]                         envir = ns)
[16:13:50.887]                       envir <- sys.frame(frame)
[16:13:50.887]                       master <- NULL
[16:13:50.887]                       while (!identical(envir, .GlobalEnv) && 
[16:13:50.887]                         !identical(envir, emptyenv())) {
[16:13:50.887]                         if (exists("master", mode = "list", envir = envir, 
[16:13:50.887]                           inherits = FALSE)) {
[16:13:50.887]                           master <- get("master", mode = "list", 
[16:13:50.887]                             envir = envir, inherits = FALSE)
[16:13:50.887]                           if (inherits(master, c("SOCKnode", 
[16:13:50.887]                             "SOCK0node"))) {
[16:13:50.887]                             sendCondition <<- function(cond) {
[16:13:50.887]                               data <- list(type = "VALUE", value = cond, 
[16:13:50.887]                                 success = TRUE)
[16:13:50.887]                               parallel_sendData(master, data)
[16:13:50.887]                             }
[16:13:50.887]                             return(sendCondition)
[16:13:50.887]                           }
[16:13:50.887]                         }
[16:13:50.887]                         frame <- frame + 1L
[16:13:50.887]                         envir <- sys.frame(frame)
[16:13:50.887]                       }
[16:13:50.887]                     }
[16:13:50.887]                     sendCondition <<- function(cond) NULL
[16:13:50.887]                   }
[16:13:50.887]                 })
[16:13:50.887]                 withCallingHandlers({
[16:13:50.887]                   {
[16:13:50.887]                     Sys.sleep(0.5)
[16:13:50.887]                     list(a = 1, b = 42L)
[16:13:50.887]                   }
[16:13:50.887]                 }, immediateCondition = function(cond) {
[16:13:50.887]                   sendCondition <- ...future.makeSendCondition()
[16:13:50.887]                   sendCondition(cond)
[16:13:50.887]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:50.887]                   {
[16:13:50.887]                     inherits <- base::inherits
[16:13:50.887]                     invokeRestart <- base::invokeRestart
[16:13:50.887]                     is.null <- base::is.null
[16:13:50.887]                     muffled <- FALSE
[16:13:50.887]                     if (inherits(cond, "message")) {
[16:13:50.887]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:50.887]                       if (muffled) 
[16:13:50.887]                         invokeRestart("muffleMessage")
[16:13:50.887]                     }
[16:13:50.887]                     else if (inherits(cond, "warning")) {
[16:13:50.887]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:50.887]                       if (muffled) 
[16:13:50.887]                         invokeRestart("muffleWarning")
[16:13:50.887]                     }
[16:13:50.887]                     else if (inherits(cond, "condition")) {
[16:13:50.887]                       if (!is.null(pattern)) {
[16:13:50.887]                         computeRestarts <- base::computeRestarts
[16:13:50.887]                         grepl <- base::grepl
[16:13:50.887]                         restarts <- computeRestarts(cond)
[16:13:50.887]                         for (restart in restarts) {
[16:13:50.887]                           name <- restart$name
[16:13:50.887]                           if (is.null(name)) 
[16:13:50.887]                             next
[16:13:50.887]                           if (!grepl(pattern, name)) 
[16:13:50.887]                             next
[16:13:50.887]                           invokeRestart(restart)
[16:13:50.887]                           muffled <- TRUE
[16:13:50.887]                           break
[16:13:50.887]                         }
[16:13:50.887]                       }
[16:13:50.887]                     }
[16:13:50.887]                     invisible(muffled)
[16:13:50.887]                   }
[16:13:50.887]                   muffleCondition(cond)
[16:13:50.887]                 })
[16:13:50.887]             }))
[16:13:50.887]             future::FutureResult(value = ...future.value$value, 
[16:13:50.887]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:50.887]                   ...future.rng), globalenv = if (FALSE) 
[16:13:50.887]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:50.887]                     ...future.globalenv.names))
[16:13:50.887]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:50.887]         }, condition = base::local({
[16:13:50.887]             c <- base::c
[16:13:50.887]             inherits <- base::inherits
[16:13:50.887]             invokeRestart <- base::invokeRestart
[16:13:50.887]             length <- base::length
[16:13:50.887]             list <- base::list
[16:13:50.887]             seq.int <- base::seq.int
[16:13:50.887]             signalCondition <- base::signalCondition
[16:13:50.887]             sys.calls <- base::sys.calls
[16:13:50.887]             `[[` <- base::`[[`
[16:13:50.887]             `+` <- base::`+`
[16:13:50.887]             `<<-` <- base::`<<-`
[16:13:50.887]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:50.887]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:50.887]                   3L)]
[16:13:50.887]             }
[16:13:50.887]             function(cond) {
[16:13:50.887]                 is_error <- inherits(cond, "error")
[16:13:50.887]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:50.887]                   NULL)
[16:13:50.887]                 if (is_error) {
[16:13:50.887]                   sessionInformation <- function() {
[16:13:50.887]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:50.887]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:50.887]                       search = base::search(), system = base::Sys.info())
[16:13:50.887]                   }
[16:13:50.887]                   ...future.conditions[[length(...future.conditions) + 
[16:13:50.887]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:50.887]                     cond$call), session = sessionInformation(), 
[16:13:50.887]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:50.887]                   signalCondition(cond)
[16:13:50.887]                 }
[16:13:50.887]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:50.887]                 "immediateCondition"))) {
[16:13:50.887]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:50.887]                   ...future.conditions[[length(...future.conditions) + 
[16:13:50.887]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:50.887]                   if (TRUE && !signal) {
[16:13:50.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:50.887]                     {
[16:13:50.887]                       inherits <- base::inherits
[16:13:50.887]                       invokeRestart <- base::invokeRestart
[16:13:50.887]                       is.null <- base::is.null
[16:13:50.887]                       muffled <- FALSE
[16:13:50.887]                       if (inherits(cond, "message")) {
[16:13:50.887]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:50.887]                         if (muffled) 
[16:13:50.887]                           invokeRestart("muffleMessage")
[16:13:50.887]                       }
[16:13:50.887]                       else if (inherits(cond, "warning")) {
[16:13:50.887]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:50.887]                         if (muffled) 
[16:13:50.887]                           invokeRestart("muffleWarning")
[16:13:50.887]                       }
[16:13:50.887]                       else if (inherits(cond, "condition")) {
[16:13:50.887]                         if (!is.null(pattern)) {
[16:13:50.887]                           computeRestarts <- base::computeRestarts
[16:13:50.887]                           grepl <- base::grepl
[16:13:50.887]                           restarts <- computeRestarts(cond)
[16:13:50.887]                           for (restart in restarts) {
[16:13:50.887]                             name <- restart$name
[16:13:50.887]                             if (is.null(name)) 
[16:13:50.887]                               next
[16:13:50.887]                             if (!grepl(pattern, name)) 
[16:13:50.887]                               next
[16:13:50.887]                             invokeRestart(restart)
[16:13:50.887]                             muffled <- TRUE
[16:13:50.887]                             break
[16:13:50.887]                           }
[16:13:50.887]                         }
[16:13:50.887]                       }
[16:13:50.887]                       invisible(muffled)
[16:13:50.887]                     }
[16:13:50.887]                     muffleCondition(cond, pattern = "^muffle")
[16:13:50.887]                   }
[16:13:50.887]                 }
[16:13:50.887]                 else {
[16:13:50.887]                   if (TRUE) {
[16:13:50.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:50.887]                     {
[16:13:50.887]                       inherits <- base::inherits
[16:13:50.887]                       invokeRestart <- base::invokeRestart
[16:13:50.887]                       is.null <- base::is.null
[16:13:50.887]                       muffled <- FALSE
[16:13:50.887]                       if (inherits(cond, "message")) {
[16:13:50.887]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:50.887]                         if (muffled) 
[16:13:50.887]                           invokeRestart("muffleMessage")
[16:13:50.887]                       }
[16:13:50.887]                       else if (inherits(cond, "warning")) {
[16:13:50.887]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:50.887]                         if (muffled) 
[16:13:50.887]                           invokeRestart("muffleWarning")
[16:13:50.887]                       }
[16:13:50.887]                       else if (inherits(cond, "condition")) {
[16:13:50.887]                         if (!is.null(pattern)) {
[16:13:50.887]                           computeRestarts <- base::computeRestarts
[16:13:50.887]                           grepl <- base::grepl
[16:13:50.887]                           restarts <- computeRestarts(cond)
[16:13:50.887]                           for (restart in restarts) {
[16:13:50.887]                             name <- restart$name
[16:13:50.887]                             if (is.null(name)) 
[16:13:50.887]                               next
[16:13:50.887]                             if (!grepl(pattern, name)) 
[16:13:50.887]                               next
[16:13:50.887]                             invokeRestart(restart)
[16:13:50.887]                             muffled <- TRUE
[16:13:50.887]                             break
[16:13:50.887]                           }
[16:13:50.887]                         }
[16:13:50.887]                       }
[16:13:50.887]                       invisible(muffled)
[16:13:50.887]                     }
[16:13:50.887]                     muffleCondition(cond, pattern = "^muffle")
[16:13:50.887]                   }
[16:13:50.887]                 }
[16:13:50.887]             }
[16:13:50.887]         }))
[16:13:50.887]     }, error = function(ex) {
[16:13:50.887]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:50.887]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:50.887]                 ...future.rng), started = ...future.startTime, 
[16:13:50.887]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:50.887]             version = "1.8"), class = "FutureResult")
[16:13:50.887]     }, finally = {
[16:13:50.887]         if (!identical(...future.workdir, getwd())) 
[16:13:50.887]             setwd(...future.workdir)
[16:13:50.887]         {
[16:13:50.887]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:50.887]                 ...future.oldOptions$nwarnings <- NULL
[16:13:50.887]             }
[16:13:50.887]             base::options(...future.oldOptions)
[16:13:50.887]             if (.Platform$OS.type == "windows") {
[16:13:50.887]                 old_names <- names(...future.oldEnvVars)
[16:13:50.887]                 envs <- base::Sys.getenv()
[16:13:50.887]                 names <- names(envs)
[16:13:50.887]                 common <- intersect(names, old_names)
[16:13:50.887]                 added <- setdiff(names, old_names)
[16:13:50.887]                 removed <- setdiff(old_names, names)
[16:13:50.887]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:50.887]                   envs[common]]
[16:13:50.887]                 NAMES <- toupper(changed)
[16:13:50.887]                 args <- list()
[16:13:50.887]                 for (kk in seq_along(NAMES)) {
[16:13:50.887]                   name <- changed[[kk]]
[16:13:50.887]                   NAME <- NAMES[[kk]]
[16:13:50.887]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:50.887]                     next
[16:13:50.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:50.887]                 }
[16:13:50.887]                 NAMES <- toupper(added)
[16:13:50.887]                 for (kk in seq_along(NAMES)) {
[16:13:50.887]                   name <- added[[kk]]
[16:13:50.887]                   NAME <- NAMES[[kk]]
[16:13:50.887]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:50.887]                     next
[16:13:50.887]                   args[[name]] <- ""
[16:13:50.887]                 }
[16:13:50.887]                 NAMES <- toupper(removed)
[16:13:50.887]                 for (kk in seq_along(NAMES)) {
[16:13:50.887]                   name <- removed[[kk]]
[16:13:50.887]                   NAME <- NAMES[[kk]]
[16:13:50.887]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:50.887]                     next
[16:13:50.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:50.887]                 }
[16:13:50.887]                 if (length(args) > 0) 
[16:13:50.887]                   base::do.call(base::Sys.setenv, args = args)
[16:13:50.887]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:50.887]             }
[16:13:50.887]             else {
[16:13:50.887]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:50.887]             }
[16:13:50.887]             {
[16:13:50.887]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:50.887]                   0L) {
[16:13:50.887]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:50.887]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:50.887]                   base::options(opts)
[16:13:50.887]                 }
[16:13:50.887]                 {
[16:13:50.887]                   {
[16:13:50.887]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:50.887]                     NULL
[16:13:50.887]                   }
[16:13:50.887]                   options(future.plan = NULL)
[16:13:50.887]                   if (is.na(NA_character_)) 
[16:13:50.887]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:50.887]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:50.887]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:50.887]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:50.887]                     envir = parent.frame()) 
[16:13:50.887]                   {
[16:13:50.887]                     if (is.function(workers)) 
[16:13:50.887]                       workers <- workers()
[16:13:50.887]                     workers <- structure(as.integer(workers), 
[16:13:50.887]                       class = class(workers))
[16:13:50.887]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:50.887]                       workers >= 1)
[16:13:50.887]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:50.887]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:50.887]                     }
[16:13:50.887]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:50.887]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:50.887]                       envir = envir)
[16:13:50.887]                     if (!future$lazy) 
[16:13:50.887]                       future <- run(future)
[16:13:50.887]                     invisible(future)
[16:13:50.887]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:50.887]                 }
[16:13:50.887]             }
[16:13:50.887]         }
[16:13:50.887]     })
[16:13:50.887]     if (TRUE) {
[16:13:50.887]         base::sink(type = "output", split = FALSE)
[16:13:50.887]         if (TRUE) {
[16:13:50.887]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:50.887]         }
[16:13:50.887]         else {
[16:13:50.887]             ...future.result["stdout"] <- base::list(NULL)
[16:13:50.887]         }
[16:13:50.887]         base::close(...future.stdout)
[16:13:50.887]         ...future.stdout <- NULL
[16:13:50.887]     }
[16:13:50.887]     ...future.result$conditions <- ...future.conditions
[16:13:50.887]     ...future.result$finished <- base::Sys.time()
[16:13:50.887]     ...future.result
[16:13:50.887] }
[16:13:50.891] MultisessionFuture started
[16:13:50.891] - Launch lazy future ... done
[16:13:50.891] run() for ‘MultisessionFuture’ ... done
[16:13:51.448] receiveMessageFromWorker() for ClusterFuture ...
[16:13:51.448] - Validating connection of MultisessionFuture
[16:13:51.449] - received message: FutureResult
[16:13:51.449] - Received FutureResult
[16:13:51.449] - Erased future from FutureRegistry
[16:13:51.449] result() for ClusterFuture ...
[16:13:51.449] - result already collected: FutureResult
[16:13:51.449] result() for ClusterFuture ... done
[16:13:51.449] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:51.449] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[16:13:51.450] getGlobalsAndPackages() ...
[16:13:51.450] Searching for globals...
[16:13:51.450] - globals found: [2] ‘list’, ‘stop’
[16:13:51.450] Searching for globals ... DONE
[16:13:51.451] Resolving globals: FALSE
[16:13:51.451] 
[16:13:51.451] 
[16:13:51.451] getGlobalsAndPackages() ... DONE
[16:13:51.451] run() for ‘Future’ ...
[16:13:51.451] - state: ‘created’
[16:13:51.452] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:51.466] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:51.466] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:51.466]   - Field: ‘node’
[16:13:51.466]   - Field: ‘label’
[16:13:51.466]   - Field: ‘local’
[16:13:51.466]   - Field: ‘owner’
[16:13:51.466]   - Field: ‘envir’
[16:13:51.466]   - Field: ‘workers’
[16:13:51.466]   - Field: ‘packages’
[16:13:51.467]   - Field: ‘gc’
[16:13:51.467]   - Field: ‘conditions’
[16:13:51.467]   - Field: ‘persistent’
[16:13:51.467]   - Field: ‘expr’
[16:13:51.467]   - Field: ‘uuid’
[16:13:51.467]   - Field: ‘seed’
[16:13:51.467]   - Field: ‘version’
[16:13:51.467]   - Field: ‘result’
[16:13:51.467]   - Field: ‘asynchronous’
[16:13:51.467]   - Field: ‘calls’
[16:13:51.467]   - Field: ‘globals’
[16:13:51.467]   - Field: ‘stdout’
[16:13:51.468]   - Field: ‘earlySignal’
[16:13:51.468]   - Field: ‘lazy’
[16:13:51.468]   - Field: ‘state’
[16:13:51.468] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:51.468] - Launch lazy future ...
[16:13:51.468] Packages needed by the future expression (n = 0): <none>
[16:13:51.468] Packages needed by future strategies (n = 0): <none>
[16:13:51.469] {
[16:13:51.469]     {
[16:13:51.469]         {
[16:13:51.469]             ...future.startTime <- base::Sys.time()
[16:13:51.469]             {
[16:13:51.469]                 {
[16:13:51.469]                   {
[16:13:51.469]                     {
[16:13:51.469]                       base::local({
[16:13:51.469]                         has_future <- base::requireNamespace("future", 
[16:13:51.469]                           quietly = TRUE)
[16:13:51.469]                         if (has_future) {
[16:13:51.469]                           ns <- base::getNamespace("future")
[16:13:51.469]                           version <- ns[[".package"]][["version"]]
[16:13:51.469]                           if (is.null(version)) 
[16:13:51.469]                             version <- utils::packageVersion("future")
[16:13:51.469]                         }
[16:13:51.469]                         else {
[16:13:51.469]                           version <- NULL
[16:13:51.469]                         }
[16:13:51.469]                         if (!has_future || version < "1.8.0") {
[16:13:51.469]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:51.469]                             "", base::R.version$version.string), 
[16:13:51.469]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:51.469]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:51.469]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:51.469]                               "release", "version")], collapse = " "), 
[16:13:51.469]                             hostname = base::Sys.info()[["nodename"]])
[16:13:51.469]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:51.469]                             info)
[16:13:51.469]                           info <- base::paste(info, collapse = "; ")
[16:13:51.469]                           if (!has_future) {
[16:13:51.469]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:51.469]                               info)
[16:13:51.469]                           }
[16:13:51.469]                           else {
[16:13:51.469]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:51.469]                               info, version)
[16:13:51.469]                           }
[16:13:51.469]                           base::stop(msg)
[16:13:51.469]                         }
[16:13:51.469]                       })
[16:13:51.469]                     }
[16:13:51.469]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:51.469]                     base::options(mc.cores = 1L)
[16:13:51.469]                   }
[16:13:51.469]                   options(future.plan = NULL)
[16:13:51.469]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:51.469]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:51.469]                 }
[16:13:51.469]                 ...future.workdir <- getwd()
[16:13:51.469]             }
[16:13:51.469]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:51.469]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:51.469]         }
[16:13:51.469]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:51.469]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:51.469]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:51.469]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:51.469]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:51.469]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:51.469]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:51.469]             base::names(...future.oldOptions))
[16:13:51.469]     }
[16:13:51.469]     if (FALSE) {
[16:13:51.469]     }
[16:13:51.469]     else {
[16:13:51.469]         if (TRUE) {
[16:13:51.469]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:51.469]                 open = "w")
[16:13:51.469]         }
[16:13:51.469]         else {
[16:13:51.469]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:51.469]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:51.469]         }
[16:13:51.469]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:51.469]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:51.469]             base::sink(type = "output", split = FALSE)
[16:13:51.469]             base::close(...future.stdout)
[16:13:51.469]         }, add = TRUE)
[16:13:51.469]     }
[16:13:51.469]     ...future.frame <- base::sys.nframe()
[16:13:51.469]     ...future.conditions <- base::list()
[16:13:51.469]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:51.469]     if (FALSE) {
[16:13:51.469]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:51.469]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:51.469]     }
[16:13:51.469]     ...future.result <- base::tryCatch({
[16:13:51.469]         base::withCallingHandlers({
[16:13:51.469]             ...future.value <- base::withVisible(base::local({
[16:13:51.469]                 ...future.makeSendCondition <- local({
[16:13:51.469]                   sendCondition <- NULL
[16:13:51.469]                   function(frame = 1L) {
[16:13:51.469]                     if (is.function(sendCondition)) 
[16:13:51.469]                       return(sendCondition)
[16:13:51.469]                     ns <- getNamespace("parallel")
[16:13:51.469]                     if (exists("sendData", mode = "function", 
[16:13:51.469]                       envir = ns)) {
[16:13:51.469]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:51.469]                         envir = ns)
[16:13:51.469]                       envir <- sys.frame(frame)
[16:13:51.469]                       master <- NULL
[16:13:51.469]                       while (!identical(envir, .GlobalEnv) && 
[16:13:51.469]                         !identical(envir, emptyenv())) {
[16:13:51.469]                         if (exists("master", mode = "list", envir = envir, 
[16:13:51.469]                           inherits = FALSE)) {
[16:13:51.469]                           master <- get("master", mode = "list", 
[16:13:51.469]                             envir = envir, inherits = FALSE)
[16:13:51.469]                           if (inherits(master, c("SOCKnode", 
[16:13:51.469]                             "SOCK0node"))) {
[16:13:51.469]                             sendCondition <<- function(cond) {
[16:13:51.469]                               data <- list(type = "VALUE", value = cond, 
[16:13:51.469]                                 success = TRUE)
[16:13:51.469]                               parallel_sendData(master, data)
[16:13:51.469]                             }
[16:13:51.469]                             return(sendCondition)
[16:13:51.469]                           }
[16:13:51.469]                         }
[16:13:51.469]                         frame <- frame + 1L
[16:13:51.469]                         envir <- sys.frame(frame)
[16:13:51.469]                       }
[16:13:51.469]                     }
[16:13:51.469]                     sendCondition <<- function(cond) NULL
[16:13:51.469]                   }
[16:13:51.469]                 })
[16:13:51.469]                 withCallingHandlers({
[16:13:51.469]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:51.469]                 }, immediateCondition = function(cond) {
[16:13:51.469]                   sendCondition <- ...future.makeSendCondition()
[16:13:51.469]                   sendCondition(cond)
[16:13:51.469]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:51.469]                   {
[16:13:51.469]                     inherits <- base::inherits
[16:13:51.469]                     invokeRestart <- base::invokeRestart
[16:13:51.469]                     is.null <- base::is.null
[16:13:51.469]                     muffled <- FALSE
[16:13:51.469]                     if (inherits(cond, "message")) {
[16:13:51.469]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:51.469]                       if (muffled) 
[16:13:51.469]                         invokeRestart("muffleMessage")
[16:13:51.469]                     }
[16:13:51.469]                     else if (inherits(cond, "warning")) {
[16:13:51.469]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:51.469]                       if (muffled) 
[16:13:51.469]                         invokeRestart("muffleWarning")
[16:13:51.469]                     }
[16:13:51.469]                     else if (inherits(cond, "condition")) {
[16:13:51.469]                       if (!is.null(pattern)) {
[16:13:51.469]                         computeRestarts <- base::computeRestarts
[16:13:51.469]                         grepl <- base::grepl
[16:13:51.469]                         restarts <- computeRestarts(cond)
[16:13:51.469]                         for (restart in restarts) {
[16:13:51.469]                           name <- restart$name
[16:13:51.469]                           if (is.null(name)) 
[16:13:51.469]                             next
[16:13:51.469]                           if (!grepl(pattern, name)) 
[16:13:51.469]                             next
[16:13:51.469]                           invokeRestart(restart)
[16:13:51.469]                           muffled <- TRUE
[16:13:51.469]                           break
[16:13:51.469]                         }
[16:13:51.469]                       }
[16:13:51.469]                     }
[16:13:51.469]                     invisible(muffled)
[16:13:51.469]                   }
[16:13:51.469]                   muffleCondition(cond)
[16:13:51.469]                 })
[16:13:51.469]             }))
[16:13:51.469]             future::FutureResult(value = ...future.value$value, 
[16:13:51.469]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:51.469]                   ...future.rng), globalenv = if (FALSE) 
[16:13:51.469]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:51.469]                     ...future.globalenv.names))
[16:13:51.469]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:51.469]         }, condition = base::local({
[16:13:51.469]             c <- base::c
[16:13:51.469]             inherits <- base::inherits
[16:13:51.469]             invokeRestart <- base::invokeRestart
[16:13:51.469]             length <- base::length
[16:13:51.469]             list <- base::list
[16:13:51.469]             seq.int <- base::seq.int
[16:13:51.469]             signalCondition <- base::signalCondition
[16:13:51.469]             sys.calls <- base::sys.calls
[16:13:51.469]             `[[` <- base::`[[`
[16:13:51.469]             `+` <- base::`+`
[16:13:51.469]             `<<-` <- base::`<<-`
[16:13:51.469]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:51.469]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:51.469]                   3L)]
[16:13:51.469]             }
[16:13:51.469]             function(cond) {
[16:13:51.469]                 is_error <- inherits(cond, "error")
[16:13:51.469]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:51.469]                   NULL)
[16:13:51.469]                 if (is_error) {
[16:13:51.469]                   sessionInformation <- function() {
[16:13:51.469]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:51.469]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:51.469]                       search = base::search(), system = base::Sys.info())
[16:13:51.469]                   }
[16:13:51.469]                   ...future.conditions[[length(...future.conditions) + 
[16:13:51.469]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:51.469]                     cond$call), session = sessionInformation(), 
[16:13:51.469]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:51.469]                   signalCondition(cond)
[16:13:51.469]                 }
[16:13:51.469]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:51.469]                 "immediateCondition"))) {
[16:13:51.469]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:51.469]                   ...future.conditions[[length(...future.conditions) + 
[16:13:51.469]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:51.469]                   if (TRUE && !signal) {
[16:13:51.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:51.469]                     {
[16:13:51.469]                       inherits <- base::inherits
[16:13:51.469]                       invokeRestart <- base::invokeRestart
[16:13:51.469]                       is.null <- base::is.null
[16:13:51.469]                       muffled <- FALSE
[16:13:51.469]                       if (inherits(cond, "message")) {
[16:13:51.469]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:51.469]                         if (muffled) 
[16:13:51.469]                           invokeRestart("muffleMessage")
[16:13:51.469]                       }
[16:13:51.469]                       else if (inherits(cond, "warning")) {
[16:13:51.469]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:51.469]                         if (muffled) 
[16:13:51.469]                           invokeRestart("muffleWarning")
[16:13:51.469]                       }
[16:13:51.469]                       else if (inherits(cond, "condition")) {
[16:13:51.469]                         if (!is.null(pattern)) {
[16:13:51.469]                           computeRestarts <- base::computeRestarts
[16:13:51.469]                           grepl <- base::grepl
[16:13:51.469]                           restarts <- computeRestarts(cond)
[16:13:51.469]                           for (restart in restarts) {
[16:13:51.469]                             name <- restart$name
[16:13:51.469]                             if (is.null(name)) 
[16:13:51.469]                               next
[16:13:51.469]                             if (!grepl(pattern, name)) 
[16:13:51.469]                               next
[16:13:51.469]                             invokeRestart(restart)
[16:13:51.469]                             muffled <- TRUE
[16:13:51.469]                             break
[16:13:51.469]                           }
[16:13:51.469]                         }
[16:13:51.469]                       }
[16:13:51.469]                       invisible(muffled)
[16:13:51.469]                     }
[16:13:51.469]                     muffleCondition(cond, pattern = "^muffle")
[16:13:51.469]                   }
[16:13:51.469]                 }
[16:13:51.469]                 else {
[16:13:51.469]                   if (TRUE) {
[16:13:51.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:51.469]                     {
[16:13:51.469]                       inherits <- base::inherits
[16:13:51.469]                       invokeRestart <- base::invokeRestart
[16:13:51.469]                       is.null <- base::is.null
[16:13:51.469]                       muffled <- FALSE
[16:13:51.469]                       if (inherits(cond, "message")) {
[16:13:51.469]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:51.469]                         if (muffled) 
[16:13:51.469]                           invokeRestart("muffleMessage")
[16:13:51.469]                       }
[16:13:51.469]                       else if (inherits(cond, "warning")) {
[16:13:51.469]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:51.469]                         if (muffled) 
[16:13:51.469]                           invokeRestart("muffleWarning")
[16:13:51.469]                       }
[16:13:51.469]                       else if (inherits(cond, "condition")) {
[16:13:51.469]                         if (!is.null(pattern)) {
[16:13:51.469]                           computeRestarts <- base::computeRestarts
[16:13:51.469]                           grepl <- base::grepl
[16:13:51.469]                           restarts <- computeRestarts(cond)
[16:13:51.469]                           for (restart in restarts) {
[16:13:51.469]                             name <- restart$name
[16:13:51.469]                             if (is.null(name)) 
[16:13:51.469]                               next
[16:13:51.469]                             if (!grepl(pattern, name)) 
[16:13:51.469]                               next
[16:13:51.469]                             invokeRestart(restart)
[16:13:51.469]                             muffled <- TRUE
[16:13:51.469]                             break
[16:13:51.469]                           }
[16:13:51.469]                         }
[16:13:51.469]                       }
[16:13:51.469]                       invisible(muffled)
[16:13:51.469]                     }
[16:13:51.469]                     muffleCondition(cond, pattern = "^muffle")
[16:13:51.469]                   }
[16:13:51.469]                 }
[16:13:51.469]             }
[16:13:51.469]         }))
[16:13:51.469]     }, error = function(ex) {
[16:13:51.469]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:51.469]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:51.469]                 ...future.rng), started = ...future.startTime, 
[16:13:51.469]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:51.469]             version = "1.8"), class = "FutureResult")
[16:13:51.469]     }, finally = {
[16:13:51.469]         if (!identical(...future.workdir, getwd())) 
[16:13:51.469]             setwd(...future.workdir)
[16:13:51.469]         {
[16:13:51.469]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:51.469]                 ...future.oldOptions$nwarnings <- NULL
[16:13:51.469]             }
[16:13:51.469]             base::options(...future.oldOptions)
[16:13:51.469]             if (.Platform$OS.type == "windows") {
[16:13:51.469]                 old_names <- names(...future.oldEnvVars)
[16:13:51.469]                 envs <- base::Sys.getenv()
[16:13:51.469]                 names <- names(envs)
[16:13:51.469]                 common <- intersect(names, old_names)
[16:13:51.469]                 added <- setdiff(names, old_names)
[16:13:51.469]                 removed <- setdiff(old_names, names)
[16:13:51.469]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:51.469]                   envs[common]]
[16:13:51.469]                 NAMES <- toupper(changed)
[16:13:51.469]                 args <- list()
[16:13:51.469]                 for (kk in seq_along(NAMES)) {
[16:13:51.469]                   name <- changed[[kk]]
[16:13:51.469]                   NAME <- NAMES[[kk]]
[16:13:51.469]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:51.469]                     next
[16:13:51.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:51.469]                 }
[16:13:51.469]                 NAMES <- toupper(added)
[16:13:51.469]                 for (kk in seq_along(NAMES)) {
[16:13:51.469]                   name <- added[[kk]]
[16:13:51.469]                   NAME <- NAMES[[kk]]
[16:13:51.469]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:51.469]                     next
[16:13:51.469]                   args[[name]] <- ""
[16:13:51.469]                 }
[16:13:51.469]                 NAMES <- toupper(removed)
[16:13:51.469]                 for (kk in seq_along(NAMES)) {
[16:13:51.469]                   name <- removed[[kk]]
[16:13:51.469]                   NAME <- NAMES[[kk]]
[16:13:51.469]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:51.469]                     next
[16:13:51.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:51.469]                 }
[16:13:51.469]                 if (length(args) > 0) 
[16:13:51.469]                   base::do.call(base::Sys.setenv, args = args)
[16:13:51.469]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:51.469]             }
[16:13:51.469]             else {
[16:13:51.469]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:51.469]             }
[16:13:51.469]             {
[16:13:51.469]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:51.469]                   0L) {
[16:13:51.469]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:51.469]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:51.469]                   base::options(opts)
[16:13:51.469]                 }
[16:13:51.469]                 {
[16:13:51.469]                   {
[16:13:51.469]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:51.469]                     NULL
[16:13:51.469]                   }
[16:13:51.469]                   options(future.plan = NULL)
[16:13:51.469]                   if (is.na(NA_character_)) 
[16:13:51.469]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:51.469]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:51.469]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:51.469]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:51.469]                     envir = parent.frame()) 
[16:13:51.469]                   {
[16:13:51.469]                     if (is.function(workers)) 
[16:13:51.469]                       workers <- workers()
[16:13:51.469]                     workers <- structure(as.integer(workers), 
[16:13:51.469]                       class = class(workers))
[16:13:51.469]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:51.469]                       workers >= 1)
[16:13:51.469]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:51.469]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:51.469]                     }
[16:13:51.469]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:51.469]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:51.469]                       envir = envir)
[16:13:51.469]                     if (!future$lazy) 
[16:13:51.469]                       future <- run(future)
[16:13:51.469]                     invisible(future)
[16:13:51.469]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:51.469]                 }
[16:13:51.469]             }
[16:13:51.469]         }
[16:13:51.469]     })
[16:13:51.469]     if (TRUE) {
[16:13:51.469]         base::sink(type = "output", split = FALSE)
[16:13:51.469]         if (TRUE) {
[16:13:51.469]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:51.469]         }
[16:13:51.469]         else {
[16:13:51.469]             ...future.result["stdout"] <- base::list(NULL)
[16:13:51.469]         }
[16:13:51.469]         base::close(...future.stdout)
[16:13:51.469]         ...future.stdout <- NULL
[16:13:51.469]     }
[16:13:51.469]     ...future.result$conditions <- ...future.conditions
[16:13:51.469]     ...future.result$finished <- base::Sys.time()
[16:13:51.469]     ...future.result
[16:13:51.469] }
[16:13:51.472] MultisessionFuture started
[16:13:51.472] - Launch lazy future ... done
[16:13:51.472] run() for ‘MultisessionFuture’ ... done
[16:13:51.521] receiveMessageFromWorker() for ClusterFuture ...
[16:13:51.521] - Validating connection of MultisessionFuture
[16:13:51.521] - received message: FutureResult
[16:13:51.521] - Received FutureResult
[16:13:51.522] - Erased future from FutureRegistry
[16:13:51.522] result() for ClusterFuture ...
[16:13:51.522] - result already collected: FutureResult
[16:13:51.522] result() for ClusterFuture ... done
[16:13:51.522] signalConditions() ...
[16:13:51.522]  - include = ‘immediateCondition’
[16:13:51.522]  - exclude = 
[16:13:51.522]  - resignal = FALSE
[16:13:51.522]  - Number of conditions: 1
[16:13:51.522] signalConditions() ... done
[16:13:51.522] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:51.523] A MultisessionFuture was resolved (result was not collected)
[16:13:51.523] getGlobalsAndPackages() ...
[16:13:51.523] Searching for globals...
[16:13:51.523] - globals found: [2] ‘list’, ‘stop’
[16:13:51.523] Searching for globals ... DONE
[16:13:51.524] Resolving globals: FALSE
[16:13:51.524] 
[16:13:51.524] 
[16:13:51.524] getGlobalsAndPackages() ... DONE
[16:13:51.524] run() for ‘Future’ ...
[16:13:51.524] - state: ‘created’
[16:13:51.525] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:51.539] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:51.539] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:51.539]   - Field: ‘node’
[16:13:51.539]   - Field: ‘label’
[16:13:51.539]   - Field: ‘local’
[16:13:51.539]   - Field: ‘owner’
[16:13:51.540]   - Field: ‘envir’
[16:13:51.540]   - Field: ‘workers’
[16:13:51.540]   - Field: ‘packages’
[16:13:51.540]   - Field: ‘gc’
[16:13:51.540]   - Field: ‘conditions’
[16:13:51.540]   - Field: ‘persistent’
[16:13:51.540]   - Field: ‘expr’
[16:13:51.540]   - Field: ‘uuid’
[16:13:51.540]   - Field: ‘seed’
[16:13:51.540]   - Field: ‘version’
[16:13:51.540]   - Field: ‘result’
[16:13:51.541]   - Field: ‘asynchronous’
[16:13:51.541]   - Field: ‘calls’
[16:13:51.541]   - Field: ‘globals’
[16:13:51.541]   - Field: ‘stdout’
[16:13:51.541]   - Field: ‘earlySignal’
[16:13:51.541]   - Field: ‘lazy’
[16:13:51.541]   - Field: ‘state’
[16:13:51.541] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:51.541] - Launch lazy future ...
[16:13:51.542] Packages needed by the future expression (n = 0): <none>
[16:13:51.542] Packages needed by future strategies (n = 0): <none>
[16:13:51.542] {
[16:13:51.542]     {
[16:13:51.542]         {
[16:13:51.542]             ...future.startTime <- base::Sys.time()
[16:13:51.542]             {
[16:13:51.542]                 {
[16:13:51.542]                   {
[16:13:51.542]                     {
[16:13:51.542]                       base::local({
[16:13:51.542]                         has_future <- base::requireNamespace("future", 
[16:13:51.542]                           quietly = TRUE)
[16:13:51.542]                         if (has_future) {
[16:13:51.542]                           ns <- base::getNamespace("future")
[16:13:51.542]                           version <- ns[[".package"]][["version"]]
[16:13:51.542]                           if (is.null(version)) 
[16:13:51.542]                             version <- utils::packageVersion("future")
[16:13:51.542]                         }
[16:13:51.542]                         else {
[16:13:51.542]                           version <- NULL
[16:13:51.542]                         }
[16:13:51.542]                         if (!has_future || version < "1.8.0") {
[16:13:51.542]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:51.542]                             "", base::R.version$version.string), 
[16:13:51.542]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:51.542]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:51.542]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:51.542]                               "release", "version")], collapse = " "), 
[16:13:51.542]                             hostname = base::Sys.info()[["nodename"]])
[16:13:51.542]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:51.542]                             info)
[16:13:51.542]                           info <- base::paste(info, collapse = "; ")
[16:13:51.542]                           if (!has_future) {
[16:13:51.542]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:51.542]                               info)
[16:13:51.542]                           }
[16:13:51.542]                           else {
[16:13:51.542]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:51.542]                               info, version)
[16:13:51.542]                           }
[16:13:51.542]                           base::stop(msg)
[16:13:51.542]                         }
[16:13:51.542]                       })
[16:13:51.542]                     }
[16:13:51.542]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:51.542]                     base::options(mc.cores = 1L)
[16:13:51.542]                   }
[16:13:51.542]                   options(future.plan = NULL)
[16:13:51.542]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:51.542]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:51.542]                 }
[16:13:51.542]                 ...future.workdir <- getwd()
[16:13:51.542]             }
[16:13:51.542]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:51.542]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:51.542]         }
[16:13:51.542]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:51.542]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:51.542]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:51.542]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:51.542]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:51.542]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:51.542]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:51.542]             base::names(...future.oldOptions))
[16:13:51.542]     }
[16:13:51.542]     if (FALSE) {
[16:13:51.542]     }
[16:13:51.542]     else {
[16:13:51.542]         if (TRUE) {
[16:13:51.542]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:51.542]                 open = "w")
[16:13:51.542]         }
[16:13:51.542]         else {
[16:13:51.542]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:51.542]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:51.542]         }
[16:13:51.542]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:51.542]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:51.542]             base::sink(type = "output", split = FALSE)
[16:13:51.542]             base::close(...future.stdout)
[16:13:51.542]         }, add = TRUE)
[16:13:51.542]     }
[16:13:51.542]     ...future.frame <- base::sys.nframe()
[16:13:51.542]     ...future.conditions <- base::list()
[16:13:51.542]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:51.542]     if (FALSE) {
[16:13:51.542]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:51.542]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:51.542]     }
[16:13:51.542]     ...future.result <- base::tryCatch({
[16:13:51.542]         base::withCallingHandlers({
[16:13:51.542]             ...future.value <- base::withVisible(base::local({
[16:13:51.542]                 ...future.makeSendCondition <- local({
[16:13:51.542]                   sendCondition <- NULL
[16:13:51.542]                   function(frame = 1L) {
[16:13:51.542]                     if (is.function(sendCondition)) 
[16:13:51.542]                       return(sendCondition)
[16:13:51.542]                     ns <- getNamespace("parallel")
[16:13:51.542]                     if (exists("sendData", mode = "function", 
[16:13:51.542]                       envir = ns)) {
[16:13:51.542]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:51.542]                         envir = ns)
[16:13:51.542]                       envir <- sys.frame(frame)
[16:13:51.542]                       master <- NULL
[16:13:51.542]                       while (!identical(envir, .GlobalEnv) && 
[16:13:51.542]                         !identical(envir, emptyenv())) {
[16:13:51.542]                         if (exists("master", mode = "list", envir = envir, 
[16:13:51.542]                           inherits = FALSE)) {
[16:13:51.542]                           master <- get("master", mode = "list", 
[16:13:51.542]                             envir = envir, inherits = FALSE)
[16:13:51.542]                           if (inherits(master, c("SOCKnode", 
[16:13:51.542]                             "SOCK0node"))) {
[16:13:51.542]                             sendCondition <<- function(cond) {
[16:13:51.542]                               data <- list(type = "VALUE", value = cond, 
[16:13:51.542]                                 success = TRUE)
[16:13:51.542]                               parallel_sendData(master, data)
[16:13:51.542]                             }
[16:13:51.542]                             return(sendCondition)
[16:13:51.542]                           }
[16:13:51.542]                         }
[16:13:51.542]                         frame <- frame + 1L
[16:13:51.542]                         envir <- sys.frame(frame)
[16:13:51.542]                       }
[16:13:51.542]                     }
[16:13:51.542]                     sendCondition <<- function(cond) NULL
[16:13:51.542]                   }
[16:13:51.542]                 })
[16:13:51.542]                 withCallingHandlers({
[16:13:51.542]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:51.542]                 }, immediateCondition = function(cond) {
[16:13:51.542]                   sendCondition <- ...future.makeSendCondition()
[16:13:51.542]                   sendCondition(cond)
[16:13:51.542]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:51.542]                   {
[16:13:51.542]                     inherits <- base::inherits
[16:13:51.542]                     invokeRestart <- base::invokeRestart
[16:13:51.542]                     is.null <- base::is.null
[16:13:51.542]                     muffled <- FALSE
[16:13:51.542]                     if (inherits(cond, "message")) {
[16:13:51.542]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:51.542]                       if (muffled) 
[16:13:51.542]                         invokeRestart("muffleMessage")
[16:13:51.542]                     }
[16:13:51.542]                     else if (inherits(cond, "warning")) {
[16:13:51.542]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:51.542]                       if (muffled) 
[16:13:51.542]                         invokeRestart("muffleWarning")
[16:13:51.542]                     }
[16:13:51.542]                     else if (inherits(cond, "condition")) {
[16:13:51.542]                       if (!is.null(pattern)) {
[16:13:51.542]                         computeRestarts <- base::computeRestarts
[16:13:51.542]                         grepl <- base::grepl
[16:13:51.542]                         restarts <- computeRestarts(cond)
[16:13:51.542]                         for (restart in restarts) {
[16:13:51.542]                           name <- restart$name
[16:13:51.542]                           if (is.null(name)) 
[16:13:51.542]                             next
[16:13:51.542]                           if (!grepl(pattern, name)) 
[16:13:51.542]                             next
[16:13:51.542]                           invokeRestart(restart)
[16:13:51.542]                           muffled <- TRUE
[16:13:51.542]                           break
[16:13:51.542]                         }
[16:13:51.542]                       }
[16:13:51.542]                     }
[16:13:51.542]                     invisible(muffled)
[16:13:51.542]                   }
[16:13:51.542]                   muffleCondition(cond)
[16:13:51.542]                 })
[16:13:51.542]             }))
[16:13:51.542]             future::FutureResult(value = ...future.value$value, 
[16:13:51.542]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:51.542]                   ...future.rng), globalenv = if (FALSE) 
[16:13:51.542]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:51.542]                     ...future.globalenv.names))
[16:13:51.542]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:51.542]         }, condition = base::local({
[16:13:51.542]             c <- base::c
[16:13:51.542]             inherits <- base::inherits
[16:13:51.542]             invokeRestart <- base::invokeRestart
[16:13:51.542]             length <- base::length
[16:13:51.542]             list <- base::list
[16:13:51.542]             seq.int <- base::seq.int
[16:13:51.542]             signalCondition <- base::signalCondition
[16:13:51.542]             sys.calls <- base::sys.calls
[16:13:51.542]             `[[` <- base::`[[`
[16:13:51.542]             `+` <- base::`+`
[16:13:51.542]             `<<-` <- base::`<<-`
[16:13:51.542]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:51.542]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:51.542]                   3L)]
[16:13:51.542]             }
[16:13:51.542]             function(cond) {
[16:13:51.542]                 is_error <- inherits(cond, "error")
[16:13:51.542]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:51.542]                   NULL)
[16:13:51.542]                 if (is_error) {
[16:13:51.542]                   sessionInformation <- function() {
[16:13:51.542]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:51.542]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:51.542]                       search = base::search(), system = base::Sys.info())
[16:13:51.542]                   }
[16:13:51.542]                   ...future.conditions[[length(...future.conditions) + 
[16:13:51.542]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:51.542]                     cond$call), session = sessionInformation(), 
[16:13:51.542]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:51.542]                   signalCondition(cond)
[16:13:51.542]                 }
[16:13:51.542]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:51.542]                 "immediateCondition"))) {
[16:13:51.542]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:51.542]                   ...future.conditions[[length(...future.conditions) + 
[16:13:51.542]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:51.542]                   if (TRUE && !signal) {
[16:13:51.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:51.542]                     {
[16:13:51.542]                       inherits <- base::inherits
[16:13:51.542]                       invokeRestart <- base::invokeRestart
[16:13:51.542]                       is.null <- base::is.null
[16:13:51.542]                       muffled <- FALSE
[16:13:51.542]                       if (inherits(cond, "message")) {
[16:13:51.542]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:51.542]                         if (muffled) 
[16:13:51.542]                           invokeRestart("muffleMessage")
[16:13:51.542]                       }
[16:13:51.542]                       else if (inherits(cond, "warning")) {
[16:13:51.542]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:51.542]                         if (muffled) 
[16:13:51.542]                           invokeRestart("muffleWarning")
[16:13:51.542]                       }
[16:13:51.542]                       else if (inherits(cond, "condition")) {
[16:13:51.542]                         if (!is.null(pattern)) {
[16:13:51.542]                           computeRestarts <- base::computeRestarts
[16:13:51.542]                           grepl <- base::grepl
[16:13:51.542]                           restarts <- computeRestarts(cond)
[16:13:51.542]                           for (restart in restarts) {
[16:13:51.542]                             name <- restart$name
[16:13:51.542]                             if (is.null(name)) 
[16:13:51.542]                               next
[16:13:51.542]                             if (!grepl(pattern, name)) 
[16:13:51.542]                               next
[16:13:51.542]                             invokeRestart(restart)
[16:13:51.542]                             muffled <- TRUE
[16:13:51.542]                             break
[16:13:51.542]                           }
[16:13:51.542]                         }
[16:13:51.542]                       }
[16:13:51.542]                       invisible(muffled)
[16:13:51.542]                     }
[16:13:51.542]                     muffleCondition(cond, pattern = "^muffle")
[16:13:51.542]                   }
[16:13:51.542]                 }
[16:13:51.542]                 else {
[16:13:51.542]                   if (TRUE) {
[16:13:51.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:51.542]                     {
[16:13:51.542]                       inherits <- base::inherits
[16:13:51.542]                       invokeRestart <- base::invokeRestart
[16:13:51.542]                       is.null <- base::is.null
[16:13:51.542]                       muffled <- FALSE
[16:13:51.542]                       if (inherits(cond, "message")) {
[16:13:51.542]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:51.542]                         if (muffled) 
[16:13:51.542]                           invokeRestart("muffleMessage")
[16:13:51.542]                       }
[16:13:51.542]                       else if (inherits(cond, "warning")) {
[16:13:51.542]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:51.542]                         if (muffled) 
[16:13:51.542]                           invokeRestart("muffleWarning")
[16:13:51.542]                       }
[16:13:51.542]                       else if (inherits(cond, "condition")) {
[16:13:51.542]                         if (!is.null(pattern)) {
[16:13:51.542]                           computeRestarts <- base::computeRestarts
[16:13:51.542]                           grepl <- base::grepl
[16:13:51.542]                           restarts <- computeRestarts(cond)
[16:13:51.542]                           for (restart in restarts) {
[16:13:51.542]                             name <- restart$name
[16:13:51.542]                             if (is.null(name)) 
[16:13:51.542]                               next
[16:13:51.542]                             if (!grepl(pattern, name)) 
[16:13:51.542]                               next
[16:13:51.542]                             invokeRestart(restart)
[16:13:51.542]                             muffled <- TRUE
[16:13:51.542]                             break
[16:13:51.542]                           }
[16:13:51.542]                         }
[16:13:51.542]                       }
[16:13:51.542]                       invisible(muffled)
[16:13:51.542]                     }
[16:13:51.542]                     muffleCondition(cond, pattern = "^muffle")
[16:13:51.542]                   }
[16:13:51.542]                 }
[16:13:51.542]             }
[16:13:51.542]         }))
[16:13:51.542]     }, error = function(ex) {
[16:13:51.542]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:51.542]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:51.542]                 ...future.rng), started = ...future.startTime, 
[16:13:51.542]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:51.542]             version = "1.8"), class = "FutureResult")
[16:13:51.542]     }, finally = {
[16:13:51.542]         if (!identical(...future.workdir, getwd())) 
[16:13:51.542]             setwd(...future.workdir)
[16:13:51.542]         {
[16:13:51.542]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:51.542]                 ...future.oldOptions$nwarnings <- NULL
[16:13:51.542]             }
[16:13:51.542]             base::options(...future.oldOptions)
[16:13:51.542]             if (.Platform$OS.type == "windows") {
[16:13:51.542]                 old_names <- names(...future.oldEnvVars)
[16:13:51.542]                 envs <- base::Sys.getenv()
[16:13:51.542]                 names <- names(envs)
[16:13:51.542]                 common <- intersect(names, old_names)
[16:13:51.542]                 added <- setdiff(names, old_names)
[16:13:51.542]                 removed <- setdiff(old_names, names)
[16:13:51.542]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:51.542]                   envs[common]]
[16:13:51.542]                 NAMES <- toupper(changed)
[16:13:51.542]                 args <- list()
[16:13:51.542]                 for (kk in seq_along(NAMES)) {
[16:13:51.542]                   name <- changed[[kk]]
[16:13:51.542]                   NAME <- NAMES[[kk]]
[16:13:51.542]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:51.542]                     next
[16:13:51.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:51.542]                 }
[16:13:51.542]                 NAMES <- toupper(added)
[16:13:51.542]                 for (kk in seq_along(NAMES)) {
[16:13:51.542]                   name <- added[[kk]]
[16:13:51.542]                   NAME <- NAMES[[kk]]
[16:13:51.542]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:51.542]                     next
[16:13:51.542]                   args[[name]] <- ""
[16:13:51.542]                 }
[16:13:51.542]                 NAMES <- toupper(removed)
[16:13:51.542]                 for (kk in seq_along(NAMES)) {
[16:13:51.542]                   name <- removed[[kk]]
[16:13:51.542]                   NAME <- NAMES[[kk]]
[16:13:51.542]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:51.542]                     next
[16:13:51.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:51.542]                 }
[16:13:51.542]                 if (length(args) > 0) 
[16:13:51.542]                   base::do.call(base::Sys.setenv, args = args)
[16:13:51.542]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:51.542]             }
[16:13:51.542]             else {
[16:13:51.542]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:51.542]             }
[16:13:51.542]             {
[16:13:51.542]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:51.542]                   0L) {
[16:13:51.542]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:51.542]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:51.542]                   base::options(opts)
[16:13:51.542]                 }
[16:13:51.542]                 {
[16:13:51.542]                   {
[16:13:51.542]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:51.542]                     NULL
[16:13:51.542]                   }
[16:13:51.542]                   options(future.plan = NULL)
[16:13:51.542]                   if (is.na(NA_character_)) 
[16:13:51.542]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:51.542]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:51.542]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:51.542]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:51.542]                     envir = parent.frame()) 
[16:13:51.542]                   {
[16:13:51.542]                     if (is.function(workers)) 
[16:13:51.542]                       workers <- workers()
[16:13:51.542]                     workers <- structure(as.integer(workers), 
[16:13:51.542]                       class = class(workers))
[16:13:51.542]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:51.542]                       workers >= 1)
[16:13:51.542]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:51.542]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:51.542]                     }
[16:13:51.542]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:51.542]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:51.542]                       envir = envir)
[16:13:51.542]                     if (!future$lazy) 
[16:13:51.542]                       future <- run(future)
[16:13:51.542]                     invisible(future)
[16:13:51.542]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:51.542]                 }
[16:13:51.542]             }
[16:13:51.542]         }
[16:13:51.542]     })
[16:13:51.542]     if (TRUE) {
[16:13:51.542]         base::sink(type = "output", split = FALSE)
[16:13:51.542]         if (TRUE) {
[16:13:51.542]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:51.542]         }
[16:13:51.542]         else {
[16:13:51.542]             ...future.result["stdout"] <- base::list(NULL)
[16:13:51.542]         }
[16:13:51.542]         base::close(...future.stdout)
[16:13:51.542]         ...future.stdout <- NULL
[16:13:51.542]     }
[16:13:51.542]     ...future.result$conditions <- ...future.conditions
[16:13:51.542]     ...future.result$finished <- base::Sys.time()
[16:13:51.542]     ...future.result
[16:13:51.542] }
[16:13:51.545] MultisessionFuture started
[16:13:51.545] - Launch lazy future ... done
[16:13:51.546] run() for ‘MultisessionFuture’ ... done
[16:13:51.592] receiveMessageFromWorker() for ClusterFuture ...
[16:13:51.593] - Validating connection of MultisessionFuture
[16:13:51.593] - received message: FutureResult
[16:13:51.593] - Received FutureResult
[16:13:51.593] - Erased future from FutureRegistry
[16:13:51.594] result() for ClusterFuture ...
[16:13:51.594] - result already collected: FutureResult
[16:13:51.594] result() for ClusterFuture ... done
[16:13:51.594] signalConditions() ...
[16:13:51.594]  - include = ‘immediateCondition’
[16:13:51.594]  - exclude = 
[16:13:51.594]  - resignal = FALSE
[16:13:51.594]  - Number of conditions: 1
[16:13:51.594] signalConditions() ... done
[16:13:51.594] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:51.594] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = Inf ... DONE
- result = TRUE, recursive = FALSE ...
[16:13:51.595] getGlobalsAndPackages() ...
[16:13:51.595] Searching for globals...
[16:13:51.596] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:51.596] Searching for globals ... DONE
[16:13:51.596] Resolving globals: FALSE
[16:13:51.597] 
[16:13:51.597] 
[16:13:51.597] getGlobalsAndPackages() ... DONE
[16:13:51.597] run() for ‘Future’ ...
[16:13:51.597] - state: ‘created’
[16:13:51.597] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:51.611] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:51.612] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:51.612]   - Field: ‘node’
[16:13:51.612]   - Field: ‘label’
[16:13:51.612]   - Field: ‘local’
[16:13:51.612]   - Field: ‘owner’
[16:13:51.612]   - Field: ‘envir’
[16:13:51.612]   - Field: ‘workers’
[16:13:51.612]   - Field: ‘packages’
[16:13:51.612]   - Field: ‘gc’
[16:13:51.613]   - Field: ‘conditions’
[16:13:51.613]   - Field: ‘persistent’
[16:13:51.613]   - Field: ‘expr’
[16:13:51.613]   - Field: ‘uuid’
[16:13:51.613]   - Field: ‘seed’
[16:13:51.613]   - Field: ‘version’
[16:13:51.613]   - Field: ‘result’
[16:13:51.613]   - Field: ‘asynchronous’
[16:13:51.613]   - Field: ‘calls’
[16:13:51.613]   - Field: ‘globals’
[16:13:51.613]   - Field: ‘stdout’
[16:13:51.614]   - Field: ‘earlySignal’
[16:13:51.614]   - Field: ‘lazy’
[16:13:51.614]   - Field: ‘state’
[16:13:51.614] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:51.614] - Launch lazy future ...
[16:13:51.614] Packages needed by the future expression (n = 0): <none>
[16:13:51.614] Packages needed by future strategies (n = 0): <none>
[16:13:51.615] {
[16:13:51.615]     {
[16:13:51.615]         {
[16:13:51.615]             ...future.startTime <- base::Sys.time()
[16:13:51.615]             {
[16:13:51.615]                 {
[16:13:51.615]                   {
[16:13:51.615]                     {
[16:13:51.615]                       base::local({
[16:13:51.615]                         has_future <- base::requireNamespace("future", 
[16:13:51.615]                           quietly = TRUE)
[16:13:51.615]                         if (has_future) {
[16:13:51.615]                           ns <- base::getNamespace("future")
[16:13:51.615]                           version <- ns[[".package"]][["version"]]
[16:13:51.615]                           if (is.null(version)) 
[16:13:51.615]                             version <- utils::packageVersion("future")
[16:13:51.615]                         }
[16:13:51.615]                         else {
[16:13:51.615]                           version <- NULL
[16:13:51.615]                         }
[16:13:51.615]                         if (!has_future || version < "1.8.0") {
[16:13:51.615]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:51.615]                             "", base::R.version$version.string), 
[16:13:51.615]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:51.615]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:51.615]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:51.615]                               "release", "version")], collapse = " "), 
[16:13:51.615]                             hostname = base::Sys.info()[["nodename"]])
[16:13:51.615]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:51.615]                             info)
[16:13:51.615]                           info <- base::paste(info, collapse = "; ")
[16:13:51.615]                           if (!has_future) {
[16:13:51.615]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:51.615]                               info)
[16:13:51.615]                           }
[16:13:51.615]                           else {
[16:13:51.615]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:51.615]                               info, version)
[16:13:51.615]                           }
[16:13:51.615]                           base::stop(msg)
[16:13:51.615]                         }
[16:13:51.615]                       })
[16:13:51.615]                     }
[16:13:51.615]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:51.615]                     base::options(mc.cores = 1L)
[16:13:51.615]                   }
[16:13:51.615]                   options(future.plan = NULL)
[16:13:51.615]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:51.615]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:51.615]                 }
[16:13:51.615]                 ...future.workdir <- getwd()
[16:13:51.615]             }
[16:13:51.615]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:51.615]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:51.615]         }
[16:13:51.615]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:51.615]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:51.615]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:51.615]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:51.615]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:51.615]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:51.615]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:51.615]             base::names(...future.oldOptions))
[16:13:51.615]     }
[16:13:51.615]     if (FALSE) {
[16:13:51.615]     }
[16:13:51.615]     else {
[16:13:51.615]         if (TRUE) {
[16:13:51.615]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:51.615]                 open = "w")
[16:13:51.615]         }
[16:13:51.615]         else {
[16:13:51.615]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:51.615]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:51.615]         }
[16:13:51.615]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:51.615]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:51.615]             base::sink(type = "output", split = FALSE)
[16:13:51.615]             base::close(...future.stdout)
[16:13:51.615]         }, add = TRUE)
[16:13:51.615]     }
[16:13:51.615]     ...future.frame <- base::sys.nframe()
[16:13:51.615]     ...future.conditions <- base::list()
[16:13:51.615]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:51.615]     if (FALSE) {
[16:13:51.615]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:51.615]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:51.615]     }
[16:13:51.615]     ...future.result <- base::tryCatch({
[16:13:51.615]         base::withCallingHandlers({
[16:13:51.615]             ...future.value <- base::withVisible(base::local({
[16:13:51.615]                 ...future.makeSendCondition <- local({
[16:13:51.615]                   sendCondition <- NULL
[16:13:51.615]                   function(frame = 1L) {
[16:13:51.615]                     if (is.function(sendCondition)) 
[16:13:51.615]                       return(sendCondition)
[16:13:51.615]                     ns <- getNamespace("parallel")
[16:13:51.615]                     if (exists("sendData", mode = "function", 
[16:13:51.615]                       envir = ns)) {
[16:13:51.615]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:51.615]                         envir = ns)
[16:13:51.615]                       envir <- sys.frame(frame)
[16:13:51.615]                       master <- NULL
[16:13:51.615]                       while (!identical(envir, .GlobalEnv) && 
[16:13:51.615]                         !identical(envir, emptyenv())) {
[16:13:51.615]                         if (exists("master", mode = "list", envir = envir, 
[16:13:51.615]                           inherits = FALSE)) {
[16:13:51.615]                           master <- get("master", mode = "list", 
[16:13:51.615]                             envir = envir, inherits = FALSE)
[16:13:51.615]                           if (inherits(master, c("SOCKnode", 
[16:13:51.615]                             "SOCK0node"))) {
[16:13:51.615]                             sendCondition <<- function(cond) {
[16:13:51.615]                               data <- list(type = "VALUE", value = cond, 
[16:13:51.615]                                 success = TRUE)
[16:13:51.615]                               parallel_sendData(master, data)
[16:13:51.615]                             }
[16:13:51.615]                             return(sendCondition)
[16:13:51.615]                           }
[16:13:51.615]                         }
[16:13:51.615]                         frame <- frame + 1L
[16:13:51.615]                         envir <- sys.frame(frame)
[16:13:51.615]                       }
[16:13:51.615]                     }
[16:13:51.615]                     sendCondition <<- function(cond) NULL
[16:13:51.615]                   }
[16:13:51.615]                 })
[16:13:51.615]                 withCallingHandlers({
[16:13:51.615]                   {
[16:13:51.615]                     Sys.sleep(0.5)
[16:13:51.615]                     list(a = 1, b = 42L)
[16:13:51.615]                   }
[16:13:51.615]                 }, immediateCondition = function(cond) {
[16:13:51.615]                   sendCondition <- ...future.makeSendCondition()
[16:13:51.615]                   sendCondition(cond)
[16:13:51.615]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:51.615]                   {
[16:13:51.615]                     inherits <- base::inherits
[16:13:51.615]                     invokeRestart <- base::invokeRestart
[16:13:51.615]                     is.null <- base::is.null
[16:13:51.615]                     muffled <- FALSE
[16:13:51.615]                     if (inherits(cond, "message")) {
[16:13:51.615]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:51.615]                       if (muffled) 
[16:13:51.615]                         invokeRestart("muffleMessage")
[16:13:51.615]                     }
[16:13:51.615]                     else if (inherits(cond, "warning")) {
[16:13:51.615]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:51.615]                       if (muffled) 
[16:13:51.615]                         invokeRestart("muffleWarning")
[16:13:51.615]                     }
[16:13:51.615]                     else if (inherits(cond, "condition")) {
[16:13:51.615]                       if (!is.null(pattern)) {
[16:13:51.615]                         computeRestarts <- base::computeRestarts
[16:13:51.615]                         grepl <- base::grepl
[16:13:51.615]                         restarts <- computeRestarts(cond)
[16:13:51.615]                         for (restart in restarts) {
[16:13:51.615]                           name <- restart$name
[16:13:51.615]                           if (is.null(name)) 
[16:13:51.615]                             next
[16:13:51.615]                           if (!grepl(pattern, name)) 
[16:13:51.615]                             next
[16:13:51.615]                           invokeRestart(restart)
[16:13:51.615]                           muffled <- TRUE
[16:13:51.615]                           break
[16:13:51.615]                         }
[16:13:51.615]                       }
[16:13:51.615]                     }
[16:13:51.615]                     invisible(muffled)
[16:13:51.615]                   }
[16:13:51.615]                   muffleCondition(cond)
[16:13:51.615]                 })
[16:13:51.615]             }))
[16:13:51.615]             future::FutureResult(value = ...future.value$value, 
[16:13:51.615]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:51.615]                   ...future.rng), globalenv = if (FALSE) 
[16:13:51.615]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:51.615]                     ...future.globalenv.names))
[16:13:51.615]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:51.615]         }, condition = base::local({
[16:13:51.615]             c <- base::c
[16:13:51.615]             inherits <- base::inherits
[16:13:51.615]             invokeRestart <- base::invokeRestart
[16:13:51.615]             length <- base::length
[16:13:51.615]             list <- base::list
[16:13:51.615]             seq.int <- base::seq.int
[16:13:51.615]             signalCondition <- base::signalCondition
[16:13:51.615]             sys.calls <- base::sys.calls
[16:13:51.615]             `[[` <- base::`[[`
[16:13:51.615]             `+` <- base::`+`
[16:13:51.615]             `<<-` <- base::`<<-`
[16:13:51.615]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:51.615]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:51.615]                   3L)]
[16:13:51.615]             }
[16:13:51.615]             function(cond) {
[16:13:51.615]                 is_error <- inherits(cond, "error")
[16:13:51.615]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:51.615]                   NULL)
[16:13:51.615]                 if (is_error) {
[16:13:51.615]                   sessionInformation <- function() {
[16:13:51.615]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:51.615]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:51.615]                       search = base::search(), system = base::Sys.info())
[16:13:51.615]                   }
[16:13:51.615]                   ...future.conditions[[length(...future.conditions) + 
[16:13:51.615]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:51.615]                     cond$call), session = sessionInformation(), 
[16:13:51.615]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:51.615]                   signalCondition(cond)
[16:13:51.615]                 }
[16:13:51.615]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:51.615]                 "immediateCondition"))) {
[16:13:51.615]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:51.615]                   ...future.conditions[[length(...future.conditions) + 
[16:13:51.615]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:51.615]                   if (TRUE && !signal) {
[16:13:51.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:51.615]                     {
[16:13:51.615]                       inherits <- base::inherits
[16:13:51.615]                       invokeRestart <- base::invokeRestart
[16:13:51.615]                       is.null <- base::is.null
[16:13:51.615]                       muffled <- FALSE
[16:13:51.615]                       if (inherits(cond, "message")) {
[16:13:51.615]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:51.615]                         if (muffled) 
[16:13:51.615]                           invokeRestart("muffleMessage")
[16:13:51.615]                       }
[16:13:51.615]                       else if (inherits(cond, "warning")) {
[16:13:51.615]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:51.615]                         if (muffled) 
[16:13:51.615]                           invokeRestart("muffleWarning")
[16:13:51.615]                       }
[16:13:51.615]                       else if (inherits(cond, "condition")) {
[16:13:51.615]                         if (!is.null(pattern)) {
[16:13:51.615]                           computeRestarts <- base::computeRestarts
[16:13:51.615]                           grepl <- base::grepl
[16:13:51.615]                           restarts <- computeRestarts(cond)
[16:13:51.615]                           for (restart in restarts) {
[16:13:51.615]                             name <- restart$name
[16:13:51.615]                             if (is.null(name)) 
[16:13:51.615]                               next
[16:13:51.615]                             if (!grepl(pattern, name)) 
[16:13:51.615]                               next
[16:13:51.615]                             invokeRestart(restart)
[16:13:51.615]                             muffled <- TRUE
[16:13:51.615]                             break
[16:13:51.615]                           }
[16:13:51.615]                         }
[16:13:51.615]                       }
[16:13:51.615]                       invisible(muffled)
[16:13:51.615]                     }
[16:13:51.615]                     muffleCondition(cond, pattern = "^muffle")
[16:13:51.615]                   }
[16:13:51.615]                 }
[16:13:51.615]                 else {
[16:13:51.615]                   if (TRUE) {
[16:13:51.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:51.615]                     {
[16:13:51.615]                       inherits <- base::inherits
[16:13:51.615]                       invokeRestart <- base::invokeRestart
[16:13:51.615]                       is.null <- base::is.null
[16:13:51.615]                       muffled <- FALSE
[16:13:51.615]                       if (inherits(cond, "message")) {
[16:13:51.615]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:51.615]                         if (muffled) 
[16:13:51.615]                           invokeRestart("muffleMessage")
[16:13:51.615]                       }
[16:13:51.615]                       else if (inherits(cond, "warning")) {
[16:13:51.615]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:51.615]                         if (muffled) 
[16:13:51.615]                           invokeRestart("muffleWarning")
[16:13:51.615]                       }
[16:13:51.615]                       else if (inherits(cond, "condition")) {
[16:13:51.615]                         if (!is.null(pattern)) {
[16:13:51.615]                           computeRestarts <- base::computeRestarts
[16:13:51.615]                           grepl <- base::grepl
[16:13:51.615]                           restarts <- computeRestarts(cond)
[16:13:51.615]                           for (restart in restarts) {
[16:13:51.615]                             name <- restart$name
[16:13:51.615]                             if (is.null(name)) 
[16:13:51.615]                               next
[16:13:51.615]                             if (!grepl(pattern, name)) 
[16:13:51.615]                               next
[16:13:51.615]                             invokeRestart(restart)
[16:13:51.615]                             muffled <- TRUE
[16:13:51.615]                             break
[16:13:51.615]                           }
[16:13:51.615]                         }
[16:13:51.615]                       }
[16:13:51.615]                       invisible(muffled)
[16:13:51.615]                     }
[16:13:51.615]                     muffleCondition(cond, pattern = "^muffle")
[16:13:51.615]                   }
[16:13:51.615]                 }
[16:13:51.615]             }
[16:13:51.615]         }))
[16:13:51.615]     }, error = function(ex) {
[16:13:51.615]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:51.615]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:51.615]                 ...future.rng), started = ...future.startTime, 
[16:13:51.615]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:51.615]             version = "1.8"), class = "FutureResult")
[16:13:51.615]     }, finally = {
[16:13:51.615]         if (!identical(...future.workdir, getwd())) 
[16:13:51.615]             setwd(...future.workdir)
[16:13:51.615]         {
[16:13:51.615]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:51.615]                 ...future.oldOptions$nwarnings <- NULL
[16:13:51.615]             }
[16:13:51.615]             base::options(...future.oldOptions)
[16:13:51.615]             if (.Platform$OS.type == "windows") {
[16:13:51.615]                 old_names <- names(...future.oldEnvVars)
[16:13:51.615]                 envs <- base::Sys.getenv()
[16:13:51.615]                 names <- names(envs)
[16:13:51.615]                 common <- intersect(names, old_names)
[16:13:51.615]                 added <- setdiff(names, old_names)
[16:13:51.615]                 removed <- setdiff(old_names, names)
[16:13:51.615]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:51.615]                   envs[common]]
[16:13:51.615]                 NAMES <- toupper(changed)
[16:13:51.615]                 args <- list()
[16:13:51.615]                 for (kk in seq_along(NAMES)) {
[16:13:51.615]                   name <- changed[[kk]]
[16:13:51.615]                   NAME <- NAMES[[kk]]
[16:13:51.615]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:51.615]                     next
[16:13:51.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:51.615]                 }
[16:13:51.615]                 NAMES <- toupper(added)
[16:13:51.615]                 for (kk in seq_along(NAMES)) {
[16:13:51.615]                   name <- added[[kk]]
[16:13:51.615]                   NAME <- NAMES[[kk]]
[16:13:51.615]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:51.615]                     next
[16:13:51.615]                   args[[name]] <- ""
[16:13:51.615]                 }
[16:13:51.615]                 NAMES <- toupper(removed)
[16:13:51.615]                 for (kk in seq_along(NAMES)) {
[16:13:51.615]                   name <- removed[[kk]]
[16:13:51.615]                   NAME <- NAMES[[kk]]
[16:13:51.615]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:51.615]                     next
[16:13:51.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:51.615]                 }
[16:13:51.615]                 if (length(args) > 0) 
[16:13:51.615]                   base::do.call(base::Sys.setenv, args = args)
[16:13:51.615]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:51.615]             }
[16:13:51.615]             else {
[16:13:51.615]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:51.615]             }
[16:13:51.615]             {
[16:13:51.615]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:51.615]                   0L) {
[16:13:51.615]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:51.615]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:51.615]                   base::options(opts)
[16:13:51.615]                 }
[16:13:51.615]                 {
[16:13:51.615]                   {
[16:13:51.615]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:51.615]                     NULL
[16:13:51.615]                   }
[16:13:51.615]                   options(future.plan = NULL)
[16:13:51.615]                   if (is.na(NA_character_)) 
[16:13:51.615]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:51.615]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:51.615]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:51.615]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:51.615]                     envir = parent.frame()) 
[16:13:51.615]                   {
[16:13:51.615]                     if (is.function(workers)) 
[16:13:51.615]                       workers <- workers()
[16:13:51.615]                     workers <- structure(as.integer(workers), 
[16:13:51.615]                       class = class(workers))
[16:13:51.615]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:51.615]                       workers >= 1)
[16:13:51.615]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:51.615]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:51.615]                     }
[16:13:51.615]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:51.615]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:51.615]                       envir = envir)
[16:13:51.615]                     if (!future$lazy) 
[16:13:51.615]                       future <- run(future)
[16:13:51.615]                     invisible(future)
[16:13:51.615]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:51.615]                 }
[16:13:51.615]             }
[16:13:51.615]         }
[16:13:51.615]     })
[16:13:51.615]     if (TRUE) {
[16:13:51.615]         base::sink(type = "output", split = FALSE)
[16:13:51.615]         if (TRUE) {
[16:13:51.615]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:51.615]         }
[16:13:51.615]         else {
[16:13:51.615]             ...future.result["stdout"] <- base::list(NULL)
[16:13:51.615]         }
[16:13:51.615]         base::close(...future.stdout)
[16:13:51.615]         ...future.stdout <- NULL
[16:13:51.615]     }
[16:13:51.615]     ...future.result$conditions <- ...future.conditions
[16:13:51.615]     ...future.result$finished <- base::Sys.time()
[16:13:51.615]     ...future.result
[16:13:51.615] }
[16:13:51.618] MultisessionFuture started
[16:13:51.618] - Launch lazy future ... done
[16:13:51.618] run() for ‘MultisessionFuture’ ... done
[16:13:52.166] receiveMessageFromWorker() for ClusterFuture ...
[16:13:52.166] - Validating connection of MultisessionFuture
[16:13:52.166] - received message: FutureResult
[16:13:52.166] - Received FutureResult
[16:13:52.166] - Erased future from FutureRegistry
[16:13:52.167] result() for ClusterFuture ...
[16:13:52.167] - result already collected: FutureResult
[16:13:52.167] result() for ClusterFuture ... done
[16:13:52.167] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:52.167] A MultisessionFuture was resolved
[16:13:52.167] getGlobalsAndPackages() ...
[16:13:52.167] Searching for globals...
[16:13:52.168] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:52.169] Searching for globals ... DONE
[16:13:52.169] Resolving globals: FALSE
[16:13:52.169] 
[16:13:52.169] 
[16:13:52.169] getGlobalsAndPackages() ... DONE
[16:13:52.169] run() for ‘Future’ ...
[16:13:52.170] - state: ‘created’
[16:13:52.170] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:52.184] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:52.184] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:52.184]   - Field: ‘node’
[16:13:52.184]   - Field: ‘label’
[16:13:52.185]   - Field: ‘local’
[16:13:52.185]   - Field: ‘owner’
[16:13:52.185]   - Field: ‘envir’
[16:13:52.185]   - Field: ‘workers’
[16:13:52.185]   - Field: ‘packages’
[16:13:52.185]   - Field: ‘gc’
[16:13:52.185]   - Field: ‘conditions’
[16:13:52.185]   - Field: ‘persistent’
[16:13:52.185]   - Field: ‘expr’
[16:13:52.185]   - Field: ‘uuid’
[16:13:52.185]   - Field: ‘seed’
[16:13:52.185]   - Field: ‘version’
[16:13:52.186]   - Field: ‘result’
[16:13:52.186]   - Field: ‘asynchronous’
[16:13:52.186]   - Field: ‘calls’
[16:13:52.186]   - Field: ‘globals’
[16:13:52.186]   - Field: ‘stdout’
[16:13:52.186]   - Field: ‘earlySignal’
[16:13:52.186]   - Field: ‘lazy’
[16:13:52.186]   - Field: ‘state’
[16:13:52.186] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:52.186] - Launch lazy future ...
[16:13:52.187] Packages needed by the future expression (n = 0): <none>
[16:13:52.187] Packages needed by future strategies (n = 0): <none>
[16:13:52.187] {
[16:13:52.187]     {
[16:13:52.187]         {
[16:13:52.187]             ...future.startTime <- base::Sys.time()
[16:13:52.187]             {
[16:13:52.187]                 {
[16:13:52.187]                   {
[16:13:52.187]                     {
[16:13:52.187]                       base::local({
[16:13:52.187]                         has_future <- base::requireNamespace("future", 
[16:13:52.187]                           quietly = TRUE)
[16:13:52.187]                         if (has_future) {
[16:13:52.187]                           ns <- base::getNamespace("future")
[16:13:52.187]                           version <- ns[[".package"]][["version"]]
[16:13:52.187]                           if (is.null(version)) 
[16:13:52.187]                             version <- utils::packageVersion("future")
[16:13:52.187]                         }
[16:13:52.187]                         else {
[16:13:52.187]                           version <- NULL
[16:13:52.187]                         }
[16:13:52.187]                         if (!has_future || version < "1.8.0") {
[16:13:52.187]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:52.187]                             "", base::R.version$version.string), 
[16:13:52.187]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:52.187]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:52.187]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:52.187]                               "release", "version")], collapse = " "), 
[16:13:52.187]                             hostname = base::Sys.info()[["nodename"]])
[16:13:52.187]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:52.187]                             info)
[16:13:52.187]                           info <- base::paste(info, collapse = "; ")
[16:13:52.187]                           if (!has_future) {
[16:13:52.187]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:52.187]                               info)
[16:13:52.187]                           }
[16:13:52.187]                           else {
[16:13:52.187]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:52.187]                               info, version)
[16:13:52.187]                           }
[16:13:52.187]                           base::stop(msg)
[16:13:52.187]                         }
[16:13:52.187]                       })
[16:13:52.187]                     }
[16:13:52.187]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:52.187]                     base::options(mc.cores = 1L)
[16:13:52.187]                   }
[16:13:52.187]                   options(future.plan = NULL)
[16:13:52.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:52.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:52.187]                 }
[16:13:52.187]                 ...future.workdir <- getwd()
[16:13:52.187]             }
[16:13:52.187]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:52.187]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:52.187]         }
[16:13:52.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:52.187]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:52.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:52.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:52.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:52.187]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:52.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:52.187]             base::names(...future.oldOptions))
[16:13:52.187]     }
[16:13:52.187]     if (FALSE) {
[16:13:52.187]     }
[16:13:52.187]     else {
[16:13:52.187]         if (TRUE) {
[16:13:52.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:52.187]                 open = "w")
[16:13:52.187]         }
[16:13:52.187]         else {
[16:13:52.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:52.187]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:52.187]         }
[16:13:52.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:52.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:52.187]             base::sink(type = "output", split = FALSE)
[16:13:52.187]             base::close(...future.stdout)
[16:13:52.187]         }, add = TRUE)
[16:13:52.187]     }
[16:13:52.187]     ...future.frame <- base::sys.nframe()
[16:13:52.187]     ...future.conditions <- base::list()
[16:13:52.187]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:52.187]     if (FALSE) {
[16:13:52.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:52.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:52.187]     }
[16:13:52.187]     ...future.result <- base::tryCatch({
[16:13:52.187]         base::withCallingHandlers({
[16:13:52.187]             ...future.value <- base::withVisible(base::local({
[16:13:52.187]                 ...future.makeSendCondition <- local({
[16:13:52.187]                   sendCondition <- NULL
[16:13:52.187]                   function(frame = 1L) {
[16:13:52.187]                     if (is.function(sendCondition)) 
[16:13:52.187]                       return(sendCondition)
[16:13:52.187]                     ns <- getNamespace("parallel")
[16:13:52.187]                     if (exists("sendData", mode = "function", 
[16:13:52.187]                       envir = ns)) {
[16:13:52.187]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:52.187]                         envir = ns)
[16:13:52.187]                       envir <- sys.frame(frame)
[16:13:52.187]                       master <- NULL
[16:13:52.187]                       while (!identical(envir, .GlobalEnv) && 
[16:13:52.187]                         !identical(envir, emptyenv())) {
[16:13:52.187]                         if (exists("master", mode = "list", envir = envir, 
[16:13:52.187]                           inherits = FALSE)) {
[16:13:52.187]                           master <- get("master", mode = "list", 
[16:13:52.187]                             envir = envir, inherits = FALSE)
[16:13:52.187]                           if (inherits(master, c("SOCKnode", 
[16:13:52.187]                             "SOCK0node"))) {
[16:13:52.187]                             sendCondition <<- function(cond) {
[16:13:52.187]                               data <- list(type = "VALUE", value = cond, 
[16:13:52.187]                                 success = TRUE)
[16:13:52.187]                               parallel_sendData(master, data)
[16:13:52.187]                             }
[16:13:52.187]                             return(sendCondition)
[16:13:52.187]                           }
[16:13:52.187]                         }
[16:13:52.187]                         frame <- frame + 1L
[16:13:52.187]                         envir <- sys.frame(frame)
[16:13:52.187]                       }
[16:13:52.187]                     }
[16:13:52.187]                     sendCondition <<- function(cond) NULL
[16:13:52.187]                   }
[16:13:52.187]                 })
[16:13:52.187]                 withCallingHandlers({
[16:13:52.187]                   {
[16:13:52.187]                     Sys.sleep(0.5)
[16:13:52.187]                     list(a = 1, b = 42L)
[16:13:52.187]                   }
[16:13:52.187]                 }, immediateCondition = function(cond) {
[16:13:52.187]                   sendCondition <- ...future.makeSendCondition()
[16:13:52.187]                   sendCondition(cond)
[16:13:52.187]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:52.187]                   {
[16:13:52.187]                     inherits <- base::inherits
[16:13:52.187]                     invokeRestart <- base::invokeRestart
[16:13:52.187]                     is.null <- base::is.null
[16:13:52.187]                     muffled <- FALSE
[16:13:52.187]                     if (inherits(cond, "message")) {
[16:13:52.187]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:52.187]                       if (muffled) 
[16:13:52.187]                         invokeRestart("muffleMessage")
[16:13:52.187]                     }
[16:13:52.187]                     else if (inherits(cond, "warning")) {
[16:13:52.187]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:52.187]                       if (muffled) 
[16:13:52.187]                         invokeRestart("muffleWarning")
[16:13:52.187]                     }
[16:13:52.187]                     else if (inherits(cond, "condition")) {
[16:13:52.187]                       if (!is.null(pattern)) {
[16:13:52.187]                         computeRestarts <- base::computeRestarts
[16:13:52.187]                         grepl <- base::grepl
[16:13:52.187]                         restarts <- computeRestarts(cond)
[16:13:52.187]                         for (restart in restarts) {
[16:13:52.187]                           name <- restart$name
[16:13:52.187]                           if (is.null(name)) 
[16:13:52.187]                             next
[16:13:52.187]                           if (!grepl(pattern, name)) 
[16:13:52.187]                             next
[16:13:52.187]                           invokeRestart(restart)
[16:13:52.187]                           muffled <- TRUE
[16:13:52.187]                           break
[16:13:52.187]                         }
[16:13:52.187]                       }
[16:13:52.187]                     }
[16:13:52.187]                     invisible(muffled)
[16:13:52.187]                   }
[16:13:52.187]                   muffleCondition(cond)
[16:13:52.187]                 })
[16:13:52.187]             }))
[16:13:52.187]             future::FutureResult(value = ...future.value$value, 
[16:13:52.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:52.187]                   ...future.rng), globalenv = if (FALSE) 
[16:13:52.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:52.187]                     ...future.globalenv.names))
[16:13:52.187]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:52.187]         }, condition = base::local({
[16:13:52.187]             c <- base::c
[16:13:52.187]             inherits <- base::inherits
[16:13:52.187]             invokeRestart <- base::invokeRestart
[16:13:52.187]             length <- base::length
[16:13:52.187]             list <- base::list
[16:13:52.187]             seq.int <- base::seq.int
[16:13:52.187]             signalCondition <- base::signalCondition
[16:13:52.187]             sys.calls <- base::sys.calls
[16:13:52.187]             `[[` <- base::`[[`
[16:13:52.187]             `+` <- base::`+`
[16:13:52.187]             `<<-` <- base::`<<-`
[16:13:52.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:52.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:52.187]                   3L)]
[16:13:52.187]             }
[16:13:52.187]             function(cond) {
[16:13:52.187]                 is_error <- inherits(cond, "error")
[16:13:52.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:52.187]                   NULL)
[16:13:52.187]                 if (is_error) {
[16:13:52.187]                   sessionInformation <- function() {
[16:13:52.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:52.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:52.187]                       search = base::search(), system = base::Sys.info())
[16:13:52.187]                   }
[16:13:52.187]                   ...future.conditions[[length(...future.conditions) + 
[16:13:52.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:52.187]                     cond$call), session = sessionInformation(), 
[16:13:52.187]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:52.187]                   signalCondition(cond)
[16:13:52.187]                 }
[16:13:52.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:52.187]                 "immediateCondition"))) {
[16:13:52.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:52.187]                   ...future.conditions[[length(...future.conditions) + 
[16:13:52.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:52.187]                   if (TRUE && !signal) {
[16:13:52.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:52.187]                     {
[16:13:52.187]                       inherits <- base::inherits
[16:13:52.187]                       invokeRestart <- base::invokeRestart
[16:13:52.187]                       is.null <- base::is.null
[16:13:52.187]                       muffled <- FALSE
[16:13:52.187]                       if (inherits(cond, "message")) {
[16:13:52.187]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:52.187]                         if (muffled) 
[16:13:52.187]                           invokeRestart("muffleMessage")
[16:13:52.187]                       }
[16:13:52.187]                       else if (inherits(cond, "warning")) {
[16:13:52.187]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:52.187]                         if (muffled) 
[16:13:52.187]                           invokeRestart("muffleWarning")
[16:13:52.187]                       }
[16:13:52.187]                       else if (inherits(cond, "condition")) {
[16:13:52.187]                         if (!is.null(pattern)) {
[16:13:52.187]                           computeRestarts <- base::computeRestarts
[16:13:52.187]                           grepl <- base::grepl
[16:13:52.187]                           restarts <- computeRestarts(cond)
[16:13:52.187]                           for (restart in restarts) {
[16:13:52.187]                             name <- restart$name
[16:13:52.187]                             if (is.null(name)) 
[16:13:52.187]                               next
[16:13:52.187]                             if (!grepl(pattern, name)) 
[16:13:52.187]                               next
[16:13:52.187]                             invokeRestart(restart)
[16:13:52.187]                             muffled <- TRUE
[16:13:52.187]                             break
[16:13:52.187]                           }
[16:13:52.187]                         }
[16:13:52.187]                       }
[16:13:52.187]                       invisible(muffled)
[16:13:52.187]                     }
[16:13:52.187]                     muffleCondition(cond, pattern = "^muffle")
[16:13:52.187]                   }
[16:13:52.187]                 }
[16:13:52.187]                 else {
[16:13:52.187]                   if (TRUE) {
[16:13:52.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:52.187]                     {
[16:13:52.187]                       inherits <- base::inherits
[16:13:52.187]                       invokeRestart <- base::invokeRestart
[16:13:52.187]                       is.null <- base::is.null
[16:13:52.187]                       muffled <- FALSE
[16:13:52.187]                       if (inherits(cond, "message")) {
[16:13:52.187]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:52.187]                         if (muffled) 
[16:13:52.187]                           invokeRestart("muffleMessage")
[16:13:52.187]                       }
[16:13:52.187]                       else if (inherits(cond, "warning")) {
[16:13:52.187]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:52.187]                         if (muffled) 
[16:13:52.187]                           invokeRestart("muffleWarning")
[16:13:52.187]                       }
[16:13:52.187]                       else if (inherits(cond, "condition")) {
[16:13:52.187]                         if (!is.null(pattern)) {
[16:13:52.187]                           computeRestarts <- base::computeRestarts
[16:13:52.187]                           grepl <- base::grepl
[16:13:52.187]                           restarts <- computeRestarts(cond)
[16:13:52.187]                           for (restart in restarts) {
[16:13:52.187]                             name <- restart$name
[16:13:52.187]                             if (is.null(name)) 
[16:13:52.187]                               next
[16:13:52.187]                             if (!grepl(pattern, name)) 
[16:13:52.187]                               next
[16:13:52.187]                             invokeRestart(restart)
[16:13:52.187]                             muffled <- TRUE
[16:13:52.187]                             break
[16:13:52.187]                           }
[16:13:52.187]                         }
[16:13:52.187]                       }
[16:13:52.187]                       invisible(muffled)
[16:13:52.187]                     }
[16:13:52.187]                     muffleCondition(cond, pattern = "^muffle")
[16:13:52.187]                   }
[16:13:52.187]                 }
[16:13:52.187]             }
[16:13:52.187]         }))
[16:13:52.187]     }, error = function(ex) {
[16:13:52.187]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:52.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:52.187]                 ...future.rng), started = ...future.startTime, 
[16:13:52.187]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:52.187]             version = "1.8"), class = "FutureResult")
[16:13:52.187]     }, finally = {
[16:13:52.187]         if (!identical(...future.workdir, getwd())) 
[16:13:52.187]             setwd(...future.workdir)
[16:13:52.187]         {
[16:13:52.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:52.187]                 ...future.oldOptions$nwarnings <- NULL
[16:13:52.187]             }
[16:13:52.187]             base::options(...future.oldOptions)
[16:13:52.187]             if (.Platform$OS.type == "windows") {
[16:13:52.187]                 old_names <- names(...future.oldEnvVars)
[16:13:52.187]                 envs <- base::Sys.getenv()
[16:13:52.187]                 names <- names(envs)
[16:13:52.187]                 common <- intersect(names, old_names)
[16:13:52.187]                 added <- setdiff(names, old_names)
[16:13:52.187]                 removed <- setdiff(old_names, names)
[16:13:52.187]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:52.187]                   envs[common]]
[16:13:52.187]                 NAMES <- toupper(changed)
[16:13:52.187]                 args <- list()
[16:13:52.187]                 for (kk in seq_along(NAMES)) {
[16:13:52.187]                   name <- changed[[kk]]
[16:13:52.187]                   NAME <- NAMES[[kk]]
[16:13:52.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:52.187]                     next
[16:13:52.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:52.187]                 }
[16:13:52.187]                 NAMES <- toupper(added)
[16:13:52.187]                 for (kk in seq_along(NAMES)) {
[16:13:52.187]                   name <- added[[kk]]
[16:13:52.187]                   NAME <- NAMES[[kk]]
[16:13:52.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:52.187]                     next
[16:13:52.187]                   args[[name]] <- ""
[16:13:52.187]                 }
[16:13:52.187]                 NAMES <- toupper(removed)
[16:13:52.187]                 for (kk in seq_along(NAMES)) {
[16:13:52.187]                   name <- removed[[kk]]
[16:13:52.187]                   NAME <- NAMES[[kk]]
[16:13:52.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:52.187]                     next
[16:13:52.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:52.187]                 }
[16:13:52.187]                 if (length(args) > 0) 
[16:13:52.187]                   base::do.call(base::Sys.setenv, args = args)
[16:13:52.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:52.187]             }
[16:13:52.187]             else {
[16:13:52.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:52.187]             }
[16:13:52.187]             {
[16:13:52.187]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:52.187]                   0L) {
[16:13:52.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:52.187]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:52.187]                   base::options(opts)
[16:13:52.187]                 }
[16:13:52.187]                 {
[16:13:52.187]                   {
[16:13:52.187]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:52.187]                     NULL
[16:13:52.187]                   }
[16:13:52.187]                   options(future.plan = NULL)
[16:13:52.187]                   if (is.na(NA_character_)) 
[16:13:52.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:52.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:52.187]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:52.187]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:52.187]                     envir = parent.frame()) 
[16:13:52.187]                   {
[16:13:52.187]                     if (is.function(workers)) 
[16:13:52.187]                       workers <- workers()
[16:13:52.187]                     workers <- structure(as.integer(workers), 
[16:13:52.187]                       class = class(workers))
[16:13:52.187]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:52.187]                       workers >= 1)
[16:13:52.187]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:52.187]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:52.187]                     }
[16:13:52.187]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:52.187]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:52.187]                       envir = envir)
[16:13:52.187]                     if (!future$lazy) 
[16:13:52.187]                       future <- run(future)
[16:13:52.187]                     invisible(future)
[16:13:52.187]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:52.187]                 }
[16:13:52.187]             }
[16:13:52.187]         }
[16:13:52.187]     })
[16:13:52.187]     if (TRUE) {
[16:13:52.187]         base::sink(type = "output", split = FALSE)
[16:13:52.187]         if (TRUE) {
[16:13:52.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:52.187]         }
[16:13:52.187]         else {
[16:13:52.187]             ...future.result["stdout"] <- base::list(NULL)
[16:13:52.187]         }
[16:13:52.187]         base::close(...future.stdout)
[16:13:52.187]         ...future.stdout <- NULL
[16:13:52.187]     }
[16:13:52.187]     ...future.result$conditions <- ...future.conditions
[16:13:52.187]     ...future.result$finished <- base::Sys.time()
[16:13:52.187]     ...future.result
[16:13:52.187] }
[16:13:52.190] MultisessionFuture started
[16:13:52.190] - Launch lazy future ... done
[16:13:52.190] run() for ‘MultisessionFuture’ ... done
[16:13:52.738] receiveMessageFromWorker() for ClusterFuture ...
[16:13:52.738] - Validating connection of MultisessionFuture
[16:13:52.739] - received message: FutureResult
[16:13:52.739] - Received FutureResult
[16:13:52.739] - Erased future from FutureRegistry
[16:13:52.739] result() for ClusterFuture ...
[16:13:52.739] - result already collected: FutureResult
[16:13:52.739] result() for ClusterFuture ... done
[16:13:52.739] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:52.739] A MultisessionFuture was resolved
- w/ exception ...
[16:13:52.740] getGlobalsAndPackages() ...
[16:13:52.740] Searching for globals...
[16:13:52.740] - globals found: [2] ‘list’, ‘stop’
[16:13:52.741] Searching for globals ... DONE
[16:13:52.741] Resolving globals: FALSE
[16:13:52.741] 
[16:13:52.741] 
[16:13:52.741] getGlobalsAndPackages() ... DONE
[16:13:52.741] run() for ‘Future’ ...
[16:13:52.742] - state: ‘created’
[16:13:52.742] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:52.756] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:52.756] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:52.756]   - Field: ‘node’
[16:13:52.757]   - Field: ‘label’
[16:13:52.757]   - Field: ‘local’
[16:13:52.757]   - Field: ‘owner’
[16:13:52.757]   - Field: ‘envir’
[16:13:52.757]   - Field: ‘workers’
[16:13:52.757]   - Field: ‘packages’
[16:13:52.757]   - Field: ‘gc’
[16:13:52.757]   - Field: ‘conditions’
[16:13:52.757]   - Field: ‘persistent’
[16:13:52.757]   - Field: ‘expr’
[16:13:52.758]   - Field: ‘uuid’
[16:13:52.758]   - Field: ‘seed’
[16:13:52.758]   - Field: ‘version’
[16:13:52.758]   - Field: ‘result’
[16:13:52.758]   - Field: ‘asynchronous’
[16:13:52.758]   - Field: ‘calls’
[16:13:52.758]   - Field: ‘globals’
[16:13:52.758]   - Field: ‘stdout’
[16:13:52.758]   - Field: ‘earlySignal’
[16:13:52.758]   - Field: ‘lazy’
[16:13:52.758]   - Field: ‘state’
[16:13:52.759] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:52.759] - Launch lazy future ...
[16:13:52.759] Packages needed by the future expression (n = 0): <none>
[16:13:52.759] Packages needed by future strategies (n = 0): <none>
[16:13:52.759] {
[16:13:52.759]     {
[16:13:52.759]         {
[16:13:52.759]             ...future.startTime <- base::Sys.time()
[16:13:52.759]             {
[16:13:52.759]                 {
[16:13:52.759]                   {
[16:13:52.759]                     {
[16:13:52.759]                       base::local({
[16:13:52.759]                         has_future <- base::requireNamespace("future", 
[16:13:52.759]                           quietly = TRUE)
[16:13:52.759]                         if (has_future) {
[16:13:52.759]                           ns <- base::getNamespace("future")
[16:13:52.759]                           version <- ns[[".package"]][["version"]]
[16:13:52.759]                           if (is.null(version)) 
[16:13:52.759]                             version <- utils::packageVersion("future")
[16:13:52.759]                         }
[16:13:52.759]                         else {
[16:13:52.759]                           version <- NULL
[16:13:52.759]                         }
[16:13:52.759]                         if (!has_future || version < "1.8.0") {
[16:13:52.759]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:52.759]                             "", base::R.version$version.string), 
[16:13:52.759]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:52.759]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:52.759]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:52.759]                               "release", "version")], collapse = " "), 
[16:13:52.759]                             hostname = base::Sys.info()[["nodename"]])
[16:13:52.759]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:52.759]                             info)
[16:13:52.759]                           info <- base::paste(info, collapse = "; ")
[16:13:52.759]                           if (!has_future) {
[16:13:52.759]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:52.759]                               info)
[16:13:52.759]                           }
[16:13:52.759]                           else {
[16:13:52.759]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:52.759]                               info, version)
[16:13:52.759]                           }
[16:13:52.759]                           base::stop(msg)
[16:13:52.759]                         }
[16:13:52.759]                       })
[16:13:52.759]                     }
[16:13:52.759]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:52.759]                     base::options(mc.cores = 1L)
[16:13:52.759]                   }
[16:13:52.759]                   options(future.plan = NULL)
[16:13:52.759]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:52.759]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:52.759]                 }
[16:13:52.759]                 ...future.workdir <- getwd()
[16:13:52.759]             }
[16:13:52.759]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:52.759]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:52.759]         }
[16:13:52.759]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:52.759]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:52.759]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:52.759]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:52.759]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:52.759]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:52.759]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:52.759]             base::names(...future.oldOptions))
[16:13:52.759]     }
[16:13:52.759]     if (FALSE) {
[16:13:52.759]     }
[16:13:52.759]     else {
[16:13:52.759]         if (TRUE) {
[16:13:52.759]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:52.759]                 open = "w")
[16:13:52.759]         }
[16:13:52.759]         else {
[16:13:52.759]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:52.759]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:52.759]         }
[16:13:52.759]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:52.759]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:52.759]             base::sink(type = "output", split = FALSE)
[16:13:52.759]             base::close(...future.stdout)
[16:13:52.759]         }, add = TRUE)
[16:13:52.759]     }
[16:13:52.759]     ...future.frame <- base::sys.nframe()
[16:13:52.759]     ...future.conditions <- base::list()
[16:13:52.759]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:52.759]     if (FALSE) {
[16:13:52.759]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:52.759]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:52.759]     }
[16:13:52.759]     ...future.result <- base::tryCatch({
[16:13:52.759]         base::withCallingHandlers({
[16:13:52.759]             ...future.value <- base::withVisible(base::local({
[16:13:52.759]                 ...future.makeSendCondition <- local({
[16:13:52.759]                   sendCondition <- NULL
[16:13:52.759]                   function(frame = 1L) {
[16:13:52.759]                     if (is.function(sendCondition)) 
[16:13:52.759]                       return(sendCondition)
[16:13:52.759]                     ns <- getNamespace("parallel")
[16:13:52.759]                     if (exists("sendData", mode = "function", 
[16:13:52.759]                       envir = ns)) {
[16:13:52.759]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:52.759]                         envir = ns)
[16:13:52.759]                       envir <- sys.frame(frame)
[16:13:52.759]                       master <- NULL
[16:13:52.759]                       while (!identical(envir, .GlobalEnv) && 
[16:13:52.759]                         !identical(envir, emptyenv())) {
[16:13:52.759]                         if (exists("master", mode = "list", envir = envir, 
[16:13:52.759]                           inherits = FALSE)) {
[16:13:52.759]                           master <- get("master", mode = "list", 
[16:13:52.759]                             envir = envir, inherits = FALSE)
[16:13:52.759]                           if (inherits(master, c("SOCKnode", 
[16:13:52.759]                             "SOCK0node"))) {
[16:13:52.759]                             sendCondition <<- function(cond) {
[16:13:52.759]                               data <- list(type = "VALUE", value = cond, 
[16:13:52.759]                                 success = TRUE)
[16:13:52.759]                               parallel_sendData(master, data)
[16:13:52.759]                             }
[16:13:52.759]                             return(sendCondition)
[16:13:52.759]                           }
[16:13:52.759]                         }
[16:13:52.759]                         frame <- frame + 1L
[16:13:52.759]                         envir <- sys.frame(frame)
[16:13:52.759]                       }
[16:13:52.759]                     }
[16:13:52.759]                     sendCondition <<- function(cond) NULL
[16:13:52.759]                   }
[16:13:52.759]                 })
[16:13:52.759]                 withCallingHandlers({
[16:13:52.759]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:52.759]                 }, immediateCondition = function(cond) {
[16:13:52.759]                   sendCondition <- ...future.makeSendCondition()
[16:13:52.759]                   sendCondition(cond)
[16:13:52.759]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:52.759]                   {
[16:13:52.759]                     inherits <- base::inherits
[16:13:52.759]                     invokeRestart <- base::invokeRestart
[16:13:52.759]                     is.null <- base::is.null
[16:13:52.759]                     muffled <- FALSE
[16:13:52.759]                     if (inherits(cond, "message")) {
[16:13:52.759]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:52.759]                       if (muffled) 
[16:13:52.759]                         invokeRestart("muffleMessage")
[16:13:52.759]                     }
[16:13:52.759]                     else if (inherits(cond, "warning")) {
[16:13:52.759]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:52.759]                       if (muffled) 
[16:13:52.759]                         invokeRestart("muffleWarning")
[16:13:52.759]                     }
[16:13:52.759]                     else if (inherits(cond, "condition")) {
[16:13:52.759]                       if (!is.null(pattern)) {
[16:13:52.759]                         computeRestarts <- base::computeRestarts
[16:13:52.759]                         grepl <- base::grepl
[16:13:52.759]                         restarts <- computeRestarts(cond)
[16:13:52.759]                         for (restart in restarts) {
[16:13:52.759]                           name <- restart$name
[16:13:52.759]                           if (is.null(name)) 
[16:13:52.759]                             next
[16:13:52.759]                           if (!grepl(pattern, name)) 
[16:13:52.759]                             next
[16:13:52.759]                           invokeRestart(restart)
[16:13:52.759]                           muffled <- TRUE
[16:13:52.759]                           break
[16:13:52.759]                         }
[16:13:52.759]                       }
[16:13:52.759]                     }
[16:13:52.759]                     invisible(muffled)
[16:13:52.759]                   }
[16:13:52.759]                   muffleCondition(cond)
[16:13:52.759]                 })
[16:13:52.759]             }))
[16:13:52.759]             future::FutureResult(value = ...future.value$value, 
[16:13:52.759]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:52.759]                   ...future.rng), globalenv = if (FALSE) 
[16:13:52.759]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:52.759]                     ...future.globalenv.names))
[16:13:52.759]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:52.759]         }, condition = base::local({
[16:13:52.759]             c <- base::c
[16:13:52.759]             inherits <- base::inherits
[16:13:52.759]             invokeRestart <- base::invokeRestart
[16:13:52.759]             length <- base::length
[16:13:52.759]             list <- base::list
[16:13:52.759]             seq.int <- base::seq.int
[16:13:52.759]             signalCondition <- base::signalCondition
[16:13:52.759]             sys.calls <- base::sys.calls
[16:13:52.759]             `[[` <- base::`[[`
[16:13:52.759]             `+` <- base::`+`
[16:13:52.759]             `<<-` <- base::`<<-`
[16:13:52.759]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:52.759]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:52.759]                   3L)]
[16:13:52.759]             }
[16:13:52.759]             function(cond) {
[16:13:52.759]                 is_error <- inherits(cond, "error")
[16:13:52.759]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:52.759]                   NULL)
[16:13:52.759]                 if (is_error) {
[16:13:52.759]                   sessionInformation <- function() {
[16:13:52.759]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:52.759]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:52.759]                       search = base::search(), system = base::Sys.info())
[16:13:52.759]                   }
[16:13:52.759]                   ...future.conditions[[length(...future.conditions) + 
[16:13:52.759]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:52.759]                     cond$call), session = sessionInformation(), 
[16:13:52.759]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:52.759]                   signalCondition(cond)
[16:13:52.759]                 }
[16:13:52.759]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:52.759]                 "immediateCondition"))) {
[16:13:52.759]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:52.759]                   ...future.conditions[[length(...future.conditions) + 
[16:13:52.759]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:52.759]                   if (TRUE && !signal) {
[16:13:52.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:52.759]                     {
[16:13:52.759]                       inherits <- base::inherits
[16:13:52.759]                       invokeRestart <- base::invokeRestart
[16:13:52.759]                       is.null <- base::is.null
[16:13:52.759]                       muffled <- FALSE
[16:13:52.759]                       if (inherits(cond, "message")) {
[16:13:52.759]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:52.759]                         if (muffled) 
[16:13:52.759]                           invokeRestart("muffleMessage")
[16:13:52.759]                       }
[16:13:52.759]                       else if (inherits(cond, "warning")) {
[16:13:52.759]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:52.759]                         if (muffled) 
[16:13:52.759]                           invokeRestart("muffleWarning")
[16:13:52.759]                       }
[16:13:52.759]                       else if (inherits(cond, "condition")) {
[16:13:52.759]                         if (!is.null(pattern)) {
[16:13:52.759]                           computeRestarts <- base::computeRestarts
[16:13:52.759]                           grepl <- base::grepl
[16:13:52.759]                           restarts <- computeRestarts(cond)
[16:13:52.759]                           for (restart in restarts) {
[16:13:52.759]                             name <- restart$name
[16:13:52.759]                             if (is.null(name)) 
[16:13:52.759]                               next
[16:13:52.759]                             if (!grepl(pattern, name)) 
[16:13:52.759]                               next
[16:13:52.759]                             invokeRestart(restart)
[16:13:52.759]                             muffled <- TRUE
[16:13:52.759]                             break
[16:13:52.759]                           }
[16:13:52.759]                         }
[16:13:52.759]                       }
[16:13:52.759]                       invisible(muffled)
[16:13:52.759]                     }
[16:13:52.759]                     muffleCondition(cond, pattern = "^muffle")
[16:13:52.759]                   }
[16:13:52.759]                 }
[16:13:52.759]                 else {
[16:13:52.759]                   if (TRUE) {
[16:13:52.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:52.759]                     {
[16:13:52.759]                       inherits <- base::inherits
[16:13:52.759]                       invokeRestart <- base::invokeRestart
[16:13:52.759]                       is.null <- base::is.null
[16:13:52.759]                       muffled <- FALSE
[16:13:52.759]                       if (inherits(cond, "message")) {
[16:13:52.759]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:52.759]                         if (muffled) 
[16:13:52.759]                           invokeRestart("muffleMessage")
[16:13:52.759]                       }
[16:13:52.759]                       else if (inherits(cond, "warning")) {
[16:13:52.759]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:52.759]                         if (muffled) 
[16:13:52.759]                           invokeRestart("muffleWarning")
[16:13:52.759]                       }
[16:13:52.759]                       else if (inherits(cond, "condition")) {
[16:13:52.759]                         if (!is.null(pattern)) {
[16:13:52.759]                           computeRestarts <- base::computeRestarts
[16:13:52.759]                           grepl <- base::grepl
[16:13:52.759]                           restarts <- computeRestarts(cond)
[16:13:52.759]                           for (restart in restarts) {
[16:13:52.759]                             name <- restart$name
[16:13:52.759]                             if (is.null(name)) 
[16:13:52.759]                               next
[16:13:52.759]                             if (!grepl(pattern, name)) 
[16:13:52.759]                               next
[16:13:52.759]                             invokeRestart(restart)
[16:13:52.759]                             muffled <- TRUE
[16:13:52.759]                             break
[16:13:52.759]                           }
[16:13:52.759]                         }
[16:13:52.759]                       }
[16:13:52.759]                       invisible(muffled)
[16:13:52.759]                     }
[16:13:52.759]                     muffleCondition(cond, pattern = "^muffle")
[16:13:52.759]                   }
[16:13:52.759]                 }
[16:13:52.759]             }
[16:13:52.759]         }))
[16:13:52.759]     }, error = function(ex) {
[16:13:52.759]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:52.759]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:52.759]                 ...future.rng), started = ...future.startTime, 
[16:13:52.759]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:52.759]             version = "1.8"), class = "FutureResult")
[16:13:52.759]     }, finally = {
[16:13:52.759]         if (!identical(...future.workdir, getwd())) 
[16:13:52.759]             setwd(...future.workdir)
[16:13:52.759]         {
[16:13:52.759]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:52.759]                 ...future.oldOptions$nwarnings <- NULL
[16:13:52.759]             }
[16:13:52.759]             base::options(...future.oldOptions)
[16:13:52.759]             if (.Platform$OS.type == "windows") {
[16:13:52.759]                 old_names <- names(...future.oldEnvVars)
[16:13:52.759]                 envs <- base::Sys.getenv()
[16:13:52.759]                 names <- names(envs)
[16:13:52.759]                 common <- intersect(names, old_names)
[16:13:52.759]                 added <- setdiff(names, old_names)
[16:13:52.759]                 removed <- setdiff(old_names, names)
[16:13:52.759]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:52.759]                   envs[common]]
[16:13:52.759]                 NAMES <- toupper(changed)
[16:13:52.759]                 args <- list()
[16:13:52.759]                 for (kk in seq_along(NAMES)) {
[16:13:52.759]                   name <- changed[[kk]]
[16:13:52.759]                   NAME <- NAMES[[kk]]
[16:13:52.759]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:52.759]                     next
[16:13:52.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:52.759]                 }
[16:13:52.759]                 NAMES <- toupper(added)
[16:13:52.759]                 for (kk in seq_along(NAMES)) {
[16:13:52.759]                   name <- added[[kk]]
[16:13:52.759]                   NAME <- NAMES[[kk]]
[16:13:52.759]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:52.759]                     next
[16:13:52.759]                   args[[name]] <- ""
[16:13:52.759]                 }
[16:13:52.759]                 NAMES <- toupper(removed)
[16:13:52.759]                 for (kk in seq_along(NAMES)) {
[16:13:52.759]                   name <- removed[[kk]]
[16:13:52.759]                   NAME <- NAMES[[kk]]
[16:13:52.759]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:52.759]                     next
[16:13:52.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:52.759]                 }
[16:13:52.759]                 if (length(args) > 0) 
[16:13:52.759]                   base::do.call(base::Sys.setenv, args = args)
[16:13:52.759]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:52.759]             }
[16:13:52.759]             else {
[16:13:52.759]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:52.759]             }
[16:13:52.759]             {
[16:13:52.759]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:52.759]                   0L) {
[16:13:52.759]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:52.759]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:52.759]                   base::options(opts)
[16:13:52.759]                 }
[16:13:52.759]                 {
[16:13:52.759]                   {
[16:13:52.759]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:52.759]                     NULL
[16:13:52.759]                   }
[16:13:52.759]                   options(future.plan = NULL)
[16:13:52.759]                   if (is.na(NA_character_)) 
[16:13:52.759]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:52.759]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:52.759]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:52.759]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:52.759]                     envir = parent.frame()) 
[16:13:52.759]                   {
[16:13:52.759]                     if (is.function(workers)) 
[16:13:52.759]                       workers <- workers()
[16:13:52.759]                     workers <- structure(as.integer(workers), 
[16:13:52.759]                       class = class(workers))
[16:13:52.759]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:52.759]                       workers >= 1)
[16:13:52.759]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:52.759]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:52.759]                     }
[16:13:52.759]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:52.759]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:52.759]                       envir = envir)
[16:13:52.759]                     if (!future$lazy) 
[16:13:52.759]                       future <- run(future)
[16:13:52.759]                     invisible(future)
[16:13:52.759]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:52.759]                 }
[16:13:52.759]             }
[16:13:52.759]         }
[16:13:52.759]     })
[16:13:52.759]     if (TRUE) {
[16:13:52.759]         base::sink(type = "output", split = FALSE)
[16:13:52.759]         if (TRUE) {
[16:13:52.759]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:52.759]         }
[16:13:52.759]         else {
[16:13:52.759]             ...future.result["stdout"] <- base::list(NULL)
[16:13:52.759]         }
[16:13:52.759]         base::close(...future.stdout)
[16:13:52.759]         ...future.stdout <- NULL
[16:13:52.759]     }
[16:13:52.759]     ...future.result$conditions <- ...future.conditions
[16:13:52.759]     ...future.result$finished <- base::Sys.time()
[16:13:52.759]     ...future.result
[16:13:52.759] }
[16:13:52.763] MultisessionFuture started
[16:13:52.763] - Launch lazy future ... done
[16:13:52.763] run() for ‘MultisessionFuture’ ... done
[16:13:52.809] receiveMessageFromWorker() for ClusterFuture ...
[16:13:52.809] - Validating connection of MultisessionFuture
[16:13:52.810] - received message: FutureResult
[16:13:52.810] - Received FutureResult
[16:13:52.810] - Erased future from FutureRegistry
[16:13:52.810] result() for ClusterFuture ...
[16:13:52.810] - result already collected: FutureResult
[16:13:52.810] result() for ClusterFuture ... done
[16:13:52.810] signalConditions() ...
[16:13:52.810]  - include = ‘immediateCondition’
[16:13:52.811]  - exclude = 
[16:13:52.811]  - resignal = FALSE
[16:13:52.811]  - Number of conditions: 1
[16:13:52.811] signalConditions() ... done
[16:13:52.811] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:52.811] A MultisessionFuture was resolved
[16:13:52.811] getGlobalsAndPackages() ...
[16:13:52.811] Searching for globals...
[16:13:52.812] - globals found: [2] ‘list’, ‘stop’
[16:13:52.812] Searching for globals ... DONE
[16:13:52.812] Resolving globals: FALSE
[16:13:52.813] 
[16:13:52.813] 
[16:13:52.813] getGlobalsAndPackages() ... DONE
[16:13:52.813] run() for ‘Future’ ...
[16:13:52.813] - state: ‘created’
[16:13:52.814] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:52.828] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:52.828] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:52.828]   - Field: ‘node’
[16:13:52.828]   - Field: ‘label’
[16:13:52.828]   - Field: ‘local’
[16:13:52.828]   - Field: ‘owner’
[16:13:52.828]   - Field: ‘envir’
[16:13:52.828]   - Field: ‘workers’
[16:13:52.829]   - Field: ‘packages’
[16:13:52.829]   - Field: ‘gc’
[16:13:52.829]   - Field: ‘conditions’
[16:13:52.829]   - Field: ‘persistent’
[16:13:52.829]   - Field: ‘expr’
[16:13:52.829]   - Field: ‘uuid’
[16:13:52.829]   - Field: ‘seed’
[16:13:52.829]   - Field: ‘version’
[16:13:52.829]   - Field: ‘result’
[16:13:52.829]   - Field: ‘asynchronous’
[16:13:52.829]   - Field: ‘calls’
[16:13:52.830]   - Field: ‘globals’
[16:13:52.830]   - Field: ‘stdout’
[16:13:52.830]   - Field: ‘earlySignal’
[16:13:52.830]   - Field: ‘lazy’
[16:13:52.830]   - Field: ‘state’
[16:13:52.830] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:52.830] - Launch lazy future ...
[16:13:52.830] Packages needed by the future expression (n = 0): <none>
[16:13:52.831] Packages needed by future strategies (n = 0): <none>
[16:13:52.831] {
[16:13:52.831]     {
[16:13:52.831]         {
[16:13:52.831]             ...future.startTime <- base::Sys.time()
[16:13:52.831]             {
[16:13:52.831]                 {
[16:13:52.831]                   {
[16:13:52.831]                     {
[16:13:52.831]                       base::local({
[16:13:52.831]                         has_future <- base::requireNamespace("future", 
[16:13:52.831]                           quietly = TRUE)
[16:13:52.831]                         if (has_future) {
[16:13:52.831]                           ns <- base::getNamespace("future")
[16:13:52.831]                           version <- ns[[".package"]][["version"]]
[16:13:52.831]                           if (is.null(version)) 
[16:13:52.831]                             version <- utils::packageVersion("future")
[16:13:52.831]                         }
[16:13:52.831]                         else {
[16:13:52.831]                           version <- NULL
[16:13:52.831]                         }
[16:13:52.831]                         if (!has_future || version < "1.8.0") {
[16:13:52.831]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:52.831]                             "", base::R.version$version.string), 
[16:13:52.831]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:52.831]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:52.831]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:52.831]                               "release", "version")], collapse = " "), 
[16:13:52.831]                             hostname = base::Sys.info()[["nodename"]])
[16:13:52.831]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:52.831]                             info)
[16:13:52.831]                           info <- base::paste(info, collapse = "; ")
[16:13:52.831]                           if (!has_future) {
[16:13:52.831]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:52.831]                               info)
[16:13:52.831]                           }
[16:13:52.831]                           else {
[16:13:52.831]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:52.831]                               info, version)
[16:13:52.831]                           }
[16:13:52.831]                           base::stop(msg)
[16:13:52.831]                         }
[16:13:52.831]                       })
[16:13:52.831]                     }
[16:13:52.831]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:52.831]                     base::options(mc.cores = 1L)
[16:13:52.831]                   }
[16:13:52.831]                   options(future.plan = NULL)
[16:13:52.831]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:52.831]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:52.831]                 }
[16:13:52.831]                 ...future.workdir <- getwd()
[16:13:52.831]             }
[16:13:52.831]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:52.831]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:52.831]         }
[16:13:52.831]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:52.831]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:52.831]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:52.831]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:52.831]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:52.831]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:52.831]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:52.831]             base::names(...future.oldOptions))
[16:13:52.831]     }
[16:13:52.831]     if (FALSE) {
[16:13:52.831]     }
[16:13:52.831]     else {
[16:13:52.831]         if (TRUE) {
[16:13:52.831]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:52.831]                 open = "w")
[16:13:52.831]         }
[16:13:52.831]         else {
[16:13:52.831]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:52.831]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:52.831]         }
[16:13:52.831]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:52.831]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:52.831]             base::sink(type = "output", split = FALSE)
[16:13:52.831]             base::close(...future.stdout)
[16:13:52.831]         }, add = TRUE)
[16:13:52.831]     }
[16:13:52.831]     ...future.frame <- base::sys.nframe()
[16:13:52.831]     ...future.conditions <- base::list()
[16:13:52.831]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:52.831]     if (FALSE) {
[16:13:52.831]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:52.831]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:52.831]     }
[16:13:52.831]     ...future.result <- base::tryCatch({
[16:13:52.831]         base::withCallingHandlers({
[16:13:52.831]             ...future.value <- base::withVisible(base::local({
[16:13:52.831]                 ...future.makeSendCondition <- local({
[16:13:52.831]                   sendCondition <- NULL
[16:13:52.831]                   function(frame = 1L) {
[16:13:52.831]                     if (is.function(sendCondition)) 
[16:13:52.831]                       return(sendCondition)
[16:13:52.831]                     ns <- getNamespace("parallel")
[16:13:52.831]                     if (exists("sendData", mode = "function", 
[16:13:52.831]                       envir = ns)) {
[16:13:52.831]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:52.831]                         envir = ns)
[16:13:52.831]                       envir <- sys.frame(frame)
[16:13:52.831]                       master <- NULL
[16:13:52.831]                       while (!identical(envir, .GlobalEnv) && 
[16:13:52.831]                         !identical(envir, emptyenv())) {
[16:13:52.831]                         if (exists("master", mode = "list", envir = envir, 
[16:13:52.831]                           inherits = FALSE)) {
[16:13:52.831]                           master <- get("master", mode = "list", 
[16:13:52.831]                             envir = envir, inherits = FALSE)
[16:13:52.831]                           if (inherits(master, c("SOCKnode", 
[16:13:52.831]                             "SOCK0node"))) {
[16:13:52.831]                             sendCondition <<- function(cond) {
[16:13:52.831]                               data <- list(type = "VALUE", value = cond, 
[16:13:52.831]                                 success = TRUE)
[16:13:52.831]                               parallel_sendData(master, data)
[16:13:52.831]                             }
[16:13:52.831]                             return(sendCondition)
[16:13:52.831]                           }
[16:13:52.831]                         }
[16:13:52.831]                         frame <- frame + 1L
[16:13:52.831]                         envir <- sys.frame(frame)
[16:13:52.831]                       }
[16:13:52.831]                     }
[16:13:52.831]                     sendCondition <<- function(cond) NULL
[16:13:52.831]                   }
[16:13:52.831]                 })
[16:13:52.831]                 withCallingHandlers({
[16:13:52.831]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:52.831]                 }, immediateCondition = function(cond) {
[16:13:52.831]                   sendCondition <- ...future.makeSendCondition()
[16:13:52.831]                   sendCondition(cond)
[16:13:52.831]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:52.831]                   {
[16:13:52.831]                     inherits <- base::inherits
[16:13:52.831]                     invokeRestart <- base::invokeRestart
[16:13:52.831]                     is.null <- base::is.null
[16:13:52.831]                     muffled <- FALSE
[16:13:52.831]                     if (inherits(cond, "message")) {
[16:13:52.831]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:52.831]                       if (muffled) 
[16:13:52.831]                         invokeRestart("muffleMessage")
[16:13:52.831]                     }
[16:13:52.831]                     else if (inherits(cond, "warning")) {
[16:13:52.831]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:52.831]                       if (muffled) 
[16:13:52.831]                         invokeRestart("muffleWarning")
[16:13:52.831]                     }
[16:13:52.831]                     else if (inherits(cond, "condition")) {
[16:13:52.831]                       if (!is.null(pattern)) {
[16:13:52.831]                         computeRestarts <- base::computeRestarts
[16:13:52.831]                         grepl <- base::grepl
[16:13:52.831]                         restarts <- computeRestarts(cond)
[16:13:52.831]                         for (restart in restarts) {
[16:13:52.831]                           name <- restart$name
[16:13:52.831]                           if (is.null(name)) 
[16:13:52.831]                             next
[16:13:52.831]                           if (!grepl(pattern, name)) 
[16:13:52.831]                             next
[16:13:52.831]                           invokeRestart(restart)
[16:13:52.831]                           muffled <- TRUE
[16:13:52.831]                           break
[16:13:52.831]                         }
[16:13:52.831]                       }
[16:13:52.831]                     }
[16:13:52.831]                     invisible(muffled)
[16:13:52.831]                   }
[16:13:52.831]                   muffleCondition(cond)
[16:13:52.831]                 })
[16:13:52.831]             }))
[16:13:52.831]             future::FutureResult(value = ...future.value$value, 
[16:13:52.831]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:52.831]                   ...future.rng), globalenv = if (FALSE) 
[16:13:52.831]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:52.831]                     ...future.globalenv.names))
[16:13:52.831]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:52.831]         }, condition = base::local({
[16:13:52.831]             c <- base::c
[16:13:52.831]             inherits <- base::inherits
[16:13:52.831]             invokeRestart <- base::invokeRestart
[16:13:52.831]             length <- base::length
[16:13:52.831]             list <- base::list
[16:13:52.831]             seq.int <- base::seq.int
[16:13:52.831]             signalCondition <- base::signalCondition
[16:13:52.831]             sys.calls <- base::sys.calls
[16:13:52.831]             `[[` <- base::`[[`
[16:13:52.831]             `+` <- base::`+`
[16:13:52.831]             `<<-` <- base::`<<-`
[16:13:52.831]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:52.831]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:52.831]                   3L)]
[16:13:52.831]             }
[16:13:52.831]             function(cond) {
[16:13:52.831]                 is_error <- inherits(cond, "error")
[16:13:52.831]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:52.831]                   NULL)
[16:13:52.831]                 if (is_error) {
[16:13:52.831]                   sessionInformation <- function() {
[16:13:52.831]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:52.831]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:52.831]                       search = base::search(), system = base::Sys.info())
[16:13:52.831]                   }
[16:13:52.831]                   ...future.conditions[[length(...future.conditions) + 
[16:13:52.831]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:52.831]                     cond$call), session = sessionInformation(), 
[16:13:52.831]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:52.831]                   signalCondition(cond)
[16:13:52.831]                 }
[16:13:52.831]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:52.831]                 "immediateCondition"))) {
[16:13:52.831]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:52.831]                   ...future.conditions[[length(...future.conditions) + 
[16:13:52.831]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:52.831]                   if (TRUE && !signal) {
[16:13:52.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:52.831]                     {
[16:13:52.831]                       inherits <- base::inherits
[16:13:52.831]                       invokeRestart <- base::invokeRestart
[16:13:52.831]                       is.null <- base::is.null
[16:13:52.831]                       muffled <- FALSE
[16:13:52.831]                       if (inherits(cond, "message")) {
[16:13:52.831]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:52.831]                         if (muffled) 
[16:13:52.831]                           invokeRestart("muffleMessage")
[16:13:52.831]                       }
[16:13:52.831]                       else if (inherits(cond, "warning")) {
[16:13:52.831]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:52.831]                         if (muffled) 
[16:13:52.831]                           invokeRestart("muffleWarning")
[16:13:52.831]                       }
[16:13:52.831]                       else if (inherits(cond, "condition")) {
[16:13:52.831]                         if (!is.null(pattern)) {
[16:13:52.831]                           computeRestarts <- base::computeRestarts
[16:13:52.831]                           grepl <- base::grepl
[16:13:52.831]                           restarts <- computeRestarts(cond)
[16:13:52.831]                           for (restart in restarts) {
[16:13:52.831]                             name <- restart$name
[16:13:52.831]                             if (is.null(name)) 
[16:13:52.831]                               next
[16:13:52.831]                             if (!grepl(pattern, name)) 
[16:13:52.831]                               next
[16:13:52.831]                             invokeRestart(restart)
[16:13:52.831]                             muffled <- TRUE
[16:13:52.831]                             break
[16:13:52.831]                           }
[16:13:52.831]                         }
[16:13:52.831]                       }
[16:13:52.831]                       invisible(muffled)
[16:13:52.831]                     }
[16:13:52.831]                     muffleCondition(cond, pattern = "^muffle")
[16:13:52.831]                   }
[16:13:52.831]                 }
[16:13:52.831]                 else {
[16:13:52.831]                   if (TRUE) {
[16:13:52.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:52.831]                     {
[16:13:52.831]                       inherits <- base::inherits
[16:13:52.831]                       invokeRestart <- base::invokeRestart
[16:13:52.831]                       is.null <- base::is.null
[16:13:52.831]                       muffled <- FALSE
[16:13:52.831]                       if (inherits(cond, "message")) {
[16:13:52.831]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:52.831]                         if (muffled) 
[16:13:52.831]                           invokeRestart("muffleMessage")
[16:13:52.831]                       }
[16:13:52.831]                       else if (inherits(cond, "warning")) {
[16:13:52.831]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:52.831]                         if (muffled) 
[16:13:52.831]                           invokeRestart("muffleWarning")
[16:13:52.831]                       }
[16:13:52.831]                       else if (inherits(cond, "condition")) {
[16:13:52.831]                         if (!is.null(pattern)) {
[16:13:52.831]                           computeRestarts <- base::computeRestarts
[16:13:52.831]                           grepl <- base::grepl
[16:13:52.831]                           restarts <- computeRestarts(cond)
[16:13:52.831]                           for (restart in restarts) {
[16:13:52.831]                             name <- restart$name
[16:13:52.831]                             if (is.null(name)) 
[16:13:52.831]                               next
[16:13:52.831]                             if (!grepl(pattern, name)) 
[16:13:52.831]                               next
[16:13:52.831]                             invokeRestart(restart)
[16:13:52.831]                             muffled <- TRUE
[16:13:52.831]                             break
[16:13:52.831]                           }
[16:13:52.831]                         }
[16:13:52.831]                       }
[16:13:52.831]                       invisible(muffled)
[16:13:52.831]                     }
[16:13:52.831]                     muffleCondition(cond, pattern = "^muffle")
[16:13:52.831]                   }
[16:13:52.831]                 }
[16:13:52.831]             }
[16:13:52.831]         }))
[16:13:52.831]     }, error = function(ex) {
[16:13:52.831]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:52.831]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:52.831]                 ...future.rng), started = ...future.startTime, 
[16:13:52.831]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:52.831]             version = "1.8"), class = "FutureResult")
[16:13:52.831]     }, finally = {
[16:13:52.831]         if (!identical(...future.workdir, getwd())) 
[16:13:52.831]             setwd(...future.workdir)
[16:13:52.831]         {
[16:13:52.831]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:52.831]                 ...future.oldOptions$nwarnings <- NULL
[16:13:52.831]             }
[16:13:52.831]             base::options(...future.oldOptions)
[16:13:52.831]             if (.Platform$OS.type == "windows") {
[16:13:52.831]                 old_names <- names(...future.oldEnvVars)
[16:13:52.831]                 envs <- base::Sys.getenv()
[16:13:52.831]                 names <- names(envs)
[16:13:52.831]                 common <- intersect(names, old_names)
[16:13:52.831]                 added <- setdiff(names, old_names)
[16:13:52.831]                 removed <- setdiff(old_names, names)
[16:13:52.831]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:52.831]                   envs[common]]
[16:13:52.831]                 NAMES <- toupper(changed)
[16:13:52.831]                 args <- list()
[16:13:52.831]                 for (kk in seq_along(NAMES)) {
[16:13:52.831]                   name <- changed[[kk]]
[16:13:52.831]                   NAME <- NAMES[[kk]]
[16:13:52.831]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:52.831]                     next
[16:13:52.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:52.831]                 }
[16:13:52.831]                 NAMES <- toupper(added)
[16:13:52.831]                 for (kk in seq_along(NAMES)) {
[16:13:52.831]                   name <- added[[kk]]
[16:13:52.831]                   NAME <- NAMES[[kk]]
[16:13:52.831]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:52.831]                     next
[16:13:52.831]                   args[[name]] <- ""
[16:13:52.831]                 }
[16:13:52.831]                 NAMES <- toupper(removed)
[16:13:52.831]                 for (kk in seq_along(NAMES)) {
[16:13:52.831]                   name <- removed[[kk]]
[16:13:52.831]                   NAME <- NAMES[[kk]]
[16:13:52.831]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:52.831]                     next
[16:13:52.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:52.831]                 }
[16:13:52.831]                 if (length(args) > 0) 
[16:13:52.831]                   base::do.call(base::Sys.setenv, args = args)
[16:13:52.831]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:52.831]             }
[16:13:52.831]             else {
[16:13:52.831]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:52.831]             }
[16:13:52.831]             {
[16:13:52.831]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:52.831]                   0L) {
[16:13:52.831]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:52.831]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:52.831]                   base::options(opts)
[16:13:52.831]                 }
[16:13:52.831]                 {
[16:13:52.831]                   {
[16:13:52.831]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:52.831]                     NULL
[16:13:52.831]                   }
[16:13:52.831]                   options(future.plan = NULL)
[16:13:52.831]                   if (is.na(NA_character_)) 
[16:13:52.831]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:52.831]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:52.831]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:52.831]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:52.831]                     envir = parent.frame()) 
[16:13:52.831]                   {
[16:13:52.831]                     if (is.function(workers)) 
[16:13:52.831]                       workers <- workers()
[16:13:52.831]                     workers <- structure(as.integer(workers), 
[16:13:52.831]                       class = class(workers))
[16:13:52.831]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:52.831]                       workers >= 1)
[16:13:52.831]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:52.831]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:52.831]                     }
[16:13:52.831]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:52.831]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:52.831]                       envir = envir)
[16:13:52.831]                     if (!future$lazy) 
[16:13:52.831]                       future <- run(future)
[16:13:52.831]                     invisible(future)
[16:13:52.831]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:52.831]                 }
[16:13:52.831]             }
[16:13:52.831]         }
[16:13:52.831]     })
[16:13:52.831]     if (TRUE) {
[16:13:52.831]         base::sink(type = "output", split = FALSE)
[16:13:52.831]         if (TRUE) {
[16:13:52.831]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:52.831]         }
[16:13:52.831]         else {
[16:13:52.831]             ...future.result["stdout"] <- base::list(NULL)
[16:13:52.831]         }
[16:13:52.831]         base::close(...future.stdout)
[16:13:52.831]         ...future.stdout <- NULL
[16:13:52.831]     }
[16:13:52.831]     ...future.result$conditions <- ...future.conditions
[16:13:52.831]     ...future.result$finished <- base::Sys.time()
[16:13:52.831]     ...future.result
[16:13:52.831] }
[16:13:52.834] MultisessionFuture started
[16:13:52.834] - Launch lazy future ... done
[16:13:52.834] run() for ‘MultisessionFuture’ ... done
[16:13:52.885] receiveMessageFromWorker() for ClusterFuture ...
[16:13:52.885] - Validating connection of MultisessionFuture
[16:13:52.886] - received message: FutureResult
[16:13:52.886] - Received FutureResult
[16:13:52.886] - Erased future from FutureRegistry
[16:13:52.886] result() for ClusterFuture ...
[16:13:52.886] - result already collected: FutureResult
[16:13:52.886] result() for ClusterFuture ... done
[16:13:52.887] signalConditions() ...
[16:13:52.887]  - include = ‘immediateCondition’
[16:13:52.887]  - exclude = 
[16:13:52.887]  - resignal = FALSE
[16:13:52.887]  - Number of conditions: 1
[16:13:52.887] signalConditions() ... done
[16:13:52.887] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:52.887] A MultisessionFuture was resolved
- result = TRUE, recursive = FALSE ... DONE
- result = TRUE, recursive = TRUE ...
[16:13:52.888] getGlobalsAndPackages() ...
[16:13:52.888] Searching for globals...
[16:13:52.889] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:52.889] Searching for globals ... DONE
[16:13:52.889] Resolving globals: FALSE
[16:13:52.889] 
[16:13:52.890] 
[16:13:52.890] getGlobalsAndPackages() ... DONE
[16:13:52.890] run() for ‘Future’ ...
[16:13:52.890] - state: ‘created’
[16:13:52.890] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:52.905] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:52.905] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:52.905]   - Field: ‘node’
[16:13:52.905]   - Field: ‘label’
[16:13:52.905]   - Field: ‘local’
[16:13:52.905]   - Field: ‘owner’
[16:13:52.905]   - Field: ‘envir’
[16:13:52.905]   - Field: ‘workers’
[16:13:52.905]   - Field: ‘packages’
[16:13:52.906]   - Field: ‘gc’
[16:13:52.906]   - Field: ‘conditions’
[16:13:52.906]   - Field: ‘persistent’
[16:13:52.906]   - Field: ‘expr’
[16:13:52.906]   - Field: ‘uuid’
[16:13:52.906]   - Field: ‘seed’
[16:13:52.906]   - Field: ‘version’
[16:13:52.906]   - Field: ‘result’
[16:13:52.906]   - Field: ‘asynchronous’
[16:13:52.906]   - Field: ‘calls’
[16:13:52.907]   - Field: ‘globals’
[16:13:52.907]   - Field: ‘stdout’
[16:13:52.907]   - Field: ‘earlySignal’
[16:13:52.907]   - Field: ‘lazy’
[16:13:52.907]   - Field: ‘state’
[16:13:52.907] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:52.907] - Launch lazy future ...
[16:13:52.907] Packages needed by the future expression (n = 0): <none>
[16:13:52.908] Packages needed by future strategies (n = 0): <none>
[16:13:52.908] {
[16:13:52.908]     {
[16:13:52.908]         {
[16:13:52.908]             ...future.startTime <- base::Sys.time()
[16:13:52.908]             {
[16:13:52.908]                 {
[16:13:52.908]                   {
[16:13:52.908]                     {
[16:13:52.908]                       base::local({
[16:13:52.908]                         has_future <- base::requireNamespace("future", 
[16:13:52.908]                           quietly = TRUE)
[16:13:52.908]                         if (has_future) {
[16:13:52.908]                           ns <- base::getNamespace("future")
[16:13:52.908]                           version <- ns[[".package"]][["version"]]
[16:13:52.908]                           if (is.null(version)) 
[16:13:52.908]                             version <- utils::packageVersion("future")
[16:13:52.908]                         }
[16:13:52.908]                         else {
[16:13:52.908]                           version <- NULL
[16:13:52.908]                         }
[16:13:52.908]                         if (!has_future || version < "1.8.0") {
[16:13:52.908]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:52.908]                             "", base::R.version$version.string), 
[16:13:52.908]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:52.908]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:52.908]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:52.908]                               "release", "version")], collapse = " "), 
[16:13:52.908]                             hostname = base::Sys.info()[["nodename"]])
[16:13:52.908]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:52.908]                             info)
[16:13:52.908]                           info <- base::paste(info, collapse = "; ")
[16:13:52.908]                           if (!has_future) {
[16:13:52.908]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:52.908]                               info)
[16:13:52.908]                           }
[16:13:52.908]                           else {
[16:13:52.908]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:52.908]                               info, version)
[16:13:52.908]                           }
[16:13:52.908]                           base::stop(msg)
[16:13:52.908]                         }
[16:13:52.908]                       })
[16:13:52.908]                     }
[16:13:52.908]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:52.908]                     base::options(mc.cores = 1L)
[16:13:52.908]                   }
[16:13:52.908]                   options(future.plan = NULL)
[16:13:52.908]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:52.908]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:52.908]                 }
[16:13:52.908]                 ...future.workdir <- getwd()
[16:13:52.908]             }
[16:13:52.908]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:52.908]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:52.908]         }
[16:13:52.908]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:52.908]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:52.908]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:52.908]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:52.908]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:52.908]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:52.908]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:52.908]             base::names(...future.oldOptions))
[16:13:52.908]     }
[16:13:52.908]     if (FALSE) {
[16:13:52.908]     }
[16:13:52.908]     else {
[16:13:52.908]         if (TRUE) {
[16:13:52.908]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:52.908]                 open = "w")
[16:13:52.908]         }
[16:13:52.908]         else {
[16:13:52.908]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:52.908]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:52.908]         }
[16:13:52.908]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:52.908]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:52.908]             base::sink(type = "output", split = FALSE)
[16:13:52.908]             base::close(...future.stdout)
[16:13:52.908]         }, add = TRUE)
[16:13:52.908]     }
[16:13:52.908]     ...future.frame <- base::sys.nframe()
[16:13:52.908]     ...future.conditions <- base::list()
[16:13:52.908]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:52.908]     if (FALSE) {
[16:13:52.908]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:52.908]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:52.908]     }
[16:13:52.908]     ...future.result <- base::tryCatch({
[16:13:52.908]         base::withCallingHandlers({
[16:13:52.908]             ...future.value <- base::withVisible(base::local({
[16:13:52.908]                 ...future.makeSendCondition <- local({
[16:13:52.908]                   sendCondition <- NULL
[16:13:52.908]                   function(frame = 1L) {
[16:13:52.908]                     if (is.function(sendCondition)) 
[16:13:52.908]                       return(sendCondition)
[16:13:52.908]                     ns <- getNamespace("parallel")
[16:13:52.908]                     if (exists("sendData", mode = "function", 
[16:13:52.908]                       envir = ns)) {
[16:13:52.908]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:52.908]                         envir = ns)
[16:13:52.908]                       envir <- sys.frame(frame)
[16:13:52.908]                       master <- NULL
[16:13:52.908]                       while (!identical(envir, .GlobalEnv) && 
[16:13:52.908]                         !identical(envir, emptyenv())) {
[16:13:52.908]                         if (exists("master", mode = "list", envir = envir, 
[16:13:52.908]                           inherits = FALSE)) {
[16:13:52.908]                           master <- get("master", mode = "list", 
[16:13:52.908]                             envir = envir, inherits = FALSE)
[16:13:52.908]                           if (inherits(master, c("SOCKnode", 
[16:13:52.908]                             "SOCK0node"))) {
[16:13:52.908]                             sendCondition <<- function(cond) {
[16:13:52.908]                               data <- list(type = "VALUE", value = cond, 
[16:13:52.908]                                 success = TRUE)
[16:13:52.908]                               parallel_sendData(master, data)
[16:13:52.908]                             }
[16:13:52.908]                             return(sendCondition)
[16:13:52.908]                           }
[16:13:52.908]                         }
[16:13:52.908]                         frame <- frame + 1L
[16:13:52.908]                         envir <- sys.frame(frame)
[16:13:52.908]                       }
[16:13:52.908]                     }
[16:13:52.908]                     sendCondition <<- function(cond) NULL
[16:13:52.908]                   }
[16:13:52.908]                 })
[16:13:52.908]                 withCallingHandlers({
[16:13:52.908]                   {
[16:13:52.908]                     Sys.sleep(0.5)
[16:13:52.908]                     list(a = 1, b = 42L)
[16:13:52.908]                   }
[16:13:52.908]                 }, immediateCondition = function(cond) {
[16:13:52.908]                   sendCondition <- ...future.makeSendCondition()
[16:13:52.908]                   sendCondition(cond)
[16:13:52.908]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:52.908]                   {
[16:13:52.908]                     inherits <- base::inherits
[16:13:52.908]                     invokeRestart <- base::invokeRestart
[16:13:52.908]                     is.null <- base::is.null
[16:13:52.908]                     muffled <- FALSE
[16:13:52.908]                     if (inherits(cond, "message")) {
[16:13:52.908]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:52.908]                       if (muffled) 
[16:13:52.908]                         invokeRestart("muffleMessage")
[16:13:52.908]                     }
[16:13:52.908]                     else if (inherits(cond, "warning")) {
[16:13:52.908]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:52.908]                       if (muffled) 
[16:13:52.908]                         invokeRestart("muffleWarning")
[16:13:52.908]                     }
[16:13:52.908]                     else if (inherits(cond, "condition")) {
[16:13:52.908]                       if (!is.null(pattern)) {
[16:13:52.908]                         computeRestarts <- base::computeRestarts
[16:13:52.908]                         grepl <- base::grepl
[16:13:52.908]                         restarts <- computeRestarts(cond)
[16:13:52.908]                         for (restart in restarts) {
[16:13:52.908]                           name <- restart$name
[16:13:52.908]                           if (is.null(name)) 
[16:13:52.908]                             next
[16:13:52.908]                           if (!grepl(pattern, name)) 
[16:13:52.908]                             next
[16:13:52.908]                           invokeRestart(restart)
[16:13:52.908]                           muffled <- TRUE
[16:13:52.908]                           break
[16:13:52.908]                         }
[16:13:52.908]                       }
[16:13:52.908]                     }
[16:13:52.908]                     invisible(muffled)
[16:13:52.908]                   }
[16:13:52.908]                   muffleCondition(cond)
[16:13:52.908]                 })
[16:13:52.908]             }))
[16:13:52.908]             future::FutureResult(value = ...future.value$value, 
[16:13:52.908]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:52.908]                   ...future.rng), globalenv = if (FALSE) 
[16:13:52.908]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:52.908]                     ...future.globalenv.names))
[16:13:52.908]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:52.908]         }, condition = base::local({
[16:13:52.908]             c <- base::c
[16:13:52.908]             inherits <- base::inherits
[16:13:52.908]             invokeRestart <- base::invokeRestart
[16:13:52.908]             length <- base::length
[16:13:52.908]             list <- base::list
[16:13:52.908]             seq.int <- base::seq.int
[16:13:52.908]             signalCondition <- base::signalCondition
[16:13:52.908]             sys.calls <- base::sys.calls
[16:13:52.908]             `[[` <- base::`[[`
[16:13:52.908]             `+` <- base::`+`
[16:13:52.908]             `<<-` <- base::`<<-`
[16:13:52.908]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:52.908]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:52.908]                   3L)]
[16:13:52.908]             }
[16:13:52.908]             function(cond) {
[16:13:52.908]                 is_error <- inherits(cond, "error")
[16:13:52.908]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:52.908]                   NULL)
[16:13:52.908]                 if (is_error) {
[16:13:52.908]                   sessionInformation <- function() {
[16:13:52.908]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:52.908]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:52.908]                       search = base::search(), system = base::Sys.info())
[16:13:52.908]                   }
[16:13:52.908]                   ...future.conditions[[length(...future.conditions) + 
[16:13:52.908]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:52.908]                     cond$call), session = sessionInformation(), 
[16:13:52.908]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:52.908]                   signalCondition(cond)
[16:13:52.908]                 }
[16:13:52.908]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:52.908]                 "immediateCondition"))) {
[16:13:52.908]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:52.908]                   ...future.conditions[[length(...future.conditions) + 
[16:13:52.908]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:52.908]                   if (TRUE && !signal) {
[16:13:52.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:52.908]                     {
[16:13:52.908]                       inherits <- base::inherits
[16:13:52.908]                       invokeRestart <- base::invokeRestart
[16:13:52.908]                       is.null <- base::is.null
[16:13:52.908]                       muffled <- FALSE
[16:13:52.908]                       if (inherits(cond, "message")) {
[16:13:52.908]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:52.908]                         if (muffled) 
[16:13:52.908]                           invokeRestart("muffleMessage")
[16:13:52.908]                       }
[16:13:52.908]                       else if (inherits(cond, "warning")) {
[16:13:52.908]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:52.908]                         if (muffled) 
[16:13:52.908]                           invokeRestart("muffleWarning")
[16:13:52.908]                       }
[16:13:52.908]                       else if (inherits(cond, "condition")) {
[16:13:52.908]                         if (!is.null(pattern)) {
[16:13:52.908]                           computeRestarts <- base::computeRestarts
[16:13:52.908]                           grepl <- base::grepl
[16:13:52.908]                           restarts <- computeRestarts(cond)
[16:13:52.908]                           for (restart in restarts) {
[16:13:52.908]                             name <- restart$name
[16:13:52.908]                             if (is.null(name)) 
[16:13:52.908]                               next
[16:13:52.908]                             if (!grepl(pattern, name)) 
[16:13:52.908]                               next
[16:13:52.908]                             invokeRestart(restart)
[16:13:52.908]                             muffled <- TRUE
[16:13:52.908]                             break
[16:13:52.908]                           }
[16:13:52.908]                         }
[16:13:52.908]                       }
[16:13:52.908]                       invisible(muffled)
[16:13:52.908]                     }
[16:13:52.908]                     muffleCondition(cond, pattern = "^muffle")
[16:13:52.908]                   }
[16:13:52.908]                 }
[16:13:52.908]                 else {
[16:13:52.908]                   if (TRUE) {
[16:13:52.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:52.908]                     {
[16:13:52.908]                       inherits <- base::inherits
[16:13:52.908]                       invokeRestart <- base::invokeRestart
[16:13:52.908]                       is.null <- base::is.null
[16:13:52.908]                       muffled <- FALSE
[16:13:52.908]                       if (inherits(cond, "message")) {
[16:13:52.908]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:52.908]                         if (muffled) 
[16:13:52.908]                           invokeRestart("muffleMessage")
[16:13:52.908]                       }
[16:13:52.908]                       else if (inherits(cond, "warning")) {
[16:13:52.908]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:52.908]                         if (muffled) 
[16:13:52.908]                           invokeRestart("muffleWarning")
[16:13:52.908]                       }
[16:13:52.908]                       else if (inherits(cond, "condition")) {
[16:13:52.908]                         if (!is.null(pattern)) {
[16:13:52.908]                           computeRestarts <- base::computeRestarts
[16:13:52.908]                           grepl <- base::grepl
[16:13:52.908]                           restarts <- computeRestarts(cond)
[16:13:52.908]                           for (restart in restarts) {
[16:13:52.908]                             name <- restart$name
[16:13:52.908]                             if (is.null(name)) 
[16:13:52.908]                               next
[16:13:52.908]                             if (!grepl(pattern, name)) 
[16:13:52.908]                               next
[16:13:52.908]                             invokeRestart(restart)
[16:13:52.908]                             muffled <- TRUE
[16:13:52.908]                             break
[16:13:52.908]                           }
[16:13:52.908]                         }
[16:13:52.908]                       }
[16:13:52.908]                       invisible(muffled)
[16:13:52.908]                     }
[16:13:52.908]                     muffleCondition(cond, pattern = "^muffle")
[16:13:52.908]                   }
[16:13:52.908]                 }
[16:13:52.908]             }
[16:13:52.908]         }))
[16:13:52.908]     }, error = function(ex) {
[16:13:52.908]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:52.908]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:52.908]                 ...future.rng), started = ...future.startTime, 
[16:13:52.908]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:52.908]             version = "1.8"), class = "FutureResult")
[16:13:52.908]     }, finally = {
[16:13:52.908]         if (!identical(...future.workdir, getwd())) 
[16:13:52.908]             setwd(...future.workdir)
[16:13:52.908]         {
[16:13:52.908]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:52.908]                 ...future.oldOptions$nwarnings <- NULL
[16:13:52.908]             }
[16:13:52.908]             base::options(...future.oldOptions)
[16:13:52.908]             if (.Platform$OS.type == "windows") {
[16:13:52.908]                 old_names <- names(...future.oldEnvVars)
[16:13:52.908]                 envs <- base::Sys.getenv()
[16:13:52.908]                 names <- names(envs)
[16:13:52.908]                 common <- intersect(names, old_names)
[16:13:52.908]                 added <- setdiff(names, old_names)
[16:13:52.908]                 removed <- setdiff(old_names, names)
[16:13:52.908]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:52.908]                   envs[common]]
[16:13:52.908]                 NAMES <- toupper(changed)
[16:13:52.908]                 args <- list()
[16:13:52.908]                 for (kk in seq_along(NAMES)) {
[16:13:52.908]                   name <- changed[[kk]]
[16:13:52.908]                   NAME <- NAMES[[kk]]
[16:13:52.908]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:52.908]                     next
[16:13:52.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:52.908]                 }
[16:13:52.908]                 NAMES <- toupper(added)
[16:13:52.908]                 for (kk in seq_along(NAMES)) {
[16:13:52.908]                   name <- added[[kk]]
[16:13:52.908]                   NAME <- NAMES[[kk]]
[16:13:52.908]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:52.908]                     next
[16:13:52.908]                   args[[name]] <- ""
[16:13:52.908]                 }
[16:13:52.908]                 NAMES <- toupper(removed)
[16:13:52.908]                 for (kk in seq_along(NAMES)) {
[16:13:52.908]                   name <- removed[[kk]]
[16:13:52.908]                   NAME <- NAMES[[kk]]
[16:13:52.908]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:52.908]                     next
[16:13:52.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:52.908]                 }
[16:13:52.908]                 if (length(args) > 0) 
[16:13:52.908]                   base::do.call(base::Sys.setenv, args = args)
[16:13:52.908]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:52.908]             }
[16:13:52.908]             else {
[16:13:52.908]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:52.908]             }
[16:13:52.908]             {
[16:13:52.908]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:52.908]                   0L) {
[16:13:52.908]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:52.908]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:52.908]                   base::options(opts)
[16:13:52.908]                 }
[16:13:52.908]                 {
[16:13:52.908]                   {
[16:13:52.908]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:52.908]                     NULL
[16:13:52.908]                   }
[16:13:52.908]                   options(future.plan = NULL)
[16:13:52.908]                   if (is.na(NA_character_)) 
[16:13:52.908]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:52.908]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:52.908]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:52.908]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:52.908]                     envir = parent.frame()) 
[16:13:52.908]                   {
[16:13:52.908]                     if (is.function(workers)) 
[16:13:52.908]                       workers <- workers()
[16:13:52.908]                     workers <- structure(as.integer(workers), 
[16:13:52.908]                       class = class(workers))
[16:13:52.908]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:52.908]                       workers >= 1)
[16:13:52.908]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:52.908]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:52.908]                     }
[16:13:52.908]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:52.908]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:52.908]                       envir = envir)
[16:13:52.908]                     if (!future$lazy) 
[16:13:52.908]                       future <- run(future)
[16:13:52.908]                     invisible(future)
[16:13:52.908]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:52.908]                 }
[16:13:52.908]             }
[16:13:52.908]         }
[16:13:52.908]     })
[16:13:52.908]     if (TRUE) {
[16:13:52.908]         base::sink(type = "output", split = FALSE)
[16:13:52.908]         if (TRUE) {
[16:13:52.908]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:52.908]         }
[16:13:52.908]         else {
[16:13:52.908]             ...future.result["stdout"] <- base::list(NULL)
[16:13:52.908]         }
[16:13:52.908]         base::close(...future.stdout)
[16:13:52.908]         ...future.stdout <- NULL
[16:13:52.908]     }
[16:13:52.908]     ...future.result$conditions <- ...future.conditions
[16:13:52.908]     ...future.result$finished <- base::Sys.time()
[16:13:52.908]     ...future.result
[16:13:52.908] }
[16:13:52.911] MultisessionFuture started
[16:13:52.911] - Launch lazy future ... done
[16:13:52.911] run() for ‘MultisessionFuture’ ... done
[16:13:53.458] receiveMessageFromWorker() for ClusterFuture ...
[16:13:53.458] - Validating connection of MultisessionFuture
[16:13:53.458] - received message: FutureResult
[16:13:53.458] - Received FutureResult
[16:13:53.458] - Erased future from FutureRegistry
[16:13:53.458] result() for ClusterFuture ...
[16:13:53.458] - result already collected: FutureResult
[16:13:53.459] result() for ClusterFuture ... done
[16:13:53.459] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:53.459] resolve() on list ...
[16:13:53.459]  recursive: 98
[16:13:53.459]  length: 2
[16:13:53.459]  elements: ‘a’, ‘b’
[16:13:53.459]  length: 1 (resolved future 1)
[16:13:53.459]  length: 0 (resolved future 2)
[16:13:53.459] resolve() on list ... DONE
[16:13:53.460] A MultisessionFuture was resolved (and resolved itself)
[16:13:53.460] getGlobalsAndPackages() ...
[16:13:53.460] Searching for globals...
[16:13:53.461] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:53.461] Searching for globals ... DONE
[16:13:53.461] Resolving globals: FALSE
[16:13:53.462] 
[16:13:53.462] 
[16:13:53.462] getGlobalsAndPackages() ... DONE
[16:13:53.462] run() for ‘Future’ ...
[16:13:53.462] - state: ‘created’
[16:13:53.462] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:53.477] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:53.477] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:53.477]   - Field: ‘node’
[16:13:53.477]   - Field: ‘label’
[16:13:53.477]   - Field: ‘local’
[16:13:53.477]   - Field: ‘owner’
[16:13:53.478]   - Field: ‘envir’
[16:13:53.484]   - Field: ‘workers’
[16:13:53.484]   - Field: ‘packages’
[16:13:53.484]   - Field: ‘gc’
[16:13:53.484]   - Field: ‘conditions’
[16:13:53.484]   - Field: ‘persistent’
[16:13:53.484]   - Field: ‘expr’
[16:13:53.485]   - Field: ‘uuid’
[16:13:53.485]   - Field: ‘seed’
[16:13:53.485]   - Field: ‘version’
[16:13:53.485]   - Field: ‘result’
[16:13:53.485]   - Field: ‘asynchronous’
[16:13:53.485]   - Field: ‘calls’
[16:13:53.485]   - Field: ‘globals’
[16:13:53.485]   - Field: ‘stdout’
[16:13:53.485]   - Field: ‘earlySignal’
[16:13:53.486]   - Field: ‘lazy’
[16:13:53.486]   - Field: ‘state’
[16:13:53.486] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:53.486] - Launch lazy future ...
[16:13:53.486] Packages needed by the future expression (n = 0): <none>
[16:13:53.486] Packages needed by future strategies (n = 0): <none>
[16:13:53.487] {
[16:13:53.487]     {
[16:13:53.487]         {
[16:13:53.487]             ...future.startTime <- base::Sys.time()
[16:13:53.487]             {
[16:13:53.487]                 {
[16:13:53.487]                   {
[16:13:53.487]                     {
[16:13:53.487]                       base::local({
[16:13:53.487]                         has_future <- base::requireNamespace("future", 
[16:13:53.487]                           quietly = TRUE)
[16:13:53.487]                         if (has_future) {
[16:13:53.487]                           ns <- base::getNamespace("future")
[16:13:53.487]                           version <- ns[[".package"]][["version"]]
[16:13:53.487]                           if (is.null(version)) 
[16:13:53.487]                             version <- utils::packageVersion("future")
[16:13:53.487]                         }
[16:13:53.487]                         else {
[16:13:53.487]                           version <- NULL
[16:13:53.487]                         }
[16:13:53.487]                         if (!has_future || version < "1.8.0") {
[16:13:53.487]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:53.487]                             "", base::R.version$version.string), 
[16:13:53.487]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:53.487]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:53.487]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:53.487]                               "release", "version")], collapse = " "), 
[16:13:53.487]                             hostname = base::Sys.info()[["nodename"]])
[16:13:53.487]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:53.487]                             info)
[16:13:53.487]                           info <- base::paste(info, collapse = "; ")
[16:13:53.487]                           if (!has_future) {
[16:13:53.487]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:53.487]                               info)
[16:13:53.487]                           }
[16:13:53.487]                           else {
[16:13:53.487]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:53.487]                               info, version)
[16:13:53.487]                           }
[16:13:53.487]                           base::stop(msg)
[16:13:53.487]                         }
[16:13:53.487]                       })
[16:13:53.487]                     }
[16:13:53.487]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:53.487]                     base::options(mc.cores = 1L)
[16:13:53.487]                   }
[16:13:53.487]                   options(future.plan = NULL)
[16:13:53.487]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:53.487]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:53.487]                 }
[16:13:53.487]                 ...future.workdir <- getwd()
[16:13:53.487]             }
[16:13:53.487]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:53.487]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:53.487]         }
[16:13:53.487]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:53.487]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:53.487]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:53.487]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:53.487]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:53.487]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:53.487]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:53.487]             base::names(...future.oldOptions))
[16:13:53.487]     }
[16:13:53.487]     if (FALSE) {
[16:13:53.487]     }
[16:13:53.487]     else {
[16:13:53.487]         if (TRUE) {
[16:13:53.487]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:53.487]                 open = "w")
[16:13:53.487]         }
[16:13:53.487]         else {
[16:13:53.487]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:53.487]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:53.487]         }
[16:13:53.487]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:53.487]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:53.487]             base::sink(type = "output", split = FALSE)
[16:13:53.487]             base::close(...future.stdout)
[16:13:53.487]         }, add = TRUE)
[16:13:53.487]     }
[16:13:53.487]     ...future.frame <- base::sys.nframe()
[16:13:53.487]     ...future.conditions <- base::list()
[16:13:53.487]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:53.487]     if (FALSE) {
[16:13:53.487]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:53.487]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:53.487]     }
[16:13:53.487]     ...future.result <- base::tryCatch({
[16:13:53.487]         base::withCallingHandlers({
[16:13:53.487]             ...future.value <- base::withVisible(base::local({
[16:13:53.487]                 ...future.makeSendCondition <- local({
[16:13:53.487]                   sendCondition <- NULL
[16:13:53.487]                   function(frame = 1L) {
[16:13:53.487]                     if (is.function(sendCondition)) 
[16:13:53.487]                       return(sendCondition)
[16:13:53.487]                     ns <- getNamespace("parallel")
[16:13:53.487]                     if (exists("sendData", mode = "function", 
[16:13:53.487]                       envir = ns)) {
[16:13:53.487]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:53.487]                         envir = ns)
[16:13:53.487]                       envir <- sys.frame(frame)
[16:13:53.487]                       master <- NULL
[16:13:53.487]                       while (!identical(envir, .GlobalEnv) && 
[16:13:53.487]                         !identical(envir, emptyenv())) {
[16:13:53.487]                         if (exists("master", mode = "list", envir = envir, 
[16:13:53.487]                           inherits = FALSE)) {
[16:13:53.487]                           master <- get("master", mode = "list", 
[16:13:53.487]                             envir = envir, inherits = FALSE)
[16:13:53.487]                           if (inherits(master, c("SOCKnode", 
[16:13:53.487]                             "SOCK0node"))) {
[16:13:53.487]                             sendCondition <<- function(cond) {
[16:13:53.487]                               data <- list(type = "VALUE", value = cond, 
[16:13:53.487]                                 success = TRUE)
[16:13:53.487]                               parallel_sendData(master, data)
[16:13:53.487]                             }
[16:13:53.487]                             return(sendCondition)
[16:13:53.487]                           }
[16:13:53.487]                         }
[16:13:53.487]                         frame <- frame + 1L
[16:13:53.487]                         envir <- sys.frame(frame)
[16:13:53.487]                       }
[16:13:53.487]                     }
[16:13:53.487]                     sendCondition <<- function(cond) NULL
[16:13:53.487]                   }
[16:13:53.487]                 })
[16:13:53.487]                 withCallingHandlers({
[16:13:53.487]                   {
[16:13:53.487]                     Sys.sleep(0.5)
[16:13:53.487]                     list(a = 1, b = 42L)
[16:13:53.487]                   }
[16:13:53.487]                 }, immediateCondition = function(cond) {
[16:13:53.487]                   sendCondition <- ...future.makeSendCondition()
[16:13:53.487]                   sendCondition(cond)
[16:13:53.487]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:53.487]                   {
[16:13:53.487]                     inherits <- base::inherits
[16:13:53.487]                     invokeRestart <- base::invokeRestart
[16:13:53.487]                     is.null <- base::is.null
[16:13:53.487]                     muffled <- FALSE
[16:13:53.487]                     if (inherits(cond, "message")) {
[16:13:53.487]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:53.487]                       if (muffled) 
[16:13:53.487]                         invokeRestart("muffleMessage")
[16:13:53.487]                     }
[16:13:53.487]                     else if (inherits(cond, "warning")) {
[16:13:53.487]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:53.487]                       if (muffled) 
[16:13:53.487]                         invokeRestart("muffleWarning")
[16:13:53.487]                     }
[16:13:53.487]                     else if (inherits(cond, "condition")) {
[16:13:53.487]                       if (!is.null(pattern)) {
[16:13:53.487]                         computeRestarts <- base::computeRestarts
[16:13:53.487]                         grepl <- base::grepl
[16:13:53.487]                         restarts <- computeRestarts(cond)
[16:13:53.487]                         for (restart in restarts) {
[16:13:53.487]                           name <- restart$name
[16:13:53.487]                           if (is.null(name)) 
[16:13:53.487]                             next
[16:13:53.487]                           if (!grepl(pattern, name)) 
[16:13:53.487]                             next
[16:13:53.487]                           invokeRestart(restart)
[16:13:53.487]                           muffled <- TRUE
[16:13:53.487]                           break
[16:13:53.487]                         }
[16:13:53.487]                       }
[16:13:53.487]                     }
[16:13:53.487]                     invisible(muffled)
[16:13:53.487]                   }
[16:13:53.487]                   muffleCondition(cond)
[16:13:53.487]                 })
[16:13:53.487]             }))
[16:13:53.487]             future::FutureResult(value = ...future.value$value, 
[16:13:53.487]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:53.487]                   ...future.rng), globalenv = if (FALSE) 
[16:13:53.487]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:53.487]                     ...future.globalenv.names))
[16:13:53.487]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:53.487]         }, condition = base::local({
[16:13:53.487]             c <- base::c
[16:13:53.487]             inherits <- base::inherits
[16:13:53.487]             invokeRestart <- base::invokeRestart
[16:13:53.487]             length <- base::length
[16:13:53.487]             list <- base::list
[16:13:53.487]             seq.int <- base::seq.int
[16:13:53.487]             signalCondition <- base::signalCondition
[16:13:53.487]             sys.calls <- base::sys.calls
[16:13:53.487]             `[[` <- base::`[[`
[16:13:53.487]             `+` <- base::`+`
[16:13:53.487]             `<<-` <- base::`<<-`
[16:13:53.487]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:53.487]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:53.487]                   3L)]
[16:13:53.487]             }
[16:13:53.487]             function(cond) {
[16:13:53.487]                 is_error <- inherits(cond, "error")
[16:13:53.487]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:53.487]                   NULL)
[16:13:53.487]                 if (is_error) {
[16:13:53.487]                   sessionInformation <- function() {
[16:13:53.487]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:53.487]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:53.487]                       search = base::search(), system = base::Sys.info())
[16:13:53.487]                   }
[16:13:53.487]                   ...future.conditions[[length(...future.conditions) + 
[16:13:53.487]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:53.487]                     cond$call), session = sessionInformation(), 
[16:13:53.487]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:53.487]                   signalCondition(cond)
[16:13:53.487]                 }
[16:13:53.487]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:53.487]                 "immediateCondition"))) {
[16:13:53.487]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:53.487]                   ...future.conditions[[length(...future.conditions) + 
[16:13:53.487]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:53.487]                   if (TRUE && !signal) {
[16:13:53.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:53.487]                     {
[16:13:53.487]                       inherits <- base::inherits
[16:13:53.487]                       invokeRestart <- base::invokeRestart
[16:13:53.487]                       is.null <- base::is.null
[16:13:53.487]                       muffled <- FALSE
[16:13:53.487]                       if (inherits(cond, "message")) {
[16:13:53.487]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:53.487]                         if (muffled) 
[16:13:53.487]                           invokeRestart("muffleMessage")
[16:13:53.487]                       }
[16:13:53.487]                       else if (inherits(cond, "warning")) {
[16:13:53.487]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:53.487]                         if (muffled) 
[16:13:53.487]                           invokeRestart("muffleWarning")
[16:13:53.487]                       }
[16:13:53.487]                       else if (inherits(cond, "condition")) {
[16:13:53.487]                         if (!is.null(pattern)) {
[16:13:53.487]                           computeRestarts <- base::computeRestarts
[16:13:53.487]                           grepl <- base::grepl
[16:13:53.487]                           restarts <- computeRestarts(cond)
[16:13:53.487]                           for (restart in restarts) {
[16:13:53.487]                             name <- restart$name
[16:13:53.487]                             if (is.null(name)) 
[16:13:53.487]                               next
[16:13:53.487]                             if (!grepl(pattern, name)) 
[16:13:53.487]                               next
[16:13:53.487]                             invokeRestart(restart)
[16:13:53.487]                             muffled <- TRUE
[16:13:53.487]                             break
[16:13:53.487]                           }
[16:13:53.487]                         }
[16:13:53.487]                       }
[16:13:53.487]                       invisible(muffled)
[16:13:53.487]                     }
[16:13:53.487]                     muffleCondition(cond, pattern = "^muffle")
[16:13:53.487]                   }
[16:13:53.487]                 }
[16:13:53.487]                 else {
[16:13:53.487]                   if (TRUE) {
[16:13:53.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:53.487]                     {
[16:13:53.487]                       inherits <- base::inherits
[16:13:53.487]                       invokeRestart <- base::invokeRestart
[16:13:53.487]                       is.null <- base::is.null
[16:13:53.487]                       muffled <- FALSE
[16:13:53.487]                       if (inherits(cond, "message")) {
[16:13:53.487]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:53.487]                         if (muffled) 
[16:13:53.487]                           invokeRestart("muffleMessage")
[16:13:53.487]                       }
[16:13:53.487]                       else if (inherits(cond, "warning")) {
[16:13:53.487]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:53.487]                         if (muffled) 
[16:13:53.487]                           invokeRestart("muffleWarning")
[16:13:53.487]                       }
[16:13:53.487]                       else if (inherits(cond, "condition")) {
[16:13:53.487]                         if (!is.null(pattern)) {
[16:13:53.487]                           computeRestarts <- base::computeRestarts
[16:13:53.487]                           grepl <- base::grepl
[16:13:53.487]                           restarts <- computeRestarts(cond)
[16:13:53.487]                           for (restart in restarts) {
[16:13:53.487]                             name <- restart$name
[16:13:53.487]                             if (is.null(name)) 
[16:13:53.487]                               next
[16:13:53.487]                             if (!grepl(pattern, name)) 
[16:13:53.487]                               next
[16:13:53.487]                             invokeRestart(restart)
[16:13:53.487]                             muffled <- TRUE
[16:13:53.487]                             break
[16:13:53.487]                           }
[16:13:53.487]                         }
[16:13:53.487]                       }
[16:13:53.487]                       invisible(muffled)
[16:13:53.487]                     }
[16:13:53.487]                     muffleCondition(cond, pattern = "^muffle")
[16:13:53.487]                   }
[16:13:53.487]                 }
[16:13:53.487]             }
[16:13:53.487]         }))
[16:13:53.487]     }, error = function(ex) {
[16:13:53.487]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:53.487]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:53.487]                 ...future.rng), started = ...future.startTime, 
[16:13:53.487]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:53.487]             version = "1.8"), class = "FutureResult")
[16:13:53.487]     }, finally = {
[16:13:53.487]         if (!identical(...future.workdir, getwd())) 
[16:13:53.487]             setwd(...future.workdir)
[16:13:53.487]         {
[16:13:53.487]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:53.487]                 ...future.oldOptions$nwarnings <- NULL
[16:13:53.487]             }
[16:13:53.487]             base::options(...future.oldOptions)
[16:13:53.487]             if (.Platform$OS.type == "windows") {
[16:13:53.487]                 old_names <- names(...future.oldEnvVars)
[16:13:53.487]                 envs <- base::Sys.getenv()
[16:13:53.487]                 names <- names(envs)
[16:13:53.487]                 common <- intersect(names, old_names)
[16:13:53.487]                 added <- setdiff(names, old_names)
[16:13:53.487]                 removed <- setdiff(old_names, names)
[16:13:53.487]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:53.487]                   envs[common]]
[16:13:53.487]                 NAMES <- toupper(changed)
[16:13:53.487]                 args <- list()
[16:13:53.487]                 for (kk in seq_along(NAMES)) {
[16:13:53.487]                   name <- changed[[kk]]
[16:13:53.487]                   NAME <- NAMES[[kk]]
[16:13:53.487]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:53.487]                     next
[16:13:53.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:53.487]                 }
[16:13:53.487]                 NAMES <- toupper(added)
[16:13:53.487]                 for (kk in seq_along(NAMES)) {
[16:13:53.487]                   name <- added[[kk]]
[16:13:53.487]                   NAME <- NAMES[[kk]]
[16:13:53.487]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:53.487]                     next
[16:13:53.487]                   args[[name]] <- ""
[16:13:53.487]                 }
[16:13:53.487]                 NAMES <- toupper(removed)
[16:13:53.487]                 for (kk in seq_along(NAMES)) {
[16:13:53.487]                   name <- removed[[kk]]
[16:13:53.487]                   NAME <- NAMES[[kk]]
[16:13:53.487]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:53.487]                     next
[16:13:53.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:53.487]                 }
[16:13:53.487]                 if (length(args) > 0) 
[16:13:53.487]                   base::do.call(base::Sys.setenv, args = args)
[16:13:53.487]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:53.487]             }
[16:13:53.487]             else {
[16:13:53.487]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:53.487]             }
[16:13:53.487]             {
[16:13:53.487]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:53.487]                   0L) {
[16:13:53.487]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:53.487]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:53.487]                   base::options(opts)
[16:13:53.487]                 }
[16:13:53.487]                 {
[16:13:53.487]                   {
[16:13:53.487]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:53.487]                     NULL
[16:13:53.487]                   }
[16:13:53.487]                   options(future.plan = NULL)
[16:13:53.487]                   if (is.na(NA_character_)) 
[16:13:53.487]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:53.487]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:53.487]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:53.487]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:53.487]                     envir = parent.frame()) 
[16:13:53.487]                   {
[16:13:53.487]                     if (is.function(workers)) 
[16:13:53.487]                       workers <- workers()
[16:13:53.487]                     workers <- structure(as.integer(workers), 
[16:13:53.487]                       class = class(workers))
[16:13:53.487]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:53.487]                       workers >= 1)
[16:13:53.487]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:53.487]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:53.487]                     }
[16:13:53.487]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:53.487]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:53.487]                       envir = envir)
[16:13:53.487]                     if (!future$lazy) 
[16:13:53.487]                       future <- run(future)
[16:13:53.487]                     invisible(future)
[16:13:53.487]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:53.487]                 }
[16:13:53.487]             }
[16:13:53.487]         }
[16:13:53.487]     })
[16:13:53.487]     if (TRUE) {
[16:13:53.487]         base::sink(type = "output", split = FALSE)
[16:13:53.487]         if (TRUE) {
[16:13:53.487]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:53.487]         }
[16:13:53.487]         else {
[16:13:53.487]             ...future.result["stdout"] <- base::list(NULL)
[16:13:53.487]         }
[16:13:53.487]         base::close(...future.stdout)
[16:13:53.487]         ...future.stdout <- NULL
[16:13:53.487]     }
[16:13:53.487]     ...future.result$conditions <- ...future.conditions
[16:13:53.487]     ...future.result$finished <- base::Sys.time()
[16:13:53.487]     ...future.result
[16:13:53.487] }
[16:13:53.490] MultisessionFuture started
[16:13:53.490] - Launch lazy future ... done
[16:13:53.490] run() for ‘MultisessionFuture’ ... done
[16:13:54.038] receiveMessageFromWorker() for ClusterFuture ...
[16:13:54.038] - Validating connection of MultisessionFuture
[16:13:54.038] - received message: FutureResult
[16:13:54.038] - Received FutureResult
[16:13:54.038] - Erased future from FutureRegistry
[16:13:54.038] result() for ClusterFuture ...
[16:13:54.038] - result already collected: FutureResult
[16:13:54.039] result() for ClusterFuture ... done
[16:13:54.039] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:54.039] resolve() on list ...
[16:13:54.039]  recursive: 98
[16:13:54.039]  length: 2
[16:13:54.039]  elements: ‘a’, ‘b’
[16:13:54.039]  length: 1 (resolved future 1)
[16:13:54.039]  length: 0 (resolved future 2)
[16:13:54.039] resolve() on list ... DONE
[16:13:54.039] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[16:13:54.040] getGlobalsAndPackages() ...
[16:13:54.040] Searching for globals...
[16:13:54.040] - globals found: [2] ‘list’, ‘stop’
[16:13:54.041] Searching for globals ... DONE
[16:13:54.041] Resolving globals: FALSE
[16:13:54.041] 
[16:13:54.041] 
[16:13:54.041] getGlobalsAndPackages() ... DONE
[16:13:54.041] run() for ‘Future’ ...
[16:13:54.042] - state: ‘created’
[16:13:54.042] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:54.056] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:54.056] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:54.056]   - Field: ‘node’
[16:13:54.056]   - Field: ‘label’
[16:13:54.056]   - Field: ‘local’
[16:13:54.056]   - Field: ‘owner’
[16:13:54.056]   - Field: ‘envir’
[16:13:54.057]   - Field: ‘workers’
[16:13:54.057]   - Field: ‘packages’
[16:13:54.057]   - Field: ‘gc’
[16:13:54.057]   - Field: ‘conditions’
[16:13:54.057]   - Field: ‘persistent’
[16:13:54.057]   - Field: ‘expr’
[16:13:54.057]   - Field: ‘uuid’
[16:13:54.057]   - Field: ‘seed’
[16:13:54.057]   - Field: ‘version’
[16:13:54.057]   - Field: ‘result’
[16:13:54.057]   - Field: ‘asynchronous’
[16:13:54.058]   - Field: ‘calls’
[16:13:54.058]   - Field: ‘globals’
[16:13:54.058]   - Field: ‘stdout’
[16:13:54.058]   - Field: ‘earlySignal’
[16:13:54.058]   - Field: ‘lazy’
[16:13:54.058]   - Field: ‘state’
[16:13:54.058] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:54.058] - Launch lazy future ...
[16:13:54.058] Packages needed by the future expression (n = 0): <none>
[16:13:54.059] Packages needed by future strategies (n = 0): <none>
[16:13:54.059] {
[16:13:54.059]     {
[16:13:54.059]         {
[16:13:54.059]             ...future.startTime <- base::Sys.time()
[16:13:54.059]             {
[16:13:54.059]                 {
[16:13:54.059]                   {
[16:13:54.059]                     {
[16:13:54.059]                       base::local({
[16:13:54.059]                         has_future <- base::requireNamespace("future", 
[16:13:54.059]                           quietly = TRUE)
[16:13:54.059]                         if (has_future) {
[16:13:54.059]                           ns <- base::getNamespace("future")
[16:13:54.059]                           version <- ns[[".package"]][["version"]]
[16:13:54.059]                           if (is.null(version)) 
[16:13:54.059]                             version <- utils::packageVersion("future")
[16:13:54.059]                         }
[16:13:54.059]                         else {
[16:13:54.059]                           version <- NULL
[16:13:54.059]                         }
[16:13:54.059]                         if (!has_future || version < "1.8.0") {
[16:13:54.059]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:54.059]                             "", base::R.version$version.string), 
[16:13:54.059]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:54.059]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:54.059]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:54.059]                               "release", "version")], collapse = " "), 
[16:13:54.059]                             hostname = base::Sys.info()[["nodename"]])
[16:13:54.059]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:54.059]                             info)
[16:13:54.059]                           info <- base::paste(info, collapse = "; ")
[16:13:54.059]                           if (!has_future) {
[16:13:54.059]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:54.059]                               info)
[16:13:54.059]                           }
[16:13:54.059]                           else {
[16:13:54.059]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:54.059]                               info, version)
[16:13:54.059]                           }
[16:13:54.059]                           base::stop(msg)
[16:13:54.059]                         }
[16:13:54.059]                       })
[16:13:54.059]                     }
[16:13:54.059]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:54.059]                     base::options(mc.cores = 1L)
[16:13:54.059]                   }
[16:13:54.059]                   options(future.plan = NULL)
[16:13:54.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:54.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:54.059]                 }
[16:13:54.059]                 ...future.workdir <- getwd()
[16:13:54.059]             }
[16:13:54.059]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:54.059]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:54.059]         }
[16:13:54.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:54.059]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:54.059]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:54.059]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:54.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:54.059]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:54.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:54.059]             base::names(...future.oldOptions))
[16:13:54.059]     }
[16:13:54.059]     if (FALSE) {
[16:13:54.059]     }
[16:13:54.059]     else {
[16:13:54.059]         if (TRUE) {
[16:13:54.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:54.059]                 open = "w")
[16:13:54.059]         }
[16:13:54.059]         else {
[16:13:54.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:54.059]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:54.059]         }
[16:13:54.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:54.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:54.059]             base::sink(type = "output", split = FALSE)
[16:13:54.059]             base::close(...future.stdout)
[16:13:54.059]         }, add = TRUE)
[16:13:54.059]     }
[16:13:54.059]     ...future.frame <- base::sys.nframe()
[16:13:54.059]     ...future.conditions <- base::list()
[16:13:54.059]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:54.059]     if (FALSE) {
[16:13:54.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:54.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:54.059]     }
[16:13:54.059]     ...future.result <- base::tryCatch({
[16:13:54.059]         base::withCallingHandlers({
[16:13:54.059]             ...future.value <- base::withVisible(base::local({
[16:13:54.059]                 ...future.makeSendCondition <- local({
[16:13:54.059]                   sendCondition <- NULL
[16:13:54.059]                   function(frame = 1L) {
[16:13:54.059]                     if (is.function(sendCondition)) 
[16:13:54.059]                       return(sendCondition)
[16:13:54.059]                     ns <- getNamespace("parallel")
[16:13:54.059]                     if (exists("sendData", mode = "function", 
[16:13:54.059]                       envir = ns)) {
[16:13:54.059]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:54.059]                         envir = ns)
[16:13:54.059]                       envir <- sys.frame(frame)
[16:13:54.059]                       master <- NULL
[16:13:54.059]                       while (!identical(envir, .GlobalEnv) && 
[16:13:54.059]                         !identical(envir, emptyenv())) {
[16:13:54.059]                         if (exists("master", mode = "list", envir = envir, 
[16:13:54.059]                           inherits = FALSE)) {
[16:13:54.059]                           master <- get("master", mode = "list", 
[16:13:54.059]                             envir = envir, inherits = FALSE)
[16:13:54.059]                           if (inherits(master, c("SOCKnode", 
[16:13:54.059]                             "SOCK0node"))) {
[16:13:54.059]                             sendCondition <<- function(cond) {
[16:13:54.059]                               data <- list(type = "VALUE", value = cond, 
[16:13:54.059]                                 success = TRUE)
[16:13:54.059]                               parallel_sendData(master, data)
[16:13:54.059]                             }
[16:13:54.059]                             return(sendCondition)
[16:13:54.059]                           }
[16:13:54.059]                         }
[16:13:54.059]                         frame <- frame + 1L
[16:13:54.059]                         envir <- sys.frame(frame)
[16:13:54.059]                       }
[16:13:54.059]                     }
[16:13:54.059]                     sendCondition <<- function(cond) NULL
[16:13:54.059]                   }
[16:13:54.059]                 })
[16:13:54.059]                 withCallingHandlers({
[16:13:54.059]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:54.059]                 }, immediateCondition = function(cond) {
[16:13:54.059]                   sendCondition <- ...future.makeSendCondition()
[16:13:54.059]                   sendCondition(cond)
[16:13:54.059]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:54.059]                   {
[16:13:54.059]                     inherits <- base::inherits
[16:13:54.059]                     invokeRestart <- base::invokeRestart
[16:13:54.059]                     is.null <- base::is.null
[16:13:54.059]                     muffled <- FALSE
[16:13:54.059]                     if (inherits(cond, "message")) {
[16:13:54.059]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:54.059]                       if (muffled) 
[16:13:54.059]                         invokeRestart("muffleMessage")
[16:13:54.059]                     }
[16:13:54.059]                     else if (inherits(cond, "warning")) {
[16:13:54.059]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:54.059]                       if (muffled) 
[16:13:54.059]                         invokeRestart("muffleWarning")
[16:13:54.059]                     }
[16:13:54.059]                     else if (inherits(cond, "condition")) {
[16:13:54.059]                       if (!is.null(pattern)) {
[16:13:54.059]                         computeRestarts <- base::computeRestarts
[16:13:54.059]                         grepl <- base::grepl
[16:13:54.059]                         restarts <- computeRestarts(cond)
[16:13:54.059]                         for (restart in restarts) {
[16:13:54.059]                           name <- restart$name
[16:13:54.059]                           if (is.null(name)) 
[16:13:54.059]                             next
[16:13:54.059]                           if (!grepl(pattern, name)) 
[16:13:54.059]                             next
[16:13:54.059]                           invokeRestart(restart)
[16:13:54.059]                           muffled <- TRUE
[16:13:54.059]                           break
[16:13:54.059]                         }
[16:13:54.059]                       }
[16:13:54.059]                     }
[16:13:54.059]                     invisible(muffled)
[16:13:54.059]                   }
[16:13:54.059]                   muffleCondition(cond)
[16:13:54.059]                 })
[16:13:54.059]             }))
[16:13:54.059]             future::FutureResult(value = ...future.value$value, 
[16:13:54.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:54.059]                   ...future.rng), globalenv = if (FALSE) 
[16:13:54.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:54.059]                     ...future.globalenv.names))
[16:13:54.059]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:54.059]         }, condition = base::local({
[16:13:54.059]             c <- base::c
[16:13:54.059]             inherits <- base::inherits
[16:13:54.059]             invokeRestart <- base::invokeRestart
[16:13:54.059]             length <- base::length
[16:13:54.059]             list <- base::list
[16:13:54.059]             seq.int <- base::seq.int
[16:13:54.059]             signalCondition <- base::signalCondition
[16:13:54.059]             sys.calls <- base::sys.calls
[16:13:54.059]             `[[` <- base::`[[`
[16:13:54.059]             `+` <- base::`+`
[16:13:54.059]             `<<-` <- base::`<<-`
[16:13:54.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:54.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:54.059]                   3L)]
[16:13:54.059]             }
[16:13:54.059]             function(cond) {
[16:13:54.059]                 is_error <- inherits(cond, "error")
[16:13:54.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:54.059]                   NULL)
[16:13:54.059]                 if (is_error) {
[16:13:54.059]                   sessionInformation <- function() {
[16:13:54.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:54.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:54.059]                       search = base::search(), system = base::Sys.info())
[16:13:54.059]                   }
[16:13:54.059]                   ...future.conditions[[length(...future.conditions) + 
[16:13:54.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:54.059]                     cond$call), session = sessionInformation(), 
[16:13:54.059]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:54.059]                   signalCondition(cond)
[16:13:54.059]                 }
[16:13:54.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:54.059]                 "immediateCondition"))) {
[16:13:54.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:54.059]                   ...future.conditions[[length(...future.conditions) + 
[16:13:54.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:54.059]                   if (TRUE && !signal) {
[16:13:54.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:54.059]                     {
[16:13:54.059]                       inherits <- base::inherits
[16:13:54.059]                       invokeRestart <- base::invokeRestart
[16:13:54.059]                       is.null <- base::is.null
[16:13:54.059]                       muffled <- FALSE
[16:13:54.059]                       if (inherits(cond, "message")) {
[16:13:54.059]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:54.059]                         if (muffled) 
[16:13:54.059]                           invokeRestart("muffleMessage")
[16:13:54.059]                       }
[16:13:54.059]                       else if (inherits(cond, "warning")) {
[16:13:54.059]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:54.059]                         if (muffled) 
[16:13:54.059]                           invokeRestart("muffleWarning")
[16:13:54.059]                       }
[16:13:54.059]                       else if (inherits(cond, "condition")) {
[16:13:54.059]                         if (!is.null(pattern)) {
[16:13:54.059]                           computeRestarts <- base::computeRestarts
[16:13:54.059]                           grepl <- base::grepl
[16:13:54.059]                           restarts <- computeRestarts(cond)
[16:13:54.059]                           for (restart in restarts) {
[16:13:54.059]                             name <- restart$name
[16:13:54.059]                             if (is.null(name)) 
[16:13:54.059]                               next
[16:13:54.059]                             if (!grepl(pattern, name)) 
[16:13:54.059]                               next
[16:13:54.059]                             invokeRestart(restart)
[16:13:54.059]                             muffled <- TRUE
[16:13:54.059]                             break
[16:13:54.059]                           }
[16:13:54.059]                         }
[16:13:54.059]                       }
[16:13:54.059]                       invisible(muffled)
[16:13:54.059]                     }
[16:13:54.059]                     muffleCondition(cond, pattern = "^muffle")
[16:13:54.059]                   }
[16:13:54.059]                 }
[16:13:54.059]                 else {
[16:13:54.059]                   if (TRUE) {
[16:13:54.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:54.059]                     {
[16:13:54.059]                       inherits <- base::inherits
[16:13:54.059]                       invokeRestart <- base::invokeRestart
[16:13:54.059]                       is.null <- base::is.null
[16:13:54.059]                       muffled <- FALSE
[16:13:54.059]                       if (inherits(cond, "message")) {
[16:13:54.059]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:54.059]                         if (muffled) 
[16:13:54.059]                           invokeRestart("muffleMessage")
[16:13:54.059]                       }
[16:13:54.059]                       else if (inherits(cond, "warning")) {
[16:13:54.059]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:54.059]                         if (muffled) 
[16:13:54.059]                           invokeRestart("muffleWarning")
[16:13:54.059]                       }
[16:13:54.059]                       else if (inherits(cond, "condition")) {
[16:13:54.059]                         if (!is.null(pattern)) {
[16:13:54.059]                           computeRestarts <- base::computeRestarts
[16:13:54.059]                           grepl <- base::grepl
[16:13:54.059]                           restarts <- computeRestarts(cond)
[16:13:54.059]                           for (restart in restarts) {
[16:13:54.059]                             name <- restart$name
[16:13:54.059]                             if (is.null(name)) 
[16:13:54.059]                               next
[16:13:54.059]                             if (!grepl(pattern, name)) 
[16:13:54.059]                               next
[16:13:54.059]                             invokeRestart(restart)
[16:13:54.059]                             muffled <- TRUE
[16:13:54.059]                             break
[16:13:54.059]                           }
[16:13:54.059]                         }
[16:13:54.059]                       }
[16:13:54.059]                       invisible(muffled)
[16:13:54.059]                     }
[16:13:54.059]                     muffleCondition(cond, pattern = "^muffle")
[16:13:54.059]                   }
[16:13:54.059]                 }
[16:13:54.059]             }
[16:13:54.059]         }))
[16:13:54.059]     }, error = function(ex) {
[16:13:54.059]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:54.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:54.059]                 ...future.rng), started = ...future.startTime, 
[16:13:54.059]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:54.059]             version = "1.8"), class = "FutureResult")
[16:13:54.059]     }, finally = {
[16:13:54.059]         if (!identical(...future.workdir, getwd())) 
[16:13:54.059]             setwd(...future.workdir)
[16:13:54.059]         {
[16:13:54.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:54.059]                 ...future.oldOptions$nwarnings <- NULL
[16:13:54.059]             }
[16:13:54.059]             base::options(...future.oldOptions)
[16:13:54.059]             if (.Platform$OS.type == "windows") {
[16:13:54.059]                 old_names <- names(...future.oldEnvVars)
[16:13:54.059]                 envs <- base::Sys.getenv()
[16:13:54.059]                 names <- names(envs)
[16:13:54.059]                 common <- intersect(names, old_names)
[16:13:54.059]                 added <- setdiff(names, old_names)
[16:13:54.059]                 removed <- setdiff(old_names, names)
[16:13:54.059]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:54.059]                   envs[common]]
[16:13:54.059]                 NAMES <- toupper(changed)
[16:13:54.059]                 args <- list()
[16:13:54.059]                 for (kk in seq_along(NAMES)) {
[16:13:54.059]                   name <- changed[[kk]]
[16:13:54.059]                   NAME <- NAMES[[kk]]
[16:13:54.059]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:54.059]                     next
[16:13:54.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:54.059]                 }
[16:13:54.059]                 NAMES <- toupper(added)
[16:13:54.059]                 for (kk in seq_along(NAMES)) {
[16:13:54.059]                   name <- added[[kk]]
[16:13:54.059]                   NAME <- NAMES[[kk]]
[16:13:54.059]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:54.059]                     next
[16:13:54.059]                   args[[name]] <- ""
[16:13:54.059]                 }
[16:13:54.059]                 NAMES <- toupper(removed)
[16:13:54.059]                 for (kk in seq_along(NAMES)) {
[16:13:54.059]                   name <- removed[[kk]]
[16:13:54.059]                   NAME <- NAMES[[kk]]
[16:13:54.059]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:54.059]                     next
[16:13:54.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:54.059]                 }
[16:13:54.059]                 if (length(args) > 0) 
[16:13:54.059]                   base::do.call(base::Sys.setenv, args = args)
[16:13:54.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:54.059]             }
[16:13:54.059]             else {
[16:13:54.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:54.059]             }
[16:13:54.059]             {
[16:13:54.059]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:54.059]                   0L) {
[16:13:54.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:54.059]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:54.059]                   base::options(opts)
[16:13:54.059]                 }
[16:13:54.059]                 {
[16:13:54.059]                   {
[16:13:54.059]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:54.059]                     NULL
[16:13:54.059]                   }
[16:13:54.059]                   options(future.plan = NULL)
[16:13:54.059]                   if (is.na(NA_character_)) 
[16:13:54.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:54.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:54.059]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:54.059]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:54.059]                     envir = parent.frame()) 
[16:13:54.059]                   {
[16:13:54.059]                     if (is.function(workers)) 
[16:13:54.059]                       workers <- workers()
[16:13:54.059]                     workers <- structure(as.integer(workers), 
[16:13:54.059]                       class = class(workers))
[16:13:54.059]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:54.059]                       workers >= 1)
[16:13:54.059]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:54.059]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:54.059]                     }
[16:13:54.059]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:54.059]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:54.059]                       envir = envir)
[16:13:54.059]                     if (!future$lazy) 
[16:13:54.059]                       future <- run(future)
[16:13:54.059]                     invisible(future)
[16:13:54.059]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:54.059]                 }
[16:13:54.059]             }
[16:13:54.059]         }
[16:13:54.059]     })
[16:13:54.059]     if (TRUE) {
[16:13:54.059]         base::sink(type = "output", split = FALSE)
[16:13:54.059]         if (TRUE) {
[16:13:54.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:54.059]         }
[16:13:54.059]         else {
[16:13:54.059]             ...future.result["stdout"] <- base::list(NULL)
[16:13:54.059]         }
[16:13:54.059]         base::close(...future.stdout)
[16:13:54.059]         ...future.stdout <- NULL
[16:13:54.059]     }
[16:13:54.059]     ...future.result$conditions <- ...future.conditions
[16:13:54.059]     ...future.result$finished <- base::Sys.time()
[16:13:54.059]     ...future.result
[16:13:54.059] }
[16:13:54.062] MultisessionFuture started
[16:13:54.062] - Launch lazy future ... done
[16:13:54.062] run() for ‘MultisessionFuture’ ... done
[16:13:54.109] receiveMessageFromWorker() for ClusterFuture ...
[16:13:54.109] - Validating connection of MultisessionFuture
[16:13:54.109] - received message: FutureResult
[16:13:54.109] - Received FutureResult
[16:13:54.110] - Erased future from FutureRegistry
[16:13:54.110] result() for ClusterFuture ...
[16:13:54.110] - result already collected: FutureResult
[16:13:54.110] result() for ClusterFuture ... done
[16:13:54.110] signalConditions() ...
[16:13:54.110]  - include = ‘immediateCondition’
[16:13:54.110]  - exclude = 
[16:13:54.110]  - resignal = FALSE
[16:13:54.110]  - Number of conditions: 1
[16:13:54.110] signalConditions() ... done
[16:13:54.110] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:54.111] A MultisessionFuture was resolved
[16:13:54.111] getGlobalsAndPackages() ...
[16:13:54.111] Searching for globals...
[16:13:54.111] - globals found: [2] ‘list’, ‘stop’
[16:13:54.112] Searching for globals ... DONE
[16:13:54.112] Resolving globals: FALSE
[16:13:54.112] 
[16:13:54.112] 
[16:13:54.112] getGlobalsAndPackages() ... DONE
[16:13:54.112] run() for ‘Future’ ...
[16:13:54.113] - state: ‘created’
[16:13:54.113] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:54.127] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:54.127] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:54.127]   - Field: ‘node’
[16:13:54.127]   - Field: ‘label’
[16:13:54.128]   - Field: ‘local’
[16:13:54.128]   - Field: ‘owner’
[16:13:54.128]   - Field: ‘envir’
[16:13:54.128]   - Field: ‘workers’
[16:13:54.128]   - Field: ‘packages’
[16:13:54.128]   - Field: ‘gc’
[16:13:54.128]   - Field: ‘conditions’
[16:13:54.128]   - Field: ‘persistent’
[16:13:54.128]   - Field: ‘expr’
[16:13:54.128]   - Field: ‘uuid’
[16:13:54.129]   - Field: ‘seed’
[16:13:54.129]   - Field: ‘version’
[16:13:54.129]   - Field: ‘result’
[16:13:54.129]   - Field: ‘asynchronous’
[16:13:54.129]   - Field: ‘calls’
[16:13:54.129]   - Field: ‘globals’
[16:13:54.129]   - Field: ‘stdout’
[16:13:54.129]   - Field: ‘earlySignal’
[16:13:54.129]   - Field: ‘lazy’
[16:13:54.129]   - Field: ‘state’
[16:13:54.129] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:54.130] - Launch lazy future ...
[16:13:54.130] Packages needed by the future expression (n = 0): <none>
[16:13:54.130] Packages needed by future strategies (n = 0): <none>
[16:13:54.130] {
[16:13:54.130]     {
[16:13:54.130]         {
[16:13:54.130]             ...future.startTime <- base::Sys.time()
[16:13:54.130]             {
[16:13:54.130]                 {
[16:13:54.130]                   {
[16:13:54.130]                     {
[16:13:54.130]                       base::local({
[16:13:54.130]                         has_future <- base::requireNamespace("future", 
[16:13:54.130]                           quietly = TRUE)
[16:13:54.130]                         if (has_future) {
[16:13:54.130]                           ns <- base::getNamespace("future")
[16:13:54.130]                           version <- ns[[".package"]][["version"]]
[16:13:54.130]                           if (is.null(version)) 
[16:13:54.130]                             version <- utils::packageVersion("future")
[16:13:54.130]                         }
[16:13:54.130]                         else {
[16:13:54.130]                           version <- NULL
[16:13:54.130]                         }
[16:13:54.130]                         if (!has_future || version < "1.8.0") {
[16:13:54.130]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:54.130]                             "", base::R.version$version.string), 
[16:13:54.130]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:54.130]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:54.130]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:54.130]                               "release", "version")], collapse = " "), 
[16:13:54.130]                             hostname = base::Sys.info()[["nodename"]])
[16:13:54.130]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:54.130]                             info)
[16:13:54.130]                           info <- base::paste(info, collapse = "; ")
[16:13:54.130]                           if (!has_future) {
[16:13:54.130]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:54.130]                               info)
[16:13:54.130]                           }
[16:13:54.130]                           else {
[16:13:54.130]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:54.130]                               info, version)
[16:13:54.130]                           }
[16:13:54.130]                           base::stop(msg)
[16:13:54.130]                         }
[16:13:54.130]                       })
[16:13:54.130]                     }
[16:13:54.130]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:54.130]                     base::options(mc.cores = 1L)
[16:13:54.130]                   }
[16:13:54.130]                   options(future.plan = NULL)
[16:13:54.130]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:54.130]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:54.130]                 }
[16:13:54.130]                 ...future.workdir <- getwd()
[16:13:54.130]             }
[16:13:54.130]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:54.130]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:54.130]         }
[16:13:54.130]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:54.130]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:54.130]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:54.130]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:54.130]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:54.130]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:54.130]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:54.130]             base::names(...future.oldOptions))
[16:13:54.130]     }
[16:13:54.130]     if (FALSE) {
[16:13:54.130]     }
[16:13:54.130]     else {
[16:13:54.130]         if (TRUE) {
[16:13:54.130]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:54.130]                 open = "w")
[16:13:54.130]         }
[16:13:54.130]         else {
[16:13:54.130]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:54.130]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:54.130]         }
[16:13:54.130]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:54.130]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:54.130]             base::sink(type = "output", split = FALSE)
[16:13:54.130]             base::close(...future.stdout)
[16:13:54.130]         }, add = TRUE)
[16:13:54.130]     }
[16:13:54.130]     ...future.frame <- base::sys.nframe()
[16:13:54.130]     ...future.conditions <- base::list()
[16:13:54.130]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:54.130]     if (FALSE) {
[16:13:54.130]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:54.130]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:54.130]     }
[16:13:54.130]     ...future.result <- base::tryCatch({
[16:13:54.130]         base::withCallingHandlers({
[16:13:54.130]             ...future.value <- base::withVisible(base::local({
[16:13:54.130]                 ...future.makeSendCondition <- local({
[16:13:54.130]                   sendCondition <- NULL
[16:13:54.130]                   function(frame = 1L) {
[16:13:54.130]                     if (is.function(sendCondition)) 
[16:13:54.130]                       return(sendCondition)
[16:13:54.130]                     ns <- getNamespace("parallel")
[16:13:54.130]                     if (exists("sendData", mode = "function", 
[16:13:54.130]                       envir = ns)) {
[16:13:54.130]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:54.130]                         envir = ns)
[16:13:54.130]                       envir <- sys.frame(frame)
[16:13:54.130]                       master <- NULL
[16:13:54.130]                       while (!identical(envir, .GlobalEnv) && 
[16:13:54.130]                         !identical(envir, emptyenv())) {
[16:13:54.130]                         if (exists("master", mode = "list", envir = envir, 
[16:13:54.130]                           inherits = FALSE)) {
[16:13:54.130]                           master <- get("master", mode = "list", 
[16:13:54.130]                             envir = envir, inherits = FALSE)
[16:13:54.130]                           if (inherits(master, c("SOCKnode", 
[16:13:54.130]                             "SOCK0node"))) {
[16:13:54.130]                             sendCondition <<- function(cond) {
[16:13:54.130]                               data <- list(type = "VALUE", value = cond, 
[16:13:54.130]                                 success = TRUE)
[16:13:54.130]                               parallel_sendData(master, data)
[16:13:54.130]                             }
[16:13:54.130]                             return(sendCondition)
[16:13:54.130]                           }
[16:13:54.130]                         }
[16:13:54.130]                         frame <- frame + 1L
[16:13:54.130]                         envir <- sys.frame(frame)
[16:13:54.130]                       }
[16:13:54.130]                     }
[16:13:54.130]                     sendCondition <<- function(cond) NULL
[16:13:54.130]                   }
[16:13:54.130]                 })
[16:13:54.130]                 withCallingHandlers({
[16:13:54.130]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:54.130]                 }, immediateCondition = function(cond) {
[16:13:54.130]                   sendCondition <- ...future.makeSendCondition()
[16:13:54.130]                   sendCondition(cond)
[16:13:54.130]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:54.130]                   {
[16:13:54.130]                     inherits <- base::inherits
[16:13:54.130]                     invokeRestart <- base::invokeRestart
[16:13:54.130]                     is.null <- base::is.null
[16:13:54.130]                     muffled <- FALSE
[16:13:54.130]                     if (inherits(cond, "message")) {
[16:13:54.130]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:54.130]                       if (muffled) 
[16:13:54.130]                         invokeRestart("muffleMessage")
[16:13:54.130]                     }
[16:13:54.130]                     else if (inherits(cond, "warning")) {
[16:13:54.130]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:54.130]                       if (muffled) 
[16:13:54.130]                         invokeRestart("muffleWarning")
[16:13:54.130]                     }
[16:13:54.130]                     else if (inherits(cond, "condition")) {
[16:13:54.130]                       if (!is.null(pattern)) {
[16:13:54.130]                         computeRestarts <- base::computeRestarts
[16:13:54.130]                         grepl <- base::grepl
[16:13:54.130]                         restarts <- computeRestarts(cond)
[16:13:54.130]                         for (restart in restarts) {
[16:13:54.130]                           name <- restart$name
[16:13:54.130]                           if (is.null(name)) 
[16:13:54.130]                             next
[16:13:54.130]                           if (!grepl(pattern, name)) 
[16:13:54.130]                             next
[16:13:54.130]                           invokeRestart(restart)
[16:13:54.130]                           muffled <- TRUE
[16:13:54.130]                           break
[16:13:54.130]                         }
[16:13:54.130]                       }
[16:13:54.130]                     }
[16:13:54.130]                     invisible(muffled)
[16:13:54.130]                   }
[16:13:54.130]                   muffleCondition(cond)
[16:13:54.130]                 })
[16:13:54.130]             }))
[16:13:54.130]             future::FutureResult(value = ...future.value$value, 
[16:13:54.130]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:54.130]                   ...future.rng), globalenv = if (FALSE) 
[16:13:54.130]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:54.130]                     ...future.globalenv.names))
[16:13:54.130]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:54.130]         }, condition = base::local({
[16:13:54.130]             c <- base::c
[16:13:54.130]             inherits <- base::inherits
[16:13:54.130]             invokeRestart <- base::invokeRestart
[16:13:54.130]             length <- base::length
[16:13:54.130]             list <- base::list
[16:13:54.130]             seq.int <- base::seq.int
[16:13:54.130]             signalCondition <- base::signalCondition
[16:13:54.130]             sys.calls <- base::sys.calls
[16:13:54.130]             `[[` <- base::`[[`
[16:13:54.130]             `+` <- base::`+`
[16:13:54.130]             `<<-` <- base::`<<-`
[16:13:54.130]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:54.130]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:54.130]                   3L)]
[16:13:54.130]             }
[16:13:54.130]             function(cond) {
[16:13:54.130]                 is_error <- inherits(cond, "error")
[16:13:54.130]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:54.130]                   NULL)
[16:13:54.130]                 if (is_error) {
[16:13:54.130]                   sessionInformation <- function() {
[16:13:54.130]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:54.130]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:54.130]                       search = base::search(), system = base::Sys.info())
[16:13:54.130]                   }
[16:13:54.130]                   ...future.conditions[[length(...future.conditions) + 
[16:13:54.130]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:54.130]                     cond$call), session = sessionInformation(), 
[16:13:54.130]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:54.130]                   signalCondition(cond)
[16:13:54.130]                 }
[16:13:54.130]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:54.130]                 "immediateCondition"))) {
[16:13:54.130]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:54.130]                   ...future.conditions[[length(...future.conditions) + 
[16:13:54.130]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:54.130]                   if (TRUE && !signal) {
[16:13:54.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:54.130]                     {
[16:13:54.130]                       inherits <- base::inherits
[16:13:54.130]                       invokeRestart <- base::invokeRestart
[16:13:54.130]                       is.null <- base::is.null
[16:13:54.130]                       muffled <- FALSE
[16:13:54.130]                       if (inherits(cond, "message")) {
[16:13:54.130]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:54.130]                         if (muffled) 
[16:13:54.130]                           invokeRestart("muffleMessage")
[16:13:54.130]                       }
[16:13:54.130]                       else if (inherits(cond, "warning")) {
[16:13:54.130]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:54.130]                         if (muffled) 
[16:13:54.130]                           invokeRestart("muffleWarning")
[16:13:54.130]                       }
[16:13:54.130]                       else if (inherits(cond, "condition")) {
[16:13:54.130]                         if (!is.null(pattern)) {
[16:13:54.130]                           computeRestarts <- base::computeRestarts
[16:13:54.130]                           grepl <- base::grepl
[16:13:54.130]                           restarts <- computeRestarts(cond)
[16:13:54.130]                           for (restart in restarts) {
[16:13:54.130]                             name <- restart$name
[16:13:54.130]                             if (is.null(name)) 
[16:13:54.130]                               next
[16:13:54.130]                             if (!grepl(pattern, name)) 
[16:13:54.130]                               next
[16:13:54.130]                             invokeRestart(restart)
[16:13:54.130]                             muffled <- TRUE
[16:13:54.130]                             break
[16:13:54.130]                           }
[16:13:54.130]                         }
[16:13:54.130]                       }
[16:13:54.130]                       invisible(muffled)
[16:13:54.130]                     }
[16:13:54.130]                     muffleCondition(cond, pattern = "^muffle")
[16:13:54.130]                   }
[16:13:54.130]                 }
[16:13:54.130]                 else {
[16:13:54.130]                   if (TRUE) {
[16:13:54.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:54.130]                     {
[16:13:54.130]                       inherits <- base::inherits
[16:13:54.130]                       invokeRestart <- base::invokeRestart
[16:13:54.130]                       is.null <- base::is.null
[16:13:54.130]                       muffled <- FALSE
[16:13:54.130]                       if (inherits(cond, "message")) {
[16:13:54.130]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:54.130]                         if (muffled) 
[16:13:54.130]                           invokeRestart("muffleMessage")
[16:13:54.130]                       }
[16:13:54.130]                       else if (inherits(cond, "warning")) {
[16:13:54.130]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:54.130]                         if (muffled) 
[16:13:54.130]                           invokeRestart("muffleWarning")
[16:13:54.130]                       }
[16:13:54.130]                       else if (inherits(cond, "condition")) {
[16:13:54.130]                         if (!is.null(pattern)) {
[16:13:54.130]                           computeRestarts <- base::computeRestarts
[16:13:54.130]                           grepl <- base::grepl
[16:13:54.130]                           restarts <- computeRestarts(cond)
[16:13:54.130]                           for (restart in restarts) {
[16:13:54.130]                             name <- restart$name
[16:13:54.130]                             if (is.null(name)) 
[16:13:54.130]                               next
[16:13:54.130]                             if (!grepl(pattern, name)) 
[16:13:54.130]                               next
[16:13:54.130]                             invokeRestart(restart)
[16:13:54.130]                             muffled <- TRUE
[16:13:54.130]                             break
[16:13:54.130]                           }
[16:13:54.130]                         }
[16:13:54.130]                       }
[16:13:54.130]                       invisible(muffled)
[16:13:54.130]                     }
[16:13:54.130]                     muffleCondition(cond, pattern = "^muffle")
[16:13:54.130]                   }
[16:13:54.130]                 }
[16:13:54.130]             }
[16:13:54.130]         }))
[16:13:54.130]     }, error = function(ex) {
[16:13:54.130]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:54.130]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:54.130]                 ...future.rng), started = ...future.startTime, 
[16:13:54.130]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:54.130]             version = "1.8"), class = "FutureResult")
[16:13:54.130]     }, finally = {
[16:13:54.130]         if (!identical(...future.workdir, getwd())) 
[16:13:54.130]             setwd(...future.workdir)
[16:13:54.130]         {
[16:13:54.130]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:54.130]                 ...future.oldOptions$nwarnings <- NULL
[16:13:54.130]             }
[16:13:54.130]             base::options(...future.oldOptions)
[16:13:54.130]             if (.Platform$OS.type == "windows") {
[16:13:54.130]                 old_names <- names(...future.oldEnvVars)
[16:13:54.130]                 envs <- base::Sys.getenv()
[16:13:54.130]                 names <- names(envs)
[16:13:54.130]                 common <- intersect(names, old_names)
[16:13:54.130]                 added <- setdiff(names, old_names)
[16:13:54.130]                 removed <- setdiff(old_names, names)
[16:13:54.130]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:54.130]                   envs[common]]
[16:13:54.130]                 NAMES <- toupper(changed)
[16:13:54.130]                 args <- list()
[16:13:54.130]                 for (kk in seq_along(NAMES)) {
[16:13:54.130]                   name <- changed[[kk]]
[16:13:54.130]                   NAME <- NAMES[[kk]]
[16:13:54.130]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:54.130]                     next
[16:13:54.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:54.130]                 }
[16:13:54.130]                 NAMES <- toupper(added)
[16:13:54.130]                 for (kk in seq_along(NAMES)) {
[16:13:54.130]                   name <- added[[kk]]
[16:13:54.130]                   NAME <- NAMES[[kk]]
[16:13:54.130]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:54.130]                     next
[16:13:54.130]                   args[[name]] <- ""
[16:13:54.130]                 }
[16:13:54.130]                 NAMES <- toupper(removed)
[16:13:54.130]                 for (kk in seq_along(NAMES)) {
[16:13:54.130]                   name <- removed[[kk]]
[16:13:54.130]                   NAME <- NAMES[[kk]]
[16:13:54.130]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:54.130]                     next
[16:13:54.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:54.130]                 }
[16:13:54.130]                 if (length(args) > 0) 
[16:13:54.130]                   base::do.call(base::Sys.setenv, args = args)
[16:13:54.130]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:54.130]             }
[16:13:54.130]             else {
[16:13:54.130]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:54.130]             }
[16:13:54.130]             {
[16:13:54.130]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:54.130]                   0L) {
[16:13:54.130]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:54.130]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:54.130]                   base::options(opts)
[16:13:54.130]                 }
[16:13:54.130]                 {
[16:13:54.130]                   {
[16:13:54.130]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:54.130]                     NULL
[16:13:54.130]                   }
[16:13:54.130]                   options(future.plan = NULL)
[16:13:54.130]                   if (is.na(NA_character_)) 
[16:13:54.130]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:54.130]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:54.130]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:54.130]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:54.130]                     envir = parent.frame()) 
[16:13:54.130]                   {
[16:13:54.130]                     if (is.function(workers)) 
[16:13:54.130]                       workers <- workers()
[16:13:54.130]                     workers <- structure(as.integer(workers), 
[16:13:54.130]                       class = class(workers))
[16:13:54.130]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:54.130]                       workers >= 1)
[16:13:54.130]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:54.130]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:54.130]                     }
[16:13:54.130]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:54.130]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:54.130]                       envir = envir)
[16:13:54.130]                     if (!future$lazy) 
[16:13:54.130]                       future <- run(future)
[16:13:54.130]                     invisible(future)
[16:13:54.130]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:54.130]                 }
[16:13:54.130]             }
[16:13:54.130]         }
[16:13:54.130]     })
[16:13:54.130]     if (TRUE) {
[16:13:54.130]         base::sink(type = "output", split = FALSE)
[16:13:54.130]         if (TRUE) {
[16:13:54.130]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:54.130]         }
[16:13:54.130]         else {
[16:13:54.130]             ...future.result["stdout"] <- base::list(NULL)
[16:13:54.130]         }
[16:13:54.130]         base::close(...future.stdout)
[16:13:54.130]         ...future.stdout <- NULL
[16:13:54.130]     }
[16:13:54.130]     ...future.result$conditions <- ...future.conditions
[16:13:54.130]     ...future.result$finished <- base::Sys.time()
[16:13:54.130]     ...future.result
[16:13:54.130] }
[16:13:54.133] MultisessionFuture started
[16:13:54.134] - Launch lazy future ... done
[16:13:54.134] run() for ‘MultisessionFuture’ ... done
[16:13:54.181] receiveMessageFromWorker() for ClusterFuture ...
[16:13:54.181] - Validating connection of MultisessionFuture
[16:13:54.181] - received message: FutureResult
[16:13:54.181] - Received FutureResult
[16:13:54.182] - Erased future from FutureRegistry
[16:13:54.182] result() for ClusterFuture ...
[16:13:54.182] - result already collected: FutureResult
[16:13:54.182] result() for ClusterFuture ... done
[16:13:54.182] signalConditions() ...
[16:13:54.182]  - include = ‘immediateCondition’
[16:13:54.182]  - exclude = 
[16:13:54.182]  - resignal = FALSE
[16:13:54.182]  - Number of conditions: 1
[16:13:54.182] signalConditions() ... done
[16:13:54.182] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:54.183] A MultisessionFuture was resolved
- result = TRUE, recursive = TRUE ... DONE
- result = TRUE, recursive = -1 ...
[16:13:54.183] getGlobalsAndPackages() ...
[16:13:54.183] Searching for globals...
[16:13:54.184] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:54.184] Searching for globals ... DONE
[16:13:54.184] Resolving globals: FALSE
[16:13:54.185] 
[16:13:54.185] 
[16:13:54.185] getGlobalsAndPackages() ... DONE
[16:13:54.185] run() for ‘Future’ ...
[16:13:54.185] - state: ‘created’
[16:13:54.185] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:54.199] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:54.200] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:54.200]   - Field: ‘node’
[16:13:54.200]   - Field: ‘label’
[16:13:54.200]   - Field: ‘local’
[16:13:54.200]   - Field: ‘owner’
[16:13:54.200]   - Field: ‘envir’
[16:13:54.200]   - Field: ‘workers’
[16:13:54.200]   - Field: ‘packages’
[16:13:54.200]   - Field: ‘gc’
[16:13:54.201]   - Field: ‘conditions’
[16:13:54.201]   - Field: ‘persistent’
[16:13:54.201]   - Field: ‘expr’
[16:13:54.201]   - Field: ‘uuid’
[16:13:54.201]   - Field: ‘seed’
[16:13:54.201]   - Field: ‘version’
[16:13:54.201]   - Field: ‘result’
[16:13:54.201]   - Field: ‘asynchronous’
[16:13:54.201]   - Field: ‘calls’
[16:13:54.201]   - Field: ‘globals’
[16:13:54.201]   - Field: ‘stdout’
[16:13:54.202]   - Field: ‘earlySignal’
[16:13:54.202]   - Field: ‘lazy’
[16:13:54.202]   - Field: ‘state’
[16:13:54.202] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:54.202] - Launch lazy future ...
[16:13:54.202] Packages needed by the future expression (n = 0): <none>
[16:13:54.202] Packages needed by future strategies (n = 0): <none>
[16:13:54.203] {
[16:13:54.203]     {
[16:13:54.203]         {
[16:13:54.203]             ...future.startTime <- base::Sys.time()
[16:13:54.203]             {
[16:13:54.203]                 {
[16:13:54.203]                   {
[16:13:54.203]                     {
[16:13:54.203]                       base::local({
[16:13:54.203]                         has_future <- base::requireNamespace("future", 
[16:13:54.203]                           quietly = TRUE)
[16:13:54.203]                         if (has_future) {
[16:13:54.203]                           ns <- base::getNamespace("future")
[16:13:54.203]                           version <- ns[[".package"]][["version"]]
[16:13:54.203]                           if (is.null(version)) 
[16:13:54.203]                             version <- utils::packageVersion("future")
[16:13:54.203]                         }
[16:13:54.203]                         else {
[16:13:54.203]                           version <- NULL
[16:13:54.203]                         }
[16:13:54.203]                         if (!has_future || version < "1.8.0") {
[16:13:54.203]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:54.203]                             "", base::R.version$version.string), 
[16:13:54.203]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:54.203]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:54.203]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:54.203]                               "release", "version")], collapse = " "), 
[16:13:54.203]                             hostname = base::Sys.info()[["nodename"]])
[16:13:54.203]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:54.203]                             info)
[16:13:54.203]                           info <- base::paste(info, collapse = "; ")
[16:13:54.203]                           if (!has_future) {
[16:13:54.203]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:54.203]                               info)
[16:13:54.203]                           }
[16:13:54.203]                           else {
[16:13:54.203]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:54.203]                               info, version)
[16:13:54.203]                           }
[16:13:54.203]                           base::stop(msg)
[16:13:54.203]                         }
[16:13:54.203]                       })
[16:13:54.203]                     }
[16:13:54.203]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:54.203]                     base::options(mc.cores = 1L)
[16:13:54.203]                   }
[16:13:54.203]                   options(future.plan = NULL)
[16:13:54.203]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:54.203]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:54.203]                 }
[16:13:54.203]                 ...future.workdir <- getwd()
[16:13:54.203]             }
[16:13:54.203]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:54.203]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:54.203]         }
[16:13:54.203]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:54.203]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:54.203]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:54.203]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:54.203]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:54.203]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:54.203]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:54.203]             base::names(...future.oldOptions))
[16:13:54.203]     }
[16:13:54.203]     if (FALSE) {
[16:13:54.203]     }
[16:13:54.203]     else {
[16:13:54.203]         if (TRUE) {
[16:13:54.203]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:54.203]                 open = "w")
[16:13:54.203]         }
[16:13:54.203]         else {
[16:13:54.203]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:54.203]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:54.203]         }
[16:13:54.203]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:54.203]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:54.203]             base::sink(type = "output", split = FALSE)
[16:13:54.203]             base::close(...future.stdout)
[16:13:54.203]         }, add = TRUE)
[16:13:54.203]     }
[16:13:54.203]     ...future.frame <- base::sys.nframe()
[16:13:54.203]     ...future.conditions <- base::list()
[16:13:54.203]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:54.203]     if (FALSE) {
[16:13:54.203]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:54.203]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:54.203]     }
[16:13:54.203]     ...future.result <- base::tryCatch({
[16:13:54.203]         base::withCallingHandlers({
[16:13:54.203]             ...future.value <- base::withVisible(base::local({
[16:13:54.203]                 ...future.makeSendCondition <- local({
[16:13:54.203]                   sendCondition <- NULL
[16:13:54.203]                   function(frame = 1L) {
[16:13:54.203]                     if (is.function(sendCondition)) 
[16:13:54.203]                       return(sendCondition)
[16:13:54.203]                     ns <- getNamespace("parallel")
[16:13:54.203]                     if (exists("sendData", mode = "function", 
[16:13:54.203]                       envir = ns)) {
[16:13:54.203]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:54.203]                         envir = ns)
[16:13:54.203]                       envir <- sys.frame(frame)
[16:13:54.203]                       master <- NULL
[16:13:54.203]                       while (!identical(envir, .GlobalEnv) && 
[16:13:54.203]                         !identical(envir, emptyenv())) {
[16:13:54.203]                         if (exists("master", mode = "list", envir = envir, 
[16:13:54.203]                           inherits = FALSE)) {
[16:13:54.203]                           master <- get("master", mode = "list", 
[16:13:54.203]                             envir = envir, inherits = FALSE)
[16:13:54.203]                           if (inherits(master, c("SOCKnode", 
[16:13:54.203]                             "SOCK0node"))) {
[16:13:54.203]                             sendCondition <<- function(cond) {
[16:13:54.203]                               data <- list(type = "VALUE", value = cond, 
[16:13:54.203]                                 success = TRUE)
[16:13:54.203]                               parallel_sendData(master, data)
[16:13:54.203]                             }
[16:13:54.203]                             return(sendCondition)
[16:13:54.203]                           }
[16:13:54.203]                         }
[16:13:54.203]                         frame <- frame + 1L
[16:13:54.203]                         envir <- sys.frame(frame)
[16:13:54.203]                       }
[16:13:54.203]                     }
[16:13:54.203]                     sendCondition <<- function(cond) NULL
[16:13:54.203]                   }
[16:13:54.203]                 })
[16:13:54.203]                 withCallingHandlers({
[16:13:54.203]                   {
[16:13:54.203]                     Sys.sleep(0.5)
[16:13:54.203]                     list(a = 1, b = 42L)
[16:13:54.203]                   }
[16:13:54.203]                 }, immediateCondition = function(cond) {
[16:13:54.203]                   sendCondition <- ...future.makeSendCondition()
[16:13:54.203]                   sendCondition(cond)
[16:13:54.203]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:54.203]                   {
[16:13:54.203]                     inherits <- base::inherits
[16:13:54.203]                     invokeRestart <- base::invokeRestart
[16:13:54.203]                     is.null <- base::is.null
[16:13:54.203]                     muffled <- FALSE
[16:13:54.203]                     if (inherits(cond, "message")) {
[16:13:54.203]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:54.203]                       if (muffled) 
[16:13:54.203]                         invokeRestart("muffleMessage")
[16:13:54.203]                     }
[16:13:54.203]                     else if (inherits(cond, "warning")) {
[16:13:54.203]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:54.203]                       if (muffled) 
[16:13:54.203]                         invokeRestart("muffleWarning")
[16:13:54.203]                     }
[16:13:54.203]                     else if (inherits(cond, "condition")) {
[16:13:54.203]                       if (!is.null(pattern)) {
[16:13:54.203]                         computeRestarts <- base::computeRestarts
[16:13:54.203]                         grepl <- base::grepl
[16:13:54.203]                         restarts <- computeRestarts(cond)
[16:13:54.203]                         for (restart in restarts) {
[16:13:54.203]                           name <- restart$name
[16:13:54.203]                           if (is.null(name)) 
[16:13:54.203]                             next
[16:13:54.203]                           if (!grepl(pattern, name)) 
[16:13:54.203]                             next
[16:13:54.203]                           invokeRestart(restart)
[16:13:54.203]                           muffled <- TRUE
[16:13:54.203]                           break
[16:13:54.203]                         }
[16:13:54.203]                       }
[16:13:54.203]                     }
[16:13:54.203]                     invisible(muffled)
[16:13:54.203]                   }
[16:13:54.203]                   muffleCondition(cond)
[16:13:54.203]                 })
[16:13:54.203]             }))
[16:13:54.203]             future::FutureResult(value = ...future.value$value, 
[16:13:54.203]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:54.203]                   ...future.rng), globalenv = if (FALSE) 
[16:13:54.203]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:54.203]                     ...future.globalenv.names))
[16:13:54.203]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:54.203]         }, condition = base::local({
[16:13:54.203]             c <- base::c
[16:13:54.203]             inherits <- base::inherits
[16:13:54.203]             invokeRestart <- base::invokeRestart
[16:13:54.203]             length <- base::length
[16:13:54.203]             list <- base::list
[16:13:54.203]             seq.int <- base::seq.int
[16:13:54.203]             signalCondition <- base::signalCondition
[16:13:54.203]             sys.calls <- base::sys.calls
[16:13:54.203]             `[[` <- base::`[[`
[16:13:54.203]             `+` <- base::`+`
[16:13:54.203]             `<<-` <- base::`<<-`
[16:13:54.203]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:54.203]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:54.203]                   3L)]
[16:13:54.203]             }
[16:13:54.203]             function(cond) {
[16:13:54.203]                 is_error <- inherits(cond, "error")
[16:13:54.203]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:54.203]                   NULL)
[16:13:54.203]                 if (is_error) {
[16:13:54.203]                   sessionInformation <- function() {
[16:13:54.203]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:54.203]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:54.203]                       search = base::search(), system = base::Sys.info())
[16:13:54.203]                   }
[16:13:54.203]                   ...future.conditions[[length(...future.conditions) + 
[16:13:54.203]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:54.203]                     cond$call), session = sessionInformation(), 
[16:13:54.203]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:54.203]                   signalCondition(cond)
[16:13:54.203]                 }
[16:13:54.203]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:54.203]                 "immediateCondition"))) {
[16:13:54.203]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:54.203]                   ...future.conditions[[length(...future.conditions) + 
[16:13:54.203]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:54.203]                   if (TRUE && !signal) {
[16:13:54.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:54.203]                     {
[16:13:54.203]                       inherits <- base::inherits
[16:13:54.203]                       invokeRestart <- base::invokeRestart
[16:13:54.203]                       is.null <- base::is.null
[16:13:54.203]                       muffled <- FALSE
[16:13:54.203]                       if (inherits(cond, "message")) {
[16:13:54.203]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:54.203]                         if (muffled) 
[16:13:54.203]                           invokeRestart("muffleMessage")
[16:13:54.203]                       }
[16:13:54.203]                       else if (inherits(cond, "warning")) {
[16:13:54.203]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:54.203]                         if (muffled) 
[16:13:54.203]                           invokeRestart("muffleWarning")
[16:13:54.203]                       }
[16:13:54.203]                       else if (inherits(cond, "condition")) {
[16:13:54.203]                         if (!is.null(pattern)) {
[16:13:54.203]                           computeRestarts <- base::computeRestarts
[16:13:54.203]                           grepl <- base::grepl
[16:13:54.203]                           restarts <- computeRestarts(cond)
[16:13:54.203]                           for (restart in restarts) {
[16:13:54.203]                             name <- restart$name
[16:13:54.203]                             if (is.null(name)) 
[16:13:54.203]                               next
[16:13:54.203]                             if (!grepl(pattern, name)) 
[16:13:54.203]                               next
[16:13:54.203]                             invokeRestart(restart)
[16:13:54.203]                             muffled <- TRUE
[16:13:54.203]                             break
[16:13:54.203]                           }
[16:13:54.203]                         }
[16:13:54.203]                       }
[16:13:54.203]                       invisible(muffled)
[16:13:54.203]                     }
[16:13:54.203]                     muffleCondition(cond, pattern = "^muffle")
[16:13:54.203]                   }
[16:13:54.203]                 }
[16:13:54.203]                 else {
[16:13:54.203]                   if (TRUE) {
[16:13:54.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:54.203]                     {
[16:13:54.203]                       inherits <- base::inherits
[16:13:54.203]                       invokeRestart <- base::invokeRestart
[16:13:54.203]                       is.null <- base::is.null
[16:13:54.203]                       muffled <- FALSE
[16:13:54.203]                       if (inherits(cond, "message")) {
[16:13:54.203]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:54.203]                         if (muffled) 
[16:13:54.203]                           invokeRestart("muffleMessage")
[16:13:54.203]                       }
[16:13:54.203]                       else if (inherits(cond, "warning")) {
[16:13:54.203]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:54.203]                         if (muffled) 
[16:13:54.203]                           invokeRestart("muffleWarning")
[16:13:54.203]                       }
[16:13:54.203]                       else if (inherits(cond, "condition")) {
[16:13:54.203]                         if (!is.null(pattern)) {
[16:13:54.203]                           computeRestarts <- base::computeRestarts
[16:13:54.203]                           grepl <- base::grepl
[16:13:54.203]                           restarts <- computeRestarts(cond)
[16:13:54.203]                           for (restart in restarts) {
[16:13:54.203]                             name <- restart$name
[16:13:54.203]                             if (is.null(name)) 
[16:13:54.203]                               next
[16:13:54.203]                             if (!grepl(pattern, name)) 
[16:13:54.203]                               next
[16:13:54.203]                             invokeRestart(restart)
[16:13:54.203]                             muffled <- TRUE
[16:13:54.203]                             break
[16:13:54.203]                           }
[16:13:54.203]                         }
[16:13:54.203]                       }
[16:13:54.203]                       invisible(muffled)
[16:13:54.203]                     }
[16:13:54.203]                     muffleCondition(cond, pattern = "^muffle")
[16:13:54.203]                   }
[16:13:54.203]                 }
[16:13:54.203]             }
[16:13:54.203]         }))
[16:13:54.203]     }, error = function(ex) {
[16:13:54.203]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:54.203]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:54.203]                 ...future.rng), started = ...future.startTime, 
[16:13:54.203]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:54.203]             version = "1.8"), class = "FutureResult")
[16:13:54.203]     }, finally = {
[16:13:54.203]         if (!identical(...future.workdir, getwd())) 
[16:13:54.203]             setwd(...future.workdir)
[16:13:54.203]         {
[16:13:54.203]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:54.203]                 ...future.oldOptions$nwarnings <- NULL
[16:13:54.203]             }
[16:13:54.203]             base::options(...future.oldOptions)
[16:13:54.203]             if (.Platform$OS.type == "windows") {
[16:13:54.203]                 old_names <- names(...future.oldEnvVars)
[16:13:54.203]                 envs <- base::Sys.getenv()
[16:13:54.203]                 names <- names(envs)
[16:13:54.203]                 common <- intersect(names, old_names)
[16:13:54.203]                 added <- setdiff(names, old_names)
[16:13:54.203]                 removed <- setdiff(old_names, names)
[16:13:54.203]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:54.203]                   envs[common]]
[16:13:54.203]                 NAMES <- toupper(changed)
[16:13:54.203]                 args <- list()
[16:13:54.203]                 for (kk in seq_along(NAMES)) {
[16:13:54.203]                   name <- changed[[kk]]
[16:13:54.203]                   NAME <- NAMES[[kk]]
[16:13:54.203]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:54.203]                     next
[16:13:54.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:54.203]                 }
[16:13:54.203]                 NAMES <- toupper(added)
[16:13:54.203]                 for (kk in seq_along(NAMES)) {
[16:13:54.203]                   name <- added[[kk]]
[16:13:54.203]                   NAME <- NAMES[[kk]]
[16:13:54.203]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:54.203]                     next
[16:13:54.203]                   args[[name]] <- ""
[16:13:54.203]                 }
[16:13:54.203]                 NAMES <- toupper(removed)
[16:13:54.203]                 for (kk in seq_along(NAMES)) {
[16:13:54.203]                   name <- removed[[kk]]
[16:13:54.203]                   NAME <- NAMES[[kk]]
[16:13:54.203]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:54.203]                     next
[16:13:54.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:54.203]                 }
[16:13:54.203]                 if (length(args) > 0) 
[16:13:54.203]                   base::do.call(base::Sys.setenv, args = args)
[16:13:54.203]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:54.203]             }
[16:13:54.203]             else {
[16:13:54.203]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:54.203]             }
[16:13:54.203]             {
[16:13:54.203]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:54.203]                   0L) {
[16:13:54.203]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:54.203]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:54.203]                   base::options(opts)
[16:13:54.203]                 }
[16:13:54.203]                 {
[16:13:54.203]                   {
[16:13:54.203]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:54.203]                     NULL
[16:13:54.203]                   }
[16:13:54.203]                   options(future.plan = NULL)
[16:13:54.203]                   if (is.na(NA_character_)) 
[16:13:54.203]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:54.203]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:54.203]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:54.203]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:54.203]                     envir = parent.frame()) 
[16:13:54.203]                   {
[16:13:54.203]                     if (is.function(workers)) 
[16:13:54.203]                       workers <- workers()
[16:13:54.203]                     workers <- structure(as.integer(workers), 
[16:13:54.203]                       class = class(workers))
[16:13:54.203]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:54.203]                       workers >= 1)
[16:13:54.203]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:54.203]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:54.203]                     }
[16:13:54.203]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:54.203]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:54.203]                       envir = envir)
[16:13:54.203]                     if (!future$lazy) 
[16:13:54.203]                       future <- run(future)
[16:13:54.203]                     invisible(future)
[16:13:54.203]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:54.203]                 }
[16:13:54.203]             }
[16:13:54.203]         }
[16:13:54.203]     })
[16:13:54.203]     if (TRUE) {
[16:13:54.203]         base::sink(type = "output", split = FALSE)
[16:13:54.203]         if (TRUE) {
[16:13:54.203]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:54.203]         }
[16:13:54.203]         else {
[16:13:54.203]             ...future.result["stdout"] <- base::list(NULL)
[16:13:54.203]         }
[16:13:54.203]         base::close(...future.stdout)
[16:13:54.203]         ...future.stdout <- NULL
[16:13:54.203]     }
[16:13:54.203]     ...future.result$conditions <- ...future.conditions
[16:13:54.203]     ...future.result$finished <- base::Sys.time()
[16:13:54.203]     ...future.result
[16:13:54.203] }
[16:13:54.206] MultisessionFuture started
[16:13:54.206] - Launch lazy future ... done
[16:13:54.206] run() for ‘MultisessionFuture’ ... done
[16:13:54.206] getGlobalsAndPackages() ...
[16:13:54.206] Searching for globals...
[16:13:54.207] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:54.208] Searching for globals ... DONE
[16:13:54.208] Resolving globals: FALSE
[16:13:54.208] 
[16:13:54.208] 
[16:13:54.208] getGlobalsAndPackages() ... DONE
- w/ exception ...
[16:13:54.209] getGlobalsAndPackages() ...
[16:13:54.209] Searching for globals...
[16:13:54.209] - globals found: [2] ‘list’, ‘stop’
[16:13:54.209] Searching for globals ... DONE
[16:13:54.210] Resolving globals: FALSE
[16:13:54.210] 
[16:13:54.210] 
[16:13:54.210] getGlobalsAndPackages() ... DONE
[16:13:54.210] run() for ‘Future’ ...
[16:13:54.210] - state: ‘created’
[16:13:54.210] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:54.225] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:54.225] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:54.225]   - Field: ‘node’
[16:13:54.225]   - Field: ‘label’
[16:13:54.225]   - Field: ‘local’
[16:13:54.225]   - Field: ‘owner’
[16:13:54.225]   - Field: ‘envir’
[16:13:54.225]   - Field: ‘workers’
[16:13:54.225]   - Field: ‘packages’
[16:13:54.225]   - Field: ‘gc’
[16:13:54.226]   - Field: ‘conditions’
[16:13:54.226]   - Field: ‘persistent’
[16:13:54.226]   - Field: ‘expr’
[16:13:54.226]   - Field: ‘uuid’
[16:13:54.226]   - Field: ‘seed’
[16:13:54.226]   - Field: ‘version’
[16:13:54.226]   - Field: ‘result’
[16:13:54.226]   - Field: ‘asynchronous’
[16:13:54.226]   - Field: ‘calls’
[16:13:54.226]   - Field: ‘globals’
[16:13:54.226]   - Field: ‘stdout’
[16:13:54.227]   - Field: ‘earlySignal’
[16:13:54.227]   - Field: ‘lazy’
[16:13:54.227]   - Field: ‘state’
[16:13:54.227] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:54.227] - Launch lazy future ...
[16:13:54.227] Packages needed by the future expression (n = 0): <none>
[16:13:54.227] Packages needed by future strategies (n = 0): <none>
[16:13:54.228] {
[16:13:54.228]     {
[16:13:54.228]         {
[16:13:54.228]             ...future.startTime <- base::Sys.time()
[16:13:54.228]             {
[16:13:54.228]                 {
[16:13:54.228]                   {
[16:13:54.228]                     {
[16:13:54.228]                       base::local({
[16:13:54.228]                         has_future <- base::requireNamespace("future", 
[16:13:54.228]                           quietly = TRUE)
[16:13:54.228]                         if (has_future) {
[16:13:54.228]                           ns <- base::getNamespace("future")
[16:13:54.228]                           version <- ns[[".package"]][["version"]]
[16:13:54.228]                           if (is.null(version)) 
[16:13:54.228]                             version <- utils::packageVersion("future")
[16:13:54.228]                         }
[16:13:54.228]                         else {
[16:13:54.228]                           version <- NULL
[16:13:54.228]                         }
[16:13:54.228]                         if (!has_future || version < "1.8.0") {
[16:13:54.228]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:54.228]                             "", base::R.version$version.string), 
[16:13:54.228]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:54.228]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:54.228]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:54.228]                               "release", "version")], collapse = " "), 
[16:13:54.228]                             hostname = base::Sys.info()[["nodename"]])
[16:13:54.228]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:54.228]                             info)
[16:13:54.228]                           info <- base::paste(info, collapse = "; ")
[16:13:54.228]                           if (!has_future) {
[16:13:54.228]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:54.228]                               info)
[16:13:54.228]                           }
[16:13:54.228]                           else {
[16:13:54.228]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:54.228]                               info, version)
[16:13:54.228]                           }
[16:13:54.228]                           base::stop(msg)
[16:13:54.228]                         }
[16:13:54.228]                       })
[16:13:54.228]                     }
[16:13:54.228]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:54.228]                     base::options(mc.cores = 1L)
[16:13:54.228]                   }
[16:13:54.228]                   options(future.plan = NULL)
[16:13:54.228]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:54.228]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:54.228]                 }
[16:13:54.228]                 ...future.workdir <- getwd()
[16:13:54.228]             }
[16:13:54.228]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:54.228]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:54.228]         }
[16:13:54.228]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:54.228]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:54.228]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:54.228]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:54.228]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:54.228]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:54.228]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:54.228]             base::names(...future.oldOptions))
[16:13:54.228]     }
[16:13:54.228]     if (FALSE) {
[16:13:54.228]     }
[16:13:54.228]     else {
[16:13:54.228]         if (TRUE) {
[16:13:54.228]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:54.228]                 open = "w")
[16:13:54.228]         }
[16:13:54.228]         else {
[16:13:54.228]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:54.228]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:54.228]         }
[16:13:54.228]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:54.228]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:54.228]             base::sink(type = "output", split = FALSE)
[16:13:54.228]             base::close(...future.stdout)
[16:13:54.228]         }, add = TRUE)
[16:13:54.228]     }
[16:13:54.228]     ...future.frame <- base::sys.nframe()
[16:13:54.228]     ...future.conditions <- base::list()
[16:13:54.228]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:54.228]     if (FALSE) {
[16:13:54.228]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:54.228]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:54.228]     }
[16:13:54.228]     ...future.result <- base::tryCatch({
[16:13:54.228]         base::withCallingHandlers({
[16:13:54.228]             ...future.value <- base::withVisible(base::local({
[16:13:54.228]                 ...future.makeSendCondition <- local({
[16:13:54.228]                   sendCondition <- NULL
[16:13:54.228]                   function(frame = 1L) {
[16:13:54.228]                     if (is.function(sendCondition)) 
[16:13:54.228]                       return(sendCondition)
[16:13:54.228]                     ns <- getNamespace("parallel")
[16:13:54.228]                     if (exists("sendData", mode = "function", 
[16:13:54.228]                       envir = ns)) {
[16:13:54.228]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:54.228]                         envir = ns)
[16:13:54.228]                       envir <- sys.frame(frame)
[16:13:54.228]                       master <- NULL
[16:13:54.228]                       while (!identical(envir, .GlobalEnv) && 
[16:13:54.228]                         !identical(envir, emptyenv())) {
[16:13:54.228]                         if (exists("master", mode = "list", envir = envir, 
[16:13:54.228]                           inherits = FALSE)) {
[16:13:54.228]                           master <- get("master", mode = "list", 
[16:13:54.228]                             envir = envir, inherits = FALSE)
[16:13:54.228]                           if (inherits(master, c("SOCKnode", 
[16:13:54.228]                             "SOCK0node"))) {
[16:13:54.228]                             sendCondition <<- function(cond) {
[16:13:54.228]                               data <- list(type = "VALUE", value = cond, 
[16:13:54.228]                                 success = TRUE)
[16:13:54.228]                               parallel_sendData(master, data)
[16:13:54.228]                             }
[16:13:54.228]                             return(sendCondition)
[16:13:54.228]                           }
[16:13:54.228]                         }
[16:13:54.228]                         frame <- frame + 1L
[16:13:54.228]                         envir <- sys.frame(frame)
[16:13:54.228]                       }
[16:13:54.228]                     }
[16:13:54.228]                     sendCondition <<- function(cond) NULL
[16:13:54.228]                   }
[16:13:54.228]                 })
[16:13:54.228]                 withCallingHandlers({
[16:13:54.228]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:54.228]                 }, immediateCondition = function(cond) {
[16:13:54.228]                   sendCondition <- ...future.makeSendCondition()
[16:13:54.228]                   sendCondition(cond)
[16:13:54.228]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:54.228]                   {
[16:13:54.228]                     inherits <- base::inherits
[16:13:54.228]                     invokeRestart <- base::invokeRestart
[16:13:54.228]                     is.null <- base::is.null
[16:13:54.228]                     muffled <- FALSE
[16:13:54.228]                     if (inherits(cond, "message")) {
[16:13:54.228]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:54.228]                       if (muffled) 
[16:13:54.228]                         invokeRestart("muffleMessage")
[16:13:54.228]                     }
[16:13:54.228]                     else if (inherits(cond, "warning")) {
[16:13:54.228]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:54.228]                       if (muffled) 
[16:13:54.228]                         invokeRestart("muffleWarning")
[16:13:54.228]                     }
[16:13:54.228]                     else if (inherits(cond, "condition")) {
[16:13:54.228]                       if (!is.null(pattern)) {
[16:13:54.228]                         computeRestarts <- base::computeRestarts
[16:13:54.228]                         grepl <- base::grepl
[16:13:54.228]                         restarts <- computeRestarts(cond)
[16:13:54.228]                         for (restart in restarts) {
[16:13:54.228]                           name <- restart$name
[16:13:54.228]                           if (is.null(name)) 
[16:13:54.228]                             next
[16:13:54.228]                           if (!grepl(pattern, name)) 
[16:13:54.228]                             next
[16:13:54.228]                           invokeRestart(restart)
[16:13:54.228]                           muffled <- TRUE
[16:13:54.228]                           break
[16:13:54.228]                         }
[16:13:54.228]                       }
[16:13:54.228]                     }
[16:13:54.228]                     invisible(muffled)
[16:13:54.228]                   }
[16:13:54.228]                   muffleCondition(cond)
[16:13:54.228]                 })
[16:13:54.228]             }))
[16:13:54.228]             future::FutureResult(value = ...future.value$value, 
[16:13:54.228]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:54.228]                   ...future.rng), globalenv = if (FALSE) 
[16:13:54.228]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:54.228]                     ...future.globalenv.names))
[16:13:54.228]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:54.228]         }, condition = base::local({
[16:13:54.228]             c <- base::c
[16:13:54.228]             inherits <- base::inherits
[16:13:54.228]             invokeRestart <- base::invokeRestart
[16:13:54.228]             length <- base::length
[16:13:54.228]             list <- base::list
[16:13:54.228]             seq.int <- base::seq.int
[16:13:54.228]             signalCondition <- base::signalCondition
[16:13:54.228]             sys.calls <- base::sys.calls
[16:13:54.228]             `[[` <- base::`[[`
[16:13:54.228]             `+` <- base::`+`
[16:13:54.228]             `<<-` <- base::`<<-`
[16:13:54.228]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:54.228]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:54.228]                   3L)]
[16:13:54.228]             }
[16:13:54.228]             function(cond) {
[16:13:54.228]                 is_error <- inherits(cond, "error")
[16:13:54.228]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:54.228]                   NULL)
[16:13:54.228]                 if (is_error) {
[16:13:54.228]                   sessionInformation <- function() {
[16:13:54.228]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:54.228]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:54.228]                       search = base::search(), system = base::Sys.info())
[16:13:54.228]                   }
[16:13:54.228]                   ...future.conditions[[length(...future.conditions) + 
[16:13:54.228]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:54.228]                     cond$call), session = sessionInformation(), 
[16:13:54.228]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:54.228]                   signalCondition(cond)
[16:13:54.228]                 }
[16:13:54.228]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:54.228]                 "immediateCondition"))) {
[16:13:54.228]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:54.228]                   ...future.conditions[[length(...future.conditions) + 
[16:13:54.228]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:54.228]                   if (TRUE && !signal) {
[16:13:54.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:54.228]                     {
[16:13:54.228]                       inherits <- base::inherits
[16:13:54.228]                       invokeRestart <- base::invokeRestart
[16:13:54.228]                       is.null <- base::is.null
[16:13:54.228]                       muffled <- FALSE
[16:13:54.228]                       if (inherits(cond, "message")) {
[16:13:54.228]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:54.228]                         if (muffled) 
[16:13:54.228]                           invokeRestart("muffleMessage")
[16:13:54.228]                       }
[16:13:54.228]                       else if (inherits(cond, "warning")) {
[16:13:54.228]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:54.228]                         if (muffled) 
[16:13:54.228]                           invokeRestart("muffleWarning")
[16:13:54.228]                       }
[16:13:54.228]                       else if (inherits(cond, "condition")) {
[16:13:54.228]                         if (!is.null(pattern)) {
[16:13:54.228]                           computeRestarts <- base::computeRestarts
[16:13:54.228]                           grepl <- base::grepl
[16:13:54.228]                           restarts <- computeRestarts(cond)
[16:13:54.228]                           for (restart in restarts) {
[16:13:54.228]                             name <- restart$name
[16:13:54.228]                             if (is.null(name)) 
[16:13:54.228]                               next
[16:13:54.228]                             if (!grepl(pattern, name)) 
[16:13:54.228]                               next
[16:13:54.228]                             invokeRestart(restart)
[16:13:54.228]                             muffled <- TRUE
[16:13:54.228]                             break
[16:13:54.228]                           }
[16:13:54.228]                         }
[16:13:54.228]                       }
[16:13:54.228]                       invisible(muffled)
[16:13:54.228]                     }
[16:13:54.228]                     muffleCondition(cond, pattern = "^muffle")
[16:13:54.228]                   }
[16:13:54.228]                 }
[16:13:54.228]                 else {
[16:13:54.228]                   if (TRUE) {
[16:13:54.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:54.228]                     {
[16:13:54.228]                       inherits <- base::inherits
[16:13:54.228]                       invokeRestart <- base::invokeRestart
[16:13:54.228]                       is.null <- base::is.null
[16:13:54.228]                       muffled <- FALSE
[16:13:54.228]                       if (inherits(cond, "message")) {
[16:13:54.228]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:54.228]                         if (muffled) 
[16:13:54.228]                           invokeRestart("muffleMessage")
[16:13:54.228]                       }
[16:13:54.228]                       else if (inherits(cond, "warning")) {
[16:13:54.228]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:54.228]                         if (muffled) 
[16:13:54.228]                           invokeRestart("muffleWarning")
[16:13:54.228]                       }
[16:13:54.228]                       else if (inherits(cond, "condition")) {
[16:13:54.228]                         if (!is.null(pattern)) {
[16:13:54.228]                           computeRestarts <- base::computeRestarts
[16:13:54.228]                           grepl <- base::grepl
[16:13:54.228]                           restarts <- computeRestarts(cond)
[16:13:54.228]                           for (restart in restarts) {
[16:13:54.228]                             name <- restart$name
[16:13:54.228]                             if (is.null(name)) 
[16:13:54.228]                               next
[16:13:54.228]                             if (!grepl(pattern, name)) 
[16:13:54.228]                               next
[16:13:54.228]                             invokeRestart(restart)
[16:13:54.228]                             muffled <- TRUE
[16:13:54.228]                             break
[16:13:54.228]                           }
[16:13:54.228]                         }
[16:13:54.228]                       }
[16:13:54.228]                       invisible(muffled)
[16:13:54.228]                     }
[16:13:54.228]                     muffleCondition(cond, pattern = "^muffle")
[16:13:54.228]                   }
[16:13:54.228]                 }
[16:13:54.228]             }
[16:13:54.228]         }))
[16:13:54.228]     }, error = function(ex) {
[16:13:54.228]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:54.228]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:54.228]                 ...future.rng), started = ...future.startTime, 
[16:13:54.228]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:54.228]             version = "1.8"), class = "FutureResult")
[16:13:54.228]     }, finally = {
[16:13:54.228]         if (!identical(...future.workdir, getwd())) 
[16:13:54.228]             setwd(...future.workdir)
[16:13:54.228]         {
[16:13:54.228]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:54.228]                 ...future.oldOptions$nwarnings <- NULL
[16:13:54.228]             }
[16:13:54.228]             base::options(...future.oldOptions)
[16:13:54.228]             if (.Platform$OS.type == "windows") {
[16:13:54.228]                 old_names <- names(...future.oldEnvVars)
[16:13:54.228]                 envs <- base::Sys.getenv()
[16:13:54.228]                 names <- names(envs)
[16:13:54.228]                 common <- intersect(names, old_names)
[16:13:54.228]                 added <- setdiff(names, old_names)
[16:13:54.228]                 removed <- setdiff(old_names, names)
[16:13:54.228]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:54.228]                   envs[common]]
[16:13:54.228]                 NAMES <- toupper(changed)
[16:13:54.228]                 args <- list()
[16:13:54.228]                 for (kk in seq_along(NAMES)) {
[16:13:54.228]                   name <- changed[[kk]]
[16:13:54.228]                   NAME <- NAMES[[kk]]
[16:13:54.228]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:54.228]                     next
[16:13:54.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:54.228]                 }
[16:13:54.228]                 NAMES <- toupper(added)
[16:13:54.228]                 for (kk in seq_along(NAMES)) {
[16:13:54.228]                   name <- added[[kk]]
[16:13:54.228]                   NAME <- NAMES[[kk]]
[16:13:54.228]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:54.228]                     next
[16:13:54.228]                   args[[name]] <- ""
[16:13:54.228]                 }
[16:13:54.228]                 NAMES <- toupper(removed)
[16:13:54.228]                 for (kk in seq_along(NAMES)) {
[16:13:54.228]                   name <- removed[[kk]]
[16:13:54.228]                   NAME <- NAMES[[kk]]
[16:13:54.228]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:54.228]                     next
[16:13:54.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:54.228]                 }
[16:13:54.228]                 if (length(args) > 0) 
[16:13:54.228]                   base::do.call(base::Sys.setenv, args = args)
[16:13:54.228]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:54.228]             }
[16:13:54.228]             else {
[16:13:54.228]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:54.228]             }
[16:13:54.228]             {
[16:13:54.228]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:54.228]                   0L) {
[16:13:54.228]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:54.228]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:54.228]                   base::options(opts)
[16:13:54.228]                 }
[16:13:54.228]                 {
[16:13:54.228]                   {
[16:13:54.228]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:54.228]                     NULL
[16:13:54.228]                   }
[16:13:54.228]                   options(future.plan = NULL)
[16:13:54.228]                   if (is.na(NA_character_)) 
[16:13:54.228]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:54.228]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:54.228]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:54.228]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:54.228]                     envir = parent.frame()) 
[16:13:54.228]                   {
[16:13:54.228]                     if (is.function(workers)) 
[16:13:54.228]                       workers <- workers()
[16:13:54.228]                     workers <- structure(as.integer(workers), 
[16:13:54.228]                       class = class(workers))
[16:13:54.228]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:54.228]                       workers >= 1)
[16:13:54.228]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:54.228]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:54.228]                     }
[16:13:54.228]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:54.228]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:54.228]                       envir = envir)
[16:13:54.228]                     if (!future$lazy) 
[16:13:54.228]                       future <- run(future)
[16:13:54.228]                     invisible(future)
[16:13:54.228]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:54.228]                 }
[16:13:54.228]             }
[16:13:54.228]         }
[16:13:54.228]     })
[16:13:54.228]     if (TRUE) {
[16:13:54.228]         base::sink(type = "output", split = FALSE)
[16:13:54.228]         if (TRUE) {
[16:13:54.228]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:54.228]         }
[16:13:54.228]         else {
[16:13:54.228]             ...future.result["stdout"] <- base::list(NULL)
[16:13:54.228]         }
[16:13:54.228]         base::close(...future.stdout)
[16:13:54.228]         ...future.stdout <- NULL
[16:13:54.228]     }
[16:13:54.228]     ...future.result$conditions <- ...future.conditions
[16:13:54.228]     ...future.result$finished <- base::Sys.time()
[16:13:54.228]     ...future.result
[16:13:54.228] }
[16:13:54.230] Poll #1 (0): usedNodes() = 2, workers = 2
[16:13:54.241] receiveMessageFromWorker() for ClusterFuture ...
[16:13:54.241] - Validating connection of MultisessionFuture
[16:13:54.241] - received message: FutureResult
[16:13:54.241] - Received FutureResult
[16:13:54.241] - Erased future from FutureRegistry
[16:13:54.241] result() for ClusterFuture ...
[16:13:54.241] - result already collected: FutureResult
[16:13:54.242] result() for ClusterFuture ... done
[16:13:54.242] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:54.242] result() for ClusterFuture ...
[16:13:54.242] - result already collected: FutureResult
[16:13:54.242] result() for ClusterFuture ... done
[16:13:54.242] result() for ClusterFuture ...
[16:13:54.242] - result already collected: FutureResult
[16:13:54.242] result() for ClusterFuture ... done
[16:13:54.243] MultisessionFuture started
[16:13:54.243] - Launch lazy future ... done
[16:13:54.244] run() for ‘MultisessionFuture’ ... done
[16:13:54.244] getGlobalsAndPackages() ...
[16:13:54.244] Searching for globals...
[16:13:54.244] - globals found: [2] ‘list’, ‘stop’
[16:13:54.245] Searching for globals ... DONE
[16:13:54.245] Resolving globals: FALSE
[16:13:54.245] 
[16:13:54.245] 
[16:13:54.245] getGlobalsAndPackages() ... DONE
- result = TRUE, recursive = -1 ... DONE
- result = TRUE, recursive = 0 ...
[16:13:54.246] getGlobalsAndPackages() ...
[16:13:54.246] Searching for globals...
[16:13:54.247] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:54.247] Searching for globals ... DONE
[16:13:54.247] Resolving globals: FALSE
[16:13:54.247] 
[16:13:54.247] 
[16:13:54.247] getGlobalsAndPackages() ... DONE
[16:13:54.248] run() for ‘Future’ ...
[16:13:54.248] - state: ‘created’
[16:13:54.248] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:54.263] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:54.264] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:54.264]   - Field: ‘node’
[16:13:54.264]   - Field: ‘label’
[16:13:54.264]   - Field: ‘local’
[16:13:54.264]   - Field: ‘owner’
[16:13:54.264]   - Field: ‘envir’
[16:13:54.264]   - Field: ‘workers’
[16:13:54.264]   - Field: ‘packages’
[16:13:54.264]   - Field: ‘gc’
[16:13:54.265]   - Field: ‘conditions’
[16:13:54.265]   - Field: ‘persistent’
[16:13:54.265]   - Field: ‘expr’
[16:13:54.265]   - Field: ‘uuid’
[16:13:54.265]   - Field: ‘seed’
[16:13:54.265]   - Field: ‘version’
[16:13:54.265]   - Field: ‘result’
[16:13:54.265]   - Field: ‘asynchronous’
[16:13:54.265]   - Field: ‘calls’
[16:13:54.265]   - Field: ‘globals’
[16:13:54.266]   - Field: ‘stdout’
[16:13:54.266]   - Field: ‘earlySignal’
[16:13:54.266]   - Field: ‘lazy’
[16:13:54.266]   - Field: ‘state’
[16:13:54.266] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:54.266] - Launch lazy future ...
[16:13:54.266] Packages needed by the future expression (n = 0): <none>
[16:13:54.266] Packages needed by future strategies (n = 0): <none>
[16:13:54.267] {
[16:13:54.267]     {
[16:13:54.267]         {
[16:13:54.267]             ...future.startTime <- base::Sys.time()
[16:13:54.267]             {
[16:13:54.267]                 {
[16:13:54.267]                   {
[16:13:54.267]                     {
[16:13:54.267]                       base::local({
[16:13:54.267]                         has_future <- base::requireNamespace("future", 
[16:13:54.267]                           quietly = TRUE)
[16:13:54.267]                         if (has_future) {
[16:13:54.267]                           ns <- base::getNamespace("future")
[16:13:54.267]                           version <- ns[[".package"]][["version"]]
[16:13:54.267]                           if (is.null(version)) 
[16:13:54.267]                             version <- utils::packageVersion("future")
[16:13:54.267]                         }
[16:13:54.267]                         else {
[16:13:54.267]                           version <- NULL
[16:13:54.267]                         }
[16:13:54.267]                         if (!has_future || version < "1.8.0") {
[16:13:54.267]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:54.267]                             "", base::R.version$version.string), 
[16:13:54.267]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:54.267]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:54.267]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:54.267]                               "release", "version")], collapse = " "), 
[16:13:54.267]                             hostname = base::Sys.info()[["nodename"]])
[16:13:54.267]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:54.267]                             info)
[16:13:54.267]                           info <- base::paste(info, collapse = "; ")
[16:13:54.267]                           if (!has_future) {
[16:13:54.267]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:54.267]                               info)
[16:13:54.267]                           }
[16:13:54.267]                           else {
[16:13:54.267]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:54.267]                               info, version)
[16:13:54.267]                           }
[16:13:54.267]                           base::stop(msg)
[16:13:54.267]                         }
[16:13:54.267]                       })
[16:13:54.267]                     }
[16:13:54.267]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:54.267]                     base::options(mc.cores = 1L)
[16:13:54.267]                   }
[16:13:54.267]                   options(future.plan = NULL)
[16:13:54.267]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:54.267]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:54.267]                 }
[16:13:54.267]                 ...future.workdir <- getwd()
[16:13:54.267]             }
[16:13:54.267]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:54.267]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:54.267]         }
[16:13:54.267]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:54.267]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:54.267]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:54.267]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:54.267]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:54.267]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:54.267]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:54.267]             base::names(...future.oldOptions))
[16:13:54.267]     }
[16:13:54.267]     if (FALSE) {
[16:13:54.267]     }
[16:13:54.267]     else {
[16:13:54.267]         if (TRUE) {
[16:13:54.267]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:54.267]                 open = "w")
[16:13:54.267]         }
[16:13:54.267]         else {
[16:13:54.267]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:54.267]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:54.267]         }
[16:13:54.267]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:54.267]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:54.267]             base::sink(type = "output", split = FALSE)
[16:13:54.267]             base::close(...future.stdout)
[16:13:54.267]         }, add = TRUE)
[16:13:54.267]     }
[16:13:54.267]     ...future.frame <- base::sys.nframe()
[16:13:54.267]     ...future.conditions <- base::list()
[16:13:54.267]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:54.267]     if (FALSE) {
[16:13:54.267]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:54.267]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:54.267]     }
[16:13:54.267]     ...future.result <- base::tryCatch({
[16:13:54.267]         base::withCallingHandlers({
[16:13:54.267]             ...future.value <- base::withVisible(base::local({
[16:13:54.267]                 ...future.makeSendCondition <- local({
[16:13:54.267]                   sendCondition <- NULL
[16:13:54.267]                   function(frame = 1L) {
[16:13:54.267]                     if (is.function(sendCondition)) 
[16:13:54.267]                       return(sendCondition)
[16:13:54.267]                     ns <- getNamespace("parallel")
[16:13:54.267]                     if (exists("sendData", mode = "function", 
[16:13:54.267]                       envir = ns)) {
[16:13:54.267]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:54.267]                         envir = ns)
[16:13:54.267]                       envir <- sys.frame(frame)
[16:13:54.267]                       master <- NULL
[16:13:54.267]                       while (!identical(envir, .GlobalEnv) && 
[16:13:54.267]                         !identical(envir, emptyenv())) {
[16:13:54.267]                         if (exists("master", mode = "list", envir = envir, 
[16:13:54.267]                           inherits = FALSE)) {
[16:13:54.267]                           master <- get("master", mode = "list", 
[16:13:54.267]                             envir = envir, inherits = FALSE)
[16:13:54.267]                           if (inherits(master, c("SOCKnode", 
[16:13:54.267]                             "SOCK0node"))) {
[16:13:54.267]                             sendCondition <<- function(cond) {
[16:13:54.267]                               data <- list(type = "VALUE", value = cond, 
[16:13:54.267]                                 success = TRUE)
[16:13:54.267]                               parallel_sendData(master, data)
[16:13:54.267]                             }
[16:13:54.267]                             return(sendCondition)
[16:13:54.267]                           }
[16:13:54.267]                         }
[16:13:54.267]                         frame <- frame + 1L
[16:13:54.267]                         envir <- sys.frame(frame)
[16:13:54.267]                       }
[16:13:54.267]                     }
[16:13:54.267]                     sendCondition <<- function(cond) NULL
[16:13:54.267]                   }
[16:13:54.267]                 })
[16:13:54.267]                 withCallingHandlers({
[16:13:54.267]                   {
[16:13:54.267]                     Sys.sleep(0.5)
[16:13:54.267]                     list(a = 1, b = 42L)
[16:13:54.267]                   }
[16:13:54.267]                 }, immediateCondition = function(cond) {
[16:13:54.267]                   sendCondition <- ...future.makeSendCondition()
[16:13:54.267]                   sendCondition(cond)
[16:13:54.267]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:54.267]                   {
[16:13:54.267]                     inherits <- base::inherits
[16:13:54.267]                     invokeRestart <- base::invokeRestart
[16:13:54.267]                     is.null <- base::is.null
[16:13:54.267]                     muffled <- FALSE
[16:13:54.267]                     if (inherits(cond, "message")) {
[16:13:54.267]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:54.267]                       if (muffled) 
[16:13:54.267]                         invokeRestart("muffleMessage")
[16:13:54.267]                     }
[16:13:54.267]                     else if (inherits(cond, "warning")) {
[16:13:54.267]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:54.267]                       if (muffled) 
[16:13:54.267]                         invokeRestart("muffleWarning")
[16:13:54.267]                     }
[16:13:54.267]                     else if (inherits(cond, "condition")) {
[16:13:54.267]                       if (!is.null(pattern)) {
[16:13:54.267]                         computeRestarts <- base::computeRestarts
[16:13:54.267]                         grepl <- base::grepl
[16:13:54.267]                         restarts <- computeRestarts(cond)
[16:13:54.267]                         for (restart in restarts) {
[16:13:54.267]                           name <- restart$name
[16:13:54.267]                           if (is.null(name)) 
[16:13:54.267]                             next
[16:13:54.267]                           if (!grepl(pattern, name)) 
[16:13:54.267]                             next
[16:13:54.267]                           invokeRestart(restart)
[16:13:54.267]                           muffled <- TRUE
[16:13:54.267]                           break
[16:13:54.267]                         }
[16:13:54.267]                       }
[16:13:54.267]                     }
[16:13:54.267]                     invisible(muffled)
[16:13:54.267]                   }
[16:13:54.267]                   muffleCondition(cond)
[16:13:54.267]                 })
[16:13:54.267]             }))
[16:13:54.267]             future::FutureResult(value = ...future.value$value, 
[16:13:54.267]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:54.267]                   ...future.rng), globalenv = if (FALSE) 
[16:13:54.267]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:54.267]                     ...future.globalenv.names))
[16:13:54.267]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:54.267]         }, condition = base::local({
[16:13:54.267]             c <- base::c
[16:13:54.267]             inherits <- base::inherits
[16:13:54.267]             invokeRestart <- base::invokeRestart
[16:13:54.267]             length <- base::length
[16:13:54.267]             list <- base::list
[16:13:54.267]             seq.int <- base::seq.int
[16:13:54.267]             signalCondition <- base::signalCondition
[16:13:54.267]             sys.calls <- base::sys.calls
[16:13:54.267]             `[[` <- base::`[[`
[16:13:54.267]             `+` <- base::`+`
[16:13:54.267]             `<<-` <- base::`<<-`
[16:13:54.267]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:54.267]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:54.267]                   3L)]
[16:13:54.267]             }
[16:13:54.267]             function(cond) {
[16:13:54.267]                 is_error <- inherits(cond, "error")
[16:13:54.267]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:54.267]                   NULL)
[16:13:54.267]                 if (is_error) {
[16:13:54.267]                   sessionInformation <- function() {
[16:13:54.267]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:54.267]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:54.267]                       search = base::search(), system = base::Sys.info())
[16:13:54.267]                   }
[16:13:54.267]                   ...future.conditions[[length(...future.conditions) + 
[16:13:54.267]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:54.267]                     cond$call), session = sessionInformation(), 
[16:13:54.267]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:54.267]                   signalCondition(cond)
[16:13:54.267]                 }
[16:13:54.267]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:54.267]                 "immediateCondition"))) {
[16:13:54.267]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:54.267]                   ...future.conditions[[length(...future.conditions) + 
[16:13:54.267]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:54.267]                   if (TRUE && !signal) {
[16:13:54.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:54.267]                     {
[16:13:54.267]                       inherits <- base::inherits
[16:13:54.267]                       invokeRestart <- base::invokeRestart
[16:13:54.267]                       is.null <- base::is.null
[16:13:54.267]                       muffled <- FALSE
[16:13:54.267]                       if (inherits(cond, "message")) {
[16:13:54.267]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:54.267]                         if (muffled) 
[16:13:54.267]                           invokeRestart("muffleMessage")
[16:13:54.267]                       }
[16:13:54.267]                       else if (inherits(cond, "warning")) {
[16:13:54.267]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:54.267]                         if (muffled) 
[16:13:54.267]                           invokeRestart("muffleWarning")
[16:13:54.267]                       }
[16:13:54.267]                       else if (inherits(cond, "condition")) {
[16:13:54.267]                         if (!is.null(pattern)) {
[16:13:54.267]                           computeRestarts <- base::computeRestarts
[16:13:54.267]                           grepl <- base::grepl
[16:13:54.267]                           restarts <- computeRestarts(cond)
[16:13:54.267]                           for (restart in restarts) {
[16:13:54.267]                             name <- restart$name
[16:13:54.267]                             if (is.null(name)) 
[16:13:54.267]                               next
[16:13:54.267]                             if (!grepl(pattern, name)) 
[16:13:54.267]                               next
[16:13:54.267]                             invokeRestart(restart)
[16:13:54.267]                             muffled <- TRUE
[16:13:54.267]                             break
[16:13:54.267]                           }
[16:13:54.267]                         }
[16:13:54.267]                       }
[16:13:54.267]                       invisible(muffled)
[16:13:54.267]                     }
[16:13:54.267]                     muffleCondition(cond, pattern = "^muffle")
[16:13:54.267]                   }
[16:13:54.267]                 }
[16:13:54.267]                 else {
[16:13:54.267]                   if (TRUE) {
[16:13:54.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:54.267]                     {
[16:13:54.267]                       inherits <- base::inherits
[16:13:54.267]                       invokeRestart <- base::invokeRestart
[16:13:54.267]                       is.null <- base::is.null
[16:13:54.267]                       muffled <- FALSE
[16:13:54.267]                       if (inherits(cond, "message")) {
[16:13:54.267]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:54.267]                         if (muffled) 
[16:13:54.267]                           invokeRestart("muffleMessage")
[16:13:54.267]                       }
[16:13:54.267]                       else if (inherits(cond, "warning")) {
[16:13:54.267]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:54.267]                         if (muffled) 
[16:13:54.267]                           invokeRestart("muffleWarning")
[16:13:54.267]                       }
[16:13:54.267]                       else if (inherits(cond, "condition")) {
[16:13:54.267]                         if (!is.null(pattern)) {
[16:13:54.267]                           computeRestarts <- base::computeRestarts
[16:13:54.267]                           grepl <- base::grepl
[16:13:54.267]                           restarts <- computeRestarts(cond)
[16:13:54.267]                           for (restart in restarts) {
[16:13:54.267]                             name <- restart$name
[16:13:54.267]                             if (is.null(name)) 
[16:13:54.267]                               next
[16:13:54.267]                             if (!grepl(pattern, name)) 
[16:13:54.267]                               next
[16:13:54.267]                             invokeRestart(restart)
[16:13:54.267]                             muffled <- TRUE
[16:13:54.267]                             break
[16:13:54.267]                           }
[16:13:54.267]                         }
[16:13:54.267]                       }
[16:13:54.267]                       invisible(muffled)
[16:13:54.267]                     }
[16:13:54.267]                     muffleCondition(cond, pattern = "^muffle")
[16:13:54.267]                   }
[16:13:54.267]                 }
[16:13:54.267]             }
[16:13:54.267]         }))
[16:13:54.267]     }, error = function(ex) {
[16:13:54.267]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:54.267]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:54.267]                 ...future.rng), started = ...future.startTime, 
[16:13:54.267]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:54.267]             version = "1.8"), class = "FutureResult")
[16:13:54.267]     }, finally = {
[16:13:54.267]         if (!identical(...future.workdir, getwd())) 
[16:13:54.267]             setwd(...future.workdir)
[16:13:54.267]         {
[16:13:54.267]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:54.267]                 ...future.oldOptions$nwarnings <- NULL
[16:13:54.267]             }
[16:13:54.267]             base::options(...future.oldOptions)
[16:13:54.267]             if (.Platform$OS.type == "windows") {
[16:13:54.267]                 old_names <- names(...future.oldEnvVars)
[16:13:54.267]                 envs <- base::Sys.getenv()
[16:13:54.267]                 names <- names(envs)
[16:13:54.267]                 common <- intersect(names, old_names)
[16:13:54.267]                 added <- setdiff(names, old_names)
[16:13:54.267]                 removed <- setdiff(old_names, names)
[16:13:54.267]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:54.267]                   envs[common]]
[16:13:54.267]                 NAMES <- toupper(changed)
[16:13:54.267]                 args <- list()
[16:13:54.267]                 for (kk in seq_along(NAMES)) {
[16:13:54.267]                   name <- changed[[kk]]
[16:13:54.267]                   NAME <- NAMES[[kk]]
[16:13:54.267]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:54.267]                     next
[16:13:54.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:54.267]                 }
[16:13:54.267]                 NAMES <- toupper(added)
[16:13:54.267]                 for (kk in seq_along(NAMES)) {
[16:13:54.267]                   name <- added[[kk]]
[16:13:54.267]                   NAME <- NAMES[[kk]]
[16:13:54.267]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:54.267]                     next
[16:13:54.267]                   args[[name]] <- ""
[16:13:54.267]                 }
[16:13:54.267]                 NAMES <- toupper(removed)
[16:13:54.267]                 for (kk in seq_along(NAMES)) {
[16:13:54.267]                   name <- removed[[kk]]
[16:13:54.267]                   NAME <- NAMES[[kk]]
[16:13:54.267]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:54.267]                     next
[16:13:54.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:54.267]                 }
[16:13:54.267]                 if (length(args) > 0) 
[16:13:54.267]                   base::do.call(base::Sys.setenv, args = args)
[16:13:54.267]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:54.267]             }
[16:13:54.267]             else {
[16:13:54.267]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:54.267]             }
[16:13:54.267]             {
[16:13:54.267]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:54.267]                   0L) {
[16:13:54.267]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:54.267]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:54.267]                   base::options(opts)
[16:13:54.267]                 }
[16:13:54.267]                 {
[16:13:54.267]                   {
[16:13:54.267]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:54.267]                     NULL
[16:13:54.267]                   }
[16:13:54.267]                   options(future.plan = NULL)
[16:13:54.267]                   if (is.na(NA_character_)) 
[16:13:54.267]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:54.267]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:54.267]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:54.267]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:54.267]                     envir = parent.frame()) 
[16:13:54.267]                   {
[16:13:54.267]                     if (is.function(workers)) 
[16:13:54.267]                       workers <- workers()
[16:13:54.267]                     workers <- structure(as.integer(workers), 
[16:13:54.267]                       class = class(workers))
[16:13:54.267]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:54.267]                       workers >= 1)
[16:13:54.267]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:54.267]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:54.267]                     }
[16:13:54.267]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:54.267]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:54.267]                       envir = envir)
[16:13:54.267]                     if (!future$lazy) 
[16:13:54.267]                       future <- run(future)
[16:13:54.267]                     invisible(future)
[16:13:54.267]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:54.267]                 }
[16:13:54.267]             }
[16:13:54.267]         }
[16:13:54.267]     })
[16:13:54.267]     if (TRUE) {
[16:13:54.267]         base::sink(type = "output", split = FALSE)
[16:13:54.267]         if (TRUE) {
[16:13:54.267]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:54.267]         }
[16:13:54.267]         else {
[16:13:54.267]             ...future.result["stdout"] <- base::list(NULL)
[16:13:54.267]         }
[16:13:54.267]         base::close(...future.stdout)
[16:13:54.267]         ...future.stdout <- NULL
[16:13:54.267]     }
[16:13:54.267]     ...future.result$conditions <- ...future.conditions
[16:13:54.267]     ...future.result$finished <- base::Sys.time()
[16:13:54.267]     ...future.result
[16:13:54.267] }
[16:13:54.269] Poll #1 (0): usedNodes() = 2, workers = 2
[16:13:54.293] receiveMessageFromWorker() for ClusterFuture ...
[16:13:54.293] - Validating connection of MultisessionFuture
[16:13:54.294] - received message: FutureResult
[16:13:54.296] - Received FutureResult
[16:13:54.297] - Erased future from FutureRegistry
[16:13:54.297] result() for ClusterFuture ...
[16:13:54.297] - result already collected: FutureResult
[16:13:54.297] result() for ClusterFuture ... done
[16:13:54.297] signalConditions() ...
[16:13:54.297]  - include = ‘immediateCondition’
[16:13:54.297]  - exclude = 
[16:13:54.297]  - resignal = FALSE
[16:13:54.298]  - Number of conditions: 1
[16:13:54.298] signalConditions() ... done
[16:13:54.298] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:54.298] result() for ClusterFuture ...
[16:13:54.298] - result already collected: FutureResult
[16:13:54.298] result() for ClusterFuture ... done
[16:13:54.298] result() for ClusterFuture ...
[16:13:54.298] - result already collected: FutureResult
[16:13:54.298] result() for ClusterFuture ... done
[16:13:54.299] signalConditions() ...
[16:13:54.299]  - include = ‘immediateCondition’
[16:13:54.299]  - exclude = 
[16:13:54.299]  - resignal = FALSE
[16:13:54.299]  - Number of conditions: 1
[16:13:54.299] signalConditions() ... done
[16:13:54.300] MultisessionFuture started
[16:13:54.300] - Launch lazy future ... done
[16:13:54.301] run() for ‘MultisessionFuture’ ... done
[16:13:54.858] receiveMessageFromWorker() for ClusterFuture ...
[16:13:54.858] - Validating connection of MultisessionFuture
[16:13:54.859] - received message: FutureResult
[16:13:54.859] - Received FutureResult
[16:13:54.859] - Erased future from FutureRegistry
[16:13:54.859] result() for ClusterFuture ...
[16:13:54.859] - result already collected: FutureResult
[16:13:54.859] result() for ClusterFuture ... done
[16:13:54.859] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:54.859] A MultisessionFuture was resolved
[16:13:54.859] getGlobalsAndPackages() ...
[16:13:54.859] Searching for globals...
[16:13:54.861] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:54.861] Searching for globals ... DONE
[16:13:54.861] Resolving globals: FALSE
[16:13:54.861] 
[16:13:54.861] 
[16:13:54.861] getGlobalsAndPackages() ... DONE
[16:13:54.862] run() for ‘Future’ ...
[16:13:54.862] - state: ‘created’
[16:13:54.862] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:54.876] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:54.877] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:54.877]   - Field: ‘node’
[16:13:54.877]   - Field: ‘label’
[16:13:54.877]   - Field: ‘local’
[16:13:54.877]   - Field: ‘owner’
[16:13:54.877]   - Field: ‘envir’
[16:13:54.877]   - Field: ‘workers’
[16:13:54.877]   - Field: ‘packages’
[16:13:54.878]   - Field: ‘gc’
[16:13:54.878]   - Field: ‘conditions’
[16:13:54.878]   - Field: ‘persistent’
[16:13:54.878]   - Field: ‘expr’
[16:13:54.878]   - Field: ‘uuid’
[16:13:54.878]   - Field: ‘seed’
[16:13:54.878]   - Field: ‘version’
[16:13:54.878]   - Field: ‘result’
[16:13:54.878]   - Field: ‘asynchronous’
[16:13:54.878]   - Field: ‘calls’
[16:13:54.878]   - Field: ‘globals’
[16:13:54.879]   - Field: ‘stdout’
[16:13:54.879]   - Field: ‘earlySignal’
[16:13:54.879]   - Field: ‘lazy’
[16:13:54.879]   - Field: ‘state’
[16:13:54.879] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:54.879] - Launch lazy future ...
[16:13:54.879] Packages needed by the future expression (n = 0): <none>
[16:13:54.879] Packages needed by future strategies (n = 0): <none>
[16:13:54.880] {
[16:13:54.880]     {
[16:13:54.880]         {
[16:13:54.880]             ...future.startTime <- base::Sys.time()
[16:13:54.880]             {
[16:13:54.880]                 {
[16:13:54.880]                   {
[16:13:54.880]                     {
[16:13:54.880]                       base::local({
[16:13:54.880]                         has_future <- base::requireNamespace("future", 
[16:13:54.880]                           quietly = TRUE)
[16:13:54.880]                         if (has_future) {
[16:13:54.880]                           ns <- base::getNamespace("future")
[16:13:54.880]                           version <- ns[[".package"]][["version"]]
[16:13:54.880]                           if (is.null(version)) 
[16:13:54.880]                             version <- utils::packageVersion("future")
[16:13:54.880]                         }
[16:13:54.880]                         else {
[16:13:54.880]                           version <- NULL
[16:13:54.880]                         }
[16:13:54.880]                         if (!has_future || version < "1.8.0") {
[16:13:54.880]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:54.880]                             "", base::R.version$version.string), 
[16:13:54.880]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:54.880]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:54.880]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:54.880]                               "release", "version")], collapse = " "), 
[16:13:54.880]                             hostname = base::Sys.info()[["nodename"]])
[16:13:54.880]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:54.880]                             info)
[16:13:54.880]                           info <- base::paste(info, collapse = "; ")
[16:13:54.880]                           if (!has_future) {
[16:13:54.880]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:54.880]                               info)
[16:13:54.880]                           }
[16:13:54.880]                           else {
[16:13:54.880]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:54.880]                               info, version)
[16:13:54.880]                           }
[16:13:54.880]                           base::stop(msg)
[16:13:54.880]                         }
[16:13:54.880]                       })
[16:13:54.880]                     }
[16:13:54.880]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:54.880]                     base::options(mc.cores = 1L)
[16:13:54.880]                   }
[16:13:54.880]                   options(future.plan = NULL)
[16:13:54.880]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:54.880]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:54.880]                 }
[16:13:54.880]                 ...future.workdir <- getwd()
[16:13:54.880]             }
[16:13:54.880]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:54.880]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:54.880]         }
[16:13:54.880]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:54.880]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:54.880]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:54.880]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:54.880]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:54.880]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:54.880]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:54.880]             base::names(...future.oldOptions))
[16:13:54.880]     }
[16:13:54.880]     if (FALSE) {
[16:13:54.880]     }
[16:13:54.880]     else {
[16:13:54.880]         if (TRUE) {
[16:13:54.880]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:54.880]                 open = "w")
[16:13:54.880]         }
[16:13:54.880]         else {
[16:13:54.880]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:54.880]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:54.880]         }
[16:13:54.880]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:54.880]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:54.880]             base::sink(type = "output", split = FALSE)
[16:13:54.880]             base::close(...future.stdout)
[16:13:54.880]         }, add = TRUE)
[16:13:54.880]     }
[16:13:54.880]     ...future.frame <- base::sys.nframe()
[16:13:54.880]     ...future.conditions <- base::list()
[16:13:54.880]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:54.880]     if (FALSE) {
[16:13:54.880]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:54.880]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:54.880]     }
[16:13:54.880]     ...future.result <- base::tryCatch({
[16:13:54.880]         base::withCallingHandlers({
[16:13:54.880]             ...future.value <- base::withVisible(base::local({
[16:13:54.880]                 ...future.makeSendCondition <- local({
[16:13:54.880]                   sendCondition <- NULL
[16:13:54.880]                   function(frame = 1L) {
[16:13:54.880]                     if (is.function(sendCondition)) 
[16:13:54.880]                       return(sendCondition)
[16:13:54.880]                     ns <- getNamespace("parallel")
[16:13:54.880]                     if (exists("sendData", mode = "function", 
[16:13:54.880]                       envir = ns)) {
[16:13:54.880]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:54.880]                         envir = ns)
[16:13:54.880]                       envir <- sys.frame(frame)
[16:13:54.880]                       master <- NULL
[16:13:54.880]                       while (!identical(envir, .GlobalEnv) && 
[16:13:54.880]                         !identical(envir, emptyenv())) {
[16:13:54.880]                         if (exists("master", mode = "list", envir = envir, 
[16:13:54.880]                           inherits = FALSE)) {
[16:13:54.880]                           master <- get("master", mode = "list", 
[16:13:54.880]                             envir = envir, inherits = FALSE)
[16:13:54.880]                           if (inherits(master, c("SOCKnode", 
[16:13:54.880]                             "SOCK0node"))) {
[16:13:54.880]                             sendCondition <<- function(cond) {
[16:13:54.880]                               data <- list(type = "VALUE", value = cond, 
[16:13:54.880]                                 success = TRUE)
[16:13:54.880]                               parallel_sendData(master, data)
[16:13:54.880]                             }
[16:13:54.880]                             return(sendCondition)
[16:13:54.880]                           }
[16:13:54.880]                         }
[16:13:54.880]                         frame <- frame + 1L
[16:13:54.880]                         envir <- sys.frame(frame)
[16:13:54.880]                       }
[16:13:54.880]                     }
[16:13:54.880]                     sendCondition <<- function(cond) NULL
[16:13:54.880]                   }
[16:13:54.880]                 })
[16:13:54.880]                 withCallingHandlers({
[16:13:54.880]                   {
[16:13:54.880]                     Sys.sleep(0.5)
[16:13:54.880]                     list(a = 1, b = 42L)
[16:13:54.880]                   }
[16:13:54.880]                 }, immediateCondition = function(cond) {
[16:13:54.880]                   sendCondition <- ...future.makeSendCondition()
[16:13:54.880]                   sendCondition(cond)
[16:13:54.880]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:54.880]                   {
[16:13:54.880]                     inherits <- base::inherits
[16:13:54.880]                     invokeRestart <- base::invokeRestart
[16:13:54.880]                     is.null <- base::is.null
[16:13:54.880]                     muffled <- FALSE
[16:13:54.880]                     if (inherits(cond, "message")) {
[16:13:54.880]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:54.880]                       if (muffled) 
[16:13:54.880]                         invokeRestart("muffleMessage")
[16:13:54.880]                     }
[16:13:54.880]                     else if (inherits(cond, "warning")) {
[16:13:54.880]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:54.880]                       if (muffled) 
[16:13:54.880]                         invokeRestart("muffleWarning")
[16:13:54.880]                     }
[16:13:54.880]                     else if (inherits(cond, "condition")) {
[16:13:54.880]                       if (!is.null(pattern)) {
[16:13:54.880]                         computeRestarts <- base::computeRestarts
[16:13:54.880]                         grepl <- base::grepl
[16:13:54.880]                         restarts <- computeRestarts(cond)
[16:13:54.880]                         for (restart in restarts) {
[16:13:54.880]                           name <- restart$name
[16:13:54.880]                           if (is.null(name)) 
[16:13:54.880]                             next
[16:13:54.880]                           if (!grepl(pattern, name)) 
[16:13:54.880]                             next
[16:13:54.880]                           invokeRestart(restart)
[16:13:54.880]                           muffled <- TRUE
[16:13:54.880]                           break
[16:13:54.880]                         }
[16:13:54.880]                       }
[16:13:54.880]                     }
[16:13:54.880]                     invisible(muffled)
[16:13:54.880]                   }
[16:13:54.880]                   muffleCondition(cond)
[16:13:54.880]                 })
[16:13:54.880]             }))
[16:13:54.880]             future::FutureResult(value = ...future.value$value, 
[16:13:54.880]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:54.880]                   ...future.rng), globalenv = if (FALSE) 
[16:13:54.880]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:54.880]                     ...future.globalenv.names))
[16:13:54.880]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:54.880]         }, condition = base::local({
[16:13:54.880]             c <- base::c
[16:13:54.880]             inherits <- base::inherits
[16:13:54.880]             invokeRestart <- base::invokeRestart
[16:13:54.880]             length <- base::length
[16:13:54.880]             list <- base::list
[16:13:54.880]             seq.int <- base::seq.int
[16:13:54.880]             signalCondition <- base::signalCondition
[16:13:54.880]             sys.calls <- base::sys.calls
[16:13:54.880]             `[[` <- base::`[[`
[16:13:54.880]             `+` <- base::`+`
[16:13:54.880]             `<<-` <- base::`<<-`
[16:13:54.880]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:54.880]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:54.880]                   3L)]
[16:13:54.880]             }
[16:13:54.880]             function(cond) {
[16:13:54.880]                 is_error <- inherits(cond, "error")
[16:13:54.880]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:54.880]                   NULL)
[16:13:54.880]                 if (is_error) {
[16:13:54.880]                   sessionInformation <- function() {
[16:13:54.880]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:54.880]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:54.880]                       search = base::search(), system = base::Sys.info())
[16:13:54.880]                   }
[16:13:54.880]                   ...future.conditions[[length(...future.conditions) + 
[16:13:54.880]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:54.880]                     cond$call), session = sessionInformation(), 
[16:13:54.880]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:54.880]                   signalCondition(cond)
[16:13:54.880]                 }
[16:13:54.880]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:54.880]                 "immediateCondition"))) {
[16:13:54.880]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:54.880]                   ...future.conditions[[length(...future.conditions) + 
[16:13:54.880]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:54.880]                   if (TRUE && !signal) {
[16:13:54.880]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:54.880]                     {
[16:13:54.880]                       inherits <- base::inherits
[16:13:54.880]                       invokeRestart <- base::invokeRestart
[16:13:54.880]                       is.null <- base::is.null
[16:13:54.880]                       muffled <- FALSE
[16:13:54.880]                       if (inherits(cond, "message")) {
[16:13:54.880]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:54.880]                         if (muffled) 
[16:13:54.880]                           invokeRestart("muffleMessage")
[16:13:54.880]                       }
[16:13:54.880]                       else if (inherits(cond, "warning")) {
[16:13:54.880]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:54.880]                         if (muffled) 
[16:13:54.880]                           invokeRestart("muffleWarning")
[16:13:54.880]                       }
[16:13:54.880]                       else if (inherits(cond, "condition")) {
[16:13:54.880]                         if (!is.null(pattern)) {
[16:13:54.880]                           computeRestarts <- base::computeRestarts
[16:13:54.880]                           grepl <- base::grepl
[16:13:54.880]                           restarts <- computeRestarts(cond)
[16:13:54.880]                           for (restart in restarts) {
[16:13:54.880]                             name <- restart$name
[16:13:54.880]                             if (is.null(name)) 
[16:13:54.880]                               next
[16:13:54.880]                             if (!grepl(pattern, name)) 
[16:13:54.880]                               next
[16:13:54.880]                             invokeRestart(restart)
[16:13:54.880]                             muffled <- TRUE
[16:13:54.880]                             break
[16:13:54.880]                           }
[16:13:54.880]                         }
[16:13:54.880]                       }
[16:13:54.880]                       invisible(muffled)
[16:13:54.880]                     }
[16:13:54.880]                     muffleCondition(cond, pattern = "^muffle")
[16:13:54.880]                   }
[16:13:54.880]                 }
[16:13:54.880]                 else {
[16:13:54.880]                   if (TRUE) {
[16:13:54.880]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:54.880]                     {
[16:13:54.880]                       inherits <- base::inherits
[16:13:54.880]                       invokeRestart <- base::invokeRestart
[16:13:54.880]                       is.null <- base::is.null
[16:13:54.880]                       muffled <- FALSE
[16:13:54.880]                       if (inherits(cond, "message")) {
[16:13:54.880]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:54.880]                         if (muffled) 
[16:13:54.880]                           invokeRestart("muffleMessage")
[16:13:54.880]                       }
[16:13:54.880]                       else if (inherits(cond, "warning")) {
[16:13:54.880]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:54.880]                         if (muffled) 
[16:13:54.880]                           invokeRestart("muffleWarning")
[16:13:54.880]                       }
[16:13:54.880]                       else if (inherits(cond, "condition")) {
[16:13:54.880]                         if (!is.null(pattern)) {
[16:13:54.880]                           computeRestarts <- base::computeRestarts
[16:13:54.880]                           grepl <- base::grepl
[16:13:54.880]                           restarts <- computeRestarts(cond)
[16:13:54.880]                           for (restart in restarts) {
[16:13:54.880]                             name <- restart$name
[16:13:54.880]                             if (is.null(name)) 
[16:13:54.880]                               next
[16:13:54.880]                             if (!grepl(pattern, name)) 
[16:13:54.880]                               next
[16:13:54.880]                             invokeRestart(restart)
[16:13:54.880]                             muffled <- TRUE
[16:13:54.880]                             break
[16:13:54.880]                           }
[16:13:54.880]                         }
[16:13:54.880]                       }
[16:13:54.880]                       invisible(muffled)
[16:13:54.880]                     }
[16:13:54.880]                     muffleCondition(cond, pattern = "^muffle")
[16:13:54.880]                   }
[16:13:54.880]                 }
[16:13:54.880]             }
[16:13:54.880]         }))
[16:13:54.880]     }, error = function(ex) {
[16:13:54.880]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:54.880]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:54.880]                 ...future.rng), started = ...future.startTime, 
[16:13:54.880]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:54.880]             version = "1.8"), class = "FutureResult")
[16:13:54.880]     }, finally = {
[16:13:54.880]         if (!identical(...future.workdir, getwd())) 
[16:13:54.880]             setwd(...future.workdir)
[16:13:54.880]         {
[16:13:54.880]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:54.880]                 ...future.oldOptions$nwarnings <- NULL
[16:13:54.880]             }
[16:13:54.880]             base::options(...future.oldOptions)
[16:13:54.880]             if (.Platform$OS.type == "windows") {
[16:13:54.880]                 old_names <- names(...future.oldEnvVars)
[16:13:54.880]                 envs <- base::Sys.getenv()
[16:13:54.880]                 names <- names(envs)
[16:13:54.880]                 common <- intersect(names, old_names)
[16:13:54.880]                 added <- setdiff(names, old_names)
[16:13:54.880]                 removed <- setdiff(old_names, names)
[16:13:54.880]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:54.880]                   envs[common]]
[16:13:54.880]                 NAMES <- toupper(changed)
[16:13:54.880]                 args <- list()
[16:13:54.880]                 for (kk in seq_along(NAMES)) {
[16:13:54.880]                   name <- changed[[kk]]
[16:13:54.880]                   NAME <- NAMES[[kk]]
[16:13:54.880]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:54.880]                     next
[16:13:54.880]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:54.880]                 }
[16:13:54.880]                 NAMES <- toupper(added)
[16:13:54.880]                 for (kk in seq_along(NAMES)) {
[16:13:54.880]                   name <- added[[kk]]
[16:13:54.880]                   NAME <- NAMES[[kk]]
[16:13:54.880]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:54.880]                     next
[16:13:54.880]                   args[[name]] <- ""
[16:13:54.880]                 }
[16:13:54.880]                 NAMES <- toupper(removed)
[16:13:54.880]                 for (kk in seq_along(NAMES)) {
[16:13:54.880]                   name <- removed[[kk]]
[16:13:54.880]                   NAME <- NAMES[[kk]]
[16:13:54.880]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:54.880]                     next
[16:13:54.880]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:54.880]                 }
[16:13:54.880]                 if (length(args) > 0) 
[16:13:54.880]                   base::do.call(base::Sys.setenv, args = args)
[16:13:54.880]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:54.880]             }
[16:13:54.880]             else {
[16:13:54.880]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:54.880]             }
[16:13:54.880]             {
[16:13:54.880]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:54.880]                   0L) {
[16:13:54.880]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:54.880]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:54.880]                   base::options(opts)
[16:13:54.880]                 }
[16:13:54.880]                 {
[16:13:54.880]                   {
[16:13:54.880]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:54.880]                     NULL
[16:13:54.880]                   }
[16:13:54.880]                   options(future.plan = NULL)
[16:13:54.880]                   if (is.na(NA_character_)) 
[16:13:54.880]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:54.880]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:54.880]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:54.880]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:54.880]                     envir = parent.frame()) 
[16:13:54.880]                   {
[16:13:54.880]                     if (is.function(workers)) 
[16:13:54.880]                       workers <- workers()
[16:13:54.880]                     workers <- structure(as.integer(workers), 
[16:13:54.880]                       class = class(workers))
[16:13:54.880]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:54.880]                       workers >= 1)
[16:13:54.880]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:54.880]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:54.880]                     }
[16:13:54.880]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:54.880]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:54.880]                       envir = envir)
[16:13:54.880]                     if (!future$lazy) 
[16:13:54.880]                       future <- run(future)
[16:13:54.880]                     invisible(future)
[16:13:54.880]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:54.880]                 }
[16:13:54.880]             }
[16:13:54.880]         }
[16:13:54.880]     })
[16:13:54.880]     if (TRUE) {
[16:13:54.880]         base::sink(type = "output", split = FALSE)
[16:13:54.880]         if (TRUE) {
[16:13:54.880]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:54.880]         }
[16:13:54.880]         else {
[16:13:54.880]             ...future.result["stdout"] <- base::list(NULL)
[16:13:54.880]         }
[16:13:54.880]         base::close(...future.stdout)
[16:13:54.880]         ...future.stdout <- NULL
[16:13:54.880]     }
[16:13:54.880]     ...future.result$conditions <- ...future.conditions
[16:13:54.880]     ...future.result$finished <- base::Sys.time()
[16:13:54.880]     ...future.result
[16:13:54.880] }
[16:13:54.883] MultisessionFuture started
[16:13:54.883] - Launch lazy future ... done
[16:13:54.884] run() for ‘MultisessionFuture’ ... done
[16:13:55.430] receiveMessageFromWorker() for ClusterFuture ...
[16:13:55.430] - Validating connection of MultisessionFuture
[16:13:55.430] - received message: FutureResult
[16:13:55.431] - Received FutureResult
[16:13:55.431] - Erased future from FutureRegistry
[16:13:55.431] result() for ClusterFuture ...
[16:13:55.431] - result already collected: FutureResult
[16:13:55.431] result() for ClusterFuture ... done
[16:13:55.431] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:55.431] A MultisessionFuture was resolved
- w/ exception ...
[16:13:55.431] getGlobalsAndPackages() ...
[16:13:55.432] Searching for globals...
[16:13:55.432] - globals found: [2] ‘list’, ‘stop’
[16:13:55.432] Searching for globals ... DONE
[16:13:55.433] Resolving globals: FALSE
[16:13:55.433] 
[16:13:55.433] 
[16:13:55.433] getGlobalsAndPackages() ... DONE
[16:13:55.433] run() for ‘Future’ ...
[16:13:55.433] - state: ‘created’
[16:13:55.434] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:55.448] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:55.448] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:55.448]   - Field: ‘node’
[16:13:55.449]   - Field: ‘label’
[16:13:55.449]   - Field: ‘local’
[16:13:55.449]   - Field: ‘owner’
[16:13:55.449]   - Field: ‘envir’
[16:13:55.449]   - Field: ‘workers’
[16:13:55.449]   - Field: ‘packages’
[16:13:55.449]   - Field: ‘gc’
[16:13:55.449]   - Field: ‘conditions’
[16:13:55.449]   - Field: ‘persistent’
[16:13:55.449]   - Field: ‘expr’
[16:13:55.449]   - Field: ‘uuid’
[16:13:55.450]   - Field: ‘seed’
[16:13:55.450]   - Field: ‘version’
[16:13:55.450]   - Field: ‘result’
[16:13:55.450]   - Field: ‘asynchronous’
[16:13:55.450]   - Field: ‘calls’
[16:13:55.450]   - Field: ‘globals’
[16:13:55.450]   - Field: ‘stdout’
[16:13:55.450]   - Field: ‘earlySignal’
[16:13:55.450]   - Field: ‘lazy’
[16:13:55.450]   - Field: ‘state’
[16:13:55.450] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:55.451] - Launch lazy future ...
[16:13:55.451] Packages needed by the future expression (n = 0): <none>
[16:13:55.451] Packages needed by future strategies (n = 0): <none>
[16:13:55.452] {
[16:13:55.452]     {
[16:13:55.452]         {
[16:13:55.452]             ...future.startTime <- base::Sys.time()
[16:13:55.452]             {
[16:13:55.452]                 {
[16:13:55.452]                   {
[16:13:55.452]                     {
[16:13:55.452]                       base::local({
[16:13:55.452]                         has_future <- base::requireNamespace("future", 
[16:13:55.452]                           quietly = TRUE)
[16:13:55.452]                         if (has_future) {
[16:13:55.452]                           ns <- base::getNamespace("future")
[16:13:55.452]                           version <- ns[[".package"]][["version"]]
[16:13:55.452]                           if (is.null(version)) 
[16:13:55.452]                             version <- utils::packageVersion("future")
[16:13:55.452]                         }
[16:13:55.452]                         else {
[16:13:55.452]                           version <- NULL
[16:13:55.452]                         }
[16:13:55.452]                         if (!has_future || version < "1.8.0") {
[16:13:55.452]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:55.452]                             "", base::R.version$version.string), 
[16:13:55.452]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:55.452]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:55.452]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:55.452]                               "release", "version")], collapse = " "), 
[16:13:55.452]                             hostname = base::Sys.info()[["nodename"]])
[16:13:55.452]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:55.452]                             info)
[16:13:55.452]                           info <- base::paste(info, collapse = "; ")
[16:13:55.452]                           if (!has_future) {
[16:13:55.452]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:55.452]                               info)
[16:13:55.452]                           }
[16:13:55.452]                           else {
[16:13:55.452]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:55.452]                               info, version)
[16:13:55.452]                           }
[16:13:55.452]                           base::stop(msg)
[16:13:55.452]                         }
[16:13:55.452]                       })
[16:13:55.452]                     }
[16:13:55.452]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:55.452]                     base::options(mc.cores = 1L)
[16:13:55.452]                   }
[16:13:55.452]                   options(future.plan = NULL)
[16:13:55.452]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:55.452]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:55.452]                 }
[16:13:55.452]                 ...future.workdir <- getwd()
[16:13:55.452]             }
[16:13:55.452]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:55.452]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:55.452]         }
[16:13:55.452]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:55.452]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:55.452]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:55.452]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:55.452]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:55.452]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:55.452]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:55.452]             base::names(...future.oldOptions))
[16:13:55.452]     }
[16:13:55.452]     if (FALSE) {
[16:13:55.452]     }
[16:13:55.452]     else {
[16:13:55.452]         if (TRUE) {
[16:13:55.452]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:55.452]                 open = "w")
[16:13:55.452]         }
[16:13:55.452]         else {
[16:13:55.452]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:55.452]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:55.452]         }
[16:13:55.452]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:55.452]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:55.452]             base::sink(type = "output", split = FALSE)
[16:13:55.452]             base::close(...future.stdout)
[16:13:55.452]         }, add = TRUE)
[16:13:55.452]     }
[16:13:55.452]     ...future.frame <- base::sys.nframe()
[16:13:55.452]     ...future.conditions <- base::list()
[16:13:55.452]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:55.452]     if (FALSE) {
[16:13:55.452]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:55.452]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:55.452]     }
[16:13:55.452]     ...future.result <- base::tryCatch({
[16:13:55.452]         base::withCallingHandlers({
[16:13:55.452]             ...future.value <- base::withVisible(base::local({
[16:13:55.452]                 ...future.makeSendCondition <- local({
[16:13:55.452]                   sendCondition <- NULL
[16:13:55.452]                   function(frame = 1L) {
[16:13:55.452]                     if (is.function(sendCondition)) 
[16:13:55.452]                       return(sendCondition)
[16:13:55.452]                     ns <- getNamespace("parallel")
[16:13:55.452]                     if (exists("sendData", mode = "function", 
[16:13:55.452]                       envir = ns)) {
[16:13:55.452]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:55.452]                         envir = ns)
[16:13:55.452]                       envir <- sys.frame(frame)
[16:13:55.452]                       master <- NULL
[16:13:55.452]                       while (!identical(envir, .GlobalEnv) && 
[16:13:55.452]                         !identical(envir, emptyenv())) {
[16:13:55.452]                         if (exists("master", mode = "list", envir = envir, 
[16:13:55.452]                           inherits = FALSE)) {
[16:13:55.452]                           master <- get("master", mode = "list", 
[16:13:55.452]                             envir = envir, inherits = FALSE)
[16:13:55.452]                           if (inherits(master, c("SOCKnode", 
[16:13:55.452]                             "SOCK0node"))) {
[16:13:55.452]                             sendCondition <<- function(cond) {
[16:13:55.452]                               data <- list(type = "VALUE", value = cond, 
[16:13:55.452]                                 success = TRUE)
[16:13:55.452]                               parallel_sendData(master, data)
[16:13:55.452]                             }
[16:13:55.452]                             return(sendCondition)
[16:13:55.452]                           }
[16:13:55.452]                         }
[16:13:55.452]                         frame <- frame + 1L
[16:13:55.452]                         envir <- sys.frame(frame)
[16:13:55.452]                       }
[16:13:55.452]                     }
[16:13:55.452]                     sendCondition <<- function(cond) NULL
[16:13:55.452]                   }
[16:13:55.452]                 })
[16:13:55.452]                 withCallingHandlers({
[16:13:55.452]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:55.452]                 }, immediateCondition = function(cond) {
[16:13:55.452]                   sendCondition <- ...future.makeSendCondition()
[16:13:55.452]                   sendCondition(cond)
[16:13:55.452]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:55.452]                   {
[16:13:55.452]                     inherits <- base::inherits
[16:13:55.452]                     invokeRestart <- base::invokeRestart
[16:13:55.452]                     is.null <- base::is.null
[16:13:55.452]                     muffled <- FALSE
[16:13:55.452]                     if (inherits(cond, "message")) {
[16:13:55.452]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:55.452]                       if (muffled) 
[16:13:55.452]                         invokeRestart("muffleMessage")
[16:13:55.452]                     }
[16:13:55.452]                     else if (inherits(cond, "warning")) {
[16:13:55.452]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:55.452]                       if (muffled) 
[16:13:55.452]                         invokeRestart("muffleWarning")
[16:13:55.452]                     }
[16:13:55.452]                     else if (inherits(cond, "condition")) {
[16:13:55.452]                       if (!is.null(pattern)) {
[16:13:55.452]                         computeRestarts <- base::computeRestarts
[16:13:55.452]                         grepl <- base::grepl
[16:13:55.452]                         restarts <- computeRestarts(cond)
[16:13:55.452]                         for (restart in restarts) {
[16:13:55.452]                           name <- restart$name
[16:13:55.452]                           if (is.null(name)) 
[16:13:55.452]                             next
[16:13:55.452]                           if (!grepl(pattern, name)) 
[16:13:55.452]                             next
[16:13:55.452]                           invokeRestart(restart)
[16:13:55.452]                           muffled <- TRUE
[16:13:55.452]                           break
[16:13:55.452]                         }
[16:13:55.452]                       }
[16:13:55.452]                     }
[16:13:55.452]                     invisible(muffled)
[16:13:55.452]                   }
[16:13:55.452]                   muffleCondition(cond)
[16:13:55.452]                 })
[16:13:55.452]             }))
[16:13:55.452]             future::FutureResult(value = ...future.value$value, 
[16:13:55.452]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:55.452]                   ...future.rng), globalenv = if (FALSE) 
[16:13:55.452]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:55.452]                     ...future.globalenv.names))
[16:13:55.452]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:55.452]         }, condition = base::local({
[16:13:55.452]             c <- base::c
[16:13:55.452]             inherits <- base::inherits
[16:13:55.452]             invokeRestart <- base::invokeRestart
[16:13:55.452]             length <- base::length
[16:13:55.452]             list <- base::list
[16:13:55.452]             seq.int <- base::seq.int
[16:13:55.452]             signalCondition <- base::signalCondition
[16:13:55.452]             sys.calls <- base::sys.calls
[16:13:55.452]             `[[` <- base::`[[`
[16:13:55.452]             `+` <- base::`+`
[16:13:55.452]             `<<-` <- base::`<<-`
[16:13:55.452]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:55.452]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:55.452]                   3L)]
[16:13:55.452]             }
[16:13:55.452]             function(cond) {
[16:13:55.452]                 is_error <- inherits(cond, "error")
[16:13:55.452]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:55.452]                   NULL)
[16:13:55.452]                 if (is_error) {
[16:13:55.452]                   sessionInformation <- function() {
[16:13:55.452]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:55.452]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:55.452]                       search = base::search(), system = base::Sys.info())
[16:13:55.452]                   }
[16:13:55.452]                   ...future.conditions[[length(...future.conditions) + 
[16:13:55.452]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:55.452]                     cond$call), session = sessionInformation(), 
[16:13:55.452]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:55.452]                   signalCondition(cond)
[16:13:55.452]                 }
[16:13:55.452]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:55.452]                 "immediateCondition"))) {
[16:13:55.452]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:55.452]                   ...future.conditions[[length(...future.conditions) + 
[16:13:55.452]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:55.452]                   if (TRUE && !signal) {
[16:13:55.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:55.452]                     {
[16:13:55.452]                       inherits <- base::inherits
[16:13:55.452]                       invokeRestart <- base::invokeRestart
[16:13:55.452]                       is.null <- base::is.null
[16:13:55.452]                       muffled <- FALSE
[16:13:55.452]                       if (inherits(cond, "message")) {
[16:13:55.452]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:55.452]                         if (muffled) 
[16:13:55.452]                           invokeRestart("muffleMessage")
[16:13:55.452]                       }
[16:13:55.452]                       else if (inherits(cond, "warning")) {
[16:13:55.452]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:55.452]                         if (muffled) 
[16:13:55.452]                           invokeRestart("muffleWarning")
[16:13:55.452]                       }
[16:13:55.452]                       else if (inherits(cond, "condition")) {
[16:13:55.452]                         if (!is.null(pattern)) {
[16:13:55.452]                           computeRestarts <- base::computeRestarts
[16:13:55.452]                           grepl <- base::grepl
[16:13:55.452]                           restarts <- computeRestarts(cond)
[16:13:55.452]                           for (restart in restarts) {
[16:13:55.452]                             name <- restart$name
[16:13:55.452]                             if (is.null(name)) 
[16:13:55.452]                               next
[16:13:55.452]                             if (!grepl(pattern, name)) 
[16:13:55.452]                               next
[16:13:55.452]                             invokeRestart(restart)
[16:13:55.452]                             muffled <- TRUE
[16:13:55.452]                             break
[16:13:55.452]                           }
[16:13:55.452]                         }
[16:13:55.452]                       }
[16:13:55.452]                       invisible(muffled)
[16:13:55.452]                     }
[16:13:55.452]                     muffleCondition(cond, pattern = "^muffle")
[16:13:55.452]                   }
[16:13:55.452]                 }
[16:13:55.452]                 else {
[16:13:55.452]                   if (TRUE) {
[16:13:55.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:55.452]                     {
[16:13:55.452]                       inherits <- base::inherits
[16:13:55.452]                       invokeRestart <- base::invokeRestart
[16:13:55.452]                       is.null <- base::is.null
[16:13:55.452]                       muffled <- FALSE
[16:13:55.452]                       if (inherits(cond, "message")) {
[16:13:55.452]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:55.452]                         if (muffled) 
[16:13:55.452]                           invokeRestart("muffleMessage")
[16:13:55.452]                       }
[16:13:55.452]                       else if (inherits(cond, "warning")) {
[16:13:55.452]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:55.452]                         if (muffled) 
[16:13:55.452]                           invokeRestart("muffleWarning")
[16:13:55.452]                       }
[16:13:55.452]                       else if (inherits(cond, "condition")) {
[16:13:55.452]                         if (!is.null(pattern)) {
[16:13:55.452]                           computeRestarts <- base::computeRestarts
[16:13:55.452]                           grepl <- base::grepl
[16:13:55.452]                           restarts <- computeRestarts(cond)
[16:13:55.452]                           for (restart in restarts) {
[16:13:55.452]                             name <- restart$name
[16:13:55.452]                             if (is.null(name)) 
[16:13:55.452]                               next
[16:13:55.452]                             if (!grepl(pattern, name)) 
[16:13:55.452]                               next
[16:13:55.452]                             invokeRestart(restart)
[16:13:55.452]                             muffled <- TRUE
[16:13:55.452]                             break
[16:13:55.452]                           }
[16:13:55.452]                         }
[16:13:55.452]                       }
[16:13:55.452]                       invisible(muffled)
[16:13:55.452]                     }
[16:13:55.452]                     muffleCondition(cond, pattern = "^muffle")
[16:13:55.452]                   }
[16:13:55.452]                 }
[16:13:55.452]             }
[16:13:55.452]         }))
[16:13:55.452]     }, error = function(ex) {
[16:13:55.452]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:55.452]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:55.452]                 ...future.rng), started = ...future.startTime, 
[16:13:55.452]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:55.452]             version = "1.8"), class = "FutureResult")
[16:13:55.452]     }, finally = {
[16:13:55.452]         if (!identical(...future.workdir, getwd())) 
[16:13:55.452]             setwd(...future.workdir)
[16:13:55.452]         {
[16:13:55.452]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:55.452]                 ...future.oldOptions$nwarnings <- NULL
[16:13:55.452]             }
[16:13:55.452]             base::options(...future.oldOptions)
[16:13:55.452]             if (.Platform$OS.type == "windows") {
[16:13:55.452]                 old_names <- names(...future.oldEnvVars)
[16:13:55.452]                 envs <- base::Sys.getenv()
[16:13:55.452]                 names <- names(envs)
[16:13:55.452]                 common <- intersect(names, old_names)
[16:13:55.452]                 added <- setdiff(names, old_names)
[16:13:55.452]                 removed <- setdiff(old_names, names)
[16:13:55.452]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:55.452]                   envs[common]]
[16:13:55.452]                 NAMES <- toupper(changed)
[16:13:55.452]                 args <- list()
[16:13:55.452]                 for (kk in seq_along(NAMES)) {
[16:13:55.452]                   name <- changed[[kk]]
[16:13:55.452]                   NAME <- NAMES[[kk]]
[16:13:55.452]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:55.452]                     next
[16:13:55.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:55.452]                 }
[16:13:55.452]                 NAMES <- toupper(added)
[16:13:55.452]                 for (kk in seq_along(NAMES)) {
[16:13:55.452]                   name <- added[[kk]]
[16:13:55.452]                   NAME <- NAMES[[kk]]
[16:13:55.452]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:55.452]                     next
[16:13:55.452]                   args[[name]] <- ""
[16:13:55.452]                 }
[16:13:55.452]                 NAMES <- toupper(removed)
[16:13:55.452]                 for (kk in seq_along(NAMES)) {
[16:13:55.452]                   name <- removed[[kk]]
[16:13:55.452]                   NAME <- NAMES[[kk]]
[16:13:55.452]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:55.452]                     next
[16:13:55.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:55.452]                 }
[16:13:55.452]                 if (length(args) > 0) 
[16:13:55.452]                   base::do.call(base::Sys.setenv, args = args)
[16:13:55.452]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:55.452]             }
[16:13:55.452]             else {
[16:13:55.452]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:55.452]             }
[16:13:55.452]             {
[16:13:55.452]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:55.452]                   0L) {
[16:13:55.452]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:55.452]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:55.452]                   base::options(opts)
[16:13:55.452]                 }
[16:13:55.452]                 {
[16:13:55.452]                   {
[16:13:55.452]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:55.452]                     NULL
[16:13:55.452]                   }
[16:13:55.452]                   options(future.plan = NULL)
[16:13:55.452]                   if (is.na(NA_character_)) 
[16:13:55.452]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:55.452]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:55.452]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:55.452]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:55.452]                     envir = parent.frame()) 
[16:13:55.452]                   {
[16:13:55.452]                     if (is.function(workers)) 
[16:13:55.452]                       workers <- workers()
[16:13:55.452]                     workers <- structure(as.integer(workers), 
[16:13:55.452]                       class = class(workers))
[16:13:55.452]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:55.452]                       workers >= 1)
[16:13:55.452]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:55.452]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:55.452]                     }
[16:13:55.452]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:55.452]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:55.452]                       envir = envir)
[16:13:55.452]                     if (!future$lazy) 
[16:13:55.452]                       future <- run(future)
[16:13:55.452]                     invisible(future)
[16:13:55.452]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:55.452]                 }
[16:13:55.452]             }
[16:13:55.452]         }
[16:13:55.452]     })
[16:13:55.452]     if (TRUE) {
[16:13:55.452]         base::sink(type = "output", split = FALSE)
[16:13:55.452]         if (TRUE) {
[16:13:55.452]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:55.452]         }
[16:13:55.452]         else {
[16:13:55.452]             ...future.result["stdout"] <- base::list(NULL)
[16:13:55.452]         }
[16:13:55.452]         base::close(...future.stdout)
[16:13:55.452]         ...future.stdout <- NULL
[16:13:55.452]     }
[16:13:55.452]     ...future.result$conditions <- ...future.conditions
[16:13:55.452]     ...future.result$finished <- base::Sys.time()
[16:13:55.452]     ...future.result
[16:13:55.452] }
[16:13:55.455] MultisessionFuture started
[16:13:55.455] - Launch lazy future ... done
[16:13:55.455] run() for ‘MultisessionFuture’ ... done
[16:13:55.501] receiveMessageFromWorker() for ClusterFuture ...
[16:13:55.501] - Validating connection of MultisessionFuture
[16:13:55.502] - received message: FutureResult
[16:13:55.502] - Received FutureResult
[16:13:55.502] - Erased future from FutureRegistry
[16:13:55.502] result() for ClusterFuture ...
[16:13:55.502] - result already collected: FutureResult
[16:13:55.502] result() for ClusterFuture ... done
[16:13:55.502] signalConditions() ...
[16:13:55.503]  - include = ‘immediateCondition’
[16:13:55.503]  - exclude = 
[16:13:55.503]  - resignal = FALSE
[16:13:55.503]  - Number of conditions: 1
[16:13:55.503] signalConditions() ... done
[16:13:55.503] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:55.503] A MultisessionFuture was resolved
[16:13:55.503] getGlobalsAndPackages() ...
[16:13:55.503] Searching for globals...
[16:13:55.504] - globals found: [2] ‘list’, ‘stop’
[16:13:55.504] Searching for globals ... DONE
[16:13:55.504] Resolving globals: FALSE
[16:13:55.505] 
[16:13:55.505] 
[16:13:55.505] getGlobalsAndPackages() ... DONE
[16:13:55.505] run() for ‘Future’ ...
[16:13:55.505] - state: ‘created’
[16:13:55.505] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:55.520] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:55.520] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:55.520]   - Field: ‘node’
[16:13:55.520]   - Field: ‘label’
[16:13:55.520]   - Field: ‘local’
[16:13:55.520]   - Field: ‘owner’
[16:13:55.520]   - Field: ‘envir’
[16:13:55.520]   - Field: ‘workers’
[16:13:55.521]   - Field: ‘packages’
[16:13:55.521]   - Field: ‘gc’
[16:13:55.521]   - Field: ‘conditions’
[16:13:55.521]   - Field: ‘persistent’
[16:13:55.521]   - Field: ‘expr’
[16:13:55.521]   - Field: ‘uuid’
[16:13:55.521]   - Field: ‘seed’
[16:13:55.521]   - Field: ‘version’
[16:13:55.521]   - Field: ‘result’
[16:13:55.521]   - Field: ‘asynchronous’
[16:13:55.521]   - Field: ‘calls’
[16:13:55.522]   - Field: ‘globals’
[16:13:55.522]   - Field: ‘stdout’
[16:13:55.522]   - Field: ‘earlySignal’
[16:13:55.522]   - Field: ‘lazy’
[16:13:55.522]   - Field: ‘state’
[16:13:55.522] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:55.522] - Launch lazy future ...
[16:13:55.522] Packages needed by the future expression (n = 0): <none>
[16:13:55.522] Packages needed by future strategies (n = 0): <none>
[16:13:55.523] {
[16:13:55.523]     {
[16:13:55.523]         {
[16:13:55.523]             ...future.startTime <- base::Sys.time()
[16:13:55.523]             {
[16:13:55.523]                 {
[16:13:55.523]                   {
[16:13:55.523]                     {
[16:13:55.523]                       base::local({
[16:13:55.523]                         has_future <- base::requireNamespace("future", 
[16:13:55.523]                           quietly = TRUE)
[16:13:55.523]                         if (has_future) {
[16:13:55.523]                           ns <- base::getNamespace("future")
[16:13:55.523]                           version <- ns[[".package"]][["version"]]
[16:13:55.523]                           if (is.null(version)) 
[16:13:55.523]                             version <- utils::packageVersion("future")
[16:13:55.523]                         }
[16:13:55.523]                         else {
[16:13:55.523]                           version <- NULL
[16:13:55.523]                         }
[16:13:55.523]                         if (!has_future || version < "1.8.0") {
[16:13:55.523]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:55.523]                             "", base::R.version$version.string), 
[16:13:55.523]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:55.523]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:55.523]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:55.523]                               "release", "version")], collapse = " "), 
[16:13:55.523]                             hostname = base::Sys.info()[["nodename"]])
[16:13:55.523]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:55.523]                             info)
[16:13:55.523]                           info <- base::paste(info, collapse = "; ")
[16:13:55.523]                           if (!has_future) {
[16:13:55.523]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:55.523]                               info)
[16:13:55.523]                           }
[16:13:55.523]                           else {
[16:13:55.523]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:55.523]                               info, version)
[16:13:55.523]                           }
[16:13:55.523]                           base::stop(msg)
[16:13:55.523]                         }
[16:13:55.523]                       })
[16:13:55.523]                     }
[16:13:55.523]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:55.523]                     base::options(mc.cores = 1L)
[16:13:55.523]                   }
[16:13:55.523]                   options(future.plan = NULL)
[16:13:55.523]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:55.523]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:55.523]                 }
[16:13:55.523]                 ...future.workdir <- getwd()
[16:13:55.523]             }
[16:13:55.523]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:55.523]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:55.523]         }
[16:13:55.523]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:55.523]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:55.523]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:55.523]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:55.523]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:55.523]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:55.523]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:55.523]             base::names(...future.oldOptions))
[16:13:55.523]     }
[16:13:55.523]     if (FALSE) {
[16:13:55.523]     }
[16:13:55.523]     else {
[16:13:55.523]         if (TRUE) {
[16:13:55.523]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:55.523]                 open = "w")
[16:13:55.523]         }
[16:13:55.523]         else {
[16:13:55.523]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:55.523]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:55.523]         }
[16:13:55.523]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:55.523]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:55.523]             base::sink(type = "output", split = FALSE)
[16:13:55.523]             base::close(...future.stdout)
[16:13:55.523]         }, add = TRUE)
[16:13:55.523]     }
[16:13:55.523]     ...future.frame <- base::sys.nframe()
[16:13:55.523]     ...future.conditions <- base::list()
[16:13:55.523]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:55.523]     if (FALSE) {
[16:13:55.523]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:55.523]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:55.523]     }
[16:13:55.523]     ...future.result <- base::tryCatch({
[16:13:55.523]         base::withCallingHandlers({
[16:13:55.523]             ...future.value <- base::withVisible(base::local({
[16:13:55.523]                 ...future.makeSendCondition <- local({
[16:13:55.523]                   sendCondition <- NULL
[16:13:55.523]                   function(frame = 1L) {
[16:13:55.523]                     if (is.function(sendCondition)) 
[16:13:55.523]                       return(sendCondition)
[16:13:55.523]                     ns <- getNamespace("parallel")
[16:13:55.523]                     if (exists("sendData", mode = "function", 
[16:13:55.523]                       envir = ns)) {
[16:13:55.523]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:55.523]                         envir = ns)
[16:13:55.523]                       envir <- sys.frame(frame)
[16:13:55.523]                       master <- NULL
[16:13:55.523]                       while (!identical(envir, .GlobalEnv) && 
[16:13:55.523]                         !identical(envir, emptyenv())) {
[16:13:55.523]                         if (exists("master", mode = "list", envir = envir, 
[16:13:55.523]                           inherits = FALSE)) {
[16:13:55.523]                           master <- get("master", mode = "list", 
[16:13:55.523]                             envir = envir, inherits = FALSE)
[16:13:55.523]                           if (inherits(master, c("SOCKnode", 
[16:13:55.523]                             "SOCK0node"))) {
[16:13:55.523]                             sendCondition <<- function(cond) {
[16:13:55.523]                               data <- list(type = "VALUE", value = cond, 
[16:13:55.523]                                 success = TRUE)
[16:13:55.523]                               parallel_sendData(master, data)
[16:13:55.523]                             }
[16:13:55.523]                             return(sendCondition)
[16:13:55.523]                           }
[16:13:55.523]                         }
[16:13:55.523]                         frame <- frame + 1L
[16:13:55.523]                         envir <- sys.frame(frame)
[16:13:55.523]                       }
[16:13:55.523]                     }
[16:13:55.523]                     sendCondition <<- function(cond) NULL
[16:13:55.523]                   }
[16:13:55.523]                 })
[16:13:55.523]                 withCallingHandlers({
[16:13:55.523]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:55.523]                 }, immediateCondition = function(cond) {
[16:13:55.523]                   sendCondition <- ...future.makeSendCondition()
[16:13:55.523]                   sendCondition(cond)
[16:13:55.523]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:55.523]                   {
[16:13:55.523]                     inherits <- base::inherits
[16:13:55.523]                     invokeRestart <- base::invokeRestart
[16:13:55.523]                     is.null <- base::is.null
[16:13:55.523]                     muffled <- FALSE
[16:13:55.523]                     if (inherits(cond, "message")) {
[16:13:55.523]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:55.523]                       if (muffled) 
[16:13:55.523]                         invokeRestart("muffleMessage")
[16:13:55.523]                     }
[16:13:55.523]                     else if (inherits(cond, "warning")) {
[16:13:55.523]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:55.523]                       if (muffled) 
[16:13:55.523]                         invokeRestart("muffleWarning")
[16:13:55.523]                     }
[16:13:55.523]                     else if (inherits(cond, "condition")) {
[16:13:55.523]                       if (!is.null(pattern)) {
[16:13:55.523]                         computeRestarts <- base::computeRestarts
[16:13:55.523]                         grepl <- base::grepl
[16:13:55.523]                         restarts <- computeRestarts(cond)
[16:13:55.523]                         for (restart in restarts) {
[16:13:55.523]                           name <- restart$name
[16:13:55.523]                           if (is.null(name)) 
[16:13:55.523]                             next
[16:13:55.523]                           if (!grepl(pattern, name)) 
[16:13:55.523]                             next
[16:13:55.523]                           invokeRestart(restart)
[16:13:55.523]                           muffled <- TRUE
[16:13:55.523]                           break
[16:13:55.523]                         }
[16:13:55.523]                       }
[16:13:55.523]                     }
[16:13:55.523]                     invisible(muffled)
[16:13:55.523]                   }
[16:13:55.523]                   muffleCondition(cond)
[16:13:55.523]                 })
[16:13:55.523]             }))
[16:13:55.523]             future::FutureResult(value = ...future.value$value, 
[16:13:55.523]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:55.523]                   ...future.rng), globalenv = if (FALSE) 
[16:13:55.523]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:55.523]                     ...future.globalenv.names))
[16:13:55.523]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:55.523]         }, condition = base::local({
[16:13:55.523]             c <- base::c
[16:13:55.523]             inherits <- base::inherits
[16:13:55.523]             invokeRestart <- base::invokeRestart
[16:13:55.523]             length <- base::length
[16:13:55.523]             list <- base::list
[16:13:55.523]             seq.int <- base::seq.int
[16:13:55.523]             signalCondition <- base::signalCondition
[16:13:55.523]             sys.calls <- base::sys.calls
[16:13:55.523]             `[[` <- base::`[[`
[16:13:55.523]             `+` <- base::`+`
[16:13:55.523]             `<<-` <- base::`<<-`
[16:13:55.523]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:55.523]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:55.523]                   3L)]
[16:13:55.523]             }
[16:13:55.523]             function(cond) {
[16:13:55.523]                 is_error <- inherits(cond, "error")
[16:13:55.523]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:55.523]                   NULL)
[16:13:55.523]                 if (is_error) {
[16:13:55.523]                   sessionInformation <- function() {
[16:13:55.523]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:55.523]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:55.523]                       search = base::search(), system = base::Sys.info())
[16:13:55.523]                   }
[16:13:55.523]                   ...future.conditions[[length(...future.conditions) + 
[16:13:55.523]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:55.523]                     cond$call), session = sessionInformation(), 
[16:13:55.523]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:55.523]                   signalCondition(cond)
[16:13:55.523]                 }
[16:13:55.523]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:55.523]                 "immediateCondition"))) {
[16:13:55.523]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:55.523]                   ...future.conditions[[length(...future.conditions) + 
[16:13:55.523]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:55.523]                   if (TRUE && !signal) {
[16:13:55.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:55.523]                     {
[16:13:55.523]                       inherits <- base::inherits
[16:13:55.523]                       invokeRestart <- base::invokeRestart
[16:13:55.523]                       is.null <- base::is.null
[16:13:55.523]                       muffled <- FALSE
[16:13:55.523]                       if (inherits(cond, "message")) {
[16:13:55.523]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:55.523]                         if (muffled) 
[16:13:55.523]                           invokeRestart("muffleMessage")
[16:13:55.523]                       }
[16:13:55.523]                       else if (inherits(cond, "warning")) {
[16:13:55.523]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:55.523]                         if (muffled) 
[16:13:55.523]                           invokeRestart("muffleWarning")
[16:13:55.523]                       }
[16:13:55.523]                       else if (inherits(cond, "condition")) {
[16:13:55.523]                         if (!is.null(pattern)) {
[16:13:55.523]                           computeRestarts <- base::computeRestarts
[16:13:55.523]                           grepl <- base::grepl
[16:13:55.523]                           restarts <- computeRestarts(cond)
[16:13:55.523]                           for (restart in restarts) {
[16:13:55.523]                             name <- restart$name
[16:13:55.523]                             if (is.null(name)) 
[16:13:55.523]                               next
[16:13:55.523]                             if (!grepl(pattern, name)) 
[16:13:55.523]                               next
[16:13:55.523]                             invokeRestart(restart)
[16:13:55.523]                             muffled <- TRUE
[16:13:55.523]                             break
[16:13:55.523]                           }
[16:13:55.523]                         }
[16:13:55.523]                       }
[16:13:55.523]                       invisible(muffled)
[16:13:55.523]                     }
[16:13:55.523]                     muffleCondition(cond, pattern = "^muffle")
[16:13:55.523]                   }
[16:13:55.523]                 }
[16:13:55.523]                 else {
[16:13:55.523]                   if (TRUE) {
[16:13:55.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:55.523]                     {
[16:13:55.523]                       inherits <- base::inherits
[16:13:55.523]                       invokeRestart <- base::invokeRestart
[16:13:55.523]                       is.null <- base::is.null
[16:13:55.523]                       muffled <- FALSE
[16:13:55.523]                       if (inherits(cond, "message")) {
[16:13:55.523]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:55.523]                         if (muffled) 
[16:13:55.523]                           invokeRestart("muffleMessage")
[16:13:55.523]                       }
[16:13:55.523]                       else if (inherits(cond, "warning")) {
[16:13:55.523]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:55.523]                         if (muffled) 
[16:13:55.523]                           invokeRestart("muffleWarning")
[16:13:55.523]                       }
[16:13:55.523]                       else if (inherits(cond, "condition")) {
[16:13:55.523]                         if (!is.null(pattern)) {
[16:13:55.523]                           computeRestarts <- base::computeRestarts
[16:13:55.523]                           grepl <- base::grepl
[16:13:55.523]                           restarts <- computeRestarts(cond)
[16:13:55.523]                           for (restart in restarts) {
[16:13:55.523]                             name <- restart$name
[16:13:55.523]                             if (is.null(name)) 
[16:13:55.523]                               next
[16:13:55.523]                             if (!grepl(pattern, name)) 
[16:13:55.523]                               next
[16:13:55.523]                             invokeRestart(restart)
[16:13:55.523]                             muffled <- TRUE
[16:13:55.523]                             break
[16:13:55.523]                           }
[16:13:55.523]                         }
[16:13:55.523]                       }
[16:13:55.523]                       invisible(muffled)
[16:13:55.523]                     }
[16:13:55.523]                     muffleCondition(cond, pattern = "^muffle")
[16:13:55.523]                   }
[16:13:55.523]                 }
[16:13:55.523]             }
[16:13:55.523]         }))
[16:13:55.523]     }, error = function(ex) {
[16:13:55.523]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:55.523]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:55.523]                 ...future.rng), started = ...future.startTime, 
[16:13:55.523]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:55.523]             version = "1.8"), class = "FutureResult")
[16:13:55.523]     }, finally = {
[16:13:55.523]         if (!identical(...future.workdir, getwd())) 
[16:13:55.523]             setwd(...future.workdir)
[16:13:55.523]         {
[16:13:55.523]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:55.523]                 ...future.oldOptions$nwarnings <- NULL
[16:13:55.523]             }
[16:13:55.523]             base::options(...future.oldOptions)
[16:13:55.523]             if (.Platform$OS.type == "windows") {
[16:13:55.523]                 old_names <- names(...future.oldEnvVars)
[16:13:55.523]                 envs <- base::Sys.getenv()
[16:13:55.523]                 names <- names(envs)
[16:13:55.523]                 common <- intersect(names, old_names)
[16:13:55.523]                 added <- setdiff(names, old_names)
[16:13:55.523]                 removed <- setdiff(old_names, names)
[16:13:55.523]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:55.523]                   envs[common]]
[16:13:55.523]                 NAMES <- toupper(changed)
[16:13:55.523]                 args <- list()
[16:13:55.523]                 for (kk in seq_along(NAMES)) {
[16:13:55.523]                   name <- changed[[kk]]
[16:13:55.523]                   NAME <- NAMES[[kk]]
[16:13:55.523]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:55.523]                     next
[16:13:55.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:55.523]                 }
[16:13:55.523]                 NAMES <- toupper(added)
[16:13:55.523]                 for (kk in seq_along(NAMES)) {
[16:13:55.523]                   name <- added[[kk]]
[16:13:55.523]                   NAME <- NAMES[[kk]]
[16:13:55.523]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:55.523]                     next
[16:13:55.523]                   args[[name]] <- ""
[16:13:55.523]                 }
[16:13:55.523]                 NAMES <- toupper(removed)
[16:13:55.523]                 for (kk in seq_along(NAMES)) {
[16:13:55.523]                   name <- removed[[kk]]
[16:13:55.523]                   NAME <- NAMES[[kk]]
[16:13:55.523]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:55.523]                     next
[16:13:55.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:55.523]                 }
[16:13:55.523]                 if (length(args) > 0) 
[16:13:55.523]                   base::do.call(base::Sys.setenv, args = args)
[16:13:55.523]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:55.523]             }
[16:13:55.523]             else {
[16:13:55.523]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:55.523]             }
[16:13:55.523]             {
[16:13:55.523]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:55.523]                   0L) {
[16:13:55.523]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:55.523]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:55.523]                   base::options(opts)
[16:13:55.523]                 }
[16:13:55.523]                 {
[16:13:55.523]                   {
[16:13:55.523]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:55.523]                     NULL
[16:13:55.523]                   }
[16:13:55.523]                   options(future.plan = NULL)
[16:13:55.523]                   if (is.na(NA_character_)) 
[16:13:55.523]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:55.523]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:55.523]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:55.523]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:55.523]                     envir = parent.frame()) 
[16:13:55.523]                   {
[16:13:55.523]                     if (is.function(workers)) 
[16:13:55.523]                       workers <- workers()
[16:13:55.523]                     workers <- structure(as.integer(workers), 
[16:13:55.523]                       class = class(workers))
[16:13:55.523]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:55.523]                       workers >= 1)
[16:13:55.523]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:55.523]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:55.523]                     }
[16:13:55.523]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:55.523]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:55.523]                       envir = envir)
[16:13:55.523]                     if (!future$lazy) 
[16:13:55.523]                       future <- run(future)
[16:13:55.523]                     invisible(future)
[16:13:55.523]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:55.523]                 }
[16:13:55.523]             }
[16:13:55.523]         }
[16:13:55.523]     })
[16:13:55.523]     if (TRUE) {
[16:13:55.523]         base::sink(type = "output", split = FALSE)
[16:13:55.523]         if (TRUE) {
[16:13:55.523]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:55.523]         }
[16:13:55.523]         else {
[16:13:55.523]             ...future.result["stdout"] <- base::list(NULL)
[16:13:55.523]         }
[16:13:55.523]         base::close(...future.stdout)
[16:13:55.523]         ...future.stdout <- NULL
[16:13:55.523]     }
[16:13:55.523]     ...future.result$conditions <- ...future.conditions
[16:13:55.523]     ...future.result$finished <- base::Sys.time()
[16:13:55.523]     ...future.result
[16:13:55.523] }
[16:13:55.526] MultisessionFuture started
[16:13:55.526] - Launch lazy future ... done
[16:13:55.526] run() for ‘MultisessionFuture’ ... done
[16:13:55.573] receiveMessageFromWorker() for ClusterFuture ...
[16:13:55.573] - Validating connection of MultisessionFuture
[16:13:55.574] - received message: FutureResult
[16:13:55.574] - Received FutureResult
[16:13:55.574] - Erased future from FutureRegistry
[16:13:55.574] result() for ClusterFuture ...
[16:13:55.574] - result already collected: FutureResult
[16:13:55.574] result() for ClusterFuture ... done
[16:13:55.574] signalConditions() ...
[16:13:55.574]  - include = ‘immediateCondition’
[16:13:55.575]  - exclude = 
[16:13:55.575]  - resignal = FALSE
[16:13:55.575]  - Number of conditions: 1
[16:13:55.575] signalConditions() ... done
[16:13:55.575] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:55.575] A MultisessionFuture was resolved
- result = TRUE, recursive = 0 ... DONE
- result = TRUE, recursive = 1 ...
[16:13:55.575] getGlobalsAndPackages() ...
[16:13:55.575] Searching for globals...
[16:13:55.577] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:55.577] Searching for globals ... DONE
[16:13:55.577] Resolving globals: FALSE
[16:13:55.577] 
[16:13:55.577] 
[16:13:55.577] getGlobalsAndPackages() ... DONE
[16:13:55.578] run() for ‘Future’ ...
[16:13:55.578] - state: ‘created’
[16:13:55.578] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:55.592] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:55.592] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:55.592]   - Field: ‘node’
[16:13:55.592]   - Field: ‘label’
[16:13:55.593]   - Field: ‘local’
[16:13:55.593]   - Field: ‘owner’
[16:13:55.593]   - Field: ‘envir’
[16:13:55.593]   - Field: ‘workers’
[16:13:55.593]   - Field: ‘packages’
[16:13:55.593]   - Field: ‘gc’
[16:13:55.593]   - Field: ‘conditions’
[16:13:55.593]   - Field: ‘persistent’
[16:13:55.593]   - Field: ‘expr’
[16:13:55.593]   - Field: ‘uuid’
[16:13:55.593]   - Field: ‘seed’
[16:13:55.594]   - Field: ‘version’
[16:13:55.594]   - Field: ‘result’
[16:13:55.594]   - Field: ‘asynchronous’
[16:13:55.594]   - Field: ‘calls’
[16:13:55.594]   - Field: ‘globals’
[16:13:55.594]   - Field: ‘stdout’
[16:13:55.594]   - Field: ‘earlySignal’
[16:13:55.594]   - Field: ‘lazy’
[16:13:55.594]   - Field: ‘state’
[16:13:55.594] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:55.594] - Launch lazy future ...
[16:13:55.595] Packages needed by the future expression (n = 0): <none>
[16:13:55.595] Packages needed by future strategies (n = 0): <none>
[16:13:55.595] {
[16:13:55.595]     {
[16:13:55.595]         {
[16:13:55.595]             ...future.startTime <- base::Sys.time()
[16:13:55.595]             {
[16:13:55.595]                 {
[16:13:55.595]                   {
[16:13:55.595]                     {
[16:13:55.595]                       base::local({
[16:13:55.595]                         has_future <- base::requireNamespace("future", 
[16:13:55.595]                           quietly = TRUE)
[16:13:55.595]                         if (has_future) {
[16:13:55.595]                           ns <- base::getNamespace("future")
[16:13:55.595]                           version <- ns[[".package"]][["version"]]
[16:13:55.595]                           if (is.null(version)) 
[16:13:55.595]                             version <- utils::packageVersion("future")
[16:13:55.595]                         }
[16:13:55.595]                         else {
[16:13:55.595]                           version <- NULL
[16:13:55.595]                         }
[16:13:55.595]                         if (!has_future || version < "1.8.0") {
[16:13:55.595]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:55.595]                             "", base::R.version$version.string), 
[16:13:55.595]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:55.595]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:55.595]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:55.595]                               "release", "version")], collapse = " "), 
[16:13:55.595]                             hostname = base::Sys.info()[["nodename"]])
[16:13:55.595]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:55.595]                             info)
[16:13:55.595]                           info <- base::paste(info, collapse = "; ")
[16:13:55.595]                           if (!has_future) {
[16:13:55.595]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:55.595]                               info)
[16:13:55.595]                           }
[16:13:55.595]                           else {
[16:13:55.595]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:55.595]                               info, version)
[16:13:55.595]                           }
[16:13:55.595]                           base::stop(msg)
[16:13:55.595]                         }
[16:13:55.595]                       })
[16:13:55.595]                     }
[16:13:55.595]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:55.595]                     base::options(mc.cores = 1L)
[16:13:55.595]                   }
[16:13:55.595]                   options(future.plan = NULL)
[16:13:55.595]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:55.595]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:55.595]                 }
[16:13:55.595]                 ...future.workdir <- getwd()
[16:13:55.595]             }
[16:13:55.595]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:55.595]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:55.595]         }
[16:13:55.595]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:55.595]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:55.595]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:55.595]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:55.595]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:55.595]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:55.595]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:55.595]             base::names(...future.oldOptions))
[16:13:55.595]     }
[16:13:55.595]     if (FALSE) {
[16:13:55.595]     }
[16:13:55.595]     else {
[16:13:55.595]         if (TRUE) {
[16:13:55.595]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:55.595]                 open = "w")
[16:13:55.595]         }
[16:13:55.595]         else {
[16:13:55.595]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:55.595]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:55.595]         }
[16:13:55.595]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:55.595]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:55.595]             base::sink(type = "output", split = FALSE)
[16:13:55.595]             base::close(...future.stdout)
[16:13:55.595]         }, add = TRUE)
[16:13:55.595]     }
[16:13:55.595]     ...future.frame <- base::sys.nframe()
[16:13:55.595]     ...future.conditions <- base::list()
[16:13:55.595]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:55.595]     if (FALSE) {
[16:13:55.595]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:55.595]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:55.595]     }
[16:13:55.595]     ...future.result <- base::tryCatch({
[16:13:55.595]         base::withCallingHandlers({
[16:13:55.595]             ...future.value <- base::withVisible(base::local({
[16:13:55.595]                 ...future.makeSendCondition <- local({
[16:13:55.595]                   sendCondition <- NULL
[16:13:55.595]                   function(frame = 1L) {
[16:13:55.595]                     if (is.function(sendCondition)) 
[16:13:55.595]                       return(sendCondition)
[16:13:55.595]                     ns <- getNamespace("parallel")
[16:13:55.595]                     if (exists("sendData", mode = "function", 
[16:13:55.595]                       envir = ns)) {
[16:13:55.595]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:55.595]                         envir = ns)
[16:13:55.595]                       envir <- sys.frame(frame)
[16:13:55.595]                       master <- NULL
[16:13:55.595]                       while (!identical(envir, .GlobalEnv) && 
[16:13:55.595]                         !identical(envir, emptyenv())) {
[16:13:55.595]                         if (exists("master", mode = "list", envir = envir, 
[16:13:55.595]                           inherits = FALSE)) {
[16:13:55.595]                           master <- get("master", mode = "list", 
[16:13:55.595]                             envir = envir, inherits = FALSE)
[16:13:55.595]                           if (inherits(master, c("SOCKnode", 
[16:13:55.595]                             "SOCK0node"))) {
[16:13:55.595]                             sendCondition <<- function(cond) {
[16:13:55.595]                               data <- list(type = "VALUE", value = cond, 
[16:13:55.595]                                 success = TRUE)
[16:13:55.595]                               parallel_sendData(master, data)
[16:13:55.595]                             }
[16:13:55.595]                             return(sendCondition)
[16:13:55.595]                           }
[16:13:55.595]                         }
[16:13:55.595]                         frame <- frame + 1L
[16:13:55.595]                         envir <- sys.frame(frame)
[16:13:55.595]                       }
[16:13:55.595]                     }
[16:13:55.595]                     sendCondition <<- function(cond) NULL
[16:13:55.595]                   }
[16:13:55.595]                 })
[16:13:55.595]                 withCallingHandlers({
[16:13:55.595]                   {
[16:13:55.595]                     Sys.sleep(0.5)
[16:13:55.595]                     list(a = 1, b = 42L)
[16:13:55.595]                   }
[16:13:55.595]                 }, immediateCondition = function(cond) {
[16:13:55.595]                   sendCondition <- ...future.makeSendCondition()
[16:13:55.595]                   sendCondition(cond)
[16:13:55.595]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:55.595]                   {
[16:13:55.595]                     inherits <- base::inherits
[16:13:55.595]                     invokeRestart <- base::invokeRestart
[16:13:55.595]                     is.null <- base::is.null
[16:13:55.595]                     muffled <- FALSE
[16:13:55.595]                     if (inherits(cond, "message")) {
[16:13:55.595]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:55.595]                       if (muffled) 
[16:13:55.595]                         invokeRestart("muffleMessage")
[16:13:55.595]                     }
[16:13:55.595]                     else if (inherits(cond, "warning")) {
[16:13:55.595]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:55.595]                       if (muffled) 
[16:13:55.595]                         invokeRestart("muffleWarning")
[16:13:55.595]                     }
[16:13:55.595]                     else if (inherits(cond, "condition")) {
[16:13:55.595]                       if (!is.null(pattern)) {
[16:13:55.595]                         computeRestarts <- base::computeRestarts
[16:13:55.595]                         grepl <- base::grepl
[16:13:55.595]                         restarts <- computeRestarts(cond)
[16:13:55.595]                         for (restart in restarts) {
[16:13:55.595]                           name <- restart$name
[16:13:55.595]                           if (is.null(name)) 
[16:13:55.595]                             next
[16:13:55.595]                           if (!grepl(pattern, name)) 
[16:13:55.595]                             next
[16:13:55.595]                           invokeRestart(restart)
[16:13:55.595]                           muffled <- TRUE
[16:13:55.595]                           break
[16:13:55.595]                         }
[16:13:55.595]                       }
[16:13:55.595]                     }
[16:13:55.595]                     invisible(muffled)
[16:13:55.595]                   }
[16:13:55.595]                   muffleCondition(cond)
[16:13:55.595]                 })
[16:13:55.595]             }))
[16:13:55.595]             future::FutureResult(value = ...future.value$value, 
[16:13:55.595]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:55.595]                   ...future.rng), globalenv = if (FALSE) 
[16:13:55.595]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:55.595]                     ...future.globalenv.names))
[16:13:55.595]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:55.595]         }, condition = base::local({
[16:13:55.595]             c <- base::c
[16:13:55.595]             inherits <- base::inherits
[16:13:55.595]             invokeRestart <- base::invokeRestart
[16:13:55.595]             length <- base::length
[16:13:55.595]             list <- base::list
[16:13:55.595]             seq.int <- base::seq.int
[16:13:55.595]             signalCondition <- base::signalCondition
[16:13:55.595]             sys.calls <- base::sys.calls
[16:13:55.595]             `[[` <- base::`[[`
[16:13:55.595]             `+` <- base::`+`
[16:13:55.595]             `<<-` <- base::`<<-`
[16:13:55.595]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:55.595]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:55.595]                   3L)]
[16:13:55.595]             }
[16:13:55.595]             function(cond) {
[16:13:55.595]                 is_error <- inherits(cond, "error")
[16:13:55.595]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:55.595]                   NULL)
[16:13:55.595]                 if (is_error) {
[16:13:55.595]                   sessionInformation <- function() {
[16:13:55.595]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:55.595]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:55.595]                       search = base::search(), system = base::Sys.info())
[16:13:55.595]                   }
[16:13:55.595]                   ...future.conditions[[length(...future.conditions) + 
[16:13:55.595]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:55.595]                     cond$call), session = sessionInformation(), 
[16:13:55.595]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:55.595]                   signalCondition(cond)
[16:13:55.595]                 }
[16:13:55.595]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:55.595]                 "immediateCondition"))) {
[16:13:55.595]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:55.595]                   ...future.conditions[[length(...future.conditions) + 
[16:13:55.595]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:55.595]                   if (TRUE && !signal) {
[16:13:55.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:55.595]                     {
[16:13:55.595]                       inherits <- base::inherits
[16:13:55.595]                       invokeRestart <- base::invokeRestart
[16:13:55.595]                       is.null <- base::is.null
[16:13:55.595]                       muffled <- FALSE
[16:13:55.595]                       if (inherits(cond, "message")) {
[16:13:55.595]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:55.595]                         if (muffled) 
[16:13:55.595]                           invokeRestart("muffleMessage")
[16:13:55.595]                       }
[16:13:55.595]                       else if (inherits(cond, "warning")) {
[16:13:55.595]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:55.595]                         if (muffled) 
[16:13:55.595]                           invokeRestart("muffleWarning")
[16:13:55.595]                       }
[16:13:55.595]                       else if (inherits(cond, "condition")) {
[16:13:55.595]                         if (!is.null(pattern)) {
[16:13:55.595]                           computeRestarts <- base::computeRestarts
[16:13:55.595]                           grepl <- base::grepl
[16:13:55.595]                           restarts <- computeRestarts(cond)
[16:13:55.595]                           for (restart in restarts) {
[16:13:55.595]                             name <- restart$name
[16:13:55.595]                             if (is.null(name)) 
[16:13:55.595]                               next
[16:13:55.595]                             if (!grepl(pattern, name)) 
[16:13:55.595]                               next
[16:13:55.595]                             invokeRestart(restart)
[16:13:55.595]                             muffled <- TRUE
[16:13:55.595]                             break
[16:13:55.595]                           }
[16:13:55.595]                         }
[16:13:55.595]                       }
[16:13:55.595]                       invisible(muffled)
[16:13:55.595]                     }
[16:13:55.595]                     muffleCondition(cond, pattern = "^muffle")
[16:13:55.595]                   }
[16:13:55.595]                 }
[16:13:55.595]                 else {
[16:13:55.595]                   if (TRUE) {
[16:13:55.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:55.595]                     {
[16:13:55.595]                       inherits <- base::inherits
[16:13:55.595]                       invokeRestart <- base::invokeRestart
[16:13:55.595]                       is.null <- base::is.null
[16:13:55.595]                       muffled <- FALSE
[16:13:55.595]                       if (inherits(cond, "message")) {
[16:13:55.595]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:55.595]                         if (muffled) 
[16:13:55.595]                           invokeRestart("muffleMessage")
[16:13:55.595]                       }
[16:13:55.595]                       else if (inherits(cond, "warning")) {
[16:13:55.595]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:55.595]                         if (muffled) 
[16:13:55.595]                           invokeRestart("muffleWarning")
[16:13:55.595]                       }
[16:13:55.595]                       else if (inherits(cond, "condition")) {
[16:13:55.595]                         if (!is.null(pattern)) {
[16:13:55.595]                           computeRestarts <- base::computeRestarts
[16:13:55.595]                           grepl <- base::grepl
[16:13:55.595]                           restarts <- computeRestarts(cond)
[16:13:55.595]                           for (restart in restarts) {
[16:13:55.595]                             name <- restart$name
[16:13:55.595]                             if (is.null(name)) 
[16:13:55.595]                               next
[16:13:55.595]                             if (!grepl(pattern, name)) 
[16:13:55.595]                               next
[16:13:55.595]                             invokeRestart(restart)
[16:13:55.595]                             muffled <- TRUE
[16:13:55.595]                             break
[16:13:55.595]                           }
[16:13:55.595]                         }
[16:13:55.595]                       }
[16:13:55.595]                       invisible(muffled)
[16:13:55.595]                     }
[16:13:55.595]                     muffleCondition(cond, pattern = "^muffle")
[16:13:55.595]                   }
[16:13:55.595]                 }
[16:13:55.595]             }
[16:13:55.595]         }))
[16:13:55.595]     }, error = function(ex) {
[16:13:55.595]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:55.595]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:55.595]                 ...future.rng), started = ...future.startTime, 
[16:13:55.595]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:55.595]             version = "1.8"), class = "FutureResult")
[16:13:55.595]     }, finally = {
[16:13:55.595]         if (!identical(...future.workdir, getwd())) 
[16:13:55.595]             setwd(...future.workdir)
[16:13:55.595]         {
[16:13:55.595]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:55.595]                 ...future.oldOptions$nwarnings <- NULL
[16:13:55.595]             }
[16:13:55.595]             base::options(...future.oldOptions)
[16:13:55.595]             if (.Platform$OS.type == "windows") {
[16:13:55.595]                 old_names <- names(...future.oldEnvVars)
[16:13:55.595]                 envs <- base::Sys.getenv()
[16:13:55.595]                 names <- names(envs)
[16:13:55.595]                 common <- intersect(names, old_names)
[16:13:55.595]                 added <- setdiff(names, old_names)
[16:13:55.595]                 removed <- setdiff(old_names, names)
[16:13:55.595]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:55.595]                   envs[common]]
[16:13:55.595]                 NAMES <- toupper(changed)
[16:13:55.595]                 args <- list()
[16:13:55.595]                 for (kk in seq_along(NAMES)) {
[16:13:55.595]                   name <- changed[[kk]]
[16:13:55.595]                   NAME <- NAMES[[kk]]
[16:13:55.595]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:55.595]                     next
[16:13:55.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:55.595]                 }
[16:13:55.595]                 NAMES <- toupper(added)
[16:13:55.595]                 for (kk in seq_along(NAMES)) {
[16:13:55.595]                   name <- added[[kk]]
[16:13:55.595]                   NAME <- NAMES[[kk]]
[16:13:55.595]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:55.595]                     next
[16:13:55.595]                   args[[name]] <- ""
[16:13:55.595]                 }
[16:13:55.595]                 NAMES <- toupper(removed)
[16:13:55.595]                 for (kk in seq_along(NAMES)) {
[16:13:55.595]                   name <- removed[[kk]]
[16:13:55.595]                   NAME <- NAMES[[kk]]
[16:13:55.595]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:55.595]                     next
[16:13:55.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:55.595]                 }
[16:13:55.595]                 if (length(args) > 0) 
[16:13:55.595]                   base::do.call(base::Sys.setenv, args = args)
[16:13:55.595]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:55.595]             }
[16:13:55.595]             else {
[16:13:55.595]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:55.595]             }
[16:13:55.595]             {
[16:13:55.595]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:55.595]                   0L) {
[16:13:55.595]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:55.595]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:55.595]                   base::options(opts)
[16:13:55.595]                 }
[16:13:55.595]                 {
[16:13:55.595]                   {
[16:13:55.595]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:55.595]                     NULL
[16:13:55.595]                   }
[16:13:55.595]                   options(future.plan = NULL)
[16:13:55.595]                   if (is.na(NA_character_)) 
[16:13:55.595]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:55.595]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:55.595]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:55.595]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:55.595]                     envir = parent.frame()) 
[16:13:55.595]                   {
[16:13:55.595]                     if (is.function(workers)) 
[16:13:55.595]                       workers <- workers()
[16:13:55.595]                     workers <- structure(as.integer(workers), 
[16:13:55.595]                       class = class(workers))
[16:13:55.595]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:55.595]                       workers >= 1)
[16:13:55.595]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:55.595]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:55.595]                     }
[16:13:55.595]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:55.595]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:55.595]                       envir = envir)
[16:13:55.595]                     if (!future$lazy) 
[16:13:55.595]                       future <- run(future)
[16:13:55.595]                     invisible(future)
[16:13:55.595]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:55.595]                 }
[16:13:55.595]             }
[16:13:55.595]         }
[16:13:55.595]     })
[16:13:55.595]     if (TRUE) {
[16:13:55.595]         base::sink(type = "output", split = FALSE)
[16:13:55.595]         if (TRUE) {
[16:13:55.595]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:55.595]         }
[16:13:55.595]         else {
[16:13:55.595]             ...future.result["stdout"] <- base::list(NULL)
[16:13:55.595]         }
[16:13:55.595]         base::close(...future.stdout)
[16:13:55.595]         ...future.stdout <- NULL
[16:13:55.595]     }
[16:13:55.595]     ...future.result$conditions <- ...future.conditions
[16:13:55.595]     ...future.result$finished <- base::Sys.time()
[16:13:55.595]     ...future.result
[16:13:55.595] }
[16:13:55.599] MultisessionFuture started
[16:13:55.599] - Launch lazy future ... done
[16:13:55.599] run() for ‘MultisessionFuture’ ... done
[16:13:56.145] receiveMessageFromWorker() for ClusterFuture ...
[16:13:56.146] - Validating connection of MultisessionFuture
[16:13:56.146] - received message: FutureResult
[16:13:56.146] - Received FutureResult
[16:13:56.146] - Erased future from FutureRegistry
[16:13:56.146] result() for ClusterFuture ...
[16:13:56.146] - result already collected: FutureResult
[16:13:56.147] result() for ClusterFuture ... done
[16:13:56.147] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:56.147] resolve() on list ...
[16:13:56.147]  recursive: 0
[16:13:56.147]  length: 2
[16:13:56.147]  elements: ‘a’, ‘b’
[16:13:56.147]  length: 1 (resolved future 1)
[16:13:56.147]  length: 0 (resolved future 2)
[16:13:56.150] resolve() on list ... DONE
[16:13:56.150] A MultisessionFuture was resolved (and resolved itself)
[16:13:56.150] getGlobalsAndPackages() ...
[16:13:56.150] Searching for globals...
[16:13:56.151] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:56.152] Searching for globals ... DONE
[16:13:56.152] Resolving globals: FALSE
[16:13:56.152] 
[16:13:56.152] 
[16:13:56.152] getGlobalsAndPackages() ... DONE
[16:13:56.153] run() for ‘Future’ ...
[16:13:56.153] - state: ‘created’
[16:13:56.153] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:56.167] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:56.167] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:56.167]   - Field: ‘node’
[16:13:56.167]   - Field: ‘label’
[16:13:56.167]   - Field: ‘local’
[16:13:56.168]   - Field: ‘owner’
[16:13:56.168]   - Field: ‘envir’
[16:13:56.168]   - Field: ‘workers’
[16:13:56.168]   - Field: ‘packages’
[16:13:56.168]   - Field: ‘gc’
[16:13:56.168]   - Field: ‘conditions’
[16:13:56.168]   - Field: ‘persistent’
[16:13:56.168]   - Field: ‘expr’
[16:13:56.168]   - Field: ‘uuid’
[16:13:56.168]   - Field: ‘seed’
[16:13:56.168]   - Field: ‘version’
[16:13:56.169]   - Field: ‘result’
[16:13:56.169]   - Field: ‘asynchronous’
[16:13:56.169]   - Field: ‘calls’
[16:13:56.169]   - Field: ‘globals’
[16:13:56.169]   - Field: ‘stdout’
[16:13:56.169]   - Field: ‘earlySignal’
[16:13:56.169]   - Field: ‘lazy’
[16:13:56.169]   - Field: ‘state’
[16:13:56.169] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:56.169] - Launch lazy future ...
[16:13:56.170] Packages needed by the future expression (n = 0): <none>
[16:13:56.170] Packages needed by future strategies (n = 0): <none>
[16:13:56.170] {
[16:13:56.170]     {
[16:13:56.170]         {
[16:13:56.170]             ...future.startTime <- base::Sys.time()
[16:13:56.170]             {
[16:13:56.170]                 {
[16:13:56.170]                   {
[16:13:56.170]                     {
[16:13:56.170]                       base::local({
[16:13:56.170]                         has_future <- base::requireNamespace("future", 
[16:13:56.170]                           quietly = TRUE)
[16:13:56.170]                         if (has_future) {
[16:13:56.170]                           ns <- base::getNamespace("future")
[16:13:56.170]                           version <- ns[[".package"]][["version"]]
[16:13:56.170]                           if (is.null(version)) 
[16:13:56.170]                             version <- utils::packageVersion("future")
[16:13:56.170]                         }
[16:13:56.170]                         else {
[16:13:56.170]                           version <- NULL
[16:13:56.170]                         }
[16:13:56.170]                         if (!has_future || version < "1.8.0") {
[16:13:56.170]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:56.170]                             "", base::R.version$version.string), 
[16:13:56.170]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:56.170]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:56.170]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:56.170]                               "release", "version")], collapse = " "), 
[16:13:56.170]                             hostname = base::Sys.info()[["nodename"]])
[16:13:56.170]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:56.170]                             info)
[16:13:56.170]                           info <- base::paste(info, collapse = "; ")
[16:13:56.170]                           if (!has_future) {
[16:13:56.170]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:56.170]                               info)
[16:13:56.170]                           }
[16:13:56.170]                           else {
[16:13:56.170]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:56.170]                               info, version)
[16:13:56.170]                           }
[16:13:56.170]                           base::stop(msg)
[16:13:56.170]                         }
[16:13:56.170]                       })
[16:13:56.170]                     }
[16:13:56.170]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:56.170]                     base::options(mc.cores = 1L)
[16:13:56.170]                   }
[16:13:56.170]                   options(future.plan = NULL)
[16:13:56.170]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:56.170]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:56.170]                 }
[16:13:56.170]                 ...future.workdir <- getwd()
[16:13:56.170]             }
[16:13:56.170]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:56.170]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:56.170]         }
[16:13:56.170]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:56.170]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:56.170]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:56.170]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:56.170]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:56.170]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:56.170]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:56.170]             base::names(...future.oldOptions))
[16:13:56.170]     }
[16:13:56.170]     if (FALSE) {
[16:13:56.170]     }
[16:13:56.170]     else {
[16:13:56.170]         if (TRUE) {
[16:13:56.170]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:56.170]                 open = "w")
[16:13:56.170]         }
[16:13:56.170]         else {
[16:13:56.170]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:56.170]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:56.170]         }
[16:13:56.170]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:56.170]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:56.170]             base::sink(type = "output", split = FALSE)
[16:13:56.170]             base::close(...future.stdout)
[16:13:56.170]         }, add = TRUE)
[16:13:56.170]     }
[16:13:56.170]     ...future.frame <- base::sys.nframe()
[16:13:56.170]     ...future.conditions <- base::list()
[16:13:56.170]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:56.170]     if (FALSE) {
[16:13:56.170]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:56.170]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:56.170]     }
[16:13:56.170]     ...future.result <- base::tryCatch({
[16:13:56.170]         base::withCallingHandlers({
[16:13:56.170]             ...future.value <- base::withVisible(base::local({
[16:13:56.170]                 ...future.makeSendCondition <- local({
[16:13:56.170]                   sendCondition <- NULL
[16:13:56.170]                   function(frame = 1L) {
[16:13:56.170]                     if (is.function(sendCondition)) 
[16:13:56.170]                       return(sendCondition)
[16:13:56.170]                     ns <- getNamespace("parallel")
[16:13:56.170]                     if (exists("sendData", mode = "function", 
[16:13:56.170]                       envir = ns)) {
[16:13:56.170]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:56.170]                         envir = ns)
[16:13:56.170]                       envir <- sys.frame(frame)
[16:13:56.170]                       master <- NULL
[16:13:56.170]                       while (!identical(envir, .GlobalEnv) && 
[16:13:56.170]                         !identical(envir, emptyenv())) {
[16:13:56.170]                         if (exists("master", mode = "list", envir = envir, 
[16:13:56.170]                           inherits = FALSE)) {
[16:13:56.170]                           master <- get("master", mode = "list", 
[16:13:56.170]                             envir = envir, inherits = FALSE)
[16:13:56.170]                           if (inherits(master, c("SOCKnode", 
[16:13:56.170]                             "SOCK0node"))) {
[16:13:56.170]                             sendCondition <<- function(cond) {
[16:13:56.170]                               data <- list(type = "VALUE", value = cond, 
[16:13:56.170]                                 success = TRUE)
[16:13:56.170]                               parallel_sendData(master, data)
[16:13:56.170]                             }
[16:13:56.170]                             return(sendCondition)
[16:13:56.170]                           }
[16:13:56.170]                         }
[16:13:56.170]                         frame <- frame + 1L
[16:13:56.170]                         envir <- sys.frame(frame)
[16:13:56.170]                       }
[16:13:56.170]                     }
[16:13:56.170]                     sendCondition <<- function(cond) NULL
[16:13:56.170]                   }
[16:13:56.170]                 })
[16:13:56.170]                 withCallingHandlers({
[16:13:56.170]                   {
[16:13:56.170]                     Sys.sleep(0.5)
[16:13:56.170]                     list(a = 1, b = 42L)
[16:13:56.170]                   }
[16:13:56.170]                 }, immediateCondition = function(cond) {
[16:13:56.170]                   sendCondition <- ...future.makeSendCondition()
[16:13:56.170]                   sendCondition(cond)
[16:13:56.170]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:56.170]                   {
[16:13:56.170]                     inherits <- base::inherits
[16:13:56.170]                     invokeRestart <- base::invokeRestart
[16:13:56.170]                     is.null <- base::is.null
[16:13:56.170]                     muffled <- FALSE
[16:13:56.170]                     if (inherits(cond, "message")) {
[16:13:56.170]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:56.170]                       if (muffled) 
[16:13:56.170]                         invokeRestart("muffleMessage")
[16:13:56.170]                     }
[16:13:56.170]                     else if (inherits(cond, "warning")) {
[16:13:56.170]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:56.170]                       if (muffled) 
[16:13:56.170]                         invokeRestart("muffleWarning")
[16:13:56.170]                     }
[16:13:56.170]                     else if (inherits(cond, "condition")) {
[16:13:56.170]                       if (!is.null(pattern)) {
[16:13:56.170]                         computeRestarts <- base::computeRestarts
[16:13:56.170]                         grepl <- base::grepl
[16:13:56.170]                         restarts <- computeRestarts(cond)
[16:13:56.170]                         for (restart in restarts) {
[16:13:56.170]                           name <- restart$name
[16:13:56.170]                           if (is.null(name)) 
[16:13:56.170]                             next
[16:13:56.170]                           if (!grepl(pattern, name)) 
[16:13:56.170]                             next
[16:13:56.170]                           invokeRestart(restart)
[16:13:56.170]                           muffled <- TRUE
[16:13:56.170]                           break
[16:13:56.170]                         }
[16:13:56.170]                       }
[16:13:56.170]                     }
[16:13:56.170]                     invisible(muffled)
[16:13:56.170]                   }
[16:13:56.170]                   muffleCondition(cond)
[16:13:56.170]                 })
[16:13:56.170]             }))
[16:13:56.170]             future::FutureResult(value = ...future.value$value, 
[16:13:56.170]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:56.170]                   ...future.rng), globalenv = if (FALSE) 
[16:13:56.170]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:56.170]                     ...future.globalenv.names))
[16:13:56.170]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:56.170]         }, condition = base::local({
[16:13:56.170]             c <- base::c
[16:13:56.170]             inherits <- base::inherits
[16:13:56.170]             invokeRestart <- base::invokeRestart
[16:13:56.170]             length <- base::length
[16:13:56.170]             list <- base::list
[16:13:56.170]             seq.int <- base::seq.int
[16:13:56.170]             signalCondition <- base::signalCondition
[16:13:56.170]             sys.calls <- base::sys.calls
[16:13:56.170]             `[[` <- base::`[[`
[16:13:56.170]             `+` <- base::`+`
[16:13:56.170]             `<<-` <- base::`<<-`
[16:13:56.170]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:56.170]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:56.170]                   3L)]
[16:13:56.170]             }
[16:13:56.170]             function(cond) {
[16:13:56.170]                 is_error <- inherits(cond, "error")
[16:13:56.170]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:56.170]                   NULL)
[16:13:56.170]                 if (is_error) {
[16:13:56.170]                   sessionInformation <- function() {
[16:13:56.170]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:56.170]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:56.170]                       search = base::search(), system = base::Sys.info())
[16:13:56.170]                   }
[16:13:56.170]                   ...future.conditions[[length(...future.conditions) + 
[16:13:56.170]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:56.170]                     cond$call), session = sessionInformation(), 
[16:13:56.170]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:56.170]                   signalCondition(cond)
[16:13:56.170]                 }
[16:13:56.170]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:56.170]                 "immediateCondition"))) {
[16:13:56.170]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:56.170]                   ...future.conditions[[length(...future.conditions) + 
[16:13:56.170]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:56.170]                   if (TRUE && !signal) {
[16:13:56.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:56.170]                     {
[16:13:56.170]                       inherits <- base::inherits
[16:13:56.170]                       invokeRestart <- base::invokeRestart
[16:13:56.170]                       is.null <- base::is.null
[16:13:56.170]                       muffled <- FALSE
[16:13:56.170]                       if (inherits(cond, "message")) {
[16:13:56.170]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:56.170]                         if (muffled) 
[16:13:56.170]                           invokeRestart("muffleMessage")
[16:13:56.170]                       }
[16:13:56.170]                       else if (inherits(cond, "warning")) {
[16:13:56.170]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:56.170]                         if (muffled) 
[16:13:56.170]                           invokeRestart("muffleWarning")
[16:13:56.170]                       }
[16:13:56.170]                       else if (inherits(cond, "condition")) {
[16:13:56.170]                         if (!is.null(pattern)) {
[16:13:56.170]                           computeRestarts <- base::computeRestarts
[16:13:56.170]                           grepl <- base::grepl
[16:13:56.170]                           restarts <- computeRestarts(cond)
[16:13:56.170]                           for (restart in restarts) {
[16:13:56.170]                             name <- restart$name
[16:13:56.170]                             if (is.null(name)) 
[16:13:56.170]                               next
[16:13:56.170]                             if (!grepl(pattern, name)) 
[16:13:56.170]                               next
[16:13:56.170]                             invokeRestart(restart)
[16:13:56.170]                             muffled <- TRUE
[16:13:56.170]                             break
[16:13:56.170]                           }
[16:13:56.170]                         }
[16:13:56.170]                       }
[16:13:56.170]                       invisible(muffled)
[16:13:56.170]                     }
[16:13:56.170]                     muffleCondition(cond, pattern = "^muffle")
[16:13:56.170]                   }
[16:13:56.170]                 }
[16:13:56.170]                 else {
[16:13:56.170]                   if (TRUE) {
[16:13:56.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:56.170]                     {
[16:13:56.170]                       inherits <- base::inherits
[16:13:56.170]                       invokeRestart <- base::invokeRestart
[16:13:56.170]                       is.null <- base::is.null
[16:13:56.170]                       muffled <- FALSE
[16:13:56.170]                       if (inherits(cond, "message")) {
[16:13:56.170]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:56.170]                         if (muffled) 
[16:13:56.170]                           invokeRestart("muffleMessage")
[16:13:56.170]                       }
[16:13:56.170]                       else if (inherits(cond, "warning")) {
[16:13:56.170]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:56.170]                         if (muffled) 
[16:13:56.170]                           invokeRestart("muffleWarning")
[16:13:56.170]                       }
[16:13:56.170]                       else if (inherits(cond, "condition")) {
[16:13:56.170]                         if (!is.null(pattern)) {
[16:13:56.170]                           computeRestarts <- base::computeRestarts
[16:13:56.170]                           grepl <- base::grepl
[16:13:56.170]                           restarts <- computeRestarts(cond)
[16:13:56.170]                           for (restart in restarts) {
[16:13:56.170]                             name <- restart$name
[16:13:56.170]                             if (is.null(name)) 
[16:13:56.170]                               next
[16:13:56.170]                             if (!grepl(pattern, name)) 
[16:13:56.170]                               next
[16:13:56.170]                             invokeRestart(restart)
[16:13:56.170]                             muffled <- TRUE
[16:13:56.170]                             break
[16:13:56.170]                           }
[16:13:56.170]                         }
[16:13:56.170]                       }
[16:13:56.170]                       invisible(muffled)
[16:13:56.170]                     }
[16:13:56.170]                     muffleCondition(cond, pattern = "^muffle")
[16:13:56.170]                   }
[16:13:56.170]                 }
[16:13:56.170]             }
[16:13:56.170]         }))
[16:13:56.170]     }, error = function(ex) {
[16:13:56.170]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:56.170]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:56.170]                 ...future.rng), started = ...future.startTime, 
[16:13:56.170]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:56.170]             version = "1.8"), class = "FutureResult")
[16:13:56.170]     }, finally = {
[16:13:56.170]         if (!identical(...future.workdir, getwd())) 
[16:13:56.170]             setwd(...future.workdir)
[16:13:56.170]         {
[16:13:56.170]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:56.170]                 ...future.oldOptions$nwarnings <- NULL
[16:13:56.170]             }
[16:13:56.170]             base::options(...future.oldOptions)
[16:13:56.170]             if (.Platform$OS.type == "windows") {
[16:13:56.170]                 old_names <- names(...future.oldEnvVars)
[16:13:56.170]                 envs <- base::Sys.getenv()
[16:13:56.170]                 names <- names(envs)
[16:13:56.170]                 common <- intersect(names, old_names)
[16:13:56.170]                 added <- setdiff(names, old_names)
[16:13:56.170]                 removed <- setdiff(old_names, names)
[16:13:56.170]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:56.170]                   envs[common]]
[16:13:56.170]                 NAMES <- toupper(changed)
[16:13:56.170]                 args <- list()
[16:13:56.170]                 for (kk in seq_along(NAMES)) {
[16:13:56.170]                   name <- changed[[kk]]
[16:13:56.170]                   NAME <- NAMES[[kk]]
[16:13:56.170]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:56.170]                     next
[16:13:56.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:56.170]                 }
[16:13:56.170]                 NAMES <- toupper(added)
[16:13:56.170]                 for (kk in seq_along(NAMES)) {
[16:13:56.170]                   name <- added[[kk]]
[16:13:56.170]                   NAME <- NAMES[[kk]]
[16:13:56.170]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:56.170]                     next
[16:13:56.170]                   args[[name]] <- ""
[16:13:56.170]                 }
[16:13:56.170]                 NAMES <- toupper(removed)
[16:13:56.170]                 for (kk in seq_along(NAMES)) {
[16:13:56.170]                   name <- removed[[kk]]
[16:13:56.170]                   NAME <- NAMES[[kk]]
[16:13:56.170]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:56.170]                     next
[16:13:56.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:56.170]                 }
[16:13:56.170]                 if (length(args) > 0) 
[16:13:56.170]                   base::do.call(base::Sys.setenv, args = args)
[16:13:56.170]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:56.170]             }
[16:13:56.170]             else {
[16:13:56.170]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:56.170]             }
[16:13:56.170]             {
[16:13:56.170]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:56.170]                   0L) {
[16:13:56.170]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:56.170]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:56.170]                   base::options(opts)
[16:13:56.170]                 }
[16:13:56.170]                 {
[16:13:56.170]                   {
[16:13:56.170]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:56.170]                     NULL
[16:13:56.170]                   }
[16:13:56.170]                   options(future.plan = NULL)
[16:13:56.170]                   if (is.na(NA_character_)) 
[16:13:56.170]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:56.170]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:56.170]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:56.170]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:56.170]                     envir = parent.frame()) 
[16:13:56.170]                   {
[16:13:56.170]                     if (is.function(workers)) 
[16:13:56.170]                       workers <- workers()
[16:13:56.170]                     workers <- structure(as.integer(workers), 
[16:13:56.170]                       class = class(workers))
[16:13:56.170]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:56.170]                       workers >= 1)
[16:13:56.170]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:56.170]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:56.170]                     }
[16:13:56.170]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:56.170]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:56.170]                       envir = envir)
[16:13:56.170]                     if (!future$lazy) 
[16:13:56.170]                       future <- run(future)
[16:13:56.170]                     invisible(future)
[16:13:56.170]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:56.170]                 }
[16:13:56.170]             }
[16:13:56.170]         }
[16:13:56.170]     })
[16:13:56.170]     if (TRUE) {
[16:13:56.170]         base::sink(type = "output", split = FALSE)
[16:13:56.170]         if (TRUE) {
[16:13:56.170]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:56.170]         }
[16:13:56.170]         else {
[16:13:56.170]             ...future.result["stdout"] <- base::list(NULL)
[16:13:56.170]         }
[16:13:56.170]         base::close(...future.stdout)
[16:13:56.170]         ...future.stdout <- NULL
[16:13:56.170]     }
[16:13:56.170]     ...future.result$conditions <- ...future.conditions
[16:13:56.170]     ...future.result$finished <- base::Sys.time()
[16:13:56.170]     ...future.result
[16:13:56.170] }
[16:13:56.174] MultisessionFuture started
[16:13:56.174] - Launch lazy future ... done
[16:13:56.174] run() for ‘MultisessionFuture’ ... done
[16:13:56.731] receiveMessageFromWorker() for ClusterFuture ...
[16:13:56.731] - Validating connection of MultisessionFuture
[16:13:56.732] - received message: FutureResult
[16:13:56.732] - Received FutureResult
[16:13:56.732] - Erased future from FutureRegistry
[16:13:56.732] result() for ClusterFuture ...
[16:13:56.732] - result already collected: FutureResult
[16:13:56.732] result() for ClusterFuture ... done
[16:13:56.732] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:56.732] resolve() on list ...
[16:13:56.733]  recursive: 0
[16:13:56.733]  length: 2
[16:13:56.733]  elements: ‘a’, ‘b’
[16:13:56.733]  length: 1 (resolved future 1)
[16:13:56.733]  length: 0 (resolved future 2)
[16:13:56.733] resolve() on list ... DONE
[16:13:56.733] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[16:13:56.733] getGlobalsAndPackages() ...
[16:13:56.733] Searching for globals...
[16:13:56.734] - globals found: [2] ‘list’, ‘stop’
[16:13:56.734] Searching for globals ... DONE
[16:13:56.734] Resolving globals: FALSE
[16:13:56.735] 
[16:13:56.735] 
[16:13:56.735] getGlobalsAndPackages() ... DONE
[16:13:56.735] run() for ‘Future’ ...
[16:13:56.735] - state: ‘created’
[16:13:56.735] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:56.750] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:56.751] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:56.751]   - Field: ‘node’
[16:13:56.751]   - Field: ‘label’
[16:13:56.751]   - Field: ‘local’
[16:13:56.751]   - Field: ‘owner’
[16:13:56.751]   - Field: ‘envir’
[16:13:56.751]   - Field: ‘workers’
[16:13:56.751]   - Field: ‘packages’
[16:13:56.751]   - Field: ‘gc’
[16:13:56.752]   - Field: ‘conditions’
[16:13:56.752]   - Field: ‘persistent’
[16:13:56.752]   - Field: ‘expr’
[16:13:56.752]   - Field: ‘uuid’
[16:13:56.752]   - Field: ‘seed’
[16:13:56.752]   - Field: ‘version’
[16:13:56.752]   - Field: ‘result’
[16:13:56.752]   - Field: ‘asynchronous’
[16:13:56.752]   - Field: ‘calls’
[16:13:56.752]   - Field: ‘globals’
[16:13:56.753]   - Field: ‘stdout’
[16:13:56.753]   - Field: ‘earlySignal’
[16:13:56.753]   - Field: ‘lazy’
[16:13:56.753]   - Field: ‘state’
[16:13:56.753] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:56.753] - Launch lazy future ...
[16:13:56.753] Packages needed by the future expression (n = 0): <none>
[16:13:56.753] Packages needed by future strategies (n = 0): <none>
[16:13:56.754] {
[16:13:56.754]     {
[16:13:56.754]         {
[16:13:56.754]             ...future.startTime <- base::Sys.time()
[16:13:56.754]             {
[16:13:56.754]                 {
[16:13:56.754]                   {
[16:13:56.754]                     {
[16:13:56.754]                       base::local({
[16:13:56.754]                         has_future <- base::requireNamespace("future", 
[16:13:56.754]                           quietly = TRUE)
[16:13:56.754]                         if (has_future) {
[16:13:56.754]                           ns <- base::getNamespace("future")
[16:13:56.754]                           version <- ns[[".package"]][["version"]]
[16:13:56.754]                           if (is.null(version)) 
[16:13:56.754]                             version <- utils::packageVersion("future")
[16:13:56.754]                         }
[16:13:56.754]                         else {
[16:13:56.754]                           version <- NULL
[16:13:56.754]                         }
[16:13:56.754]                         if (!has_future || version < "1.8.0") {
[16:13:56.754]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:56.754]                             "", base::R.version$version.string), 
[16:13:56.754]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:56.754]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:56.754]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:56.754]                               "release", "version")], collapse = " "), 
[16:13:56.754]                             hostname = base::Sys.info()[["nodename"]])
[16:13:56.754]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:56.754]                             info)
[16:13:56.754]                           info <- base::paste(info, collapse = "; ")
[16:13:56.754]                           if (!has_future) {
[16:13:56.754]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:56.754]                               info)
[16:13:56.754]                           }
[16:13:56.754]                           else {
[16:13:56.754]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:56.754]                               info, version)
[16:13:56.754]                           }
[16:13:56.754]                           base::stop(msg)
[16:13:56.754]                         }
[16:13:56.754]                       })
[16:13:56.754]                     }
[16:13:56.754]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:56.754]                     base::options(mc.cores = 1L)
[16:13:56.754]                   }
[16:13:56.754]                   options(future.plan = NULL)
[16:13:56.754]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:56.754]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:56.754]                 }
[16:13:56.754]                 ...future.workdir <- getwd()
[16:13:56.754]             }
[16:13:56.754]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:56.754]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:56.754]         }
[16:13:56.754]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:56.754]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:56.754]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:56.754]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:56.754]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:56.754]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:56.754]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:56.754]             base::names(...future.oldOptions))
[16:13:56.754]     }
[16:13:56.754]     if (FALSE) {
[16:13:56.754]     }
[16:13:56.754]     else {
[16:13:56.754]         if (TRUE) {
[16:13:56.754]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:56.754]                 open = "w")
[16:13:56.754]         }
[16:13:56.754]         else {
[16:13:56.754]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:56.754]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:56.754]         }
[16:13:56.754]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:56.754]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:56.754]             base::sink(type = "output", split = FALSE)
[16:13:56.754]             base::close(...future.stdout)
[16:13:56.754]         }, add = TRUE)
[16:13:56.754]     }
[16:13:56.754]     ...future.frame <- base::sys.nframe()
[16:13:56.754]     ...future.conditions <- base::list()
[16:13:56.754]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:56.754]     if (FALSE) {
[16:13:56.754]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:56.754]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:56.754]     }
[16:13:56.754]     ...future.result <- base::tryCatch({
[16:13:56.754]         base::withCallingHandlers({
[16:13:56.754]             ...future.value <- base::withVisible(base::local({
[16:13:56.754]                 ...future.makeSendCondition <- local({
[16:13:56.754]                   sendCondition <- NULL
[16:13:56.754]                   function(frame = 1L) {
[16:13:56.754]                     if (is.function(sendCondition)) 
[16:13:56.754]                       return(sendCondition)
[16:13:56.754]                     ns <- getNamespace("parallel")
[16:13:56.754]                     if (exists("sendData", mode = "function", 
[16:13:56.754]                       envir = ns)) {
[16:13:56.754]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:56.754]                         envir = ns)
[16:13:56.754]                       envir <- sys.frame(frame)
[16:13:56.754]                       master <- NULL
[16:13:56.754]                       while (!identical(envir, .GlobalEnv) && 
[16:13:56.754]                         !identical(envir, emptyenv())) {
[16:13:56.754]                         if (exists("master", mode = "list", envir = envir, 
[16:13:56.754]                           inherits = FALSE)) {
[16:13:56.754]                           master <- get("master", mode = "list", 
[16:13:56.754]                             envir = envir, inherits = FALSE)
[16:13:56.754]                           if (inherits(master, c("SOCKnode", 
[16:13:56.754]                             "SOCK0node"))) {
[16:13:56.754]                             sendCondition <<- function(cond) {
[16:13:56.754]                               data <- list(type = "VALUE", value = cond, 
[16:13:56.754]                                 success = TRUE)
[16:13:56.754]                               parallel_sendData(master, data)
[16:13:56.754]                             }
[16:13:56.754]                             return(sendCondition)
[16:13:56.754]                           }
[16:13:56.754]                         }
[16:13:56.754]                         frame <- frame + 1L
[16:13:56.754]                         envir <- sys.frame(frame)
[16:13:56.754]                       }
[16:13:56.754]                     }
[16:13:56.754]                     sendCondition <<- function(cond) NULL
[16:13:56.754]                   }
[16:13:56.754]                 })
[16:13:56.754]                 withCallingHandlers({
[16:13:56.754]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:56.754]                 }, immediateCondition = function(cond) {
[16:13:56.754]                   sendCondition <- ...future.makeSendCondition()
[16:13:56.754]                   sendCondition(cond)
[16:13:56.754]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:56.754]                   {
[16:13:56.754]                     inherits <- base::inherits
[16:13:56.754]                     invokeRestart <- base::invokeRestart
[16:13:56.754]                     is.null <- base::is.null
[16:13:56.754]                     muffled <- FALSE
[16:13:56.754]                     if (inherits(cond, "message")) {
[16:13:56.754]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:56.754]                       if (muffled) 
[16:13:56.754]                         invokeRestart("muffleMessage")
[16:13:56.754]                     }
[16:13:56.754]                     else if (inherits(cond, "warning")) {
[16:13:56.754]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:56.754]                       if (muffled) 
[16:13:56.754]                         invokeRestart("muffleWarning")
[16:13:56.754]                     }
[16:13:56.754]                     else if (inherits(cond, "condition")) {
[16:13:56.754]                       if (!is.null(pattern)) {
[16:13:56.754]                         computeRestarts <- base::computeRestarts
[16:13:56.754]                         grepl <- base::grepl
[16:13:56.754]                         restarts <- computeRestarts(cond)
[16:13:56.754]                         for (restart in restarts) {
[16:13:56.754]                           name <- restart$name
[16:13:56.754]                           if (is.null(name)) 
[16:13:56.754]                             next
[16:13:56.754]                           if (!grepl(pattern, name)) 
[16:13:56.754]                             next
[16:13:56.754]                           invokeRestart(restart)
[16:13:56.754]                           muffled <- TRUE
[16:13:56.754]                           break
[16:13:56.754]                         }
[16:13:56.754]                       }
[16:13:56.754]                     }
[16:13:56.754]                     invisible(muffled)
[16:13:56.754]                   }
[16:13:56.754]                   muffleCondition(cond)
[16:13:56.754]                 })
[16:13:56.754]             }))
[16:13:56.754]             future::FutureResult(value = ...future.value$value, 
[16:13:56.754]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:56.754]                   ...future.rng), globalenv = if (FALSE) 
[16:13:56.754]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:56.754]                     ...future.globalenv.names))
[16:13:56.754]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:56.754]         }, condition = base::local({
[16:13:56.754]             c <- base::c
[16:13:56.754]             inherits <- base::inherits
[16:13:56.754]             invokeRestart <- base::invokeRestart
[16:13:56.754]             length <- base::length
[16:13:56.754]             list <- base::list
[16:13:56.754]             seq.int <- base::seq.int
[16:13:56.754]             signalCondition <- base::signalCondition
[16:13:56.754]             sys.calls <- base::sys.calls
[16:13:56.754]             `[[` <- base::`[[`
[16:13:56.754]             `+` <- base::`+`
[16:13:56.754]             `<<-` <- base::`<<-`
[16:13:56.754]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:56.754]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:56.754]                   3L)]
[16:13:56.754]             }
[16:13:56.754]             function(cond) {
[16:13:56.754]                 is_error <- inherits(cond, "error")
[16:13:56.754]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:56.754]                   NULL)
[16:13:56.754]                 if (is_error) {
[16:13:56.754]                   sessionInformation <- function() {
[16:13:56.754]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:56.754]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:56.754]                       search = base::search(), system = base::Sys.info())
[16:13:56.754]                   }
[16:13:56.754]                   ...future.conditions[[length(...future.conditions) + 
[16:13:56.754]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:56.754]                     cond$call), session = sessionInformation(), 
[16:13:56.754]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:56.754]                   signalCondition(cond)
[16:13:56.754]                 }
[16:13:56.754]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:56.754]                 "immediateCondition"))) {
[16:13:56.754]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:56.754]                   ...future.conditions[[length(...future.conditions) + 
[16:13:56.754]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:56.754]                   if (TRUE && !signal) {
[16:13:56.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:56.754]                     {
[16:13:56.754]                       inherits <- base::inherits
[16:13:56.754]                       invokeRestart <- base::invokeRestart
[16:13:56.754]                       is.null <- base::is.null
[16:13:56.754]                       muffled <- FALSE
[16:13:56.754]                       if (inherits(cond, "message")) {
[16:13:56.754]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:56.754]                         if (muffled) 
[16:13:56.754]                           invokeRestart("muffleMessage")
[16:13:56.754]                       }
[16:13:56.754]                       else if (inherits(cond, "warning")) {
[16:13:56.754]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:56.754]                         if (muffled) 
[16:13:56.754]                           invokeRestart("muffleWarning")
[16:13:56.754]                       }
[16:13:56.754]                       else if (inherits(cond, "condition")) {
[16:13:56.754]                         if (!is.null(pattern)) {
[16:13:56.754]                           computeRestarts <- base::computeRestarts
[16:13:56.754]                           grepl <- base::grepl
[16:13:56.754]                           restarts <- computeRestarts(cond)
[16:13:56.754]                           for (restart in restarts) {
[16:13:56.754]                             name <- restart$name
[16:13:56.754]                             if (is.null(name)) 
[16:13:56.754]                               next
[16:13:56.754]                             if (!grepl(pattern, name)) 
[16:13:56.754]                               next
[16:13:56.754]                             invokeRestart(restart)
[16:13:56.754]                             muffled <- TRUE
[16:13:56.754]                             break
[16:13:56.754]                           }
[16:13:56.754]                         }
[16:13:56.754]                       }
[16:13:56.754]                       invisible(muffled)
[16:13:56.754]                     }
[16:13:56.754]                     muffleCondition(cond, pattern = "^muffle")
[16:13:56.754]                   }
[16:13:56.754]                 }
[16:13:56.754]                 else {
[16:13:56.754]                   if (TRUE) {
[16:13:56.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:56.754]                     {
[16:13:56.754]                       inherits <- base::inherits
[16:13:56.754]                       invokeRestart <- base::invokeRestart
[16:13:56.754]                       is.null <- base::is.null
[16:13:56.754]                       muffled <- FALSE
[16:13:56.754]                       if (inherits(cond, "message")) {
[16:13:56.754]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:56.754]                         if (muffled) 
[16:13:56.754]                           invokeRestart("muffleMessage")
[16:13:56.754]                       }
[16:13:56.754]                       else if (inherits(cond, "warning")) {
[16:13:56.754]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:56.754]                         if (muffled) 
[16:13:56.754]                           invokeRestart("muffleWarning")
[16:13:56.754]                       }
[16:13:56.754]                       else if (inherits(cond, "condition")) {
[16:13:56.754]                         if (!is.null(pattern)) {
[16:13:56.754]                           computeRestarts <- base::computeRestarts
[16:13:56.754]                           grepl <- base::grepl
[16:13:56.754]                           restarts <- computeRestarts(cond)
[16:13:56.754]                           for (restart in restarts) {
[16:13:56.754]                             name <- restart$name
[16:13:56.754]                             if (is.null(name)) 
[16:13:56.754]                               next
[16:13:56.754]                             if (!grepl(pattern, name)) 
[16:13:56.754]                               next
[16:13:56.754]                             invokeRestart(restart)
[16:13:56.754]                             muffled <- TRUE
[16:13:56.754]                             break
[16:13:56.754]                           }
[16:13:56.754]                         }
[16:13:56.754]                       }
[16:13:56.754]                       invisible(muffled)
[16:13:56.754]                     }
[16:13:56.754]                     muffleCondition(cond, pattern = "^muffle")
[16:13:56.754]                   }
[16:13:56.754]                 }
[16:13:56.754]             }
[16:13:56.754]         }))
[16:13:56.754]     }, error = function(ex) {
[16:13:56.754]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:56.754]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:56.754]                 ...future.rng), started = ...future.startTime, 
[16:13:56.754]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:56.754]             version = "1.8"), class = "FutureResult")
[16:13:56.754]     }, finally = {
[16:13:56.754]         if (!identical(...future.workdir, getwd())) 
[16:13:56.754]             setwd(...future.workdir)
[16:13:56.754]         {
[16:13:56.754]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:56.754]                 ...future.oldOptions$nwarnings <- NULL
[16:13:56.754]             }
[16:13:56.754]             base::options(...future.oldOptions)
[16:13:56.754]             if (.Platform$OS.type == "windows") {
[16:13:56.754]                 old_names <- names(...future.oldEnvVars)
[16:13:56.754]                 envs <- base::Sys.getenv()
[16:13:56.754]                 names <- names(envs)
[16:13:56.754]                 common <- intersect(names, old_names)
[16:13:56.754]                 added <- setdiff(names, old_names)
[16:13:56.754]                 removed <- setdiff(old_names, names)
[16:13:56.754]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:56.754]                   envs[common]]
[16:13:56.754]                 NAMES <- toupper(changed)
[16:13:56.754]                 args <- list()
[16:13:56.754]                 for (kk in seq_along(NAMES)) {
[16:13:56.754]                   name <- changed[[kk]]
[16:13:56.754]                   NAME <- NAMES[[kk]]
[16:13:56.754]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:56.754]                     next
[16:13:56.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:56.754]                 }
[16:13:56.754]                 NAMES <- toupper(added)
[16:13:56.754]                 for (kk in seq_along(NAMES)) {
[16:13:56.754]                   name <- added[[kk]]
[16:13:56.754]                   NAME <- NAMES[[kk]]
[16:13:56.754]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:56.754]                     next
[16:13:56.754]                   args[[name]] <- ""
[16:13:56.754]                 }
[16:13:56.754]                 NAMES <- toupper(removed)
[16:13:56.754]                 for (kk in seq_along(NAMES)) {
[16:13:56.754]                   name <- removed[[kk]]
[16:13:56.754]                   NAME <- NAMES[[kk]]
[16:13:56.754]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:56.754]                     next
[16:13:56.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:56.754]                 }
[16:13:56.754]                 if (length(args) > 0) 
[16:13:56.754]                   base::do.call(base::Sys.setenv, args = args)
[16:13:56.754]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:56.754]             }
[16:13:56.754]             else {
[16:13:56.754]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:56.754]             }
[16:13:56.754]             {
[16:13:56.754]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:56.754]                   0L) {
[16:13:56.754]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:56.754]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:56.754]                   base::options(opts)
[16:13:56.754]                 }
[16:13:56.754]                 {
[16:13:56.754]                   {
[16:13:56.754]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:56.754]                     NULL
[16:13:56.754]                   }
[16:13:56.754]                   options(future.plan = NULL)
[16:13:56.754]                   if (is.na(NA_character_)) 
[16:13:56.754]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:56.754]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:56.754]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:56.754]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:56.754]                     envir = parent.frame()) 
[16:13:56.754]                   {
[16:13:56.754]                     if (is.function(workers)) 
[16:13:56.754]                       workers <- workers()
[16:13:56.754]                     workers <- structure(as.integer(workers), 
[16:13:56.754]                       class = class(workers))
[16:13:56.754]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:56.754]                       workers >= 1)
[16:13:56.754]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:56.754]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:56.754]                     }
[16:13:56.754]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:56.754]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:56.754]                       envir = envir)
[16:13:56.754]                     if (!future$lazy) 
[16:13:56.754]                       future <- run(future)
[16:13:56.754]                     invisible(future)
[16:13:56.754]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:56.754]                 }
[16:13:56.754]             }
[16:13:56.754]         }
[16:13:56.754]     })
[16:13:56.754]     if (TRUE) {
[16:13:56.754]         base::sink(type = "output", split = FALSE)
[16:13:56.754]         if (TRUE) {
[16:13:56.754]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:56.754]         }
[16:13:56.754]         else {
[16:13:56.754]             ...future.result["stdout"] <- base::list(NULL)
[16:13:56.754]         }
[16:13:56.754]         base::close(...future.stdout)
[16:13:56.754]         ...future.stdout <- NULL
[16:13:56.754]     }
[16:13:56.754]     ...future.result$conditions <- ...future.conditions
[16:13:56.754]     ...future.result$finished <- base::Sys.time()
[16:13:56.754]     ...future.result
[16:13:56.754] }
[16:13:56.757] MultisessionFuture started
[16:13:56.757] - Launch lazy future ... done
[16:13:56.757] run() for ‘MultisessionFuture’ ... done
[16:13:56.804] receiveMessageFromWorker() for ClusterFuture ...
[16:13:56.804] - Validating connection of MultisessionFuture
[16:13:56.805] - received message: FutureResult
[16:13:56.805] - Received FutureResult
[16:13:56.805] - Erased future from FutureRegistry
[16:13:56.805] result() for ClusterFuture ...
[16:13:56.805] - result already collected: FutureResult
[16:13:56.805] result() for ClusterFuture ... done
[16:13:56.805] signalConditions() ...
[16:13:56.806]  - include = ‘immediateCondition’
[16:13:56.806]  - exclude = 
[16:13:56.806]  - resignal = FALSE
[16:13:56.806]  - Number of conditions: 1
[16:13:56.806] signalConditions() ... done
[16:13:56.806] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:56.806] A MultisessionFuture was resolved
[16:13:56.806] getGlobalsAndPackages() ...
[16:13:56.806] Searching for globals...
[16:13:56.807] - globals found: [2] ‘list’, ‘stop’
[16:13:56.807] Searching for globals ... DONE
[16:13:56.807] Resolving globals: FALSE
[16:13:56.807] 
[16:13:56.807] 
[16:13:56.808] getGlobalsAndPackages() ... DONE
[16:13:56.808] run() for ‘Future’ ...
[16:13:56.808] - state: ‘created’
[16:13:56.808] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:56.822] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:56.822] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:56.822]   - Field: ‘node’
[16:13:56.822]   - Field: ‘label’
[16:13:56.822]   - Field: ‘local’
[16:13:56.823]   - Field: ‘owner’
[16:13:56.823]   - Field: ‘envir’
[16:13:56.823]   - Field: ‘workers’
[16:13:56.823]   - Field: ‘packages’
[16:13:56.823]   - Field: ‘gc’
[16:13:56.823]   - Field: ‘conditions’
[16:13:56.823]   - Field: ‘persistent’
[16:13:56.823]   - Field: ‘expr’
[16:13:56.823]   - Field: ‘uuid’
[16:13:56.823]   - Field: ‘seed’
[16:13:56.823]   - Field: ‘version’
[16:13:56.824]   - Field: ‘result’
[16:13:56.824]   - Field: ‘asynchronous’
[16:13:56.824]   - Field: ‘calls’
[16:13:56.824]   - Field: ‘globals’
[16:13:56.824]   - Field: ‘stdout’
[16:13:56.824]   - Field: ‘earlySignal’
[16:13:56.824]   - Field: ‘lazy’
[16:13:56.824]   - Field: ‘state’
[16:13:56.824] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:56.824] - Launch lazy future ...
[16:13:56.825] Packages needed by the future expression (n = 0): <none>
[16:13:56.825] Packages needed by future strategies (n = 0): <none>
[16:13:56.825] {
[16:13:56.825]     {
[16:13:56.825]         {
[16:13:56.825]             ...future.startTime <- base::Sys.time()
[16:13:56.825]             {
[16:13:56.825]                 {
[16:13:56.825]                   {
[16:13:56.825]                     {
[16:13:56.825]                       base::local({
[16:13:56.825]                         has_future <- base::requireNamespace("future", 
[16:13:56.825]                           quietly = TRUE)
[16:13:56.825]                         if (has_future) {
[16:13:56.825]                           ns <- base::getNamespace("future")
[16:13:56.825]                           version <- ns[[".package"]][["version"]]
[16:13:56.825]                           if (is.null(version)) 
[16:13:56.825]                             version <- utils::packageVersion("future")
[16:13:56.825]                         }
[16:13:56.825]                         else {
[16:13:56.825]                           version <- NULL
[16:13:56.825]                         }
[16:13:56.825]                         if (!has_future || version < "1.8.0") {
[16:13:56.825]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:56.825]                             "", base::R.version$version.string), 
[16:13:56.825]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:56.825]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:56.825]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:56.825]                               "release", "version")], collapse = " "), 
[16:13:56.825]                             hostname = base::Sys.info()[["nodename"]])
[16:13:56.825]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:56.825]                             info)
[16:13:56.825]                           info <- base::paste(info, collapse = "; ")
[16:13:56.825]                           if (!has_future) {
[16:13:56.825]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:56.825]                               info)
[16:13:56.825]                           }
[16:13:56.825]                           else {
[16:13:56.825]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:56.825]                               info, version)
[16:13:56.825]                           }
[16:13:56.825]                           base::stop(msg)
[16:13:56.825]                         }
[16:13:56.825]                       })
[16:13:56.825]                     }
[16:13:56.825]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:56.825]                     base::options(mc.cores = 1L)
[16:13:56.825]                   }
[16:13:56.825]                   options(future.plan = NULL)
[16:13:56.825]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:56.825]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:56.825]                 }
[16:13:56.825]                 ...future.workdir <- getwd()
[16:13:56.825]             }
[16:13:56.825]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:56.825]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:56.825]         }
[16:13:56.825]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:56.825]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:56.825]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:56.825]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:56.825]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:56.825]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:56.825]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:56.825]             base::names(...future.oldOptions))
[16:13:56.825]     }
[16:13:56.825]     if (FALSE) {
[16:13:56.825]     }
[16:13:56.825]     else {
[16:13:56.825]         if (TRUE) {
[16:13:56.825]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:56.825]                 open = "w")
[16:13:56.825]         }
[16:13:56.825]         else {
[16:13:56.825]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:56.825]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:56.825]         }
[16:13:56.825]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:56.825]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:56.825]             base::sink(type = "output", split = FALSE)
[16:13:56.825]             base::close(...future.stdout)
[16:13:56.825]         }, add = TRUE)
[16:13:56.825]     }
[16:13:56.825]     ...future.frame <- base::sys.nframe()
[16:13:56.825]     ...future.conditions <- base::list()
[16:13:56.825]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:56.825]     if (FALSE) {
[16:13:56.825]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:56.825]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:56.825]     }
[16:13:56.825]     ...future.result <- base::tryCatch({
[16:13:56.825]         base::withCallingHandlers({
[16:13:56.825]             ...future.value <- base::withVisible(base::local({
[16:13:56.825]                 ...future.makeSendCondition <- local({
[16:13:56.825]                   sendCondition <- NULL
[16:13:56.825]                   function(frame = 1L) {
[16:13:56.825]                     if (is.function(sendCondition)) 
[16:13:56.825]                       return(sendCondition)
[16:13:56.825]                     ns <- getNamespace("parallel")
[16:13:56.825]                     if (exists("sendData", mode = "function", 
[16:13:56.825]                       envir = ns)) {
[16:13:56.825]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:56.825]                         envir = ns)
[16:13:56.825]                       envir <- sys.frame(frame)
[16:13:56.825]                       master <- NULL
[16:13:56.825]                       while (!identical(envir, .GlobalEnv) && 
[16:13:56.825]                         !identical(envir, emptyenv())) {
[16:13:56.825]                         if (exists("master", mode = "list", envir = envir, 
[16:13:56.825]                           inherits = FALSE)) {
[16:13:56.825]                           master <- get("master", mode = "list", 
[16:13:56.825]                             envir = envir, inherits = FALSE)
[16:13:56.825]                           if (inherits(master, c("SOCKnode", 
[16:13:56.825]                             "SOCK0node"))) {
[16:13:56.825]                             sendCondition <<- function(cond) {
[16:13:56.825]                               data <- list(type = "VALUE", value = cond, 
[16:13:56.825]                                 success = TRUE)
[16:13:56.825]                               parallel_sendData(master, data)
[16:13:56.825]                             }
[16:13:56.825]                             return(sendCondition)
[16:13:56.825]                           }
[16:13:56.825]                         }
[16:13:56.825]                         frame <- frame + 1L
[16:13:56.825]                         envir <- sys.frame(frame)
[16:13:56.825]                       }
[16:13:56.825]                     }
[16:13:56.825]                     sendCondition <<- function(cond) NULL
[16:13:56.825]                   }
[16:13:56.825]                 })
[16:13:56.825]                 withCallingHandlers({
[16:13:56.825]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:56.825]                 }, immediateCondition = function(cond) {
[16:13:56.825]                   sendCondition <- ...future.makeSendCondition()
[16:13:56.825]                   sendCondition(cond)
[16:13:56.825]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:56.825]                   {
[16:13:56.825]                     inherits <- base::inherits
[16:13:56.825]                     invokeRestart <- base::invokeRestart
[16:13:56.825]                     is.null <- base::is.null
[16:13:56.825]                     muffled <- FALSE
[16:13:56.825]                     if (inherits(cond, "message")) {
[16:13:56.825]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:56.825]                       if (muffled) 
[16:13:56.825]                         invokeRestart("muffleMessage")
[16:13:56.825]                     }
[16:13:56.825]                     else if (inherits(cond, "warning")) {
[16:13:56.825]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:56.825]                       if (muffled) 
[16:13:56.825]                         invokeRestart("muffleWarning")
[16:13:56.825]                     }
[16:13:56.825]                     else if (inherits(cond, "condition")) {
[16:13:56.825]                       if (!is.null(pattern)) {
[16:13:56.825]                         computeRestarts <- base::computeRestarts
[16:13:56.825]                         grepl <- base::grepl
[16:13:56.825]                         restarts <- computeRestarts(cond)
[16:13:56.825]                         for (restart in restarts) {
[16:13:56.825]                           name <- restart$name
[16:13:56.825]                           if (is.null(name)) 
[16:13:56.825]                             next
[16:13:56.825]                           if (!grepl(pattern, name)) 
[16:13:56.825]                             next
[16:13:56.825]                           invokeRestart(restart)
[16:13:56.825]                           muffled <- TRUE
[16:13:56.825]                           break
[16:13:56.825]                         }
[16:13:56.825]                       }
[16:13:56.825]                     }
[16:13:56.825]                     invisible(muffled)
[16:13:56.825]                   }
[16:13:56.825]                   muffleCondition(cond)
[16:13:56.825]                 })
[16:13:56.825]             }))
[16:13:56.825]             future::FutureResult(value = ...future.value$value, 
[16:13:56.825]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:56.825]                   ...future.rng), globalenv = if (FALSE) 
[16:13:56.825]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:56.825]                     ...future.globalenv.names))
[16:13:56.825]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:56.825]         }, condition = base::local({
[16:13:56.825]             c <- base::c
[16:13:56.825]             inherits <- base::inherits
[16:13:56.825]             invokeRestart <- base::invokeRestart
[16:13:56.825]             length <- base::length
[16:13:56.825]             list <- base::list
[16:13:56.825]             seq.int <- base::seq.int
[16:13:56.825]             signalCondition <- base::signalCondition
[16:13:56.825]             sys.calls <- base::sys.calls
[16:13:56.825]             `[[` <- base::`[[`
[16:13:56.825]             `+` <- base::`+`
[16:13:56.825]             `<<-` <- base::`<<-`
[16:13:56.825]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:56.825]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:56.825]                   3L)]
[16:13:56.825]             }
[16:13:56.825]             function(cond) {
[16:13:56.825]                 is_error <- inherits(cond, "error")
[16:13:56.825]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:56.825]                   NULL)
[16:13:56.825]                 if (is_error) {
[16:13:56.825]                   sessionInformation <- function() {
[16:13:56.825]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:56.825]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:56.825]                       search = base::search(), system = base::Sys.info())
[16:13:56.825]                   }
[16:13:56.825]                   ...future.conditions[[length(...future.conditions) + 
[16:13:56.825]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:56.825]                     cond$call), session = sessionInformation(), 
[16:13:56.825]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:56.825]                   signalCondition(cond)
[16:13:56.825]                 }
[16:13:56.825]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:56.825]                 "immediateCondition"))) {
[16:13:56.825]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:56.825]                   ...future.conditions[[length(...future.conditions) + 
[16:13:56.825]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:56.825]                   if (TRUE && !signal) {
[16:13:56.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:56.825]                     {
[16:13:56.825]                       inherits <- base::inherits
[16:13:56.825]                       invokeRestart <- base::invokeRestart
[16:13:56.825]                       is.null <- base::is.null
[16:13:56.825]                       muffled <- FALSE
[16:13:56.825]                       if (inherits(cond, "message")) {
[16:13:56.825]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:56.825]                         if (muffled) 
[16:13:56.825]                           invokeRestart("muffleMessage")
[16:13:56.825]                       }
[16:13:56.825]                       else if (inherits(cond, "warning")) {
[16:13:56.825]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:56.825]                         if (muffled) 
[16:13:56.825]                           invokeRestart("muffleWarning")
[16:13:56.825]                       }
[16:13:56.825]                       else if (inherits(cond, "condition")) {
[16:13:56.825]                         if (!is.null(pattern)) {
[16:13:56.825]                           computeRestarts <- base::computeRestarts
[16:13:56.825]                           grepl <- base::grepl
[16:13:56.825]                           restarts <- computeRestarts(cond)
[16:13:56.825]                           for (restart in restarts) {
[16:13:56.825]                             name <- restart$name
[16:13:56.825]                             if (is.null(name)) 
[16:13:56.825]                               next
[16:13:56.825]                             if (!grepl(pattern, name)) 
[16:13:56.825]                               next
[16:13:56.825]                             invokeRestart(restart)
[16:13:56.825]                             muffled <- TRUE
[16:13:56.825]                             break
[16:13:56.825]                           }
[16:13:56.825]                         }
[16:13:56.825]                       }
[16:13:56.825]                       invisible(muffled)
[16:13:56.825]                     }
[16:13:56.825]                     muffleCondition(cond, pattern = "^muffle")
[16:13:56.825]                   }
[16:13:56.825]                 }
[16:13:56.825]                 else {
[16:13:56.825]                   if (TRUE) {
[16:13:56.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:56.825]                     {
[16:13:56.825]                       inherits <- base::inherits
[16:13:56.825]                       invokeRestart <- base::invokeRestart
[16:13:56.825]                       is.null <- base::is.null
[16:13:56.825]                       muffled <- FALSE
[16:13:56.825]                       if (inherits(cond, "message")) {
[16:13:56.825]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:56.825]                         if (muffled) 
[16:13:56.825]                           invokeRestart("muffleMessage")
[16:13:56.825]                       }
[16:13:56.825]                       else if (inherits(cond, "warning")) {
[16:13:56.825]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:56.825]                         if (muffled) 
[16:13:56.825]                           invokeRestart("muffleWarning")
[16:13:56.825]                       }
[16:13:56.825]                       else if (inherits(cond, "condition")) {
[16:13:56.825]                         if (!is.null(pattern)) {
[16:13:56.825]                           computeRestarts <- base::computeRestarts
[16:13:56.825]                           grepl <- base::grepl
[16:13:56.825]                           restarts <- computeRestarts(cond)
[16:13:56.825]                           for (restart in restarts) {
[16:13:56.825]                             name <- restart$name
[16:13:56.825]                             if (is.null(name)) 
[16:13:56.825]                               next
[16:13:56.825]                             if (!grepl(pattern, name)) 
[16:13:56.825]                               next
[16:13:56.825]                             invokeRestart(restart)
[16:13:56.825]                             muffled <- TRUE
[16:13:56.825]                             break
[16:13:56.825]                           }
[16:13:56.825]                         }
[16:13:56.825]                       }
[16:13:56.825]                       invisible(muffled)
[16:13:56.825]                     }
[16:13:56.825]                     muffleCondition(cond, pattern = "^muffle")
[16:13:56.825]                   }
[16:13:56.825]                 }
[16:13:56.825]             }
[16:13:56.825]         }))
[16:13:56.825]     }, error = function(ex) {
[16:13:56.825]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:56.825]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:56.825]                 ...future.rng), started = ...future.startTime, 
[16:13:56.825]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:56.825]             version = "1.8"), class = "FutureResult")
[16:13:56.825]     }, finally = {
[16:13:56.825]         if (!identical(...future.workdir, getwd())) 
[16:13:56.825]             setwd(...future.workdir)
[16:13:56.825]         {
[16:13:56.825]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:56.825]                 ...future.oldOptions$nwarnings <- NULL
[16:13:56.825]             }
[16:13:56.825]             base::options(...future.oldOptions)
[16:13:56.825]             if (.Platform$OS.type == "windows") {
[16:13:56.825]                 old_names <- names(...future.oldEnvVars)
[16:13:56.825]                 envs <- base::Sys.getenv()
[16:13:56.825]                 names <- names(envs)
[16:13:56.825]                 common <- intersect(names, old_names)
[16:13:56.825]                 added <- setdiff(names, old_names)
[16:13:56.825]                 removed <- setdiff(old_names, names)
[16:13:56.825]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:56.825]                   envs[common]]
[16:13:56.825]                 NAMES <- toupper(changed)
[16:13:56.825]                 args <- list()
[16:13:56.825]                 for (kk in seq_along(NAMES)) {
[16:13:56.825]                   name <- changed[[kk]]
[16:13:56.825]                   NAME <- NAMES[[kk]]
[16:13:56.825]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:56.825]                     next
[16:13:56.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:56.825]                 }
[16:13:56.825]                 NAMES <- toupper(added)
[16:13:56.825]                 for (kk in seq_along(NAMES)) {
[16:13:56.825]                   name <- added[[kk]]
[16:13:56.825]                   NAME <- NAMES[[kk]]
[16:13:56.825]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:56.825]                     next
[16:13:56.825]                   args[[name]] <- ""
[16:13:56.825]                 }
[16:13:56.825]                 NAMES <- toupper(removed)
[16:13:56.825]                 for (kk in seq_along(NAMES)) {
[16:13:56.825]                   name <- removed[[kk]]
[16:13:56.825]                   NAME <- NAMES[[kk]]
[16:13:56.825]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:56.825]                     next
[16:13:56.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:56.825]                 }
[16:13:56.825]                 if (length(args) > 0) 
[16:13:56.825]                   base::do.call(base::Sys.setenv, args = args)
[16:13:56.825]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:56.825]             }
[16:13:56.825]             else {
[16:13:56.825]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:56.825]             }
[16:13:56.825]             {
[16:13:56.825]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:56.825]                   0L) {
[16:13:56.825]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:56.825]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:56.825]                   base::options(opts)
[16:13:56.825]                 }
[16:13:56.825]                 {
[16:13:56.825]                   {
[16:13:56.825]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:56.825]                     NULL
[16:13:56.825]                   }
[16:13:56.825]                   options(future.plan = NULL)
[16:13:56.825]                   if (is.na(NA_character_)) 
[16:13:56.825]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:56.825]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:56.825]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:56.825]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:56.825]                     envir = parent.frame()) 
[16:13:56.825]                   {
[16:13:56.825]                     if (is.function(workers)) 
[16:13:56.825]                       workers <- workers()
[16:13:56.825]                     workers <- structure(as.integer(workers), 
[16:13:56.825]                       class = class(workers))
[16:13:56.825]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:56.825]                       workers >= 1)
[16:13:56.825]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:56.825]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:56.825]                     }
[16:13:56.825]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:56.825]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:56.825]                       envir = envir)
[16:13:56.825]                     if (!future$lazy) 
[16:13:56.825]                       future <- run(future)
[16:13:56.825]                     invisible(future)
[16:13:56.825]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:56.825]                 }
[16:13:56.825]             }
[16:13:56.825]         }
[16:13:56.825]     })
[16:13:56.825]     if (TRUE) {
[16:13:56.825]         base::sink(type = "output", split = FALSE)
[16:13:56.825]         if (TRUE) {
[16:13:56.825]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:56.825]         }
[16:13:56.825]         else {
[16:13:56.825]             ...future.result["stdout"] <- base::list(NULL)
[16:13:56.825]         }
[16:13:56.825]         base::close(...future.stdout)
[16:13:56.825]         ...future.stdout <- NULL
[16:13:56.825]     }
[16:13:56.825]     ...future.result$conditions <- ...future.conditions
[16:13:56.825]     ...future.result$finished <- base::Sys.time()
[16:13:56.825]     ...future.result
[16:13:56.825] }
[16:13:56.828] MultisessionFuture started
[16:13:56.828] - Launch lazy future ... done
[16:13:56.828] run() for ‘MultisessionFuture’ ... done
[16:13:56.877] receiveMessageFromWorker() for ClusterFuture ...
[16:13:56.877] - Validating connection of MultisessionFuture
[16:13:56.877] - received message: FutureResult
[16:13:56.877] - Received FutureResult
[16:13:56.878] - Erased future from FutureRegistry
[16:13:56.878] result() for ClusterFuture ...
[16:13:56.878] - result already collected: FutureResult
[16:13:56.878] result() for ClusterFuture ... done
[16:13:56.878] signalConditions() ...
[16:13:56.878]  - include = ‘immediateCondition’
[16:13:56.878]  - exclude = 
[16:13:56.878]  - resignal = FALSE
[16:13:56.878]  - Number of conditions: 1
[16:13:56.878] signalConditions() ... done
[16:13:56.878] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:56.879] A MultisessionFuture was resolved
- result = TRUE, recursive = 1 ... DONE
- result = TRUE, recursive = 2 ...
[16:13:56.879] getGlobalsAndPackages() ...
[16:13:56.879] Searching for globals...
[16:13:56.880] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:56.880] Searching for globals ... DONE
[16:13:56.880] Resolving globals: FALSE
[16:13:56.881] 
[16:13:56.881] 
[16:13:56.881] getGlobalsAndPackages() ... DONE
[16:13:56.881] run() for ‘Future’ ...
[16:13:56.881] - state: ‘created’
[16:13:56.881] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:56.896] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:56.896] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:56.896]   - Field: ‘node’
[16:13:56.896]   - Field: ‘label’
[16:13:56.896]   - Field: ‘local’
[16:13:56.896]   - Field: ‘owner’
[16:13:56.896]   - Field: ‘envir’
[16:13:56.896]   - Field: ‘workers’
[16:13:56.896]   - Field: ‘packages’
[16:13:56.897]   - Field: ‘gc’
[16:13:56.897]   - Field: ‘conditions’
[16:13:56.897]   - Field: ‘persistent’
[16:13:56.897]   - Field: ‘expr’
[16:13:56.897]   - Field: ‘uuid’
[16:13:56.897]   - Field: ‘seed’
[16:13:56.897]   - Field: ‘version’
[16:13:56.897]   - Field: ‘result’
[16:13:56.897]   - Field: ‘asynchronous’
[16:13:56.897]   - Field: ‘calls’
[16:13:56.897]   - Field: ‘globals’
[16:13:56.898]   - Field: ‘stdout’
[16:13:56.898]   - Field: ‘earlySignal’
[16:13:56.898]   - Field: ‘lazy’
[16:13:56.898]   - Field: ‘state’
[16:13:56.898] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:56.898] - Launch lazy future ...
[16:13:56.898] Packages needed by the future expression (n = 0): <none>
[16:13:56.898] Packages needed by future strategies (n = 0): <none>
[16:13:56.899] {
[16:13:56.899]     {
[16:13:56.899]         {
[16:13:56.899]             ...future.startTime <- base::Sys.time()
[16:13:56.899]             {
[16:13:56.899]                 {
[16:13:56.899]                   {
[16:13:56.899]                     {
[16:13:56.899]                       base::local({
[16:13:56.899]                         has_future <- base::requireNamespace("future", 
[16:13:56.899]                           quietly = TRUE)
[16:13:56.899]                         if (has_future) {
[16:13:56.899]                           ns <- base::getNamespace("future")
[16:13:56.899]                           version <- ns[[".package"]][["version"]]
[16:13:56.899]                           if (is.null(version)) 
[16:13:56.899]                             version <- utils::packageVersion("future")
[16:13:56.899]                         }
[16:13:56.899]                         else {
[16:13:56.899]                           version <- NULL
[16:13:56.899]                         }
[16:13:56.899]                         if (!has_future || version < "1.8.0") {
[16:13:56.899]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:56.899]                             "", base::R.version$version.string), 
[16:13:56.899]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:56.899]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:56.899]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:56.899]                               "release", "version")], collapse = " "), 
[16:13:56.899]                             hostname = base::Sys.info()[["nodename"]])
[16:13:56.899]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:56.899]                             info)
[16:13:56.899]                           info <- base::paste(info, collapse = "; ")
[16:13:56.899]                           if (!has_future) {
[16:13:56.899]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:56.899]                               info)
[16:13:56.899]                           }
[16:13:56.899]                           else {
[16:13:56.899]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:56.899]                               info, version)
[16:13:56.899]                           }
[16:13:56.899]                           base::stop(msg)
[16:13:56.899]                         }
[16:13:56.899]                       })
[16:13:56.899]                     }
[16:13:56.899]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:56.899]                     base::options(mc.cores = 1L)
[16:13:56.899]                   }
[16:13:56.899]                   options(future.plan = NULL)
[16:13:56.899]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:56.899]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:56.899]                 }
[16:13:56.899]                 ...future.workdir <- getwd()
[16:13:56.899]             }
[16:13:56.899]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:56.899]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:56.899]         }
[16:13:56.899]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:56.899]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:56.899]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:56.899]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:56.899]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:56.899]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:56.899]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:56.899]             base::names(...future.oldOptions))
[16:13:56.899]     }
[16:13:56.899]     if (FALSE) {
[16:13:56.899]     }
[16:13:56.899]     else {
[16:13:56.899]         if (TRUE) {
[16:13:56.899]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:56.899]                 open = "w")
[16:13:56.899]         }
[16:13:56.899]         else {
[16:13:56.899]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:56.899]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:56.899]         }
[16:13:56.899]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:56.899]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:56.899]             base::sink(type = "output", split = FALSE)
[16:13:56.899]             base::close(...future.stdout)
[16:13:56.899]         }, add = TRUE)
[16:13:56.899]     }
[16:13:56.899]     ...future.frame <- base::sys.nframe()
[16:13:56.899]     ...future.conditions <- base::list()
[16:13:56.899]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:56.899]     if (FALSE) {
[16:13:56.899]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:56.899]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:56.899]     }
[16:13:56.899]     ...future.result <- base::tryCatch({
[16:13:56.899]         base::withCallingHandlers({
[16:13:56.899]             ...future.value <- base::withVisible(base::local({
[16:13:56.899]                 ...future.makeSendCondition <- local({
[16:13:56.899]                   sendCondition <- NULL
[16:13:56.899]                   function(frame = 1L) {
[16:13:56.899]                     if (is.function(sendCondition)) 
[16:13:56.899]                       return(sendCondition)
[16:13:56.899]                     ns <- getNamespace("parallel")
[16:13:56.899]                     if (exists("sendData", mode = "function", 
[16:13:56.899]                       envir = ns)) {
[16:13:56.899]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:56.899]                         envir = ns)
[16:13:56.899]                       envir <- sys.frame(frame)
[16:13:56.899]                       master <- NULL
[16:13:56.899]                       while (!identical(envir, .GlobalEnv) && 
[16:13:56.899]                         !identical(envir, emptyenv())) {
[16:13:56.899]                         if (exists("master", mode = "list", envir = envir, 
[16:13:56.899]                           inherits = FALSE)) {
[16:13:56.899]                           master <- get("master", mode = "list", 
[16:13:56.899]                             envir = envir, inherits = FALSE)
[16:13:56.899]                           if (inherits(master, c("SOCKnode", 
[16:13:56.899]                             "SOCK0node"))) {
[16:13:56.899]                             sendCondition <<- function(cond) {
[16:13:56.899]                               data <- list(type = "VALUE", value = cond, 
[16:13:56.899]                                 success = TRUE)
[16:13:56.899]                               parallel_sendData(master, data)
[16:13:56.899]                             }
[16:13:56.899]                             return(sendCondition)
[16:13:56.899]                           }
[16:13:56.899]                         }
[16:13:56.899]                         frame <- frame + 1L
[16:13:56.899]                         envir <- sys.frame(frame)
[16:13:56.899]                       }
[16:13:56.899]                     }
[16:13:56.899]                     sendCondition <<- function(cond) NULL
[16:13:56.899]                   }
[16:13:56.899]                 })
[16:13:56.899]                 withCallingHandlers({
[16:13:56.899]                   {
[16:13:56.899]                     Sys.sleep(0.5)
[16:13:56.899]                     list(a = 1, b = 42L)
[16:13:56.899]                   }
[16:13:56.899]                 }, immediateCondition = function(cond) {
[16:13:56.899]                   sendCondition <- ...future.makeSendCondition()
[16:13:56.899]                   sendCondition(cond)
[16:13:56.899]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:56.899]                   {
[16:13:56.899]                     inherits <- base::inherits
[16:13:56.899]                     invokeRestart <- base::invokeRestart
[16:13:56.899]                     is.null <- base::is.null
[16:13:56.899]                     muffled <- FALSE
[16:13:56.899]                     if (inherits(cond, "message")) {
[16:13:56.899]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:56.899]                       if (muffled) 
[16:13:56.899]                         invokeRestart("muffleMessage")
[16:13:56.899]                     }
[16:13:56.899]                     else if (inherits(cond, "warning")) {
[16:13:56.899]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:56.899]                       if (muffled) 
[16:13:56.899]                         invokeRestart("muffleWarning")
[16:13:56.899]                     }
[16:13:56.899]                     else if (inherits(cond, "condition")) {
[16:13:56.899]                       if (!is.null(pattern)) {
[16:13:56.899]                         computeRestarts <- base::computeRestarts
[16:13:56.899]                         grepl <- base::grepl
[16:13:56.899]                         restarts <- computeRestarts(cond)
[16:13:56.899]                         for (restart in restarts) {
[16:13:56.899]                           name <- restart$name
[16:13:56.899]                           if (is.null(name)) 
[16:13:56.899]                             next
[16:13:56.899]                           if (!grepl(pattern, name)) 
[16:13:56.899]                             next
[16:13:56.899]                           invokeRestart(restart)
[16:13:56.899]                           muffled <- TRUE
[16:13:56.899]                           break
[16:13:56.899]                         }
[16:13:56.899]                       }
[16:13:56.899]                     }
[16:13:56.899]                     invisible(muffled)
[16:13:56.899]                   }
[16:13:56.899]                   muffleCondition(cond)
[16:13:56.899]                 })
[16:13:56.899]             }))
[16:13:56.899]             future::FutureResult(value = ...future.value$value, 
[16:13:56.899]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:56.899]                   ...future.rng), globalenv = if (FALSE) 
[16:13:56.899]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:56.899]                     ...future.globalenv.names))
[16:13:56.899]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:56.899]         }, condition = base::local({
[16:13:56.899]             c <- base::c
[16:13:56.899]             inherits <- base::inherits
[16:13:56.899]             invokeRestart <- base::invokeRestart
[16:13:56.899]             length <- base::length
[16:13:56.899]             list <- base::list
[16:13:56.899]             seq.int <- base::seq.int
[16:13:56.899]             signalCondition <- base::signalCondition
[16:13:56.899]             sys.calls <- base::sys.calls
[16:13:56.899]             `[[` <- base::`[[`
[16:13:56.899]             `+` <- base::`+`
[16:13:56.899]             `<<-` <- base::`<<-`
[16:13:56.899]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:56.899]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:56.899]                   3L)]
[16:13:56.899]             }
[16:13:56.899]             function(cond) {
[16:13:56.899]                 is_error <- inherits(cond, "error")
[16:13:56.899]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:56.899]                   NULL)
[16:13:56.899]                 if (is_error) {
[16:13:56.899]                   sessionInformation <- function() {
[16:13:56.899]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:56.899]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:56.899]                       search = base::search(), system = base::Sys.info())
[16:13:56.899]                   }
[16:13:56.899]                   ...future.conditions[[length(...future.conditions) + 
[16:13:56.899]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:56.899]                     cond$call), session = sessionInformation(), 
[16:13:56.899]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:56.899]                   signalCondition(cond)
[16:13:56.899]                 }
[16:13:56.899]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:56.899]                 "immediateCondition"))) {
[16:13:56.899]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:56.899]                   ...future.conditions[[length(...future.conditions) + 
[16:13:56.899]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:56.899]                   if (TRUE && !signal) {
[16:13:56.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:56.899]                     {
[16:13:56.899]                       inherits <- base::inherits
[16:13:56.899]                       invokeRestart <- base::invokeRestart
[16:13:56.899]                       is.null <- base::is.null
[16:13:56.899]                       muffled <- FALSE
[16:13:56.899]                       if (inherits(cond, "message")) {
[16:13:56.899]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:56.899]                         if (muffled) 
[16:13:56.899]                           invokeRestart("muffleMessage")
[16:13:56.899]                       }
[16:13:56.899]                       else if (inherits(cond, "warning")) {
[16:13:56.899]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:56.899]                         if (muffled) 
[16:13:56.899]                           invokeRestart("muffleWarning")
[16:13:56.899]                       }
[16:13:56.899]                       else if (inherits(cond, "condition")) {
[16:13:56.899]                         if (!is.null(pattern)) {
[16:13:56.899]                           computeRestarts <- base::computeRestarts
[16:13:56.899]                           grepl <- base::grepl
[16:13:56.899]                           restarts <- computeRestarts(cond)
[16:13:56.899]                           for (restart in restarts) {
[16:13:56.899]                             name <- restart$name
[16:13:56.899]                             if (is.null(name)) 
[16:13:56.899]                               next
[16:13:56.899]                             if (!grepl(pattern, name)) 
[16:13:56.899]                               next
[16:13:56.899]                             invokeRestart(restart)
[16:13:56.899]                             muffled <- TRUE
[16:13:56.899]                             break
[16:13:56.899]                           }
[16:13:56.899]                         }
[16:13:56.899]                       }
[16:13:56.899]                       invisible(muffled)
[16:13:56.899]                     }
[16:13:56.899]                     muffleCondition(cond, pattern = "^muffle")
[16:13:56.899]                   }
[16:13:56.899]                 }
[16:13:56.899]                 else {
[16:13:56.899]                   if (TRUE) {
[16:13:56.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:56.899]                     {
[16:13:56.899]                       inherits <- base::inherits
[16:13:56.899]                       invokeRestart <- base::invokeRestart
[16:13:56.899]                       is.null <- base::is.null
[16:13:56.899]                       muffled <- FALSE
[16:13:56.899]                       if (inherits(cond, "message")) {
[16:13:56.899]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:56.899]                         if (muffled) 
[16:13:56.899]                           invokeRestart("muffleMessage")
[16:13:56.899]                       }
[16:13:56.899]                       else if (inherits(cond, "warning")) {
[16:13:56.899]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:56.899]                         if (muffled) 
[16:13:56.899]                           invokeRestart("muffleWarning")
[16:13:56.899]                       }
[16:13:56.899]                       else if (inherits(cond, "condition")) {
[16:13:56.899]                         if (!is.null(pattern)) {
[16:13:56.899]                           computeRestarts <- base::computeRestarts
[16:13:56.899]                           grepl <- base::grepl
[16:13:56.899]                           restarts <- computeRestarts(cond)
[16:13:56.899]                           for (restart in restarts) {
[16:13:56.899]                             name <- restart$name
[16:13:56.899]                             if (is.null(name)) 
[16:13:56.899]                               next
[16:13:56.899]                             if (!grepl(pattern, name)) 
[16:13:56.899]                               next
[16:13:56.899]                             invokeRestart(restart)
[16:13:56.899]                             muffled <- TRUE
[16:13:56.899]                             break
[16:13:56.899]                           }
[16:13:56.899]                         }
[16:13:56.899]                       }
[16:13:56.899]                       invisible(muffled)
[16:13:56.899]                     }
[16:13:56.899]                     muffleCondition(cond, pattern = "^muffle")
[16:13:56.899]                   }
[16:13:56.899]                 }
[16:13:56.899]             }
[16:13:56.899]         }))
[16:13:56.899]     }, error = function(ex) {
[16:13:56.899]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:56.899]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:56.899]                 ...future.rng), started = ...future.startTime, 
[16:13:56.899]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:56.899]             version = "1.8"), class = "FutureResult")
[16:13:56.899]     }, finally = {
[16:13:56.899]         if (!identical(...future.workdir, getwd())) 
[16:13:56.899]             setwd(...future.workdir)
[16:13:56.899]         {
[16:13:56.899]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:56.899]                 ...future.oldOptions$nwarnings <- NULL
[16:13:56.899]             }
[16:13:56.899]             base::options(...future.oldOptions)
[16:13:56.899]             if (.Platform$OS.type == "windows") {
[16:13:56.899]                 old_names <- names(...future.oldEnvVars)
[16:13:56.899]                 envs <- base::Sys.getenv()
[16:13:56.899]                 names <- names(envs)
[16:13:56.899]                 common <- intersect(names, old_names)
[16:13:56.899]                 added <- setdiff(names, old_names)
[16:13:56.899]                 removed <- setdiff(old_names, names)
[16:13:56.899]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:56.899]                   envs[common]]
[16:13:56.899]                 NAMES <- toupper(changed)
[16:13:56.899]                 args <- list()
[16:13:56.899]                 for (kk in seq_along(NAMES)) {
[16:13:56.899]                   name <- changed[[kk]]
[16:13:56.899]                   NAME <- NAMES[[kk]]
[16:13:56.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:56.899]                     next
[16:13:56.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:56.899]                 }
[16:13:56.899]                 NAMES <- toupper(added)
[16:13:56.899]                 for (kk in seq_along(NAMES)) {
[16:13:56.899]                   name <- added[[kk]]
[16:13:56.899]                   NAME <- NAMES[[kk]]
[16:13:56.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:56.899]                     next
[16:13:56.899]                   args[[name]] <- ""
[16:13:56.899]                 }
[16:13:56.899]                 NAMES <- toupper(removed)
[16:13:56.899]                 for (kk in seq_along(NAMES)) {
[16:13:56.899]                   name <- removed[[kk]]
[16:13:56.899]                   NAME <- NAMES[[kk]]
[16:13:56.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:56.899]                     next
[16:13:56.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:56.899]                 }
[16:13:56.899]                 if (length(args) > 0) 
[16:13:56.899]                   base::do.call(base::Sys.setenv, args = args)
[16:13:56.899]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:56.899]             }
[16:13:56.899]             else {
[16:13:56.899]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:56.899]             }
[16:13:56.899]             {
[16:13:56.899]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:56.899]                   0L) {
[16:13:56.899]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:56.899]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:56.899]                   base::options(opts)
[16:13:56.899]                 }
[16:13:56.899]                 {
[16:13:56.899]                   {
[16:13:56.899]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:56.899]                     NULL
[16:13:56.899]                   }
[16:13:56.899]                   options(future.plan = NULL)
[16:13:56.899]                   if (is.na(NA_character_)) 
[16:13:56.899]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:56.899]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:56.899]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:56.899]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:56.899]                     envir = parent.frame()) 
[16:13:56.899]                   {
[16:13:56.899]                     if (is.function(workers)) 
[16:13:56.899]                       workers <- workers()
[16:13:56.899]                     workers <- structure(as.integer(workers), 
[16:13:56.899]                       class = class(workers))
[16:13:56.899]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:56.899]                       workers >= 1)
[16:13:56.899]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:56.899]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:56.899]                     }
[16:13:56.899]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:56.899]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:56.899]                       envir = envir)
[16:13:56.899]                     if (!future$lazy) 
[16:13:56.899]                       future <- run(future)
[16:13:56.899]                     invisible(future)
[16:13:56.899]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:56.899]                 }
[16:13:56.899]             }
[16:13:56.899]         }
[16:13:56.899]     })
[16:13:56.899]     if (TRUE) {
[16:13:56.899]         base::sink(type = "output", split = FALSE)
[16:13:56.899]         if (TRUE) {
[16:13:56.899]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:56.899]         }
[16:13:56.899]         else {
[16:13:56.899]             ...future.result["stdout"] <- base::list(NULL)
[16:13:56.899]         }
[16:13:56.899]         base::close(...future.stdout)
[16:13:56.899]         ...future.stdout <- NULL
[16:13:56.899]     }
[16:13:56.899]     ...future.result$conditions <- ...future.conditions
[16:13:56.899]     ...future.result$finished <- base::Sys.time()
[16:13:56.899]     ...future.result
[16:13:56.899] }
[16:13:56.902] MultisessionFuture started
[16:13:56.902] - Launch lazy future ... done
[16:13:56.902] run() for ‘MultisessionFuture’ ... done
[16:13:57.460] receiveMessageFromWorker() for ClusterFuture ...
[16:13:57.460] - Validating connection of MultisessionFuture
[16:13:57.460] - received message: FutureResult
[16:13:57.460] - Received FutureResult
[16:13:57.461] - Erased future from FutureRegistry
[16:13:57.461] result() for ClusterFuture ...
[16:13:57.461] - result already collected: FutureResult
[16:13:57.461] result() for ClusterFuture ... done
[16:13:57.461] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:57.461] resolve() on list ...
[16:13:57.461]  recursive: 1
[16:13:57.461]  length: 2
[16:13:57.461]  elements: ‘a’, ‘b’
[16:13:57.462]  length: 1 (resolved future 1)
[16:13:57.462]  length: 0 (resolved future 2)
[16:13:57.462] resolve() on list ... DONE
[16:13:57.462] A MultisessionFuture was resolved (and resolved itself)
[16:13:57.462] getGlobalsAndPackages() ...
[16:13:57.462] Searching for globals...
[16:13:57.463] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:57.463] Searching for globals ... DONE
[16:13:57.463] Resolving globals: FALSE
[16:13:57.464] 
[16:13:57.464] 
[16:13:57.464] getGlobalsAndPackages() ... DONE
[16:13:57.464] run() for ‘Future’ ...
[16:13:57.464] - state: ‘created’
[16:13:57.464] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:57.478] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:57.479] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:57.479]   - Field: ‘node’
[16:13:57.479]   - Field: ‘label’
[16:13:57.479]   - Field: ‘local’
[16:13:57.479]   - Field: ‘owner’
[16:13:57.479]   - Field: ‘envir’
[16:13:57.479]   - Field: ‘workers’
[16:13:57.479]   - Field: ‘packages’
[16:13:57.479]   - Field: ‘gc’
[16:13:57.479]   - Field: ‘conditions’
[16:13:57.480]   - Field: ‘persistent’
[16:13:57.480]   - Field: ‘expr’
[16:13:57.480]   - Field: ‘uuid’
[16:13:57.480]   - Field: ‘seed’
[16:13:57.480]   - Field: ‘version’
[16:13:57.480]   - Field: ‘result’
[16:13:57.480]   - Field: ‘asynchronous’
[16:13:57.480]   - Field: ‘calls’
[16:13:57.480]   - Field: ‘globals’
[16:13:57.480]   - Field: ‘stdout’
[16:13:57.481]   - Field: ‘earlySignal’
[16:13:57.481]   - Field: ‘lazy’
[16:13:57.481]   - Field: ‘state’
[16:13:57.481] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:57.481] - Launch lazy future ...
[16:13:57.481] Packages needed by the future expression (n = 0): <none>
[16:13:57.481] Packages needed by future strategies (n = 0): <none>
[16:13:57.482] {
[16:13:57.482]     {
[16:13:57.482]         {
[16:13:57.482]             ...future.startTime <- base::Sys.time()
[16:13:57.482]             {
[16:13:57.482]                 {
[16:13:57.482]                   {
[16:13:57.482]                     {
[16:13:57.482]                       base::local({
[16:13:57.482]                         has_future <- base::requireNamespace("future", 
[16:13:57.482]                           quietly = TRUE)
[16:13:57.482]                         if (has_future) {
[16:13:57.482]                           ns <- base::getNamespace("future")
[16:13:57.482]                           version <- ns[[".package"]][["version"]]
[16:13:57.482]                           if (is.null(version)) 
[16:13:57.482]                             version <- utils::packageVersion("future")
[16:13:57.482]                         }
[16:13:57.482]                         else {
[16:13:57.482]                           version <- NULL
[16:13:57.482]                         }
[16:13:57.482]                         if (!has_future || version < "1.8.0") {
[16:13:57.482]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:57.482]                             "", base::R.version$version.string), 
[16:13:57.482]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:57.482]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:57.482]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:57.482]                               "release", "version")], collapse = " "), 
[16:13:57.482]                             hostname = base::Sys.info()[["nodename"]])
[16:13:57.482]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:57.482]                             info)
[16:13:57.482]                           info <- base::paste(info, collapse = "; ")
[16:13:57.482]                           if (!has_future) {
[16:13:57.482]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:57.482]                               info)
[16:13:57.482]                           }
[16:13:57.482]                           else {
[16:13:57.482]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:57.482]                               info, version)
[16:13:57.482]                           }
[16:13:57.482]                           base::stop(msg)
[16:13:57.482]                         }
[16:13:57.482]                       })
[16:13:57.482]                     }
[16:13:57.482]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:57.482]                     base::options(mc.cores = 1L)
[16:13:57.482]                   }
[16:13:57.482]                   options(future.plan = NULL)
[16:13:57.482]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:57.482]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:57.482]                 }
[16:13:57.482]                 ...future.workdir <- getwd()
[16:13:57.482]             }
[16:13:57.482]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:57.482]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:57.482]         }
[16:13:57.482]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:57.482]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:57.482]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:57.482]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:57.482]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:57.482]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:57.482]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:57.482]             base::names(...future.oldOptions))
[16:13:57.482]     }
[16:13:57.482]     if (FALSE) {
[16:13:57.482]     }
[16:13:57.482]     else {
[16:13:57.482]         if (TRUE) {
[16:13:57.482]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:57.482]                 open = "w")
[16:13:57.482]         }
[16:13:57.482]         else {
[16:13:57.482]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:57.482]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:57.482]         }
[16:13:57.482]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:57.482]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:57.482]             base::sink(type = "output", split = FALSE)
[16:13:57.482]             base::close(...future.stdout)
[16:13:57.482]         }, add = TRUE)
[16:13:57.482]     }
[16:13:57.482]     ...future.frame <- base::sys.nframe()
[16:13:57.482]     ...future.conditions <- base::list()
[16:13:57.482]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:57.482]     if (FALSE) {
[16:13:57.482]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:57.482]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:57.482]     }
[16:13:57.482]     ...future.result <- base::tryCatch({
[16:13:57.482]         base::withCallingHandlers({
[16:13:57.482]             ...future.value <- base::withVisible(base::local({
[16:13:57.482]                 ...future.makeSendCondition <- local({
[16:13:57.482]                   sendCondition <- NULL
[16:13:57.482]                   function(frame = 1L) {
[16:13:57.482]                     if (is.function(sendCondition)) 
[16:13:57.482]                       return(sendCondition)
[16:13:57.482]                     ns <- getNamespace("parallel")
[16:13:57.482]                     if (exists("sendData", mode = "function", 
[16:13:57.482]                       envir = ns)) {
[16:13:57.482]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:57.482]                         envir = ns)
[16:13:57.482]                       envir <- sys.frame(frame)
[16:13:57.482]                       master <- NULL
[16:13:57.482]                       while (!identical(envir, .GlobalEnv) && 
[16:13:57.482]                         !identical(envir, emptyenv())) {
[16:13:57.482]                         if (exists("master", mode = "list", envir = envir, 
[16:13:57.482]                           inherits = FALSE)) {
[16:13:57.482]                           master <- get("master", mode = "list", 
[16:13:57.482]                             envir = envir, inherits = FALSE)
[16:13:57.482]                           if (inherits(master, c("SOCKnode", 
[16:13:57.482]                             "SOCK0node"))) {
[16:13:57.482]                             sendCondition <<- function(cond) {
[16:13:57.482]                               data <- list(type = "VALUE", value = cond, 
[16:13:57.482]                                 success = TRUE)
[16:13:57.482]                               parallel_sendData(master, data)
[16:13:57.482]                             }
[16:13:57.482]                             return(sendCondition)
[16:13:57.482]                           }
[16:13:57.482]                         }
[16:13:57.482]                         frame <- frame + 1L
[16:13:57.482]                         envir <- sys.frame(frame)
[16:13:57.482]                       }
[16:13:57.482]                     }
[16:13:57.482]                     sendCondition <<- function(cond) NULL
[16:13:57.482]                   }
[16:13:57.482]                 })
[16:13:57.482]                 withCallingHandlers({
[16:13:57.482]                   {
[16:13:57.482]                     Sys.sleep(0.5)
[16:13:57.482]                     list(a = 1, b = 42L)
[16:13:57.482]                   }
[16:13:57.482]                 }, immediateCondition = function(cond) {
[16:13:57.482]                   sendCondition <- ...future.makeSendCondition()
[16:13:57.482]                   sendCondition(cond)
[16:13:57.482]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:57.482]                   {
[16:13:57.482]                     inherits <- base::inherits
[16:13:57.482]                     invokeRestart <- base::invokeRestart
[16:13:57.482]                     is.null <- base::is.null
[16:13:57.482]                     muffled <- FALSE
[16:13:57.482]                     if (inherits(cond, "message")) {
[16:13:57.482]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:57.482]                       if (muffled) 
[16:13:57.482]                         invokeRestart("muffleMessage")
[16:13:57.482]                     }
[16:13:57.482]                     else if (inherits(cond, "warning")) {
[16:13:57.482]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:57.482]                       if (muffled) 
[16:13:57.482]                         invokeRestart("muffleWarning")
[16:13:57.482]                     }
[16:13:57.482]                     else if (inherits(cond, "condition")) {
[16:13:57.482]                       if (!is.null(pattern)) {
[16:13:57.482]                         computeRestarts <- base::computeRestarts
[16:13:57.482]                         grepl <- base::grepl
[16:13:57.482]                         restarts <- computeRestarts(cond)
[16:13:57.482]                         for (restart in restarts) {
[16:13:57.482]                           name <- restart$name
[16:13:57.482]                           if (is.null(name)) 
[16:13:57.482]                             next
[16:13:57.482]                           if (!grepl(pattern, name)) 
[16:13:57.482]                             next
[16:13:57.482]                           invokeRestart(restart)
[16:13:57.482]                           muffled <- TRUE
[16:13:57.482]                           break
[16:13:57.482]                         }
[16:13:57.482]                       }
[16:13:57.482]                     }
[16:13:57.482]                     invisible(muffled)
[16:13:57.482]                   }
[16:13:57.482]                   muffleCondition(cond)
[16:13:57.482]                 })
[16:13:57.482]             }))
[16:13:57.482]             future::FutureResult(value = ...future.value$value, 
[16:13:57.482]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:57.482]                   ...future.rng), globalenv = if (FALSE) 
[16:13:57.482]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:57.482]                     ...future.globalenv.names))
[16:13:57.482]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:57.482]         }, condition = base::local({
[16:13:57.482]             c <- base::c
[16:13:57.482]             inherits <- base::inherits
[16:13:57.482]             invokeRestart <- base::invokeRestart
[16:13:57.482]             length <- base::length
[16:13:57.482]             list <- base::list
[16:13:57.482]             seq.int <- base::seq.int
[16:13:57.482]             signalCondition <- base::signalCondition
[16:13:57.482]             sys.calls <- base::sys.calls
[16:13:57.482]             `[[` <- base::`[[`
[16:13:57.482]             `+` <- base::`+`
[16:13:57.482]             `<<-` <- base::`<<-`
[16:13:57.482]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:57.482]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:57.482]                   3L)]
[16:13:57.482]             }
[16:13:57.482]             function(cond) {
[16:13:57.482]                 is_error <- inherits(cond, "error")
[16:13:57.482]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:57.482]                   NULL)
[16:13:57.482]                 if (is_error) {
[16:13:57.482]                   sessionInformation <- function() {
[16:13:57.482]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:57.482]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:57.482]                       search = base::search(), system = base::Sys.info())
[16:13:57.482]                   }
[16:13:57.482]                   ...future.conditions[[length(...future.conditions) + 
[16:13:57.482]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:57.482]                     cond$call), session = sessionInformation(), 
[16:13:57.482]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:57.482]                   signalCondition(cond)
[16:13:57.482]                 }
[16:13:57.482]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:57.482]                 "immediateCondition"))) {
[16:13:57.482]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:57.482]                   ...future.conditions[[length(...future.conditions) + 
[16:13:57.482]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:57.482]                   if (TRUE && !signal) {
[16:13:57.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:57.482]                     {
[16:13:57.482]                       inherits <- base::inherits
[16:13:57.482]                       invokeRestart <- base::invokeRestart
[16:13:57.482]                       is.null <- base::is.null
[16:13:57.482]                       muffled <- FALSE
[16:13:57.482]                       if (inherits(cond, "message")) {
[16:13:57.482]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:57.482]                         if (muffled) 
[16:13:57.482]                           invokeRestart("muffleMessage")
[16:13:57.482]                       }
[16:13:57.482]                       else if (inherits(cond, "warning")) {
[16:13:57.482]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:57.482]                         if (muffled) 
[16:13:57.482]                           invokeRestart("muffleWarning")
[16:13:57.482]                       }
[16:13:57.482]                       else if (inherits(cond, "condition")) {
[16:13:57.482]                         if (!is.null(pattern)) {
[16:13:57.482]                           computeRestarts <- base::computeRestarts
[16:13:57.482]                           grepl <- base::grepl
[16:13:57.482]                           restarts <- computeRestarts(cond)
[16:13:57.482]                           for (restart in restarts) {
[16:13:57.482]                             name <- restart$name
[16:13:57.482]                             if (is.null(name)) 
[16:13:57.482]                               next
[16:13:57.482]                             if (!grepl(pattern, name)) 
[16:13:57.482]                               next
[16:13:57.482]                             invokeRestart(restart)
[16:13:57.482]                             muffled <- TRUE
[16:13:57.482]                             break
[16:13:57.482]                           }
[16:13:57.482]                         }
[16:13:57.482]                       }
[16:13:57.482]                       invisible(muffled)
[16:13:57.482]                     }
[16:13:57.482]                     muffleCondition(cond, pattern = "^muffle")
[16:13:57.482]                   }
[16:13:57.482]                 }
[16:13:57.482]                 else {
[16:13:57.482]                   if (TRUE) {
[16:13:57.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:57.482]                     {
[16:13:57.482]                       inherits <- base::inherits
[16:13:57.482]                       invokeRestart <- base::invokeRestart
[16:13:57.482]                       is.null <- base::is.null
[16:13:57.482]                       muffled <- FALSE
[16:13:57.482]                       if (inherits(cond, "message")) {
[16:13:57.482]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:57.482]                         if (muffled) 
[16:13:57.482]                           invokeRestart("muffleMessage")
[16:13:57.482]                       }
[16:13:57.482]                       else if (inherits(cond, "warning")) {
[16:13:57.482]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:57.482]                         if (muffled) 
[16:13:57.482]                           invokeRestart("muffleWarning")
[16:13:57.482]                       }
[16:13:57.482]                       else if (inherits(cond, "condition")) {
[16:13:57.482]                         if (!is.null(pattern)) {
[16:13:57.482]                           computeRestarts <- base::computeRestarts
[16:13:57.482]                           grepl <- base::grepl
[16:13:57.482]                           restarts <- computeRestarts(cond)
[16:13:57.482]                           for (restart in restarts) {
[16:13:57.482]                             name <- restart$name
[16:13:57.482]                             if (is.null(name)) 
[16:13:57.482]                               next
[16:13:57.482]                             if (!grepl(pattern, name)) 
[16:13:57.482]                               next
[16:13:57.482]                             invokeRestart(restart)
[16:13:57.482]                             muffled <- TRUE
[16:13:57.482]                             break
[16:13:57.482]                           }
[16:13:57.482]                         }
[16:13:57.482]                       }
[16:13:57.482]                       invisible(muffled)
[16:13:57.482]                     }
[16:13:57.482]                     muffleCondition(cond, pattern = "^muffle")
[16:13:57.482]                   }
[16:13:57.482]                 }
[16:13:57.482]             }
[16:13:57.482]         }))
[16:13:57.482]     }, error = function(ex) {
[16:13:57.482]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:57.482]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:57.482]                 ...future.rng), started = ...future.startTime, 
[16:13:57.482]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:57.482]             version = "1.8"), class = "FutureResult")
[16:13:57.482]     }, finally = {
[16:13:57.482]         if (!identical(...future.workdir, getwd())) 
[16:13:57.482]             setwd(...future.workdir)
[16:13:57.482]         {
[16:13:57.482]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:57.482]                 ...future.oldOptions$nwarnings <- NULL
[16:13:57.482]             }
[16:13:57.482]             base::options(...future.oldOptions)
[16:13:57.482]             if (.Platform$OS.type == "windows") {
[16:13:57.482]                 old_names <- names(...future.oldEnvVars)
[16:13:57.482]                 envs <- base::Sys.getenv()
[16:13:57.482]                 names <- names(envs)
[16:13:57.482]                 common <- intersect(names, old_names)
[16:13:57.482]                 added <- setdiff(names, old_names)
[16:13:57.482]                 removed <- setdiff(old_names, names)
[16:13:57.482]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:57.482]                   envs[common]]
[16:13:57.482]                 NAMES <- toupper(changed)
[16:13:57.482]                 args <- list()
[16:13:57.482]                 for (kk in seq_along(NAMES)) {
[16:13:57.482]                   name <- changed[[kk]]
[16:13:57.482]                   NAME <- NAMES[[kk]]
[16:13:57.482]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:57.482]                     next
[16:13:57.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:57.482]                 }
[16:13:57.482]                 NAMES <- toupper(added)
[16:13:57.482]                 for (kk in seq_along(NAMES)) {
[16:13:57.482]                   name <- added[[kk]]
[16:13:57.482]                   NAME <- NAMES[[kk]]
[16:13:57.482]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:57.482]                     next
[16:13:57.482]                   args[[name]] <- ""
[16:13:57.482]                 }
[16:13:57.482]                 NAMES <- toupper(removed)
[16:13:57.482]                 for (kk in seq_along(NAMES)) {
[16:13:57.482]                   name <- removed[[kk]]
[16:13:57.482]                   NAME <- NAMES[[kk]]
[16:13:57.482]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:57.482]                     next
[16:13:57.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:57.482]                 }
[16:13:57.482]                 if (length(args) > 0) 
[16:13:57.482]                   base::do.call(base::Sys.setenv, args = args)
[16:13:57.482]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:57.482]             }
[16:13:57.482]             else {
[16:13:57.482]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:57.482]             }
[16:13:57.482]             {
[16:13:57.482]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:57.482]                   0L) {
[16:13:57.482]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:57.482]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:57.482]                   base::options(opts)
[16:13:57.482]                 }
[16:13:57.482]                 {
[16:13:57.482]                   {
[16:13:57.482]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:57.482]                     NULL
[16:13:57.482]                   }
[16:13:57.482]                   options(future.plan = NULL)
[16:13:57.482]                   if (is.na(NA_character_)) 
[16:13:57.482]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:57.482]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:57.482]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:57.482]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:57.482]                     envir = parent.frame()) 
[16:13:57.482]                   {
[16:13:57.482]                     if (is.function(workers)) 
[16:13:57.482]                       workers <- workers()
[16:13:57.482]                     workers <- structure(as.integer(workers), 
[16:13:57.482]                       class = class(workers))
[16:13:57.482]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:57.482]                       workers >= 1)
[16:13:57.482]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:57.482]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:57.482]                     }
[16:13:57.482]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:57.482]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:57.482]                       envir = envir)
[16:13:57.482]                     if (!future$lazy) 
[16:13:57.482]                       future <- run(future)
[16:13:57.482]                     invisible(future)
[16:13:57.482]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:57.482]                 }
[16:13:57.482]             }
[16:13:57.482]         }
[16:13:57.482]     })
[16:13:57.482]     if (TRUE) {
[16:13:57.482]         base::sink(type = "output", split = FALSE)
[16:13:57.482]         if (TRUE) {
[16:13:57.482]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:57.482]         }
[16:13:57.482]         else {
[16:13:57.482]             ...future.result["stdout"] <- base::list(NULL)
[16:13:57.482]         }
[16:13:57.482]         base::close(...future.stdout)
[16:13:57.482]         ...future.stdout <- NULL
[16:13:57.482]     }
[16:13:57.482]     ...future.result$conditions <- ...future.conditions
[16:13:57.482]     ...future.result$finished <- base::Sys.time()
[16:13:57.482]     ...future.result
[16:13:57.482] }
[16:13:57.487] MultisessionFuture started
[16:13:57.487] - Launch lazy future ... done
[16:13:57.487] run() for ‘MultisessionFuture’ ... done
[16:13:58.034] receiveMessageFromWorker() for ClusterFuture ...
[16:13:58.034] - Validating connection of MultisessionFuture
[16:13:58.034] - received message: FutureResult
[16:13:58.034] - Received FutureResult
[16:13:58.034] - Erased future from FutureRegistry
[16:13:58.035] result() for ClusterFuture ...
[16:13:58.035] - result already collected: FutureResult
[16:13:58.035] result() for ClusterFuture ... done
[16:13:58.035] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:58.035] resolve() on list ...
[16:13:58.035]  recursive: 1
[16:13:58.035]  length: 2
[16:13:58.035]  elements: ‘a’, ‘b’
[16:13:58.035]  length: 1 (resolved future 1)
[16:13:58.036]  length: 0 (resolved future 2)
[16:13:58.036] resolve() on list ... DONE
[16:13:58.036] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[16:13:58.036] getGlobalsAndPackages() ...
[16:13:58.036] Searching for globals...
[16:13:58.037] - globals found: [2] ‘list’, ‘stop’
[16:13:58.037] Searching for globals ... DONE
[16:13:58.037] Resolving globals: FALSE
[16:13:58.037] 
[16:13:58.037] 
[16:13:58.037] getGlobalsAndPackages() ... DONE
[16:13:58.038] run() for ‘Future’ ...
[16:13:58.038] - state: ‘created’
[16:13:58.038] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:58.052] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:58.053] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:58.053]   - Field: ‘node’
[16:13:58.053]   - Field: ‘label’
[16:13:58.053]   - Field: ‘local’
[16:13:58.053]   - Field: ‘owner’
[16:13:58.053]   - Field: ‘envir’
[16:13:58.053]   - Field: ‘workers’
[16:13:58.053]   - Field: ‘packages’
[16:13:58.053]   - Field: ‘gc’
[16:13:58.053]   - Field: ‘conditions’
[16:13:58.054]   - Field: ‘persistent’
[16:13:58.054]   - Field: ‘expr’
[16:13:58.054]   - Field: ‘uuid’
[16:13:58.054]   - Field: ‘seed’
[16:13:58.054]   - Field: ‘version’
[16:13:58.054]   - Field: ‘result’
[16:13:58.054]   - Field: ‘asynchronous’
[16:13:58.054]   - Field: ‘calls’
[16:13:58.054]   - Field: ‘globals’
[16:13:58.054]   - Field: ‘stdout’
[16:13:58.054]   - Field: ‘earlySignal’
[16:13:58.055]   - Field: ‘lazy’
[16:13:58.055]   - Field: ‘state’
[16:13:58.055] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:58.055] - Launch lazy future ...
[16:13:58.055] Packages needed by the future expression (n = 0): <none>
[16:13:58.055] Packages needed by future strategies (n = 0): <none>
[16:13:58.056] {
[16:13:58.056]     {
[16:13:58.056]         {
[16:13:58.056]             ...future.startTime <- base::Sys.time()
[16:13:58.056]             {
[16:13:58.056]                 {
[16:13:58.056]                   {
[16:13:58.056]                     {
[16:13:58.056]                       base::local({
[16:13:58.056]                         has_future <- base::requireNamespace("future", 
[16:13:58.056]                           quietly = TRUE)
[16:13:58.056]                         if (has_future) {
[16:13:58.056]                           ns <- base::getNamespace("future")
[16:13:58.056]                           version <- ns[[".package"]][["version"]]
[16:13:58.056]                           if (is.null(version)) 
[16:13:58.056]                             version <- utils::packageVersion("future")
[16:13:58.056]                         }
[16:13:58.056]                         else {
[16:13:58.056]                           version <- NULL
[16:13:58.056]                         }
[16:13:58.056]                         if (!has_future || version < "1.8.0") {
[16:13:58.056]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:58.056]                             "", base::R.version$version.string), 
[16:13:58.056]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:58.056]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:58.056]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:58.056]                               "release", "version")], collapse = " "), 
[16:13:58.056]                             hostname = base::Sys.info()[["nodename"]])
[16:13:58.056]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:58.056]                             info)
[16:13:58.056]                           info <- base::paste(info, collapse = "; ")
[16:13:58.056]                           if (!has_future) {
[16:13:58.056]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:58.056]                               info)
[16:13:58.056]                           }
[16:13:58.056]                           else {
[16:13:58.056]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:58.056]                               info, version)
[16:13:58.056]                           }
[16:13:58.056]                           base::stop(msg)
[16:13:58.056]                         }
[16:13:58.056]                       })
[16:13:58.056]                     }
[16:13:58.056]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:58.056]                     base::options(mc.cores = 1L)
[16:13:58.056]                   }
[16:13:58.056]                   options(future.plan = NULL)
[16:13:58.056]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:58.056]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:58.056]                 }
[16:13:58.056]                 ...future.workdir <- getwd()
[16:13:58.056]             }
[16:13:58.056]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:58.056]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:58.056]         }
[16:13:58.056]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:58.056]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:58.056]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:58.056]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:58.056]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:58.056]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:58.056]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:58.056]             base::names(...future.oldOptions))
[16:13:58.056]     }
[16:13:58.056]     if (FALSE) {
[16:13:58.056]     }
[16:13:58.056]     else {
[16:13:58.056]         if (TRUE) {
[16:13:58.056]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:58.056]                 open = "w")
[16:13:58.056]         }
[16:13:58.056]         else {
[16:13:58.056]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:58.056]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:58.056]         }
[16:13:58.056]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:58.056]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:58.056]             base::sink(type = "output", split = FALSE)
[16:13:58.056]             base::close(...future.stdout)
[16:13:58.056]         }, add = TRUE)
[16:13:58.056]     }
[16:13:58.056]     ...future.frame <- base::sys.nframe()
[16:13:58.056]     ...future.conditions <- base::list()
[16:13:58.056]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:58.056]     if (FALSE) {
[16:13:58.056]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:58.056]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:58.056]     }
[16:13:58.056]     ...future.result <- base::tryCatch({
[16:13:58.056]         base::withCallingHandlers({
[16:13:58.056]             ...future.value <- base::withVisible(base::local({
[16:13:58.056]                 ...future.makeSendCondition <- local({
[16:13:58.056]                   sendCondition <- NULL
[16:13:58.056]                   function(frame = 1L) {
[16:13:58.056]                     if (is.function(sendCondition)) 
[16:13:58.056]                       return(sendCondition)
[16:13:58.056]                     ns <- getNamespace("parallel")
[16:13:58.056]                     if (exists("sendData", mode = "function", 
[16:13:58.056]                       envir = ns)) {
[16:13:58.056]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:58.056]                         envir = ns)
[16:13:58.056]                       envir <- sys.frame(frame)
[16:13:58.056]                       master <- NULL
[16:13:58.056]                       while (!identical(envir, .GlobalEnv) && 
[16:13:58.056]                         !identical(envir, emptyenv())) {
[16:13:58.056]                         if (exists("master", mode = "list", envir = envir, 
[16:13:58.056]                           inherits = FALSE)) {
[16:13:58.056]                           master <- get("master", mode = "list", 
[16:13:58.056]                             envir = envir, inherits = FALSE)
[16:13:58.056]                           if (inherits(master, c("SOCKnode", 
[16:13:58.056]                             "SOCK0node"))) {
[16:13:58.056]                             sendCondition <<- function(cond) {
[16:13:58.056]                               data <- list(type = "VALUE", value = cond, 
[16:13:58.056]                                 success = TRUE)
[16:13:58.056]                               parallel_sendData(master, data)
[16:13:58.056]                             }
[16:13:58.056]                             return(sendCondition)
[16:13:58.056]                           }
[16:13:58.056]                         }
[16:13:58.056]                         frame <- frame + 1L
[16:13:58.056]                         envir <- sys.frame(frame)
[16:13:58.056]                       }
[16:13:58.056]                     }
[16:13:58.056]                     sendCondition <<- function(cond) NULL
[16:13:58.056]                   }
[16:13:58.056]                 })
[16:13:58.056]                 withCallingHandlers({
[16:13:58.056]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:58.056]                 }, immediateCondition = function(cond) {
[16:13:58.056]                   sendCondition <- ...future.makeSendCondition()
[16:13:58.056]                   sendCondition(cond)
[16:13:58.056]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:58.056]                   {
[16:13:58.056]                     inherits <- base::inherits
[16:13:58.056]                     invokeRestart <- base::invokeRestart
[16:13:58.056]                     is.null <- base::is.null
[16:13:58.056]                     muffled <- FALSE
[16:13:58.056]                     if (inherits(cond, "message")) {
[16:13:58.056]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:58.056]                       if (muffled) 
[16:13:58.056]                         invokeRestart("muffleMessage")
[16:13:58.056]                     }
[16:13:58.056]                     else if (inherits(cond, "warning")) {
[16:13:58.056]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:58.056]                       if (muffled) 
[16:13:58.056]                         invokeRestart("muffleWarning")
[16:13:58.056]                     }
[16:13:58.056]                     else if (inherits(cond, "condition")) {
[16:13:58.056]                       if (!is.null(pattern)) {
[16:13:58.056]                         computeRestarts <- base::computeRestarts
[16:13:58.056]                         grepl <- base::grepl
[16:13:58.056]                         restarts <- computeRestarts(cond)
[16:13:58.056]                         for (restart in restarts) {
[16:13:58.056]                           name <- restart$name
[16:13:58.056]                           if (is.null(name)) 
[16:13:58.056]                             next
[16:13:58.056]                           if (!grepl(pattern, name)) 
[16:13:58.056]                             next
[16:13:58.056]                           invokeRestart(restart)
[16:13:58.056]                           muffled <- TRUE
[16:13:58.056]                           break
[16:13:58.056]                         }
[16:13:58.056]                       }
[16:13:58.056]                     }
[16:13:58.056]                     invisible(muffled)
[16:13:58.056]                   }
[16:13:58.056]                   muffleCondition(cond)
[16:13:58.056]                 })
[16:13:58.056]             }))
[16:13:58.056]             future::FutureResult(value = ...future.value$value, 
[16:13:58.056]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:58.056]                   ...future.rng), globalenv = if (FALSE) 
[16:13:58.056]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:58.056]                     ...future.globalenv.names))
[16:13:58.056]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:58.056]         }, condition = base::local({
[16:13:58.056]             c <- base::c
[16:13:58.056]             inherits <- base::inherits
[16:13:58.056]             invokeRestart <- base::invokeRestart
[16:13:58.056]             length <- base::length
[16:13:58.056]             list <- base::list
[16:13:58.056]             seq.int <- base::seq.int
[16:13:58.056]             signalCondition <- base::signalCondition
[16:13:58.056]             sys.calls <- base::sys.calls
[16:13:58.056]             `[[` <- base::`[[`
[16:13:58.056]             `+` <- base::`+`
[16:13:58.056]             `<<-` <- base::`<<-`
[16:13:58.056]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:58.056]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:58.056]                   3L)]
[16:13:58.056]             }
[16:13:58.056]             function(cond) {
[16:13:58.056]                 is_error <- inherits(cond, "error")
[16:13:58.056]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:58.056]                   NULL)
[16:13:58.056]                 if (is_error) {
[16:13:58.056]                   sessionInformation <- function() {
[16:13:58.056]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:58.056]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:58.056]                       search = base::search(), system = base::Sys.info())
[16:13:58.056]                   }
[16:13:58.056]                   ...future.conditions[[length(...future.conditions) + 
[16:13:58.056]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:58.056]                     cond$call), session = sessionInformation(), 
[16:13:58.056]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:58.056]                   signalCondition(cond)
[16:13:58.056]                 }
[16:13:58.056]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:58.056]                 "immediateCondition"))) {
[16:13:58.056]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:58.056]                   ...future.conditions[[length(...future.conditions) + 
[16:13:58.056]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:58.056]                   if (TRUE && !signal) {
[16:13:58.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:58.056]                     {
[16:13:58.056]                       inherits <- base::inherits
[16:13:58.056]                       invokeRestart <- base::invokeRestart
[16:13:58.056]                       is.null <- base::is.null
[16:13:58.056]                       muffled <- FALSE
[16:13:58.056]                       if (inherits(cond, "message")) {
[16:13:58.056]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:58.056]                         if (muffled) 
[16:13:58.056]                           invokeRestart("muffleMessage")
[16:13:58.056]                       }
[16:13:58.056]                       else if (inherits(cond, "warning")) {
[16:13:58.056]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:58.056]                         if (muffled) 
[16:13:58.056]                           invokeRestart("muffleWarning")
[16:13:58.056]                       }
[16:13:58.056]                       else if (inherits(cond, "condition")) {
[16:13:58.056]                         if (!is.null(pattern)) {
[16:13:58.056]                           computeRestarts <- base::computeRestarts
[16:13:58.056]                           grepl <- base::grepl
[16:13:58.056]                           restarts <- computeRestarts(cond)
[16:13:58.056]                           for (restart in restarts) {
[16:13:58.056]                             name <- restart$name
[16:13:58.056]                             if (is.null(name)) 
[16:13:58.056]                               next
[16:13:58.056]                             if (!grepl(pattern, name)) 
[16:13:58.056]                               next
[16:13:58.056]                             invokeRestart(restart)
[16:13:58.056]                             muffled <- TRUE
[16:13:58.056]                             break
[16:13:58.056]                           }
[16:13:58.056]                         }
[16:13:58.056]                       }
[16:13:58.056]                       invisible(muffled)
[16:13:58.056]                     }
[16:13:58.056]                     muffleCondition(cond, pattern = "^muffle")
[16:13:58.056]                   }
[16:13:58.056]                 }
[16:13:58.056]                 else {
[16:13:58.056]                   if (TRUE) {
[16:13:58.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:58.056]                     {
[16:13:58.056]                       inherits <- base::inherits
[16:13:58.056]                       invokeRestart <- base::invokeRestart
[16:13:58.056]                       is.null <- base::is.null
[16:13:58.056]                       muffled <- FALSE
[16:13:58.056]                       if (inherits(cond, "message")) {
[16:13:58.056]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:58.056]                         if (muffled) 
[16:13:58.056]                           invokeRestart("muffleMessage")
[16:13:58.056]                       }
[16:13:58.056]                       else if (inherits(cond, "warning")) {
[16:13:58.056]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:58.056]                         if (muffled) 
[16:13:58.056]                           invokeRestart("muffleWarning")
[16:13:58.056]                       }
[16:13:58.056]                       else if (inherits(cond, "condition")) {
[16:13:58.056]                         if (!is.null(pattern)) {
[16:13:58.056]                           computeRestarts <- base::computeRestarts
[16:13:58.056]                           grepl <- base::grepl
[16:13:58.056]                           restarts <- computeRestarts(cond)
[16:13:58.056]                           for (restart in restarts) {
[16:13:58.056]                             name <- restart$name
[16:13:58.056]                             if (is.null(name)) 
[16:13:58.056]                               next
[16:13:58.056]                             if (!grepl(pattern, name)) 
[16:13:58.056]                               next
[16:13:58.056]                             invokeRestart(restart)
[16:13:58.056]                             muffled <- TRUE
[16:13:58.056]                             break
[16:13:58.056]                           }
[16:13:58.056]                         }
[16:13:58.056]                       }
[16:13:58.056]                       invisible(muffled)
[16:13:58.056]                     }
[16:13:58.056]                     muffleCondition(cond, pattern = "^muffle")
[16:13:58.056]                   }
[16:13:58.056]                 }
[16:13:58.056]             }
[16:13:58.056]         }))
[16:13:58.056]     }, error = function(ex) {
[16:13:58.056]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:58.056]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:58.056]                 ...future.rng), started = ...future.startTime, 
[16:13:58.056]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:58.056]             version = "1.8"), class = "FutureResult")
[16:13:58.056]     }, finally = {
[16:13:58.056]         if (!identical(...future.workdir, getwd())) 
[16:13:58.056]             setwd(...future.workdir)
[16:13:58.056]         {
[16:13:58.056]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:58.056]                 ...future.oldOptions$nwarnings <- NULL
[16:13:58.056]             }
[16:13:58.056]             base::options(...future.oldOptions)
[16:13:58.056]             if (.Platform$OS.type == "windows") {
[16:13:58.056]                 old_names <- names(...future.oldEnvVars)
[16:13:58.056]                 envs <- base::Sys.getenv()
[16:13:58.056]                 names <- names(envs)
[16:13:58.056]                 common <- intersect(names, old_names)
[16:13:58.056]                 added <- setdiff(names, old_names)
[16:13:58.056]                 removed <- setdiff(old_names, names)
[16:13:58.056]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:58.056]                   envs[common]]
[16:13:58.056]                 NAMES <- toupper(changed)
[16:13:58.056]                 args <- list()
[16:13:58.056]                 for (kk in seq_along(NAMES)) {
[16:13:58.056]                   name <- changed[[kk]]
[16:13:58.056]                   NAME <- NAMES[[kk]]
[16:13:58.056]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:58.056]                     next
[16:13:58.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:58.056]                 }
[16:13:58.056]                 NAMES <- toupper(added)
[16:13:58.056]                 for (kk in seq_along(NAMES)) {
[16:13:58.056]                   name <- added[[kk]]
[16:13:58.056]                   NAME <- NAMES[[kk]]
[16:13:58.056]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:58.056]                     next
[16:13:58.056]                   args[[name]] <- ""
[16:13:58.056]                 }
[16:13:58.056]                 NAMES <- toupper(removed)
[16:13:58.056]                 for (kk in seq_along(NAMES)) {
[16:13:58.056]                   name <- removed[[kk]]
[16:13:58.056]                   NAME <- NAMES[[kk]]
[16:13:58.056]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:58.056]                     next
[16:13:58.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:58.056]                 }
[16:13:58.056]                 if (length(args) > 0) 
[16:13:58.056]                   base::do.call(base::Sys.setenv, args = args)
[16:13:58.056]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:58.056]             }
[16:13:58.056]             else {
[16:13:58.056]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:58.056]             }
[16:13:58.056]             {
[16:13:58.056]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:58.056]                   0L) {
[16:13:58.056]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:58.056]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:58.056]                   base::options(opts)
[16:13:58.056]                 }
[16:13:58.056]                 {
[16:13:58.056]                   {
[16:13:58.056]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:58.056]                     NULL
[16:13:58.056]                   }
[16:13:58.056]                   options(future.plan = NULL)
[16:13:58.056]                   if (is.na(NA_character_)) 
[16:13:58.056]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:58.056]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:58.056]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:58.056]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:58.056]                     envir = parent.frame()) 
[16:13:58.056]                   {
[16:13:58.056]                     if (is.function(workers)) 
[16:13:58.056]                       workers <- workers()
[16:13:58.056]                     workers <- structure(as.integer(workers), 
[16:13:58.056]                       class = class(workers))
[16:13:58.056]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:58.056]                       workers >= 1)
[16:13:58.056]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:58.056]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:58.056]                     }
[16:13:58.056]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:58.056]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:58.056]                       envir = envir)
[16:13:58.056]                     if (!future$lazy) 
[16:13:58.056]                       future <- run(future)
[16:13:58.056]                     invisible(future)
[16:13:58.056]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:58.056]                 }
[16:13:58.056]             }
[16:13:58.056]         }
[16:13:58.056]     })
[16:13:58.056]     if (TRUE) {
[16:13:58.056]         base::sink(type = "output", split = FALSE)
[16:13:58.056]         if (TRUE) {
[16:13:58.056]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:58.056]         }
[16:13:58.056]         else {
[16:13:58.056]             ...future.result["stdout"] <- base::list(NULL)
[16:13:58.056]         }
[16:13:58.056]         base::close(...future.stdout)
[16:13:58.056]         ...future.stdout <- NULL
[16:13:58.056]     }
[16:13:58.056]     ...future.result$conditions <- ...future.conditions
[16:13:58.056]     ...future.result$finished <- base::Sys.time()
[16:13:58.056]     ...future.result
[16:13:58.056] }
[16:13:58.059] MultisessionFuture started
[16:13:58.059] - Launch lazy future ... done
[16:13:58.059] run() for ‘MultisessionFuture’ ... done
[16:13:58.104] receiveMessageFromWorker() for ClusterFuture ...
[16:13:58.105] - Validating connection of MultisessionFuture
[16:13:58.105] - received message: FutureResult
[16:13:58.105] - Received FutureResult
[16:13:58.105] - Erased future from FutureRegistry
[16:13:58.105] result() for ClusterFuture ...
[16:13:58.105] - result already collected: FutureResult
[16:13:58.106] result() for ClusterFuture ... done
[16:13:58.106] signalConditions() ...
[16:13:58.106]  - include = ‘immediateCondition’
[16:13:58.106]  - exclude = 
[16:13:58.106]  - resignal = FALSE
[16:13:58.106]  - Number of conditions: 1
[16:13:58.106] signalConditions() ... done
[16:13:58.106] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:58.106] A MultisessionFuture was resolved
[16:13:58.106] getGlobalsAndPackages() ...
[16:13:58.106] Searching for globals...
[16:13:58.107] - globals found: [2] ‘list’, ‘stop’
[16:13:58.107] Searching for globals ... DONE
[16:13:58.107] Resolving globals: FALSE
[16:13:58.108] 
[16:13:58.108] 
[16:13:58.108] getGlobalsAndPackages() ... DONE
[16:13:58.108] run() for ‘Future’ ...
[16:13:58.108] - state: ‘created’
[16:13:58.108] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:58.123] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:58.123] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:58.123]   - Field: ‘node’
[16:13:58.124]   - Field: ‘label’
[16:13:58.124]   - Field: ‘local’
[16:13:58.124]   - Field: ‘owner’
[16:13:58.124]   - Field: ‘envir’
[16:13:58.124]   - Field: ‘workers’
[16:13:58.124]   - Field: ‘packages’
[16:13:58.124]   - Field: ‘gc’
[16:13:58.124]   - Field: ‘conditions’
[16:13:58.124]   - Field: ‘persistent’
[16:13:58.124]   - Field: ‘expr’
[16:13:58.125]   - Field: ‘uuid’
[16:13:58.125]   - Field: ‘seed’
[16:13:58.125]   - Field: ‘version’
[16:13:58.125]   - Field: ‘result’
[16:13:58.125]   - Field: ‘asynchronous’
[16:13:58.125]   - Field: ‘calls’
[16:13:58.125]   - Field: ‘globals’
[16:13:58.125]   - Field: ‘stdout’
[16:13:58.125]   - Field: ‘earlySignal’
[16:13:58.125]   - Field: ‘lazy’
[16:13:58.125]   - Field: ‘state’
[16:13:58.126] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:58.126] - Launch lazy future ...
[16:13:58.126] Packages needed by the future expression (n = 0): <none>
[16:13:58.126] Packages needed by future strategies (n = 0): <none>
[16:13:58.126] {
[16:13:58.126]     {
[16:13:58.126]         {
[16:13:58.126]             ...future.startTime <- base::Sys.time()
[16:13:58.126]             {
[16:13:58.126]                 {
[16:13:58.126]                   {
[16:13:58.126]                     {
[16:13:58.126]                       base::local({
[16:13:58.126]                         has_future <- base::requireNamespace("future", 
[16:13:58.126]                           quietly = TRUE)
[16:13:58.126]                         if (has_future) {
[16:13:58.126]                           ns <- base::getNamespace("future")
[16:13:58.126]                           version <- ns[[".package"]][["version"]]
[16:13:58.126]                           if (is.null(version)) 
[16:13:58.126]                             version <- utils::packageVersion("future")
[16:13:58.126]                         }
[16:13:58.126]                         else {
[16:13:58.126]                           version <- NULL
[16:13:58.126]                         }
[16:13:58.126]                         if (!has_future || version < "1.8.0") {
[16:13:58.126]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:58.126]                             "", base::R.version$version.string), 
[16:13:58.126]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:58.126]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:58.126]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:58.126]                               "release", "version")], collapse = " "), 
[16:13:58.126]                             hostname = base::Sys.info()[["nodename"]])
[16:13:58.126]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:58.126]                             info)
[16:13:58.126]                           info <- base::paste(info, collapse = "; ")
[16:13:58.126]                           if (!has_future) {
[16:13:58.126]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:58.126]                               info)
[16:13:58.126]                           }
[16:13:58.126]                           else {
[16:13:58.126]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:58.126]                               info, version)
[16:13:58.126]                           }
[16:13:58.126]                           base::stop(msg)
[16:13:58.126]                         }
[16:13:58.126]                       })
[16:13:58.126]                     }
[16:13:58.126]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:58.126]                     base::options(mc.cores = 1L)
[16:13:58.126]                   }
[16:13:58.126]                   options(future.plan = NULL)
[16:13:58.126]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:58.126]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:58.126]                 }
[16:13:58.126]                 ...future.workdir <- getwd()
[16:13:58.126]             }
[16:13:58.126]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:58.126]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:58.126]         }
[16:13:58.126]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:58.126]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:58.126]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:58.126]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:58.126]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:58.126]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:58.126]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:58.126]             base::names(...future.oldOptions))
[16:13:58.126]     }
[16:13:58.126]     if (FALSE) {
[16:13:58.126]     }
[16:13:58.126]     else {
[16:13:58.126]         if (TRUE) {
[16:13:58.126]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:58.126]                 open = "w")
[16:13:58.126]         }
[16:13:58.126]         else {
[16:13:58.126]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:58.126]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:58.126]         }
[16:13:58.126]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:58.126]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:58.126]             base::sink(type = "output", split = FALSE)
[16:13:58.126]             base::close(...future.stdout)
[16:13:58.126]         }, add = TRUE)
[16:13:58.126]     }
[16:13:58.126]     ...future.frame <- base::sys.nframe()
[16:13:58.126]     ...future.conditions <- base::list()
[16:13:58.126]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:58.126]     if (FALSE) {
[16:13:58.126]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:58.126]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:58.126]     }
[16:13:58.126]     ...future.result <- base::tryCatch({
[16:13:58.126]         base::withCallingHandlers({
[16:13:58.126]             ...future.value <- base::withVisible(base::local({
[16:13:58.126]                 ...future.makeSendCondition <- local({
[16:13:58.126]                   sendCondition <- NULL
[16:13:58.126]                   function(frame = 1L) {
[16:13:58.126]                     if (is.function(sendCondition)) 
[16:13:58.126]                       return(sendCondition)
[16:13:58.126]                     ns <- getNamespace("parallel")
[16:13:58.126]                     if (exists("sendData", mode = "function", 
[16:13:58.126]                       envir = ns)) {
[16:13:58.126]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:58.126]                         envir = ns)
[16:13:58.126]                       envir <- sys.frame(frame)
[16:13:58.126]                       master <- NULL
[16:13:58.126]                       while (!identical(envir, .GlobalEnv) && 
[16:13:58.126]                         !identical(envir, emptyenv())) {
[16:13:58.126]                         if (exists("master", mode = "list", envir = envir, 
[16:13:58.126]                           inherits = FALSE)) {
[16:13:58.126]                           master <- get("master", mode = "list", 
[16:13:58.126]                             envir = envir, inherits = FALSE)
[16:13:58.126]                           if (inherits(master, c("SOCKnode", 
[16:13:58.126]                             "SOCK0node"))) {
[16:13:58.126]                             sendCondition <<- function(cond) {
[16:13:58.126]                               data <- list(type = "VALUE", value = cond, 
[16:13:58.126]                                 success = TRUE)
[16:13:58.126]                               parallel_sendData(master, data)
[16:13:58.126]                             }
[16:13:58.126]                             return(sendCondition)
[16:13:58.126]                           }
[16:13:58.126]                         }
[16:13:58.126]                         frame <- frame + 1L
[16:13:58.126]                         envir <- sys.frame(frame)
[16:13:58.126]                       }
[16:13:58.126]                     }
[16:13:58.126]                     sendCondition <<- function(cond) NULL
[16:13:58.126]                   }
[16:13:58.126]                 })
[16:13:58.126]                 withCallingHandlers({
[16:13:58.126]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:58.126]                 }, immediateCondition = function(cond) {
[16:13:58.126]                   sendCondition <- ...future.makeSendCondition()
[16:13:58.126]                   sendCondition(cond)
[16:13:58.126]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:58.126]                   {
[16:13:58.126]                     inherits <- base::inherits
[16:13:58.126]                     invokeRestart <- base::invokeRestart
[16:13:58.126]                     is.null <- base::is.null
[16:13:58.126]                     muffled <- FALSE
[16:13:58.126]                     if (inherits(cond, "message")) {
[16:13:58.126]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:58.126]                       if (muffled) 
[16:13:58.126]                         invokeRestart("muffleMessage")
[16:13:58.126]                     }
[16:13:58.126]                     else if (inherits(cond, "warning")) {
[16:13:58.126]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:58.126]                       if (muffled) 
[16:13:58.126]                         invokeRestart("muffleWarning")
[16:13:58.126]                     }
[16:13:58.126]                     else if (inherits(cond, "condition")) {
[16:13:58.126]                       if (!is.null(pattern)) {
[16:13:58.126]                         computeRestarts <- base::computeRestarts
[16:13:58.126]                         grepl <- base::grepl
[16:13:58.126]                         restarts <- computeRestarts(cond)
[16:13:58.126]                         for (restart in restarts) {
[16:13:58.126]                           name <- restart$name
[16:13:58.126]                           if (is.null(name)) 
[16:13:58.126]                             next
[16:13:58.126]                           if (!grepl(pattern, name)) 
[16:13:58.126]                             next
[16:13:58.126]                           invokeRestart(restart)
[16:13:58.126]                           muffled <- TRUE
[16:13:58.126]                           break
[16:13:58.126]                         }
[16:13:58.126]                       }
[16:13:58.126]                     }
[16:13:58.126]                     invisible(muffled)
[16:13:58.126]                   }
[16:13:58.126]                   muffleCondition(cond)
[16:13:58.126]                 })
[16:13:58.126]             }))
[16:13:58.126]             future::FutureResult(value = ...future.value$value, 
[16:13:58.126]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:58.126]                   ...future.rng), globalenv = if (FALSE) 
[16:13:58.126]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:58.126]                     ...future.globalenv.names))
[16:13:58.126]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:58.126]         }, condition = base::local({
[16:13:58.126]             c <- base::c
[16:13:58.126]             inherits <- base::inherits
[16:13:58.126]             invokeRestart <- base::invokeRestart
[16:13:58.126]             length <- base::length
[16:13:58.126]             list <- base::list
[16:13:58.126]             seq.int <- base::seq.int
[16:13:58.126]             signalCondition <- base::signalCondition
[16:13:58.126]             sys.calls <- base::sys.calls
[16:13:58.126]             `[[` <- base::`[[`
[16:13:58.126]             `+` <- base::`+`
[16:13:58.126]             `<<-` <- base::`<<-`
[16:13:58.126]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:58.126]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:58.126]                   3L)]
[16:13:58.126]             }
[16:13:58.126]             function(cond) {
[16:13:58.126]                 is_error <- inherits(cond, "error")
[16:13:58.126]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:58.126]                   NULL)
[16:13:58.126]                 if (is_error) {
[16:13:58.126]                   sessionInformation <- function() {
[16:13:58.126]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:58.126]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:58.126]                       search = base::search(), system = base::Sys.info())
[16:13:58.126]                   }
[16:13:58.126]                   ...future.conditions[[length(...future.conditions) + 
[16:13:58.126]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:58.126]                     cond$call), session = sessionInformation(), 
[16:13:58.126]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:58.126]                   signalCondition(cond)
[16:13:58.126]                 }
[16:13:58.126]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:58.126]                 "immediateCondition"))) {
[16:13:58.126]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:58.126]                   ...future.conditions[[length(...future.conditions) + 
[16:13:58.126]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:58.126]                   if (TRUE && !signal) {
[16:13:58.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:58.126]                     {
[16:13:58.126]                       inherits <- base::inherits
[16:13:58.126]                       invokeRestart <- base::invokeRestart
[16:13:58.126]                       is.null <- base::is.null
[16:13:58.126]                       muffled <- FALSE
[16:13:58.126]                       if (inherits(cond, "message")) {
[16:13:58.126]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:58.126]                         if (muffled) 
[16:13:58.126]                           invokeRestart("muffleMessage")
[16:13:58.126]                       }
[16:13:58.126]                       else if (inherits(cond, "warning")) {
[16:13:58.126]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:58.126]                         if (muffled) 
[16:13:58.126]                           invokeRestart("muffleWarning")
[16:13:58.126]                       }
[16:13:58.126]                       else if (inherits(cond, "condition")) {
[16:13:58.126]                         if (!is.null(pattern)) {
[16:13:58.126]                           computeRestarts <- base::computeRestarts
[16:13:58.126]                           grepl <- base::grepl
[16:13:58.126]                           restarts <- computeRestarts(cond)
[16:13:58.126]                           for (restart in restarts) {
[16:13:58.126]                             name <- restart$name
[16:13:58.126]                             if (is.null(name)) 
[16:13:58.126]                               next
[16:13:58.126]                             if (!grepl(pattern, name)) 
[16:13:58.126]                               next
[16:13:58.126]                             invokeRestart(restart)
[16:13:58.126]                             muffled <- TRUE
[16:13:58.126]                             break
[16:13:58.126]                           }
[16:13:58.126]                         }
[16:13:58.126]                       }
[16:13:58.126]                       invisible(muffled)
[16:13:58.126]                     }
[16:13:58.126]                     muffleCondition(cond, pattern = "^muffle")
[16:13:58.126]                   }
[16:13:58.126]                 }
[16:13:58.126]                 else {
[16:13:58.126]                   if (TRUE) {
[16:13:58.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:58.126]                     {
[16:13:58.126]                       inherits <- base::inherits
[16:13:58.126]                       invokeRestart <- base::invokeRestart
[16:13:58.126]                       is.null <- base::is.null
[16:13:58.126]                       muffled <- FALSE
[16:13:58.126]                       if (inherits(cond, "message")) {
[16:13:58.126]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:58.126]                         if (muffled) 
[16:13:58.126]                           invokeRestart("muffleMessage")
[16:13:58.126]                       }
[16:13:58.126]                       else if (inherits(cond, "warning")) {
[16:13:58.126]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:58.126]                         if (muffled) 
[16:13:58.126]                           invokeRestart("muffleWarning")
[16:13:58.126]                       }
[16:13:58.126]                       else if (inherits(cond, "condition")) {
[16:13:58.126]                         if (!is.null(pattern)) {
[16:13:58.126]                           computeRestarts <- base::computeRestarts
[16:13:58.126]                           grepl <- base::grepl
[16:13:58.126]                           restarts <- computeRestarts(cond)
[16:13:58.126]                           for (restart in restarts) {
[16:13:58.126]                             name <- restart$name
[16:13:58.126]                             if (is.null(name)) 
[16:13:58.126]                               next
[16:13:58.126]                             if (!grepl(pattern, name)) 
[16:13:58.126]                               next
[16:13:58.126]                             invokeRestart(restart)
[16:13:58.126]                             muffled <- TRUE
[16:13:58.126]                             break
[16:13:58.126]                           }
[16:13:58.126]                         }
[16:13:58.126]                       }
[16:13:58.126]                       invisible(muffled)
[16:13:58.126]                     }
[16:13:58.126]                     muffleCondition(cond, pattern = "^muffle")
[16:13:58.126]                   }
[16:13:58.126]                 }
[16:13:58.126]             }
[16:13:58.126]         }))
[16:13:58.126]     }, error = function(ex) {
[16:13:58.126]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:58.126]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:58.126]                 ...future.rng), started = ...future.startTime, 
[16:13:58.126]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:58.126]             version = "1.8"), class = "FutureResult")
[16:13:58.126]     }, finally = {
[16:13:58.126]         if (!identical(...future.workdir, getwd())) 
[16:13:58.126]             setwd(...future.workdir)
[16:13:58.126]         {
[16:13:58.126]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:58.126]                 ...future.oldOptions$nwarnings <- NULL
[16:13:58.126]             }
[16:13:58.126]             base::options(...future.oldOptions)
[16:13:58.126]             if (.Platform$OS.type == "windows") {
[16:13:58.126]                 old_names <- names(...future.oldEnvVars)
[16:13:58.126]                 envs <- base::Sys.getenv()
[16:13:58.126]                 names <- names(envs)
[16:13:58.126]                 common <- intersect(names, old_names)
[16:13:58.126]                 added <- setdiff(names, old_names)
[16:13:58.126]                 removed <- setdiff(old_names, names)
[16:13:58.126]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:58.126]                   envs[common]]
[16:13:58.126]                 NAMES <- toupper(changed)
[16:13:58.126]                 args <- list()
[16:13:58.126]                 for (kk in seq_along(NAMES)) {
[16:13:58.126]                   name <- changed[[kk]]
[16:13:58.126]                   NAME <- NAMES[[kk]]
[16:13:58.126]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:58.126]                     next
[16:13:58.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:58.126]                 }
[16:13:58.126]                 NAMES <- toupper(added)
[16:13:58.126]                 for (kk in seq_along(NAMES)) {
[16:13:58.126]                   name <- added[[kk]]
[16:13:58.126]                   NAME <- NAMES[[kk]]
[16:13:58.126]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:58.126]                     next
[16:13:58.126]                   args[[name]] <- ""
[16:13:58.126]                 }
[16:13:58.126]                 NAMES <- toupper(removed)
[16:13:58.126]                 for (kk in seq_along(NAMES)) {
[16:13:58.126]                   name <- removed[[kk]]
[16:13:58.126]                   NAME <- NAMES[[kk]]
[16:13:58.126]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:58.126]                     next
[16:13:58.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:58.126]                 }
[16:13:58.126]                 if (length(args) > 0) 
[16:13:58.126]                   base::do.call(base::Sys.setenv, args = args)
[16:13:58.126]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:58.126]             }
[16:13:58.126]             else {
[16:13:58.126]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:58.126]             }
[16:13:58.126]             {
[16:13:58.126]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:58.126]                   0L) {
[16:13:58.126]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:58.126]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:58.126]                   base::options(opts)
[16:13:58.126]                 }
[16:13:58.126]                 {
[16:13:58.126]                   {
[16:13:58.126]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:58.126]                     NULL
[16:13:58.126]                   }
[16:13:58.126]                   options(future.plan = NULL)
[16:13:58.126]                   if (is.na(NA_character_)) 
[16:13:58.126]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:58.126]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:58.126]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:58.126]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:58.126]                     envir = parent.frame()) 
[16:13:58.126]                   {
[16:13:58.126]                     if (is.function(workers)) 
[16:13:58.126]                       workers <- workers()
[16:13:58.126]                     workers <- structure(as.integer(workers), 
[16:13:58.126]                       class = class(workers))
[16:13:58.126]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:58.126]                       workers >= 1)
[16:13:58.126]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:58.126]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:58.126]                     }
[16:13:58.126]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:58.126]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:58.126]                       envir = envir)
[16:13:58.126]                     if (!future$lazy) 
[16:13:58.126]                       future <- run(future)
[16:13:58.126]                     invisible(future)
[16:13:58.126]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:58.126]                 }
[16:13:58.126]             }
[16:13:58.126]         }
[16:13:58.126]     })
[16:13:58.126]     if (TRUE) {
[16:13:58.126]         base::sink(type = "output", split = FALSE)
[16:13:58.126]         if (TRUE) {
[16:13:58.126]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:58.126]         }
[16:13:58.126]         else {
[16:13:58.126]             ...future.result["stdout"] <- base::list(NULL)
[16:13:58.126]         }
[16:13:58.126]         base::close(...future.stdout)
[16:13:58.126]         ...future.stdout <- NULL
[16:13:58.126]     }
[16:13:58.126]     ...future.result$conditions <- ...future.conditions
[16:13:58.126]     ...future.result$finished <- base::Sys.time()
[16:13:58.126]     ...future.result
[16:13:58.126] }
[16:13:58.129] MultisessionFuture started
[16:13:58.129] - Launch lazy future ... done
[16:13:58.130] run() for ‘MultisessionFuture’ ... done
[16:13:58.176] receiveMessageFromWorker() for ClusterFuture ...
[16:13:58.176] - Validating connection of MultisessionFuture
[16:13:58.177] - received message: FutureResult
[16:13:58.177] - Received FutureResult
[16:13:58.177] - Erased future from FutureRegistry
[16:13:58.177] result() for ClusterFuture ...
[16:13:58.177] - result already collected: FutureResult
[16:13:58.177] result() for ClusterFuture ... done
[16:13:58.177] signalConditions() ...
[16:13:58.177]  - include = ‘immediateCondition’
[16:13:58.177]  - exclude = 
[16:13:58.177]  - resignal = FALSE
[16:13:58.178]  - Number of conditions: 1
[16:13:58.178] signalConditions() ... done
[16:13:58.178] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:58.178] A MultisessionFuture was resolved
- result = TRUE, recursive = 2 ... DONE
- result = TRUE, recursive = Inf ...
[16:13:58.178] getGlobalsAndPackages() ...
[16:13:58.178] Searching for globals...
[16:13:58.179] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:58.179] Searching for globals ... DONE
[16:13:58.179] Resolving globals: FALSE
[16:13:58.180] 
[16:13:58.180] 
[16:13:58.180] getGlobalsAndPackages() ... DONE
[16:13:58.180] run() for ‘Future’ ...
[16:13:58.180] - state: ‘created’
[16:13:58.180] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:58.195] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:58.195] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:58.195]   - Field: ‘node’
[16:13:58.195]   - Field: ‘label’
[16:13:58.195]   - Field: ‘local’
[16:13:58.195]   - Field: ‘owner’
[16:13:58.195]   - Field: ‘envir’
[16:13:58.195]   - Field: ‘workers’
[16:13:58.195]   - Field: ‘packages’
[16:13:58.195]   - Field: ‘gc’
[16:13:58.196]   - Field: ‘conditions’
[16:13:58.196]   - Field: ‘persistent’
[16:13:58.196]   - Field: ‘expr’
[16:13:58.196]   - Field: ‘uuid’
[16:13:58.196]   - Field: ‘seed’
[16:13:58.196]   - Field: ‘version’
[16:13:58.196]   - Field: ‘result’
[16:13:58.196]   - Field: ‘asynchronous’
[16:13:58.196]   - Field: ‘calls’
[16:13:58.197]   - Field: ‘globals’
[16:13:58.197]   - Field: ‘stdout’
[16:13:58.197]   - Field: ‘earlySignal’
[16:13:58.197]   - Field: ‘lazy’
[16:13:58.197]   - Field: ‘state’
[16:13:58.197] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:58.197] - Launch lazy future ...
[16:13:58.197] Packages needed by the future expression (n = 0): <none>
[16:13:58.197] Packages needed by future strategies (n = 0): <none>
[16:13:58.198] {
[16:13:58.198]     {
[16:13:58.198]         {
[16:13:58.198]             ...future.startTime <- base::Sys.time()
[16:13:58.198]             {
[16:13:58.198]                 {
[16:13:58.198]                   {
[16:13:58.198]                     {
[16:13:58.198]                       base::local({
[16:13:58.198]                         has_future <- base::requireNamespace("future", 
[16:13:58.198]                           quietly = TRUE)
[16:13:58.198]                         if (has_future) {
[16:13:58.198]                           ns <- base::getNamespace("future")
[16:13:58.198]                           version <- ns[[".package"]][["version"]]
[16:13:58.198]                           if (is.null(version)) 
[16:13:58.198]                             version <- utils::packageVersion("future")
[16:13:58.198]                         }
[16:13:58.198]                         else {
[16:13:58.198]                           version <- NULL
[16:13:58.198]                         }
[16:13:58.198]                         if (!has_future || version < "1.8.0") {
[16:13:58.198]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:58.198]                             "", base::R.version$version.string), 
[16:13:58.198]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:58.198]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:58.198]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:58.198]                               "release", "version")], collapse = " "), 
[16:13:58.198]                             hostname = base::Sys.info()[["nodename"]])
[16:13:58.198]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:58.198]                             info)
[16:13:58.198]                           info <- base::paste(info, collapse = "; ")
[16:13:58.198]                           if (!has_future) {
[16:13:58.198]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:58.198]                               info)
[16:13:58.198]                           }
[16:13:58.198]                           else {
[16:13:58.198]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:58.198]                               info, version)
[16:13:58.198]                           }
[16:13:58.198]                           base::stop(msg)
[16:13:58.198]                         }
[16:13:58.198]                       })
[16:13:58.198]                     }
[16:13:58.198]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:58.198]                     base::options(mc.cores = 1L)
[16:13:58.198]                   }
[16:13:58.198]                   options(future.plan = NULL)
[16:13:58.198]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:58.198]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:58.198]                 }
[16:13:58.198]                 ...future.workdir <- getwd()
[16:13:58.198]             }
[16:13:58.198]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:58.198]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:58.198]         }
[16:13:58.198]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:58.198]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:58.198]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:58.198]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:58.198]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:58.198]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:58.198]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:58.198]             base::names(...future.oldOptions))
[16:13:58.198]     }
[16:13:58.198]     if (FALSE) {
[16:13:58.198]     }
[16:13:58.198]     else {
[16:13:58.198]         if (TRUE) {
[16:13:58.198]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:58.198]                 open = "w")
[16:13:58.198]         }
[16:13:58.198]         else {
[16:13:58.198]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:58.198]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:58.198]         }
[16:13:58.198]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:58.198]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:58.198]             base::sink(type = "output", split = FALSE)
[16:13:58.198]             base::close(...future.stdout)
[16:13:58.198]         }, add = TRUE)
[16:13:58.198]     }
[16:13:58.198]     ...future.frame <- base::sys.nframe()
[16:13:58.198]     ...future.conditions <- base::list()
[16:13:58.198]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:58.198]     if (FALSE) {
[16:13:58.198]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:58.198]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:58.198]     }
[16:13:58.198]     ...future.result <- base::tryCatch({
[16:13:58.198]         base::withCallingHandlers({
[16:13:58.198]             ...future.value <- base::withVisible(base::local({
[16:13:58.198]                 ...future.makeSendCondition <- local({
[16:13:58.198]                   sendCondition <- NULL
[16:13:58.198]                   function(frame = 1L) {
[16:13:58.198]                     if (is.function(sendCondition)) 
[16:13:58.198]                       return(sendCondition)
[16:13:58.198]                     ns <- getNamespace("parallel")
[16:13:58.198]                     if (exists("sendData", mode = "function", 
[16:13:58.198]                       envir = ns)) {
[16:13:58.198]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:58.198]                         envir = ns)
[16:13:58.198]                       envir <- sys.frame(frame)
[16:13:58.198]                       master <- NULL
[16:13:58.198]                       while (!identical(envir, .GlobalEnv) && 
[16:13:58.198]                         !identical(envir, emptyenv())) {
[16:13:58.198]                         if (exists("master", mode = "list", envir = envir, 
[16:13:58.198]                           inherits = FALSE)) {
[16:13:58.198]                           master <- get("master", mode = "list", 
[16:13:58.198]                             envir = envir, inherits = FALSE)
[16:13:58.198]                           if (inherits(master, c("SOCKnode", 
[16:13:58.198]                             "SOCK0node"))) {
[16:13:58.198]                             sendCondition <<- function(cond) {
[16:13:58.198]                               data <- list(type = "VALUE", value = cond, 
[16:13:58.198]                                 success = TRUE)
[16:13:58.198]                               parallel_sendData(master, data)
[16:13:58.198]                             }
[16:13:58.198]                             return(sendCondition)
[16:13:58.198]                           }
[16:13:58.198]                         }
[16:13:58.198]                         frame <- frame + 1L
[16:13:58.198]                         envir <- sys.frame(frame)
[16:13:58.198]                       }
[16:13:58.198]                     }
[16:13:58.198]                     sendCondition <<- function(cond) NULL
[16:13:58.198]                   }
[16:13:58.198]                 })
[16:13:58.198]                 withCallingHandlers({
[16:13:58.198]                   {
[16:13:58.198]                     Sys.sleep(0.5)
[16:13:58.198]                     list(a = 1, b = 42L)
[16:13:58.198]                   }
[16:13:58.198]                 }, immediateCondition = function(cond) {
[16:13:58.198]                   sendCondition <- ...future.makeSendCondition()
[16:13:58.198]                   sendCondition(cond)
[16:13:58.198]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:58.198]                   {
[16:13:58.198]                     inherits <- base::inherits
[16:13:58.198]                     invokeRestart <- base::invokeRestart
[16:13:58.198]                     is.null <- base::is.null
[16:13:58.198]                     muffled <- FALSE
[16:13:58.198]                     if (inherits(cond, "message")) {
[16:13:58.198]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:58.198]                       if (muffled) 
[16:13:58.198]                         invokeRestart("muffleMessage")
[16:13:58.198]                     }
[16:13:58.198]                     else if (inherits(cond, "warning")) {
[16:13:58.198]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:58.198]                       if (muffled) 
[16:13:58.198]                         invokeRestart("muffleWarning")
[16:13:58.198]                     }
[16:13:58.198]                     else if (inherits(cond, "condition")) {
[16:13:58.198]                       if (!is.null(pattern)) {
[16:13:58.198]                         computeRestarts <- base::computeRestarts
[16:13:58.198]                         grepl <- base::grepl
[16:13:58.198]                         restarts <- computeRestarts(cond)
[16:13:58.198]                         for (restart in restarts) {
[16:13:58.198]                           name <- restart$name
[16:13:58.198]                           if (is.null(name)) 
[16:13:58.198]                             next
[16:13:58.198]                           if (!grepl(pattern, name)) 
[16:13:58.198]                             next
[16:13:58.198]                           invokeRestart(restart)
[16:13:58.198]                           muffled <- TRUE
[16:13:58.198]                           break
[16:13:58.198]                         }
[16:13:58.198]                       }
[16:13:58.198]                     }
[16:13:58.198]                     invisible(muffled)
[16:13:58.198]                   }
[16:13:58.198]                   muffleCondition(cond)
[16:13:58.198]                 })
[16:13:58.198]             }))
[16:13:58.198]             future::FutureResult(value = ...future.value$value, 
[16:13:58.198]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:58.198]                   ...future.rng), globalenv = if (FALSE) 
[16:13:58.198]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:58.198]                     ...future.globalenv.names))
[16:13:58.198]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:58.198]         }, condition = base::local({
[16:13:58.198]             c <- base::c
[16:13:58.198]             inherits <- base::inherits
[16:13:58.198]             invokeRestart <- base::invokeRestart
[16:13:58.198]             length <- base::length
[16:13:58.198]             list <- base::list
[16:13:58.198]             seq.int <- base::seq.int
[16:13:58.198]             signalCondition <- base::signalCondition
[16:13:58.198]             sys.calls <- base::sys.calls
[16:13:58.198]             `[[` <- base::`[[`
[16:13:58.198]             `+` <- base::`+`
[16:13:58.198]             `<<-` <- base::`<<-`
[16:13:58.198]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:58.198]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:58.198]                   3L)]
[16:13:58.198]             }
[16:13:58.198]             function(cond) {
[16:13:58.198]                 is_error <- inherits(cond, "error")
[16:13:58.198]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:58.198]                   NULL)
[16:13:58.198]                 if (is_error) {
[16:13:58.198]                   sessionInformation <- function() {
[16:13:58.198]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:58.198]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:58.198]                       search = base::search(), system = base::Sys.info())
[16:13:58.198]                   }
[16:13:58.198]                   ...future.conditions[[length(...future.conditions) + 
[16:13:58.198]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:58.198]                     cond$call), session = sessionInformation(), 
[16:13:58.198]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:58.198]                   signalCondition(cond)
[16:13:58.198]                 }
[16:13:58.198]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:58.198]                 "immediateCondition"))) {
[16:13:58.198]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:58.198]                   ...future.conditions[[length(...future.conditions) + 
[16:13:58.198]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:58.198]                   if (TRUE && !signal) {
[16:13:58.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:58.198]                     {
[16:13:58.198]                       inherits <- base::inherits
[16:13:58.198]                       invokeRestart <- base::invokeRestart
[16:13:58.198]                       is.null <- base::is.null
[16:13:58.198]                       muffled <- FALSE
[16:13:58.198]                       if (inherits(cond, "message")) {
[16:13:58.198]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:58.198]                         if (muffled) 
[16:13:58.198]                           invokeRestart("muffleMessage")
[16:13:58.198]                       }
[16:13:58.198]                       else if (inherits(cond, "warning")) {
[16:13:58.198]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:58.198]                         if (muffled) 
[16:13:58.198]                           invokeRestart("muffleWarning")
[16:13:58.198]                       }
[16:13:58.198]                       else if (inherits(cond, "condition")) {
[16:13:58.198]                         if (!is.null(pattern)) {
[16:13:58.198]                           computeRestarts <- base::computeRestarts
[16:13:58.198]                           grepl <- base::grepl
[16:13:58.198]                           restarts <- computeRestarts(cond)
[16:13:58.198]                           for (restart in restarts) {
[16:13:58.198]                             name <- restart$name
[16:13:58.198]                             if (is.null(name)) 
[16:13:58.198]                               next
[16:13:58.198]                             if (!grepl(pattern, name)) 
[16:13:58.198]                               next
[16:13:58.198]                             invokeRestart(restart)
[16:13:58.198]                             muffled <- TRUE
[16:13:58.198]                             break
[16:13:58.198]                           }
[16:13:58.198]                         }
[16:13:58.198]                       }
[16:13:58.198]                       invisible(muffled)
[16:13:58.198]                     }
[16:13:58.198]                     muffleCondition(cond, pattern = "^muffle")
[16:13:58.198]                   }
[16:13:58.198]                 }
[16:13:58.198]                 else {
[16:13:58.198]                   if (TRUE) {
[16:13:58.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:58.198]                     {
[16:13:58.198]                       inherits <- base::inherits
[16:13:58.198]                       invokeRestart <- base::invokeRestart
[16:13:58.198]                       is.null <- base::is.null
[16:13:58.198]                       muffled <- FALSE
[16:13:58.198]                       if (inherits(cond, "message")) {
[16:13:58.198]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:58.198]                         if (muffled) 
[16:13:58.198]                           invokeRestart("muffleMessage")
[16:13:58.198]                       }
[16:13:58.198]                       else if (inherits(cond, "warning")) {
[16:13:58.198]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:58.198]                         if (muffled) 
[16:13:58.198]                           invokeRestart("muffleWarning")
[16:13:58.198]                       }
[16:13:58.198]                       else if (inherits(cond, "condition")) {
[16:13:58.198]                         if (!is.null(pattern)) {
[16:13:58.198]                           computeRestarts <- base::computeRestarts
[16:13:58.198]                           grepl <- base::grepl
[16:13:58.198]                           restarts <- computeRestarts(cond)
[16:13:58.198]                           for (restart in restarts) {
[16:13:58.198]                             name <- restart$name
[16:13:58.198]                             if (is.null(name)) 
[16:13:58.198]                               next
[16:13:58.198]                             if (!grepl(pattern, name)) 
[16:13:58.198]                               next
[16:13:58.198]                             invokeRestart(restart)
[16:13:58.198]                             muffled <- TRUE
[16:13:58.198]                             break
[16:13:58.198]                           }
[16:13:58.198]                         }
[16:13:58.198]                       }
[16:13:58.198]                       invisible(muffled)
[16:13:58.198]                     }
[16:13:58.198]                     muffleCondition(cond, pattern = "^muffle")
[16:13:58.198]                   }
[16:13:58.198]                 }
[16:13:58.198]             }
[16:13:58.198]         }))
[16:13:58.198]     }, error = function(ex) {
[16:13:58.198]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:58.198]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:58.198]                 ...future.rng), started = ...future.startTime, 
[16:13:58.198]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:58.198]             version = "1.8"), class = "FutureResult")
[16:13:58.198]     }, finally = {
[16:13:58.198]         if (!identical(...future.workdir, getwd())) 
[16:13:58.198]             setwd(...future.workdir)
[16:13:58.198]         {
[16:13:58.198]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:58.198]                 ...future.oldOptions$nwarnings <- NULL
[16:13:58.198]             }
[16:13:58.198]             base::options(...future.oldOptions)
[16:13:58.198]             if (.Platform$OS.type == "windows") {
[16:13:58.198]                 old_names <- names(...future.oldEnvVars)
[16:13:58.198]                 envs <- base::Sys.getenv()
[16:13:58.198]                 names <- names(envs)
[16:13:58.198]                 common <- intersect(names, old_names)
[16:13:58.198]                 added <- setdiff(names, old_names)
[16:13:58.198]                 removed <- setdiff(old_names, names)
[16:13:58.198]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:58.198]                   envs[common]]
[16:13:58.198]                 NAMES <- toupper(changed)
[16:13:58.198]                 args <- list()
[16:13:58.198]                 for (kk in seq_along(NAMES)) {
[16:13:58.198]                   name <- changed[[kk]]
[16:13:58.198]                   NAME <- NAMES[[kk]]
[16:13:58.198]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:58.198]                     next
[16:13:58.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:58.198]                 }
[16:13:58.198]                 NAMES <- toupper(added)
[16:13:58.198]                 for (kk in seq_along(NAMES)) {
[16:13:58.198]                   name <- added[[kk]]
[16:13:58.198]                   NAME <- NAMES[[kk]]
[16:13:58.198]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:58.198]                     next
[16:13:58.198]                   args[[name]] <- ""
[16:13:58.198]                 }
[16:13:58.198]                 NAMES <- toupper(removed)
[16:13:58.198]                 for (kk in seq_along(NAMES)) {
[16:13:58.198]                   name <- removed[[kk]]
[16:13:58.198]                   NAME <- NAMES[[kk]]
[16:13:58.198]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:58.198]                     next
[16:13:58.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:58.198]                 }
[16:13:58.198]                 if (length(args) > 0) 
[16:13:58.198]                   base::do.call(base::Sys.setenv, args = args)
[16:13:58.198]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:58.198]             }
[16:13:58.198]             else {
[16:13:58.198]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:58.198]             }
[16:13:58.198]             {
[16:13:58.198]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:58.198]                   0L) {
[16:13:58.198]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:58.198]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:58.198]                   base::options(opts)
[16:13:58.198]                 }
[16:13:58.198]                 {
[16:13:58.198]                   {
[16:13:58.198]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:58.198]                     NULL
[16:13:58.198]                   }
[16:13:58.198]                   options(future.plan = NULL)
[16:13:58.198]                   if (is.na(NA_character_)) 
[16:13:58.198]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:58.198]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:58.198]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:58.198]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:58.198]                     envir = parent.frame()) 
[16:13:58.198]                   {
[16:13:58.198]                     if (is.function(workers)) 
[16:13:58.198]                       workers <- workers()
[16:13:58.198]                     workers <- structure(as.integer(workers), 
[16:13:58.198]                       class = class(workers))
[16:13:58.198]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:58.198]                       workers >= 1)
[16:13:58.198]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:58.198]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:58.198]                     }
[16:13:58.198]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:58.198]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:58.198]                       envir = envir)
[16:13:58.198]                     if (!future$lazy) 
[16:13:58.198]                       future <- run(future)
[16:13:58.198]                     invisible(future)
[16:13:58.198]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:58.198]                 }
[16:13:58.198]             }
[16:13:58.198]         }
[16:13:58.198]     })
[16:13:58.198]     if (TRUE) {
[16:13:58.198]         base::sink(type = "output", split = FALSE)
[16:13:58.198]         if (TRUE) {
[16:13:58.198]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:58.198]         }
[16:13:58.198]         else {
[16:13:58.198]             ...future.result["stdout"] <- base::list(NULL)
[16:13:58.198]         }
[16:13:58.198]         base::close(...future.stdout)
[16:13:58.198]         ...future.stdout <- NULL
[16:13:58.198]     }
[16:13:58.198]     ...future.result$conditions <- ...future.conditions
[16:13:58.198]     ...future.result$finished <- base::Sys.time()
[16:13:58.198]     ...future.result
[16:13:58.198] }
[16:13:58.201] MultisessionFuture started
[16:13:58.201] - Launch lazy future ... done
[16:13:58.201] run() for ‘MultisessionFuture’ ... done
[16:13:58.758] receiveMessageFromWorker() for ClusterFuture ...
[16:13:58.758] - Validating connection of MultisessionFuture
[16:13:58.759] - received message: FutureResult
[16:13:58.759] - Received FutureResult
[16:13:58.759] - Erased future from FutureRegistry
[16:13:58.759] result() for ClusterFuture ...
[16:13:58.759] - result already collected: FutureResult
[16:13:58.759] result() for ClusterFuture ... done
[16:13:58.759] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:58.760] resolve() on list ...
[16:13:58.760]  recursive: Inf
[16:13:58.760]  length: 2
[16:13:58.760]  elements: ‘a’, ‘b’
[16:13:58.760]  length: 1 (resolved future 1)
[16:13:58.760]  length: 0 (resolved future 2)
[16:13:58.760] resolve() on list ... DONE
[16:13:58.760] A MultisessionFuture was resolved (and resolved itself)
[16:13:58.760] getGlobalsAndPackages() ...
[16:13:58.760] Searching for globals...
[16:13:58.762] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:13:58.762] Searching for globals ... DONE
[16:13:58.762] Resolving globals: FALSE
[16:13:58.762] 
[16:13:58.762] 
[16:13:58.762] getGlobalsAndPackages() ... DONE
[16:13:58.763] run() for ‘Future’ ...
[16:13:58.763] - state: ‘created’
[16:13:58.763] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:58.777] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:58.777] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:58.777]   - Field: ‘node’
[16:13:58.778]   - Field: ‘label’
[16:13:58.778]   - Field: ‘local’
[16:13:58.778]   - Field: ‘owner’
[16:13:58.778]   - Field: ‘envir’
[16:13:58.778]   - Field: ‘workers’
[16:13:58.778]   - Field: ‘packages’
[16:13:58.778]   - Field: ‘gc’
[16:13:58.778]   - Field: ‘conditions’
[16:13:58.778]   - Field: ‘persistent’
[16:13:58.778]   - Field: ‘expr’
[16:13:58.778]   - Field: ‘uuid’
[16:13:58.779]   - Field: ‘seed’
[16:13:58.779]   - Field: ‘version’
[16:13:58.779]   - Field: ‘result’
[16:13:58.779]   - Field: ‘asynchronous’
[16:13:58.779]   - Field: ‘calls’
[16:13:58.779]   - Field: ‘globals’
[16:13:58.779]   - Field: ‘stdout’
[16:13:58.779]   - Field: ‘earlySignal’
[16:13:58.779]   - Field: ‘lazy’
[16:13:58.779]   - Field: ‘state’
[16:13:58.779] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:58.780] - Launch lazy future ...
[16:13:58.780] Packages needed by the future expression (n = 0): <none>
[16:13:58.780] Packages needed by future strategies (n = 0): <none>
[16:13:58.780] {
[16:13:58.780]     {
[16:13:58.780]         {
[16:13:58.780]             ...future.startTime <- base::Sys.time()
[16:13:58.780]             {
[16:13:58.780]                 {
[16:13:58.780]                   {
[16:13:58.780]                     {
[16:13:58.780]                       base::local({
[16:13:58.780]                         has_future <- base::requireNamespace("future", 
[16:13:58.780]                           quietly = TRUE)
[16:13:58.780]                         if (has_future) {
[16:13:58.780]                           ns <- base::getNamespace("future")
[16:13:58.780]                           version <- ns[[".package"]][["version"]]
[16:13:58.780]                           if (is.null(version)) 
[16:13:58.780]                             version <- utils::packageVersion("future")
[16:13:58.780]                         }
[16:13:58.780]                         else {
[16:13:58.780]                           version <- NULL
[16:13:58.780]                         }
[16:13:58.780]                         if (!has_future || version < "1.8.0") {
[16:13:58.780]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:58.780]                             "", base::R.version$version.string), 
[16:13:58.780]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:58.780]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:58.780]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:58.780]                               "release", "version")], collapse = " "), 
[16:13:58.780]                             hostname = base::Sys.info()[["nodename"]])
[16:13:58.780]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:58.780]                             info)
[16:13:58.780]                           info <- base::paste(info, collapse = "; ")
[16:13:58.780]                           if (!has_future) {
[16:13:58.780]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:58.780]                               info)
[16:13:58.780]                           }
[16:13:58.780]                           else {
[16:13:58.780]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:58.780]                               info, version)
[16:13:58.780]                           }
[16:13:58.780]                           base::stop(msg)
[16:13:58.780]                         }
[16:13:58.780]                       })
[16:13:58.780]                     }
[16:13:58.780]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:58.780]                     base::options(mc.cores = 1L)
[16:13:58.780]                   }
[16:13:58.780]                   options(future.plan = NULL)
[16:13:58.780]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:58.780]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:58.780]                 }
[16:13:58.780]                 ...future.workdir <- getwd()
[16:13:58.780]             }
[16:13:58.780]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:58.780]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:58.780]         }
[16:13:58.780]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:58.780]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:58.780]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:58.780]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:58.780]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:58.780]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:58.780]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:58.780]             base::names(...future.oldOptions))
[16:13:58.780]     }
[16:13:58.780]     if (FALSE) {
[16:13:58.780]     }
[16:13:58.780]     else {
[16:13:58.780]         if (TRUE) {
[16:13:58.780]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:58.780]                 open = "w")
[16:13:58.780]         }
[16:13:58.780]         else {
[16:13:58.780]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:58.780]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:58.780]         }
[16:13:58.780]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:58.780]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:58.780]             base::sink(type = "output", split = FALSE)
[16:13:58.780]             base::close(...future.stdout)
[16:13:58.780]         }, add = TRUE)
[16:13:58.780]     }
[16:13:58.780]     ...future.frame <- base::sys.nframe()
[16:13:58.780]     ...future.conditions <- base::list()
[16:13:58.780]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:58.780]     if (FALSE) {
[16:13:58.780]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:58.780]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:58.780]     }
[16:13:58.780]     ...future.result <- base::tryCatch({
[16:13:58.780]         base::withCallingHandlers({
[16:13:58.780]             ...future.value <- base::withVisible(base::local({
[16:13:58.780]                 ...future.makeSendCondition <- local({
[16:13:58.780]                   sendCondition <- NULL
[16:13:58.780]                   function(frame = 1L) {
[16:13:58.780]                     if (is.function(sendCondition)) 
[16:13:58.780]                       return(sendCondition)
[16:13:58.780]                     ns <- getNamespace("parallel")
[16:13:58.780]                     if (exists("sendData", mode = "function", 
[16:13:58.780]                       envir = ns)) {
[16:13:58.780]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:58.780]                         envir = ns)
[16:13:58.780]                       envir <- sys.frame(frame)
[16:13:58.780]                       master <- NULL
[16:13:58.780]                       while (!identical(envir, .GlobalEnv) && 
[16:13:58.780]                         !identical(envir, emptyenv())) {
[16:13:58.780]                         if (exists("master", mode = "list", envir = envir, 
[16:13:58.780]                           inherits = FALSE)) {
[16:13:58.780]                           master <- get("master", mode = "list", 
[16:13:58.780]                             envir = envir, inherits = FALSE)
[16:13:58.780]                           if (inherits(master, c("SOCKnode", 
[16:13:58.780]                             "SOCK0node"))) {
[16:13:58.780]                             sendCondition <<- function(cond) {
[16:13:58.780]                               data <- list(type = "VALUE", value = cond, 
[16:13:58.780]                                 success = TRUE)
[16:13:58.780]                               parallel_sendData(master, data)
[16:13:58.780]                             }
[16:13:58.780]                             return(sendCondition)
[16:13:58.780]                           }
[16:13:58.780]                         }
[16:13:58.780]                         frame <- frame + 1L
[16:13:58.780]                         envir <- sys.frame(frame)
[16:13:58.780]                       }
[16:13:58.780]                     }
[16:13:58.780]                     sendCondition <<- function(cond) NULL
[16:13:58.780]                   }
[16:13:58.780]                 })
[16:13:58.780]                 withCallingHandlers({
[16:13:58.780]                   {
[16:13:58.780]                     Sys.sleep(0.5)
[16:13:58.780]                     list(a = 1, b = 42L)
[16:13:58.780]                   }
[16:13:58.780]                 }, immediateCondition = function(cond) {
[16:13:58.780]                   sendCondition <- ...future.makeSendCondition()
[16:13:58.780]                   sendCondition(cond)
[16:13:58.780]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:58.780]                   {
[16:13:58.780]                     inherits <- base::inherits
[16:13:58.780]                     invokeRestart <- base::invokeRestart
[16:13:58.780]                     is.null <- base::is.null
[16:13:58.780]                     muffled <- FALSE
[16:13:58.780]                     if (inherits(cond, "message")) {
[16:13:58.780]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:58.780]                       if (muffled) 
[16:13:58.780]                         invokeRestart("muffleMessage")
[16:13:58.780]                     }
[16:13:58.780]                     else if (inherits(cond, "warning")) {
[16:13:58.780]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:58.780]                       if (muffled) 
[16:13:58.780]                         invokeRestart("muffleWarning")
[16:13:58.780]                     }
[16:13:58.780]                     else if (inherits(cond, "condition")) {
[16:13:58.780]                       if (!is.null(pattern)) {
[16:13:58.780]                         computeRestarts <- base::computeRestarts
[16:13:58.780]                         grepl <- base::grepl
[16:13:58.780]                         restarts <- computeRestarts(cond)
[16:13:58.780]                         for (restart in restarts) {
[16:13:58.780]                           name <- restart$name
[16:13:58.780]                           if (is.null(name)) 
[16:13:58.780]                             next
[16:13:58.780]                           if (!grepl(pattern, name)) 
[16:13:58.780]                             next
[16:13:58.780]                           invokeRestart(restart)
[16:13:58.780]                           muffled <- TRUE
[16:13:58.780]                           break
[16:13:58.780]                         }
[16:13:58.780]                       }
[16:13:58.780]                     }
[16:13:58.780]                     invisible(muffled)
[16:13:58.780]                   }
[16:13:58.780]                   muffleCondition(cond)
[16:13:58.780]                 })
[16:13:58.780]             }))
[16:13:58.780]             future::FutureResult(value = ...future.value$value, 
[16:13:58.780]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:58.780]                   ...future.rng), globalenv = if (FALSE) 
[16:13:58.780]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:58.780]                     ...future.globalenv.names))
[16:13:58.780]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:58.780]         }, condition = base::local({
[16:13:58.780]             c <- base::c
[16:13:58.780]             inherits <- base::inherits
[16:13:58.780]             invokeRestart <- base::invokeRestart
[16:13:58.780]             length <- base::length
[16:13:58.780]             list <- base::list
[16:13:58.780]             seq.int <- base::seq.int
[16:13:58.780]             signalCondition <- base::signalCondition
[16:13:58.780]             sys.calls <- base::sys.calls
[16:13:58.780]             `[[` <- base::`[[`
[16:13:58.780]             `+` <- base::`+`
[16:13:58.780]             `<<-` <- base::`<<-`
[16:13:58.780]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:58.780]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:58.780]                   3L)]
[16:13:58.780]             }
[16:13:58.780]             function(cond) {
[16:13:58.780]                 is_error <- inherits(cond, "error")
[16:13:58.780]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:58.780]                   NULL)
[16:13:58.780]                 if (is_error) {
[16:13:58.780]                   sessionInformation <- function() {
[16:13:58.780]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:58.780]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:58.780]                       search = base::search(), system = base::Sys.info())
[16:13:58.780]                   }
[16:13:58.780]                   ...future.conditions[[length(...future.conditions) + 
[16:13:58.780]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:58.780]                     cond$call), session = sessionInformation(), 
[16:13:58.780]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:58.780]                   signalCondition(cond)
[16:13:58.780]                 }
[16:13:58.780]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:58.780]                 "immediateCondition"))) {
[16:13:58.780]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:58.780]                   ...future.conditions[[length(...future.conditions) + 
[16:13:58.780]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:58.780]                   if (TRUE && !signal) {
[16:13:58.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:58.780]                     {
[16:13:58.780]                       inherits <- base::inherits
[16:13:58.780]                       invokeRestart <- base::invokeRestart
[16:13:58.780]                       is.null <- base::is.null
[16:13:58.780]                       muffled <- FALSE
[16:13:58.780]                       if (inherits(cond, "message")) {
[16:13:58.780]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:58.780]                         if (muffled) 
[16:13:58.780]                           invokeRestart("muffleMessage")
[16:13:58.780]                       }
[16:13:58.780]                       else if (inherits(cond, "warning")) {
[16:13:58.780]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:58.780]                         if (muffled) 
[16:13:58.780]                           invokeRestart("muffleWarning")
[16:13:58.780]                       }
[16:13:58.780]                       else if (inherits(cond, "condition")) {
[16:13:58.780]                         if (!is.null(pattern)) {
[16:13:58.780]                           computeRestarts <- base::computeRestarts
[16:13:58.780]                           grepl <- base::grepl
[16:13:58.780]                           restarts <- computeRestarts(cond)
[16:13:58.780]                           for (restart in restarts) {
[16:13:58.780]                             name <- restart$name
[16:13:58.780]                             if (is.null(name)) 
[16:13:58.780]                               next
[16:13:58.780]                             if (!grepl(pattern, name)) 
[16:13:58.780]                               next
[16:13:58.780]                             invokeRestart(restart)
[16:13:58.780]                             muffled <- TRUE
[16:13:58.780]                             break
[16:13:58.780]                           }
[16:13:58.780]                         }
[16:13:58.780]                       }
[16:13:58.780]                       invisible(muffled)
[16:13:58.780]                     }
[16:13:58.780]                     muffleCondition(cond, pattern = "^muffle")
[16:13:58.780]                   }
[16:13:58.780]                 }
[16:13:58.780]                 else {
[16:13:58.780]                   if (TRUE) {
[16:13:58.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:58.780]                     {
[16:13:58.780]                       inherits <- base::inherits
[16:13:58.780]                       invokeRestart <- base::invokeRestart
[16:13:58.780]                       is.null <- base::is.null
[16:13:58.780]                       muffled <- FALSE
[16:13:58.780]                       if (inherits(cond, "message")) {
[16:13:58.780]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:58.780]                         if (muffled) 
[16:13:58.780]                           invokeRestart("muffleMessage")
[16:13:58.780]                       }
[16:13:58.780]                       else if (inherits(cond, "warning")) {
[16:13:58.780]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:58.780]                         if (muffled) 
[16:13:58.780]                           invokeRestart("muffleWarning")
[16:13:58.780]                       }
[16:13:58.780]                       else if (inherits(cond, "condition")) {
[16:13:58.780]                         if (!is.null(pattern)) {
[16:13:58.780]                           computeRestarts <- base::computeRestarts
[16:13:58.780]                           grepl <- base::grepl
[16:13:58.780]                           restarts <- computeRestarts(cond)
[16:13:58.780]                           for (restart in restarts) {
[16:13:58.780]                             name <- restart$name
[16:13:58.780]                             if (is.null(name)) 
[16:13:58.780]                               next
[16:13:58.780]                             if (!grepl(pattern, name)) 
[16:13:58.780]                               next
[16:13:58.780]                             invokeRestart(restart)
[16:13:58.780]                             muffled <- TRUE
[16:13:58.780]                             break
[16:13:58.780]                           }
[16:13:58.780]                         }
[16:13:58.780]                       }
[16:13:58.780]                       invisible(muffled)
[16:13:58.780]                     }
[16:13:58.780]                     muffleCondition(cond, pattern = "^muffle")
[16:13:58.780]                   }
[16:13:58.780]                 }
[16:13:58.780]             }
[16:13:58.780]         }))
[16:13:58.780]     }, error = function(ex) {
[16:13:58.780]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:58.780]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:58.780]                 ...future.rng), started = ...future.startTime, 
[16:13:58.780]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:58.780]             version = "1.8"), class = "FutureResult")
[16:13:58.780]     }, finally = {
[16:13:58.780]         if (!identical(...future.workdir, getwd())) 
[16:13:58.780]             setwd(...future.workdir)
[16:13:58.780]         {
[16:13:58.780]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:58.780]                 ...future.oldOptions$nwarnings <- NULL
[16:13:58.780]             }
[16:13:58.780]             base::options(...future.oldOptions)
[16:13:58.780]             if (.Platform$OS.type == "windows") {
[16:13:58.780]                 old_names <- names(...future.oldEnvVars)
[16:13:58.780]                 envs <- base::Sys.getenv()
[16:13:58.780]                 names <- names(envs)
[16:13:58.780]                 common <- intersect(names, old_names)
[16:13:58.780]                 added <- setdiff(names, old_names)
[16:13:58.780]                 removed <- setdiff(old_names, names)
[16:13:58.780]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:58.780]                   envs[common]]
[16:13:58.780]                 NAMES <- toupper(changed)
[16:13:58.780]                 args <- list()
[16:13:58.780]                 for (kk in seq_along(NAMES)) {
[16:13:58.780]                   name <- changed[[kk]]
[16:13:58.780]                   NAME <- NAMES[[kk]]
[16:13:58.780]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:58.780]                     next
[16:13:58.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:58.780]                 }
[16:13:58.780]                 NAMES <- toupper(added)
[16:13:58.780]                 for (kk in seq_along(NAMES)) {
[16:13:58.780]                   name <- added[[kk]]
[16:13:58.780]                   NAME <- NAMES[[kk]]
[16:13:58.780]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:58.780]                     next
[16:13:58.780]                   args[[name]] <- ""
[16:13:58.780]                 }
[16:13:58.780]                 NAMES <- toupper(removed)
[16:13:58.780]                 for (kk in seq_along(NAMES)) {
[16:13:58.780]                   name <- removed[[kk]]
[16:13:58.780]                   NAME <- NAMES[[kk]]
[16:13:58.780]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:58.780]                     next
[16:13:58.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:58.780]                 }
[16:13:58.780]                 if (length(args) > 0) 
[16:13:58.780]                   base::do.call(base::Sys.setenv, args = args)
[16:13:58.780]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:58.780]             }
[16:13:58.780]             else {
[16:13:58.780]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:58.780]             }
[16:13:58.780]             {
[16:13:58.780]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:58.780]                   0L) {
[16:13:58.780]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:58.780]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:58.780]                   base::options(opts)
[16:13:58.780]                 }
[16:13:58.780]                 {
[16:13:58.780]                   {
[16:13:58.780]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:58.780]                     NULL
[16:13:58.780]                   }
[16:13:58.780]                   options(future.plan = NULL)
[16:13:58.780]                   if (is.na(NA_character_)) 
[16:13:58.780]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:58.780]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:58.780]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:58.780]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:58.780]                     envir = parent.frame()) 
[16:13:58.780]                   {
[16:13:58.780]                     if (is.function(workers)) 
[16:13:58.780]                       workers <- workers()
[16:13:58.780]                     workers <- structure(as.integer(workers), 
[16:13:58.780]                       class = class(workers))
[16:13:58.780]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:58.780]                       workers >= 1)
[16:13:58.780]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:58.780]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:58.780]                     }
[16:13:58.780]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:58.780]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:58.780]                       envir = envir)
[16:13:58.780]                     if (!future$lazy) 
[16:13:58.780]                       future <- run(future)
[16:13:58.780]                     invisible(future)
[16:13:58.780]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:58.780]                 }
[16:13:58.780]             }
[16:13:58.780]         }
[16:13:58.780]     })
[16:13:58.780]     if (TRUE) {
[16:13:58.780]         base::sink(type = "output", split = FALSE)
[16:13:58.780]         if (TRUE) {
[16:13:58.780]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:58.780]         }
[16:13:58.780]         else {
[16:13:58.780]             ...future.result["stdout"] <- base::list(NULL)
[16:13:58.780]         }
[16:13:58.780]         base::close(...future.stdout)
[16:13:58.780]         ...future.stdout <- NULL
[16:13:58.780]     }
[16:13:58.780]     ...future.result$conditions <- ...future.conditions
[16:13:58.780]     ...future.result$finished <- base::Sys.time()
[16:13:58.780]     ...future.result
[16:13:58.780] }
[16:13:58.783] MultisessionFuture started
[16:13:58.783] - Launch lazy future ... done
[16:13:58.784] run() for ‘MultisessionFuture’ ... done
[16:13:59.330] receiveMessageFromWorker() for ClusterFuture ...
[16:13:59.330] - Validating connection of MultisessionFuture
[16:13:59.330] - received message: FutureResult
[16:13:59.330] - Received FutureResult
[16:13:59.330] - Erased future from FutureRegistry
[16:13:59.330] result() for ClusterFuture ...
[16:13:59.331] - result already collected: FutureResult
[16:13:59.331] result() for ClusterFuture ... done
[16:13:59.331] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:59.331] resolve() on list ...
[16:13:59.331]  recursive: Inf
[16:13:59.331]  length: 2
[16:13:59.331]  elements: ‘a’, ‘b’
[16:13:59.331]  length: 1 (resolved future 1)
[16:13:59.331]  length: 0 (resolved future 2)
[16:13:59.331] resolve() on list ... DONE
[16:13:59.332] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[16:13:59.334] getGlobalsAndPackages() ...
[16:13:59.334] Searching for globals...
[16:13:59.335] - globals found: [2] ‘list’, ‘stop’
[16:13:59.335] Searching for globals ... DONE
[16:13:59.335] Resolving globals: FALSE
[16:13:59.336] 
[16:13:59.336] 
[16:13:59.336] getGlobalsAndPackages() ... DONE
[16:13:59.336] run() for ‘Future’ ...
[16:13:59.336] - state: ‘created’
[16:13:59.336] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:59.350] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:59.350] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:59.351]   - Field: ‘node’
[16:13:59.351]   - Field: ‘label’
[16:13:59.351]   - Field: ‘local’
[16:13:59.351]   - Field: ‘owner’
[16:13:59.351]   - Field: ‘envir’
[16:13:59.351]   - Field: ‘workers’
[16:13:59.351]   - Field: ‘packages’
[16:13:59.351]   - Field: ‘gc’
[16:13:59.351]   - Field: ‘conditions’
[16:13:59.351]   - Field: ‘persistent’
[16:13:59.352]   - Field: ‘expr’
[16:13:59.352]   - Field: ‘uuid’
[16:13:59.352]   - Field: ‘seed’
[16:13:59.352]   - Field: ‘version’
[16:13:59.352]   - Field: ‘result’
[16:13:59.352]   - Field: ‘asynchronous’
[16:13:59.352]   - Field: ‘calls’
[16:13:59.352]   - Field: ‘globals’
[16:13:59.352]   - Field: ‘stdout’
[16:13:59.352]   - Field: ‘earlySignal’
[16:13:59.352]   - Field: ‘lazy’
[16:13:59.352]   - Field: ‘state’
[16:13:59.353] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:59.353] - Launch lazy future ...
[16:13:59.353] Packages needed by the future expression (n = 0): <none>
[16:13:59.353] Packages needed by future strategies (n = 0): <none>
[16:13:59.353] {
[16:13:59.353]     {
[16:13:59.353]         {
[16:13:59.353]             ...future.startTime <- base::Sys.time()
[16:13:59.353]             {
[16:13:59.353]                 {
[16:13:59.353]                   {
[16:13:59.353]                     {
[16:13:59.353]                       base::local({
[16:13:59.353]                         has_future <- base::requireNamespace("future", 
[16:13:59.353]                           quietly = TRUE)
[16:13:59.353]                         if (has_future) {
[16:13:59.353]                           ns <- base::getNamespace("future")
[16:13:59.353]                           version <- ns[[".package"]][["version"]]
[16:13:59.353]                           if (is.null(version)) 
[16:13:59.353]                             version <- utils::packageVersion("future")
[16:13:59.353]                         }
[16:13:59.353]                         else {
[16:13:59.353]                           version <- NULL
[16:13:59.353]                         }
[16:13:59.353]                         if (!has_future || version < "1.8.0") {
[16:13:59.353]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:59.353]                             "", base::R.version$version.string), 
[16:13:59.353]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:59.353]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:59.353]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:59.353]                               "release", "version")], collapse = " "), 
[16:13:59.353]                             hostname = base::Sys.info()[["nodename"]])
[16:13:59.353]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:59.353]                             info)
[16:13:59.353]                           info <- base::paste(info, collapse = "; ")
[16:13:59.353]                           if (!has_future) {
[16:13:59.353]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:59.353]                               info)
[16:13:59.353]                           }
[16:13:59.353]                           else {
[16:13:59.353]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:59.353]                               info, version)
[16:13:59.353]                           }
[16:13:59.353]                           base::stop(msg)
[16:13:59.353]                         }
[16:13:59.353]                       })
[16:13:59.353]                     }
[16:13:59.353]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:59.353]                     base::options(mc.cores = 1L)
[16:13:59.353]                   }
[16:13:59.353]                   options(future.plan = NULL)
[16:13:59.353]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:59.353]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:59.353]                 }
[16:13:59.353]                 ...future.workdir <- getwd()
[16:13:59.353]             }
[16:13:59.353]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:59.353]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:59.353]         }
[16:13:59.353]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:59.353]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:59.353]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:59.353]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:59.353]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:59.353]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:59.353]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:59.353]             base::names(...future.oldOptions))
[16:13:59.353]     }
[16:13:59.353]     if (FALSE) {
[16:13:59.353]     }
[16:13:59.353]     else {
[16:13:59.353]         if (TRUE) {
[16:13:59.353]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:59.353]                 open = "w")
[16:13:59.353]         }
[16:13:59.353]         else {
[16:13:59.353]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:59.353]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:59.353]         }
[16:13:59.353]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:59.353]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:59.353]             base::sink(type = "output", split = FALSE)
[16:13:59.353]             base::close(...future.stdout)
[16:13:59.353]         }, add = TRUE)
[16:13:59.353]     }
[16:13:59.353]     ...future.frame <- base::sys.nframe()
[16:13:59.353]     ...future.conditions <- base::list()
[16:13:59.353]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:59.353]     if (FALSE) {
[16:13:59.353]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:59.353]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:59.353]     }
[16:13:59.353]     ...future.result <- base::tryCatch({
[16:13:59.353]         base::withCallingHandlers({
[16:13:59.353]             ...future.value <- base::withVisible(base::local({
[16:13:59.353]                 ...future.makeSendCondition <- local({
[16:13:59.353]                   sendCondition <- NULL
[16:13:59.353]                   function(frame = 1L) {
[16:13:59.353]                     if (is.function(sendCondition)) 
[16:13:59.353]                       return(sendCondition)
[16:13:59.353]                     ns <- getNamespace("parallel")
[16:13:59.353]                     if (exists("sendData", mode = "function", 
[16:13:59.353]                       envir = ns)) {
[16:13:59.353]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:59.353]                         envir = ns)
[16:13:59.353]                       envir <- sys.frame(frame)
[16:13:59.353]                       master <- NULL
[16:13:59.353]                       while (!identical(envir, .GlobalEnv) && 
[16:13:59.353]                         !identical(envir, emptyenv())) {
[16:13:59.353]                         if (exists("master", mode = "list", envir = envir, 
[16:13:59.353]                           inherits = FALSE)) {
[16:13:59.353]                           master <- get("master", mode = "list", 
[16:13:59.353]                             envir = envir, inherits = FALSE)
[16:13:59.353]                           if (inherits(master, c("SOCKnode", 
[16:13:59.353]                             "SOCK0node"))) {
[16:13:59.353]                             sendCondition <<- function(cond) {
[16:13:59.353]                               data <- list(type = "VALUE", value = cond, 
[16:13:59.353]                                 success = TRUE)
[16:13:59.353]                               parallel_sendData(master, data)
[16:13:59.353]                             }
[16:13:59.353]                             return(sendCondition)
[16:13:59.353]                           }
[16:13:59.353]                         }
[16:13:59.353]                         frame <- frame + 1L
[16:13:59.353]                         envir <- sys.frame(frame)
[16:13:59.353]                       }
[16:13:59.353]                     }
[16:13:59.353]                     sendCondition <<- function(cond) NULL
[16:13:59.353]                   }
[16:13:59.353]                 })
[16:13:59.353]                 withCallingHandlers({
[16:13:59.353]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:59.353]                 }, immediateCondition = function(cond) {
[16:13:59.353]                   sendCondition <- ...future.makeSendCondition()
[16:13:59.353]                   sendCondition(cond)
[16:13:59.353]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.353]                   {
[16:13:59.353]                     inherits <- base::inherits
[16:13:59.353]                     invokeRestart <- base::invokeRestart
[16:13:59.353]                     is.null <- base::is.null
[16:13:59.353]                     muffled <- FALSE
[16:13:59.353]                     if (inherits(cond, "message")) {
[16:13:59.353]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:59.353]                       if (muffled) 
[16:13:59.353]                         invokeRestart("muffleMessage")
[16:13:59.353]                     }
[16:13:59.353]                     else if (inherits(cond, "warning")) {
[16:13:59.353]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:59.353]                       if (muffled) 
[16:13:59.353]                         invokeRestart("muffleWarning")
[16:13:59.353]                     }
[16:13:59.353]                     else if (inherits(cond, "condition")) {
[16:13:59.353]                       if (!is.null(pattern)) {
[16:13:59.353]                         computeRestarts <- base::computeRestarts
[16:13:59.353]                         grepl <- base::grepl
[16:13:59.353]                         restarts <- computeRestarts(cond)
[16:13:59.353]                         for (restart in restarts) {
[16:13:59.353]                           name <- restart$name
[16:13:59.353]                           if (is.null(name)) 
[16:13:59.353]                             next
[16:13:59.353]                           if (!grepl(pattern, name)) 
[16:13:59.353]                             next
[16:13:59.353]                           invokeRestart(restart)
[16:13:59.353]                           muffled <- TRUE
[16:13:59.353]                           break
[16:13:59.353]                         }
[16:13:59.353]                       }
[16:13:59.353]                     }
[16:13:59.353]                     invisible(muffled)
[16:13:59.353]                   }
[16:13:59.353]                   muffleCondition(cond)
[16:13:59.353]                 })
[16:13:59.353]             }))
[16:13:59.353]             future::FutureResult(value = ...future.value$value, 
[16:13:59.353]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:59.353]                   ...future.rng), globalenv = if (FALSE) 
[16:13:59.353]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:59.353]                     ...future.globalenv.names))
[16:13:59.353]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:59.353]         }, condition = base::local({
[16:13:59.353]             c <- base::c
[16:13:59.353]             inherits <- base::inherits
[16:13:59.353]             invokeRestart <- base::invokeRestart
[16:13:59.353]             length <- base::length
[16:13:59.353]             list <- base::list
[16:13:59.353]             seq.int <- base::seq.int
[16:13:59.353]             signalCondition <- base::signalCondition
[16:13:59.353]             sys.calls <- base::sys.calls
[16:13:59.353]             `[[` <- base::`[[`
[16:13:59.353]             `+` <- base::`+`
[16:13:59.353]             `<<-` <- base::`<<-`
[16:13:59.353]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:59.353]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:59.353]                   3L)]
[16:13:59.353]             }
[16:13:59.353]             function(cond) {
[16:13:59.353]                 is_error <- inherits(cond, "error")
[16:13:59.353]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:59.353]                   NULL)
[16:13:59.353]                 if (is_error) {
[16:13:59.353]                   sessionInformation <- function() {
[16:13:59.353]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:59.353]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:59.353]                       search = base::search(), system = base::Sys.info())
[16:13:59.353]                   }
[16:13:59.353]                   ...future.conditions[[length(...future.conditions) + 
[16:13:59.353]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:59.353]                     cond$call), session = sessionInformation(), 
[16:13:59.353]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:59.353]                   signalCondition(cond)
[16:13:59.353]                 }
[16:13:59.353]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:59.353]                 "immediateCondition"))) {
[16:13:59.353]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:59.353]                   ...future.conditions[[length(...future.conditions) + 
[16:13:59.353]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:59.353]                   if (TRUE && !signal) {
[16:13:59.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.353]                     {
[16:13:59.353]                       inherits <- base::inherits
[16:13:59.353]                       invokeRestart <- base::invokeRestart
[16:13:59.353]                       is.null <- base::is.null
[16:13:59.353]                       muffled <- FALSE
[16:13:59.353]                       if (inherits(cond, "message")) {
[16:13:59.353]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:59.353]                         if (muffled) 
[16:13:59.353]                           invokeRestart("muffleMessage")
[16:13:59.353]                       }
[16:13:59.353]                       else if (inherits(cond, "warning")) {
[16:13:59.353]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:59.353]                         if (muffled) 
[16:13:59.353]                           invokeRestart("muffleWarning")
[16:13:59.353]                       }
[16:13:59.353]                       else if (inherits(cond, "condition")) {
[16:13:59.353]                         if (!is.null(pattern)) {
[16:13:59.353]                           computeRestarts <- base::computeRestarts
[16:13:59.353]                           grepl <- base::grepl
[16:13:59.353]                           restarts <- computeRestarts(cond)
[16:13:59.353]                           for (restart in restarts) {
[16:13:59.353]                             name <- restart$name
[16:13:59.353]                             if (is.null(name)) 
[16:13:59.353]                               next
[16:13:59.353]                             if (!grepl(pattern, name)) 
[16:13:59.353]                               next
[16:13:59.353]                             invokeRestart(restart)
[16:13:59.353]                             muffled <- TRUE
[16:13:59.353]                             break
[16:13:59.353]                           }
[16:13:59.353]                         }
[16:13:59.353]                       }
[16:13:59.353]                       invisible(muffled)
[16:13:59.353]                     }
[16:13:59.353]                     muffleCondition(cond, pattern = "^muffle")
[16:13:59.353]                   }
[16:13:59.353]                 }
[16:13:59.353]                 else {
[16:13:59.353]                   if (TRUE) {
[16:13:59.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.353]                     {
[16:13:59.353]                       inherits <- base::inherits
[16:13:59.353]                       invokeRestart <- base::invokeRestart
[16:13:59.353]                       is.null <- base::is.null
[16:13:59.353]                       muffled <- FALSE
[16:13:59.353]                       if (inherits(cond, "message")) {
[16:13:59.353]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:59.353]                         if (muffled) 
[16:13:59.353]                           invokeRestart("muffleMessage")
[16:13:59.353]                       }
[16:13:59.353]                       else if (inherits(cond, "warning")) {
[16:13:59.353]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:59.353]                         if (muffled) 
[16:13:59.353]                           invokeRestart("muffleWarning")
[16:13:59.353]                       }
[16:13:59.353]                       else if (inherits(cond, "condition")) {
[16:13:59.353]                         if (!is.null(pattern)) {
[16:13:59.353]                           computeRestarts <- base::computeRestarts
[16:13:59.353]                           grepl <- base::grepl
[16:13:59.353]                           restarts <- computeRestarts(cond)
[16:13:59.353]                           for (restart in restarts) {
[16:13:59.353]                             name <- restart$name
[16:13:59.353]                             if (is.null(name)) 
[16:13:59.353]                               next
[16:13:59.353]                             if (!grepl(pattern, name)) 
[16:13:59.353]                               next
[16:13:59.353]                             invokeRestart(restart)
[16:13:59.353]                             muffled <- TRUE
[16:13:59.353]                             break
[16:13:59.353]                           }
[16:13:59.353]                         }
[16:13:59.353]                       }
[16:13:59.353]                       invisible(muffled)
[16:13:59.353]                     }
[16:13:59.353]                     muffleCondition(cond, pattern = "^muffle")
[16:13:59.353]                   }
[16:13:59.353]                 }
[16:13:59.353]             }
[16:13:59.353]         }))
[16:13:59.353]     }, error = function(ex) {
[16:13:59.353]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:59.353]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:59.353]                 ...future.rng), started = ...future.startTime, 
[16:13:59.353]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:59.353]             version = "1.8"), class = "FutureResult")
[16:13:59.353]     }, finally = {
[16:13:59.353]         if (!identical(...future.workdir, getwd())) 
[16:13:59.353]             setwd(...future.workdir)
[16:13:59.353]         {
[16:13:59.353]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:59.353]                 ...future.oldOptions$nwarnings <- NULL
[16:13:59.353]             }
[16:13:59.353]             base::options(...future.oldOptions)
[16:13:59.353]             if (.Platform$OS.type == "windows") {
[16:13:59.353]                 old_names <- names(...future.oldEnvVars)
[16:13:59.353]                 envs <- base::Sys.getenv()
[16:13:59.353]                 names <- names(envs)
[16:13:59.353]                 common <- intersect(names, old_names)
[16:13:59.353]                 added <- setdiff(names, old_names)
[16:13:59.353]                 removed <- setdiff(old_names, names)
[16:13:59.353]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:59.353]                   envs[common]]
[16:13:59.353]                 NAMES <- toupper(changed)
[16:13:59.353]                 args <- list()
[16:13:59.353]                 for (kk in seq_along(NAMES)) {
[16:13:59.353]                   name <- changed[[kk]]
[16:13:59.353]                   NAME <- NAMES[[kk]]
[16:13:59.353]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.353]                     next
[16:13:59.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:59.353]                 }
[16:13:59.353]                 NAMES <- toupper(added)
[16:13:59.353]                 for (kk in seq_along(NAMES)) {
[16:13:59.353]                   name <- added[[kk]]
[16:13:59.353]                   NAME <- NAMES[[kk]]
[16:13:59.353]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.353]                     next
[16:13:59.353]                   args[[name]] <- ""
[16:13:59.353]                 }
[16:13:59.353]                 NAMES <- toupper(removed)
[16:13:59.353]                 for (kk in seq_along(NAMES)) {
[16:13:59.353]                   name <- removed[[kk]]
[16:13:59.353]                   NAME <- NAMES[[kk]]
[16:13:59.353]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.353]                     next
[16:13:59.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:59.353]                 }
[16:13:59.353]                 if (length(args) > 0) 
[16:13:59.353]                   base::do.call(base::Sys.setenv, args = args)
[16:13:59.353]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:59.353]             }
[16:13:59.353]             else {
[16:13:59.353]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:59.353]             }
[16:13:59.353]             {
[16:13:59.353]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:59.353]                   0L) {
[16:13:59.353]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:59.353]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:59.353]                   base::options(opts)
[16:13:59.353]                 }
[16:13:59.353]                 {
[16:13:59.353]                   {
[16:13:59.353]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:59.353]                     NULL
[16:13:59.353]                   }
[16:13:59.353]                   options(future.plan = NULL)
[16:13:59.353]                   if (is.na(NA_character_)) 
[16:13:59.353]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:59.353]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:59.353]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:59.353]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:59.353]                     envir = parent.frame()) 
[16:13:59.353]                   {
[16:13:59.353]                     if (is.function(workers)) 
[16:13:59.353]                       workers <- workers()
[16:13:59.353]                     workers <- structure(as.integer(workers), 
[16:13:59.353]                       class = class(workers))
[16:13:59.353]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:59.353]                       workers >= 1)
[16:13:59.353]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:59.353]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:59.353]                     }
[16:13:59.353]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:59.353]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:59.353]                       envir = envir)
[16:13:59.353]                     if (!future$lazy) 
[16:13:59.353]                       future <- run(future)
[16:13:59.353]                     invisible(future)
[16:13:59.353]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:59.353]                 }
[16:13:59.353]             }
[16:13:59.353]         }
[16:13:59.353]     })
[16:13:59.353]     if (TRUE) {
[16:13:59.353]         base::sink(type = "output", split = FALSE)
[16:13:59.353]         if (TRUE) {
[16:13:59.353]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:59.353]         }
[16:13:59.353]         else {
[16:13:59.353]             ...future.result["stdout"] <- base::list(NULL)
[16:13:59.353]         }
[16:13:59.353]         base::close(...future.stdout)
[16:13:59.353]         ...future.stdout <- NULL
[16:13:59.353]     }
[16:13:59.353]     ...future.result$conditions <- ...future.conditions
[16:13:59.353]     ...future.result$finished <- base::Sys.time()
[16:13:59.353]     ...future.result
[16:13:59.353] }
[16:13:59.357] MultisessionFuture started
[16:13:59.357] - Launch lazy future ... done
[16:13:59.357] run() for ‘MultisessionFuture’ ... done
[16:13:59.404] receiveMessageFromWorker() for ClusterFuture ...
[16:13:59.405] - Validating connection of MultisessionFuture
[16:13:59.405] - received message: FutureResult
[16:13:59.405] - Received FutureResult
[16:13:59.405] - Erased future from FutureRegistry
[16:13:59.405] result() for ClusterFuture ...
[16:13:59.405] - result already collected: FutureResult
[16:13:59.405] result() for ClusterFuture ... done
[16:13:59.406] signalConditions() ...
[16:13:59.406]  - include = ‘immediateCondition’
[16:13:59.406]  - exclude = 
[16:13:59.406]  - resignal = FALSE
[16:13:59.406]  - Number of conditions: 1
[16:13:59.406] signalConditions() ... done
[16:13:59.406] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:59.406] A MultisessionFuture was resolved
[16:13:59.406] getGlobalsAndPackages() ...
[16:13:59.406] Searching for globals...
[16:13:59.407] - globals found: [2] ‘list’, ‘stop’
[16:13:59.407] Searching for globals ... DONE
[16:13:59.407] Resolving globals: FALSE
[16:13:59.407] 
[16:13:59.408] 
[16:13:59.408] getGlobalsAndPackages() ... DONE
[16:13:59.408] run() for ‘Future’ ...
[16:13:59.408] - state: ‘created’
[16:13:59.408] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:59.422] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:59.423] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:59.423]   - Field: ‘node’
[16:13:59.423]   - Field: ‘label’
[16:13:59.423]   - Field: ‘local’
[16:13:59.423]   - Field: ‘owner’
[16:13:59.423]   - Field: ‘envir’
[16:13:59.423]   - Field: ‘workers’
[16:13:59.423]   - Field: ‘packages’
[16:13:59.423]   - Field: ‘gc’
[16:13:59.423]   - Field: ‘conditions’
[16:13:59.424]   - Field: ‘persistent’
[16:13:59.424]   - Field: ‘expr’
[16:13:59.424]   - Field: ‘uuid’
[16:13:59.424]   - Field: ‘seed’
[16:13:59.424]   - Field: ‘version’
[16:13:59.424]   - Field: ‘result’
[16:13:59.424]   - Field: ‘asynchronous’
[16:13:59.424]   - Field: ‘calls’
[16:13:59.424]   - Field: ‘globals’
[16:13:59.424]   - Field: ‘stdout’
[16:13:59.424]   - Field: ‘earlySignal’
[16:13:59.425]   - Field: ‘lazy’
[16:13:59.425]   - Field: ‘state’
[16:13:59.425] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:59.425] - Launch lazy future ...
[16:13:59.425] Packages needed by the future expression (n = 0): <none>
[16:13:59.425] Packages needed by future strategies (n = 0): <none>
[16:13:59.426] {
[16:13:59.426]     {
[16:13:59.426]         {
[16:13:59.426]             ...future.startTime <- base::Sys.time()
[16:13:59.426]             {
[16:13:59.426]                 {
[16:13:59.426]                   {
[16:13:59.426]                     {
[16:13:59.426]                       base::local({
[16:13:59.426]                         has_future <- base::requireNamespace("future", 
[16:13:59.426]                           quietly = TRUE)
[16:13:59.426]                         if (has_future) {
[16:13:59.426]                           ns <- base::getNamespace("future")
[16:13:59.426]                           version <- ns[[".package"]][["version"]]
[16:13:59.426]                           if (is.null(version)) 
[16:13:59.426]                             version <- utils::packageVersion("future")
[16:13:59.426]                         }
[16:13:59.426]                         else {
[16:13:59.426]                           version <- NULL
[16:13:59.426]                         }
[16:13:59.426]                         if (!has_future || version < "1.8.0") {
[16:13:59.426]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:59.426]                             "", base::R.version$version.string), 
[16:13:59.426]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:59.426]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:59.426]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:59.426]                               "release", "version")], collapse = " "), 
[16:13:59.426]                             hostname = base::Sys.info()[["nodename"]])
[16:13:59.426]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:59.426]                             info)
[16:13:59.426]                           info <- base::paste(info, collapse = "; ")
[16:13:59.426]                           if (!has_future) {
[16:13:59.426]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:59.426]                               info)
[16:13:59.426]                           }
[16:13:59.426]                           else {
[16:13:59.426]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:59.426]                               info, version)
[16:13:59.426]                           }
[16:13:59.426]                           base::stop(msg)
[16:13:59.426]                         }
[16:13:59.426]                       })
[16:13:59.426]                     }
[16:13:59.426]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:59.426]                     base::options(mc.cores = 1L)
[16:13:59.426]                   }
[16:13:59.426]                   options(future.plan = NULL)
[16:13:59.426]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:59.426]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:59.426]                 }
[16:13:59.426]                 ...future.workdir <- getwd()
[16:13:59.426]             }
[16:13:59.426]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:59.426]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:59.426]         }
[16:13:59.426]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:59.426]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:59.426]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:59.426]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:59.426]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:59.426]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:59.426]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:59.426]             base::names(...future.oldOptions))
[16:13:59.426]     }
[16:13:59.426]     if (FALSE) {
[16:13:59.426]     }
[16:13:59.426]     else {
[16:13:59.426]         if (TRUE) {
[16:13:59.426]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:59.426]                 open = "w")
[16:13:59.426]         }
[16:13:59.426]         else {
[16:13:59.426]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:59.426]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:59.426]         }
[16:13:59.426]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:59.426]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:59.426]             base::sink(type = "output", split = FALSE)
[16:13:59.426]             base::close(...future.stdout)
[16:13:59.426]         }, add = TRUE)
[16:13:59.426]     }
[16:13:59.426]     ...future.frame <- base::sys.nframe()
[16:13:59.426]     ...future.conditions <- base::list()
[16:13:59.426]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:59.426]     if (FALSE) {
[16:13:59.426]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:59.426]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:59.426]     }
[16:13:59.426]     ...future.result <- base::tryCatch({
[16:13:59.426]         base::withCallingHandlers({
[16:13:59.426]             ...future.value <- base::withVisible(base::local({
[16:13:59.426]                 ...future.makeSendCondition <- local({
[16:13:59.426]                   sendCondition <- NULL
[16:13:59.426]                   function(frame = 1L) {
[16:13:59.426]                     if (is.function(sendCondition)) 
[16:13:59.426]                       return(sendCondition)
[16:13:59.426]                     ns <- getNamespace("parallel")
[16:13:59.426]                     if (exists("sendData", mode = "function", 
[16:13:59.426]                       envir = ns)) {
[16:13:59.426]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:59.426]                         envir = ns)
[16:13:59.426]                       envir <- sys.frame(frame)
[16:13:59.426]                       master <- NULL
[16:13:59.426]                       while (!identical(envir, .GlobalEnv) && 
[16:13:59.426]                         !identical(envir, emptyenv())) {
[16:13:59.426]                         if (exists("master", mode = "list", envir = envir, 
[16:13:59.426]                           inherits = FALSE)) {
[16:13:59.426]                           master <- get("master", mode = "list", 
[16:13:59.426]                             envir = envir, inherits = FALSE)
[16:13:59.426]                           if (inherits(master, c("SOCKnode", 
[16:13:59.426]                             "SOCK0node"))) {
[16:13:59.426]                             sendCondition <<- function(cond) {
[16:13:59.426]                               data <- list(type = "VALUE", value = cond, 
[16:13:59.426]                                 success = TRUE)
[16:13:59.426]                               parallel_sendData(master, data)
[16:13:59.426]                             }
[16:13:59.426]                             return(sendCondition)
[16:13:59.426]                           }
[16:13:59.426]                         }
[16:13:59.426]                         frame <- frame + 1L
[16:13:59.426]                         envir <- sys.frame(frame)
[16:13:59.426]                       }
[16:13:59.426]                     }
[16:13:59.426]                     sendCondition <<- function(cond) NULL
[16:13:59.426]                   }
[16:13:59.426]                 })
[16:13:59.426]                 withCallingHandlers({
[16:13:59.426]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:13:59.426]                 }, immediateCondition = function(cond) {
[16:13:59.426]                   sendCondition <- ...future.makeSendCondition()
[16:13:59.426]                   sendCondition(cond)
[16:13:59.426]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.426]                   {
[16:13:59.426]                     inherits <- base::inherits
[16:13:59.426]                     invokeRestart <- base::invokeRestart
[16:13:59.426]                     is.null <- base::is.null
[16:13:59.426]                     muffled <- FALSE
[16:13:59.426]                     if (inherits(cond, "message")) {
[16:13:59.426]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:59.426]                       if (muffled) 
[16:13:59.426]                         invokeRestart("muffleMessage")
[16:13:59.426]                     }
[16:13:59.426]                     else if (inherits(cond, "warning")) {
[16:13:59.426]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:59.426]                       if (muffled) 
[16:13:59.426]                         invokeRestart("muffleWarning")
[16:13:59.426]                     }
[16:13:59.426]                     else if (inherits(cond, "condition")) {
[16:13:59.426]                       if (!is.null(pattern)) {
[16:13:59.426]                         computeRestarts <- base::computeRestarts
[16:13:59.426]                         grepl <- base::grepl
[16:13:59.426]                         restarts <- computeRestarts(cond)
[16:13:59.426]                         for (restart in restarts) {
[16:13:59.426]                           name <- restart$name
[16:13:59.426]                           if (is.null(name)) 
[16:13:59.426]                             next
[16:13:59.426]                           if (!grepl(pattern, name)) 
[16:13:59.426]                             next
[16:13:59.426]                           invokeRestart(restart)
[16:13:59.426]                           muffled <- TRUE
[16:13:59.426]                           break
[16:13:59.426]                         }
[16:13:59.426]                       }
[16:13:59.426]                     }
[16:13:59.426]                     invisible(muffled)
[16:13:59.426]                   }
[16:13:59.426]                   muffleCondition(cond)
[16:13:59.426]                 })
[16:13:59.426]             }))
[16:13:59.426]             future::FutureResult(value = ...future.value$value, 
[16:13:59.426]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:59.426]                   ...future.rng), globalenv = if (FALSE) 
[16:13:59.426]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:59.426]                     ...future.globalenv.names))
[16:13:59.426]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:59.426]         }, condition = base::local({
[16:13:59.426]             c <- base::c
[16:13:59.426]             inherits <- base::inherits
[16:13:59.426]             invokeRestart <- base::invokeRestart
[16:13:59.426]             length <- base::length
[16:13:59.426]             list <- base::list
[16:13:59.426]             seq.int <- base::seq.int
[16:13:59.426]             signalCondition <- base::signalCondition
[16:13:59.426]             sys.calls <- base::sys.calls
[16:13:59.426]             `[[` <- base::`[[`
[16:13:59.426]             `+` <- base::`+`
[16:13:59.426]             `<<-` <- base::`<<-`
[16:13:59.426]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:59.426]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:59.426]                   3L)]
[16:13:59.426]             }
[16:13:59.426]             function(cond) {
[16:13:59.426]                 is_error <- inherits(cond, "error")
[16:13:59.426]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:59.426]                   NULL)
[16:13:59.426]                 if (is_error) {
[16:13:59.426]                   sessionInformation <- function() {
[16:13:59.426]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:59.426]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:59.426]                       search = base::search(), system = base::Sys.info())
[16:13:59.426]                   }
[16:13:59.426]                   ...future.conditions[[length(...future.conditions) + 
[16:13:59.426]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:59.426]                     cond$call), session = sessionInformation(), 
[16:13:59.426]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:59.426]                   signalCondition(cond)
[16:13:59.426]                 }
[16:13:59.426]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:59.426]                 "immediateCondition"))) {
[16:13:59.426]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:59.426]                   ...future.conditions[[length(...future.conditions) + 
[16:13:59.426]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:59.426]                   if (TRUE && !signal) {
[16:13:59.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.426]                     {
[16:13:59.426]                       inherits <- base::inherits
[16:13:59.426]                       invokeRestart <- base::invokeRestart
[16:13:59.426]                       is.null <- base::is.null
[16:13:59.426]                       muffled <- FALSE
[16:13:59.426]                       if (inherits(cond, "message")) {
[16:13:59.426]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:59.426]                         if (muffled) 
[16:13:59.426]                           invokeRestart("muffleMessage")
[16:13:59.426]                       }
[16:13:59.426]                       else if (inherits(cond, "warning")) {
[16:13:59.426]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:59.426]                         if (muffled) 
[16:13:59.426]                           invokeRestart("muffleWarning")
[16:13:59.426]                       }
[16:13:59.426]                       else if (inherits(cond, "condition")) {
[16:13:59.426]                         if (!is.null(pattern)) {
[16:13:59.426]                           computeRestarts <- base::computeRestarts
[16:13:59.426]                           grepl <- base::grepl
[16:13:59.426]                           restarts <- computeRestarts(cond)
[16:13:59.426]                           for (restart in restarts) {
[16:13:59.426]                             name <- restart$name
[16:13:59.426]                             if (is.null(name)) 
[16:13:59.426]                               next
[16:13:59.426]                             if (!grepl(pattern, name)) 
[16:13:59.426]                               next
[16:13:59.426]                             invokeRestart(restart)
[16:13:59.426]                             muffled <- TRUE
[16:13:59.426]                             break
[16:13:59.426]                           }
[16:13:59.426]                         }
[16:13:59.426]                       }
[16:13:59.426]                       invisible(muffled)
[16:13:59.426]                     }
[16:13:59.426]                     muffleCondition(cond, pattern = "^muffle")
[16:13:59.426]                   }
[16:13:59.426]                 }
[16:13:59.426]                 else {
[16:13:59.426]                   if (TRUE) {
[16:13:59.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.426]                     {
[16:13:59.426]                       inherits <- base::inherits
[16:13:59.426]                       invokeRestart <- base::invokeRestart
[16:13:59.426]                       is.null <- base::is.null
[16:13:59.426]                       muffled <- FALSE
[16:13:59.426]                       if (inherits(cond, "message")) {
[16:13:59.426]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:59.426]                         if (muffled) 
[16:13:59.426]                           invokeRestart("muffleMessage")
[16:13:59.426]                       }
[16:13:59.426]                       else if (inherits(cond, "warning")) {
[16:13:59.426]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:59.426]                         if (muffled) 
[16:13:59.426]                           invokeRestart("muffleWarning")
[16:13:59.426]                       }
[16:13:59.426]                       else if (inherits(cond, "condition")) {
[16:13:59.426]                         if (!is.null(pattern)) {
[16:13:59.426]                           computeRestarts <- base::computeRestarts
[16:13:59.426]                           grepl <- base::grepl
[16:13:59.426]                           restarts <- computeRestarts(cond)
[16:13:59.426]                           for (restart in restarts) {
[16:13:59.426]                             name <- restart$name
[16:13:59.426]                             if (is.null(name)) 
[16:13:59.426]                               next
[16:13:59.426]                             if (!grepl(pattern, name)) 
[16:13:59.426]                               next
[16:13:59.426]                             invokeRestart(restart)
[16:13:59.426]                             muffled <- TRUE
[16:13:59.426]                             break
[16:13:59.426]                           }
[16:13:59.426]                         }
[16:13:59.426]                       }
[16:13:59.426]                       invisible(muffled)
[16:13:59.426]                     }
[16:13:59.426]                     muffleCondition(cond, pattern = "^muffle")
[16:13:59.426]                   }
[16:13:59.426]                 }
[16:13:59.426]             }
[16:13:59.426]         }))
[16:13:59.426]     }, error = function(ex) {
[16:13:59.426]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:59.426]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:59.426]                 ...future.rng), started = ...future.startTime, 
[16:13:59.426]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:59.426]             version = "1.8"), class = "FutureResult")
[16:13:59.426]     }, finally = {
[16:13:59.426]         if (!identical(...future.workdir, getwd())) 
[16:13:59.426]             setwd(...future.workdir)
[16:13:59.426]         {
[16:13:59.426]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:59.426]                 ...future.oldOptions$nwarnings <- NULL
[16:13:59.426]             }
[16:13:59.426]             base::options(...future.oldOptions)
[16:13:59.426]             if (.Platform$OS.type == "windows") {
[16:13:59.426]                 old_names <- names(...future.oldEnvVars)
[16:13:59.426]                 envs <- base::Sys.getenv()
[16:13:59.426]                 names <- names(envs)
[16:13:59.426]                 common <- intersect(names, old_names)
[16:13:59.426]                 added <- setdiff(names, old_names)
[16:13:59.426]                 removed <- setdiff(old_names, names)
[16:13:59.426]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:59.426]                   envs[common]]
[16:13:59.426]                 NAMES <- toupper(changed)
[16:13:59.426]                 args <- list()
[16:13:59.426]                 for (kk in seq_along(NAMES)) {
[16:13:59.426]                   name <- changed[[kk]]
[16:13:59.426]                   NAME <- NAMES[[kk]]
[16:13:59.426]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.426]                     next
[16:13:59.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:59.426]                 }
[16:13:59.426]                 NAMES <- toupper(added)
[16:13:59.426]                 for (kk in seq_along(NAMES)) {
[16:13:59.426]                   name <- added[[kk]]
[16:13:59.426]                   NAME <- NAMES[[kk]]
[16:13:59.426]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.426]                     next
[16:13:59.426]                   args[[name]] <- ""
[16:13:59.426]                 }
[16:13:59.426]                 NAMES <- toupper(removed)
[16:13:59.426]                 for (kk in seq_along(NAMES)) {
[16:13:59.426]                   name <- removed[[kk]]
[16:13:59.426]                   NAME <- NAMES[[kk]]
[16:13:59.426]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.426]                     next
[16:13:59.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:59.426]                 }
[16:13:59.426]                 if (length(args) > 0) 
[16:13:59.426]                   base::do.call(base::Sys.setenv, args = args)
[16:13:59.426]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:59.426]             }
[16:13:59.426]             else {
[16:13:59.426]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:59.426]             }
[16:13:59.426]             {
[16:13:59.426]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:59.426]                   0L) {
[16:13:59.426]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:59.426]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:59.426]                   base::options(opts)
[16:13:59.426]                 }
[16:13:59.426]                 {
[16:13:59.426]                   {
[16:13:59.426]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:59.426]                     NULL
[16:13:59.426]                   }
[16:13:59.426]                   options(future.plan = NULL)
[16:13:59.426]                   if (is.na(NA_character_)) 
[16:13:59.426]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:59.426]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:59.426]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:59.426]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:59.426]                     envir = parent.frame()) 
[16:13:59.426]                   {
[16:13:59.426]                     if (is.function(workers)) 
[16:13:59.426]                       workers <- workers()
[16:13:59.426]                     workers <- structure(as.integer(workers), 
[16:13:59.426]                       class = class(workers))
[16:13:59.426]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:59.426]                       workers >= 1)
[16:13:59.426]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:59.426]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:59.426]                     }
[16:13:59.426]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:59.426]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:59.426]                       envir = envir)
[16:13:59.426]                     if (!future$lazy) 
[16:13:59.426]                       future <- run(future)
[16:13:59.426]                     invisible(future)
[16:13:59.426]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:59.426]                 }
[16:13:59.426]             }
[16:13:59.426]         }
[16:13:59.426]     })
[16:13:59.426]     if (TRUE) {
[16:13:59.426]         base::sink(type = "output", split = FALSE)
[16:13:59.426]         if (TRUE) {
[16:13:59.426]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:59.426]         }
[16:13:59.426]         else {
[16:13:59.426]             ...future.result["stdout"] <- base::list(NULL)
[16:13:59.426]         }
[16:13:59.426]         base::close(...future.stdout)
[16:13:59.426]         ...future.stdout <- NULL
[16:13:59.426]     }
[16:13:59.426]     ...future.result$conditions <- ...future.conditions
[16:13:59.426]     ...future.result$finished <- base::Sys.time()
[16:13:59.426]     ...future.result
[16:13:59.426] }
[16:13:59.429] MultisessionFuture started
[16:13:59.429] - Launch lazy future ... done
[16:13:59.429] run() for ‘MultisessionFuture’ ... done
[16:13:59.476] receiveMessageFromWorker() for ClusterFuture ...
[16:13:59.476] - Validating connection of MultisessionFuture
[16:13:59.478] - received message: FutureResult
[16:13:59.478] - Received FutureResult
[16:13:59.478] - Erased future from FutureRegistry
[16:13:59.479] result() for ClusterFuture ...
[16:13:59.479] - result already collected: FutureResult
[16:13:59.479] result() for ClusterFuture ... done
[16:13:59.479] signalConditions() ...
[16:13:59.479]  - include = ‘immediateCondition’
[16:13:59.479]  - exclude = 
[16:13:59.479]  - resignal = FALSE
[16:13:59.479]  - Number of conditions: 1
[16:13:59.479] signalConditions() ... done
[16:13:59.479] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:59.480] A MultisessionFuture was resolved
- result = TRUE, recursive = Inf ... DONE
*** resolve() for Future objects ... DONE
*** resolve() for lists ...
[16:13:59.480] resolve() on list ...
[16:13:59.480]  recursive: 0
[16:13:59.480]  length: 2
[16:13:59.480]  elements: ‘a’, ‘b’
[16:13:59.480]  length: 1 (resolved future 1)
[16:13:59.480]  length: 0 (resolved future 2)
[16:13:59.481] resolve() on list ... DONE
[16:13:59.481] getGlobalsAndPackages() ...
[16:13:59.481] Searching for globals...
[16:13:59.481] 
[16:13:59.481] Searching for globals ... DONE
[16:13:59.481] - globals: [0] <none>
[16:13:59.481] getGlobalsAndPackages() ... DONE
[16:13:59.482] run() for ‘Future’ ...
[16:13:59.482] - state: ‘created’
[16:13:59.482] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:59.497] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:59.497] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:59.497]   - Field: ‘node’
[16:13:59.497]   - Field: ‘label’
[16:13:59.497]   - Field: ‘local’
[16:13:59.497]   - Field: ‘owner’
[16:13:59.497]   - Field: ‘envir’
[16:13:59.497]   - Field: ‘workers’
[16:13:59.497]   - Field: ‘packages’
[16:13:59.498]   - Field: ‘gc’
[16:13:59.498]   - Field: ‘conditions’
[16:13:59.498]   - Field: ‘persistent’
[16:13:59.498]   - Field: ‘expr’
[16:13:59.498]   - Field: ‘uuid’
[16:13:59.498]   - Field: ‘seed’
[16:13:59.498]   - Field: ‘version’
[16:13:59.498]   - Field: ‘result’
[16:13:59.498]   - Field: ‘asynchronous’
[16:13:59.498]   - Field: ‘calls’
[16:13:59.498]   - Field: ‘globals’
[16:13:59.499]   - Field: ‘stdout’
[16:13:59.499]   - Field: ‘earlySignal’
[16:13:59.499]   - Field: ‘lazy’
[16:13:59.499]   - Field: ‘state’
[16:13:59.499] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:59.499] - Launch lazy future ...
[16:13:59.499] Packages needed by the future expression (n = 0): <none>
[16:13:59.499] Packages needed by future strategies (n = 0): <none>
[16:13:59.500] {
[16:13:59.500]     {
[16:13:59.500]         {
[16:13:59.500]             ...future.startTime <- base::Sys.time()
[16:13:59.500]             {
[16:13:59.500]                 {
[16:13:59.500]                   {
[16:13:59.500]                     {
[16:13:59.500]                       base::local({
[16:13:59.500]                         has_future <- base::requireNamespace("future", 
[16:13:59.500]                           quietly = TRUE)
[16:13:59.500]                         if (has_future) {
[16:13:59.500]                           ns <- base::getNamespace("future")
[16:13:59.500]                           version <- ns[[".package"]][["version"]]
[16:13:59.500]                           if (is.null(version)) 
[16:13:59.500]                             version <- utils::packageVersion("future")
[16:13:59.500]                         }
[16:13:59.500]                         else {
[16:13:59.500]                           version <- NULL
[16:13:59.500]                         }
[16:13:59.500]                         if (!has_future || version < "1.8.0") {
[16:13:59.500]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:59.500]                             "", base::R.version$version.string), 
[16:13:59.500]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:59.500]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:59.500]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:59.500]                               "release", "version")], collapse = " "), 
[16:13:59.500]                             hostname = base::Sys.info()[["nodename"]])
[16:13:59.500]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:59.500]                             info)
[16:13:59.500]                           info <- base::paste(info, collapse = "; ")
[16:13:59.500]                           if (!has_future) {
[16:13:59.500]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:59.500]                               info)
[16:13:59.500]                           }
[16:13:59.500]                           else {
[16:13:59.500]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:59.500]                               info, version)
[16:13:59.500]                           }
[16:13:59.500]                           base::stop(msg)
[16:13:59.500]                         }
[16:13:59.500]                       })
[16:13:59.500]                     }
[16:13:59.500]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:59.500]                     base::options(mc.cores = 1L)
[16:13:59.500]                   }
[16:13:59.500]                   options(future.plan = NULL)
[16:13:59.500]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:59.500]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:59.500]                 }
[16:13:59.500]                 ...future.workdir <- getwd()
[16:13:59.500]             }
[16:13:59.500]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:59.500]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:59.500]         }
[16:13:59.500]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:59.500]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:59.500]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:59.500]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:59.500]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:59.500]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:59.500]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:59.500]             base::names(...future.oldOptions))
[16:13:59.500]     }
[16:13:59.500]     if (FALSE) {
[16:13:59.500]     }
[16:13:59.500]     else {
[16:13:59.500]         if (TRUE) {
[16:13:59.500]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:59.500]                 open = "w")
[16:13:59.500]         }
[16:13:59.500]         else {
[16:13:59.500]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:59.500]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:59.500]         }
[16:13:59.500]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:59.500]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:59.500]             base::sink(type = "output", split = FALSE)
[16:13:59.500]             base::close(...future.stdout)
[16:13:59.500]         }, add = TRUE)
[16:13:59.500]     }
[16:13:59.500]     ...future.frame <- base::sys.nframe()
[16:13:59.500]     ...future.conditions <- base::list()
[16:13:59.500]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:59.500]     if (FALSE) {
[16:13:59.500]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:59.500]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:59.500]     }
[16:13:59.500]     ...future.result <- base::tryCatch({
[16:13:59.500]         base::withCallingHandlers({
[16:13:59.500]             ...future.value <- base::withVisible(base::local({
[16:13:59.500]                 ...future.makeSendCondition <- local({
[16:13:59.500]                   sendCondition <- NULL
[16:13:59.500]                   function(frame = 1L) {
[16:13:59.500]                     if (is.function(sendCondition)) 
[16:13:59.500]                       return(sendCondition)
[16:13:59.500]                     ns <- getNamespace("parallel")
[16:13:59.500]                     if (exists("sendData", mode = "function", 
[16:13:59.500]                       envir = ns)) {
[16:13:59.500]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:59.500]                         envir = ns)
[16:13:59.500]                       envir <- sys.frame(frame)
[16:13:59.500]                       master <- NULL
[16:13:59.500]                       while (!identical(envir, .GlobalEnv) && 
[16:13:59.500]                         !identical(envir, emptyenv())) {
[16:13:59.500]                         if (exists("master", mode = "list", envir = envir, 
[16:13:59.500]                           inherits = FALSE)) {
[16:13:59.500]                           master <- get("master", mode = "list", 
[16:13:59.500]                             envir = envir, inherits = FALSE)
[16:13:59.500]                           if (inherits(master, c("SOCKnode", 
[16:13:59.500]                             "SOCK0node"))) {
[16:13:59.500]                             sendCondition <<- function(cond) {
[16:13:59.500]                               data <- list(type = "VALUE", value = cond, 
[16:13:59.500]                                 success = TRUE)
[16:13:59.500]                               parallel_sendData(master, data)
[16:13:59.500]                             }
[16:13:59.500]                             return(sendCondition)
[16:13:59.500]                           }
[16:13:59.500]                         }
[16:13:59.500]                         frame <- frame + 1L
[16:13:59.500]                         envir <- sys.frame(frame)
[16:13:59.500]                       }
[16:13:59.500]                     }
[16:13:59.500]                     sendCondition <<- function(cond) NULL
[16:13:59.500]                   }
[16:13:59.500]                 })
[16:13:59.500]                 withCallingHandlers({
[16:13:59.500]                   1
[16:13:59.500]                 }, immediateCondition = function(cond) {
[16:13:59.500]                   sendCondition <- ...future.makeSendCondition()
[16:13:59.500]                   sendCondition(cond)
[16:13:59.500]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.500]                   {
[16:13:59.500]                     inherits <- base::inherits
[16:13:59.500]                     invokeRestart <- base::invokeRestart
[16:13:59.500]                     is.null <- base::is.null
[16:13:59.500]                     muffled <- FALSE
[16:13:59.500]                     if (inherits(cond, "message")) {
[16:13:59.500]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:59.500]                       if (muffled) 
[16:13:59.500]                         invokeRestart("muffleMessage")
[16:13:59.500]                     }
[16:13:59.500]                     else if (inherits(cond, "warning")) {
[16:13:59.500]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:59.500]                       if (muffled) 
[16:13:59.500]                         invokeRestart("muffleWarning")
[16:13:59.500]                     }
[16:13:59.500]                     else if (inherits(cond, "condition")) {
[16:13:59.500]                       if (!is.null(pattern)) {
[16:13:59.500]                         computeRestarts <- base::computeRestarts
[16:13:59.500]                         grepl <- base::grepl
[16:13:59.500]                         restarts <- computeRestarts(cond)
[16:13:59.500]                         for (restart in restarts) {
[16:13:59.500]                           name <- restart$name
[16:13:59.500]                           if (is.null(name)) 
[16:13:59.500]                             next
[16:13:59.500]                           if (!grepl(pattern, name)) 
[16:13:59.500]                             next
[16:13:59.500]                           invokeRestart(restart)
[16:13:59.500]                           muffled <- TRUE
[16:13:59.500]                           break
[16:13:59.500]                         }
[16:13:59.500]                       }
[16:13:59.500]                     }
[16:13:59.500]                     invisible(muffled)
[16:13:59.500]                   }
[16:13:59.500]                   muffleCondition(cond)
[16:13:59.500]                 })
[16:13:59.500]             }))
[16:13:59.500]             future::FutureResult(value = ...future.value$value, 
[16:13:59.500]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:59.500]                   ...future.rng), globalenv = if (FALSE) 
[16:13:59.500]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:59.500]                     ...future.globalenv.names))
[16:13:59.500]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:59.500]         }, condition = base::local({
[16:13:59.500]             c <- base::c
[16:13:59.500]             inherits <- base::inherits
[16:13:59.500]             invokeRestart <- base::invokeRestart
[16:13:59.500]             length <- base::length
[16:13:59.500]             list <- base::list
[16:13:59.500]             seq.int <- base::seq.int
[16:13:59.500]             signalCondition <- base::signalCondition
[16:13:59.500]             sys.calls <- base::sys.calls
[16:13:59.500]             `[[` <- base::`[[`
[16:13:59.500]             `+` <- base::`+`
[16:13:59.500]             `<<-` <- base::`<<-`
[16:13:59.500]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:59.500]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:59.500]                   3L)]
[16:13:59.500]             }
[16:13:59.500]             function(cond) {
[16:13:59.500]                 is_error <- inherits(cond, "error")
[16:13:59.500]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:59.500]                   NULL)
[16:13:59.500]                 if (is_error) {
[16:13:59.500]                   sessionInformation <- function() {
[16:13:59.500]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:59.500]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:59.500]                       search = base::search(), system = base::Sys.info())
[16:13:59.500]                   }
[16:13:59.500]                   ...future.conditions[[length(...future.conditions) + 
[16:13:59.500]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:59.500]                     cond$call), session = sessionInformation(), 
[16:13:59.500]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:59.500]                   signalCondition(cond)
[16:13:59.500]                 }
[16:13:59.500]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:59.500]                 "immediateCondition"))) {
[16:13:59.500]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:59.500]                   ...future.conditions[[length(...future.conditions) + 
[16:13:59.500]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:59.500]                   if (TRUE && !signal) {
[16:13:59.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.500]                     {
[16:13:59.500]                       inherits <- base::inherits
[16:13:59.500]                       invokeRestart <- base::invokeRestart
[16:13:59.500]                       is.null <- base::is.null
[16:13:59.500]                       muffled <- FALSE
[16:13:59.500]                       if (inherits(cond, "message")) {
[16:13:59.500]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:59.500]                         if (muffled) 
[16:13:59.500]                           invokeRestart("muffleMessage")
[16:13:59.500]                       }
[16:13:59.500]                       else if (inherits(cond, "warning")) {
[16:13:59.500]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:59.500]                         if (muffled) 
[16:13:59.500]                           invokeRestart("muffleWarning")
[16:13:59.500]                       }
[16:13:59.500]                       else if (inherits(cond, "condition")) {
[16:13:59.500]                         if (!is.null(pattern)) {
[16:13:59.500]                           computeRestarts <- base::computeRestarts
[16:13:59.500]                           grepl <- base::grepl
[16:13:59.500]                           restarts <- computeRestarts(cond)
[16:13:59.500]                           for (restart in restarts) {
[16:13:59.500]                             name <- restart$name
[16:13:59.500]                             if (is.null(name)) 
[16:13:59.500]                               next
[16:13:59.500]                             if (!grepl(pattern, name)) 
[16:13:59.500]                               next
[16:13:59.500]                             invokeRestart(restart)
[16:13:59.500]                             muffled <- TRUE
[16:13:59.500]                             break
[16:13:59.500]                           }
[16:13:59.500]                         }
[16:13:59.500]                       }
[16:13:59.500]                       invisible(muffled)
[16:13:59.500]                     }
[16:13:59.500]                     muffleCondition(cond, pattern = "^muffle")
[16:13:59.500]                   }
[16:13:59.500]                 }
[16:13:59.500]                 else {
[16:13:59.500]                   if (TRUE) {
[16:13:59.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.500]                     {
[16:13:59.500]                       inherits <- base::inherits
[16:13:59.500]                       invokeRestart <- base::invokeRestart
[16:13:59.500]                       is.null <- base::is.null
[16:13:59.500]                       muffled <- FALSE
[16:13:59.500]                       if (inherits(cond, "message")) {
[16:13:59.500]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:59.500]                         if (muffled) 
[16:13:59.500]                           invokeRestart("muffleMessage")
[16:13:59.500]                       }
[16:13:59.500]                       else if (inherits(cond, "warning")) {
[16:13:59.500]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:59.500]                         if (muffled) 
[16:13:59.500]                           invokeRestart("muffleWarning")
[16:13:59.500]                       }
[16:13:59.500]                       else if (inherits(cond, "condition")) {
[16:13:59.500]                         if (!is.null(pattern)) {
[16:13:59.500]                           computeRestarts <- base::computeRestarts
[16:13:59.500]                           grepl <- base::grepl
[16:13:59.500]                           restarts <- computeRestarts(cond)
[16:13:59.500]                           for (restart in restarts) {
[16:13:59.500]                             name <- restart$name
[16:13:59.500]                             if (is.null(name)) 
[16:13:59.500]                               next
[16:13:59.500]                             if (!grepl(pattern, name)) 
[16:13:59.500]                               next
[16:13:59.500]                             invokeRestart(restart)
[16:13:59.500]                             muffled <- TRUE
[16:13:59.500]                             break
[16:13:59.500]                           }
[16:13:59.500]                         }
[16:13:59.500]                       }
[16:13:59.500]                       invisible(muffled)
[16:13:59.500]                     }
[16:13:59.500]                     muffleCondition(cond, pattern = "^muffle")
[16:13:59.500]                   }
[16:13:59.500]                 }
[16:13:59.500]             }
[16:13:59.500]         }))
[16:13:59.500]     }, error = function(ex) {
[16:13:59.500]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:59.500]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:59.500]                 ...future.rng), started = ...future.startTime, 
[16:13:59.500]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:59.500]             version = "1.8"), class = "FutureResult")
[16:13:59.500]     }, finally = {
[16:13:59.500]         if (!identical(...future.workdir, getwd())) 
[16:13:59.500]             setwd(...future.workdir)
[16:13:59.500]         {
[16:13:59.500]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:59.500]                 ...future.oldOptions$nwarnings <- NULL
[16:13:59.500]             }
[16:13:59.500]             base::options(...future.oldOptions)
[16:13:59.500]             if (.Platform$OS.type == "windows") {
[16:13:59.500]                 old_names <- names(...future.oldEnvVars)
[16:13:59.500]                 envs <- base::Sys.getenv()
[16:13:59.500]                 names <- names(envs)
[16:13:59.500]                 common <- intersect(names, old_names)
[16:13:59.500]                 added <- setdiff(names, old_names)
[16:13:59.500]                 removed <- setdiff(old_names, names)
[16:13:59.500]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:59.500]                   envs[common]]
[16:13:59.500]                 NAMES <- toupper(changed)
[16:13:59.500]                 args <- list()
[16:13:59.500]                 for (kk in seq_along(NAMES)) {
[16:13:59.500]                   name <- changed[[kk]]
[16:13:59.500]                   NAME <- NAMES[[kk]]
[16:13:59.500]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.500]                     next
[16:13:59.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:59.500]                 }
[16:13:59.500]                 NAMES <- toupper(added)
[16:13:59.500]                 for (kk in seq_along(NAMES)) {
[16:13:59.500]                   name <- added[[kk]]
[16:13:59.500]                   NAME <- NAMES[[kk]]
[16:13:59.500]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.500]                     next
[16:13:59.500]                   args[[name]] <- ""
[16:13:59.500]                 }
[16:13:59.500]                 NAMES <- toupper(removed)
[16:13:59.500]                 for (kk in seq_along(NAMES)) {
[16:13:59.500]                   name <- removed[[kk]]
[16:13:59.500]                   NAME <- NAMES[[kk]]
[16:13:59.500]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.500]                     next
[16:13:59.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:59.500]                 }
[16:13:59.500]                 if (length(args) > 0) 
[16:13:59.500]                   base::do.call(base::Sys.setenv, args = args)
[16:13:59.500]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:59.500]             }
[16:13:59.500]             else {
[16:13:59.500]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:59.500]             }
[16:13:59.500]             {
[16:13:59.500]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:59.500]                   0L) {
[16:13:59.500]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:59.500]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:59.500]                   base::options(opts)
[16:13:59.500]                 }
[16:13:59.500]                 {
[16:13:59.500]                   {
[16:13:59.500]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:59.500]                     NULL
[16:13:59.500]                   }
[16:13:59.500]                   options(future.plan = NULL)
[16:13:59.500]                   if (is.na(NA_character_)) 
[16:13:59.500]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:59.500]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:59.500]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:59.500]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:59.500]                     envir = parent.frame()) 
[16:13:59.500]                   {
[16:13:59.500]                     if (is.function(workers)) 
[16:13:59.500]                       workers <- workers()
[16:13:59.500]                     workers <- structure(as.integer(workers), 
[16:13:59.500]                       class = class(workers))
[16:13:59.500]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:59.500]                       workers >= 1)
[16:13:59.500]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:59.500]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:59.500]                     }
[16:13:59.500]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:59.500]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:59.500]                       envir = envir)
[16:13:59.500]                     if (!future$lazy) 
[16:13:59.500]                       future <- run(future)
[16:13:59.500]                     invisible(future)
[16:13:59.500]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:59.500]                 }
[16:13:59.500]             }
[16:13:59.500]         }
[16:13:59.500]     })
[16:13:59.500]     if (TRUE) {
[16:13:59.500]         base::sink(type = "output", split = FALSE)
[16:13:59.500]         if (TRUE) {
[16:13:59.500]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:59.500]         }
[16:13:59.500]         else {
[16:13:59.500]             ...future.result["stdout"] <- base::list(NULL)
[16:13:59.500]         }
[16:13:59.500]         base::close(...future.stdout)
[16:13:59.500]         ...future.stdout <- NULL
[16:13:59.500]     }
[16:13:59.500]     ...future.result$conditions <- ...future.conditions
[16:13:59.500]     ...future.result$finished <- base::Sys.time()
[16:13:59.500]     ...future.result
[16:13:59.500] }
[16:13:59.503] MultisessionFuture started
[16:13:59.503] - Launch lazy future ... done
[16:13:59.503] run() for ‘MultisessionFuture’ ... done
[16:13:59.503] getGlobalsAndPackages() ...
[16:13:59.503] Searching for globals...
[16:13:59.504] 
[16:13:59.504] Searching for globals ... DONE
[16:13:59.504] - globals: [0] <none>
[16:13:59.504] getGlobalsAndPackages() ... DONE
[16:13:59.504] run() for ‘Future’ ...
[16:13:59.504] - state: ‘created’
[16:13:59.505] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:59.519] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:59.519] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:59.519]   - Field: ‘node’
[16:13:59.519]   - Field: ‘label’
[16:13:59.519]   - Field: ‘local’
[16:13:59.519]   - Field: ‘owner’
[16:13:59.519]   - Field: ‘envir’
[16:13:59.519]   - Field: ‘workers’
[16:13:59.519]   - Field: ‘packages’
[16:13:59.519]   - Field: ‘gc’
[16:13:59.520]   - Field: ‘conditions’
[16:13:59.520]   - Field: ‘persistent’
[16:13:59.520]   - Field: ‘expr’
[16:13:59.520]   - Field: ‘uuid’
[16:13:59.520]   - Field: ‘seed’
[16:13:59.520]   - Field: ‘version’
[16:13:59.520]   - Field: ‘result’
[16:13:59.520]   - Field: ‘asynchronous’
[16:13:59.520]   - Field: ‘calls’
[16:13:59.521]   - Field: ‘globals’
[16:13:59.521]   - Field: ‘stdout’
[16:13:59.521]   - Field: ‘earlySignal’
[16:13:59.521]   - Field: ‘lazy’
[16:13:59.521]   - Field: ‘state’
[16:13:59.521] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:59.521] - Launch lazy future ...
[16:13:59.521] Packages needed by the future expression (n = 0): <none>
[16:13:59.521] Packages needed by future strategies (n = 0): <none>
[16:13:59.522] {
[16:13:59.522]     {
[16:13:59.522]         {
[16:13:59.522]             ...future.startTime <- base::Sys.time()
[16:13:59.522]             {
[16:13:59.522]                 {
[16:13:59.522]                   {
[16:13:59.522]                     {
[16:13:59.522]                       base::local({
[16:13:59.522]                         has_future <- base::requireNamespace("future", 
[16:13:59.522]                           quietly = TRUE)
[16:13:59.522]                         if (has_future) {
[16:13:59.522]                           ns <- base::getNamespace("future")
[16:13:59.522]                           version <- ns[[".package"]][["version"]]
[16:13:59.522]                           if (is.null(version)) 
[16:13:59.522]                             version <- utils::packageVersion("future")
[16:13:59.522]                         }
[16:13:59.522]                         else {
[16:13:59.522]                           version <- NULL
[16:13:59.522]                         }
[16:13:59.522]                         if (!has_future || version < "1.8.0") {
[16:13:59.522]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:59.522]                             "", base::R.version$version.string), 
[16:13:59.522]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:59.522]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:59.522]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:59.522]                               "release", "version")], collapse = " "), 
[16:13:59.522]                             hostname = base::Sys.info()[["nodename"]])
[16:13:59.522]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:59.522]                             info)
[16:13:59.522]                           info <- base::paste(info, collapse = "; ")
[16:13:59.522]                           if (!has_future) {
[16:13:59.522]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:59.522]                               info)
[16:13:59.522]                           }
[16:13:59.522]                           else {
[16:13:59.522]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:59.522]                               info, version)
[16:13:59.522]                           }
[16:13:59.522]                           base::stop(msg)
[16:13:59.522]                         }
[16:13:59.522]                       })
[16:13:59.522]                     }
[16:13:59.522]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:59.522]                     base::options(mc.cores = 1L)
[16:13:59.522]                   }
[16:13:59.522]                   options(future.plan = NULL)
[16:13:59.522]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:59.522]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:59.522]                 }
[16:13:59.522]                 ...future.workdir <- getwd()
[16:13:59.522]             }
[16:13:59.522]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:59.522]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:59.522]         }
[16:13:59.522]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:59.522]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:59.522]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:59.522]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:59.522]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:59.522]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:59.522]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:59.522]             base::names(...future.oldOptions))
[16:13:59.522]     }
[16:13:59.522]     if (FALSE) {
[16:13:59.522]     }
[16:13:59.522]     else {
[16:13:59.522]         if (TRUE) {
[16:13:59.522]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:59.522]                 open = "w")
[16:13:59.522]         }
[16:13:59.522]         else {
[16:13:59.522]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:59.522]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:59.522]         }
[16:13:59.522]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:59.522]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:59.522]             base::sink(type = "output", split = FALSE)
[16:13:59.522]             base::close(...future.stdout)
[16:13:59.522]         }, add = TRUE)
[16:13:59.522]     }
[16:13:59.522]     ...future.frame <- base::sys.nframe()
[16:13:59.522]     ...future.conditions <- base::list()
[16:13:59.522]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:59.522]     if (FALSE) {
[16:13:59.522]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:59.522]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:59.522]     }
[16:13:59.522]     ...future.result <- base::tryCatch({
[16:13:59.522]         base::withCallingHandlers({
[16:13:59.522]             ...future.value <- base::withVisible(base::local({
[16:13:59.522]                 ...future.makeSendCondition <- local({
[16:13:59.522]                   sendCondition <- NULL
[16:13:59.522]                   function(frame = 1L) {
[16:13:59.522]                     if (is.function(sendCondition)) 
[16:13:59.522]                       return(sendCondition)
[16:13:59.522]                     ns <- getNamespace("parallel")
[16:13:59.522]                     if (exists("sendData", mode = "function", 
[16:13:59.522]                       envir = ns)) {
[16:13:59.522]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:59.522]                         envir = ns)
[16:13:59.522]                       envir <- sys.frame(frame)
[16:13:59.522]                       master <- NULL
[16:13:59.522]                       while (!identical(envir, .GlobalEnv) && 
[16:13:59.522]                         !identical(envir, emptyenv())) {
[16:13:59.522]                         if (exists("master", mode = "list", envir = envir, 
[16:13:59.522]                           inherits = FALSE)) {
[16:13:59.522]                           master <- get("master", mode = "list", 
[16:13:59.522]                             envir = envir, inherits = FALSE)
[16:13:59.522]                           if (inherits(master, c("SOCKnode", 
[16:13:59.522]                             "SOCK0node"))) {
[16:13:59.522]                             sendCondition <<- function(cond) {
[16:13:59.522]                               data <- list(type = "VALUE", value = cond, 
[16:13:59.522]                                 success = TRUE)
[16:13:59.522]                               parallel_sendData(master, data)
[16:13:59.522]                             }
[16:13:59.522]                             return(sendCondition)
[16:13:59.522]                           }
[16:13:59.522]                         }
[16:13:59.522]                         frame <- frame + 1L
[16:13:59.522]                         envir <- sys.frame(frame)
[16:13:59.522]                       }
[16:13:59.522]                     }
[16:13:59.522]                     sendCondition <<- function(cond) NULL
[16:13:59.522]                   }
[16:13:59.522]                 })
[16:13:59.522]                 withCallingHandlers({
[16:13:59.522]                   2
[16:13:59.522]                 }, immediateCondition = function(cond) {
[16:13:59.522]                   sendCondition <- ...future.makeSendCondition()
[16:13:59.522]                   sendCondition(cond)
[16:13:59.522]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.522]                   {
[16:13:59.522]                     inherits <- base::inherits
[16:13:59.522]                     invokeRestart <- base::invokeRestart
[16:13:59.522]                     is.null <- base::is.null
[16:13:59.522]                     muffled <- FALSE
[16:13:59.522]                     if (inherits(cond, "message")) {
[16:13:59.522]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:59.522]                       if (muffled) 
[16:13:59.522]                         invokeRestart("muffleMessage")
[16:13:59.522]                     }
[16:13:59.522]                     else if (inherits(cond, "warning")) {
[16:13:59.522]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:59.522]                       if (muffled) 
[16:13:59.522]                         invokeRestart("muffleWarning")
[16:13:59.522]                     }
[16:13:59.522]                     else if (inherits(cond, "condition")) {
[16:13:59.522]                       if (!is.null(pattern)) {
[16:13:59.522]                         computeRestarts <- base::computeRestarts
[16:13:59.522]                         grepl <- base::grepl
[16:13:59.522]                         restarts <- computeRestarts(cond)
[16:13:59.522]                         for (restart in restarts) {
[16:13:59.522]                           name <- restart$name
[16:13:59.522]                           if (is.null(name)) 
[16:13:59.522]                             next
[16:13:59.522]                           if (!grepl(pattern, name)) 
[16:13:59.522]                             next
[16:13:59.522]                           invokeRestart(restart)
[16:13:59.522]                           muffled <- TRUE
[16:13:59.522]                           break
[16:13:59.522]                         }
[16:13:59.522]                       }
[16:13:59.522]                     }
[16:13:59.522]                     invisible(muffled)
[16:13:59.522]                   }
[16:13:59.522]                   muffleCondition(cond)
[16:13:59.522]                 })
[16:13:59.522]             }))
[16:13:59.522]             future::FutureResult(value = ...future.value$value, 
[16:13:59.522]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:59.522]                   ...future.rng), globalenv = if (FALSE) 
[16:13:59.522]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:59.522]                     ...future.globalenv.names))
[16:13:59.522]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:59.522]         }, condition = base::local({
[16:13:59.522]             c <- base::c
[16:13:59.522]             inherits <- base::inherits
[16:13:59.522]             invokeRestart <- base::invokeRestart
[16:13:59.522]             length <- base::length
[16:13:59.522]             list <- base::list
[16:13:59.522]             seq.int <- base::seq.int
[16:13:59.522]             signalCondition <- base::signalCondition
[16:13:59.522]             sys.calls <- base::sys.calls
[16:13:59.522]             `[[` <- base::`[[`
[16:13:59.522]             `+` <- base::`+`
[16:13:59.522]             `<<-` <- base::`<<-`
[16:13:59.522]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:59.522]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:59.522]                   3L)]
[16:13:59.522]             }
[16:13:59.522]             function(cond) {
[16:13:59.522]                 is_error <- inherits(cond, "error")
[16:13:59.522]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:59.522]                   NULL)
[16:13:59.522]                 if (is_error) {
[16:13:59.522]                   sessionInformation <- function() {
[16:13:59.522]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:59.522]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:59.522]                       search = base::search(), system = base::Sys.info())
[16:13:59.522]                   }
[16:13:59.522]                   ...future.conditions[[length(...future.conditions) + 
[16:13:59.522]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:59.522]                     cond$call), session = sessionInformation(), 
[16:13:59.522]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:59.522]                   signalCondition(cond)
[16:13:59.522]                 }
[16:13:59.522]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:59.522]                 "immediateCondition"))) {
[16:13:59.522]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:59.522]                   ...future.conditions[[length(...future.conditions) + 
[16:13:59.522]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:59.522]                   if (TRUE && !signal) {
[16:13:59.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.522]                     {
[16:13:59.522]                       inherits <- base::inherits
[16:13:59.522]                       invokeRestart <- base::invokeRestart
[16:13:59.522]                       is.null <- base::is.null
[16:13:59.522]                       muffled <- FALSE
[16:13:59.522]                       if (inherits(cond, "message")) {
[16:13:59.522]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:59.522]                         if (muffled) 
[16:13:59.522]                           invokeRestart("muffleMessage")
[16:13:59.522]                       }
[16:13:59.522]                       else if (inherits(cond, "warning")) {
[16:13:59.522]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:59.522]                         if (muffled) 
[16:13:59.522]                           invokeRestart("muffleWarning")
[16:13:59.522]                       }
[16:13:59.522]                       else if (inherits(cond, "condition")) {
[16:13:59.522]                         if (!is.null(pattern)) {
[16:13:59.522]                           computeRestarts <- base::computeRestarts
[16:13:59.522]                           grepl <- base::grepl
[16:13:59.522]                           restarts <- computeRestarts(cond)
[16:13:59.522]                           for (restart in restarts) {
[16:13:59.522]                             name <- restart$name
[16:13:59.522]                             if (is.null(name)) 
[16:13:59.522]                               next
[16:13:59.522]                             if (!grepl(pattern, name)) 
[16:13:59.522]                               next
[16:13:59.522]                             invokeRestart(restart)
[16:13:59.522]                             muffled <- TRUE
[16:13:59.522]                             break
[16:13:59.522]                           }
[16:13:59.522]                         }
[16:13:59.522]                       }
[16:13:59.522]                       invisible(muffled)
[16:13:59.522]                     }
[16:13:59.522]                     muffleCondition(cond, pattern = "^muffle")
[16:13:59.522]                   }
[16:13:59.522]                 }
[16:13:59.522]                 else {
[16:13:59.522]                   if (TRUE) {
[16:13:59.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.522]                     {
[16:13:59.522]                       inherits <- base::inherits
[16:13:59.522]                       invokeRestart <- base::invokeRestart
[16:13:59.522]                       is.null <- base::is.null
[16:13:59.522]                       muffled <- FALSE
[16:13:59.522]                       if (inherits(cond, "message")) {
[16:13:59.522]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:59.522]                         if (muffled) 
[16:13:59.522]                           invokeRestart("muffleMessage")
[16:13:59.522]                       }
[16:13:59.522]                       else if (inherits(cond, "warning")) {
[16:13:59.522]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:59.522]                         if (muffled) 
[16:13:59.522]                           invokeRestart("muffleWarning")
[16:13:59.522]                       }
[16:13:59.522]                       else if (inherits(cond, "condition")) {
[16:13:59.522]                         if (!is.null(pattern)) {
[16:13:59.522]                           computeRestarts <- base::computeRestarts
[16:13:59.522]                           grepl <- base::grepl
[16:13:59.522]                           restarts <- computeRestarts(cond)
[16:13:59.522]                           for (restart in restarts) {
[16:13:59.522]                             name <- restart$name
[16:13:59.522]                             if (is.null(name)) 
[16:13:59.522]                               next
[16:13:59.522]                             if (!grepl(pattern, name)) 
[16:13:59.522]                               next
[16:13:59.522]                             invokeRestart(restart)
[16:13:59.522]                             muffled <- TRUE
[16:13:59.522]                             break
[16:13:59.522]                           }
[16:13:59.522]                         }
[16:13:59.522]                       }
[16:13:59.522]                       invisible(muffled)
[16:13:59.522]                     }
[16:13:59.522]                     muffleCondition(cond, pattern = "^muffle")
[16:13:59.522]                   }
[16:13:59.522]                 }
[16:13:59.522]             }
[16:13:59.522]         }))
[16:13:59.522]     }, error = function(ex) {
[16:13:59.522]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:59.522]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:59.522]                 ...future.rng), started = ...future.startTime, 
[16:13:59.522]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:59.522]             version = "1.8"), class = "FutureResult")
[16:13:59.522]     }, finally = {
[16:13:59.522]         if (!identical(...future.workdir, getwd())) 
[16:13:59.522]             setwd(...future.workdir)
[16:13:59.522]         {
[16:13:59.522]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:59.522]                 ...future.oldOptions$nwarnings <- NULL
[16:13:59.522]             }
[16:13:59.522]             base::options(...future.oldOptions)
[16:13:59.522]             if (.Platform$OS.type == "windows") {
[16:13:59.522]                 old_names <- names(...future.oldEnvVars)
[16:13:59.522]                 envs <- base::Sys.getenv()
[16:13:59.522]                 names <- names(envs)
[16:13:59.522]                 common <- intersect(names, old_names)
[16:13:59.522]                 added <- setdiff(names, old_names)
[16:13:59.522]                 removed <- setdiff(old_names, names)
[16:13:59.522]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:59.522]                   envs[common]]
[16:13:59.522]                 NAMES <- toupper(changed)
[16:13:59.522]                 args <- list()
[16:13:59.522]                 for (kk in seq_along(NAMES)) {
[16:13:59.522]                   name <- changed[[kk]]
[16:13:59.522]                   NAME <- NAMES[[kk]]
[16:13:59.522]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.522]                     next
[16:13:59.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:59.522]                 }
[16:13:59.522]                 NAMES <- toupper(added)
[16:13:59.522]                 for (kk in seq_along(NAMES)) {
[16:13:59.522]                   name <- added[[kk]]
[16:13:59.522]                   NAME <- NAMES[[kk]]
[16:13:59.522]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.522]                     next
[16:13:59.522]                   args[[name]] <- ""
[16:13:59.522]                 }
[16:13:59.522]                 NAMES <- toupper(removed)
[16:13:59.522]                 for (kk in seq_along(NAMES)) {
[16:13:59.522]                   name <- removed[[kk]]
[16:13:59.522]                   NAME <- NAMES[[kk]]
[16:13:59.522]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.522]                     next
[16:13:59.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:59.522]                 }
[16:13:59.522]                 if (length(args) > 0) 
[16:13:59.522]                   base::do.call(base::Sys.setenv, args = args)
[16:13:59.522]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:59.522]             }
[16:13:59.522]             else {
[16:13:59.522]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:59.522]             }
[16:13:59.522]             {
[16:13:59.522]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:59.522]                   0L) {
[16:13:59.522]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:59.522]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:59.522]                   base::options(opts)
[16:13:59.522]                 }
[16:13:59.522]                 {
[16:13:59.522]                   {
[16:13:59.522]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:59.522]                     NULL
[16:13:59.522]                   }
[16:13:59.522]                   options(future.plan = NULL)
[16:13:59.522]                   if (is.na(NA_character_)) 
[16:13:59.522]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:59.522]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:59.522]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:59.522]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:59.522]                     envir = parent.frame()) 
[16:13:59.522]                   {
[16:13:59.522]                     if (is.function(workers)) 
[16:13:59.522]                       workers <- workers()
[16:13:59.522]                     workers <- structure(as.integer(workers), 
[16:13:59.522]                       class = class(workers))
[16:13:59.522]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:59.522]                       workers >= 1)
[16:13:59.522]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:59.522]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:59.522]                     }
[16:13:59.522]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:59.522]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:59.522]                       envir = envir)
[16:13:59.522]                     if (!future$lazy) 
[16:13:59.522]                       future <- run(future)
[16:13:59.522]                     invisible(future)
[16:13:59.522]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:59.522]                 }
[16:13:59.522]             }
[16:13:59.522]         }
[16:13:59.522]     })
[16:13:59.522]     if (TRUE) {
[16:13:59.522]         base::sink(type = "output", split = FALSE)
[16:13:59.522]         if (TRUE) {
[16:13:59.522]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:59.522]         }
[16:13:59.522]         else {
[16:13:59.522]             ...future.result["stdout"] <- base::list(NULL)
[16:13:59.522]         }
[16:13:59.522]         base::close(...future.stdout)
[16:13:59.522]         ...future.stdout <- NULL
[16:13:59.522]     }
[16:13:59.522]     ...future.result$conditions <- ...future.conditions
[16:13:59.522]     ...future.result$finished <- base::Sys.time()
[16:13:59.522]     ...future.result
[16:13:59.522] }
[16:13:59.524] Poll #1 (0): usedNodes() = 2, workers = 2
[16:13:59.535] receiveMessageFromWorker() for ClusterFuture ...
[16:13:59.535] - Validating connection of MultisessionFuture
[16:13:59.535] - received message: FutureResult
[16:13:59.535] - Received FutureResult
[16:13:59.535] - Erased future from FutureRegistry
[16:13:59.536] result() for ClusterFuture ...
[16:13:59.536] - result already collected: FutureResult
[16:13:59.536] result() for ClusterFuture ... done
[16:13:59.536] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:59.536] result() for ClusterFuture ...
[16:13:59.536] - result already collected: FutureResult
[16:13:59.536] result() for ClusterFuture ... done
[16:13:59.536] result() for ClusterFuture ...
[16:13:59.536] - result already collected: FutureResult
[16:13:59.536] result() for ClusterFuture ... done
[16:13:59.537] MultisessionFuture started
[16:13:59.538] - Launch lazy future ... done
[16:13:59.538] run() for ‘MultisessionFuture’ ... done
[16:13:59.538] resolve() on list ...
[16:13:59.538]  recursive: 0
[16:13:59.538]  length: 3
[16:13:59.538]  elements: ‘a’, ‘b’, ‘’
[16:13:59.549] receiveMessageFromWorker() for ClusterFuture ...
[16:13:59.549] - Validating connection of MultisessionFuture
[16:13:59.549] - received message: FutureResult
[16:13:59.549] - Received FutureResult
[16:13:59.549] - Erased future from FutureRegistry
[16:13:59.549] result() for ClusterFuture ...
[16:13:59.549] - result already collected: FutureResult
[16:13:59.549] result() for ClusterFuture ... done
[16:13:59.550] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:59.550] Future #1
[16:13:59.550]  length: 2 (resolved future 1)
[16:13:59.560]  length: 1 (resolved future 3)
[16:13:59.592] receiveMessageFromWorker() for ClusterFuture ...
[16:13:59.592] - Validating connection of MultisessionFuture
[16:13:59.592] - received message: FutureResult
[16:13:59.592] - Received FutureResult
[16:13:59.592] - Erased future from FutureRegistry
[16:13:59.592] result() for ClusterFuture ...
[16:13:59.592] - result already collected: FutureResult
[16:13:59.592] result() for ClusterFuture ... done
[16:13:59.593] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:59.593] Future #2
[16:13:59.593]  length: 0 (resolved future 2)
[16:13:59.593] resolve() on list ... DONE
[16:13:59.593] getGlobalsAndPackages() ...
[16:13:59.593] Searching for globals...
[16:13:59.593] 
[16:13:59.594] Searching for globals ... DONE
[16:13:59.594] - globals: [0] <none>
[16:13:59.594] getGlobalsAndPackages() ... DONE
[16:13:59.594] getGlobalsAndPackages() ...
[16:13:59.594] Searching for globals...
[16:13:59.594] 
[16:13:59.594] Searching for globals ... DONE
[16:13:59.594] - globals: [0] <none>
[16:13:59.595] getGlobalsAndPackages() ... DONE
[16:13:59.595] run() for ‘Future’ ...
[16:13:59.595] - state: ‘created’
[16:13:59.595] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:59.609] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:59.610] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:59.610]   - Field: ‘node’
[16:13:59.610]   - Field: ‘label’
[16:13:59.610]   - Field: ‘local’
[16:13:59.610]   - Field: ‘owner’
[16:13:59.610]   - Field: ‘envir’
[16:13:59.610]   - Field: ‘workers’
[16:13:59.610]   - Field: ‘packages’
[16:13:59.610]   - Field: ‘gc’
[16:13:59.611]   - Field: ‘conditions’
[16:13:59.611]   - Field: ‘persistent’
[16:13:59.611]   - Field: ‘expr’
[16:13:59.611]   - Field: ‘uuid’
[16:13:59.611]   - Field: ‘seed’
[16:13:59.611]   - Field: ‘version’
[16:13:59.611]   - Field: ‘result’
[16:13:59.611]   - Field: ‘asynchronous’
[16:13:59.611]   - Field: ‘calls’
[16:13:59.611]   - Field: ‘globals’
[16:13:59.611]   - Field: ‘stdout’
[16:13:59.612]   - Field: ‘earlySignal’
[16:13:59.612]   - Field: ‘lazy’
[16:13:59.612]   - Field: ‘state’
[16:13:59.612] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:59.612] - Launch lazy future ...
[16:13:59.612] Packages needed by the future expression (n = 0): <none>
[16:13:59.612] Packages needed by future strategies (n = 0): <none>
[16:13:59.613] {
[16:13:59.613]     {
[16:13:59.613]         {
[16:13:59.613]             ...future.startTime <- base::Sys.time()
[16:13:59.613]             {
[16:13:59.613]                 {
[16:13:59.613]                   {
[16:13:59.613]                     {
[16:13:59.613]                       base::local({
[16:13:59.613]                         has_future <- base::requireNamespace("future", 
[16:13:59.613]                           quietly = TRUE)
[16:13:59.613]                         if (has_future) {
[16:13:59.613]                           ns <- base::getNamespace("future")
[16:13:59.613]                           version <- ns[[".package"]][["version"]]
[16:13:59.613]                           if (is.null(version)) 
[16:13:59.613]                             version <- utils::packageVersion("future")
[16:13:59.613]                         }
[16:13:59.613]                         else {
[16:13:59.613]                           version <- NULL
[16:13:59.613]                         }
[16:13:59.613]                         if (!has_future || version < "1.8.0") {
[16:13:59.613]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:59.613]                             "", base::R.version$version.string), 
[16:13:59.613]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:59.613]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:59.613]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:59.613]                               "release", "version")], collapse = " "), 
[16:13:59.613]                             hostname = base::Sys.info()[["nodename"]])
[16:13:59.613]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:59.613]                             info)
[16:13:59.613]                           info <- base::paste(info, collapse = "; ")
[16:13:59.613]                           if (!has_future) {
[16:13:59.613]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:59.613]                               info)
[16:13:59.613]                           }
[16:13:59.613]                           else {
[16:13:59.613]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:59.613]                               info, version)
[16:13:59.613]                           }
[16:13:59.613]                           base::stop(msg)
[16:13:59.613]                         }
[16:13:59.613]                       })
[16:13:59.613]                     }
[16:13:59.613]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:59.613]                     base::options(mc.cores = 1L)
[16:13:59.613]                   }
[16:13:59.613]                   options(future.plan = NULL)
[16:13:59.613]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:59.613]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:59.613]                 }
[16:13:59.613]                 ...future.workdir <- getwd()
[16:13:59.613]             }
[16:13:59.613]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:59.613]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:59.613]         }
[16:13:59.613]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:59.613]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:59.613]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:59.613]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:59.613]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:59.613]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:59.613]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:59.613]             base::names(...future.oldOptions))
[16:13:59.613]     }
[16:13:59.613]     if (FALSE) {
[16:13:59.613]     }
[16:13:59.613]     else {
[16:13:59.613]         if (TRUE) {
[16:13:59.613]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:59.613]                 open = "w")
[16:13:59.613]         }
[16:13:59.613]         else {
[16:13:59.613]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:59.613]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:59.613]         }
[16:13:59.613]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:59.613]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:59.613]             base::sink(type = "output", split = FALSE)
[16:13:59.613]             base::close(...future.stdout)
[16:13:59.613]         }, add = TRUE)
[16:13:59.613]     }
[16:13:59.613]     ...future.frame <- base::sys.nframe()
[16:13:59.613]     ...future.conditions <- base::list()
[16:13:59.613]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:59.613]     if (FALSE) {
[16:13:59.613]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:59.613]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:59.613]     }
[16:13:59.613]     ...future.result <- base::tryCatch({
[16:13:59.613]         base::withCallingHandlers({
[16:13:59.613]             ...future.value <- base::withVisible(base::local({
[16:13:59.613]                 ...future.makeSendCondition <- local({
[16:13:59.613]                   sendCondition <- NULL
[16:13:59.613]                   function(frame = 1L) {
[16:13:59.613]                     if (is.function(sendCondition)) 
[16:13:59.613]                       return(sendCondition)
[16:13:59.613]                     ns <- getNamespace("parallel")
[16:13:59.613]                     if (exists("sendData", mode = "function", 
[16:13:59.613]                       envir = ns)) {
[16:13:59.613]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:59.613]                         envir = ns)
[16:13:59.613]                       envir <- sys.frame(frame)
[16:13:59.613]                       master <- NULL
[16:13:59.613]                       while (!identical(envir, .GlobalEnv) && 
[16:13:59.613]                         !identical(envir, emptyenv())) {
[16:13:59.613]                         if (exists("master", mode = "list", envir = envir, 
[16:13:59.613]                           inherits = FALSE)) {
[16:13:59.613]                           master <- get("master", mode = "list", 
[16:13:59.613]                             envir = envir, inherits = FALSE)
[16:13:59.613]                           if (inherits(master, c("SOCKnode", 
[16:13:59.613]                             "SOCK0node"))) {
[16:13:59.613]                             sendCondition <<- function(cond) {
[16:13:59.613]                               data <- list(type = "VALUE", value = cond, 
[16:13:59.613]                                 success = TRUE)
[16:13:59.613]                               parallel_sendData(master, data)
[16:13:59.613]                             }
[16:13:59.613]                             return(sendCondition)
[16:13:59.613]                           }
[16:13:59.613]                         }
[16:13:59.613]                         frame <- frame + 1L
[16:13:59.613]                         envir <- sys.frame(frame)
[16:13:59.613]                       }
[16:13:59.613]                     }
[16:13:59.613]                     sendCondition <<- function(cond) NULL
[16:13:59.613]                   }
[16:13:59.613]                 })
[16:13:59.613]                 withCallingHandlers({
[16:13:59.613]                   2
[16:13:59.613]                 }, immediateCondition = function(cond) {
[16:13:59.613]                   sendCondition <- ...future.makeSendCondition()
[16:13:59.613]                   sendCondition(cond)
[16:13:59.613]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.613]                   {
[16:13:59.613]                     inherits <- base::inherits
[16:13:59.613]                     invokeRestart <- base::invokeRestart
[16:13:59.613]                     is.null <- base::is.null
[16:13:59.613]                     muffled <- FALSE
[16:13:59.613]                     if (inherits(cond, "message")) {
[16:13:59.613]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:59.613]                       if (muffled) 
[16:13:59.613]                         invokeRestart("muffleMessage")
[16:13:59.613]                     }
[16:13:59.613]                     else if (inherits(cond, "warning")) {
[16:13:59.613]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:59.613]                       if (muffled) 
[16:13:59.613]                         invokeRestart("muffleWarning")
[16:13:59.613]                     }
[16:13:59.613]                     else if (inherits(cond, "condition")) {
[16:13:59.613]                       if (!is.null(pattern)) {
[16:13:59.613]                         computeRestarts <- base::computeRestarts
[16:13:59.613]                         grepl <- base::grepl
[16:13:59.613]                         restarts <- computeRestarts(cond)
[16:13:59.613]                         for (restart in restarts) {
[16:13:59.613]                           name <- restart$name
[16:13:59.613]                           if (is.null(name)) 
[16:13:59.613]                             next
[16:13:59.613]                           if (!grepl(pattern, name)) 
[16:13:59.613]                             next
[16:13:59.613]                           invokeRestart(restart)
[16:13:59.613]                           muffled <- TRUE
[16:13:59.613]                           break
[16:13:59.613]                         }
[16:13:59.613]                       }
[16:13:59.613]                     }
[16:13:59.613]                     invisible(muffled)
[16:13:59.613]                   }
[16:13:59.613]                   muffleCondition(cond)
[16:13:59.613]                 })
[16:13:59.613]             }))
[16:13:59.613]             future::FutureResult(value = ...future.value$value, 
[16:13:59.613]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:59.613]                   ...future.rng), globalenv = if (FALSE) 
[16:13:59.613]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:59.613]                     ...future.globalenv.names))
[16:13:59.613]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:59.613]         }, condition = base::local({
[16:13:59.613]             c <- base::c
[16:13:59.613]             inherits <- base::inherits
[16:13:59.613]             invokeRestart <- base::invokeRestart
[16:13:59.613]             length <- base::length
[16:13:59.613]             list <- base::list
[16:13:59.613]             seq.int <- base::seq.int
[16:13:59.613]             signalCondition <- base::signalCondition
[16:13:59.613]             sys.calls <- base::sys.calls
[16:13:59.613]             `[[` <- base::`[[`
[16:13:59.613]             `+` <- base::`+`
[16:13:59.613]             `<<-` <- base::`<<-`
[16:13:59.613]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:59.613]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:59.613]                   3L)]
[16:13:59.613]             }
[16:13:59.613]             function(cond) {
[16:13:59.613]                 is_error <- inherits(cond, "error")
[16:13:59.613]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:59.613]                   NULL)
[16:13:59.613]                 if (is_error) {
[16:13:59.613]                   sessionInformation <- function() {
[16:13:59.613]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:59.613]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:59.613]                       search = base::search(), system = base::Sys.info())
[16:13:59.613]                   }
[16:13:59.613]                   ...future.conditions[[length(...future.conditions) + 
[16:13:59.613]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:59.613]                     cond$call), session = sessionInformation(), 
[16:13:59.613]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:59.613]                   signalCondition(cond)
[16:13:59.613]                 }
[16:13:59.613]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:59.613]                 "immediateCondition"))) {
[16:13:59.613]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:59.613]                   ...future.conditions[[length(...future.conditions) + 
[16:13:59.613]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:59.613]                   if (TRUE && !signal) {
[16:13:59.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.613]                     {
[16:13:59.613]                       inherits <- base::inherits
[16:13:59.613]                       invokeRestart <- base::invokeRestart
[16:13:59.613]                       is.null <- base::is.null
[16:13:59.613]                       muffled <- FALSE
[16:13:59.613]                       if (inherits(cond, "message")) {
[16:13:59.613]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:59.613]                         if (muffled) 
[16:13:59.613]                           invokeRestart("muffleMessage")
[16:13:59.613]                       }
[16:13:59.613]                       else if (inherits(cond, "warning")) {
[16:13:59.613]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:59.613]                         if (muffled) 
[16:13:59.613]                           invokeRestart("muffleWarning")
[16:13:59.613]                       }
[16:13:59.613]                       else if (inherits(cond, "condition")) {
[16:13:59.613]                         if (!is.null(pattern)) {
[16:13:59.613]                           computeRestarts <- base::computeRestarts
[16:13:59.613]                           grepl <- base::grepl
[16:13:59.613]                           restarts <- computeRestarts(cond)
[16:13:59.613]                           for (restart in restarts) {
[16:13:59.613]                             name <- restart$name
[16:13:59.613]                             if (is.null(name)) 
[16:13:59.613]                               next
[16:13:59.613]                             if (!grepl(pattern, name)) 
[16:13:59.613]                               next
[16:13:59.613]                             invokeRestart(restart)
[16:13:59.613]                             muffled <- TRUE
[16:13:59.613]                             break
[16:13:59.613]                           }
[16:13:59.613]                         }
[16:13:59.613]                       }
[16:13:59.613]                       invisible(muffled)
[16:13:59.613]                     }
[16:13:59.613]                     muffleCondition(cond, pattern = "^muffle")
[16:13:59.613]                   }
[16:13:59.613]                 }
[16:13:59.613]                 else {
[16:13:59.613]                   if (TRUE) {
[16:13:59.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.613]                     {
[16:13:59.613]                       inherits <- base::inherits
[16:13:59.613]                       invokeRestart <- base::invokeRestart
[16:13:59.613]                       is.null <- base::is.null
[16:13:59.613]                       muffled <- FALSE
[16:13:59.613]                       if (inherits(cond, "message")) {
[16:13:59.613]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:59.613]                         if (muffled) 
[16:13:59.613]                           invokeRestart("muffleMessage")
[16:13:59.613]                       }
[16:13:59.613]                       else if (inherits(cond, "warning")) {
[16:13:59.613]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:59.613]                         if (muffled) 
[16:13:59.613]                           invokeRestart("muffleWarning")
[16:13:59.613]                       }
[16:13:59.613]                       else if (inherits(cond, "condition")) {
[16:13:59.613]                         if (!is.null(pattern)) {
[16:13:59.613]                           computeRestarts <- base::computeRestarts
[16:13:59.613]                           grepl <- base::grepl
[16:13:59.613]                           restarts <- computeRestarts(cond)
[16:13:59.613]                           for (restart in restarts) {
[16:13:59.613]                             name <- restart$name
[16:13:59.613]                             if (is.null(name)) 
[16:13:59.613]                               next
[16:13:59.613]                             if (!grepl(pattern, name)) 
[16:13:59.613]                               next
[16:13:59.613]                             invokeRestart(restart)
[16:13:59.613]                             muffled <- TRUE
[16:13:59.613]                             break
[16:13:59.613]                           }
[16:13:59.613]                         }
[16:13:59.613]                       }
[16:13:59.613]                       invisible(muffled)
[16:13:59.613]                     }
[16:13:59.613]                     muffleCondition(cond, pattern = "^muffle")
[16:13:59.613]                   }
[16:13:59.613]                 }
[16:13:59.613]             }
[16:13:59.613]         }))
[16:13:59.613]     }, error = function(ex) {
[16:13:59.613]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:59.613]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:59.613]                 ...future.rng), started = ...future.startTime, 
[16:13:59.613]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:59.613]             version = "1.8"), class = "FutureResult")
[16:13:59.613]     }, finally = {
[16:13:59.613]         if (!identical(...future.workdir, getwd())) 
[16:13:59.613]             setwd(...future.workdir)
[16:13:59.613]         {
[16:13:59.613]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:59.613]                 ...future.oldOptions$nwarnings <- NULL
[16:13:59.613]             }
[16:13:59.613]             base::options(...future.oldOptions)
[16:13:59.613]             if (.Platform$OS.type == "windows") {
[16:13:59.613]                 old_names <- names(...future.oldEnvVars)
[16:13:59.613]                 envs <- base::Sys.getenv()
[16:13:59.613]                 names <- names(envs)
[16:13:59.613]                 common <- intersect(names, old_names)
[16:13:59.613]                 added <- setdiff(names, old_names)
[16:13:59.613]                 removed <- setdiff(old_names, names)
[16:13:59.613]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:59.613]                   envs[common]]
[16:13:59.613]                 NAMES <- toupper(changed)
[16:13:59.613]                 args <- list()
[16:13:59.613]                 for (kk in seq_along(NAMES)) {
[16:13:59.613]                   name <- changed[[kk]]
[16:13:59.613]                   NAME <- NAMES[[kk]]
[16:13:59.613]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.613]                     next
[16:13:59.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:59.613]                 }
[16:13:59.613]                 NAMES <- toupper(added)
[16:13:59.613]                 for (kk in seq_along(NAMES)) {
[16:13:59.613]                   name <- added[[kk]]
[16:13:59.613]                   NAME <- NAMES[[kk]]
[16:13:59.613]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.613]                     next
[16:13:59.613]                   args[[name]] <- ""
[16:13:59.613]                 }
[16:13:59.613]                 NAMES <- toupper(removed)
[16:13:59.613]                 for (kk in seq_along(NAMES)) {
[16:13:59.613]                   name <- removed[[kk]]
[16:13:59.613]                   NAME <- NAMES[[kk]]
[16:13:59.613]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.613]                     next
[16:13:59.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:59.613]                 }
[16:13:59.613]                 if (length(args) > 0) 
[16:13:59.613]                   base::do.call(base::Sys.setenv, args = args)
[16:13:59.613]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:59.613]             }
[16:13:59.613]             else {
[16:13:59.613]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:59.613]             }
[16:13:59.613]             {
[16:13:59.613]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:59.613]                   0L) {
[16:13:59.613]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:59.613]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:59.613]                   base::options(opts)
[16:13:59.613]                 }
[16:13:59.613]                 {
[16:13:59.613]                   {
[16:13:59.613]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:59.613]                     NULL
[16:13:59.613]                   }
[16:13:59.613]                   options(future.plan = NULL)
[16:13:59.613]                   if (is.na(NA_character_)) 
[16:13:59.613]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:59.613]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:59.613]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:59.613]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:59.613]                     envir = parent.frame()) 
[16:13:59.613]                   {
[16:13:59.613]                     if (is.function(workers)) 
[16:13:59.613]                       workers <- workers()
[16:13:59.613]                     workers <- structure(as.integer(workers), 
[16:13:59.613]                       class = class(workers))
[16:13:59.613]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:59.613]                       workers >= 1)
[16:13:59.613]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:59.613]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:59.613]                     }
[16:13:59.613]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:59.613]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:59.613]                       envir = envir)
[16:13:59.613]                     if (!future$lazy) 
[16:13:59.613]                       future <- run(future)
[16:13:59.613]                     invisible(future)
[16:13:59.613]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:59.613]                 }
[16:13:59.613]             }
[16:13:59.613]         }
[16:13:59.613]     })
[16:13:59.613]     if (TRUE) {
[16:13:59.613]         base::sink(type = "output", split = FALSE)
[16:13:59.613]         if (TRUE) {
[16:13:59.613]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:59.613]         }
[16:13:59.613]         else {
[16:13:59.613]             ...future.result["stdout"] <- base::list(NULL)
[16:13:59.613]         }
[16:13:59.613]         base::close(...future.stdout)
[16:13:59.613]         ...future.stdout <- NULL
[16:13:59.613]     }
[16:13:59.613]     ...future.result$conditions <- ...future.conditions
[16:13:59.613]     ...future.result$finished <- base::Sys.time()
[16:13:59.613]     ...future.result
[16:13:59.613] }
[16:13:59.616] MultisessionFuture started
[16:13:59.616] - Launch lazy future ... done
[16:13:59.616] run() for ‘MultisessionFuture’ ... done
[16:13:59.617] resolve() on list ...
[16:13:59.617]  recursive: 0
[16:13:59.617]  length: 3
[16:13:59.617]  elements: ‘a’, ‘b’, ‘’
[16:13:59.617] run() for ‘Future’ ...
[16:13:59.617] - state: ‘created’
[16:13:59.617] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:59.631] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:59.632] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:59.632]   - Field: ‘node’
[16:13:59.632]   - Field: ‘label’
[16:13:59.632]   - Field: ‘local’
[16:13:59.632]   - Field: ‘owner’
[16:13:59.632]   - Field: ‘envir’
[16:13:59.632]   - Field: ‘workers’
[16:13:59.632]   - Field: ‘packages’
[16:13:59.632]   - Field: ‘gc’
[16:13:59.633]   - Field: ‘conditions’
[16:13:59.633]   - Field: ‘persistent’
[16:13:59.633]   - Field: ‘expr’
[16:13:59.633]   - Field: ‘uuid’
[16:13:59.633]   - Field: ‘seed’
[16:13:59.633]   - Field: ‘version’
[16:13:59.633]   - Field: ‘result’
[16:13:59.633]   - Field: ‘asynchronous’
[16:13:59.633]   - Field: ‘calls’
[16:13:59.633]   - Field: ‘globals’
[16:13:59.633]   - Field: ‘stdout’
[16:13:59.634]   - Field: ‘earlySignal’
[16:13:59.634]   - Field: ‘lazy’
[16:13:59.634]   - Field: ‘state’
[16:13:59.634] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:59.634] - Launch lazy future ...
[16:13:59.634] Packages needed by the future expression (n = 0): <none>
[16:13:59.634] Packages needed by future strategies (n = 0): <none>
[16:13:59.635] {
[16:13:59.635]     {
[16:13:59.635]         {
[16:13:59.635]             ...future.startTime <- base::Sys.time()
[16:13:59.635]             {
[16:13:59.635]                 {
[16:13:59.635]                   {
[16:13:59.635]                     {
[16:13:59.635]                       base::local({
[16:13:59.635]                         has_future <- base::requireNamespace("future", 
[16:13:59.635]                           quietly = TRUE)
[16:13:59.635]                         if (has_future) {
[16:13:59.635]                           ns <- base::getNamespace("future")
[16:13:59.635]                           version <- ns[[".package"]][["version"]]
[16:13:59.635]                           if (is.null(version)) 
[16:13:59.635]                             version <- utils::packageVersion("future")
[16:13:59.635]                         }
[16:13:59.635]                         else {
[16:13:59.635]                           version <- NULL
[16:13:59.635]                         }
[16:13:59.635]                         if (!has_future || version < "1.8.0") {
[16:13:59.635]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:59.635]                             "", base::R.version$version.string), 
[16:13:59.635]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:59.635]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:59.635]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:59.635]                               "release", "version")], collapse = " "), 
[16:13:59.635]                             hostname = base::Sys.info()[["nodename"]])
[16:13:59.635]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:59.635]                             info)
[16:13:59.635]                           info <- base::paste(info, collapse = "; ")
[16:13:59.635]                           if (!has_future) {
[16:13:59.635]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:59.635]                               info)
[16:13:59.635]                           }
[16:13:59.635]                           else {
[16:13:59.635]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:59.635]                               info, version)
[16:13:59.635]                           }
[16:13:59.635]                           base::stop(msg)
[16:13:59.635]                         }
[16:13:59.635]                       })
[16:13:59.635]                     }
[16:13:59.635]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:59.635]                     base::options(mc.cores = 1L)
[16:13:59.635]                   }
[16:13:59.635]                   options(future.plan = NULL)
[16:13:59.635]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:59.635]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:59.635]                 }
[16:13:59.635]                 ...future.workdir <- getwd()
[16:13:59.635]             }
[16:13:59.635]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:59.635]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:59.635]         }
[16:13:59.635]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:59.635]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:59.635]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:59.635]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:59.635]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:59.635]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:59.635]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:59.635]             base::names(...future.oldOptions))
[16:13:59.635]     }
[16:13:59.635]     if (FALSE) {
[16:13:59.635]     }
[16:13:59.635]     else {
[16:13:59.635]         if (TRUE) {
[16:13:59.635]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:59.635]                 open = "w")
[16:13:59.635]         }
[16:13:59.635]         else {
[16:13:59.635]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:59.635]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:59.635]         }
[16:13:59.635]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:59.635]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:59.635]             base::sink(type = "output", split = FALSE)
[16:13:59.635]             base::close(...future.stdout)
[16:13:59.635]         }, add = TRUE)
[16:13:59.635]     }
[16:13:59.635]     ...future.frame <- base::sys.nframe()
[16:13:59.635]     ...future.conditions <- base::list()
[16:13:59.635]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:59.635]     if (FALSE) {
[16:13:59.635]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:59.635]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:59.635]     }
[16:13:59.635]     ...future.result <- base::tryCatch({
[16:13:59.635]         base::withCallingHandlers({
[16:13:59.635]             ...future.value <- base::withVisible(base::local({
[16:13:59.635]                 ...future.makeSendCondition <- local({
[16:13:59.635]                   sendCondition <- NULL
[16:13:59.635]                   function(frame = 1L) {
[16:13:59.635]                     if (is.function(sendCondition)) 
[16:13:59.635]                       return(sendCondition)
[16:13:59.635]                     ns <- getNamespace("parallel")
[16:13:59.635]                     if (exists("sendData", mode = "function", 
[16:13:59.635]                       envir = ns)) {
[16:13:59.635]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:59.635]                         envir = ns)
[16:13:59.635]                       envir <- sys.frame(frame)
[16:13:59.635]                       master <- NULL
[16:13:59.635]                       while (!identical(envir, .GlobalEnv) && 
[16:13:59.635]                         !identical(envir, emptyenv())) {
[16:13:59.635]                         if (exists("master", mode = "list", envir = envir, 
[16:13:59.635]                           inherits = FALSE)) {
[16:13:59.635]                           master <- get("master", mode = "list", 
[16:13:59.635]                             envir = envir, inherits = FALSE)
[16:13:59.635]                           if (inherits(master, c("SOCKnode", 
[16:13:59.635]                             "SOCK0node"))) {
[16:13:59.635]                             sendCondition <<- function(cond) {
[16:13:59.635]                               data <- list(type = "VALUE", value = cond, 
[16:13:59.635]                                 success = TRUE)
[16:13:59.635]                               parallel_sendData(master, data)
[16:13:59.635]                             }
[16:13:59.635]                             return(sendCondition)
[16:13:59.635]                           }
[16:13:59.635]                         }
[16:13:59.635]                         frame <- frame + 1L
[16:13:59.635]                         envir <- sys.frame(frame)
[16:13:59.635]                       }
[16:13:59.635]                     }
[16:13:59.635]                     sendCondition <<- function(cond) NULL
[16:13:59.635]                   }
[16:13:59.635]                 })
[16:13:59.635]                 withCallingHandlers({
[16:13:59.635]                   1
[16:13:59.635]                 }, immediateCondition = function(cond) {
[16:13:59.635]                   sendCondition <- ...future.makeSendCondition()
[16:13:59.635]                   sendCondition(cond)
[16:13:59.635]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.635]                   {
[16:13:59.635]                     inherits <- base::inherits
[16:13:59.635]                     invokeRestart <- base::invokeRestart
[16:13:59.635]                     is.null <- base::is.null
[16:13:59.635]                     muffled <- FALSE
[16:13:59.635]                     if (inherits(cond, "message")) {
[16:13:59.635]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:59.635]                       if (muffled) 
[16:13:59.635]                         invokeRestart("muffleMessage")
[16:13:59.635]                     }
[16:13:59.635]                     else if (inherits(cond, "warning")) {
[16:13:59.635]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:59.635]                       if (muffled) 
[16:13:59.635]                         invokeRestart("muffleWarning")
[16:13:59.635]                     }
[16:13:59.635]                     else if (inherits(cond, "condition")) {
[16:13:59.635]                       if (!is.null(pattern)) {
[16:13:59.635]                         computeRestarts <- base::computeRestarts
[16:13:59.635]                         grepl <- base::grepl
[16:13:59.635]                         restarts <- computeRestarts(cond)
[16:13:59.635]                         for (restart in restarts) {
[16:13:59.635]                           name <- restart$name
[16:13:59.635]                           if (is.null(name)) 
[16:13:59.635]                             next
[16:13:59.635]                           if (!grepl(pattern, name)) 
[16:13:59.635]                             next
[16:13:59.635]                           invokeRestart(restart)
[16:13:59.635]                           muffled <- TRUE
[16:13:59.635]                           break
[16:13:59.635]                         }
[16:13:59.635]                       }
[16:13:59.635]                     }
[16:13:59.635]                     invisible(muffled)
[16:13:59.635]                   }
[16:13:59.635]                   muffleCondition(cond)
[16:13:59.635]                 })
[16:13:59.635]             }))
[16:13:59.635]             future::FutureResult(value = ...future.value$value, 
[16:13:59.635]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:59.635]                   ...future.rng), globalenv = if (FALSE) 
[16:13:59.635]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:59.635]                     ...future.globalenv.names))
[16:13:59.635]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:59.635]         }, condition = base::local({
[16:13:59.635]             c <- base::c
[16:13:59.635]             inherits <- base::inherits
[16:13:59.635]             invokeRestart <- base::invokeRestart
[16:13:59.635]             length <- base::length
[16:13:59.635]             list <- base::list
[16:13:59.635]             seq.int <- base::seq.int
[16:13:59.635]             signalCondition <- base::signalCondition
[16:13:59.635]             sys.calls <- base::sys.calls
[16:13:59.635]             `[[` <- base::`[[`
[16:13:59.635]             `+` <- base::`+`
[16:13:59.635]             `<<-` <- base::`<<-`
[16:13:59.635]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:59.635]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:59.635]                   3L)]
[16:13:59.635]             }
[16:13:59.635]             function(cond) {
[16:13:59.635]                 is_error <- inherits(cond, "error")
[16:13:59.635]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:59.635]                   NULL)
[16:13:59.635]                 if (is_error) {
[16:13:59.635]                   sessionInformation <- function() {
[16:13:59.635]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:59.635]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:59.635]                       search = base::search(), system = base::Sys.info())
[16:13:59.635]                   }
[16:13:59.635]                   ...future.conditions[[length(...future.conditions) + 
[16:13:59.635]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:59.635]                     cond$call), session = sessionInformation(), 
[16:13:59.635]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:59.635]                   signalCondition(cond)
[16:13:59.635]                 }
[16:13:59.635]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:59.635]                 "immediateCondition"))) {
[16:13:59.635]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:59.635]                   ...future.conditions[[length(...future.conditions) + 
[16:13:59.635]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:59.635]                   if (TRUE && !signal) {
[16:13:59.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.635]                     {
[16:13:59.635]                       inherits <- base::inherits
[16:13:59.635]                       invokeRestart <- base::invokeRestart
[16:13:59.635]                       is.null <- base::is.null
[16:13:59.635]                       muffled <- FALSE
[16:13:59.635]                       if (inherits(cond, "message")) {
[16:13:59.635]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:59.635]                         if (muffled) 
[16:13:59.635]                           invokeRestart("muffleMessage")
[16:13:59.635]                       }
[16:13:59.635]                       else if (inherits(cond, "warning")) {
[16:13:59.635]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:59.635]                         if (muffled) 
[16:13:59.635]                           invokeRestart("muffleWarning")
[16:13:59.635]                       }
[16:13:59.635]                       else if (inherits(cond, "condition")) {
[16:13:59.635]                         if (!is.null(pattern)) {
[16:13:59.635]                           computeRestarts <- base::computeRestarts
[16:13:59.635]                           grepl <- base::grepl
[16:13:59.635]                           restarts <- computeRestarts(cond)
[16:13:59.635]                           for (restart in restarts) {
[16:13:59.635]                             name <- restart$name
[16:13:59.635]                             if (is.null(name)) 
[16:13:59.635]                               next
[16:13:59.635]                             if (!grepl(pattern, name)) 
[16:13:59.635]                               next
[16:13:59.635]                             invokeRestart(restart)
[16:13:59.635]                             muffled <- TRUE
[16:13:59.635]                             break
[16:13:59.635]                           }
[16:13:59.635]                         }
[16:13:59.635]                       }
[16:13:59.635]                       invisible(muffled)
[16:13:59.635]                     }
[16:13:59.635]                     muffleCondition(cond, pattern = "^muffle")
[16:13:59.635]                   }
[16:13:59.635]                 }
[16:13:59.635]                 else {
[16:13:59.635]                   if (TRUE) {
[16:13:59.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.635]                     {
[16:13:59.635]                       inherits <- base::inherits
[16:13:59.635]                       invokeRestart <- base::invokeRestart
[16:13:59.635]                       is.null <- base::is.null
[16:13:59.635]                       muffled <- FALSE
[16:13:59.635]                       if (inherits(cond, "message")) {
[16:13:59.635]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:59.635]                         if (muffled) 
[16:13:59.635]                           invokeRestart("muffleMessage")
[16:13:59.635]                       }
[16:13:59.635]                       else if (inherits(cond, "warning")) {
[16:13:59.635]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:59.635]                         if (muffled) 
[16:13:59.635]                           invokeRestart("muffleWarning")
[16:13:59.635]                       }
[16:13:59.635]                       else if (inherits(cond, "condition")) {
[16:13:59.635]                         if (!is.null(pattern)) {
[16:13:59.635]                           computeRestarts <- base::computeRestarts
[16:13:59.635]                           grepl <- base::grepl
[16:13:59.635]                           restarts <- computeRestarts(cond)
[16:13:59.635]                           for (restart in restarts) {
[16:13:59.635]                             name <- restart$name
[16:13:59.635]                             if (is.null(name)) 
[16:13:59.635]                               next
[16:13:59.635]                             if (!grepl(pattern, name)) 
[16:13:59.635]                               next
[16:13:59.635]                             invokeRestart(restart)
[16:13:59.635]                             muffled <- TRUE
[16:13:59.635]                             break
[16:13:59.635]                           }
[16:13:59.635]                         }
[16:13:59.635]                       }
[16:13:59.635]                       invisible(muffled)
[16:13:59.635]                     }
[16:13:59.635]                     muffleCondition(cond, pattern = "^muffle")
[16:13:59.635]                   }
[16:13:59.635]                 }
[16:13:59.635]             }
[16:13:59.635]         }))
[16:13:59.635]     }, error = function(ex) {
[16:13:59.635]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:59.635]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:59.635]                 ...future.rng), started = ...future.startTime, 
[16:13:59.635]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:59.635]             version = "1.8"), class = "FutureResult")
[16:13:59.635]     }, finally = {
[16:13:59.635]         if (!identical(...future.workdir, getwd())) 
[16:13:59.635]             setwd(...future.workdir)
[16:13:59.635]         {
[16:13:59.635]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:59.635]                 ...future.oldOptions$nwarnings <- NULL
[16:13:59.635]             }
[16:13:59.635]             base::options(...future.oldOptions)
[16:13:59.635]             if (.Platform$OS.type == "windows") {
[16:13:59.635]                 old_names <- names(...future.oldEnvVars)
[16:13:59.635]                 envs <- base::Sys.getenv()
[16:13:59.635]                 names <- names(envs)
[16:13:59.635]                 common <- intersect(names, old_names)
[16:13:59.635]                 added <- setdiff(names, old_names)
[16:13:59.635]                 removed <- setdiff(old_names, names)
[16:13:59.635]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:59.635]                   envs[common]]
[16:13:59.635]                 NAMES <- toupper(changed)
[16:13:59.635]                 args <- list()
[16:13:59.635]                 for (kk in seq_along(NAMES)) {
[16:13:59.635]                   name <- changed[[kk]]
[16:13:59.635]                   NAME <- NAMES[[kk]]
[16:13:59.635]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.635]                     next
[16:13:59.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:59.635]                 }
[16:13:59.635]                 NAMES <- toupper(added)
[16:13:59.635]                 for (kk in seq_along(NAMES)) {
[16:13:59.635]                   name <- added[[kk]]
[16:13:59.635]                   NAME <- NAMES[[kk]]
[16:13:59.635]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.635]                     next
[16:13:59.635]                   args[[name]] <- ""
[16:13:59.635]                 }
[16:13:59.635]                 NAMES <- toupper(removed)
[16:13:59.635]                 for (kk in seq_along(NAMES)) {
[16:13:59.635]                   name <- removed[[kk]]
[16:13:59.635]                   NAME <- NAMES[[kk]]
[16:13:59.635]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.635]                     next
[16:13:59.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:59.635]                 }
[16:13:59.635]                 if (length(args) > 0) 
[16:13:59.635]                   base::do.call(base::Sys.setenv, args = args)
[16:13:59.635]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:59.635]             }
[16:13:59.635]             else {
[16:13:59.635]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:59.635]             }
[16:13:59.635]             {
[16:13:59.635]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:59.635]                   0L) {
[16:13:59.635]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:59.635]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:59.635]                   base::options(opts)
[16:13:59.635]                 }
[16:13:59.635]                 {
[16:13:59.635]                   {
[16:13:59.635]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:59.635]                     NULL
[16:13:59.635]                   }
[16:13:59.635]                   options(future.plan = NULL)
[16:13:59.635]                   if (is.na(NA_character_)) 
[16:13:59.635]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:59.635]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:59.635]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:59.635]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:59.635]                     envir = parent.frame()) 
[16:13:59.635]                   {
[16:13:59.635]                     if (is.function(workers)) 
[16:13:59.635]                       workers <- workers()
[16:13:59.635]                     workers <- structure(as.integer(workers), 
[16:13:59.635]                       class = class(workers))
[16:13:59.635]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:59.635]                       workers >= 1)
[16:13:59.635]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:59.635]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:59.635]                     }
[16:13:59.635]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:59.635]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:59.635]                       envir = envir)
[16:13:59.635]                     if (!future$lazy) 
[16:13:59.635]                       future <- run(future)
[16:13:59.635]                     invisible(future)
[16:13:59.635]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:59.635]                 }
[16:13:59.635]             }
[16:13:59.635]         }
[16:13:59.635]     })
[16:13:59.635]     if (TRUE) {
[16:13:59.635]         base::sink(type = "output", split = FALSE)
[16:13:59.635]         if (TRUE) {
[16:13:59.635]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:59.635]         }
[16:13:59.635]         else {
[16:13:59.635]             ...future.result["stdout"] <- base::list(NULL)
[16:13:59.635]         }
[16:13:59.635]         base::close(...future.stdout)
[16:13:59.635]         ...future.stdout <- NULL
[16:13:59.635]     }
[16:13:59.635]     ...future.result$conditions <- ...future.conditions
[16:13:59.635]     ...future.result$finished <- base::Sys.time()
[16:13:59.635]     ...future.result
[16:13:59.635] }
[16:13:59.638] MultisessionFuture started
[16:13:59.638] - Launch lazy future ... done
[16:13:59.638] run() for ‘MultisessionFuture’ ... done
[16:13:59.659]  length: 2 (resolved future 3)
[16:13:59.680] receiveMessageFromWorker() for ClusterFuture ...
[16:13:59.680] - Validating connection of MultisessionFuture
[16:13:59.680] - received message: FutureResult
[16:13:59.681] - Received FutureResult
[16:13:59.681] - Erased future from FutureRegistry
[16:13:59.681] result() for ClusterFuture ...
[16:13:59.681] - result already collected: FutureResult
[16:13:59.681] result() for ClusterFuture ... done
[16:13:59.681] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:59.681] Future #2
[16:13:59.681]  length: 1 (resolved future 2)
[16:13:59.692] receiveMessageFromWorker() for ClusterFuture ...
[16:13:59.692] - Validating connection of MultisessionFuture
[16:13:59.692] - received message: FutureResult
[16:13:59.693] - Received FutureResult
[16:13:59.693] - Erased future from FutureRegistry
[16:13:59.693] result() for ClusterFuture ...
[16:13:59.693] - result already collected: FutureResult
[16:13:59.693] result() for ClusterFuture ... done
[16:13:59.693] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:59.693] Future #1
[16:13:59.693]  length: 0 (resolved future 1)
[16:13:59.693] resolve() on list ... DONE
[16:13:59.693] getGlobalsAndPackages() ...
[16:13:59.694] Searching for globals...
[16:13:59.694] 
[16:13:59.694] Searching for globals ... DONE
[16:13:59.694] - globals: [0] <none>
[16:13:59.694] getGlobalsAndPackages() ... DONE
[16:13:59.694] getGlobalsAndPackages() ...
[16:13:59.695] Searching for globals...
[16:13:59.695] 
[16:13:59.695] Searching for globals ... DONE
[16:13:59.695] - globals: [0] <none>
[16:13:59.695] getGlobalsAndPackages() ... DONE
[16:13:59.695] resolve() on list ...
[16:13:59.695]  recursive: 0
[16:13:59.696]  length: 3
[16:13:59.698]  elements: ‘a’, ‘b’, ‘’
[16:13:59.698] run() for ‘Future’ ...
[16:13:59.698] - state: ‘created’
[16:13:59.699] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:59.713] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:59.713] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:59.713]   - Field: ‘node’
[16:13:59.713]   - Field: ‘label’
[16:13:59.713]   - Field: ‘local’
[16:13:59.713]   - Field: ‘owner’
[16:13:59.714]   - Field: ‘envir’
[16:13:59.714]   - Field: ‘workers’
[16:13:59.714]   - Field: ‘packages’
[16:13:59.714]   - Field: ‘gc’
[16:13:59.714]   - Field: ‘conditions’
[16:13:59.714]   - Field: ‘persistent’
[16:13:59.714]   - Field: ‘expr’
[16:13:59.714]   - Field: ‘uuid’
[16:13:59.714]   - Field: ‘seed’
[16:13:59.714]   - Field: ‘version’
[16:13:59.714]   - Field: ‘result’
[16:13:59.715]   - Field: ‘asynchronous’
[16:13:59.715]   - Field: ‘calls’
[16:13:59.715]   - Field: ‘globals’
[16:13:59.715]   - Field: ‘stdout’
[16:13:59.715]   - Field: ‘earlySignal’
[16:13:59.715]   - Field: ‘lazy’
[16:13:59.715]   - Field: ‘state’
[16:13:59.715] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:59.715] - Launch lazy future ...
[16:13:59.715] Packages needed by the future expression (n = 0): <none>
[16:13:59.716] Packages needed by future strategies (n = 0): <none>
[16:13:59.716] {
[16:13:59.716]     {
[16:13:59.716]         {
[16:13:59.716]             ...future.startTime <- base::Sys.time()
[16:13:59.716]             {
[16:13:59.716]                 {
[16:13:59.716]                   {
[16:13:59.716]                     {
[16:13:59.716]                       base::local({
[16:13:59.716]                         has_future <- base::requireNamespace("future", 
[16:13:59.716]                           quietly = TRUE)
[16:13:59.716]                         if (has_future) {
[16:13:59.716]                           ns <- base::getNamespace("future")
[16:13:59.716]                           version <- ns[[".package"]][["version"]]
[16:13:59.716]                           if (is.null(version)) 
[16:13:59.716]                             version <- utils::packageVersion("future")
[16:13:59.716]                         }
[16:13:59.716]                         else {
[16:13:59.716]                           version <- NULL
[16:13:59.716]                         }
[16:13:59.716]                         if (!has_future || version < "1.8.0") {
[16:13:59.716]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:59.716]                             "", base::R.version$version.string), 
[16:13:59.716]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:59.716]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:59.716]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:59.716]                               "release", "version")], collapse = " "), 
[16:13:59.716]                             hostname = base::Sys.info()[["nodename"]])
[16:13:59.716]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:59.716]                             info)
[16:13:59.716]                           info <- base::paste(info, collapse = "; ")
[16:13:59.716]                           if (!has_future) {
[16:13:59.716]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:59.716]                               info)
[16:13:59.716]                           }
[16:13:59.716]                           else {
[16:13:59.716]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:59.716]                               info, version)
[16:13:59.716]                           }
[16:13:59.716]                           base::stop(msg)
[16:13:59.716]                         }
[16:13:59.716]                       })
[16:13:59.716]                     }
[16:13:59.716]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:59.716]                     base::options(mc.cores = 1L)
[16:13:59.716]                   }
[16:13:59.716]                   options(future.plan = NULL)
[16:13:59.716]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:59.716]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:59.716]                 }
[16:13:59.716]                 ...future.workdir <- getwd()
[16:13:59.716]             }
[16:13:59.716]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:59.716]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:59.716]         }
[16:13:59.716]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:59.716]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:59.716]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:59.716]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:59.716]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:59.716]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:59.716]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:59.716]             base::names(...future.oldOptions))
[16:13:59.716]     }
[16:13:59.716]     if (FALSE) {
[16:13:59.716]     }
[16:13:59.716]     else {
[16:13:59.716]         if (TRUE) {
[16:13:59.716]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:59.716]                 open = "w")
[16:13:59.716]         }
[16:13:59.716]         else {
[16:13:59.716]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:59.716]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:59.716]         }
[16:13:59.716]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:59.716]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:59.716]             base::sink(type = "output", split = FALSE)
[16:13:59.716]             base::close(...future.stdout)
[16:13:59.716]         }, add = TRUE)
[16:13:59.716]     }
[16:13:59.716]     ...future.frame <- base::sys.nframe()
[16:13:59.716]     ...future.conditions <- base::list()
[16:13:59.716]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:59.716]     if (FALSE) {
[16:13:59.716]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:59.716]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:59.716]     }
[16:13:59.716]     ...future.result <- base::tryCatch({
[16:13:59.716]         base::withCallingHandlers({
[16:13:59.716]             ...future.value <- base::withVisible(base::local({
[16:13:59.716]                 ...future.makeSendCondition <- local({
[16:13:59.716]                   sendCondition <- NULL
[16:13:59.716]                   function(frame = 1L) {
[16:13:59.716]                     if (is.function(sendCondition)) 
[16:13:59.716]                       return(sendCondition)
[16:13:59.716]                     ns <- getNamespace("parallel")
[16:13:59.716]                     if (exists("sendData", mode = "function", 
[16:13:59.716]                       envir = ns)) {
[16:13:59.716]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:59.716]                         envir = ns)
[16:13:59.716]                       envir <- sys.frame(frame)
[16:13:59.716]                       master <- NULL
[16:13:59.716]                       while (!identical(envir, .GlobalEnv) && 
[16:13:59.716]                         !identical(envir, emptyenv())) {
[16:13:59.716]                         if (exists("master", mode = "list", envir = envir, 
[16:13:59.716]                           inherits = FALSE)) {
[16:13:59.716]                           master <- get("master", mode = "list", 
[16:13:59.716]                             envir = envir, inherits = FALSE)
[16:13:59.716]                           if (inherits(master, c("SOCKnode", 
[16:13:59.716]                             "SOCK0node"))) {
[16:13:59.716]                             sendCondition <<- function(cond) {
[16:13:59.716]                               data <- list(type = "VALUE", value = cond, 
[16:13:59.716]                                 success = TRUE)
[16:13:59.716]                               parallel_sendData(master, data)
[16:13:59.716]                             }
[16:13:59.716]                             return(sendCondition)
[16:13:59.716]                           }
[16:13:59.716]                         }
[16:13:59.716]                         frame <- frame + 1L
[16:13:59.716]                         envir <- sys.frame(frame)
[16:13:59.716]                       }
[16:13:59.716]                     }
[16:13:59.716]                     sendCondition <<- function(cond) NULL
[16:13:59.716]                   }
[16:13:59.716]                 })
[16:13:59.716]                 withCallingHandlers({
[16:13:59.716]                   1
[16:13:59.716]                 }, immediateCondition = function(cond) {
[16:13:59.716]                   sendCondition <- ...future.makeSendCondition()
[16:13:59.716]                   sendCondition(cond)
[16:13:59.716]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.716]                   {
[16:13:59.716]                     inherits <- base::inherits
[16:13:59.716]                     invokeRestart <- base::invokeRestart
[16:13:59.716]                     is.null <- base::is.null
[16:13:59.716]                     muffled <- FALSE
[16:13:59.716]                     if (inherits(cond, "message")) {
[16:13:59.716]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:59.716]                       if (muffled) 
[16:13:59.716]                         invokeRestart("muffleMessage")
[16:13:59.716]                     }
[16:13:59.716]                     else if (inherits(cond, "warning")) {
[16:13:59.716]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:59.716]                       if (muffled) 
[16:13:59.716]                         invokeRestart("muffleWarning")
[16:13:59.716]                     }
[16:13:59.716]                     else if (inherits(cond, "condition")) {
[16:13:59.716]                       if (!is.null(pattern)) {
[16:13:59.716]                         computeRestarts <- base::computeRestarts
[16:13:59.716]                         grepl <- base::grepl
[16:13:59.716]                         restarts <- computeRestarts(cond)
[16:13:59.716]                         for (restart in restarts) {
[16:13:59.716]                           name <- restart$name
[16:13:59.716]                           if (is.null(name)) 
[16:13:59.716]                             next
[16:13:59.716]                           if (!grepl(pattern, name)) 
[16:13:59.716]                             next
[16:13:59.716]                           invokeRestart(restart)
[16:13:59.716]                           muffled <- TRUE
[16:13:59.716]                           break
[16:13:59.716]                         }
[16:13:59.716]                       }
[16:13:59.716]                     }
[16:13:59.716]                     invisible(muffled)
[16:13:59.716]                   }
[16:13:59.716]                   muffleCondition(cond)
[16:13:59.716]                 })
[16:13:59.716]             }))
[16:13:59.716]             future::FutureResult(value = ...future.value$value, 
[16:13:59.716]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:59.716]                   ...future.rng), globalenv = if (FALSE) 
[16:13:59.716]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:59.716]                     ...future.globalenv.names))
[16:13:59.716]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:59.716]         }, condition = base::local({
[16:13:59.716]             c <- base::c
[16:13:59.716]             inherits <- base::inherits
[16:13:59.716]             invokeRestart <- base::invokeRestart
[16:13:59.716]             length <- base::length
[16:13:59.716]             list <- base::list
[16:13:59.716]             seq.int <- base::seq.int
[16:13:59.716]             signalCondition <- base::signalCondition
[16:13:59.716]             sys.calls <- base::sys.calls
[16:13:59.716]             `[[` <- base::`[[`
[16:13:59.716]             `+` <- base::`+`
[16:13:59.716]             `<<-` <- base::`<<-`
[16:13:59.716]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:59.716]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:59.716]                   3L)]
[16:13:59.716]             }
[16:13:59.716]             function(cond) {
[16:13:59.716]                 is_error <- inherits(cond, "error")
[16:13:59.716]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:59.716]                   NULL)
[16:13:59.716]                 if (is_error) {
[16:13:59.716]                   sessionInformation <- function() {
[16:13:59.716]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:59.716]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:59.716]                       search = base::search(), system = base::Sys.info())
[16:13:59.716]                   }
[16:13:59.716]                   ...future.conditions[[length(...future.conditions) + 
[16:13:59.716]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:59.716]                     cond$call), session = sessionInformation(), 
[16:13:59.716]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:59.716]                   signalCondition(cond)
[16:13:59.716]                 }
[16:13:59.716]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:59.716]                 "immediateCondition"))) {
[16:13:59.716]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:59.716]                   ...future.conditions[[length(...future.conditions) + 
[16:13:59.716]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:59.716]                   if (TRUE && !signal) {
[16:13:59.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.716]                     {
[16:13:59.716]                       inherits <- base::inherits
[16:13:59.716]                       invokeRestart <- base::invokeRestart
[16:13:59.716]                       is.null <- base::is.null
[16:13:59.716]                       muffled <- FALSE
[16:13:59.716]                       if (inherits(cond, "message")) {
[16:13:59.716]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:59.716]                         if (muffled) 
[16:13:59.716]                           invokeRestart("muffleMessage")
[16:13:59.716]                       }
[16:13:59.716]                       else if (inherits(cond, "warning")) {
[16:13:59.716]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:59.716]                         if (muffled) 
[16:13:59.716]                           invokeRestart("muffleWarning")
[16:13:59.716]                       }
[16:13:59.716]                       else if (inherits(cond, "condition")) {
[16:13:59.716]                         if (!is.null(pattern)) {
[16:13:59.716]                           computeRestarts <- base::computeRestarts
[16:13:59.716]                           grepl <- base::grepl
[16:13:59.716]                           restarts <- computeRestarts(cond)
[16:13:59.716]                           for (restart in restarts) {
[16:13:59.716]                             name <- restart$name
[16:13:59.716]                             if (is.null(name)) 
[16:13:59.716]                               next
[16:13:59.716]                             if (!grepl(pattern, name)) 
[16:13:59.716]                               next
[16:13:59.716]                             invokeRestart(restart)
[16:13:59.716]                             muffled <- TRUE
[16:13:59.716]                             break
[16:13:59.716]                           }
[16:13:59.716]                         }
[16:13:59.716]                       }
[16:13:59.716]                       invisible(muffled)
[16:13:59.716]                     }
[16:13:59.716]                     muffleCondition(cond, pattern = "^muffle")
[16:13:59.716]                   }
[16:13:59.716]                 }
[16:13:59.716]                 else {
[16:13:59.716]                   if (TRUE) {
[16:13:59.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.716]                     {
[16:13:59.716]                       inherits <- base::inherits
[16:13:59.716]                       invokeRestart <- base::invokeRestart
[16:13:59.716]                       is.null <- base::is.null
[16:13:59.716]                       muffled <- FALSE
[16:13:59.716]                       if (inherits(cond, "message")) {
[16:13:59.716]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:59.716]                         if (muffled) 
[16:13:59.716]                           invokeRestart("muffleMessage")
[16:13:59.716]                       }
[16:13:59.716]                       else if (inherits(cond, "warning")) {
[16:13:59.716]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:59.716]                         if (muffled) 
[16:13:59.716]                           invokeRestart("muffleWarning")
[16:13:59.716]                       }
[16:13:59.716]                       else if (inherits(cond, "condition")) {
[16:13:59.716]                         if (!is.null(pattern)) {
[16:13:59.716]                           computeRestarts <- base::computeRestarts
[16:13:59.716]                           grepl <- base::grepl
[16:13:59.716]                           restarts <- computeRestarts(cond)
[16:13:59.716]                           for (restart in restarts) {
[16:13:59.716]                             name <- restart$name
[16:13:59.716]                             if (is.null(name)) 
[16:13:59.716]                               next
[16:13:59.716]                             if (!grepl(pattern, name)) 
[16:13:59.716]                               next
[16:13:59.716]                             invokeRestart(restart)
[16:13:59.716]                             muffled <- TRUE
[16:13:59.716]                             break
[16:13:59.716]                           }
[16:13:59.716]                         }
[16:13:59.716]                       }
[16:13:59.716]                       invisible(muffled)
[16:13:59.716]                     }
[16:13:59.716]                     muffleCondition(cond, pattern = "^muffle")
[16:13:59.716]                   }
[16:13:59.716]                 }
[16:13:59.716]             }
[16:13:59.716]         }))
[16:13:59.716]     }, error = function(ex) {
[16:13:59.716]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:59.716]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:59.716]                 ...future.rng), started = ...future.startTime, 
[16:13:59.716]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:59.716]             version = "1.8"), class = "FutureResult")
[16:13:59.716]     }, finally = {
[16:13:59.716]         if (!identical(...future.workdir, getwd())) 
[16:13:59.716]             setwd(...future.workdir)
[16:13:59.716]         {
[16:13:59.716]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:59.716]                 ...future.oldOptions$nwarnings <- NULL
[16:13:59.716]             }
[16:13:59.716]             base::options(...future.oldOptions)
[16:13:59.716]             if (.Platform$OS.type == "windows") {
[16:13:59.716]                 old_names <- names(...future.oldEnvVars)
[16:13:59.716]                 envs <- base::Sys.getenv()
[16:13:59.716]                 names <- names(envs)
[16:13:59.716]                 common <- intersect(names, old_names)
[16:13:59.716]                 added <- setdiff(names, old_names)
[16:13:59.716]                 removed <- setdiff(old_names, names)
[16:13:59.716]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:59.716]                   envs[common]]
[16:13:59.716]                 NAMES <- toupper(changed)
[16:13:59.716]                 args <- list()
[16:13:59.716]                 for (kk in seq_along(NAMES)) {
[16:13:59.716]                   name <- changed[[kk]]
[16:13:59.716]                   NAME <- NAMES[[kk]]
[16:13:59.716]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.716]                     next
[16:13:59.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:59.716]                 }
[16:13:59.716]                 NAMES <- toupper(added)
[16:13:59.716]                 for (kk in seq_along(NAMES)) {
[16:13:59.716]                   name <- added[[kk]]
[16:13:59.716]                   NAME <- NAMES[[kk]]
[16:13:59.716]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.716]                     next
[16:13:59.716]                   args[[name]] <- ""
[16:13:59.716]                 }
[16:13:59.716]                 NAMES <- toupper(removed)
[16:13:59.716]                 for (kk in seq_along(NAMES)) {
[16:13:59.716]                   name <- removed[[kk]]
[16:13:59.716]                   NAME <- NAMES[[kk]]
[16:13:59.716]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.716]                     next
[16:13:59.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:59.716]                 }
[16:13:59.716]                 if (length(args) > 0) 
[16:13:59.716]                   base::do.call(base::Sys.setenv, args = args)
[16:13:59.716]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:59.716]             }
[16:13:59.716]             else {
[16:13:59.716]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:59.716]             }
[16:13:59.716]             {
[16:13:59.716]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:59.716]                   0L) {
[16:13:59.716]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:59.716]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:59.716]                   base::options(opts)
[16:13:59.716]                 }
[16:13:59.716]                 {
[16:13:59.716]                   {
[16:13:59.716]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:59.716]                     NULL
[16:13:59.716]                   }
[16:13:59.716]                   options(future.plan = NULL)
[16:13:59.716]                   if (is.na(NA_character_)) 
[16:13:59.716]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:59.716]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:59.716]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:59.716]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:59.716]                     envir = parent.frame()) 
[16:13:59.716]                   {
[16:13:59.716]                     if (is.function(workers)) 
[16:13:59.716]                       workers <- workers()
[16:13:59.716]                     workers <- structure(as.integer(workers), 
[16:13:59.716]                       class = class(workers))
[16:13:59.716]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:59.716]                       workers >= 1)
[16:13:59.716]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:59.716]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:59.716]                     }
[16:13:59.716]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:59.716]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:59.716]                       envir = envir)
[16:13:59.716]                     if (!future$lazy) 
[16:13:59.716]                       future <- run(future)
[16:13:59.716]                     invisible(future)
[16:13:59.716]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:59.716]                 }
[16:13:59.716]             }
[16:13:59.716]         }
[16:13:59.716]     })
[16:13:59.716]     if (TRUE) {
[16:13:59.716]         base::sink(type = "output", split = FALSE)
[16:13:59.716]         if (TRUE) {
[16:13:59.716]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:59.716]         }
[16:13:59.716]         else {
[16:13:59.716]             ...future.result["stdout"] <- base::list(NULL)
[16:13:59.716]         }
[16:13:59.716]         base::close(...future.stdout)
[16:13:59.716]         ...future.stdout <- NULL
[16:13:59.716]     }
[16:13:59.716]     ...future.result$conditions <- ...future.conditions
[16:13:59.716]     ...future.result$finished <- base::Sys.time()
[16:13:59.716]     ...future.result
[16:13:59.716] }
[16:13:59.719] MultisessionFuture started
[16:13:59.719] - Launch lazy future ... done
[16:13:59.719] run() for ‘MultisessionFuture’ ... done
[16:13:59.730] run() for ‘Future’ ...
[16:13:59.730] - state: ‘created’
[16:13:59.730] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:59.744] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:59.744] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:59.744]   - Field: ‘node’
[16:13:59.745]   - Field: ‘label’
[16:13:59.745]   - Field: ‘local’
[16:13:59.745]   - Field: ‘owner’
[16:13:59.745]   - Field: ‘envir’
[16:13:59.745]   - Field: ‘workers’
[16:13:59.745]   - Field: ‘packages’
[16:13:59.745]   - Field: ‘gc’
[16:13:59.745]   - Field: ‘conditions’
[16:13:59.745]   - Field: ‘persistent’
[16:13:59.745]   - Field: ‘expr’
[16:13:59.745]   - Field: ‘uuid’
[16:13:59.746]   - Field: ‘seed’
[16:13:59.746]   - Field: ‘version’
[16:13:59.746]   - Field: ‘result’
[16:13:59.746]   - Field: ‘asynchronous’
[16:13:59.746]   - Field: ‘calls’
[16:13:59.746]   - Field: ‘globals’
[16:13:59.746]   - Field: ‘stdout’
[16:13:59.746]   - Field: ‘earlySignal’
[16:13:59.746]   - Field: ‘lazy’
[16:13:59.746]   - Field: ‘state’
[16:13:59.746] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:59.747] - Launch lazy future ...
[16:13:59.747] Packages needed by the future expression (n = 0): <none>
[16:13:59.747] Packages needed by future strategies (n = 0): <none>
[16:13:59.747] {
[16:13:59.747]     {
[16:13:59.747]         {
[16:13:59.747]             ...future.startTime <- base::Sys.time()
[16:13:59.747]             {
[16:13:59.747]                 {
[16:13:59.747]                   {
[16:13:59.747]                     {
[16:13:59.747]                       base::local({
[16:13:59.747]                         has_future <- base::requireNamespace("future", 
[16:13:59.747]                           quietly = TRUE)
[16:13:59.747]                         if (has_future) {
[16:13:59.747]                           ns <- base::getNamespace("future")
[16:13:59.747]                           version <- ns[[".package"]][["version"]]
[16:13:59.747]                           if (is.null(version)) 
[16:13:59.747]                             version <- utils::packageVersion("future")
[16:13:59.747]                         }
[16:13:59.747]                         else {
[16:13:59.747]                           version <- NULL
[16:13:59.747]                         }
[16:13:59.747]                         if (!has_future || version < "1.8.0") {
[16:13:59.747]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:59.747]                             "", base::R.version$version.string), 
[16:13:59.747]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:59.747]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:59.747]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:59.747]                               "release", "version")], collapse = " "), 
[16:13:59.747]                             hostname = base::Sys.info()[["nodename"]])
[16:13:59.747]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:59.747]                             info)
[16:13:59.747]                           info <- base::paste(info, collapse = "; ")
[16:13:59.747]                           if (!has_future) {
[16:13:59.747]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:59.747]                               info)
[16:13:59.747]                           }
[16:13:59.747]                           else {
[16:13:59.747]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:59.747]                               info, version)
[16:13:59.747]                           }
[16:13:59.747]                           base::stop(msg)
[16:13:59.747]                         }
[16:13:59.747]                       })
[16:13:59.747]                     }
[16:13:59.747]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:59.747]                     base::options(mc.cores = 1L)
[16:13:59.747]                   }
[16:13:59.747]                   options(future.plan = NULL)
[16:13:59.747]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:59.747]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:59.747]                 }
[16:13:59.747]                 ...future.workdir <- getwd()
[16:13:59.747]             }
[16:13:59.747]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:59.747]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:59.747]         }
[16:13:59.747]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:59.747]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:59.747]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:59.747]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:59.747]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:59.747]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:59.747]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:59.747]             base::names(...future.oldOptions))
[16:13:59.747]     }
[16:13:59.747]     if (FALSE) {
[16:13:59.747]     }
[16:13:59.747]     else {
[16:13:59.747]         if (TRUE) {
[16:13:59.747]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:59.747]                 open = "w")
[16:13:59.747]         }
[16:13:59.747]         else {
[16:13:59.747]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:59.747]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:59.747]         }
[16:13:59.747]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:59.747]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:59.747]             base::sink(type = "output", split = FALSE)
[16:13:59.747]             base::close(...future.stdout)
[16:13:59.747]         }, add = TRUE)
[16:13:59.747]     }
[16:13:59.747]     ...future.frame <- base::sys.nframe()
[16:13:59.747]     ...future.conditions <- base::list()
[16:13:59.747]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:59.747]     if (FALSE) {
[16:13:59.747]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:59.747]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:59.747]     }
[16:13:59.747]     ...future.result <- base::tryCatch({
[16:13:59.747]         base::withCallingHandlers({
[16:13:59.747]             ...future.value <- base::withVisible(base::local({
[16:13:59.747]                 ...future.makeSendCondition <- local({
[16:13:59.747]                   sendCondition <- NULL
[16:13:59.747]                   function(frame = 1L) {
[16:13:59.747]                     if (is.function(sendCondition)) 
[16:13:59.747]                       return(sendCondition)
[16:13:59.747]                     ns <- getNamespace("parallel")
[16:13:59.747]                     if (exists("sendData", mode = "function", 
[16:13:59.747]                       envir = ns)) {
[16:13:59.747]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:59.747]                         envir = ns)
[16:13:59.747]                       envir <- sys.frame(frame)
[16:13:59.747]                       master <- NULL
[16:13:59.747]                       while (!identical(envir, .GlobalEnv) && 
[16:13:59.747]                         !identical(envir, emptyenv())) {
[16:13:59.747]                         if (exists("master", mode = "list", envir = envir, 
[16:13:59.747]                           inherits = FALSE)) {
[16:13:59.747]                           master <- get("master", mode = "list", 
[16:13:59.747]                             envir = envir, inherits = FALSE)
[16:13:59.747]                           if (inherits(master, c("SOCKnode", 
[16:13:59.747]                             "SOCK0node"))) {
[16:13:59.747]                             sendCondition <<- function(cond) {
[16:13:59.747]                               data <- list(type = "VALUE", value = cond, 
[16:13:59.747]                                 success = TRUE)
[16:13:59.747]                               parallel_sendData(master, data)
[16:13:59.747]                             }
[16:13:59.747]                             return(sendCondition)
[16:13:59.747]                           }
[16:13:59.747]                         }
[16:13:59.747]                         frame <- frame + 1L
[16:13:59.747]                         envir <- sys.frame(frame)
[16:13:59.747]                       }
[16:13:59.747]                     }
[16:13:59.747]                     sendCondition <<- function(cond) NULL
[16:13:59.747]                   }
[16:13:59.747]                 })
[16:13:59.747]                 withCallingHandlers({
[16:13:59.747]                   2
[16:13:59.747]                 }, immediateCondition = function(cond) {
[16:13:59.747]                   sendCondition <- ...future.makeSendCondition()
[16:13:59.747]                   sendCondition(cond)
[16:13:59.747]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.747]                   {
[16:13:59.747]                     inherits <- base::inherits
[16:13:59.747]                     invokeRestart <- base::invokeRestart
[16:13:59.747]                     is.null <- base::is.null
[16:13:59.747]                     muffled <- FALSE
[16:13:59.747]                     if (inherits(cond, "message")) {
[16:13:59.747]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:59.747]                       if (muffled) 
[16:13:59.747]                         invokeRestart("muffleMessage")
[16:13:59.747]                     }
[16:13:59.747]                     else if (inherits(cond, "warning")) {
[16:13:59.747]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:59.747]                       if (muffled) 
[16:13:59.747]                         invokeRestart("muffleWarning")
[16:13:59.747]                     }
[16:13:59.747]                     else if (inherits(cond, "condition")) {
[16:13:59.747]                       if (!is.null(pattern)) {
[16:13:59.747]                         computeRestarts <- base::computeRestarts
[16:13:59.747]                         grepl <- base::grepl
[16:13:59.747]                         restarts <- computeRestarts(cond)
[16:13:59.747]                         for (restart in restarts) {
[16:13:59.747]                           name <- restart$name
[16:13:59.747]                           if (is.null(name)) 
[16:13:59.747]                             next
[16:13:59.747]                           if (!grepl(pattern, name)) 
[16:13:59.747]                             next
[16:13:59.747]                           invokeRestart(restart)
[16:13:59.747]                           muffled <- TRUE
[16:13:59.747]                           break
[16:13:59.747]                         }
[16:13:59.747]                       }
[16:13:59.747]                     }
[16:13:59.747]                     invisible(muffled)
[16:13:59.747]                   }
[16:13:59.747]                   muffleCondition(cond)
[16:13:59.747]                 })
[16:13:59.747]             }))
[16:13:59.747]             future::FutureResult(value = ...future.value$value, 
[16:13:59.747]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:59.747]                   ...future.rng), globalenv = if (FALSE) 
[16:13:59.747]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:59.747]                     ...future.globalenv.names))
[16:13:59.747]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:59.747]         }, condition = base::local({
[16:13:59.747]             c <- base::c
[16:13:59.747]             inherits <- base::inherits
[16:13:59.747]             invokeRestart <- base::invokeRestart
[16:13:59.747]             length <- base::length
[16:13:59.747]             list <- base::list
[16:13:59.747]             seq.int <- base::seq.int
[16:13:59.747]             signalCondition <- base::signalCondition
[16:13:59.747]             sys.calls <- base::sys.calls
[16:13:59.747]             `[[` <- base::`[[`
[16:13:59.747]             `+` <- base::`+`
[16:13:59.747]             `<<-` <- base::`<<-`
[16:13:59.747]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:59.747]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:59.747]                   3L)]
[16:13:59.747]             }
[16:13:59.747]             function(cond) {
[16:13:59.747]                 is_error <- inherits(cond, "error")
[16:13:59.747]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:59.747]                   NULL)
[16:13:59.747]                 if (is_error) {
[16:13:59.747]                   sessionInformation <- function() {
[16:13:59.747]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:59.747]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:59.747]                       search = base::search(), system = base::Sys.info())
[16:13:59.747]                   }
[16:13:59.747]                   ...future.conditions[[length(...future.conditions) + 
[16:13:59.747]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:59.747]                     cond$call), session = sessionInformation(), 
[16:13:59.747]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:59.747]                   signalCondition(cond)
[16:13:59.747]                 }
[16:13:59.747]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:59.747]                 "immediateCondition"))) {
[16:13:59.747]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:59.747]                   ...future.conditions[[length(...future.conditions) + 
[16:13:59.747]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:59.747]                   if (TRUE && !signal) {
[16:13:59.747]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.747]                     {
[16:13:59.747]                       inherits <- base::inherits
[16:13:59.747]                       invokeRestart <- base::invokeRestart
[16:13:59.747]                       is.null <- base::is.null
[16:13:59.747]                       muffled <- FALSE
[16:13:59.747]                       if (inherits(cond, "message")) {
[16:13:59.747]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:59.747]                         if (muffled) 
[16:13:59.747]                           invokeRestart("muffleMessage")
[16:13:59.747]                       }
[16:13:59.747]                       else if (inherits(cond, "warning")) {
[16:13:59.747]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:59.747]                         if (muffled) 
[16:13:59.747]                           invokeRestart("muffleWarning")
[16:13:59.747]                       }
[16:13:59.747]                       else if (inherits(cond, "condition")) {
[16:13:59.747]                         if (!is.null(pattern)) {
[16:13:59.747]                           computeRestarts <- base::computeRestarts
[16:13:59.747]                           grepl <- base::grepl
[16:13:59.747]                           restarts <- computeRestarts(cond)
[16:13:59.747]                           for (restart in restarts) {
[16:13:59.747]                             name <- restart$name
[16:13:59.747]                             if (is.null(name)) 
[16:13:59.747]                               next
[16:13:59.747]                             if (!grepl(pattern, name)) 
[16:13:59.747]                               next
[16:13:59.747]                             invokeRestart(restart)
[16:13:59.747]                             muffled <- TRUE
[16:13:59.747]                             break
[16:13:59.747]                           }
[16:13:59.747]                         }
[16:13:59.747]                       }
[16:13:59.747]                       invisible(muffled)
[16:13:59.747]                     }
[16:13:59.747]                     muffleCondition(cond, pattern = "^muffle")
[16:13:59.747]                   }
[16:13:59.747]                 }
[16:13:59.747]                 else {
[16:13:59.747]                   if (TRUE) {
[16:13:59.747]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.747]                     {
[16:13:59.747]                       inherits <- base::inherits
[16:13:59.747]                       invokeRestart <- base::invokeRestart
[16:13:59.747]                       is.null <- base::is.null
[16:13:59.747]                       muffled <- FALSE
[16:13:59.747]                       if (inherits(cond, "message")) {
[16:13:59.747]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:59.747]                         if (muffled) 
[16:13:59.747]                           invokeRestart("muffleMessage")
[16:13:59.747]                       }
[16:13:59.747]                       else if (inherits(cond, "warning")) {
[16:13:59.747]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:59.747]                         if (muffled) 
[16:13:59.747]                           invokeRestart("muffleWarning")
[16:13:59.747]                       }
[16:13:59.747]                       else if (inherits(cond, "condition")) {
[16:13:59.747]                         if (!is.null(pattern)) {
[16:13:59.747]                           computeRestarts <- base::computeRestarts
[16:13:59.747]                           grepl <- base::grepl
[16:13:59.747]                           restarts <- computeRestarts(cond)
[16:13:59.747]                           for (restart in restarts) {
[16:13:59.747]                             name <- restart$name
[16:13:59.747]                             if (is.null(name)) 
[16:13:59.747]                               next
[16:13:59.747]                             if (!grepl(pattern, name)) 
[16:13:59.747]                               next
[16:13:59.747]                             invokeRestart(restart)
[16:13:59.747]                             muffled <- TRUE
[16:13:59.747]                             break
[16:13:59.747]                           }
[16:13:59.747]                         }
[16:13:59.747]                       }
[16:13:59.747]                       invisible(muffled)
[16:13:59.747]                     }
[16:13:59.747]                     muffleCondition(cond, pattern = "^muffle")
[16:13:59.747]                   }
[16:13:59.747]                 }
[16:13:59.747]             }
[16:13:59.747]         }))
[16:13:59.747]     }, error = function(ex) {
[16:13:59.747]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:59.747]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:59.747]                 ...future.rng), started = ...future.startTime, 
[16:13:59.747]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:59.747]             version = "1.8"), class = "FutureResult")
[16:13:59.747]     }, finally = {
[16:13:59.747]         if (!identical(...future.workdir, getwd())) 
[16:13:59.747]             setwd(...future.workdir)
[16:13:59.747]         {
[16:13:59.747]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:59.747]                 ...future.oldOptions$nwarnings <- NULL
[16:13:59.747]             }
[16:13:59.747]             base::options(...future.oldOptions)
[16:13:59.747]             if (.Platform$OS.type == "windows") {
[16:13:59.747]                 old_names <- names(...future.oldEnvVars)
[16:13:59.747]                 envs <- base::Sys.getenv()
[16:13:59.747]                 names <- names(envs)
[16:13:59.747]                 common <- intersect(names, old_names)
[16:13:59.747]                 added <- setdiff(names, old_names)
[16:13:59.747]                 removed <- setdiff(old_names, names)
[16:13:59.747]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:59.747]                   envs[common]]
[16:13:59.747]                 NAMES <- toupper(changed)
[16:13:59.747]                 args <- list()
[16:13:59.747]                 for (kk in seq_along(NAMES)) {
[16:13:59.747]                   name <- changed[[kk]]
[16:13:59.747]                   NAME <- NAMES[[kk]]
[16:13:59.747]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.747]                     next
[16:13:59.747]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:59.747]                 }
[16:13:59.747]                 NAMES <- toupper(added)
[16:13:59.747]                 for (kk in seq_along(NAMES)) {
[16:13:59.747]                   name <- added[[kk]]
[16:13:59.747]                   NAME <- NAMES[[kk]]
[16:13:59.747]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.747]                     next
[16:13:59.747]                   args[[name]] <- ""
[16:13:59.747]                 }
[16:13:59.747]                 NAMES <- toupper(removed)
[16:13:59.747]                 for (kk in seq_along(NAMES)) {
[16:13:59.747]                   name <- removed[[kk]]
[16:13:59.747]                   NAME <- NAMES[[kk]]
[16:13:59.747]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.747]                     next
[16:13:59.747]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:59.747]                 }
[16:13:59.747]                 if (length(args) > 0) 
[16:13:59.747]                   base::do.call(base::Sys.setenv, args = args)
[16:13:59.747]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:59.747]             }
[16:13:59.747]             else {
[16:13:59.747]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:59.747]             }
[16:13:59.747]             {
[16:13:59.747]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:59.747]                   0L) {
[16:13:59.747]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:59.747]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:59.747]                   base::options(opts)
[16:13:59.747]                 }
[16:13:59.747]                 {
[16:13:59.747]                   {
[16:13:59.747]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:59.747]                     NULL
[16:13:59.747]                   }
[16:13:59.747]                   options(future.plan = NULL)
[16:13:59.747]                   if (is.na(NA_character_)) 
[16:13:59.747]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:59.747]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:59.747]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:59.747]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:59.747]                     envir = parent.frame()) 
[16:13:59.747]                   {
[16:13:59.747]                     if (is.function(workers)) 
[16:13:59.747]                       workers <- workers()
[16:13:59.747]                     workers <- structure(as.integer(workers), 
[16:13:59.747]                       class = class(workers))
[16:13:59.747]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:59.747]                       workers >= 1)
[16:13:59.747]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:59.747]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:59.747]                     }
[16:13:59.747]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:59.747]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:59.747]                       envir = envir)
[16:13:59.747]                     if (!future$lazy) 
[16:13:59.747]                       future <- run(future)
[16:13:59.747]                     invisible(future)
[16:13:59.747]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:59.747]                 }
[16:13:59.747]             }
[16:13:59.747]         }
[16:13:59.747]     })
[16:13:59.747]     if (TRUE) {
[16:13:59.747]         base::sink(type = "output", split = FALSE)
[16:13:59.747]         if (TRUE) {
[16:13:59.747]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:59.747]         }
[16:13:59.747]         else {
[16:13:59.747]             ...future.result["stdout"] <- base::list(NULL)
[16:13:59.747]         }
[16:13:59.747]         base::close(...future.stdout)
[16:13:59.747]         ...future.stdout <- NULL
[16:13:59.747]     }
[16:13:59.747]     ...future.result$conditions <- ...future.conditions
[16:13:59.747]     ...future.result$finished <- base::Sys.time()
[16:13:59.747]     ...future.result
[16:13:59.747] }
[16:13:59.750] MultisessionFuture started
[16:13:59.750] - Launch lazy future ... done
[16:13:59.751] run() for ‘MultisessionFuture’ ... done
[16:13:59.761]  length: 2 (resolved future 3)
[16:13:59.772] receiveMessageFromWorker() for ClusterFuture ...
[16:13:59.772] - Validating connection of MultisessionFuture
[16:13:59.772] - received message: FutureResult
[16:13:59.772] - Received FutureResult
[16:13:59.772] - Erased future from FutureRegistry
[16:13:59.772] result() for ClusterFuture ...
[16:13:59.773] - result already collected: FutureResult
[16:13:59.773] result() for ClusterFuture ... done
[16:13:59.773] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:59.773] Future #1
[16:13:59.773]  length: 1 (resolved future 1)
[16:13:59.796] receiveMessageFromWorker() for ClusterFuture ...
[16:13:59.796] - Validating connection of MultisessionFuture
[16:13:59.796] - received message: FutureResult
[16:13:59.797] - Received FutureResult
[16:13:59.797] - Erased future from FutureRegistry
[16:13:59.797] result() for ClusterFuture ...
[16:13:59.797] - result already collected: FutureResult
[16:13:59.797] result() for ClusterFuture ... done
[16:13:59.797] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:59.797] Future #2
[16:13:59.797]  length: 0 (resolved future 2)
[16:13:59.797] resolve() on list ... DONE
[16:13:59.797] getGlobalsAndPackages() ...
[16:13:59.798] Searching for globals...
[16:13:59.798] 
[16:13:59.798] Searching for globals ... DONE
[16:13:59.798] - globals: [0] <none>
[16:13:59.798] getGlobalsAndPackages() ... DONE
[16:13:59.798] run() for ‘Future’ ...
[16:13:59.798] - state: ‘created’
[16:13:59.799] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:59.813] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:59.813] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:59.813]   - Field: ‘node’
[16:13:59.814]   - Field: ‘label’
[16:13:59.814]   - Field: ‘local’
[16:13:59.814]   - Field: ‘owner’
[16:13:59.814]   - Field: ‘envir’
[16:13:59.814]   - Field: ‘workers’
[16:13:59.814]   - Field: ‘packages’
[16:13:59.814]   - Field: ‘gc’
[16:13:59.814]   - Field: ‘conditions’
[16:13:59.814]   - Field: ‘persistent’
[16:13:59.814]   - Field: ‘expr’
[16:13:59.815]   - Field: ‘uuid’
[16:13:59.815]   - Field: ‘seed’
[16:13:59.815]   - Field: ‘version’
[16:13:59.815]   - Field: ‘result’
[16:13:59.815]   - Field: ‘asynchronous’
[16:13:59.815]   - Field: ‘calls’
[16:13:59.815]   - Field: ‘globals’
[16:13:59.815]   - Field: ‘stdout’
[16:13:59.815]   - Field: ‘earlySignal’
[16:13:59.815]   - Field: ‘lazy’
[16:13:59.815]   - Field: ‘state’
[16:13:59.816] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:59.816] - Launch lazy future ...
[16:13:59.816] Packages needed by the future expression (n = 0): <none>
[16:13:59.816] Packages needed by future strategies (n = 0): <none>
[16:13:59.817] {
[16:13:59.817]     {
[16:13:59.817]         {
[16:13:59.817]             ...future.startTime <- base::Sys.time()
[16:13:59.817]             {
[16:13:59.817]                 {
[16:13:59.817]                   {
[16:13:59.817]                     {
[16:13:59.817]                       base::local({
[16:13:59.817]                         has_future <- base::requireNamespace("future", 
[16:13:59.817]                           quietly = TRUE)
[16:13:59.817]                         if (has_future) {
[16:13:59.817]                           ns <- base::getNamespace("future")
[16:13:59.817]                           version <- ns[[".package"]][["version"]]
[16:13:59.817]                           if (is.null(version)) 
[16:13:59.817]                             version <- utils::packageVersion("future")
[16:13:59.817]                         }
[16:13:59.817]                         else {
[16:13:59.817]                           version <- NULL
[16:13:59.817]                         }
[16:13:59.817]                         if (!has_future || version < "1.8.0") {
[16:13:59.817]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:59.817]                             "", base::R.version$version.string), 
[16:13:59.817]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:59.817]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:59.817]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:59.817]                               "release", "version")], collapse = " "), 
[16:13:59.817]                             hostname = base::Sys.info()[["nodename"]])
[16:13:59.817]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:59.817]                             info)
[16:13:59.817]                           info <- base::paste(info, collapse = "; ")
[16:13:59.817]                           if (!has_future) {
[16:13:59.817]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:59.817]                               info)
[16:13:59.817]                           }
[16:13:59.817]                           else {
[16:13:59.817]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:59.817]                               info, version)
[16:13:59.817]                           }
[16:13:59.817]                           base::stop(msg)
[16:13:59.817]                         }
[16:13:59.817]                       })
[16:13:59.817]                     }
[16:13:59.817]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:59.817]                     base::options(mc.cores = 1L)
[16:13:59.817]                   }
[16:13:59.817]                   options(future.plan = NULL)
[16:13:59.817]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:59.817]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:59.817]                 }
[16:13:59.817]                 ...future.workdir <- getwd()
[16:13:59.817]             }
[16:13:59.817]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:59.817]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:59.817]         }
[16:13:59.817]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:59.817]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:59.817]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:59.817]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:59.817]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:59.817]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:59.817]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:59.817]             base::names(...future.oldOptions))
[16:13:59.817]     }
[16:13:59.817]     if (FALSE) {
[16:13:59.817]     }
[16:13:59.817]     else {
[16:13:59.817]         if (TRUE) {
[16:13:59.817]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:59.817]                 open = "w")
[16:13:59.817]         }
[16:13:59.817]         else {
[16:13:59.817]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:59.817]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:59.817]         }
[16:13:59.817]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:59.817]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:59.817]             base::sink(type = "output", split = FALSE)
[16:13:59.817]             base::close(...future.stdout)
[16:13:59.817]         }, add = TRUE)
[16:13:59.817]     }
[16:13:59.817]     ...future.frame <- base::sys.nframe()
[16:13:59.817]     ...future.conditions <- base::list()
[16:13:59.817]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:59.817]     if (FALSE) {
[16:13:59.817]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:59.817]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:59.817]     }
[16:13:59.817]     ...future.result <- base::tryCatch({
[16:13:59.817]         base::withCallingHandlers({
[16:13:59.817]             ...future.value <- base::withVisible(base::local({
[16:13:59.817]                 ...future.makeSendCondition <- local({
[16:13:59.817]                   sendCondition <- NULL
[16:13:59.817]                   function(frame = 1L) {
[16:13:59.817]                     if (is.function(sendCondition)) 
[16:13:59.817]                       return(sendCondition)
[16:13:59.817]                     ns <- getNamespace("parallel")
[16:13:59.817]                     if (exists("sendData", mode = "function", 
[16:13:59.817]                       envir = ns)) {
[16:13:59.817]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:59.817]                         envir = ns)
[16:13:59.817]                       envir <- sys.frame(frame)
[16:13:59.817]                       master <- NULL
[16:13:59.817]                       while (!identical(envir, .GlobalEnv) && 
[16:13:59.817]                         !identical(envir, emptyenv())) {
[16:13:59.817]                         if (exists("master", mode = "list", envir = envir, 
[16:13:59.817]                           inherits = FALSE)) {
[16:13:59.817]                           master <- get("master", mode = "list", 
[16:13:59.817]                             envir = envir, inherits = FALSE)
[16:13:59.817]                           if (inherits(master, c("SOCKnode", 
[16:13:59.817]                             "SOCK0node"))) {
[16:13:59.817]                             sendCondition <<- function(cond) {
[16:13:59.817]                               data <- list(type = "VALUE", value = cond, 
[16:13:59.817]                                 success = TRUE)
[16:13:59.817]                               parallel_sendData(master, data)
[16:13:59.817]                             }
[16:13:59.817]                             return(sendCondition)
[16:13:59.817]                           }
[16:13:59.817]                         }
[16:13:59.817]                         frame <- frame + 1L
[16:13:59.817]                         envir <- sys.frame(frame)
[16:13:59.817]                       }
[16:13:59.817]                     }
[16:13:59.817]                     sendCondition <<- function(cond) NULL
[16:13:59.817]                   }
[16:13:59.817]                 })
[16:13:59.817]                 withCallingHandlers({
[16:13:59.817]                   1
[16:13:59.817]                 }, immediateCondition = function(cond) {
[16:13:59.817]                   sendCondition <- ...future.makeSendCondition()
[16:13:59.817]                   sendCondition(cond)
[16:13:59.817]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.817]                   {
[16:13:59.817]                     inherits <- base::inherits
[16:13:59.817]                     invokeRestart <- base::invokeRestart
[16:13:59.817]                     is.null <- base::is.null
[16:13:59.817]                     muffled <- FALSE
[16:13:59.817]                     if (inherits(cond, "message")) {
[16:13:59.817]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:59.817]                       if (muffled) 
[16:13:59.817]                         invokeRestart("muffleMessage")
[16:13:59.817]                     }
[16:13:59.817]                     else if (inherits(cond, "warning")) {
[16:13:59.817]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:59.817]                       if (muffled) 
[16:13:59.817]                         invokeRestart("muffleWarning")
[16:13:59.817]                     }
[16:13:59.817]                     else if (inherits(cond, "condition")) {
[16:13:59.817]                       if (!is.null(pattern)) {
[16:13:59.817]                         computeRestarts <- base::computeRestarts
[16:13:59.817]                         grepl <- base::grepl
[16:13:59.817]                         restarts <- computeRestarts(cond)
[16:13:59.817]                         for (restart in restarts) {
[16:13:59.817]                           name <- restart$name
[16:13:59.817]                           if (is.null(name)) 
[16:13:59.817]                             next
[16:13:59.817]                           if (!grepl(pattern, name)) 
[16:13:59.817]                             next
[16:13:59.817]                           invokeRestart(restart)
[16:13:59.817]                           muffled <- TRUE
[16:13:59.817]                           break
[16:13:59.817]                         }
[16:13:59.817]                       }
[16:13:59.817]                     }
[16:13:59.817]                     invisible(muffled)
[16:13:59.817]                   }
[16:13:59.817]                   muffleCondition(cond)
[16:13:59.817]                 })
[16:13:59.817]             }))
[16:13:59.817]             future::FutureResult(value = ...future.value$value, 
[16:13:59.817]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:59.817]                   ...future.rng), globalenv = if (FALSE) 
[16:13:59.817]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:59.817]                     ...future.globalenv.names))
[16:13:59.817]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:59.817]         }, condition = base::local({
[16:13:59.817]             c <- base::c
[16:13:59.817]             inherits <- base::inherits
[16:13:59.817]             invokeRestart <- base::invokeRestart
[16:13:59.817]             length <- base::length
[16:13:59.817]             list <- base::list
[16:13:59.817]             seq.int <- base::seq.int
[16:13:59.817]             signalCondition <- base::signalCondition
[16:13:59.817]             sys.calls <- base::sys.calls
[16:13:59.817]             `[[` <- base::`[[`
[16:13:59.817]             `+` <- base::`+`
[16:13:59.817]             `<<-` <- base::`<<-`
[16:13:59.817]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:59.817]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:59.817]                   3L)]
[16:13:59.817]             }
[16:13:59.817]             function(cond) {
[16:13:59.817]                 is_error <- inherits(cond, "error")
[16:13:59.817]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:59.817]                   NULL)
[16:13:59.817]                 if (is_error) {
[16:13:59.817]                   sessionInformation <- function() {
[16:13:59.817]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:59.817]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:59.817]                       search = base::search(), system = base::Sys.info())
[16:13:59.817]                   }
[16:13:59.817]                   ...future.conditions[[length(...future.conditions) + 
[16:13:59.817]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:59.817]                     cond$call), session = sessionInformation(), 
[16:13:59.817]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:59.817]                   signalCondition(cond)
[16:13:59.817]                 }
[16:13:59.817]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:59.817]                 "immediateCondition"))) {
[16:13:59.817]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:59.817]                   ...future.conditions[[length(...future.conditions) + 
[16:13:59.817]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:59.817]                   if (TRUE && !signal) {
[16:13:59.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.817]                     {
[16:13:59.817]                       inherits <- base::inherits
[16:13:59.817]                       invokeRestart <- base::invokeRestart
[16:13:59.817]                       is.null <- base::is.null
[16:13:59.817]                       muffled <- FALSE
[16:13:59.817]                       if (inherits(cond, "message")) {
[16:13:59.817]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:59.817]                         if (muffled) 
[16:13:59.817]                           invokeRestart("muffleMessage")
[16:13:59.817]                       }
[16:13:59.817]                       else if (inherits(cond, "warning")) {
[16:13:59.817]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:59.817]                         if (muffled) 
[16:13:59.817]                           invokeRestart("muffleWarning")
[16:13:59.817]                       }
[16:13:59.817]                       else if (inherits(cond, "condition")) {
[16:13:59.817]                         if (!is.null(pattern)) {
[16:13:59.817]                           computeRestarts <- base::computeRestarts
[16:13:59.817]                           grepl <- base::grepl
[16:13:59.817]                           restarts <- computeRestarts(cond)
[16:13:59.817]                           for (restart in restarts) {
[16:13:59.817]                             name <- restart$name
[16:13:59.817]                             if (is.null(name)) 
[16:13:59.817]                               next
[16:13:59.817]                             if (!grepl(pattern, name)) 
[16:13:59.817]                               next
[16:13:59.817]                             invokeRestart(restart)
[16:13:59.817]                             muffled <- TRUE
[16:13:59.817]                             break
[16:13:59.817]                           }
[16:13:59.817]                         }
[16:13:59.817]                       }
[16:13:59.817]                       invisible(muffled)
[16:13:59.817]                     }
[16:13:59.817]                     muffleCondition(cond, pattern = "^muffle")
[16:13:59.817]                   }
[16:13:59.817]                 }
[16:13:59.817]                 else {
[16:13:59.817]                   if (TRUE) {
[16:13:59.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.817]                     {
[16:13:59.817]                       inherits <- base::inherits
[16:13:59.817]                       invokeRestart <- base::invokeRestart
[16:13:59.817]                       is.null <- base::is.null
[16:13:59.817]                       muffled <- FALSE
[16:13:59.817]                       if (inherits(cond, "message")) {
[16:13:59.817]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:59.817]                         if (muffled) 
[16:13:59.817]                           invokeRestart("muffleMessage")
[16:13:59.817]                       }
[16:13:59.817]                       else if (inherits(cond, "warning")) {
[16:13:59.817]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:59.817]                         if (muffled) 
[16:13:59.817]                           invokeRestart("muffleWarning")
[16:13:59.817]                       }
[16:13:59.817]                       else if (inherits(cond, "condition")) {
[16:13:59.817]                         if (!is.null(pattern)) {
[16:13:59.817]                           computeRestarts <- base::computeRestarts
[16:13:59.817]                           grepl <- base::grepl
[16:13:59.817]                           restarts <- computeRestarts(cond)
[16:13:59.817]                           for (restart in restarts) {
[16:13:59.817]                             name <- restart$name
[16:13:59.817]                             if (is.null(name)) 
[16:13:59.817]                               next
[16:13:59.817]                             if (!grepl(pattern, name)) 
[16:13:59.817]                               next
[16:13:59.817]                             invokeRestart(restart)
[16:13:59.817]                             muffled <- TRUE
[16:13:59.817]                             break
[16:13:59.817]                           }
[16:13:59.817]                         }
[16:13:59.817]                       }
[16:13:59.817]                       invisible(muffled)
[16:13:59.817]                     }
[16:13:59.817]                     muffleCondition(cond, pattern = "^muffle")
[16:13:59.817]                   }
[16:13:59.817]                 }
[16:13:59.817]             }
[16:13:59.817]         }))
[16:13:59.817]     }, error = function(ex) {
[16:13:59.817]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:59.817]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:59.817]                 ...future.rng), started = ...future.startTime, 
[16:13:59.817]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:59.817]             version = "1.8"), class = "FutureResult")
[16:13:59.817]     }, finally = {
[16:13:59.817]         if (!identical(...future.workdir, getwd())) 
[16:13:59.817]             setwd(...future.workdir)
[16:13:59.817]         {
[16:13:59.817]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:59.817]                 ...future.oldOptions$nwarnings <- NULL
[16:13:59.817]             }
[16:13:59.817]             base::options(...future.oldOptions)
[16:13:59.817]             if (.Platform$OS.type == "windows") {
[16:13:59.817]                 old_names <- names(...future.oldEnvVars)
[16:13:59.817]                 envs <- base::Sys.getenv()
[16:13:59.817]                 names <- names(envs)
[16:13:59.817]                 common <- intersect(names, old_names)
[16:13:59.817]                 added <- setdiff(names, old_names)
[16:13:59.817]                 removed <- setdiff(old_names, names)
[16:13:59.817]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:59.817]                   envs[common]]
[16:13:59.817]                 NAMES <- toupper(changed)
[16:13:59.817]                 args <- list()
[16:13:59.817]                 for (kk in seq_along(NAMES)) {
[16:13:59.817]                   name <- changed[[kk]]
[16:13:59.817]                   NAME <- NAMES[[kk]]
[16:13:59.817]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.817]                     next
[16:13:59.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:59.817]                 }
[16:13:59.817]                 NAMES <- toupper(added)
[16:13:59.817]                 for (kk in seq_along(NAMES)) {
[16:13:59.817]                   name <- added[[kk]]
[16:13:59.817]                   NAME <- NAMES[[kk]]
[16:13:59.817]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.817]                     next
[16:13:59.817]                   args[[name]] <- ""
[16:13:59.817]                 }
[16:13:59.817]                 NAMES <- toupper(removed)
[16:13:59.817]                 for (kk in seq_along(NAMES)) {
[16:13:59.817]                   name <- removed[[kk]]
[16:13:59.817]                   NAME <- NAMES[[kk]]
[16:13:59.817]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.817]                     next
[16:13:59.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:59.817]                 }
[16:13:59.817]                 if (length(args) > 0) 
[16:13:59.817]                   base::do.call(base::Sys.setenv, args = args)
[16:13:59.817]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:59.817]             }
[16:13:59.817]             else {
[16:13:59.817]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:59.817]             }
[16:13:59.817]             {
[16:13:59.817]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:59.817]                   0L) {
[16:13:59.817]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:59.817]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:59.817]                   base::options(opts)
[16:13:59.817]                 }
[16:13:59.817]                 {
[16:13:59.817]                   {
[16:13:59.817]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:59.817]                     NULL
[16:13:59.817]                   }
[16:13:59.817]                   options(future.plan = NULL)
[16:13:59.817]                   if (is.na(NA_character_)) 
[16:13:59.817]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:59.817]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:59.817]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:59.817]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:59.817]                     envir = parent.frame()) 
[16:13:59.817]                   {
[16:13:59.817]                     if (is.function(workers)) 
[16:13:59.817]                       workers <- workers()
[16:13:59.817]                     workers <- structure(as.integer(workers), 
[16:13:59.817]                       class = class(workers))
[16:13:59.817]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:59.817]                       workers >= 1)
[16:13:59.817]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:59.817]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:59.817]                     }
[16:13:59.817]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:59.817]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:59.817]                       envir = envir)
[16:13:59.817]                     if (!future$lazy) 
[16:13:59.817]                       future <- run(future)
[16:13:59.817]                     invisible(future)
[16:13:59.817]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:59.817]                 }
[16:13:59.817]             }
[16:13:59.817]         }
[16:13:59.817]     })
[16:13:59.817]     if (TRUE) {
[16:13:59.817]         base::sink(type = "output", split = FALSE)
[16:13:59.817]         if (TRUE) {
[16:13:59.817]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:59.817]         }
[16:13:59.817]         else {
[16:13:59.817]             ...future.result["stdout"] <- base::list(NULL)
[16:13:59.817]         }
[16:13:59.817]         base::close(...future.stdout)
[16:13:59.817]         ...future.stdout <- NULL
[16:13:59.817]     }
[16:13:59.817]     ...future.result$conditions <- ...future.conditions
[16:13:59.817]     ...future.result$finished <- base::Sys.time()
[16:13:59.817]     ...future.result
[16:13:59.817] }
[16:13:59.819] MultisessionFuture started
[16:13:59.820] - Launch lazy future ... done
[16:13:59.820] run() for ‘MultisessionFuture’ ... done
[16:13:59.820] getGlobalsAndPackages() ...
[16:13:59.820] Searching for globals...
[16:13:59.821] - globals found: [2] ‘{’, ‘Sys.sleep’
[16:13:59.821] Searching for globals ... DONE
[16:13:59.821] Resolving globals: FALSE
[16:13:59.821] 
[16:13:59.821] 
[16:13:59.822] getGlobalsAndPackages() ... DONE
[16:13:59.822] run() for ‘Future’ ...
[16:13:59.822] - state: ‘created’
[16:13:59.822] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:59.836] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:59.836] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:59.837]   - Field: ‘node’
[16:13:59.837]   - Field: ‘label’
[16:13:59.837]   - Field: ‘local’
[16:13:59.837]   - Field: ‘owner’
[16:13:59.837]   - Field: ‘envir’
[16:13:59.837]   - Field: ‘workers’
[16:13:59.837]   - Field: ‘packages’
[16:13:59.837]   - Field: ‘gc’
[16:13:59.837]   - Field: ‘conditions’
[16:13:59.837]   - Field: ‘persistent’
[16:13:59.837]   - Field: ‘expr’
[16:13:59.838]   - Field: ‘uuid’
[16:13:59.838]   - Field: ‘seed’
[16:13:59.838]   - Field: ‘version’
[16:13:59.838]   - Field: ‘result’
[16:13:59.838]   - Field: ‘asynchronous’
[16:13:59.838]   - Field: ‘calls’
[16:13:59.838]   - Field: ‘globals’
[16:13:59.838]   - Field: ‘stdout’
[16:13:59.838]   - Field: ‘earlySignal’
[16:13:59.838]   - Field: ‘lazy’
[16:13:59.838]   - Field: ‘state’
[16:13:59.839] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:59.839] - Launch lazy future ...
[16:13:59.839] Packages needed by the future expression (n = 0): <none>
[16:13:59.839] Packages needed by future strategies (n = 0): <none>
[16:13:59.839] {
[16:13:59.839]     {
[16:13:59.839]         {
[16:13:59.839]             ...future.startTime <- base::Sys.time()
[16:13:59.839]             {
[16:13:59.839]                 {
[16:13:59.839]                   {
[16:13:59.839]                     {
[16:13:59.839]                       base::local({
[16:13:59.839]                         has_future <- base::requireNamespace("future", 
[16:13:59.839]                           quietly = TRUE)
[16:13:59.839]                         if (has_future) {
[16:13:59.839]                           ns <- base::getNamespace("future")
[16:13:59.839]                           version <- ns[[".package"]][["version"]]
[16:13:59.839]                           if (is.null(version)) 
[16:13:59.839]                             version <- utils::packageVersion("future")
[16:13:59.839]                         }
[16:13:59.839]                         else {
[16:13:59.839]                           version <- NULL
[16:13:59.839]                         }
[16:13:59.839]                         if (!has_future || version < "1.8.0") {
[16:13:59.839]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:59.839]                             "", base::R.version$version.string), 
[16:13:59.839]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:59.839]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:59.839]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:59.839]                               "release", "version")], collapse = " "), 
[16:13:59.839]                             hostname = base::Sys.info()[["nodename"]])
[16:13:59.839]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:59.839]                             info)
[16:13:59.839]                           info <- base::paste(info, collapse = "; ")
[16:13:59.839]                           if (!has_future) {
[16:13:59.839]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:59.839]                               info)
[16:13:59.839]                           }
[16:13:59.839]                           else {
[16:13:59.839]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:59.839]                               info, version)
[16:13:59.839]                           }
[16:13:59.839]                           base::stop(msg)
[16:13:59.839]                         }
[16:13:59.839]                       })
[16:13:59.839]                     }
[16:13:59.839]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:59.839]                     base::options(mc.cores = 1L)
[16:13:59.839]                   }
[16:13:59.839]                   options(future.plan = NULL)
[16:13:59.839]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:59.839]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:59.839]                 }
[16:13:59.839]                 ...future.workdir <- getwd()
[16:13:59.839]             }
[16:13:59.839]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:59.839]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:59.839]         }
[16:13:59.839]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:59.839]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:59.839]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:59.839]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:59.839]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:59.839]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:59.839]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:59.839]             base::names(...future.oldOptions))
[16:13:59.839]     }
[16:13:59.839]     if (FALSE) {
[16:13:59.839]     }
[16:13:59.839]     else {
[16:13:59.839]         if (TRUE) {
[16:13:59.839]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:59.839]                 open = "w")
[16:13:59.839]         }
[16:13:59.839]         else {
[16:13:59.839]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:59.839]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:59.839]         }
[16:13:59.839]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:59.839]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:59.839]             base::sink(type = "output", split = FALSE)
[16:13:59.839]             base::close(...future.stdout)
[16:13:59.839]         }, add = TRUE)
[16:13:59.839]     }
[16:13:59.839]     ...future.frame <- base::sys.nframe()
[16:13:59.839]     ...future.conditions <- base::list()
[16:13:59.839]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:59.839]     if (FALSE) {
[16:13:59.839]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:59.839]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:59.839]     }
[16:13:59.839]     ...future.result <- base::tryCatch({
[16:13:59.839]         base::withCallingHandlers({
[16:13:59.839]             ...future.value <- base::withVisible(base::local({
[16:13:59.839]                 ...future.makeSendCondition <- local({
[16:13:59.839]                   sendCondition <- NULL
[16:13:59.839]                   function(frame = 1L) {
[16:13:59.839]                     if (is.function(sendCondition)) 
[16:13:59.839]                       return(sendCondition)
[16:13:59.839]                     ns <- getNamespace("parallel")
[16:13:59.839]                     if (exists("sendData", mode = "function", 
[16:13:59.839]                       envir = ns)) {
[16:13:59.839]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:59.839]                         envir = ns)
[16:13:59.839]                       envir <- sys.frame(frame)
[16:13:59.839]                       master <- NULL
[16:13:59.839]                       while (!identical(envir, .GlobalEnv) && 
[16:13:59.839]                         !identical(envir, emptyenv())) {
[16:13:59.839]                         if (exists("master", mode = "list", envir = envir, 
[16:13:59.839]                           inherits = FALSE)) {
[16:13:59.839]                           master <- get("master", mode = "list", 
[16:13:59.839]                             envir = envir, inherits = FALSE)
[16:13:59.839]                           if (inherits(master, c("SOCKnode", 
[16:13:59.839]                             "SOCK0node"))) {
[16:13:59.839]                             sendCondition <<- function(cond) {
[16:13:59.839]                               data <- list(type = "VALUE", value = cond, 
[16:13:59.839]                                 success = TRUE)
[16:13:59.839]                               parallel_sendData(master, data)
[16:13:59.839]                             }
[16:13:59.839]                             return(sendCondition)
[16:13:59.839]                           }
[16:13:59.839]                         }
[16:13:59.839]                         frame <- frame + 1L
[16:13:59.839]                         envir <- sys.frame(frame)
[16:13:59.839]                       }
[16:13:59.839]                     }
[16:13:59.839]                     sendCondition <<- function(cond) NULL
[16:13:59.839]                   }
[16:13:59.839]                 })
[16:13:59.839]                 withCallingHandlers({
[16:13:59.839]                   {
[16:13:59.839]                     Sys.sleep(0.5)
[16:13:59.839]                     2
[16:13:59.839]                   }
[16:13:59.839]                 }, immediateCondition = function(cond) {
[16:13:59.839]                   sendCondition <- ...future.makeSendCondition()
[16:13:59.839]                   sendCondition(cond)
[16:13:59.839]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.839]                   {
[16:13:59.839]                     inherits <- base::inherits
[16:13:59.839]                     invokeRestart <- base::invokeRestart
[16:13:59.839]                     is.null <- base::is.null
[16:13:59.839]                     muffled <- FALSE
[16:13:59.839]                     if (inherits(cond, "message")) {
[16:13:59.839]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:59.839]                       if (muffled) 
[16:13:59.839]                         invokeRestart("muffleMessage")
[16:13:59.839]                     }
[16:13:59.839]                     else if (inherits(cond, "warning")) {
[16:13:59.839]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:59.839]                       if (muffled) 
[16:13:59.839]                         invokeRestart("muffleWarning")
[16:13:59.839]                     }
[16:13:59.839]                     else if (inherits(cond, "condition")) {
[16:13:59.839]                       if (!is.null(pattern)) {
[16:13:59.839]                         computeRestarts <- base::computeRestarts
[16:13:59.839]                         grepl <- base::grepl
[16:13:59.839]                         restarts <- computeRestarts(cond)
[16:13:59.839]                         for (restart in restarts) {
[16:13:59.839]                           name <- restart$name
[16:13:59.839]                           if (is.null(name)) 
[16:13:59.839]                             next
[16:13:59.839]                           if (!grepl(pattern, name)) 
[16:13:59.839]                             next
[16:13:59.839]                           invokeRestart(restart)
[16:13:59.839]                           muffled <- TRUE
[16:13:59.839]                           break
[16:13:59.839]                         }
[16:13:59.839]                       }
[16:13:59.839]                     }
[16:13:59.839]                     invisible(muffled)
[16:13:59.839]                   }
[16:13:59.839]                   muffleCondition(cond)
[16:13:59.839]                 })
[16:13:59.839]             }))
[16:13:59.839]             future::FutureResult(value = ...future.value$value, 
[16:13:59.839]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:59.839]                   ...future.rng), globalenv = if (FALSE) 
[16:13:59.839]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:59.839]                     ...future.globalenv.names))
[16:13:59.839]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:59.839]         }, condition = base::local({
[16:13:59.839]             c <- base::c
[16:13:59.839]             inherits <- base::inherits
[16:13:59.839]             invokeRestart <- base::invokeRestart
[16:13:59.839]             length <- base::length
[16:13:59.839]             list <- base::list
[16:13:59.839]             seq.int <- base::seq.int
[16:13:59.839]             signalCondition <- base::signalCondition
[16:13:59.839]             sys.calls <- base::sys.calls
[16:13:59.839]             `[[` <- base::`[[`
[16:13:59.839]             `+` <- base::`+`
[16:13:59.839]             `<<-` <- base::`<<-`
[16:13:59.839]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:59.839]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:59.839]                   3L)]
[16:13:59.839]             }
[16:13:59.839]             function(cond) {
[16:13:59.839]                 is_error <- inherits(cond, "error")
[16:13:59.839]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:59.839]                   NULL)
[16:13:59.839]                 if (is_error) {
[16:13:59.839]                   sessionInformation <- function() {
[16:13:59.839]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:59.839]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:59.839]                       search = base::search(), system = base::Sys.info())
[16:13:59.839]                   }
[16:13:59.839]                   ...future.conditions[[length(...future.conditions) + 
[16:13:59.839]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:59.839]                     cond$call), session = sessionInformation(), 
[16:13:59.839]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:59.839]                   signalCondition(cond)
[16:13:59.839]                 }
[16:13:59.839]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:59.839]                 "immediateCondition"))) {
[16:13:59.839]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:59.839]                   ...future.conditions[[length(...future.conditions) + 
[16:13:59.839]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:59.839]                   if (TRUE && !signal) {
[16:13:59.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.839]                     {
[16:13:59.839]                       inherits <- base::inherits
[16:13:59.839]                       invokeRestart <- base::invokeRestart
[16:13:59.839]                       is.null <- base::is.null
[16:13:59.839]                       muffled <- FALSE
[16:13:59.839]                       if (inherits(cond, "message")) {
[16:13:59.839]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:59.839]                         if (muffled) 
[16:13:59.839]                           invokeRestart("muffleMessage")
[16:13:59.839]                       }
[16:13:59.839]                       else if (inherits(cond, "warning")) {
[16:13:59.839]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:59.839]                         if (muffled) 
[16:13:59.839]                           invokeRestart("muffleWarning")
[16:13:59.839]                       }
[16:13:59.839]                       else if (inherits(cond, "condition")) {
[16:13:59.839]                         if (!is.null(pattern)) {
[16:13:59.839]                           computeRestarts <- base::computeRestarts
[16:13:59.839]                           grepl <- base::grepl
[16:13:59.839]                           restarts <- computeRestarts(cond)
[16:13:59.839]                           for (restart in restarts) {
[16:13:59.839]                             name <- restart$name
[16:13:59.839]                             if (is.null(name)) 
[16:13:59.839]                               next
[16:13:59.839]                             if (!grepl(pattern, name)) 
[16:13:59.839]                               next
[16:13:59.839]                             invokeRestart(restart)
[16:13:59.839]                             muffled <- TRUE
[16:13:59.839]                             break
[16:13:59.839]                           }
[16:13:59.839]                         }
[16:13:59.839]                       }
[16:13:59.839]                       invisible(muffled)
[16:13:59.839]                     }
[16:13:59.839]                     muffleCondition(cond, pattern = "^muffle")
[16:13:59.839]                   }
[16:13:59.839]                 }
[16:13:59.839]                 else {
[16:13:59.839]                   if (TRUE) {
[16:13:59.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:59.839]                     {
[16:13:59.839]                       inherits <- base::inherits
[16:13:59.839]                       invokeRestart <- base::invokeRestart
[16:13:59.839]                       is.null <- base::is.null
[16:13:59.839]                       muffled <- FALSE
[16:13:59.839]                       if (inherits(cond, "message")) {
[16:13:59.839]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:59.839]                         if (muffled) 
[16:13:59.839]                           invokeRestart("muffleMessage")
[16:13:59.839]                       }
[16:13:59.839]                       else if (inherits(cond, "warning")) {
[16:13:59.839]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:59.839]                         if (muffled) 
[16:13:59.839]                           invokeRestart("muffleWarning")
[16:13:59.839]                       }
[16:13:59.839]                       else if (inherits(cond, "condition")) {
[16:13:59.839]                         if (!is.null(pattern)) {
[16:13:59.839]                           computeRestarts <- base::computeRestarts
[16:13:59.839]                           grepl <- base::grepl
[16:13:59.839]                           restarts <- computeRestarts(cond)
[16:13:59.839]                           for (restart in restarts) {
[16:13:59.839]                             name <- restart$name
[16:13:59.839]                             if (is.null(name)) 
[16:13:59.839]                               next
[16:13:59.839]                             if (!grepl(pattern, name)) 
[16:13:59.839]                               next
[16:13:59.839]                             invokeRestart(restart)
[16:13:59.839]                             muffled <- TRUE
[16:13:59.839]                             break
[16:13:59.839]                           }
[16:13:59.839]                         }
[16:13:59.839]                       }
[16:13:59.839]                       invisible(muffled)
[16:13:59.839]                     }
[16:13:59.839]                     muffleCondition(cond, pattern = "^muffle")
[16:13:59.839]                   }
[16:13:59.839]                 }
[16:13:59.839]             }
[16:13:59.839]         }))
[16:13:59.839]     }, error = function(ex) {
[16:13:59.839]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:59.839]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:59.839]                 ...future.rng), started = ...future.startTime, 
[16:13:59.839]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:59.839]             version = "1.8"), class = "FutureResult")
[16:13:59.839]     }, finally = {
[16:13:59.839]         if (!identical(...future.workdir, getwd())) 
[16:13:59.839]             setwd(...future.workdir)
[16:13:59.839]         {
[16:13:59.839]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:59.839]                 ...future.oldOptions$nwarnings <- NULL
[16:13:59.839]             }
[16:13:59.839]             base::options(...future.oldOptions)
[16:13:59.839]             if (.Platform$OS.type == "windows") {
[16:13:59.839]                 old_names <- names(...future.oldEnvVars)
[16:13:59.839]                 envs <- base::Sys.getenv()
[16:13:59.839]                 names <- names(envs)
[16:13:59.839]                 common <- intersect(names, old_names)
[16:13:59.839]                 added <- setdiff(names, old_names)
[16:13:59.839]                 removed <- setdiff(old_names, names)
[16:13:59.839]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:59.839]                   envs[common]]
[16:13:59.839]                 NAMES <- toupper(changed)
[16:13:59.839]                 args <- list()
[16:13:59.839]                 for (kk in seq_along(NAMES)) {
[16:13:59.839]                   name <- changed[[kk]]
[16:13:59.839]                   NAME <- NAMES[[kk]]
[16:13:59.839]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.839]                     next
[16:13:59.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:59.839]                 }
[16:13:59.839]                 NAMES <- toupper(added)
[16:13:59.839]                 for (kk in seq_along(NAMES)) {
[16:13:59.839]                   name <- added[[kk]]
[16:13:59.839]                   NAME <- NAMES[[kk]]
[16:13:59.839]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.839]                     next
[16:13:59.839]                   args[[name]] <- ""
[16:13:59.839]                 }
[16:13:59.839]                 NAMES <- toupper(removed)
[16:13:59.839]                 for (kk in seq_along(NAMES)) {
[16:13:59.839]                   name <- removed[[kk]]
[16:13:59.839]                   NAME <- NAMES[[kk]]
[16:13:59.839]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:59.839]                     next
[16:13:59.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:59.839]                 }
[16:13:59.839]                 if (length(args) > 0) 
[16:13:59.839]                   base::do.call(base::Sys.setenv, args = args)
[16:13:59.839]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:59.839]             }
[16:13:59.839]             else {
[16:13:59.839]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:59.839]             }
[16:13:59.839]             {
[16:13:59.839]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:59.839]                   0L) {
[16:13:59.839]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:59.839]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:59.839]                   base::options(opts)
[16:13:59.839]                 }
[16:13:59.839]                 {
[16:13:59.839]                   {
[16:13:59.839]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:59.839]                     NULL
[16:13:59.839]                   }
[16:13:59.839]                   options(future.plan = NULL)
[16:13:59.839]                   if (is.na(NA_character_)) 
[16:13:59.839]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:59.839]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:59.839]                   future::plan(list(function (..., workers = availableCores(), 
[16:13:59.839]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:59.839]                     envir = parent.frame()) 
[16:13:59.839]                   {
[16:13:59.839]                     if (is.function(workers)) 
[16:13:59.839]                       workers <- workers()
[16:13:59.839]                     workers <- structure(as.integer(workers), 
[16:13:59.839]                       class = class(workers))
[16:13:59.839]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:59.839]                       workers >= 1)
[16:13:59.839]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:59.839]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:59.839]                     }
[16:13:59.839]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:59.839]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:59.839]                       envir = envir)
[16:13:59.839]                     if (!future$lazy) 
[16:13:59.839]                       future <- run(future)
[16:13:59.839]                     invisible(future)
[16:13:59.839]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:59.839]                 }
[16:13:59.839]             }
[16:13:59.839]         }
[16:13:59.839]     })
[16:13:59.839]     if (TRUE) {
[16:13:59.839]         base::sink(type = "output", split = FALSE)
[16:13:59.839]         if (TRUE) {
[16:13:59.839]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:59.839]         }
[16:13:59.839]         else {
[16:13:59.839]             ...future.result["stdout"] <- base::list(NULL)
[16:13:59.839]         }
[16:13:59.839]         base::close(...future.stdout)
[16:13:59.839]         ...future.stdout <- NULL
[16:13:59.839]     }
[16:13:59.839]     ...future.result$conditions <- ...future.conditions
[16:13:59.839]     ...future.result$finished <- base::Sys.time()
[16:13:59.839]     ...future.result
[16:13:59.839] }
[16:13:59.842] MultisessionFuture started
[16:13:59.842] - Launch lazy future ... done
[16:13:59.843] run() for ‘MultisessionFuture’ ... done
[16:13:59.843] resolve() on list ...
[16:13:59.843]  recursive: 0
[16:13:59.843]  length: 1
[16:13:59.843] 
[16:13:59.864] receiveMessageFromWorker() for ClusterFuture ...
[16:13:59.864] - Validating connection of MultisessionFuture
[16:13:59.864] - received message: FutureResult
[16:13:59.865] - Received FutureResult
[16:13:59.865] - Erased future from FutureRegistry
[16:13:59.865] result() for ClusterFuture ...
[16:13:59.865] - result already collected: FutureResult
[16:13:59.865] result() for ClusterFuture ... done
[16:13:59.865] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:59.865] Future #1
[16:13:59.865]  length: 0 (resolved future 1)
[16:13:59.865] resolve() on list ... DONE
[16:13:59.866] resolve() on list ...
[16:13:59.866]  recursive: 0
[16:13:59.866]  length: 1
[16:13:59.866] 
[16:14:00.389] receiveMessageFromWorker() for ClusterFuture ...
[16:14:00.390] - Validating connection of MultisessionFuture
[16:14:00.390] - received message: FutureResult
[16:14:00.390] - Received FutureResult
[16:14:00.390] - Erased future from FutureRegistry
[16:14:00.390] result() for ClusterFuture ...
[16:14:00.390] - result already collected: FutureResult
[16:14:00.390] result() for ClusterFuture ... done
[16:14:00.391] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:00.391] Future #1
[16:14:00.391]  length: 0 (resolved future 1)
[16:14:00.391] resolve() on list ... DONE
[16:14:00.391] resolve() on list ...
[16:14:00.391]  recursive: 0
[16:14:00.391]  length: 1
[16:14:00.391] 
[16:14:00.391]  length: 0 (resolved future 1)
[16:14:00.392] resolve() on list ... DONE
[16:14:00.392] resolve() on list ...
[16:14:00.392]  recursive: 0
[16:14:00.392]  length: 4
[16:14:00.392] 
[16:14:00.392] Future #1
[16:14:00.392]  length: 3 (resolved future 1)
[16:14:00.392] Future #2
[16:14:00.392]  length: 2 (resolved future 2)
[16:14:00.393]  length: 1 (resolved future 3)
[16:14:00.393]  length: 0 (resolved future 4)
[16:14:00.393] resolve() on list ... DONE
[16:14:00.393] resolve() on list ...
[16:14:00.393]  recursive: 0
[16:14:00.393]  length: 4
[16:14:00.393] 
[16:14:00.393] Future #1
[16:14:00.393]  length: 3 (resolved future 1)
[16:14:00.393] Future #2
[16:14:00.393]  length: 2 (resolved future 2)
[16:14:00.394]  length: 1 (resolved future 3)
[16:14:00.394]  length: 0 (resolved future 4)
[16:14:00.394] resolve() on list ... DONE
[16:14:00.394] resolve() on list ...
[16:14:00.394]  recursive: 0
[16:14:00.394]  length: 1
[16:14:00.394] 
[16:14:00.394]  length: 0 (resolved future 1)
[16:14:00.394] resolve() on list ... DONE
[16:14:00.395] getGlobalsAndPackages() ...
[16:14:00.395] Searching for globals...
[16:14:00.396] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:14:00.396] Searching for globals ... DONE
[16:14:00.396] Resolving globals: FALSE
[16:14:00.396] The total size of the 1 globals is 56 bytes (56 bytes)
[16:14:00.397] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:14:00.397] - globals: [1] ‘kk’
[16:14:00.397] 
[16:14:00.397] getGlobalsAndPackages() ... DONE
[16:14:00.397] run() for ‘Future’ ...
[16:14:00.397] - state: ‘created’
[16:14:00.397] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:00.411] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:00.412] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:00.412]   - Field: ‘node’
[16:14:00.412]   - Field: ‘label’
[16:14:00.412]   - Field: ‘local’
[16:14:00.412]   - Field: ‘owner’
[16:14:00.412]   - Field: ‘envir’
[16:14:00.412]   - Field: ‘workers’
[16:14:00.412]   - Field: ‘packages’
[16:14:00.412]   - Field: ‘gc’
[16:14:00.413]   - Field: ‘conditions’
[16:14:00.413]   - Field: ‘persistent’
[16:14:00.413]   - Field: ‘expr’
[16:14:00.413]   - Field: ‘uuid’
[16:14:00.413]   - Field: ‘seed’
[16:14:00.413]   - Field: ‘version’
[16:14:00.413]   - Field: ‘result’
[16:14:00.413]   - Field: ‘asynchronous’
[16:14:00.413]   - Field: ‘calls’
[16:14:00.413]   - Field: ‘globals’
[16:14:00.413]   - Field: ‘stdout’
[16:14:00.414]   - Field: ‘earlySignal’
[16:14:00.414]   - Field: ‘lazy’
[16:14:00.414]   - Field: ‘state’
[16:14:00.414] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:00.414] - Launch lazy future ...
[16:14:00.414] Packages needed by the future expression (n = 0): <none>
[16:14:00.414] Packages needed by future strategies (n = 0): <none>
[16:14:00.415] {
[16:14:00.415]     {
[16:14:00.415]         {
[16:14:00.415]             ...future.startTime <- base::Sys.time()
[16:14:00.415]             {
[16:14:00.415]                 {
[16:14:00.415]                   {
[16:14:00.415]                     {
[16:14:00.415]                       base::local({
[16:14:00.415]                         has_future <- base::requireNamespace("future", 
[16:14:00.415]                           quietly = TRUE)
[16:14:00.415]                         if (has_future) {
[16:14:00.415]                           ns <- base::getNamespace("future")
[16:14:00.415]                           version <- ns[[".package"]][["version"]]
[16:14:00.415]                           if (is.null(version)) 
[16:14:00.415]                             version <- utils::packageVersion("future")
[16:14:00.415]                         }
[16:14:00.415]                         else {
[16:14:00.415]                           version <- NULL
[16:14:00.415]                         }
[16:14:00.415]                         if (!has_future || version < "1.8.0") {
[16:14:00.415]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:00.415]                             "", base::R.version$version.string), 
[16:14:00.415]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:00.415]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:00.415]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:00.415]                               "release", "version")], collapse = " "), 
[16:14:00.415]                             hostname = base::Sys.info()[["nodename"]])
[16:14:00.415]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:00.415]                             info)
[16:14:00.415]                           info <- base::paste(info, collapse = "; ")
[16:14:00.415]                           if (!has_future) {
[16:14:00.415]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:00.415]                               info)
[16:14:00.415]                           }
[16:14:00.415]                           else {
[16:14:00.415]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:00.415]                               info, version)
[16:14:00.415]                           }
[16:14:00.415]                           base::stop(msg)
[16:14:00.415]                         }
[16:14:00.415]                       })
[16:14:00.415]                     }
[16:14:00.415]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:00.415]                     base::options(mc.cores = 1L)
[16:14:00.415]                   }
[16:14:00.415]                   options(future.plan = NULL)
[16:14:00.415]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:00.415]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:00.415]                 }
[16:14:00.415]                 ...future.workdir <- getwd()
[16:14:00.415]             }
[16:14:00.415]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:00.415]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:00.415]         }
[16:14:00.415]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:00.415]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:00.415]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:00.415]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:00.415]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:00.415]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:00.415]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:00.415]             base::names(...future.oldOptions))
[16:14:00.415]     }
[16:14:00.415]     if (FALSE) {
[16:14:00.415]     }
[16:14:00.415]     else {
[16:14:00.415]         if (TRUE) {
[16:14:00.415]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:00.415]                 open = "w")
[16:14:00.415]         }
[16:14:00.415]         else {
[16:14:00.415]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:00.415]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:00.415]         }
[16:14:00.415]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:00.415]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:00.415]             base::sink(type = "output", split = FALSE)
[16:14:00.415]             base::close(...future.stdout)
[16:14:00.415]         }, add = TRUE)
[16:14:00.415]     }
[16:14:00.415]     ...future.frame <- base::sys.nframe()
[16:14:00.415]     ...future.conditions <- base::list()
[16:14:00.415]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:00.415]     if (FALSE) {
[16:14:00.415]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:00.415]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:00.415]     }
[16:14:00.415]     ...future.result <- base::tryCatch({
[16:14:00.415]         base::withCallingHandlers({
[16:14:00.415]             ...future.value <- base::withVisible(base::local({
[16:14:00.415]                 ...future.makeSendCondition <- local({
[16:14:00.415]                   sendCondition <- NULL
[16:14:00.415]                   function(frame = 1L) {
[16:14:00.415]                     if (is.function(sendCondition)) 
[16:14:00.415]                       return(sendCondition)
[16:14:00.415]                     ns <- getNamespace("parallel")
[16:14:00.415]                     if (exists("sendData", mode = "function", 
[16:14:00.415]                       envir = ns)) {
[16:14:00.415]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:00.415]                         envir = ns)
[16:14:00.415]                       envir <- sys.frame(frame)
[16:14:00.415]                       master <- NULL
[16:14:00.415]                       while (!identical(envir, .GlobalEnv) && 
[16:14:00.415]                         !identical(envir, emptyenv())) {
[16:14:00.415]                         if (exists("master", mode = "list", envir = envir, 
[16:14:00.415]                           inherits = FALSE)) {
[16:14:00.415]                           master <- get("master", mode = "list", 
[16:14:00.415]                             envir = envir, inherits = FALSE)
[16:14:00.415]                           if (inherits(master, c("SOCKnode", 
[16:14:00.415]                             "SOCK0node"))) {
[16:14:00.415]                             sendCondition <<- function(cond) {
[16:14:00.415]                               data <- list(type = "VALUE", value = cond, 
[16:14:00.415]                                 success = TRUE)
[16:14:00.415]                               parallel_sendData(master, data)
[16:14:00.415]                             }
[16:14:00.415]                             return(sendCondition)
[16:14:00.415]                           }
[16:14:00.415]                         }
[16:14:00.415]                         frame <- frame + 1L
[16:14:00.415]                         envir <- sys.frame(frame)
[16:14:00.415]                       }
[16:14:00.415]                     }
[16:14:00.415]                     sendCondition <<- function(cond) NULL
[16:14:00.415]                   }
[16:14:00.415]                 })
[16:14:00.415]                 withCallingHandlers({
[16:14:00.415]                   {
[16:14:00.415]                     Sys.sleep(0.1)
[16:14:00.415]                     kk
[16:14:00.415]                   }
[16:14:00.415]                 }, immediateCondition = function(cond) {
[16:14:00.415]                   sendCondition <- ...future.makeSendCondition()
[16:14:00.415]                   sendCondition(cond)
[16:14:00.415]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:00.415]                   {
[16:14:00.415]                     inherits <- base::inherits
[16:14:00.415]                     invokeRestart <- base::invokeRestart
[16:14:00.415]                     is.null <- base::is.null
[16:14:00.415]                     muffled <- FALSE
[16:14:00.415]                     if (inherits(cond, "message")) {
[16:14:00.415]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:00.415]                       if (muffled) 
[16:14:00.415]                         invokeRestart("muffleMessage")
[16:14:00.415]                     }
[16:14:00.415]                     else if (inherits(cond, "warning")) {
[16:14:00.415]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:00.415]                       if (muffled) 
[16:14:00.415]                         invokeRestart("muffleWarning")
[16:14:00.415]                     }
[16:14:00.415]                     else if (inherits(cond, "condition")) {
[16:14:00.415]                       if (!is.null(pattern)) {
[16:14:00.415]                         computeRestarts <- base::computeRestarts
[16:14:00.415]                         grepl <- base::grepl
[16:14:00.415]                         restarts <- computeRestarts(cond)
[16:14:00.415]                         for (restart in restarts) {
[16:14:00.415]                           name <- restart$name
[16:14:00.415]                           if (is.null(name)) 
[16:14:00.415]                             next
[16:14:00.415]                           if (!grepl(pattern, name)) 
[16:14:00.415]                             next
[16:14:00.415]                           invokeRestart(restart)
[16:14:00.415]                           muffled <- TRUE
[16:14:00.415]                           break
[16:14:00.415]                         }
[16:14:00.415]                       }
[16:14:00.415]                     }
[16:14:00.415]                     invisible(muffled)
[16:14:00.415]                   }
[16:14:00.415]                   muffleCondition(cond)
[16:14:00.415]                 })
[16:14:00.415]             }))
[16:14:00.415]             future::FutureResult(value = ...future.value$value, 
[16:14:00.415]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:00.415]                   ...future.rng), globalenv = if (FALSE) 
[16:14:00.415]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:00.415]                     ...future.globalenv.names))
[16:14:00.415]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:00.415]         }, condition = base::local({
[16:14:00.415]             c <- base::c
[16:14:00.415]             inherits <- base::inherits
[16:14:00.415]             invokeRestart <- base::invokeRestart
[16:14:00.415]             length <- base::length
[16:14:00.415]             list <- base::list
[16:14:00.415]             seq.int <- base::seq.int
[16:14:00.415]             signalCondition <- base::signalCondition
[16:14:00.415]             sys.calls <- base::sys.calls
[16:14:00.415]             `[[` <- base::`[[`
[16:14:00.415]             `+` <- base::`+`
[16:14:00.415]             `<<-` <- base::`<<-`
[16:14:00.415]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:00.415]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:00.415]                   3L)]
[16:14:00.415]             }
[16:14:00.415]             function(cond) {
[16:14:00.415]                 is_error <- inherits(cond, "error")
[16:14:00.415]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:00.415]                   NULL)
[16:14:00.415]                 if (is_error) {
[16:14:00.415]                   sessionInformation <- function() {
[16:14:00.415]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:00.415]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:00.415]                       search = base::search(), system = base::Sys.info())
[16:14:00.415]                   }
[16:14:00.415]                   ...future.conditions[[length(...future.conditions) + 
[16:14:00.415]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:00.415]                     cond$call), session = sessionInformation(), 
[16:14:00.415]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:00.415]                   signalCondition(cond)
[16:14:00.415]                 }
[16:14:00.415]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:00.415]                 "immediateCondition"))) {
[16:14:00.415]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:00.415]                   ...future.conditions[[length(...future.conditions) + 
[16:14:00.415]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:00.415]                   if (TRUE && !signal) {
[16:14:00.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:00.415]                     {
[16:14:00.415]                       inherits <- base::inherits
[16:14:00.415]                       invokeRestart <- base::invokeRestart
[16:14:00.415]                       is.null <- base::is.null
[16:14:00.415]                       muffled <- FALSE
[16:14:00.415]                       if (inherits(cond, "message")) {
[16:14:00.415]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:00.415]                         if (muffled) 
[16:14:00.415]                           invokeRestart("muffleMessage")
[16:14:00.415]                       }
[16:14:00.415]                       else if (inherits(cond, "warning")) {
[16:14:00.415]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:00.415]                         if (muffled) 
[16:14:00.415]                           invokeRestart("muffleWarning")
[16:14:00.415]                       }
[16:14:00.415]                       else if (inherits(cond, "condition")) {
[16:14:00.415]                         if (!is.null(pattern)) {
[16:14:00.415]                           computeRestarts <- base::computeRestarts
[16:14:00.415]                           grepl <- base::grepl
[16:14:00.415]                           restarts <- computeRestarts(cond)
[16:14:00.415]                           for (restart in restarts) {
[16:14:00.415]                             name <- restart$name
[16:14:00.415]                             if (is.null(name)) 
[16:14:00.415]                               next
[16:14:00.415]                             if (!grepl(pattern, name)) 
[16:14:00.415]                               next
[16:14:00.415]                             invokeRestart(restart)
[16:14:00.415]                             muffled <- TRUE
[16:14:00.415]                             break
[16:14:00.415]                           }
[16:14:00.415]                         }
[16:14:00.415]                       }
[16:14:00.415]                       invisible(muffled)
[16:14:00.415]                     }
[16:14:00.415]                     muffleCondition(cond, pattern = "^muffle")
[16:14:00.415]                   }
[16:14:00.415]                 }
[16:14:00.415]                 else {
[16:14:00.415]                   if (TRUE) {
[16:14:00.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:00.415]                     {
[16:14:00.415]                       inherits <- base::inherits
[16:14:00.415]                       invokeRestart <- base::invokeRestart
[16:14:00.415]                       is.null <- base::is.null
[16:14:00.415]                       muffled <- FALSE
[16:14:00.415]                       if (inherits(cond, "message")) {
[16:14:00.415]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:00.415]                         if (muffled) 
[16:14:00.415]                           invokeRestart("muffleMessage")
[16:14:00.415]                       }
[16:14:00.415]                       else if (inherits(cond, "warning")) {
[16:14:00.415]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:00.415]                         if (muffled) 
[16:14:00.415]                           invokeRestart("muffleWarning")
[16:14:00.415]                       }
[16:14:00.415]                       else if (inherits(cond, "condition")) {
[16:14:00.415]                         if (!is.null(pattern)) {
[16:14:00.415]                           computeRestarts <- base::computeRestarts
[16:14:00.415]                           grepl <- base::grepl
[16:14:00.415]                           restarts <- computeRestarts(cond)
[16:14:00.415]                           for (restart in restarts) {
[16:14:00.415]                             name <- restart$name
[16:14:00.415]                             if (is.null(name)) 
[16:14:00.415]                               next
[16:14:00.415]                             if (!grepl(pattern, name)) 
[16:14:00.415]                               next
[16:14:00.415]                             invokeRestart(restart)
[16:14:00.415]                             muffled <- TRUE
[16:14:00.415]                             break
[16:14:00.415]                           }
[16:14:00.415]                         }
[16:14:00.415]                       }
[16:14:00.415]                       invisible(muffled)
[16:14:00.415]                     }
[16:14:00.415]                     muffleCondition(cond, pattern = "^muffle")
[16:14:00.415]                   }
[16:14:00.415]                 }
[16:14:00.415]             }
[16:14:00.415]         }))
[16:14:00.415]     }, error = function(ex) {
[16:14:00.415]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:00.415]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:00.415]                 ...future.rng), started = ...future.startTime, 
[16:14:00.415]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:00.415]             version = "1.8"), class = "FutureResult")
[16:14:00.415]     }, finally = {
[16:14:00.415]         if (!identical(...future.workdir, getwd())) 
[16:14:00.415]             setwd(...future.workdir)
[16:14:00.415]         {
[16:14:00.415]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:00.415]                 ...future.oldOptions$nwarnings <- NULL
[16:14:00.415]             }
[16:14:00.415]             base::options(...future.oldOptions)
[16:14:00.415]             if (.Platform$OS.type == "windows") {
[16:14:00.415]                 old_names <- names(...future.oldEnvVars)
[16:14:00.415]                 envs <- base::Sys.getenv()
[16:14:00.415]                 names <- names(envs)
[16:14:00.415]                 common <- intersect(names, old_names)
[16:14:00.415]                 added <- setdiff(names, old_names)
[16:14:00.415]                 removed <- setdiff(old_names, names)
[16:14:00.415]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:00.415]                   envs[common]]
[16:14:00.415]                 NAMES <- toupper(changed)
[16:14:00.415]                 args <- list()
[16:14:00.415]                 for (kk in seq_along(NAMES)) {
[16:14:00.415]                   name <- changed[[kk]]
[16:14:00.415]                   NAME <- NAMES[[kk]]
[16:14:00.415]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:00.415]                     next
[16:14:00.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:00.415]                 }
[16:14:00.415]                 NAMES <- toupper(added)
[16:14:00.415]                 for (kk in seq_along(NAMES)) {
[16:14:00.415]                   name <- added[[kk]]
[16:14:00.415]                   NAME <- NAMES[[kk]]
[16:14:00.415]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:00.415]                     next
[16:14:00.415]                   args[[name]] <- ""
[16:14:00.415]                 }
[16:14:00.415]                 NAMES <- toupper(removed)
[16:14:00.415]                 for (kk in seq_along(NAMES)) {
[16:14:00.415]                   name <- removed[[kk]]
[16:14:00.415]                   NAME <- NAMES[[kk]]
[16:14:00.415]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:00.415]                     next
[16:14:00.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:00.415]                 }
[16:14:00.415]                 if (length(args) > 0) 
[16:14:00.415]                   base::do.call(base::Sys.setenv, args = args)
[16:14:00.415]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:00.415]             }
[16:14:00.415]             else {
[16:14:00.415]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:00.415]             }
[16:14:00.415]             {
[16:14:00.415]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:00.415]                   0L) {
[16:14:00.415]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:00.415]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:00.415]                   base::options(opts)
[16:14:00.415]                 }
[16:14:00.415]                 {
[16:14:00.415]                   {
[16:14:00.415]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:00.415]                     NULL
[16:14:00.415]                   }
[16:14:00.415]                   options(future.plan = NULL)
[16:14:00.415]                   if (is.na(NA_character_)) 
[16:14:00.415]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:00.415]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:00.415]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:00.415]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:00.415]                     envir = parent.frame()) 
[16:14:00.415]                   {
[16:14:00.415]                     if (is.function(workers)) 
[16:14:00.415]                       workers <- workers()
[16:14:00.415]                     workers <- structure(as.integer(workers), 
[16:14:00.415]                       class = class(workers))
[16:14:00.415]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:00.415]                       workers >= 1)
[16:14:00.415]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:00.415]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:00.415]                     }
[16:14:00.415]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:00.415]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:00.415]                       envir = envir)
[16:14:00.415]                     if (!future$lazy) 
[16:14:00.415]                       future <- run(future)
[16:14:00.415]                     invisible(future)
[16:14:00.415]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:00.415]                 }
[16:14:00.415]             }
[16:14:00.415]         }
[16:14:00.415]     })
[16:14:00.415]     if (TRUE) {
[16:14:00.415]         base::sink(type = "output", split = FALSE)
[16:14:00.415]         if (TRUE) {
[16:14:00.415]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:00.415]         }
[16:14:00.415]         else {
[16:14:00.415]             ...future.result["stdout"] <- base::list(NULL)
[16:14:00.415]         }
[16:14:00.415]         base::close(...future.stdout)
[16:14:00.415]         ...future.stdout <- NULL
[16:14:00.415]     }
[16:14:00.415]     ...future.result$conditions <- ...future.conditions
[16:14:00.415]     ...future.result$finished <- base::Sys.time()
[16:14:00.415]     ...future.result
[16:14:00.415] }
[16:14:00.417] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:14:00.418] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[16:14:00.418] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[16:14:00.418] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:14:00.419] MultisessionFuture started
[16:14:00.419] - Launch lazy future ... done
[16:14:00.419] run() for ‘MultisessionFuture’ ... done
[16:14:00.419] getGlobalsAndPackages() ...
[16:14:00.419] Searching for globals...
[16:14:00.420] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:14:00.420] Searching for globals ... DONE
[16:14:00.420] Resolving globals: FALSE
[16:14:00.421] The total size of the 1 globals is 56 bytes (56 bytes)
[16:14:00.421] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:14:00.421] - globals: [1] ‘kk’
[16:14:00.421] 
[16:14:00.421] getGlobalsAndPackages() ... DONE
[16:14:00.422] run() for ‘Future’ ...
[16:14:00.422] - state: ‘created’
[16:14:00.422] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:00.436] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:00.436] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:00.436]   - Field: ‘node’
[16:14:00.436]   - Field: ‘label’
[16:14:00.437]   - Field: ‘local’
[16:14:00.437]   - Field: ‘owner’
[16:14:00.437]   - Field: ‘envir’
[16:14:00.437]   - Field: ‘workers’
[16:14:00.437]   - Field: ‘packages’
[16:14:00.437]   - Field: ‘gc’
[16:14:00.437]   - Field: ‘conditions’
[16:14:00.437]   - Field: ‘persistent’
[16:14:00.437]   - Field: ‘expr’
[16:14:00.437]   - Field: ‘uuid’
[16:14:00.437]   - Field: ‘seed’
[16:14:00.438]   - Field: ‘version’
[16:14:00.438]   - Field: ‘result’
[16:14:00.438]   - Field: ‘asynchronous’
[16:14:00.440]   - Field: ‘calls’
[16:14:00.440]   - Field: ‘globals’
[16:14:00.441]   - Field: ‘stdout’
[16:14:00.441]   - Field: ‘earlySignal’
[16:14:00.441]   - Field: ‘lazy’
[16:14:00.441]   - Field: ‘state’
[16:14:00.441] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:00.441] - Launch lazy future ...
[16:14:00.441] Packages needed by the future expression (n = 0): <none>
[16:14:00.442] Packages needed by future strategies (n = 0): <none>
[16:14:00.442] {
[16:14:00.442]     {
[16:14:00.442]         {
[16:14:00.442]             ...future.startTime <- base::Sys.time()
[16:14:00.442]             {
[16:14:00.442]                 {
[16:14:00.442]                   {
[16:14:00.442]                     {
[16:14:00.442]                       base::local({
[16:14:00.442]                         has_future <- base::requireNamespace("future", 
[16:14:00.442]                           quietly = TRUE)
[16:14:00.442]                         if (has_future) {
[16:14:00.442]                           ns <- base::getNamespace("future")
[16:14:00.442]                           version <- ns[[".package"]][["version"]]
[16:14:00.442]                           if (is.null(version)) 
[16:14:00.442]                             version <- utils::packageVersion("future")
[16:14:00.442]                         }
[16:14:00.442]                         else {
[16:14:00.442]                           version <- NULL
[16:14:00.442]                         }
[16:14:00.442]                         if (!has_future || version < "1.8.0") {
[16:14:00.442]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:00.442]                             "", base::R.version$version.string), 
[16:14:00.442]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:00.442]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:00.442]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:00.442]                               "release", "version")], collapse = " "), 
[16:14:00.442]                             hostname = base::Sys.info()[["nodename"]])
[16:14:00.442]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:00.442]                             info)
[16:14:00.442]                           info <- base::paste(info, collapse = "; ")
[16:14:00.442]                           if (!has_future) {
[16:14:00.442]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:00.442]                               info)
[16:14:00.442]                           }
[16:14:00.442]                           else {
[16:14:00.442]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:00.442]                               info, version)
[16:14:00.442]                           }
[16:14:00.442]                           base::stop(msg)
[16:14:00.442]                         }
[16:14:00.442]                       })
[16:14:00.442]                     }
[16:14:00.442]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:00.442]                     base::options(mc.cores = 1L)
[16:14:00.442]                   }
[16:14:00.442]                   options(future.plan = NULL)
[16:14:00.442]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:00.442]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:00.442]                 }
[16:14:00.442]                 ...future.workdir <- getwd()
[16:14:00.442]             }
[16:14:00.442]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:00.442]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:00.442]         }
[16:14:00.442]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:00.442]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:00.442]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:00.442]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:00.442]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:00.442]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:00.442]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:00.442]             base::names(...future.oldOptions))
[16:14:00.442]     }
[16:14:00.442]     if (FALSE) {
[16:14:00.442]     }
[16:14:00.442]     else {
[16:14:00.442]         if (TRUE) {
[16:14:00.442]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:00.442]                 open = "w")
[16:14:00.442]         }
[16:14:00.442]         else {
[16:14:00.442]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:00.442]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:00.442]         }
[16:14:00.442]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:00.442]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:00.442]             base::sink(type = "output", split = FALSE)
[16:14:00.442]             base::close(...future.stdout)
[16:14:00.442]         }, add = TRUE)
[16:14:00.442]     }
[16:14:00.442]     ...future.frame <- base::sys.nframe()
[16:14:00.442]     ...future.conditions <- base::list()
[16:14:00.442]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:00.442]     if (FALSE) {
[16:14:00.442]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:00.442]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:00.442]     }
[16:14:00.442]     ...future.result <- base::tryCatch({
[16:14:00.442]         base::withCallingHandlers({
[16:14:00.442]             ...future.value <- base::withVisible(base::local({
[16:14:00.442]                 ...future.makeSendCondition <- local({
[16:14:00.442]                   sendCondition <- NULL
[16:14:00.442]                   function(frame = 1L) {
[16:14:00.442]                     if (is.function(sendCondition)) 
[16:14:00.442]                       return(sendCondition)
[16:14:00.442]                     ns <- getNamespace("parallel")
[16:14:00.442]                     if (exists("sendData", mode = "function", 
[16:14:00.442]                       envir = ns)) {
[16:14:00.442]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:00.442]                         envir = ns)
[16:14:00.442]                       envir <- sys.frame(frame)
[16:14:00.442]                       master <- NULL
[16:14:00.442]                       while (!identical(envir, .GlobalEnv) && 
[16:14:00.442]                         !identical(envir, emptyenv())) {
[16:14:00.442]                         if (exists("master", mode = "list", envir = envir, 
[16:14:00.442]                           inherits = FALSE)) {
[16:14:00.442]                           master <- get("master", mode = "list", 
[16:14:00.442]                             envir = envir, inherits = FALSE)
[16:14:00.442]                           if (inherits(master, c("SOCKnode", 
[16:14:00.442]                             "SOCK0node"))) {
[16:14:00.442]                             sendCondition <<- function(cond) {
[16:14:00.442]                               data <- list(type = "VALUE", value = cond, 
[16:14:00.442]                                 success = TRUE)
[16:14:00.442]                               parallel_sendData(master, data)
[16:14:00.442]                             }
[16:14:00.442]                             return(sendCondition)
[16:14:00.442]                           }
[16:14:00.442]                         }
[16:14:00.442]                         frame <- frame + 1L
[16:14:00.442]                         envir <- sys.frame(frame)
[16:14:00.442]                       }
[16:14:00.442]                     }
[16:14:00.442]                     sendCondition <<- function(cond) NULL
[16:14:00.442]                   }
[16:14:00.442]                 })
[16:14:00.442]                 withCallingHandlers({
[16:14:00.442]                   {
[16:14:00.442]                     Sys.sleep(0.1)
[16:14:00.442]                     kk
[16:14:00.442]                   }
[16:14:00.442]                 }, immediateCondition = function(cond) {
[16:14:00.442]                   sendCondition <- ...future.makeSendCondition()
[16:14:00.442]                   sendCondition(cond)
[16:14:00.442]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:00.442]                   {
[16:14:00.442]                     inherits <- base::inherits
[16:14:00.442]                     invokeRestart <- base::invokeRestart
[16:14:00.442]                     is.null <- base::is.null
[16:14:00.442]                     muffled <- FALSE
[16:14:00.442]                     if (inherits(cond, "message")) {
[16:14:00.442]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:00.442]                       if (muffled) 
[16:14:00.442]                         invokeRestart("muffleMessage")
[16:14:00.442]                     }
[16:14:00.442]                     else if (inherits(cond, "warning")) {
[16:14:00.442]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:00.442]                       if (muffled) 
[16:14:00.442]                         invokeRestart("muffleWarning")
[16:14:00.442]                     }
[16:14:00.442]                     else if (inherits(cond, "condition")) {
[16:14:00.442]                       if (!is.null(pattern)) {
[16:14:00.442]                         computeRestarts <- base::computeRestarts
[16:14:00.442]                         grepl <- base::grepl
[16:14:00.442]                         restarts <- computeRestarts(cond)
[16:14:00.442]                         for (restart in restarts) {
[16:14:00.442]                           name <- restart$name
[16:14:00.442]                           if (is.null(name)) 
[16:14:00.442]                             next
[16:14:00.442]                           if (!grepl(pattern, name)) 
[16:14:00.442]                             next
[16:14:00.442]                           invokeRestart(restart)
[16:14:00.442]                           muffled <- TRUE
[16:14:00.442]                           break
[16:14:00.442]                         }
[16:14:00.442]                       }
[16:14:00.442]                     }
[16:14:00.442]                     invisible(muffled)
[16:14:00.442]                   }
[16:14:00.442]                   muffleCondition(cond)
[16:14:00.442]                 })
[16:14:00.442]             }))
[16:14:00.442]             future::FutureResult(value = ...future.value$value, 
[16:14:00.442]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:00.442]                   ...future.rng), globalenv = if (FALSE) 
[16:14:00.442]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:00.442]                     ...future.globalenv.names))
[16:14:00.442]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:00.442]         }, condition = base::local({
[16:14:00.442]             c <- base::c
[16:14:00.442]             inherits <- base::inherits
[16:14:00.442]             invokeRestart <- base::invokeRestart
[16:14:00.442]             length <- base::length
[16:14:00.442]             list <- base::list
[16:14:00.442]             seq.int <- base::seq.int
[16:14:00.442]             signalCondition <- base::signalCondition
[16:14:00.442]             sys.calls <- base::sys.calls
[16:14:00.442]             `[[` <- base::`[[`
[16:14:00.442]             `+` <- base::`+`
[16:14:00.442]             `<<-` <- base::`<<-`
[16:14:00.442]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:00.442]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:00.442]                   3L)]
[16:14:00.442]             }
[16:14:00.442]             function(cond) {
[16:14:00.442]                 is_error <- inherits(cond, "error")
[16:14:00.442]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:00.442]                   NULL)
[16:14:00.442]                 if (is_error) {
[16:14:00.442]                   sessionInformation <- function() {
[16:14:00.442]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:00.442]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:00.442]                       search = base::search(), system = base::Sys.info())
[16:14:00.442]                   }
[16:14:00.442]                   ...future.conditions[[length(...future.conditions) + 
[16:14:00.442]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:00.442]                     cond$call), session = sessionInformation(), 
[16:14:00.442]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:00.442]                   signalCondition(cond)
[16:14:00.442]                 }
[16:14:00.442]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:00.442]                 "immediateCondition"))) {
[16:14:00.442]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:00.442]                   ...future.conditions[[length(...future.conditions) + 
[16:14:00.442]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:00.442]                   if (TRUE && !signal) {
[16:14:00.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:00.442]                     {
[16:14:00.442]                       inherits <- base::inherits
[16:14:00.442]                       invokeRestart <- base::invokeRestart
[16:14:00.442]                       is.null <- base::is.null
[16:14:00.442]                       muffled <- FALSE
[16:14:00.442]                       if (inherits(cond, "message")) {
[16:14:00.442]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:00.442]                         if (muffled) 
[16:14:00.442]                           invokeRestart("muffleMessage")
[16:14:00.442]                       }
[16:14:00.442]                       else if (inherits(cond, "warning")) {
[16:14:00.442]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:00.442]                         if (muffled) 
[16:14:00.442]                           invokeRestart("muffleWarning")
[16:14:00.442]                       }
[16:14:00.442]                       else if (inherits(cond, "condition")) {
[16:14:00.442]                         if (!is.null(pattern)) {
[16:14:00.442]                           computeRestarts <- base::computeRestarts
[16:14:00.442]                           grepl <- base::grepl
[16:14:00.442]                           restarts <- computeRestarts(cond)
[16:14:00.442]                           for (restart in restarts) {
[16:14:00.442]                             name <- restart$name
[16:14:00.442]                             if (is.null(name)) 
[16:14:00.442]                               next
[16:14:00.442]                             if (!grepl(pattern, name)) 
[16:14:00.442]                               next
[16:14:00.442]                             invokeRestart(restart)
[16:14:00.442]                             muffled <- TRUE
[16:14:00.442]                             break
[16:14:00.442]                           }
[16:14:00.442]                         }
[16:14:00.442]                       }
[16:14:00.442]                       invisible(muffled)
[16:14:00.442]                     }
[16:14:00.442]                     muffleCondition(cond, pattern = "^muffle")
[16:14:00.442]                   }
[16:14:00.442]                 }
[16:14:00.442]                 else {
[16:14:00.442]                   if (TRUE) {
[16:14:00.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:00.442]                     {
[16:14:00.442]                       inherits <- base::inherits
[16:14:00.442]                       invokeRestart <- base::invokeRestart
[16:14:00.442]                       is.null <- base::is.null
[16:14:00.442]                       muffled <- FALSE
[16:14:00.442]                       if (inherits(cond, "message")) {
[16:14:00.442]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:00.442]                         if (muffled) 
[16:14:00.442]                           invokeRestart("muffleMessage")
[16:14:00.442]                       }
[16:14:00.442]                       else if (inherits(cond, "warning")) {
[16:14:00.442]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:00.442]                         if (muffled) 
[16:14:00.442]                           invokeRestart("muffleWarning")
[16:14:00.442]                       }
[16:14:00.442]                       else if (inherits(cond, "condition")) {
[16:14:00.442]                         if (!is.null(pattern)) {
[16:14:00.442]                           computeRestarts <- base::computeRestarts
[16:14:00.442]                           grepl <- base::grepl
[16:14:00.442]                           restarts <- computeRestarts(cond)
[16:14:00.442]                           for (restart in restarts) {
[16:14:00.442]                             name <- restart$name
[16:14:00.442]                             if (is.null(name)) 
[16:14:00.442]                               next
[16:14:00.442]                             if (!grepl(pattern, name)) 
[16:14:00.442]                               next
[16:14:00.442]                             invokeRestart(restart)
[16:14:00.442]                             muffled <- TRUE
[16:14:00.442]                             break
[16:14:00.442]                           }
[16:14:00.442]                         }
[16:14:00.442]                       }
[16:14:00.442]                       invisible(muffled)
[16:14:00.442]                     }
[16:14:00.442]                     muffleCondition(cond, pattern = "^muffle")
[16:14:00.442]                   }
[16:14:00.442]                 }
[16:14:00.442]             }
[16:14:00.442]         }))
[16:14:00.442]     }, error = function(ex) {
[16:14:00.442]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:00.442]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:00.442]                 ...future.rng), started = ...future.startTime, 
[16:14:00.442]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:00.442]             version = "1.8"), class = "FutureResult")
[16:14:00.442]     }, finally = {
[16:14:00.442]         if (!identical(...future.workdir, getwd())) 
[16:14:00.442]             setwd(...future.workdir)
[16:14:00.442]         {
[16:14:00.442]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:00.442]                 ...future.oldOptions$nwarnings <- NULL
[16:14:00.442]             }
[16:14:00.442]             base::options(...future.oldOptions)
[16:14:00.442]             if (.Platform$OS.type == "windows") {
[16:14:00.442]                 old_names <- names(...future.oldEnvVars)
[16:14:00.442]                 envs <- base::Sys.getenv()
[16:14:00.442]                 names <- names(envs)
[16:14:00.442]                 common <- intersect(names, old_names)
[16:14:00.442]                 added <- setdiff(names, old_names)
[16:14:00.442]                 removed <- setdiff(old_names, names)
[16:14:00.442]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:00.442]                   envs[common]]
[16:14:00.442]                 NAMES <- toupper(changed)
[16:14:00.442]                 args <- list()
[16:14:00.442]                 for (kk in seq_along(NAMES)) {
[16:14:00.442]                   name <- changed[[kk]]
[16:14:00.442]                   NAME <- NAMES[[kk]]
[16:14:00.442]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:00.442]                     next
[16:14:00.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:00.442]                 }
[16:14:00.442]                 NAMES <- toupper(added)
[16:14:00.442]                 for (kk in seq_along(NAMES)) {
[16:14:00.442]                   name <- added[[kk]]
[16:14:00.442]                   NAME <- NAMES[[kk]]
[16:14:00.442]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:00.442]                     next
[16:14:00.442]                   args[[name]] <- ""
[16:14:00.442]                 }
[16:14:00.442]                 NAMES <- toupper(removed)
[16:14:00.442]                 for (kk in seq_along(NAMES)) {
[16:14:00.442]                   name <- removed[[kk]]
[16:14:00.442]                   NAME <- NAMES[[kk]]
[16:14:00.442]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:00.442]                     next
[16:14:00.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:00.442]                 }
[16:14:00.442]                 if (length(args) > 0) 
[16:14:00.442]                   base::do.call(base::Sys.setenv, args = args)
[16:14:00.442]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:00.442]             }
[16:14:00.442]             else {
[16:14:00.442]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:00.442]             }
[16:14:00.442]             {
[16:14:00.442]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:00.442]                   0L) {
[16:14:00.442]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:00.442]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:00.442]                   base::options(opts)
[16:14:00.442]                 }
[16:14:00.442]                 {
[16:14:00.442]                   {
[16:14:00.442]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:00.442]                     NULL
[16:14:00.442]                   }
[16:14:00.442]                   options(future.plan = NULL)
[16:14:00.442]                   if (is.na(NA_character_)) 
[16:14:00.442]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:00.442]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:00.442]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:00.442]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:00.442]                     envir = parent.frame()) 
[16:14:00.442]                   {
[16:14:00.442]                     if (is.function(workers)) 
[16:14:00.442]                       workers <- workers()
[16:14:00.442]                     workers <- structure(as.integer(workers), 
[16:14:00.442]                       class = class(workers))
[16:14:00.442]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:00.442]                       workers >= 1)
[16:14:00.442]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:00.442]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:00.442]                     }
[16:14:00.442]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:00.442]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:00.442]                       envir = envir)
[16:14:00.442]                     if (!future$lazy) 
[16:14:00.442]                       future <- run(future)
[16:14:00.442]                     invisible(future)
[16:14:00.442]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:00.442]                 }
[16:14:00.442]             }
[16:14:00.442]         }
[16:14:00.442]     })
[16:14:00.442]     if (TRUE) {
[16:14:00.442]         base::sink(type = "output", split = FALSE)
[16:14:00.442]         if (TRUE) {
[16:14:00.442]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:00.442]         }
[16:14:00.442]         else {
[16:14:00.442]             ...future.result["stdout"] <- base::list(NULL)
[16:14:00.442]         }
[16:14:00.442]         base::close(...future.stdout)
[16:14:00.442]         ...future.stdout <- NULL
[16:14:00.442]     }
[16:14:00.442]     ...future.result$conditions <- ...future.conditions
[16:14:00.442]     ...future.result$finished <- base::Sys.time()
[16:14:00.442]     ...future.result
[16:14:00.442] }
[16:14:00.445] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[16:14:00.445] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[16:14:00.445] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[16:14:00.445] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[16:14:00.446] MultisessionFuture started
[16:14:00.446] - Launch lazy future ... done
[16:14:00.446] run() for ‘MultisessionFuture’ ... done
[16:14:00.446] getGlobalsAndPackages() ...
[16:14:00.446] Searching for globals...
[16:14:00.447] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:14:00.447] Searching for globals ... DONE
[16:14:00.447] Resolving globals: FALSE
[16:14:00.448] The total size of the 1 globals is 56 bytes (56 bytes)
[16:14:00.448] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:14:00.448] - globals: [1] ‘kk’
[16:14:00.448] 
[16:14:00.448] getGlobalsAndPackages() ... DONE
[16:14:00.448] run() for ‘Future’ ...
[16:14:00.449] - state: ‘created’
[16:14:00.449] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:00.464] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:00.464] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:00.465]   - Field: ‘node’
[16:14:00.465]   - Field: ‘label’
[16:14:00.465]   - Field: ‘local’
[16:14:00.465]   - Field: ‘owner’
[16:14:00.465]   - Field: ‘envir’
[16:14:00.465]   - Field: ‘workers’
[16:14:00.465]   - Field: ‘packages’
[16:14:00.465]   - Field: ‘gc’
[16:14:00.466]   - Field: ‘conditions’
[16:14:00.466]   - Field: ‘persistent’
[16:14:00.466]   - Field: ‘expr’
[16:14:00.466]   - Field: ‘uuid’
[16:14:00.466]   - Field: ‘seed’
[16:14:00.466]   - Field: ‘version’
[16:14:00.466]   - Field: ‘result’
[16:14:00.466]   - Field: ‘asynchronous’
[16:14:00.466]   - Field: ‘calls’
[16:14:00.466]   - Field: ‘globals’
[16:14:00.466]   - Field: ‘stdout’
[16:14:00.466]   - Field: ‘earlySignal’
[16:14:00.467]   - Field: ‘lazy’
[16:14:00.467]   - Field: ‘state’
[16:14:00.467] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:00.467] - Launch lazy future ...
[16:14:00.467] Packages needed by the future expression (n = 0): <none>
[16:14:00.467] Packages needed by future strategies (n = 0): <none>
[16:14:00.468] {
[16:14:00.468]     {
[16:14:00.468]         {
[16:14:00.468]             ...future.startTime <- base::Sys.time()
[16:14:00.468]             {
[16:14:00.468]                 {
[16:14:00.468]                   {
[16:14:00.468]                     {
[16:14:00.468]                       base::local({
[16:14:00.468]                         has_future <- base::requireNamespace("future", 
[16:14:00.468]                           quietly = TRUE)
[16:14:00.468]                         if (has_future) {
[16:14:00.468]                           ns <- base::getNamespace("future")
[16:14:00.468]                           version <- ns[[".package"]][["version"]]
[16:14:00.468]                           if (is.null(version)) 
[16:14:00.468]                             version <- utils::packageVersion("future")
[16:14:00.468]                         }
[16:14:00.468]                         else {
[16:14:00.468]                           version <- NULL
[16:14:00.468]                         }
[16:14:00.468]                         if (!has_future || version < "1.8.0") {
[16:14:00.468]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:00.468]                             "", base::R.version$version.string), 
[16:14:00.468]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:00.468]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:00.468]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:00.468]                               "release", "version")], collapse = " "), 
[16:14:00.468]                             hostname = base::Sys.info()[["nodename"]])
[16:14:00.468]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:00.468]                             info)
[16:14:00.468]                           info <- base::paste(info, collapse = "; ")
[16:14:00.468]                           if (!has_future) {
[16:14:00.468]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:00.468]                               info)
[16:14:00.468]                           }
[16:14:00.468]                           else {
[16:14:00.468]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:00.468]                               info, version)
[16:14:00.468]                           }
[16:14:00.468]                           base::stop(msg)
[16:14:00.468]                         }
[16:14:00.468]                       })
[16:14:00.468]                     }
[16:14:00.468]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:00.468]                     base::options(mc.cores = 1L)
[16:14:00.468]                   }
[16:14:00.468]                   options(future.plan = NULL)
[16:14:00.468]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:00.468]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:00.468]                 }
[16:14:00.468]                 ...future.workdir <- getwd()
[16:14:00.468]             }
[16:14:00.468]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:00.468]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:00.468]         }
[16:14:00.468]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:00.468]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:00.468]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:00.468]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:00.468]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:00.468]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:00.468]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:00.468]             base::names(...future.oldOptions))
[16:14:00.468]     }
[16:14:00.468]     if (FALSE) {
[16:14:00.468]     }
[16:14:00.468]     else {
[16:14:00.468]         if (TRUE) {
[16:14:00.468]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:00.468]                 open = "w")
[16:14:00.468]         }
[16:14:00.468]         else {
[16:14:00.468]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:00.468]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:00.468]         }
[16:14:00.468]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:00.468]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:00.468]             base::sink(type = "output", split = FALSE)
[16:14:00.468]             base::close(...future.stdout)
[16:14:00.468]         }, add = TRUE)
[16:14:00.468]     }
[16:14:00.468]     ...future.frame <- base::sys.nframe()
[16:14:00.468]     ...future.conditions <- base::list()
[16:14:00.468]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:00.468]     if (FALSE) {
[16:14:00.468]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:00.468]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:00.468]     }
[16:14:00.468]     ...future.result <- base::tryCatch({
[16:14:00.468]         base::withCallingHandlers({
[16:14:00.468]             ...future.value <- base::withVisible(base::local({
[16:14:00.468]                 ...future.makeSendCondition <- local({
[16:14:00.468]                   sendCondition <- NULL
[16:14:00.468]                   function(frame = 1L) {
[16:14:00.468]                     if (is.function(sendCondition)) 
[16:14:00.468]                       return(sendCondition)
[16:14:00.468]                     ns <- getNamespace("parallel")
[16:14:00.468]                     if (exists("sendData", mode = "function", 
[16:14:00.468]                       envir = ns)) {
[16:14:00.468]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:00.468]                         envir = ns)
[16:14:00.468]                       envir <- sys.frame(frame)
[16:14:00.468]                       master <- NULL
[16:14:00.468]                       while (!identical(envir, .GlobalEnv) && 
[16:14:00.468]                         !identical(envir, emptyenv())) {
[16:14:00.468]                         if (exists("master", mode = "list", envir = envir, 
[16:14:00.468]                           inherits = FALSE)) {
[16:14:00.468]                           master <- get("master", mode = "list", 
[16:14:00.468]                             envir = envir, inherits = FALSE)
[16:14:00.468]                           if (inherits(master, c("SOCKnode", 
[16:14:00.468]                             "SOCK0node"))) {
[16:14:00.468]                             sendCondition <<- function(cond) {
[16:14:00.468]                               data <- list(type = "VALUE", value = cond, 
[16:14:00.468]                                 success = TRUE)
[16:14:00.468]                               parallel_sendData(master, data)
[16:14:00.468]                             }
[16:14:00.468]                             return(sendCondition)
[16:14:00.468]                           }
[16:14:00.468]                         }
[16:14:00.468]                         frame <- frame + 1L
[16:14:00.468]                         envir <- sys.frame(frame)
[16:14:00.468]                       }
[16:14:00.468]                     }
[16:14:00.468]                     sendCondition <<- function(cond) NULL
[16:14:00.468]                   }
[16:14:00.468]                 })
[16:14:00.468]                 withCallingHandlers({
[16:14:00.468]                   {
[16:14:00.468]                     Sys.sleep(0.1)
[16:14:00.468]                     kk
[16:14:00.468]                   }
[16:14:00.468]                 }, immediateCondition = function(cond) {
[16:14:00.468]                   sendCondition <- ...future.makeSendCondition()
[16:14:00.468]                   sendCondition(cond)
[16:14:00.468]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:00.468]                   {
[16:14:00.468]                     inherits <- base::inherits
[16:14:00.468]                     invokeRestart <- base::invokeRestart
[16:14:00.468]                     is.null <- base::is.null
[16:14:00.468]                     muffled <- FALSE
[16:14:00.468]                     if (inherits(cond, "message")) {
[16:14:00.468]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:00.468]                       if (muffled) 
[16:14:00.468]                         invokeRestart("muffleMessage")
[16:14:00.468]                     }
[16:14:00.468]                     else if (inherits(cond, "warning")) {
[16:14:00.468]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:00.468]                       if (muffled) 
[16:14:00.468]                         invokeRestart("muffleWarning")
[16:14:00.468]                     }
[16:14:00.468]                     else if (inherits(cond, "condition")) {
[16:14:00.468]                       if (!is.null(pattern)) {
[16:14:00.468]                         computeRestarts <- base::computeRestarts
[16:14:00.468]                         grepl <- base::grepl
[16:14:00.468]                         restarts <- computeRestarts(cond)
[16:14:00.468]                         for (restart in restarts) {
[16:14:00.468]                           name <- restart$name
[16:14:00.468]                           if (is.null(name)) 
[16:14:00.468]                             next
[16:14:00.468]                           if (!grepl(pattern, name)) 
[16:14:00.468]                             next
[16:14:00.468]                           invokeRestart(restart)
[16:14:00.468]                           muffled <- TRUE
[16:14:00.468]                           break
[16:14:00.468]                         }
[16:14:00.468]                       }
[16:14:00.468]                     }
[16:14:00.468]                     invisible(muffled)
[16:14:00.468]                   }
[16:14:00.468]                   muffleCondition(cond)
[16:14:00.468]                 })
[16:14:00.468]             }))
[16:14:00.468]             future::FutureResult(value = ...future.value$value, 
[16:14:00.468]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:00.468]                   ...future.rng), globalenv = if (FALSE) 
[16:14:00.468]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:00.468]                     ...future.globalenv.names))
[16:14:00.468]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:00.468]         }, condition = base::local({
[16:14:00.468]             c <- base::c
[16:14:00.468]             inherits <- base::inherits
[16:14:00.468]             invokeRestart <- base::invokeRestart
[16:14:00.468]             length <- base::length
[16:14:00.468]             list <- base::list
[16:14:00.468]             seq.int <- base::seq.int
[16:14:00.468]             signalCondition <- base::signalCondition
[16:14:00.468]             sys.calls <- base::sys.calls
[16:14:00.468]             `[[` <- base::`[[`
[16:14:00.468]             `+` <- base::`+`
[16:14:00.468]             `<<-` <- base::`<<-`
[16:14:00.468]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:00.468]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:00.468]                   3L)]
[16:14:00.468]             }
[16:14:00.468]             function(cond) {
[16:14:00.468]                 is_error <- inherits(cond, "error")
[16:14:00.468]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:00.468]                   NULL)
[16:14:00.468]                 if (is_error) {
[16:14:00.468]                   sessionInformation <- function() {
[16:14:00.468]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:00.468]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:00.468]                       search = base::search(), system = base::Sys.info())
[16:14:00.468]                   }
[16:14:00.468]                   ...future.conditions[[length(...future.conditions) + 
[16:14:00.468]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:00.468]                     cond$call), session = sessionInformation(), 
[16:14:00.468]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:00.468]                   signalCondition(cond)
[16:14:00.468]                 }
[16:14:00.468]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:00.468]                 "immediateCondition"))) {
[16:14:00.468]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:00.468]                   ...future.conditions[[length(...future.conditions) + 
[16:14:00.468]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:00.468]                   if (TRUE && !signal) {
[16:14:00.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:00.468]                     {
[16:14:00.468]                       inherits <- base::inherits
[16:14:00.468]                       invokeRestart <- base::invokeRestart
[16:14:00.468]                       is.null <- base::is.null
[16:14:00.468]                       muffled <- FALSE
[16:14:00.468]                       if (inherits(cond, "message")) {
[16:14:00.468]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:00.468]                         if (muffled) 
[16:14:00.468]                           invokeRestart("muffleMessage")
[16:14:00.468]                       }
[16:14:00.468]                       else if (inherits(cond, "warning")) {
[16:14:00.468]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:00.468]                         if (muffled) 
[16:14:00.468]                           invokeRestart("muffleWarning")
[16:14:00.468]                       }
[16:14:00.468]                       else if (inherits(cond, "condition")) {
[16:14:00.468]                         if (!is.null(pattern)) {
[16:14:00.468]                           computeRestarts <- base::computeRestarts
[16:14:00.468]                           grepl <- base::grepl
[16:14:00.468]                           restarts <- computeRestarts(cond)
[16:14:00.468]                           for (restart in restarts) {
[16:14:00.468]                             name <- restart$name
[16:14:00.468]                             if (is.null(name)) 
[16:14:00.468]                               next
[16:14:00.468]                             if (!grepl(pattern, name)) 
[16:14:00.468]                               next
[16:14:00.468]                             invokeRestart(restart)
[16:14:00.468]                             muffled <- TRUE
[16:14:00.468]                             break
[16:14:00.468]                           }
[16:14:00.468]                         }
[16:14:00.468]                       }
[16:14:00.468]                       invisible(muffled)
[16:14:00.468]                     }
[16:14:00.468]                     muffleCondition(cond, pattern = "^muffle")
[16:14:00.468]                   }
[16:14:00.468]                 }
[16:14:00.468]                 else {
[16:14:00.468]                   if (TRUE) {
[16:14:00.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:00.468]                     {
[16:14:00.468]                       inherits <- base::inherits
[16:14:00.468]                       invokeRestart <- base::invokeRestart
[16:14:00.468]                       is.null <- base::is.null
[16:14:00.468]                       muffled <- FALSE
[16:14:00.468]                       if (inherits(cond, "message")) {
[16:14:00.468]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:00.468]                         if (muffled) 
[16:14:00.468]                           invokeRestart("muffleMessage")
[16:14:00.468]                       }
[16:14:00.468]                       else if (inherits(cond, "warning")) {
[16:14:00.468]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:00.468]                         if (muffled) 
[16:14:00.468]                           invokeRestart("muffleWarning")
[16:14:00.468]                       }
[16:14:00.468]                       else if (inherits(cond, "condition")) {
[16:14:00.468]                         if (!is.null(pattern)) {
[16:14:00.468]                           computeRestarts <- base::computeRestarts
[16:14:00.468]                           grepl <- base::grepl
[16:14:00.468]                           restarts <- computeRestarts(cond)
[16:14:00.468]                           for (restart in restarts) {
[16:14:00.468]                             name <- restart$name
[16:14:00.468]                             if (is.null(name)) 
[16:14:00.468]                               next
[16:14:00.468]                             if (!grepl(pattern, name)) 
[16:14:00.468]                               next
[16:14:00.468]                             invokeRestart(restart)
[16:14:00.468]                             muffled <- TRUE
[16:14:00.468]                             break
[16:14:00.468]                           }
[16:14:00.468]                         }
[16:14:00.468]                       }
[16:14:00.468]                       invisible(muffled)
[16:14:00.468]                     }
[16:14:00.468]                     muffleCondition(cond, pattern = "^muffle")
[16:14:00.468]                   }
[16:14:00.468]                 }
[16:14:00.468]             }
[16:14:00.468]         }))
[16:14:00.468]     }, error = function(ex) {
[16:14:00.468]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:00.468]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:00.468]                 ...future.rng), started = ...future.startTime, 
[16:14:00.468]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:00.468]             version = "1.8"), class = "FutureResult")
[16:14:00.468]     }, finally = {
[16:14:00.468]         if (!identical(...future.workdir, getwd())) 
[16:14:00.468]             setwd(...future.workdir)
[16:14:00.468]         {
[16:14:00.468]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:00.468]                 ...future.oldOptions$nwarnings <- NULL
[16:14:00.468]             }
[16:14:00.468]             base::options(...future.oldOptions)
[16:14:00.468]             if (.Platform$OS.type == "windows") {
[16:14:00.468]                 old_names <- names(...future.oldEnvVars)
[16:14:00.468]                 envs <- base::Sys.getenv()
[16:14:00.468]                 names <- names(envs)
[16:14:00.468]                 common <- intersect(names, old_names)
[16:14:00.468]                 added <- setdiff(names, old_names)
[16:14:00.468]                 removed <- setdiff(old_names, names)
[16:14:00.468]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:00.468]                   envs[common]]
[16:14:00.468]                 NAMES <- toupper(changed)
[16:14:00.468]                 args <- list()
[16:14:00.468]                 for (kk in seq_along(NAMES)) {
[16:14:00.468]                   name <- changed[[kk]]
[16:14:00.468]                   NAME <- NAMES[[kk]]
[16:14:00.468]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:00.468]                     next
[16:14:00.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:00.468]                 }
[16:14:00.468]                 NAMES <- toupper(added)
[16:14:00.468]                 for (kk in seq_along(NAMES)) {
[16:14:00.468]                   name <- added[[kk]]
[16:14:00.468]                   NAME <- NAMES[[kk]]
[16:14:00.468]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:00.468]                     next
[16:14:00.468]                   args[[name]] <- ""
[16:14:00.468]                 }
[16:14:00.468]                 NAMES <- toupper(removed)
[16:14:00.468]                 for (kk in seq_along(NAMES)) {
[16:14:00.468]                   name <- removed[[kk]]
[16:14:00.468]                   NAME <- NAMES[[kk]]
[16:14:00.468]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:00.468]                     next
[16:14:00.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:00.468]                 }
[16:14:00.468]                 if (length(args) > 0) 
[16:14:00.468]                   base::do.call(base::Sys.setenv, args = args)
[16:14:00.468]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:00.468]             }
[16:14:00.468]             else {
[16:14:00.468]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:00.468]             }
[16:14:00.468]             {
[16:14:00.468]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:00.468]                   0L) {
[16:14:00.468]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:00.468]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:00.468]                   base::options(opts)
[16:14:00.468]                 }
[16:14:00.468]                 {
[16:14:00.468]                   {
[16:14:00.468]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:00.468]                     NULL
[16:14:00.468]                   }
[16:14:00.468]                   options(future.plan = NULL)
[16:14:00.468]                   if (is.na(NA_character_)) 
[16:14:00.468]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:00.468]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:00.468]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:00.468]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:00.468]                     envir = parent.frame()) 
[16:14:00.468]                   {
[16:14:00.468]                     if (is.function(workers)) 
[16:14:00.468]                       workers <- workers()
[16:14:00.468]                     workers <- structure(as.integer(workers), 
[16:14:00.468]                       class = class(workers))
[16:14:00.468]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:00.468]                       workers >= 1)
[16:14:00.468]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:00.468]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:00.468]                     }
[16:14:00.468]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:00.468]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:00.468]                       envir = envir)
[16:14:00.468]                     if (!future$lazy) 
[16:14:00.468]                       future <- run(future)
[16:14:00.468]                     invisible(future)
[16:14:00.468]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:00.468]                 }
[16:14:00.468]             }
[16:14:00.468]         }
[16:14:00.468]     })
[16:14:00.468]     if (TRUE) {
[16:14:00.468]         base::sink(type = "output", split = FALSE)
[16:14:00.468]         if (TRUE) {
[16:14:00.468]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:00.468]         }
[16:14:00.468]         else {
[16:14:00.468]             ...future.result["stdout"] <- base::list(NULL)
[16:14:00.468]         }
[16:14:00.468]         base::close(...future.stdout)
[16:14:00.468]         ...future.stdout <- NULL
[16:14:00.468]     }
[16:14:00.468]     ...future.result$conditions <- ...future.conditions
[16:14:00.468]     ...future.result$finished <- base::Sys.time()
[16:14:00.468]     ...future.result
[16:14:00.468] }
[16:14:00.470] Poll #1 (0): usedNodes() = 2, workers = 2
[16:14:00.501] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[16:14:00.532] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[16:14:00.564] Poll #4 (0.09 secs): usedNodes() = 2, workers = 2
[16:14:00.575] receiveMessageFromWorker() for ClusterFuture ...
[16:14:00.575] - Validating connection of MultisessionFuture
[16:14:00.575] - received message: FutureResult
[16:14:00.575] - Received FutureResult
[16:14:00.575] - Erased future from FutureRegistry
[16:14:00.575] result() for ClusterFuture ...
[16:14:00.576] - result already collected: FutureResult
[16:14:00.576] result() for ClusterFuture ... done
[16:14:00.576] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:00.576] result() for ClusterFuture ...
[16:14:00.576] - result already collected: FutureResult
[16:14:00.576] result() for ClusterFuture ... done
[16:14:00.576] result() for ClusterFuture ...
[16:14:00.576] - result already collected: FutureResult
[16:14:00.576] result() for ClusterFuture ... done
[16:14:00.577] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:14:00.577] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[16:14:00.577] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[16:14:00.578] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:14:00.578] MultisessionFuture started
[16:14:00.578] - Launch lazy future ... done
[16:14:00.578] run() for ‘MultisessionFuture’ ... done
[16:14:00.579] resolve() on list ...
[16:14:00.579]  recursive: 0
[16:14:00.579]  length: 3
[16:14:00.579] 
[16:14:00.579] Future #1
[16:14:00.579]  length: 2 (resolved future 1)
[16:14:00.611] receiveMessageFromWorker() for ClusterFuture ...
[16:14:00.611] - Validating connection of MultisessionFuture
[16:14:00.611] - received message: FutureResult
[16:14:00.611] - Received FutureResult
[16:14:00.611] - Erased future from FutureRegistry
[16:14:00.611] result() for ClusterFuture ...
[16:14:00.612] - result already collected: FutureResult
[16:14:00.612] result() for ClusterFuture ... done
[16:14:00.612] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:00.612] Future #2
[16:14:00.612]  length: 1 (resolved future 2)
[16:14:00.736] receiveMessageFromWorker() for ClusterFuture ...
[16:14:00.736] - Validating connection of MultisessionFuture
[16:14:00.736] - received message: FutureResult
[16:14:00.736] - Received FutureResult
[16:14:00.736] - Erased future from FutureRegistry
[16:14:00.736] result() for ClusterFuture ...
[16:14:00.736] - result already collected: FutureResult
[16:14:00.737] result() for ClusterFuture ... done
[16:14:00.737] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:00.737] Future #3
[16:14:00.737]  length: 0 (resolved future 3)
[16:14:00.737] resolve() on list ... DONE
[16:14:00.737] getGlobalsAndPackages() ...
[16:14:00.737] Searching for globals...
[16:14:00.738] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:14:00.738] Searching for globals ... DONE
[16:14:00.739] Resolving globals: FALSE
[16:14:00.739] The total size of the 1 globals is 56 bytes (56 bytes)
[16:14:00.739] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:14:00.739] - globals: [1] ‘kk’
[16:14:00.739] 
[16:14:00.740] getGlobalsAndPackages() ... DONE
[16:14:00.740] getGlobalsAndPackages() ...
[16:14:00.740] Searching for globals...
[16:14:00.741] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:14:00.741] Searching for globals ... DONE
[16:14:00.741] Resolving globals: FALSE
[16:14:00.741] The total size of the 1 globals is 56 bytes (56 bytes)
[16:14:00.742] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:14:00.742] - globals: [1] ‘kk’
[16:14:00.742] 
[16:14:00.742] getGlobalsAndPackages() ... DONE
[16:14:00.742] getGlobalsAndPackages() ...
[16:14:00.742] Searching for globals...
[16:14:00.743] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:14:00.743] Searching for globals ... DONE
[16:14:00.743] Resolving globals: FALSE
[16:14:00.744] The total size of the 1 globals is 56 bytes (56 bytes)
[16:14:00.744] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:14:00.744] - globals: [1] ‘kk’
[16:14:00.744] 
[16:14:00.744] getGlobalsAndPackages() ... DONE
[16:14:00.745] resolve() on list ...
[16:14:00.745]  recursive: 0
[16:14:00.745]  length: 3
[16:14:00.745] 
[16:14:00.745] run() for ‘Future’ ...
[16:14:00.745] - state: ‘created’
[16:14:00.745] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:00.759] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:00.760] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:00.760]   - Field: ‘node’
[16:14:00.760]   - Field: ‘label’
[16:14:00.760]   - Field: ‘local’
[16:14:00.760]   - Field: ‘owner’
[16:14:00.760]   - Field: ‘envir’
[16:14:00.760]   - Field: ‘workers’
[16:14:00.760]   - Field: ‘packages’
[16:14:00.760]   - Field: ‘gc’
[16:14:00.760]   - Field: ‘conditions’
[16:14:00.761]   - Field: ‘persistent’
[16:14:00.761]   - Field: ‘expr’
[16:14:00.761]   - Field: ‘uuid’
[16:14:00.761]   - Field: ‘seed’
[16:14:00.761]   - Field: ‘version’
[16:14:00.761]   - Field: ‘result’
[16:14:00.761]   - Field: ‘asynchronous’
[16:14:00.761]   - Field: ‘calls’
[16:14:00.761]   - Field: ‘globals’
[16:14:00.761]   - Field: ‘stdout’
[16:14:00.761]   - Field: ‘earlySignal’
[16:14:00.762]   - Field: ‘lazy’
[16:14:00.762]   - Field: ‘state’
[16:14:00.762] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:00.762] - Launch lazy future ...
[16:14:00.762] Packages needed by the future expression (n = 0): <none>
[16:14:00.762] Packages needed by future strategies (n = 0): <none>
[16:14:00.763] {
[16:14:00.763]     {
[16:14:00.763]         {
[16:14:00.763]             ...future.startTime <- base::Sys.time()
[16:14:00.763]             {
[16:14:00.763]                 {
[16:14:00.763]                   {
[16:14:00.763]                     {
[16:14:00.763]                       base::local({
[16:14:00.763]                         has_future <- base::requireNamespace("future", 
[16:14:00.763]                           quietly = TRUE)
[16:14:00.763]                         if (has_future) {
[16:14:00.763]                           ns <- base::getNamespace("future")
[16:14:00.763]                           version <- ns[[".package"]][["version"]]
[16:14:00.763]                           if (is.null(version)) 
[16:14:00.763]                             version <- utils::packageVersion("future")
[16:14:00.763]                         }
[16:14:00.763]                         else {
[16:14:00.763]                           version <- NULL
[16:14:00.763]                         }
[16:14:00.763]                         if (!has_future || version < "1.8.0") {
[16:14:00.763]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:00.763]                             "", base::R.version$version.string), 
[16:14:00.763]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:00.763]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:00.763]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:00.763]                               "release", "version")], collapse = " "), 
[16:14:00.763]                             hostname = base::Sys.info()[["nodename"]])
[16:14:00.763]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:00.763]                             info)
[16:14:00.763]                           info <- base::paste(info, collapse = "; ")
[16:14:00.763]                           if (!has_future) {
[16:14:00.763]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:00.763]                               info)
[16:14:00.763]                           }
[16:14:00.763]                           else {
[16:14:00.763]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:00.763]                               info, version)
[16:14:00.763]                           }
[16:14:00.763]                           base::stop(msg)
[16:14:00.763]                         }
[16:14:00.763]                       })
[16:14:00.763]                     }
[16:14:00.763]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:00.763]                     base::options(mc.cores = 1L)
[16:14:00.763]                   }
[16:14:00.763]                   options(future.plan = NULL)
[16:14:00.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:00.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:00.763]                 }
[16:14:00.763]                 ...future.workdir <- getwd()
[16:14:00.763]             }
[16:14:00.763]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:00.763]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:00.763]         }
[16:14:00.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:00.763]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:00.763]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:00.763]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:00.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:00.763]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:00.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:00.763]             base::names(...future.oldOptions))
[16:14:00.763]     }
[16:14:00.763]     if (FALSE) {
[16:14:00.763]     }
[16:14:00.763]     else {
[16:14:00.763]         if (TRUE) {
[16:14:00.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:00.763]                 open = "w")
[16:14:00.763]         }
[16:14:00.763]         else {
[16:14:00.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:00.763]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:00.763]         }
[16:14:00.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:00.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:00.763]             base::sink(type = "output", split = FALSE)
[16:14:00.763]             base::close(...future.stdout)
[16:14:00.763]         }, add = TRUE)
[16:14:00.763]     }
[16:14:00.763]     ...future.frame <- base::sys.nframe()
[16:14:00.763]     ...future.conditions <- base::list()
[16:14:00.763]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:00.763]     if (FALSE) {
[16:14:00.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:00.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:00.763]     }
[16:14:00.763]     ...future.result <- base::tryCatch({
[16:14:00.763]         base::withCallingHandlers({
[16:14:00.763]             ...future.value <- base::withVisible(base::local({
[16:14:00.763]                 ...future.makeSendCondition <- local({
[16:14:00.763]                   sendCondition <- NULL
[16:14:00.763]                   function(frame = 1L) {
[16:14:00.763]                     if (is.function(sendCondition)) 
[16:14:00.763]                       return(sendCondition)
[16:14:00.763]                     ns <- getNamespace("parallel")
[16:14:00.763]                     if (exists("sendData", mode = "function", 
[16:14:00.763]                       envir = ns)) {
[16:14:00.763]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:00.763]                         envir = ns)
[16:14:00.763]                       envir <- sys.frame(frame)
[16:14:00.763]                       master <- NULL
[16:14:00.763]                       while (!identical(envir, .GlobalEnv) && 
[16:14:00.763]                         !identical(envir, emptyenv())) {
[16:14:00.763]                         if (exists("master", mode = "list", envir = envir, 
[16:14:00.763]                           inherits = FALSE)) {
[16:14:00.763]                           master <- get("master", mode = "list", 
[16:14:00.763]                             envir = envir, inherits = FALSE)
[16:14:00.763]                           if (inherits(master, c("SOCKnode", 
[16:14:00.763]                             "SOCK0node"))) {
[16:14:00.763]                             sendCondition <<- function(cond) {
[16:14:00.763]                               data <- list(type = "VALUE", value = cond, 
[16:14:00.763]                                 success = TRUE)
[16:14:00.763]                               parallel_sendData(master, data)
[16:14:00.763]                             }
[16:14:00.763]                             return(sendCondition)
[16:14:00.763]                           }
[16:14:00.763]                         }
[16:14:00.763]                         frame <- frame + 1L
[16:14:00.763]                         envir <- sys.frame(frame)
[16:14:00.763]                       }
[16:14:00.763]                     }
[16:14:00.763]                     sendCondition <<- function(cond) NULL
[16:14:00.763]                   }
[16:14:00.763]                 })
[16:14:00.763]                 withCallingHandlers({
[16:14:00.763]                   {
[16:14:00.763]                     Sys.sleep(0.1)
[16:14:00.763]                     kk
[16:14:00.763]                   }
[16:14:00.763]                 }, immediateCondition = function(cond) {
[16:14:00.763]                   sendCondition <- ...future.makeSendCondition()
[16:14:00.763]                   sendCondition(cond)
[16:14:00.763]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:00.763]                   {
[16:14:00.763]                     inherits <- base::inherits
[16:14:00.763]                     invokeRestart <- base::invokeRestart
[16:14:00.763]                     is.null <- base::is.null
[16:14:00.763]                     muffled <- FALSE
[16:14:00.763]                     if (inherits(cond, "message")) {
[16:14:00.763]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:00.763]                       if (muffled) 
[16:14:00.763]                         invokeRestart("muffleMessage")
[16:14:00.763]                     }
[16:14:00.763]                     else if (inherits(cond, "warning")) {
[16:14:00.763]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:00.763]                       if (muffled) 
[16:14:00.763]                         invokeRestart("muffleWarning")
[16:14:00.763]                     }
[16:14:00.763]                     else if (inherits(cond, "condition")) {
[16:14:00.763]                       if (!is.null(pattern)) {
[16:14:00.763]                         computeRestarts <- base::computeRestarts
[16:14:00.763]                         grepl <- base::grepl
[16:14:00.763]                         restarts <- computeRestarts(cond)
[16:14:00.763]                         for (restart in restarts) {
[16:14:00.763]                           name <- restart$name
[16:14:00.763]                           if (is.null(name)) 
[16:14:00.763]                             next
[16:14:00.763]                           if (!grepl(pattern, name)) 
[16:14:00.763]                             next
[16:14:00.763]                           invokeRestart(restart)
[16:14:00.763]                           muffled <- TRUE
[16:14:00.763]                           break
[16:14:00.763]                         }
[16:14:00.763]                       }
[16:14:00.763]                     }
[16:14:00.763]                     invisible(muffled)
[16:14:00.763]                   }
[16:14:00.763]                   muffleCondition(cond)
[16:14:00.763]                 })
[16:14:00.763]             }))
[16:14:00.763]             future::FutureResult(value = ...future.value$value, 
[16:14:00.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:00.763]                   ...future.rng), globalenv = if (FALSE) 
[16:14:00.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:00.763]                     ...future.globalenv.names))
[16:14:00.763]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:00.763]         }, condition = base::local({
[16:14:00.763]             c <- base::c
[16:14:00.763]             inherits <- base::inherits
[16:14:00.763]             invokeRestart <- base::invokeRestart
[16:14:00.763]             length <- base::length
[16:14:00.763]             list <- base::list
[16:14:00.763]             seq.int <- base::seq.int
[16:14:00.763]             signalCondition <- base::signalCondition
[16:14:00.763]             sys.calls <- base::sys.calls
[16:14:00.763]             `[[` <- base::`[[`
[16:14:00.763]             `+` <- base::`+`
[16:14:00.763]             `<<-` <- base::`<<-`
[16:14:00.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:00.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:00.763]                   3L)]
[16:14:00.763]             }
[16:14:00.763]             function(cond) {
[16:14:00.763]                 is_error <- inherits(cond, "error")
[16:14:00.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:00.763]                   NULL)
[16:14:00.763]                 if (is_error) {
[16:14:00.763]                   sessionInformation <- function() {
[16:14:00.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:00.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:00.763]                       search = base::search(), system = base::Sys.info())
[16:14:00.763]                   }
[16:14:00.763]                   ...future.conditions[[length(...future.conditions) + 
[16:14:00.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:00.763]                     cond$call), session = sessionInformation(), 
[16:14:00.763]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:00.763]                   signalCondition(cond)
[16:14:00.763]                 }
[16:14:00.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:00.763]                 "immediateCondition"))) {
[16:14:00.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:00.763]                   ...future.conditions[[length(...future.conditions) + 
[16:14:00.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:00.763]                   if (TRUE && !signal) {
[16:14:00.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:00.763]                     {
[16:14:00.763]                       inherits <- base::inherits
[16:14:00.763]                       invokeRestart <- base::invokeRestart
[16:14:00.763]                       is.null <- base::is.null
[16:14:00.763]                       muffled <- FALSE
[16:14:00.763]                       if (inherits(cond, "message")) {
[16:14:00.763]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:00.763]                         if (muffled) 
[16:14:00.763]                           invokeRestart("muffleMessage")
[16:14:00.763]                       }
[16:14:00.763]                       else if (inherits(cond, "warning")) {
[16:14:00.763]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:00.763]                         if (muffled) 
[16:14:00.763]                           invokeRestart("muffleWarning")
[16:14:00.763]                       }
[16:14:00.763]                       else if (inherits(cond, "condition")) {
[16:14:00.763]                         if (!is.null(pattern)) {
[16:14:00.763]                           computeRestarts <- base::computeRestarts
[16:14:00.763]                           grepl <- base::grepl
[16:14:00.763]                           restarts <- computeRestarts(cond)
[16:14:00.763]                           for (restart in restarts) {
[16:14:00.763]                             name <- restart$name
[16:14:00.763]                             if (is.null(name)) 
[16:14:00.763]                               next
[16:14:00.763]                             if (!grepl(pattern, name)) 
[16:14:00.763]                               next
[16:14:00.763]                             invokeRestart(restart)
[16:14:00.763]                             muffled <- TRUE
[16:14:00.763]                             break
[16:14:00.763]                           }
[16:14:00.763]                         }
[16:14:00.763]                       }
[16:14:00.763]                       invisible(muffled)
[16:14:00.763]                     }
[16:14:00.763]                     muffleCondition(cond, pattern = "^muffle")
[16:14:00.763]                   }
[16:14:00.763]                 }
[16:14:00.763]                 else {
[16:14:00.763]                   if (TRUE) {
[16:14:00.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:00.763]                     {
[16:14:00.763]                       inherits <- base::inherits
[16:14:00.763]                       invokeRestart <- base::invokeRestart
[16:14:00.763]                       is.null <- base::is.null
[16:14:00.763]                       muffled <- FALSE
[16:14:00.763]                       if (inherits(cond, "message")) {
[16:14:00.763]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:00.763]                         if (muffled) 
[16:14:00.763]                           invokeRestart("muffleMessage")
[16:14:00.763]                       }
[16:14:00.763]                       else if (inherits(cond, "warning")) {
[16:14:00.763]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:00.763]                         if (muffled) 
[16:14:00.763]                           invokeRestart("muffleWarning")
[16:14:00.763]                       }
[16:14:00.763]                       else if (inherits(cond, "condition")) {
[16:14:00.763]                         if (!is.null(pattern)) {
[16:14:00.763]                           computeRestarts <- base::computeRestarts
[16:14:00.763]                           grepl <- base::grepl
[16:14:00.763]                           restarts <- computeRestarts(cond)
[16:14:00.763]                           for (restart in restarts) {
[16:14:00.763]                             name <- restart$name
[16:14:00.763]                             if (is.null(name)) 
[16:14:00.763]                               next
[16:14:00.763]                             if (!grepl(pattern, name)) 
[16:14:00.763]                               next
[16:14:00.763]                             invokeRestart(restart)
[16:14:00.763]                             muffled <- TRUE
[16:14:00.763]                             break
[16:14:00.763]                           }
[16:14:00.763]                         }
[16:14:00.763]                       }
[16:14:00.763]                       invisible(muffled)
[16:14:00.763]                     }
[16:14:00.763]                     muffleCondition(cond, pattern = "^muffle")
[16:14:00.763]                   }
[16:14:00.763]                 }
[16:14:00.763]             }
[16:14:00.763]         }))
[16:14:00.763]     }, error = function(ex) {
[16:14:00.763]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:00.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:00.763]                 ...future.rng), started = ...future.startTime, 
[16:14:00.763]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:00.763]             version = "1.8"), class = "FutureResult")
[16:14:00.763]     }, finally = {
[16:14:00.763]         if (!identical(...future.workdir, getwd())) 
[16:14:00.763]             setwd(...future.workdir)
[16:14:00.763]         {
[16:14:00.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:00.763]                 ...future.oldOptions$nwarnings <- NULL
[16:14:00.763]             }
[16:14:00.763]             base::options(...future.oldOptions)
[16:14:00.763]             if (.Platform$OS.type == "windows") {
[16:14:00.763]                 old_names <- names(...future.oldEnvVars)
[16:14:00.763]                 envs <- base::Sys.getenv()
[16:14:00.763]                 names <- names(envs)
[16:14:00.763]                 common <- intersect(names, old_names)
[16:14:00.763]                 added <- setdiff(names, old_names)
[16:14:00.763]                 removed <- setdiff(old_names, names)
[16:14:00.763]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:00.763]                   envs[common]]
[16:14:00.763]                 NAMES <- toupper(changed)
[16:14:00.763]                 args <- list()
[16:14:00.763]                 for (kk in seq_along(NAMES)) {
[16:14:00.763]                   name <- changed[[kk]]
[16:14:00.763]                   NAME <- NAMES[[kk]]
[16:14:00.763]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:00.763]                     next
[16:14:00.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:00.763]                 }
[16:14:00.763]                 NAMES <- toupper(added)
[16:14:00.763]                 for (kk in seq_along(NAMES)) {
[16:14:00.763]                   name <- added[[kk]]
[16:14:00.763]                   NAME <- NAMES[[kk]]
[16:14:00.763]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:00.763]                     next
[16:14:00.763]                   args[[name]] <- ""
[16:14:00.763]                 }
[16:14:00.763]                 NAMES <- toupper(removed)
[16:14:00.763]                 for (kk in seq_along(NAMES)) {
[16:14:00.763]                   name <- removed[[kk]]
[16:14:00.763]                   NAME <- NAMES[[kk]]
[16:14:00.763]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:00.763]                     next
[16:14:00.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:00.763]                 }
[16:14:00.763]                 if (length(args) > 0) 
[16:14:00.763]                   base::do.call(base::Sys.setenv, args = args)
[16:14:00.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:00.763]             }
[16:14:00.763]             else {
[16:14:00.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:00.763]             }
[16:14:00.763]             {
[16:14:00.763]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:00.763]                   0L) {
[16:14:00.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:00.763]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:00.763]                   base::options(opts)
[16:14:00.763]                 }
[16:14:00.763]                 {
[16:14:00.763]                   {
[16:14:00.763]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:00.763]                     NULL
[16:14:00.763]                   }
[16:14:00.763]                   options(future.plan = NULL)
[16:14:00.763]                   if (is.na(NA_character_)) 
[16:14:00.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:00.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:00.763]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:00.763]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:00.763]                     envir = parent.frame()) 
[16:14:00.763]                   {
[16:14:00.763]                     if (is.function(workers)) 
[16:14:00.763]                       workers <- workers()
[16:14:00.763]                     workers <- structure(as.integer(workers), 
[16:14:00.763]                       class = class(workers))
[16:14:00.763]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:00.763]                       workers >= 1)
[16:14:00.763]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:00.763]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:00.763]                     }
[16:14:00.763]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:00.763]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:00.763]                       envir = envir)
[16:14:00.763]                     if (!future$lazy) 
[16:14:00.763]                       future <- run(future)
[16:14:00.763]                     invisible(future)
[16:14:00.763]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:00.763]                 }
[16:14:00.763]             }
[16:14:00.763]         }
[16:14:00.763]     })
[16:14:00.763]     if (TRUE) {
[16:14:00.763]         base::sink(type = "output", split = FALSE)
[16:14:00.763]         if (TRUE) {
[16:14:00.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:00.763]         }
[16:14:00.763]         else {
[16:14:00.763]             ...future.result["stdout"] <- base::list(NULL)
[16:14:00.763]         }
[16:14:00.763]         base::close(...future.stdout)
[16:14:00.763]         ...future.stdout <- NULL
[16:14:00.763]     }
[16:14:00.763]     ...future.result$conditions <- ...future.conditions
[16:14:00.763]     ...future.result$finished <- base::Sys.time()
[16:14:00.763]     ...future.result
[16:14:00.763] }
[16:14:00.765] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:14:00.766] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[16:14:00.766] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[16:14:00.766] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:14:00.767] MultisessionFuture started
[16:14:00.767] - Launch lazy future ... done
[16:14:00.767] run() for ‘MultisessionFuture’ ... done
[16:14:00.777] run() for ‘Future’ ...
[16:14:00.778] - state: ‘created’
[16:14:00.778] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:00.792] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:00.792] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:00.792]   - Field: ‘node’
[16:14:00.792]   - Field: ‘label’
[16:14:00.792]   - Field: ‘local’
[16:14:00.792]   - Field: ‘owner’
[16:14:00.792]   - Field: ‘envir’
[16:14:00.792]   - Field: ‘workers’
[16:14:00.793]   - Field: ‘packages’
[16:14:00.793]   - Field: ‘gc’
[16:14:00.793]   - Field: ‘conditions’
[16:14:00.793]   - Field: ‘persistent’
[16:14:00.793]   - Field: ‘expr’
[16:14:00.793]   - Field: ‘uuid’
[16:14:00.793]   - Field: ‘seed’
[16:14:00.793]   - Field: ‘version’
[16:14:00.793]   - Field: ‘result’
[16:14:00.793]   - Field: ‘asynchronous’
[16:14:00.793]   - Field: ‘calls’
[16:14:00.794]   - Field: ‘globals’
[16:14:00.794]   - Field: ‘stdout’
[16:14:00.794]   - Field: ‘earlySignal’
[16:14:00.794]   - Field: ‘lazy’
[16:14:00.794]   - Field: ‘state’
[16:14:00.794] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:00.794] - Launch lazy future ...
[16:14:00.794] Packages needed by the future expression (n = 0): <none>
[16:14:00.794] Packages needed by future strategies (n = 0): <none>
[16:14:00.795] {
[16:14:00.795]     {
[16:14:00.795]         {
[16:14:00.795]             ...future.startTime <- base::Sys.time()
[16:14:00.795]             {
[16:14:00.795]                 {
[16:14:00.795]                   {
[16:14:00.795]                     {
[16:14:00.795]                       base::local({
[16:14:00.795]                         has_future <- base::requireNamespace("future", 
[16:14:00.795]                           quietly = TRUE)
[16:14:00.795]                         if (has_future) {
[16:14:00.795]                           ns <- base::getNamespace("future")
[16:14:00.795]                           version <- ns[[".package"]][["version"]]
[16:14:00.795]                           if (is.null(version)) 
[16:14:00.795]                             version <- utils::packageVersion("future")
[16:14:00.795]                         }
[16:14:00.795]                         else {
[16:14:00.795]                           version <- NULL
[16:14:00.795]                         }
[16:14:00.795]                         if (!has_future || version < "1.8.0") {
[16:14:00.795]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:00.795]                             "", base::R.version$version.string), 
[16:14:00.795]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:00.795]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:00.795]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:00.795]                               "release", "version")], collapse = " "), 
[16:14:00.795]                             hostname = base::Sys.info()[["nodename"]])
[16:14:00.795]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:00.795]                             info)
[16:14:00.795]                           info <- base::paste(info, collapse = "; ")
[16:14:00.795]                           if (!has_future) {
[16:14:00.795]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:00.795]                               info)
[16:14:00.795]                           }
[16:14:00.795]                           else {
[16:14:00.795]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:00.795]                               info, version)
[16:14:00.795]                           }
[16:14:00.795]                           base::stop(msg)
[16:14:00.795]                         }
[16:14:00.795]                       })
[16:14:00.795]                     }
[16:14:00.795]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:00.795]                     base::options(mc.cores = 1L)
[16:14:00.795]                   }
[16:14:00.795]                   options(future.plan = NULL)
[16:14:00.795]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:00.795]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:00.795]                 }
[16:14:00.795]                 ...future.workdir <- getwd()
[16:14:00.795]             }
[16:14:00.795]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:00.795]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:00.795]         }
[16:14:00.795]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:00.795]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:00.795]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:00.795]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:00.795]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:00.795]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:00.795]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:00.795]             base::names(...future.oldOptions))
[16:14:00.795]     }
[16:14:00.795]     if (FALSE) {
[16:14:00.795]     }
[16:14:00.795]     else {
[16:14:00.795]         if (TRUE) {
[16:14:00.795]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:00.795]                 open = "w")
[16:14:00.795]         }
[16:14:00.795]         else {
[16:14:00.795]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:00.795]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:00.795]         }
[16:14:00.795]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:00.795]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:00.795]             base::sink(type = "output", split = FALSE)
[16:14:00.795]             base::close(...future.stdout)
[16:14:00.795]         }, add = TRUE)
[16:14:00.795]     }
[16:14:00.795]     ...future.frame <- base::sys.nframe()
[16:14:00.795]     ...future.conditions <- base::list()
[16:14:00.795]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:00.795]     if (FALSE) {
[16:14:00.795]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:00.795]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:00.795]     }
[16:14:00.795]     ...future.result <- base::tryCatch({
[16:14:00.795]         base::withCallingHandlers({
[16:14:00.795]             ...future.value <- base::withVisible(base::local({
[16:14:00.795]                 ...future.makeSendCondition <- local({
[16:14:00.795]                   sendCondition <- NULL
[16:14:00.795]                   function(frame = 1L) {
[16:14:00.795]                     if (is.function(sendCondition)) 
[16:14:00.795]                       return(sendCondition)
[16:14:00.795]                     ns <- getNamespace("parallel")
[16:14:00.795]                     if (exists("sendData", mode = "function", 
[16:14:00.795]                       envir = ns)) {
[16:14:00.795]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:00.795]                         envir = ns)
[16:14:00.795]                       envir <- sys.frame(frame)
[16:14:00.795]                       master <- NULL
[16:14:00.795]                       while (!identical(envir, .GlobalEnv) && 
[16:14:00.795]                         !identical(envir, emptyenv())) {
[16:14:00.795]                         if (exists("master", mode = "list", envir = envir, 
[16:14:00.795]                           inherits = FALSE)) {
[16:14:00.795]                           master <- get("master", mode = "list", 
[16:14:00.795]                             envir = envir, inherits = FALSE)
[16:14:00.795]                           if (inherits(master, c("SOCKnode", 
[16:14:00.795]                             "SOCK0node"))) {
[16:14:00.795]                             sendCondition <<- function(cond) {
[16:14:00.795]                               data <- list(type = "VALUE", value = cond, 
[16:14:00.795]                                 success = TRUE)
[16:14:00.795]                               parallel_sendData(master, data)
[16:14:00.795]                             }
[16:14:00.795]                             return(sendCondition)
[16:14:00.795]                           }
[16:14:00.795]                         }
[16:14:00.795]                         frame <- frame + 1L
[16:14:00.795]                         envir <- sys.frame(frame)
[16:14:00.795]                       }
[16:14:00.795]                     }
[16:14:00.795]                     sendCondition <<- function(cond) NULL
[16:14:00.795]                   }
[16:14:00.795]                 })
[16:14:00.795]                 withCallingHandlers({
[16:14:00.795]                   {
[16:14:00.795]                     Sys.sleep(0.1)
[16:14:00.795]                     kk
[16:14:00.795]                   }
[16:14:00.795]                 }, immediateCondition = function(cond) {
[16:14:00.795]                   sendCondition <- ...future.makeSendCondition()
[16:14:00.795]                   sendCondition(cond)
[16:14:00.795]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:00.795]                   {
[16:14:00.795]                     inherits <- base::inherits
[16:14:00.795]                     invokeRestart <- base::invokeRestart
[16:14:00.795]                     is.null <- base::is.null
[16:14:00.795]                     muffled <- FALSE
[16:14:00.795]                     if (inherits(cond, "message")) {
[16:14:00.795]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:00.795]                       if (muffled) 
[16:14:00.795]                         invokeRestart("muffleMessage")
[16:14:00.795]                     }
[16:14:00.795]                     else if (inherits(cond, "warning")) {
[16:14:00.795]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:00.795]                       if (muffled) 
[16:14:00.795]                         invokeRestart("muffleWarning")
[16:14:00.795]                     }
[16:14:00.795]                     else if (inherits(cond, "condition")) {
[16:14:00.795]                       if (!is.null(pattern)) {
[16:14:00.795]                         computeRestarts <- base::computeRestarts
[16:14:00.795]                         grepl <- base::grepl
[16:14:00.795]                         restarts <- computeRestarts(cond)
[16:14:00.795]                         for (restart in restarts) {
[16:14:00.795]                           name <- restart$name
[16:14:00.795]                           if (is.null(name)) 
[16:14:00.795]                             next
[16:14:00.795]                           if (!grepl(pattern, name)) 
[16:14:00.795]                             next
[16:14:00.795]                           invokeRestart(restart)
[16:14:00.795]                           muffled <- TRUE
[16:14:00.795]                           break
[16:14:00.795]                         }
[16:14:00.795]                       }
[16:14:00.795]                     }
[16:14:00.795]                     invisible(muffled)
[16:14:00.795]                   }
[16:14:00.795]                   muffleCondition(cond)
[16:14:00.795]                 })
[16:14:00.795]             }))
[16:14:00.795]             future::FutureResult(value = ...future.value$value, 
[16:14:00.795]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:00.795]                   ...future.rng), globalenv = if (FALSE) 
[16:14:00.795]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:00.795]                     ...future.globalenv.names))
[16:14:00.795]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:00.795]         }, condition = base::local({
[16:14:00.795]             c <- base::c
[16:14:00.795]             inherits <- base::inherits
[16:14:00.795]             invokeRestart <- base::invokeRestart
[16:14:00.795]             length <- base::length
[16:14:00.795]             list <- base::list
[16:14:00.795]             seq.int <- base::seq.int
[16:14:00.795]             signalCondition <- base::signalCondition
[16:14:00.795]             sys.calls <- base::sys.calls
[16:14:00.795]             `[[` <- base::`[[`
[16:14:00.795]             `+` <- base::`+`
[16:14:00.795]             `<<-` <- base::`<<-`
[16:14:00.795]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:00.795]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:00.795]                   3L)]
[16:14:00.795]             }
[16:14:00.795]             function(cond) {
[16:14:00.795]                 is_error <- inherits(cond, "error")
[16:14:00.795]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:00.795]                   NULL)
[16:14:00.795]                 if (is_error) {
[16:14:00.795]                   sessionInformation <- function() {
[16:14:00.795]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:00.795]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:00.795]                       search = base::search(), system = base::Sys.info())
[16:14:00.795]                   }
[16:14:00.795]                   ...future.conditions[[length(...future.conditions) + 
[16:14:00.795]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:00.795]                     cond$call), session = sessionInformation(), 
[16:14:00.795]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:00.795]                   signalCondition(cond)
[16:14:00.795]                 }
[16:14:00.795]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:00.795]                 "immediateCondition"))) {
[16:14:00.795]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:00.795]                   ...future.conditions[[length(...future.conditions) + 
[16:14:00.795]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:00.795]                   if (TRUE && !signal) {
[16:14:00.795]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:00.795]                     {
[16:14:00.795]                       inherits <- base::inherits
[16:14:00.795]                       invokeRestart <- base::invokeRestart
[16:14:00.795]                       is.null <- base::is.null
[16:14:00.795]                       muffled <- FALSE
[16:14:00.795]                       if (inherits(cond, "message")) {
[16:14:00.795]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:00.795]                         if (muffled) 
[16:14:00.795]                           invokeRestart("muffleMessage")
[16:14:00.795]                       }
[16:14:00.795]                       else if (inherits(cond, "warning")) {
[16:14:00.795]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:00.795]                         if (muffled) 
[16:14:00.795]                           invokeRestart("muffleWarning")
[16:14:00.795]                       }
[16:14:00.795]                       else if (inherits(cond, "condition")) {
[16:14:00.795]                         if (!is.null(pattern)) {
[16:14:00.795]                           computeRestarts <- base::computeRestarts
[16:14:00.795]                           grepl <- base::grepl
[16:14:00.795]                           restarts <- computeRestarts(cond)
[16:14:00.795]                           for (restart in restarts) {
[16:14:00.795]                             name <- restart$name
[16:14:00.795]                             if (is.null(name)) 
[16:14:00.795]                               next
[16:14:00.795]                             if (!grepl(pattern, name)) 
[16:14:00.795]                               next
[16:14:00.795]                             invokeRestart(restart)
[16:14:00.795]                             muffled <- TRUE
[16:14:00.795]                             break
[16:14:00.795]                           }
[16:14:00.795]                         }
[16:14:00.795]                       }
[16:14:00.795]                       invisible(muffled)
[16:14:00.795]                     }
[16:14:00.795]                     muffleCondition(cond, pattern = "^muffle")
[16:14:00.795]                   }
[16:14:00.795]                 }
[16:14:00.795]                 else {
[16:14:00.795]                   if (TRUE) {
[16:14:00.795]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:00.795]                     {
[16:14:00.795]                       inherits <- base::inherits
[16:14:00.795]                       invokeRestart <- base::invokeRestart
[16:14:00.795]                       is.null <- base::is.null
[16:14:00.795]                       muffled <- FALSE
[16:14:00.795]                       if (inherits(cond, "message")) {
[16:14:00.795]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:00.795]                         if (muffled) 
[16:14:00.795]                           invokeRestart("muffleMessage")
[16:14:00.795]                       }
[16:14:00.795]                       else if (inherits(cond, "warning")) {
[16:14:00.795]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:00.795]                         if (muffled) 
[16:14:00.795]                           invokeRestart("muffleWarning")
[16:14:00.795]                       }
[16:14:00.795]                       else if (inherits(cond, "condition")) {
[16:14:00.795]                         if (!is.null(pattern)) {
[16:14:00.795]                           computeRestarts <- base::computeRestarts
[16:14:00.795]                           grepl <- base::grepl
[16:14:00.795]                           restarts <- computeRestarts(cond)
[16:14:00.795]                           for (restart in restarts) {
[16:14:00.795]                             name <- restart$name
[16:14:00.795]                             if (is.null(name)) 
[16:14:00.795]                               next
[16:14:00.795]                             if (!grepl(pattern, name)) 
[16:14:00.795]                               next
[16:14:00.795]                             invokeRestart(restart)
[16:14:00.795]                             muffled <- TRUE
[16:14:00.795]                             break
[16:14:00.795]                           }
[16:14:00.795]                         }
[16:14:00.795]                       }
[16:14:00.795]                       invisible(muffled)
[16:14:00.795]                     }
[16:14:00.795]                     muffleCondition(cond, pattern = "^muffle")
[16:14:00.795]                   }
[16:14:00.795]                 }
[16:14:00.795]             }
[16:14:00.795]         }))
[16:14:00.795]     }, error = function(ex) {
[16:14:00.795]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:00.795]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:00.795]                 ...future.rng), started = ...future.startTime, 
[16:14:00.795]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:00.795]             version = "1.8"), class = "FutureResult")
[16:14:00.795]     }, finally = {
[16:14:00.795]         if (!identical(...future.workdir, getwd())) 
[16:14:00.795]             setwd(...future.workdir)
[16:14:00.795]         {
[16:14:00.795]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:00.795]                 ...future.oldOptions$nwarnings <- NULL
[16:14:00.795]             }
[16:14:00.795]             base::options(...future.oldOptions)
[16:14:00.795]             if (.Platform$OS.type == "windows") {
[16:14:00.795]                 old_names <- names(...future.oldEnvVars)
[16:14:00.795]                 envs <- base::Sys.getenv()
[16:14:00.795]                 names <- names(envs)
[16:14:00.795]                 common <- intersect(names, old_names)
[16:14:00.795]                 added <- setdiff(names, old_names)
[16:14:00.795]                 removed <- setdiff(old_names, names)
[16:14:00.795]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:00.795]                   envs[common]]
[16:14:00.795]                 NAMES <- toupper(changed)
[16:14:00.795]                 args <- list()
[16:14:00.795]                 for (kk in seq_along(NAMES)) {
[16:14:00.795]                   name <- changed[[kk]]
[16:14:00.795]                   NAME <- NAMES[[kk]]
[16:14:00.795]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:00.795]                     next
[16:14:00.795]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:00.795]                 }
[16:14:00.795]                 NAMES <- toupper(added)
[16:14:00.795]                 for (kk in seq_along(NAMES)) {
[16:14:00.795]                   name <- added[[kk]]
[16:14:00.795]                   NAME <- NAMES[[kk]]
[16:14:00.795]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:00.795]                     next
[16:14:00.795]                   args[[name]] <- ""
[16:14:00.795]                 }
[16:14:00.795]                 NAMES <- toupper(removed)
[16:14:00.795]                 for (kk in seq_along(NAMES)) {
[16:14:00.795]                   name <- removed[[kk]]
[16:14:00.795]                   NAME <- NAMES[[kk]]
[16:14:00.795]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:00.795]                     next
[16:14:00.795]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:00.795]                 }
[16:14:00.795]                 if (length(args) > 0) 
[16:14:00.795]                   base::do.call(base::Sys.setenv, args = args)
[16:14:00.795]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:00.795]             }
[16:14:00.795]             else {
[16:14:00.795]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:00.795]             }
[16:14:00.795]             {
[16:14:00.795]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:00.795]                   0L) {
[16:14:00.795]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:00.795]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:00.795]                   base::options(opts)
[16:14:00.795]                 }
[16:14:00.795]                 {
[16:14:00.795]                   {
[16:14:00.795]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:00.795]                     NULL
[16:14:00.795]                   }
[16:14:00.795]                   options(future.plan = NULL)
[16:14:00.795]                   if (is.na(NA_character_)) 
[16:14:00.795]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:00.795]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:00.795]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:00.795]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:00.795]                     envir = parent.frame()) 
[16:14:00.795]                   {
[16:14:00.795]                     if (is.function(workers)) 
[16:14:00.795]                       workers <- workers()
[16:14:00.795]                     workers <- structure(as.integer(workers), 
[16:14:00.795]                       class = class(workers))
[16:14:00.795]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:00.795]                       workers >= 1)
[16:14:00.795]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:00.795]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:00.795]                     }
[16:14:00.795]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:00.795]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:00.795]                       envir = envir)
[16:14:00.795]                     if (!future$lazy) 
[16:14:00.795]                       future <- run(future)
[16:14:00.795]                     invisible(future)
[16:14:00.795]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:00.795]                 }
[16:14:00.795]             }
[16:14:00.795]         }
[16:14:00.795]     })
[16:14:00.795]     if (TRUE) {
[16:14:00.795]         base::sink(type = "output", split = FALSE)
[16:14:00.795]         if (TRUE) {
[16:14:00.795]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:00.795]         }
[16:14:00.795]         else {
[16:14:00.795]             ...future.result["stdout"] <- base::list(NULL)
[16:14:00.795]         }
[16:14:00.795]         base::close(...future.stdout)
[16:14:00.795]         ...future.stdout <- NULL
[16:14:00.795]     }
[16:14:00.795]     ...future.result$conditions <- ...future.conditions
[16:14:00.795]     ...future.result$finished <- base::Sys.time()
[16:14:00.795]     ...future.result
[16:14:00.795] }
[16:14:00.798] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[16:14:00.798] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[16:14:00.798] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[16:14:00.798] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[16:14:00.799] MultisessionFuture started
[16:14:00.799] - Launch lazy future ... done
[16:14:00.799] run() for ‘MultisessionFuture’ ... done
[16:14:00.810] run() for ‘Future’ ...
[16:14:00.810] - state: ‘created’
[16:14:00.810] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:00.824] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:00.824] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:00.824]   - Field: ‘node’
[16:14:00.824]   - Field: ‘label’
[16:14:00.824]   - Field: ‘local’
[16:14:00.824]   - Field: ‘owner’
[16:14:00.825]   - Field: ‘envir’
[16:14:00.825]   - Field: ‘workers’
[16:14:00.825]   - Field: ‘packages’
[16:14:00.825]   - Field: ‘gc’
[16:14:00.825]   - Field: ‘conditions’
[16:14:00.825]   - Field: ‘persistent’
[16:14:00.825]   - Field: ‘expr’
[16:14:00.825]   - Field: ‘uuid’
[16:14:00.825]   - Field: ‘seed’
[16:14:00.825]   - Field: ‘version’
[16:14:00.825]   - Field: ‘result’
[16:14:00.826]   - Field: ‘asynchronous’
[16:14:00.826]   - Field: ‘calls’
[16:14:00.826]   - Field: ‘globals’
[16:14:00.826]   - Field: ‘stdout’
[16:14:00.826]   - Field: ‘earlySignal’
[16:14:00.826]   - Field: ‘lazy’
[16:14:00.826]   - Field: ‘state’
[16:14:00.826] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:00.826] - Launch lazy future ...
[16:14:00.827] Packages needed by the future expression (n = 0): <none>
[16:14:00.827] Packages needed by future strategies (n = 0): <none>
[16:14:00.827] {
[16:14:00.827]     {
[16:14:00.827]         {
[16:14:00.827]             ...future.startTime <- base::Sys.time()
[16:14:00.827]             {
[16:14:00.827]                 {
[16:14:00.827]                   {
[16:14:00.827]                     {
[16:14:00.827]                       base::local({
[16:14:00.827]                         has_future <- base::requireNamespace("future", 
[16:14:00.827]                           quietly = TRUE)
[16:14:00.827]                         if (has_future) {
[16:14:00.827]                           ns <- base::getNamespace("future")
[16:14:00.827]                           version <- ns[[".package"]][["version"]]
[16:14:00.827]                           if (is.null(version)) 
[16:14:00.827]                             version <- utils::packageVersion("future")
[16:14:00.827]                         }
[16:14:00.827]                         else {
[16:14:00.827]                           version <- NULL
[16:14:00.827]                         }
[16:14:00.827]                         if (!has_future || version < "1.8.0") {
[16:14:00.827]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:00.827]                             "", base::R.version$version.string), 
[16:14:00.827]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:00.827]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:00.827]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:00.827]                               "release", "version")], collapse = " "), 
[16:14:00.827]                             hostname = base::Sys.info()[["nodename"]])
[16:14:00.827]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:00.827]                             info)
[16:14:00.827]                           info <- base::paste(info, collapse = "; ")
[16:14:00.827]                           if (!has_future) {
[16:14:00.827]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:00.827]                               info)
[16:14:00.827]                           }
[16:14:00.827]                           else {
[16:14:00.827]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:00.827]                               info, version)
[16:14:00.827]                           }
[16:14:00.827]                           base::stop(msg)
[16:14:00.827]                         }
[16:14:00.827]                       })
[16:14:00.827]                     }
[16:14:00.827]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:00.827]                     base::options(mc.cores = 1L)
[16:14:00.827]                   }
[16:14:00.827]                   options(future.plan = NULL)
[16:14:00.827]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:00.827]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:00.827]                 }
[16:14:00.827]                 ...future.workdir <- getwd()
[16:14:00.827]             }
[16:14:00.827]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:00.827]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:00.827]         }
[16:14:00.827]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:00.827]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:00.827]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:00.827]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:00.827]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:00.827]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:00.827]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:00.827]             base::names(...future.oldOptions))
[16:14:00.827]     }
[16:14:00.827]     if (FALSE) {
[16:14:00.827]     }
[16:14:00.827]     else {
[16:14:00.827]         if (TRUE) {
[16:14:00.827]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:00.827]                 open = "w")
[16:14:00.827]         }
[16:14:00.827]         else {
[16:14:00.827]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:00.827]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:00.827]         }
[16:14:00.827]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:00.827]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:00.827]             base::sink(type = "output", split = FALSE)
[16:14:00.827]             base::close(...future.stdout)
[16:14:00.827]         }, add = TRUE)
[16:14:00.827]     }
[16:14:00.827]     ...future.frame <- base::sys.nframe()
[16:14:00.827]     ...future.conditions <- base::list()
[16:14:00.827]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:00.827]     if (FALSE) {
[16:14:00.827]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:00.827]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:00.827]     }
[16:14:00.827]     ...future.result <- base::tryCatch({
[16:14:00.827]         base::withCallingHandlers({
[16:14:00.827]             ...future.value <- base::withVisible(base::local({
[16:14:00.827]                 ...future.makeSendCondition <- local({
[16:14:00.827]                   sendCondition <- NULL
[16:14:00.827]                   function(frame = 1L) {
[16:14:00.827]                     if (is.function(sendCondition)) 
[16:14:00.827]                       return(sendCondition)
[16:14:00.827]                     ns <- getNamespace("parallel")
[16:14:00.827]                     if (exists("sendData", mode = "function", 
[16:14:00.827]                       envir = ns)) {
[16:14:00.827]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:00.827]                         envir = ns)
[16:14:00.827]                       envir <- sys.frame(frame)
[16:14:00.827]                       master <- NULL
[16:14:00.827]                       while (!identical(envir, .GlobalEnv) && 
[16:14:00.827]                         !identical(envir, emptyenv())) {
[16:14:00.827]                         if (exists("master", mode = "list", envir = envir, 
[16:14:00.827]                           inherits = FALSE)) {
[16:14:00.827]                           master <- get("master", mode = "list", 
[16:14:00.827]                             envir = envir, inherits = FALSE)
[16:14:00.827]                           if (inherits(master, c("SOCKnode", 
[16:14:00.827]                             "SOCK0node"))) {
[16:14:00.827]                             sendCondition <<- function(cond) {
[16:14:00.827]                               data <- list(type = "VALUE", value = cond, 
[16:14:00.827]                                 success = TRUE)
[16:14:00.827]                               parallel_sendData(master, data)
[16:14:00.827]                             }
[16:14:00.827]                             return(sendCondition)
[16:14:00.827]                           }
[16:14:00.827]                         }
[16:14:00.827]                         frame <- frame + 1L
[16:14:00.827]                         envir <- sys.frame(frame)
[16:14:00.827]                       }
[16:14:00.827]                     }
[16:14:00.827]                     sendCondition <<- function(cond) NULL
[16:14:00.827]                   }
[16:14:00.827]                 })
[16:14:00.827]                 withCallingHandlers({
[16:14:00.827]                   {
[16:14:00.827]                     Sys.sleep(0.1)
[16:14:00.827]                     kk
[16:14:00.827]                   }
[16:14:00.827]                 }, immediateCondition = function(cond) {
[16:14:00.827]                   sendCondition <- ...future.makeSendCondition()
[16:14:00.827]                   sendCondition(cond)
[16:14:00.827]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:00.827]                   {
[16:14:00.827]                     inherits <- base::inherits
[16:14:00.827]                     invokeRestart <- base::invokeRestart
[16:14:00.827]                     is.null <- base::is.null
[16:14:00.827]                     muffled <- FALSE
[16:14:00.827]                     if (inherits(cond, "message")) {
[16:14:00.827]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:00.827]                       if (muffled) 
[16:14:00.827]                         invokeRestart("muffleMessage")
[16:14:00.827]                     }
[16:14:00.827]                     else if (inherits(cond, "warning")) {
[16:14:00.827]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:00.827]                       if (muffled) 
[16:14:00.827]                         invokeRestart("muffleWarning")
[16:14:00.827]                     }
[16:14:00.827]                     else if (inherits(cond, "condition")) {
[16:14:00.827]                       if (!is.null(pattern)) {
[16:14:00.827]                         computeRestarts <- base::computeRestarts
[16:14:00.827]                         grepl <- base::grepl
[16:14:00.827]                         restarts <- computeRestarts(cond)
[16:14:00.827]                         for (restart in restarts) {
[16:14:00.827]                           name <- restart$name
[16:14:00.827]                           if (is.null(name)) 
[16:14:00.827]                             next
[16:14:00.827]                           if (!grepl(pattern, name)) 
[16:14:00.827]                             next
[16:14:00.827]                           invokeRestart(restart)
[16:14:00.827]                           muffled <- TRUE
[16:14:00.827]                           break
[16:14:00.827]                         }
[16:14:00.827]                       }
[16:14:00.827]                     }
[16:14:00.827]                     invisible(muffled)
[16:14:00.827]                   }
[16:14:00.827]                   muffleCondition(cond)
[16:14:00.827]                 })
[16:14:00.827]             }))
[16:14:00.827]             future::FutureResult(value = ...future.value$value, 
[16:14:00.827]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:00.827]                   ...future.rng), globalenv = if (FALSE) 
[16:14:00.827]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:00.827]                     ...future.globalenv.names))
[16:14:00.827]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:00.827]         }, condition = base::local({
[16:14:00.827]             c <- base::c
[16:14:00.827]             inherits <- base::inherits
[16:14:00.827]             invokeRestart <- base::invokeRestart
[16:14:00.827]             length <- base::length
[16:14:00.827]             list <- base::list
[16:14:00.827]             seq.int <- base::seq.int
[16:14:00.827]             signalCondition <- base::signalCondition
[16:14:00.827]             sys.calls <- base::sys.calls
[16:14:00.827]             `[[` <- base::`[[`
[16:14:00.827]             `+` <- base::`+`
[16:14:00.827]             `<<-` <- base::`<<-`
[16:14:00.827]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:00.827]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:00.827]                   3L)]
[16:14:00.827]             }
[16:14:00.827]             function(cond) {
[16:14:00.827]                 is_error <- inherits(cond, "error")
[16:14:00.827]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:00.827]                   NULL)
[16:14:00.827]                 if (is_error) {
[16:14:00.827]                   sessionInformation <- function() {
[16:14:00.827]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:00.827]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:00.827]                       search = base::search(), system = base::Sys.info())
[16:14:00.827]                   }
[16:14:00.827]                   ...future.conditions[[length(...future.conditions) + 
[16:14:00.827]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:00.827]                     cond$call), session = sessionInformation(), 
[16:14:00.827]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:00.827]                   signalCondition(cond)
[16:14:00.827]                 }
[16:14:00.827]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:00.827]                 "immediateCondition"))) {
[16:14:00.827]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:00.827]                   ...future.conditions[[length(...future.conditions) + 
[16:14:00.827]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:00.827]                   if (TRUE && !signal) {
[16:14:00.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:00.827]                     {
[16:14:00.827]                       inherits <- base::inherits
[16:14:00.827]                       invokeRestart <- base::invokeRestart
[16:14:00.827]                       is.null <- base::is.null
[16:14:00.827]                       muffled <- FALSE
[16:14:00.827]                       if (inherits(cond, "message")) {
[16:14:00.827]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:00.827]                         if (muffled) 
[16:14:00.827]                           invokeRestart("muffleMessage")
[16:14:00.827]                       }
[16:14:00.827]                       else if (inherits(cond, "warning")) {
[16:14:00.827]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:00.827]                         if (muffled) 
[16:14:00.827]                           invokeRestart("muffleWarning")
[16:14:00.827]                       }
[16:14:00.827]                       else if (inherits(cond, "condition")) {
[16:14:00.827]                         if (!is.null(pattern)) {
[16:14:00.827]                           computeRestarts <- base::computeRestarts
[16:14:00.827]                           grepl <- base::grepl
[16:14:00.827]                           restarts <- computeRestarts(cond)
[16:14:00.827]                           for (restart in restarts) {
[16:14:00.827]                             name <- restart$name
[16:14:00.827]                             if (is.null(name)) 
[16:14:00.827]                               next
[16:14:00.827]                             if (!grepl(pattern, name)) 
[16:14:00.827]                               next
[16:14:00.827]                             invokeRestart(restart)
[16:14:00.827]                             muffled <- TRUE
[16:14:00.827]                             break
[16:14:00.827]                           }
[16:14:00.827]                         }
[16:14:00.827]                       }
[16:14:00.827]                       invisible(muffled)
[16:14:00.827]                     }
[16:14:00.827]                     muffleCondition(cond, pattern = "^muffle")
[16:14:00.827]                   }
[16:14:00.827]                 }
[16:14:00.827]                 else {
[16:14:00.827]                   if (TRUE) {
[16:14:00.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:00.827]                     {
[16:14:00.827]                       inherits <- base::inherits
[16:14:00.827]                       invokeRestart <- base::invokeRestart
[16:14:00.827]                       is.null <- base::is.null
[16:14:00.827]                       muffled <- FALSE
[16:14:00.827]                       if (inherits(cond, "message")) {
[16:14:00.827]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:00.827]                         if (muffled) 
[16:14:00.827]                           invokeRestart("muffleMessage")
[16:14:00.827]                       }
[16:14:00.827]                       else if (inherits(cond, "warning")) {
[16:14:00.827]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:00.827]                         if (muffled) 
[16:14:00.827]                           invokeRestart("muffleWarning")
[16:14:00.827]                       }
[16:14:00.827]                       else if (inherits(cond, "condition")) {
[16:14:00.827]                         if (!is.null(pattern)) {
[16:14:00.827]                           computeRestarts <- base::computeRestarts
[16:14:00.827]                           grepl <- base::grepl
[16:14:00.827]                           restarts <- computeRestarts(cond)
[16:14:00.827]                           for (restart in restarts) {
[16:14:00.827]                             name <- restart$name
[16:14:00.827]                             if (is.null(name)) 
[16:14:00.827]                               next
[16:14:00.827]                             if (!grepl(pattern, name)) 
[16:14:00.827]                               next
[16:14:00.827]                             invokeRestart(restart)
[16:14:00.827]                             muffled <- TRUE
[16:14:00.827]                             break
[16:14:00.827]                           }
[16:14:00.827]                         }
[16:14:00.827]                       }
[16:14:00.827]                       invisible(muffled)
[16:14:00.827]                     }
[16:14:00.827]                     muffleCondition(cond, pattern = "^muffle")
[16:14:00.827]                   }
[16:14:00.827]                 }
[16:14:00.827]             }
[16:14:00.827]         }))
[16:14:00.827]     }, error = function(ex) {
[16:14:00.827]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:00.827]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:00.827]                 ...future.rng), started = ...future.startTime, 
[16:14:00.827]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:00.827]             version = "1.8"), class = "FutureResult")
[16:14:00.827]     }, finally = {
[16:14:00.827]         if (!identical(...future.workdir, getwd())) 
[16:14:00.827]             setwd(...future.workdir)
[16:14:00.827]         {
[16:14:00.827]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:00.827]                 ...future.oldOptions$nwarnings <- NULL
[16:14:00.827]             }
[16:14:00.827]             base::options(...future.oldOptions)
[16:14:00.827]             if (.Platform$OS.type == "windows") {
[16:14:00.827]                 old_names <- names(...future.oldEnvVars)
[16:14:00.827]                 envs <- base::Sys.getenv()
[16:14:00.827]                 names <- names(envs)
[16:14:00.827]                 common <- intersect(names, old_names)
[16:14:00.827]                 added <- setdiff(names, old_names)
[16:14:00.827]                 removed <- setdiff(old_names, names)
[16:14:00.827]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:00.827]                   envs[common]]
[16:14:00.827]                 NAMES <- toupper(changed)
[16:14:00.827]                 args <- list()
[16:14:00.827]                 for (kk in seq_along(NAMES)) {
[16:14:00.827]                   name <- changed[[kk]]
[16:14:00.827]                   NAME <- NAMES[[kk]]
[16:14:00.827]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:00.827]                     next
[16:14:00.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:00.827]                 }
[16:14:00.827]                 NAMES <- toupper(added)
[16:14:00.827]                 for (kk in seq_along(NAMES)) {
[16:14:00.827]                   name <- added[[kk]]
[16:14:00.827]                   NAME <- NAMES[[kk]]
[16:14:00.827]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:00.827]                     next
[16:14:00.827]                   args[[name]] <- ""
[16:14:00.827]                 }
[16:14:00.827]                 NAMES <- toupper(removed)
[16:14:00.827]                 for (kk in seq_along(NAMES)) {
[16:14:00.827]                   name <- removed[[kk]]
[16:14:00.827]                   NAME <- NAMES[[kk]]
[16:14:00.827]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:00.827]                     next
[16:14:00.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:00.827]                 }
[16:14:00.827]                 if (length(args) > 0) 
[16:14:00.827]                   base::do.call(base::Sys.setenv, args = args)
[16:14:00.827]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:00.827]             }
[16:14:00.827]             else {
[16:14:00.827]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:00.827]             }
[16:14:00.827]             {
[16:14:00.827]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:00.827]                   0L) {
[16:14:00.827]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:00.827]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:00.827]                   base::options(opts)
[16:14:00.827]                 }
[16:14:00.827]                 {
[16:14:00.827]                   {
[16:14:00.827]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:00.827]                     NULL
[16:14:00.827]                   }
[16:14:00.827]                   options(future.plan = NULL)
[16:14:00.827]                   if (is.na(NA_character_)) 
[16:14:00.827]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:00.827]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:00.827]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:00.827]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:00.827]                     envir = parent.frame()) 
[16:14:00.827]                   {
[16:14:00.827]                     if (is.function(workers)) 
[16:14:00.827]                       workers <- workers()
[16:14:00.827]                     workers <- structure(as.integer(workers), 
[16:14:00.827]                       class = class(workers))
[16:14:00.827]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:00.827]                       workers >= 1)
[16:14:00.827]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:00.827]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:00.827]                     }
[16:14:00.827]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:00.827]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:00.827]                       envir = envir)
[16:14:00.827]                     if (!future$lazy) 
[16:14:00.827]                       future <- run(future)
[16:14:00.827]                     invisible(future)
[16:14:00.827]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:00.827]                 }
[16:14:00.827]             }
[16:14:00.827]         }
[16:14:00.827]     })
[16:14:00.827]     if (TRUE) {
[16:14:00.827]         base::sink(type = "output", split = FALSE)
[16:14:00.827]         if (TRUE) {
[16:14:00.827]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:00.827]         }
[16:14:00.827]         else {
[16:14:00.827]             ...future.result["stdout"] <- base::list(NULL)
[16:14:00.827]         }
[16:14:00.827]         base::close(...future.stdout)
[16:14:00.827]         ...future.stdout <- NULL
[16:14:00.827]     }
[16:14:00.827]     ...future.result$conditions <- ...future.conditions
[16:14:00.827]     ...future.result$finished <- base::Sys.time()
[16:14:00.827]     ...future.result
[16:14:00.827] }
[16:14:00.829] Poll #1 (0): usedNodes() = 2, workers = 2
[16:14:00.861] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[16:14:00.892] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[16:14:00.924] Poll #4 (0.09 secs): usedNodes() = 2, workers = 2
[16:14:00.935] receiveMessageFromWorker() for ClusterFuture ...
[16:14:00.935] - Validating connection of MultisessionFuture
[16:14:00.935] - received message: FutureResult
[16:14:00.936] - Received FutureResult
[16:14:00.936] - Erased future from FutureRegistry
[16:14:00.936] result() for ClusterFuture ...
[16:14:00.936] - result already collected: FutureResult
[16:14:00.936] result() for ClusterFuture ... done
[16:14:00.936] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:00.936] result() for ClusterFuture ...
[16:14:00.936] - result already collected: FutureResult
[16:14:00.936] result() for ClusterFuture ... done
[16:14:00.936] result() for ClusterFuture ...
[16:14:00.937] - result already collected: FutureResult
[16:14:00.937] result() for ClusterFuture ... done
[16:14:00.937] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:14:00.937] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[16:14:00.938] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[16:14:00.938] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:14:00.938] MultisessionFuture started
[16:14:00.939] - Launch lazy future ... done
[16:14:00.939] run() for ‘MultisessionFuture’ ... done
[16:14:00.959] Future #1
[16:14:00.959]  length: 2 (resolved future 1)
[16:14:00.960] receiveMessageFromWorker() for ClusterFuture ...
[16:14:00.960] - Validating connection of MultisessionFuture
[16:14:00.960] - received message: FutureResult
[16:14:00.960] - Received FutureResult
[16:14:00.960] - Erased future from FutureRegistry
[16:14:00.961] result() for ClusterFuture ...
[16:14:00.961] - result already collected: FutureResult
[16:14:00.961] result() for ClusterFuture ... done
[16:14:00.961] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:00.961] Future #2
[16:14:00.961]  length: 1 (resolved future 2)
[16:14:01.086] receiveMessageFromWorker() for ClusterFuture ...
[16:14:01.086] - Validating connection of MultisessionFuture
[16:14:01.086] - received message: FutureResult
[16:14:01.086] - Received FutureResult
[16:14:01.086] - Erased future from FutureRegistry
[16:14:01.086] result() for ClusterFuture ...
[16:14:01.086] - result already collected: FutureResult
[16:14:01.087] result() for ClusterFuture ... done
[16:14:01.087] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:01.087] Future #3
[16:14:01.087]  length: 0 (resolved future 3)
[16:14:01.087] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[16:14:01.088] resolve() on environment ...
[16:14:01.088]  recursive: 0
[16:14:01.088]  elements: [2] ‘a’, ‘b’
[16:14:01.088]  length: 1 (resolved future 1)
[16:14:01.088]  length: 0 (resolved future 2)
[16:14:01.088] resolve() on environment ... DONE
[16:14:01.089] getGlobalsAndPackages() ...
[16:14:01.089] Searching for globals...
[16:14:01.089] 
[16:14:01.089] Searching for globals ... DONE
[16:14:01.089] - globals: [0] <none>
[16:14:01.090] getGlobalsAndPackages() ... DONE
[16:14:01.090] run() for ‘Future’ ...
[16:14:01.090] - state: ‘created’
[16:14:01.090] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:01.109] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:01.110] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:01.110]   - Field: ‘node’
[16:14:01.110]   - Field: ‘label’
[16:14:01.110]   - Field: ‘local’
[16:14:01.110]   - Field: ‘owner’
[16:14:01.110]   - Field: ‘envir’
[16:14:01.110]   - Field: ‘workers’
[16:14:01.110]   - Field: ‘packages’
[16:14:01.110]   - Field: ‘gc’
[16:14:01.111]   - Field: ‘conditions’
[16:14:01.111]   - Field: ‘persistent’
[16:14:01.111]   - Field: ‘expr’
[16:14:01.111]   - Field: ‘uuid’
[16:14:01.111]   - Field: ‘seed’
[16:14:01.111]   - Field: ‘version’
[16:14:01.111]   - Field: ‘result’
[16:14:01.111]   - Field: ‘asynchronous’
[16:14:01.111]   - Field: ‘calls’
[16:14:01.111]   - Field: ‘globals’
[16:14:01.111]   - Field: ‘stdout’
[16:14:01.112]   - Field: ‘earlySignal’
[16:14:01.112]   - Field: ‘lazy’
[16:14:01.112]   - Field: ‘state’
[16:14:01.112] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:01.112] - Launch lazy future ...
[16:14:01.112] Packages needed by the future expression (n = 0): <none>
[16:14:01.112] Packages needed by future strategies (n = 0): <none>
[16:14:01.113] {
[16:14:01.113]     {
[16:14:01.113]         {
[16:14:01.113]             ...future.startTime <- base::Sys.time()
[16:14:01.113]             {
[16:14:01.113]                 {
[16:14:01.113]                   {
[16:14:01.113]                     {
[16:14:01.113]                       base::local({
[16:14:01.113]                         has_future <- base::requireNamespace("future", 
[16:14:01.113]                           quietly = TRUE)
[16:14:01.113]                         if (has_future) {
[16:14:01.113]                           ns <- base::getNamespace("future")
[16:14:01.113]                           version <- ns[[".package"]][["version"]]
[16:14:01.113]                           if (is.null(version)) 
[16:14:01.113]                             version <- utils::packageVersion("future")
[16:14:01.113]                         }
[16:14:01.113]                         else {
[16:14:01.113]                           version <- NULL
[16:14:01.113]                         }
[16:14:01.113]                         if (!has_future || version < "1.8.0") {
[16:14:01.113]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:01.113]                             "", base::R.version$version.string), 
[16:14:01.113]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:01.113]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:01.113]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:01.113]                               "release", "version")], collapse = " "), 
[16:14:01.113]                             hostname = base::Sys.info()[["nodename"]])
[16:14:01.113]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:01.113]                             info)
[16:14:01.113]                           info <- base::paste(info, collapse = "; ")
[16:14:01.113]                           if (!has_future) {
[16:14:01.113]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:01.113]                               info)
[16:14:01.113]                           }
[16:14:01.113]                           else {
[16:14:01.113]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:01.113]                               info, version)
[16:14:01.113]                           }
[16:14:01.113]                           base::stop(msg)
[16:14:01.113]                         }
[16:14:01.113]                       })
[16:14:01.113]                     }
[16:14:01.113]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:01.113]                     base::options(mc.cores = 1L)
[16:14:01.113]                   }
[16:14:01.113]                   options(future.plan = NULL)
[16:14:01.113]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.113]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:01.113]                 }
[16:14:01.113]                 ...future.workdir <- getwd()
[16:14:01.113]             }
[16:14:01.113]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:01.113]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:01.113]         }
[16:14:01.113]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:01.113]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:01.113]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:01.113]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:01.113]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:01.113]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:01.113]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:01.113]             base::names(...future.oldOptions))
[16:14:01.113]     }
[16:14:01.113]     if (FALSE) {
[16:14:01.113]     }
[16:14:01.113]     else {
[16:14:01.113]         if (TRUE) {
[16:14:01.113]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:01.113]                 open = "w")
[16:14:01.113]         }
[16:14:01.113]         else {
[16:14:01.113]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:01.113]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:01.113]         }
[16:14:01.113]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:01.113]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:01.113]             base::sink(type = "output", split = FALSE)
[16:14:01.113]             base::close(...future.stdout)
[16:14:01.113]         }, add = TRUE)
[16:14:01.113]     }
[16:14:01.113]     ...future.frame <- base::sys.nframe()
[16:14:01.113]     ...future.conditions <- base::list()
[16:14:01.113]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:01.113]     if (FALSE) {
[16:14:01.113]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:01.113]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:01.113]     }
[16:14:01.113]     ...future.result <- base::tryCatch({
[16:14:01.113]         base::withCallingHandlers({
[16:14:01.113]             ...future.value <- base::withVisible(base::local({
[16:14:01.113]                 ...future.makeSendCondition <- local({
[16:14:01.113]                   sendCondition <- NULL
[16:14:01.113]                   function(frame = 1L) {
[16:14:01.113]                     if (is.function(sendCondition)) 
[16:14:01.113]                       return(sendCondition)
[16:14:01.113]                     ns <- getNamespace("parallel")
[16:14:01.113]                     if (exists("sendData", mode = "function", 
[16:14:01.113]                       envir = ns)) {
[16:14:01.113]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:01.113]                         envir = ns)
[16:14:01.113]                       envir <- sys.frame(frame)
[16:14:01.113]                       master <- NULL
[16:14:01.113]                       while (!identical(envir, .GlobalEnv) && 
[16:14:01.113]                         !identical(envir, emptyenv())) {
[16:14:01.113]                         if (exists("master", mode = "list", envir = envir, 
[16:14:01.113]                           inherits = FALSE)) {
[16:14:01.113]                           master <- get("master", mode = "list", 
[16:14:01.113]                             envir = envir, inherits = FALSE)
[16:14:01.113]                           if (inherits(master, c("SOCKnode", 
[16:14:01.113]                             "SOCK0node"))) {
[16:14:01.113]                             sendCondition <<- function(cond) {
[16:14:01.113]                               data <- list(type = "VALUE", value = cond, 
[16:14:01.113]                                 success = TRUE)
[16:14:01.113]                               parallel_sendData(master, data)
[16:14:01.113]                             }
[16:14:01.113]                             return(sendCondition)
[16:14:01.113]                           }
[16:14:01.113]                         }
[16:14:01.113]                         frame <- frame + 1L
[16:14:01.113]                         envir <- sys.frame(frame)
[16:14:01.113]                       }
[16:14:01.113]                     }
[16:14:01.113]                     sendCondition <<- function(cond) NULL
[16:14:01.113]                   }
[16:14:01.113]                 })
[16:14:01.113]                 withCallingHandlers({
[16:14:01.113]                   1
[16:14:01.113]                 }, immediateCondition = function(cond) {
[16:14:01.113]                   sendCondition <- ...future.makeSendCondition()
[16:14:01.113]                   sendCondition(cond)
[16:14:01.113]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.113]                   {
[16:14:01.113]                     inherits <- base::inherits
[16:14:01.113]                     invokeRestart <- base::invokeRestart
[16:14:01.113]                     is.null <- base::is.null
[16:14:01.113]                     muffled <- FALSE
[16:14:01.113]                     if (inherits(cond, "message")) {
[16:14:01.113]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:01.113]                       if (muffled) 
[16:14:01.113]                         invokeRestart("muffleMessage")
[16:14:01.113]                     }
[16:14:01.113]                     else if (inherits(cond, "warning")) {
[16:14:01.113]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:01.113]                       if (muffled) 
[16:14:01.113]                         invokeRestart("muffleWarning")
[16:14:01.113]                     }
[16:14:01.113]                     else if (inherits(cond, "condition")) {
[16:14:01.113]                       if (!is.null(pattern)) {
[16:14:01.113]                         computeRestarts <- base::computeRestarts
[16:14:01.113]                         grepl <- base::grepl
[16:14:01.113]                         restarts <- computeRestarts(cond)
[16:14:01.113]                         for (restart in restarts) {
[16:14:01.113]                           name <- restart$name
[16:14:01.113]                           if (is.null(name)) 
[16:14:01.113]                             next
[16:14:01.113]                           if (!grepl(pattern, name)) 
[16:14:01.113]                             next
[16:14:01.113]                           invokeRestart(restart)
[16:14:01.113]                           muffled <- TRUE
[16:14:01.113]                           break
[16:14:01.113]                         }
[16:14:01.113]                       }
[16:14:01.113]                     }
[16:14:01.113]                     invisible(muffled)
[16:14:01.113]                   }
[16:14:01.113]                   muffleCondition(cond)
[16:14:01.113]                 })
[16:14:01.113]             }))
[16:14:01.113]             future::FutureResult(value = ...future.value$value, 
[16:14:01.113]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.113]                   ...future.rng), globalenv = if (FALSE) 
[16:14:01.113]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:01.113]                     ...future.globalenv.names))
[16:14:01.113]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:01.113]         }, condition = base::local({
[16:14:01.113]             c <- base::c
[16:14:01.113]             inherits <- base::inherits
[16:14:01.113]             invokeRestart <- base::invokeRestart
[16:14:01.113]             length <- base::length
[16:14:01.113]             list <- base::list
[16:14:01.113]             seq.int <- base::seq.int
[16:14:01.113]             signalCondition <- base::signalCondition
[16:14:01.113]             sys.calls <- base::sys.calls
[16:14:01.113]             `[[` <- base::`[[`
[16:14:01.113]             `+` <- base::`+`
[16:14:01.113]             `<<-` <- base::`<<-`
[16:14:01.113]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:01.113]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:01.113]                   3L)]
[16:14:01.113]             }
[16:14:01.113]             function(cond) {
[16:14:01.113]                 is_error <- inherits(cond, "error")
[16:14:01.113]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:01.113]                   NULL)
[16:14:01.113]                 if (is_error) {
[16:14:01.113]                   sessionInformation <- function() {
[16:14:01.113]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:01.113]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:01.113]                       search = base::search(), system = base::Sys.info())
[16:14:01.113]                   }
[16:14:01.113]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.113]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:01.113]                     cond$call), session = sessionInformation(), 
[16:14:01.113]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:01.113]                   signalCondition(cond)
[16:14:01.113]                 }
[16:14:01.113]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:01.113]                 "immediateCondition"))) {
[16:14:01.113]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:01.113]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.113]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:01.113]                   if (TRUE && !signal) {
[16:14:01.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.113]                     {
[16:14:01.113]                       inherits <- base::inherits
[16:14:01.113]                       invokeRestart <- base::invokeRestart
[16:14:01.113]                       is.null <- base::is.null
[16:14:01.113]                       muffled <- FALSE
[16:14:01.113]                       if (inherits(cond, "message")) {
[16:14:01.113]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.113]                         if (muffled) 
[16:14:01.113]                           invokeRestart("muffleMessage")
[16:14:01.113]                       }
[16:14:01.113]                       else if (inherits(cond, "warning")) {
[16:14:01.113]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.113]                         if (muffled) 
[16:14:01.113]                           invokeRestart("muffleWarning")
[16:14:01.113]                       }
[16:14:01.113]                       else if (inherits(cond, "condition")) {
[16:14:01.113]                         if (!is.null(pattern)) {
[16:14:01.113]                           computeRestarts <- base::computeRestarts
[16:14:01.113]                           grepl <- base::grepl
[16:14:01.113]                           restarts <- computeRestarts(cond)
[16:14:01.113]                           for (restart in restarts) {
[16:14:01.113]                             name <- restart$name
[16:14:01.113]                             if (is.null(name)) 
[16:14:01.113]                               next
[16:14:01.113]                             if (!grepl(pattern, name)) 
[16:14:01.113]                               next
[16:14:01.113]                             invokeRestart(restart)
[16:14:01.113]                             muffled <- TRUE
[16:14:01.113]                             break
[16:14:01.113]                           }
[16:14:01.113]                         }
[16:14:01.113]                       }
[16:14:01.113]                       invisible(muffled)
[16:14:01.113]                     }
[16:14:01.113]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.113]                   }
[16:14:01.113]                 }
[16:14:01.113]                 else {
[16:14:01.113]                   if (TRUE) {
[16:14:01.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.113]                     {
[16:14:01.113]                       inherits <- base::inherits
[16:14:01.113]                       invokeRestart <- base::invokeRestart
[16:14:01.113]                       is.null <- base::is.null
[16:14:01.113]                       muffled <- FALSE
[16:14:01.113]                       if (inherits(cond, "message")) {
[16:14:01.113]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.113]                         if (muffled) 
[16:14:01.113]                           invokeRestart("muffleMessage")
[16:14:01.113]                       }
[16:14:01.113]                       else if (inherits(cond, "warning")) {
[16:14:01.113]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.113]                         if (muffled) 
[16:14:01.113]                           invokeRestart("muffleWarning")
[16:14:01.113]                       }
[16:14:01.113]                       else if (inherits(cond, "condition")) {
[16:14:01.113]                         if (!is.null(pattern)) {
[16:14:01.113]                           computeRestarts <- base::computeRestarts
[16:14:01.113]                           grepl <- base::grepl
[16:14:01.113]                           restarts <- computeRestarts(cond)
[16:14:01.113]                           for (restart in restarts) {
[16:14:01.113]                             name <- restart$name
[16:14:01.113]                             if (is.null(name)) 
[16:14:01.113]                               next
[16:14:01.113]                             if (!grepl(pattern, name)) 
[16:14:01.113]                               next
[16:14:01.113]                             invokeRestart(restart)
[16:14:01.113]                             muffled <- TRUE
[16:14:01.113]                             break
[16:14:01.113]                           }
[16:14:01.113]                         }
[16:14:01.113]                       }
[16:14:01.113]                       invisible(muffled)
[16:14:01.113]                     }
[16:14:01.113]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.113]                   }
[16:14:01.113]                 }
[16:14:01.113]             }
[16:14:01.113]         }))
[16:14:01.113]     }, error = function(ex) {
[16:14:01.113]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:01.113]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.113]                 ...future.rng), started = ...future.startTime, 
[16:14:01.113]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:01.113]             version = "1.8"), class = "FutureResult")
[16:14:01.113]     }, finally = {
[16:14:01.113]         if (!identical(...future.workdir, getwd())) 
[16:14:01.113]             setwd(...future.workdir)
[16:14:01.113]         {
[16:14:01.113]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:01.113]                 ...future.oldOptions$nwarnings <- NULL
[16:14:01.113]             }
[16:14:01.113]             base::options(...future.oldOptions)
[16:14:01.113]             if (.Platform$OS.type == "windows") {
[16:14:01.113]                 old_names <- names(...future.oldEnvVars)
[16:14:01.113]                 envs <- base::Sys.getenv()
[16:14:01.113]                 names <- names(envs)
[16:14:01.113]                 common <- intersect(names, old_names)
[16:14:01.113]                 added <- setdiff(names, old_names)
[16:14:01.113]                 removed <- setdiff(old_names, names)
[16:14:01.113]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:01.113]                   envs[common]]
[16:14:01.113]                 NAMES <- toupper(changed)
[16:14:01.113]                 args <- list()
[16:14:01.113]                 for (kk in seq_along(NAMES)) {
[16:14:01.113]                   name <- changed[[kk]]
[16:14:01.113]                   NAME <- NAMES[[kk]]
[16:14:01.113]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.113]                     next
[16:14:01.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.113]                 }
[16:14:01.113]                 NAMES <- toupper(added)
[16:14:01.113]                 for (kk in seq_along(NAMES)) {
[16:14:01.113]                   name <- added[[kk]]
[16:14:01.113]                   NAME <- NAMES[[kk]]
[16:14:01.113]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.113]                     next
[16:14:01.113]                   args[[name]] <- ""
[16:14:01.113]                 }
[16:14:01.113]                 NAMES <- toupper(removed)
[16:14:01.113]                 for (kk in seq_along(NAMES)) {
[16:14:01.113]                   name <- removed[[kk]]
[16:14:01.113]                   NAME <- NAMES[[kk]]
[16:14:01.113]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.113]                     next
[16:14:01.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.113]                 }
[16:14:01.113]                 if (length(args) > 0) 
[16:14:01.113]                   base::do.call(base::Sys.setenv, args = args)
[16:14:01.113]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:01.113]             }
[16:14:01.113]             else {
[16:14:01.113]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:01.113]             }
[16:14:01.113]             {
[16:14:01.113]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:01.113]                   0L) {
[16:14:01.113]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:01.113]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:01.113]                   base::options(opts)
[16:14:01.113]                 }
[16:14:01.113]                 {
[16:14:01.113]                   {
[16:14:01.113]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:01.113]                     NULL
[16:14:01.113]                   }
[16:14:01.113]                   options(future.plan = NULL)
[16:14:01.113]                   if (is.na(NA_character_)) 
[16:14:01.113]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.113]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:01.113]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:01.113]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:01.113]                     envir = parent.frame()) 
[16:14:01.113]                   {
[16:14:01.113]                     if (is.function(workers)) 
[16:14:01.113]                       workers <- workers()
[16:14:01.113]                     workers <- structure(as.integer(workers), 
[16:14:01.113]                       class = class(workers))
[16:14:01.113]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:01.113]                       workers >= 1)
[16:14:01.113]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:01.113]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:01.113]                     }
[16:14:01.113]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:01.113]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:01.113]                       envir = envir)
[16:14:01.113]                     if (!future$lazy) 
[16:14:01.113]                       future <- run(future)
[16:14:01.113]                     invisible(future)
[16:14:01.113]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:01.113]                 }
[16:14:01.113]             }
[16:14:01.113]         }
[16:14:01.113]     })
[16:14:01.113]     if (TRUE) {
[16:14:01.113]         base::sink(type = "output", split = FALSE)
[16:14:01.113]         if (TRUE) {
[16:14:01.113]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:01.113]         }
[16:14:01.113]         else {
[16:14:01.113]             ...future.result["stdout"] <- base::list(NULL)
[16:14:01.113]         }
[16:14:01.113]         base::close(...future.stdout)
[16:14:01.113]         ...future.stdout <- NULL
[16:14:01.113]     }
[16:14:01.113]     ...future.result$conditions <- ...future.conditions
[16:14:01.113]     ...future.result$finished <- base::Sys.time()
[16:14:01.113]     ...future.result
[16:14:01.113] }
[16:14:01.116] MultisessionFuture started
[16:14:01.116] - Launch lazy future ... done
[16:14:01.116] run() for ‘MultisessionFuture’ ... done
[16:14:01.116] getGlobalsAndPackages() ...
[16:14:01.117] Searching for globals...
[16:14:01.117] 
[16:14:01.117] Searching for globals ... DONE
[16:14:01.117] - globals: [0] <none>
[16:14:01.117] getGlobalsAndPackages() ... DONE
[16:14:01.117] run() for ‘Future’ ...
[16:14:01.118] - state: ‘created’
[16:14:01.118] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:01.133] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:01.133] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:01.133]   - Field: ‘node’
[16:14:01.133]   - Field: ‘label’
[16:14:01.133]   - Field: ‘local’
[16:14:01.133]   - Field: ‘owner’
[16:14:01.133]   - Field: ‘envir’
[16:14:01.133]   - Field: ‘workers’
[16:14:01.134]   - Field: ‘packages’
[16:14:01.134]   - Field: ‘gc’
[16:14:01.134]   - Field: ‘conditions’
[16:14:01.134]   - Field: ‘persistent’
[16:14:01.134]   - Field: ‘expr’
[16:14:01.134]   - Field: ‘uuid’
[16:14:01.134]   - Field: ‘seed’
[16:14:01.134]   - Field: ‘version’
[16:14:01.134]   - Field: ‘result’
[16:14:01.134]   - Field: ‘asynchronous’
[16:14:01.134]   - Field: ‘calls’
[16:14:01.135]   - Field: ‘globals’
[16:14:01.135]   - Field: ‘stdout’
[16:14:01.135]   - Field: ‘earlySignal’
[16:14:01.135]   - Field: ‘lazy’
[16:14:01.135]   - Field: ‘state’
[16:14:01.135] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:01.135] - Launch lazy future ...
[16:14:01.135] Packages needed by the future expression (n = 0): <none>
[16:14:01.135] Packages needed by future strategies (n = 0): <none>
[16:14:01.136] {
[16:14:01.136]     {
[16:14:01.136]         {
[16:14:01.136]             ...future.startTime <- base::Sys.time()
[16:14:01.136]             {
[16:14:01.136]                 {
[16:14:01.136]                   {
[16:14:01.136]                     {
[16:14:01.136]                       base::local({
[16:14:01.136]                         has_future <- base::requireNamespace("future", 
[16:14:01.136]                           quietly = TRUE)
[16:14:01.136]                         if (has_future) {
[16:14:01.136]                           ns <- base::getNamespace("future")
[16:14:01.136]                           version <- ns[[".package"]][["version"]]
[16:14:01.136]                           if (is.null(version)) 
[16:14:01.136]                             version <- utils::packageVersion("future")
[16:14:01.136]                         }
[16:14:01.136]                         else {
[16:14:01.136]                           version <- NULL
[16:14:01.136]                         }
[16:14:01.136]                         if (!has_future || version < "1.8.0") {
[16:14:01.136]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:01.136]                             "", base::R.version$version.string), 
[16:14:01.136]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:01.136]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:01.136]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:01.136]                               "release", "version")], collapse = " "), 
[16:14:01.136]                             hostname = base::Sys.info()[["nodename"]])
[16:14:01.136]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:01.136]                             info)
[16:14:01.136]                           info <- base::paste(info, collapse = "; ")
[16:14:01.136]                           if (!has_future) {
[16:14:01.136]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:01.136]                               info)
[16:14:01.136]                           }
[16:14:01.136]                           else {
[16:14:01.136]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:01.136]                               info, version)
[16:14:01.136]                           }
[16:14:01.136]                           base::stop(msg)
[16:14:01.136]                         }
[16:14:01.136]                       })
[16:14:01.136]                     }
[16:14:01.136]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:01.136]                     base::options(mc.cores = 1L)
[16:14:01.136]                   }
[16:14:01.136]                   options(future.plan = NULL)
[16:14:01.136]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.136]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:01.136]                 }
[16:14:01.136]                 ...future.workdir <- getwd()
[16:14:01.136]             }
[16:14:01.136]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:01.136]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:01.136]         }
[16:14:01.136]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:01.136]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:01.136]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:01.136]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:01.136]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:01.136]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:01.136]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:01.136]             base::names(...future.oldOptions))
[16:14:01.136]     }
[16:14:01.136]     if (FALSE) {
[16:14:01.136]     }
[16:14:01.136]     else {
[16:14:01.136]         if (TRUE) {
[16:14:01.136]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:01.136]                 open = "w")
[16:14:01.136]         }
[16:14:01.136]         else {
[16:14:01.136]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:01.136]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:01.136]         }
[16:14:01.136]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:01.136]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:01.136]             base::sink(type = "output", split = FALSE)
[16:14:01.136]             base::close(...future.stdout)
[16:14:01.136]         }, add = TRUE)
[16:14:01.136]     }
[16:14:01.136]     ...future.frame <- base::sys.nframe()
[16:14:01.136]     ...future.conditions <- base::list()
[16:14:01.136]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:01.136]     if (FALSE) {
[16:14:01.136]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:01.136]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:01.136]     }
[16:14:01.136]     ...future.result <- base::tryCatch({
[16:14:01.136]         base::withCallingHandlers({
[16:14:01.136]             ...future.value <- base::withVisible(base::local({
[16:14:01.136]                 ...future.makeSendCondition <- local({
[16:14:01.136]                   sendCondition <- NULL
[16:14:01.136]                   function(frame = 1L) {
[16:14:01.136]                     if (is.function(sendCondition)) 
[16:14:01.136]                       return(sendCondition)
[16:14:01.136]                     ns <- getNamespace("parallel")
[16:14:01.136]                     if (exists("sendData", mode = "function", 
[16:14:01.136]                       envir = ns)) {
[16:14:01.136]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:01.136]                         envir = ns)
[16:14:01.136]                       envir <- sys.frame(frame)
[16:14:01.136]                       master <- NULL
[16:14:01.136]                       while (!identical(envir, .GlobalEnv) && 
[16:14:01.136]                         !identical(envir, emptyenv())) {
[16:14:01.136]                         if (exists("master", mode = "list", envir = envir, 
[16:14:01.136]                           inherits = FALSE)) {
[16:14:01.136]                           master <- get("master", mode = "list", 
[16:14:01.136]                             envir = envir, inherits = FALSE)
[16:14:01.136]                           if (inherits(master, c("SOCKnode", 
[16:14:01.136]                             "SOCK0node"))) {
[16:14:01.136]                             sendCondition <<- function(cond) {
[16:14:01.136]                               data <- list(type = "VALUE", value = cond, 
[16:14:01.136]                                 success = TRUE)
[16:14:01.136]                               parallel_sendData(master, data)
[16:14:01.136]                             }
[16:14:01.136]                             return(sendCondition)
[16:14:01.136]                           }
[16:14:01.136]                         }
[16:14:01.136]                         frame <- frame + 1L
[16:14:01.136]                         envir <- sys.frame(frame)
[16:14:01.136]                       }
[16:14:01.136]                     }
[16:14:01.136]                     sendCondition <<- function(cond) NULL
[16:14:01.136]                   }
[16:14:01.136]                 })
[16:14:01.136]                 withCallingHandlers({
[16:14:01.136]                   2
[16:14:01.136]                 }, immediateCondition = function(cond) {
[16:14:01.136]                   sendCondition <- ...future.makeSendCondition()
[16:14:01.136]                   sendCondition(cond)
[16:14:01.136]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.136]                   {
[16:14:01.136]                     inherits <- base::inherits
[16:14:01.136]                     invokeRestart <- base::invokeRestart
[16:14:01.136]                     is.null <- base::is.null
[16:14:01.136]                     muffled <- FALSE
[16:14:01.136]                     if (inherits(cond, "message")) {
[16:14:01.136]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:01.136]                       if (muffled) 
[16:14:01.136]                         invokeRestart("muffleMessage")
[16:14:01.136]                     }
[16:14:01.136]                     else if (inherits(cond, "warning")) {
[16:14:01.136]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:01.136]                       if (muffled) 
[16:14:01.136]                         invokeRestart("muffleWarning")
[16:14:01.136]                     }
[16:14:01.136]                     else if (inherits(cond, "condition")) {
[16:14:01.136]                       if (!is.null(pattern)) {
[16:14:01.136]                         computeRestarts <- base::computeRestarts
[16:14:01.136]                         grepl <- base::grepl
[16:14:01.136]                         restarts <- computeRestarts(cond)
[16:14:01.136]                         for (restart in restarts) {
[16:14:01.136]                           name <- restart$name
[16:14:01.136]                           if (is.null(name)) 
[16:14:01.136]                             next
[16:14:01.136]                           if (!grepl(pattern, name)) 
[16:14:01.136]                             next
[16:14:01.136]                           invokeRestart(restart)
[16:14:01.136]                           muffled <- TRUE
[16:14:01.136]                           break
[16:14:01.136]                         }
[16:14:01.136]                       }
[16:14:01.136]                     }
[16:14:01.136]                     invisible(muffled)
[16:14:01.136]                   }
[16:14:01.136]                   muffleCondition(cond)
[16:14:01.136]                 })
[16:14:01.136]             }))
[16:14:01.136]             future::FutureResult(value = ...future.value$value, 
[16:14:01.136]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.136]                   ...future.rng), globalenv = if (FALSE) 
[16:14:01.136]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:01.136]                     ...future.globalenv.names))
[16:14:01.136]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:01.136]         }, condition = base::local({
[16:14:01.136]             c <- base::c
[16:14:01.136]             inherits <- base::inherits
[16:14:01.136]             invokeRestart <- base::invokeRestart
[16:14:01.136]             length <- base::length
[16:14:01.136]             list <- base::list
[16:14:01.136]             seq.int <- base::seq.int
[16:14:01.136]             signalCondition <- base::signalCondition
[16:14:01.136]             sys.calls <- base::sys.calls
[16:14:01.136]             `[[` <- base::`[[`
[16:14:01.136]             `+` <- base::`+`
[16:14:01.136]             `<<-` <- base::`<<-`
[16:14:01.136]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:01.136]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:01.136]                   3L)]
[16:14:01.136]             }
[16:14:01.136]             function(cond) {
[16:14:01.136]                 is_error <- inherits(cond, "error")
[16:14:01.136]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:01.136]                   NULL)
[16:14:01.136]                 if (is_error) {
[16:14:01.136]                   sessionInformation <- function() {
[16:14:01.136]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:01.136]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:01.136]                       search = base::search(), system = base::Sys.info())
[16:14:01.136]                   }
[16:14:01.136]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.136]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:01.136]                     cond$call), session = sessionInformation(), 
[16:14:01.136]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:01.136]                   signalCondition(cond)
[16:14:01.136]                 }
[16:14:01.136]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:01.136]                 "immediateCondition"))) {
[16:14:01.136]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:01.136]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.136]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:01.136]                   if (TRUE && !signal) {
[16:14:01.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.136]                     {
[16:14:01.136]                       inherits <- base::inherits
[16:14:01.136]                       invokeRestart <- base::invokeRestart
[16:14:01.136]                       is.null <- base::is.null
[16:14:01.136]                       muffled <- FALSE
[16:14:01.136]                       if (inherits(cond, "message")) {
[16:14:01.136]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.136]                         if (muffled) 
[16:14:01.136]                           invokeRestart("muffleMessage")
[16:14:01.136]                       }
[16:14:01.136]                       else if (inherits(cond, "warning")) {
[16:14:01.136]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.136]                         if (muffled) 
[16:14:01.136]                           invokeRestart("muffleWarning")
[16:14:01.136]                       }
[16:14:01.136]                       else if (inherits(cond, "condition")) {
[16:14:01.136]                         if (!is.null(pattern)) {
[16:14:01.136]                           computeRestarts <- base::computeRestarts
[16:14:01.136]                           grepl <- base::grepl
[16:14:01.136]                           restarts <- computeRestarts(cond)
[16:14:01.136]                           for (restart in restarts) {
[16:14:01.136]                             name <- restart$name
[16:14:01.136]                             if (is.null(name)) 
[16:14:01.136]                               next
[16:14:01.136]                             if (!grepl(pattern, name)) 
[16:14:01.136]                               next
[16:14:01.136]                             invokeRestart(restart)
[16:14:01.136]                             muffled <- TRUE
[16:14:01.136]                             break
[16:14:01.136]                           }
[16:14:01.136]                         }
[16:14:01.136]                       }
[16:14:01.136]                       invisible(muffled)
[16:14:01.136]                     }
[16:14:01.136]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.136]                   }
[16:14:01.136]                 }
[16:14:01.136]                 else {
[16:14:01.136]                   if (TRUE) {
[16:14:01.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.136]                     {
[16:14:01.136]                       inherits <- base::inherits
[16:14:01.136]                       invokeRestart <- base::invokeRestart
[16:14:01.136]                       is.null <- base::is.null
[16:14:01.136]                       muffled <- FALSE
[16:14:01.136]                       if (inherits(cond, "message")) {
[16:14:01.136]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.136]                         if (muffled) 
[16:14:01.136]                           invokeRestart("muffleMessage")
[16:14:01.136]                       }
[16:14:01.136]                       else if (inherits(cond, "warning")) {
[16:14:01.136]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.136]                         if (muffled) 
[16:14:01.136]                           invokeRestart("muffleWarning")
[16:14:01.136]                       }
[16:14:01.136]                       else if (inherits(cond, "condition")) {
[16:14:01.136]                         if (!is.null(pattern)) {
[16:14:01.136]                           computeRestarts <- base::computeRestarts
[16:14:01.136]                           grepl <- base::grepl
[16:14:01.136]                           restarts <- computeRestarts(cond)
[16:14:01.136]                           for (restart in restarts) {
[16:14:01.136]                             name <- restart$name
[16:14:01.136]                             if (is.null(name)) 
[16:14:01.136]                               next
[16:14:01.136]                             if (!grepl(pattern, name)) 
[16:14:01.136]                               next
[16:14:01.136]                             invokeRestart(restart)
[16:14:01.136]                             muffled <- TRUE
[16:14:01.136]                             break
[16:14:01.136]                           }
[16:14:01.136]                         }
[16:14:01.136]                       }
[16:14:01.136]                       invisible(muffled)
[16:14:01.136]                     }
[16:14:01.136]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.136]                   }
[16:14:01.136]                 }
[16:14:01.136]             }
[16:14:01.136]         }))
[16:14:01.136]     }, error = function(ex) {
[16:14:01.136]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:01.136]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.136]                 ...future.rng), started = ...future.startTime, 
[16:14:01.136]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:01.136]             version = "1.8"), class = "FutureResult")
[16:14:01.136]     }, finally = {
[16:14:01.136]         if (!identical(...future.workdir, getwd())) 
[16:14:01.136]             setwd(...future.workdir)
[16:14:01.136]         {
[16:14:01.136]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:01.136]                 ...future.oldOptions$nwarnings <- NULL
[16:14:01.136]             }
[16:14:01.136]             base::options(...future.oldOptions)
[16:14:01.136]             if (.Platform$OS.type == "windows") {
[16:14:01.136]                 old_names <- names(...future.oldEnvVars)
[16:14:01.136]                 envs <- base::Sys.getenv()
[16:14:01.136]                 names <- names(envs)
[16:14:01.136]                 common <- intersect(names, old_names)
[16:14:01.136]                 added <- setdiff(names, old_names)
[16:14:01.136]                 removed <- setdiff(old_names, names)
[16:14:01.136]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:01.136]                   envs[common]]
[16:14:01.136]                 NAMES <- toupper(changed)
[16:14:01.136]                 args <- list()
[16:14:01.136]                 for (kk in seq_along(NAMES)) {
[16:14:01.136]                   name <- changed[[kk]]
[16:14:01.136]                   NAME <- NAMES[[kk]]
[16:14:01.136]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.136]                     next
[16:14:01.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.136]                 }
[16:14:01.136]                 NAMES <- toupper(added)
[16:14:01.136]                 for (kk in seq_along(NAMES)) {
[16:14:01.136]                   name <- added[[kk]]
[16:14:01.136]                   NAME <- NAMES[[kk]]
[16:14:01.136]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.136]                     next
[16:14:01.136]                   args[[name]] <- ""
[16:14:01.136]                 }
[16:14:01.136]                 NAMES <- toupper(removed)
[16:14:01.136]                 for (kk in seq_along(NAMES)) {
[16:14:01.136]                   name <- removed[[kk]]
[16:14:01.136]                   NAME <- NAMES[[kk]]
[16:14:01.136]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.136]                     next
[16:14:01.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.136]                 }
[16:14:01.136]                 if (length(args) > 0) 
[16:14:01.136]                   base::do.call(base::Sys.setenv, args = args)
[16:14:01.136]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:01.136]             }
[16:14:01.136]             else {
[16:14:01.136]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:01.136]             }
[16:14:01.136]             {
[16:14:01.136]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:01.136]                   0L) {
[16:14:01.136]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:01.136]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:01.136]                   base::options(opts)
[16:14:01.136]                 }
[16:14:01.136]                 {
[16:14:01.136]                   {
[16:14:01.136]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:01.136]                     NULL
[16:14:01.136]                   }
[16:14:01.136]                   options(future.plan = NULL)
[16:14:01.136]                   if (is.na(NA_character_)) 
[16:14:01.136]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.136]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:01.136]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:01.136]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:01.136]                     envir = parent.frame()) 
[16:14:01.136]                   {
[16:14:01.136]                     if (is.function(workers)) 
[16:14:01.136]                       workers <- workers()
[16:14:01.136]                     workers <- structure(as.integer(workers), 
[16:14:01.136]                       class = class(workers))
[16:14:01.136]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:01.136]                       workers >= 1)
[16:14:01.136]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:01.136]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:01.136]                     }
[16:14:01.136]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:01.136]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:01.136]                       envir = envir)
[16:14:01.136]                     if (!future$lazy) 
[16:14:01.136]                       future <- run(future)
[16:14:01.136]                     invisible(future)
[16:14:01.136]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:01.136]                 }
[16:14:01.136]             }
[16:14:01.136]         }
[16:14:01.136]     })
[16:14:01.136]     if (TRUE) {
[16:14:01.136]         base::sink(type = "output", split = FALSE)
[16:14:01.136]         if (TRUE) {
[16:14:01.136]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:01.136]         }
[16:14:01.136]         else {
[16:14:01.136]             ...future.result["stdout"] <- base::list(NULL)
[16:14:01.136]         }
[16:14:01.136]         base::close(...future.stdout)
[16:14:01.136]         ...future.stdout <- NULL
[16:14:01.136]     }
[16:14:01.136]     ...future.result$conditions <- ...future.conditions
[16:14:01.136]     ...future.result$finished <- base::Sys.time()
[16:14:01.136]     ...future.result
[16:14:01.136] }
[16:14:01.139] MultisessionFuture started
[16:14:01.139] - Launch lazy future ... done
[16:14:01.139] run() for ‘MultisessionFuture’ ... done
[16:14:01.140] resolve() on environment ...
[16:14:01.140]  recursive: 0
[16:14:01.140]  elements: [3] ‘a’, ‘b’, ‘c’
[16:14:01.141] receiveMessageFromWorker() for ClusterFuture ...
[16:14:01.141] - Validating connection of MultisessionFuture
[16:14:01.141] - received message: FutureResult
[16:14:01.141] - Received FutureResult
[16:14:01.142] - Erased future from FutureRegistry
[16:14:01.142] result() for ClusterFuture ...
[16:14:01.142] - result already collected: FutureResult
[16:14:01.142] result() for ClusterFuture ... done
[16:14:01.142] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:01.142] Future #1
[16:14:01.142]  length: 2 (resolved future 1)
[16:14:01.153]  length: 1 (resolved future 3)
[16:14:01.185] receiveMessageFromWorker() for ClusterFuture ...
[16:14:01.185] - Validating connection of MultisessionFuture
[16:14:01.185] - received message: FutureResult
[16:14:01.185] - Received FutureResult
[16:14:01.186] - Erased future from FutureRegistry
[16:14:01.186] result() for ClusterFuture ...
[16:14:01.186] - result already collected: FutureResult
[16:14:01.186] result() for ClusterFuture ... done
[16:14:01.186] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:01.186] Future #2
[16:14:01.186]  length: 0 (resolved future 2)
[16:14:01.186] resolve() on environment ... DONE
[16:14:01.187] getGlobalsAndPackages() ...
[16:14:01.187] Searching for globals...
[16:14:01.188] - globals found: [1] ‘{’
[16:14:01.188] Searching for globals ... DONE
[16:14:01.188] Resolving globals: FALSE
[16:14:01.188] 
[16:14:01.188] 
[16:14:01.188] getGlobalsAndPackages() ... DONE
[16:14:01.189] run() for ‘Future’ ...
[16:14:01.189] - state: ‘created’
[16:14:01.189] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:01.204] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:01.204] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:01.204]   - Field: ‘node’
[16:14:01.205]   - Field: ‘label’
[16:14:01.205]   - Field: ‘local’
[16:14:01.205]   - Field: ‘owner’
[16:14:01.205]   - Field: ‘envir’
[16:14:01.205]   - Field: ‘workers’
[16:14:01.205]   - Field: ‘packages’
[16:14:01.205]   - Field: ‘gc’
[16:14:01.205]   - Field: ‘conditions’
[16:14:01.205]   - Field: ‘persistent’
[16:14:01.205]   - Field: ‘expr’
[16:14:01.205]   - Field: ‘uuid’
[16:14:01.206]   - Field: ‘seed’
[16:14:01.206]   - Field: ‘version’
[16:14:01.206]   - Field: ‘result’
[16:14:01.206]   - Field: ‘asynchronous’
[16:14:01.206]   - Field: ‘calls’
[16:14:01.206]   - Field: ‘globals’
[16:14:01.206]   - Field: ‘stdout’
[16:14:01.206]   - Field: ‘earlySignal’
[16:14:01.206]   - Field: ‘lazy’
[16:14:01.206]   - Field: ‘state’
[16:14:01.206] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:01.207] - Launch lazy future ...
[16:14:01.207] Packages needed by the future expression (n = 0): <none>
[16:14:01.207] Packages needed by future strategies (n = 0): <none>
[16:14:01.207] {
[16:14:01.207]     {
[16:14:01.207]         {
[16:14:01.207]             ...future.startTime <- base::Sys.time()
[16:14:01.207]             {
[16:14:01.207]                 {
[16:14:01.207]                   {
[16:14:01.207]                     {
[16:14:01.207]                       base::local({
[16:14:01.207]                         has_future <- base::requireNamespace("future", 
[16:14:01.207]                           quietly = TRUE)
[16:14:01.207]                         if (has_future) {
[16:14:01.207]                           ns <- base::getNamespace("future")
[16:14:01.207]                           version <- ns[[".package"]][["version"]]
[16:14:01.207]                           if (is.null(version)) 
[16:14:01.207]                             version <- utils::packageVersion("future")
[16:14:01.207]                         }
[16:14:01.207]                         else {
[16:14:01.207]                           version <- NULL
[16:14:01.207]                         }
[16:14:01.207]                         if (!has_future || version < "1.8.0") {
[16:14:01.207]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:01.207]                             "", base::R.version$version.string), 
[16:14:01.207]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:01.207]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:01.207]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:01.207]                               "release", "version")], collapse = " "), 
[16:14:01.207]                             hostname = base::Sys.info()[["nodename"]])
[16:14:01.207]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:01.207]                             info)
[16:14:01.207]                           info <- base::paste(info, collapse = "; ")
[16:14:01.207]                           if (!has_future) {
[16:14:01.207]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:01.207]                               info)
[16:14:01.207]                           }
[16:14:01.207]                           else {
[16:14:01.207]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:01.207]                               info, version)
[16:14:01.207]                           }
[16:14:01.207]                           base::stop(msg)
[16:14:01.207]                         }
[16:14:01.207]                       })
[16:14:01.207]                     }
[16:14:01.207]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:01.207]                     base::options(mc.cores = 1L)
[16:14:01.207]                   }
[16:14:01.207]                   options(future.plan = NULL)
[16:14:01.207]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.207]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:01.207]                 }
[16:14:01.207]                 ...future.workdir <- getwd()
[16:14:01.207]             }
[16:14:01.207]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:01.207]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:01.207]         }
[16:14:01.207]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:01.207]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:01.207]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:01.207]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:01.207]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:01.207]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:01.207]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:01.207]             base::names(...future.oldOptions))
[16:14:01.207]     }
[16:14:01.207]     if (FALSE) {
[16:14:01.207]     }
[16:14:01.207]     else {
[16:14:01.207]         if (TRUE) {
[16:14:01.207]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:01.207]                 open = "w")
[16:14:01.207]         }
[16:14:01.207]         else {
[16:14:01.207]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:01.207]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:01.207]         }
[16:14:01.207]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:01.207]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:01.207]             base::sink(type = "output", split = FALSE)
[16:14:01.207]             base::close(...future.stdout)
[16:14:01.207]         }, add = TRUE)
[16:14:01.207]     }
[16:14:01.207]     ...future.frame <- base::sys.nframe()
[16:14:01.207]     ...future.conditions <- base::list()
[16:14:01.207]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:01.207]     if (FALSE) {
[16:14:01.207]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:01.207]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:01.207]     }
[16:14:01.207]     ...future.result <- base::tryCatch({
[16:14:01.207]         base::withCallingHandlers({
[16:14:01.207]             ...future.value <- base::withVisible(base::local({
[16:14:01.207]                 ...future.makeSendCondition <- local({
[16:14:01.207]                   sendCondition <- NULL
[16:14:01.207]                   function(frame = 1L) {
[16:14:01.207]                     if (is.function(sendCondition)) 
[16:14:01.207]                       return(sendCondition)
[16:14:01.207]                     ns <- getNamespace("parallel")
[16:14:01.207]                     if (exists("sendData", mode = "function", 
[16:14:01.207]                       envir = ns)) {
[16:14:01.207]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:01.207]                         envir = ns)
[16:14:01.207]                       envir <- sys.frame(frame)
[16:14:01.207]                       master <- NULL
[16:14:01.207]                       while (!identical(envir, .GlobalEnv) && 
[16:14:01.207]                         !identical(envir, emptyenv())) {
[16:14:01.207]                         if (exists("master", mode = "list", envir = envir, 
[16:14:01.207]                           inherits = FALSE)) {
[16:14:01.207]                           master <- get("master", mode = "list", 
[16:14:01.207]                             envir = envir, inherits = FALSE)
[16:14:01.207]                           if (inherits(master, c("SOCKnode", 
[16:14:01.207]                             "SOCK0node"))) {
[16:14:01.207]                             sendCondition <<- function(cond) {
[16:14:01.207]                               data <- list(type = "VALUE", value = cond, 
[16:14:01.207]                                 success = TRUE)
[16:14:01.207]                               parallel_sendData(master, data)
[16:14:01.207]                             }
[16:14:01.207]                             return(sendCondition)
[16:14:01.207]                           }
[16:14:01.207]                         }
[16:14:01.207]                         frame <- frame + 1L
[16:14:01.207]                         envir <- sys.frame(frame)
[16:14:01.207]                       }
[16:14:01.207]                     }
[16:14:01.207]                     sendCondition <<- function(cond) NULL
[16:14:01.207]                   }
[16:14:01.207]                 })
[16:14:01.207]                 withCallingHandlers({
[16:14:01.207]                   {
[16:14:01.207]                     1
[16:14:01.207]                   }
[16:14:01.207]                 }, immediateCondition = function(cond) {
[16:14:01.207]                   sendCondition <- ...future.makeSendCondition()
[16:14:01.207]                   sendCondition(cond)
[16:14:01.207]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.207]                   {
[16:14:01.207]                     inherits <- base::inherits
[16:14:01.207]                     invokeRestart <- base::invokeRestart
[16:14:01.207]                     is.null <- base::is.null
[16:14:01.207]                     muffled <- FALSE
[16:14:01.207]                     if (inherits(cond, "message")) {
[16:14:01.207]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:01.207]                       if (muffled) 
[16:14:01.207]                         invokeRestart("muffleMessage")
[16:14:01.207]                     }
[16:14:01.207]                     else if (inherits(cond, "warning")) {
[16:14:01.207]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:01.207]                       if (muffled) 
[16:14:01.207]                         invokeRestart("muffleWarning")
[16:14:01.207]                     }
[16:14:01.207]                     else if (inherits(cond, "condition")) {
[16:14:01.207]                       if (!is.null(pattern)) {
[16:14:01.207]                         computeRestarts <- base::computeRestarts
[16:14:01.207]                         grepl <- base::grepl
[16:14:01.207]                         restarts <- computeRestarts(cond)
[16:14:01.207]                         for (restart in restarts) {
[16:14:01.207]                           name <- restart$name
[16:14:01.207]                           if (is.null(name)) 
[16:14:01.207]                             next
[16:14:01.207]                           if (!grepl(pattern, name)) 
[16:14:01.207]                             next
[16:14:01.207]                           invokeRestart(restart)
[16:14:01.207]                           muffled <- TRUE
[16:14:01.207]                           break
[16:14:01.207]                         }
[16:14:01.207]                       }
[16:14:01.207]                     }
[16:14:01.207]                     invisible(muffled)
[16:14:01.207]                   }
[16:14:01.207]                   muffleCondition(cond)
[16:14:01.207]                 })
[16:14:01.207]             }))
[16:14:01.207]             future::FutureResult(value = ...future.value$value, 
[16:14:01.207]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.207]                   ...future.rng), globalenv = if (FALSE) 
[16:14:01.207]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:01.207]                     ...future.globalenv.names))
[16:14:01.207]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:01.207]         }, condition = base::local({
[16:14:01.207]             c <- base::c
[16:14:01.207]             inherits <- base::inherits
[16:14:01.207]             invokeRestart <- base::invokeRestart
[16:14:01.207]             length <- base::length
[16:14:01.207]             list <- base::list
[16:14:01.207]             seq.int <- base::seq.int
[16:14:01.207]             signalCondition <- base::signalCondition
[16:14:01.207]             sys.calls <- base::sys.calls
[16:14:01.207]             `[[` <- base::`[[`
[16:14:01.207]             `+` <- base::`+`
[16:14:01.207]             `<<-` <- base::`<<-`
[16:14:01.207]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:01.207]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:01.207]                   3L)]
[16:14:01.207]             }
[16:14:01.207]             function(cond) {
[16:14:01.207]                 is_error <- inherits(cond, "error")
[16:14:01.207]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:01.207]                   NULL)
[16:14:01.207]                 if (is_error) {
[16:14:01.207]                   sessionInformation <- function() {
[16:14:01.207]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:01.207]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:01.207]                       search = base::search(), system = base::Sys.info())
[16:14:01.207]                   }
[16:14:01.207]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.207]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:01.207]                     cond$call), session = sessionInformation(), 
[16:14:01.207]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:01.207]                   signalCondition(cond)
[16:14:01.207]                 }
[16:14:01.207]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:01.207]                 "immediateCondition"))) {
[16:14:01.207]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:01.207]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.207]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:01.207]                   if (TRUE && !signal) {
[16:14:01.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.207]                     {
[16:14:01.207]                       inherits <- base::inherits
[16:14:01.207]                       invokeRestart <- base::invokeRestart
[16:14:01.207]                       is.null <- base::is.null
[16:14:01.207]                       muffled <- FALSE
[16:14:01.207]                       if (inherits(cond, "message")) {
[16:14:01.207]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.207]                         if (muffled) 
[16:14:01.207]                           invokeRestart("muffleMessage")
[16:14:01.207]                       }
[16:14:01.207]                       else if (inherits(cond, "warning")) {
[16:14:01.207]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.207]                         if (muffled) 
[16:14:01.207]                           invokeRestart("muffleWarning")
[16:14:01.207]                       }
[16:14:01.207]                       else if (inherits(cond, "condition")) {
[16:14:01.207]                         if (!is.null(pattern)) {
[16:14:01.207]                           computeRestarts <- base::computeRestarts
[16:14:01.207]                           grepl <- base::grepl
[16:14:01.207]                           restarts <- computeRestarts(cond)
[16:14:01.207]                           for (restart in restarts) {
[16:14:01.207]                             name <- restart$name
[16:14:01.207]                             if (is.null(name)) 
[16:14:01.207]                               next
[16:14:01.207]                             if (!grepl(pattern, name)) 
[16:14:01.207]                               next
[16:14:01.207]                             invokeRestart(restart)
[16:14:01.207]                             muffled <- TRUE
[16:14:01.207]                             break
[16:14:01.207]                           }
[16:14:01.207]                         }
[16:14:01.207]                       }
[16:14:01.207]                       invisible(muffled)
[16:14:01.207]                     }
[16:14:01.207]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.207]                   }
[16:14:01.207]                 }
[16:14:01.207]                 else {
[16:14:01.207]                   if (TRUE) {
[16:14:01.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.207]                     {
[16:14:01.207]                       inherits <- base::inherits
[16:14:01.207]                       invokeRestart <- base::invokeRestart
[16:14:01.207]                       is.null <- base::is.null
[16:14:01.207]                       muffled <- FALSE
[16:14:01.207]                       if (inherits(cond, "message")) {
[16:14:01.207]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.207]                         if (muffled) 
[16:14:01.207]                           invokeRestart("muffleMessage")
[16:14:01.207]                       }
[16:14:01.207]                       else if (inherits(cond, "warning")) {
[16:14:01.207]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.207]                         if (muffled) 
[16:14:01.207]                           invokeRestart("muffleWarning")
[16:14:01.207]                       }
[16:14:01.207]                       else if (inherits(cond, "condition")) {
[16:14:01.207]                         if (!is.null(pattern)) {
[16:14:01.207]                           computeRestarts <- base::computeRestarts
[16:14:01.207]                           grepl <- base::grepl
[16:14:01.207]                           restarts <- computeRestarts(cond)
[16:14:01.207]                           for (restart in restarts) {
[16:14:01.207]                             name <- restart$name
[16:14:01.207]                             if (is.null(name)) 
[16:14:01.207]                               next
[16:14:01.207]                             if (!grepl(pattern, name)) 
[16:14:01.207]                               next
[16:14:01.207]                             invokeRestart(restart)
[16:14:01.207]                             muffled <- TRUE
[16:14:01.207]                             break
[16:14:01.207]                           }
[16:14:01.207]                         }
[16:14:01.207]                       }
[16:14:01.207]                       invisible(muffled)
[16:14:01.207]                     }
[16:14:01.207]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.207]                   }
[16:14:01.207]                 }
[16:14:01.207]             }
[16:14:01.207]         }))
[16:14:01.207]     }, error = function(ex) {
[16:14:01.207]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:01.207]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.207]                 ...future.rng), started = ...future.startTime, 
[16:14:01.207]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:01.207]             version = "1.8"), class = "FutureResult")
[16:14:01.207]     }, finally = {
[16:14:01.207]         if (!identical(...future.workdir, getwd())) 
[16:14:01.207]             setwd(...future.workdir)
[16:14:01.207]         {
[16:14:01.207]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:01.207]                 ...future.oldOptions$nwarnings <- NULL
[16:14:01.207]             }
[16:14:01.207]             base::options(...future.oldOptions)
[16:14:01.207]             if (.Platform$OS.type == "windows") {
[16:14:01.207]                 old_names <- names(...future.oldEnvVars)
[16:14:01.207]                 envs <- base::Sys.getenv()
[16:14:01.207]                 names <- names(envs)
[16:14:01.207]                 common <- intersect(names, old_names)
[16:14:01.207]                 added <- setdiff(names, old_names)
[16:14:01.207]                 removed <- setdiff(old_names, names)
[16:14:01.207]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:01.207]                   envs[common]]
[16:14:01.207]                 NAMES <- toupper(changed)
[16:14:01.207]                 args <- list()
[16:14:01.207]                 for (kk in seq_along(NAMES)) {
[16:14:01.207]                   name <- changed[[kk]]
[16:14:01.207]                   NAME <- NAMES[[kk]]
[16:14:01.207]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.207]                     next
[16:14:01.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.207]                 }
[16:14:01.207]                 NAMES <- toupper(added)
[16:14:01.207]                 for (kk in seq_along(NAMES)) {
[16:14:01.207]                   name <- added[[kk]]
[16:14:01.207]                   NAME <- NAMES[[kk]]
[16:14:01.207]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.207]                     next
[16:14:01.207]                   args[[name]] <- ""
[16:14:01.207]                 }
[16:14:01.207]                 NAMES <- toupper(removed)
[16:14:01.207]                 for (kk in seq_along(NAMES)) {
[16:14:01.207]                   name <- removed[[kk]]
[16:14:01.207]                   NAME <- NAMES[[kk]]
[16:14:01.207]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.207]                     next
[16:14:01.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.207]                 }
[16:14:01.207]                 if (length(args) > 0) 
[16:14:01.207]                   base::do.call(base::Sys.setenv, args = args)
[16:14:01.207]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:01.207]             }
[16:14:01.207]             else {
[16:14:01.207]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:01.207]             }
[16:14:01.207]             {
[16:14:01.207]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:01.207]                   0L) {
[16:14:01.207]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:01.207]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:01.207]                   base::options(opts)
[16:14:01.207]                 }
[16:14:01.207]                 {
[16:14:01.207]                   {
[16:14:01.207]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:01.207]                     NULL
[16:14:01.207]                   }
[16:14:01.207]                   options(future.plan = NULL)
[16:14:01.207]                   if (is.na(NA_character_)) 
[16:14:01.207]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.207]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:01.207]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:01.207]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:01.207]                     envir = parent.frame()) 
[16:14:01.207]                   {
[16:14:01.207]                     if (is.function(workers)) 
[16:14:01.207]                       workers <- workers()
[16:14:01.207]                     workers <- structure(as.integer(workers), 
[16:14:01.207]                       class = class(workers))
[16:14:01.207]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:01.207]                       workers >= 1)
[16:14:01.207]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:01.207]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:01.207]                     }
[16:14:01.207]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:01.207]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:01.207]                       envir = envir)
[16:14:01.207]                     if (!future$lazy) 
[16:14:01.207]                       future <- run(future)
[16:14:01.207]                     invisible(future)
[16:14:01.207]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:01.207]                 }
[16:14:01.207]             }
[16:14:01.207]         }
[16:14:01.207]     })
[16:14:01.207]     if (TRUE) {
[16:14:01.207]         base::sink(type = "output", split = FALSE)
[16:14:01.207]         if (TRUE) {
[16:14:01.207]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:01.207]         }
[16:14:01.207]         else {
[16:14:01.207]             ...future.result["stdout"] <- base::list(NULL)
[16:14:01.207]         }
[16:14:01.207]         base::close(...future.stdout)
[16:14:01.207]         ...future.stdout <- NULL
[16:14:01.207]     }
[16:14:01.207]     ...future.result$conditions <- ...future.conditions
[16:14:01.207]     ...future.result$finished <- base::Sys.time()
[16:14:01.207]     ...future.result
[16:14:01.207] }
[16:14:01.211] MultisessionFuture started
[16:14:01.211] - Launch lazy future ... done
[16:14:01.211] run() for ‘MultisessionFuture’ ... done
[16:14:01.211] getGlobalsAndPackages() ...
[16:14:01.212] Searching for globals...
[16:14:01.212] - globals found: [1] ‘{’
[16:14:01.212] Searching for globals ... DONE
[16:14:01.212] Resolving globals: FALSE
[16:14:01.213] 
[16:14:01.213] 
[16:14:01.213] getGlobalsAndPackages() ... DONE
[16:14:01.213] run() for ‘Future’ ...
[16:14:01.213] - state: ‘created’
[16:14:01.213] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:01.228] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:01.228] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:01.228]   - Field: ‘node’
[16:14:01.228]   - Field: ‘label’
[16:14:01.229]   - Field: ‘local’
[16:14:01.229]   - Field: ‘owner’
[16:14:01.229]   - Field: ‘envir’
[16:14:01.229]   - Field: ‘workers’
[16:14:01.229]   - Field: ‘packages’
[16:14:01.229]   - Field: ‘gc’
[16:14:01.229]   - Field: ‘conditions’
[16:14:01.229]   - Field: ‘persistent’
[16:14:01.229]   - Field: ‘expr’
[16:14:01.229]   - Field: ‘uuid’
[16:14:01.230]   - Field: ‘seed’
[16:14:01.230]   - Field: ‘version’
[16:14:01.230]   - Field: ‘result’
[16:14:01.230]   - Field: ‘asynchronous’
[16:14:01.230]   - Field: ‘calls’
[16:14:01.230]   - Field: ‘globals’
[16:14:01.230]   - Field: ‘stdout’
[16:14:01.230]   - Field: ‘earlySignal’
[16:14:01.230]   - Field: ‘lazy’
[16:14:01.230]   - Field: ‘state’
[16:14:01.230] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:01.231] - Launch lazy future ...
[16:14:01.231] Packages needed by the future expression (n = 0): <none>
[16:14:01.231] Packages needed by future strategies (n = 0): <none>
[16:14:01.231] {
[16:14:01.231]     {
[16:14:01.231]         {
[16:14:01.231]             ...future.startTime <- base::Sys.time()
[16:14:01.231]             {
[16:14:01.231]                 {
[16:14:01.231]                   {
[16:14:01.231]                     {
[16:14:01.231]                       base::local({
[16:14:01.231]                         has_future <- base::requireNamespace("future", 
[16:14:01.231]                           quietly = TRUE)
[16:14:01.231]                         if (has_future) {
[16:14:01.231]                           ns <- base::getNamespace("future")
[16:14:01.231]                           version <- ns[[".package"]][["version"]]
[16:14:01.231]                           if (is.null(version)) 
[16:14:01.231]                             version <- utils::packageVersion("future")
[16:14:01.231]                         }
[16:14:01.231]                         else {
[16:14:01.231]                           version <- NULL
[16:14:01.231]                         }
[16:14:01.231]                         if (!has_future || version < "1.8.0") {
[16:14:01.231]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:01.231]                             "", base::R.version$version.string), 
[16:14:01.231]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:01.231]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:01.231]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:01.231]                               "release", "version")], collapse = " "), 
[16:14:01.231]                             hostname = base::Sys.info()[["nodename"]])
[16:14:01.231]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:01.231]                             info)
[16:14:01.231]                           info <- base::paste(info, collapse = "; ")
[16:14:01.231]                           if (!has_future) {
[16:14:01.231]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:01.231]                               info)
[16:14:01.231]                           }
[16:14:01.231]                           else {
[16:14:01.231]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:01.231]                               info, version)
[16:14:01.231]                           }
[16:14:01.231]                           base::stop(msg)
[16:14:01.231]                         }
[16:14:01.231]                       })
[16:14:01.231]                     }
[16:14:01.231]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:01.231]                     base::options(mc.cores = 1L)
[16:14:01.231]                   }
[16:14:01.231]                   options(future.plan = NULL)
[16:14:01.231]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.231]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:01.231]                 }
[16:14:01.231]                 ...future.workdir <- getwd()
[16:14:01.231]             }
[16:14:01.231]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:01.231]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:01.231]         }
[16:14:01.231]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:01.231]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:01.231]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:01.231]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:01.231]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:01.231]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:01.231]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:01.231]             base::names(...future.oldOptions))
[16:14:01.231]     }
[16:14:01.231]     if (FALSE) {
[16:14:01.231]     }
[16:14:01.231]     else {
[16:14:01.231]         if (TRUE) {
[16:14:01.231]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:01.231]                 open = "w")
[16:14:01.231]         }
[16:14:01.231]         else {
[16:14:01.231]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:01.231]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:01.231]         }
[16:14:01.231]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:01.231]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:01.231]             base::sink(type = "output", split = FALSE)
[16:14:01.231]             base::close(...future.stdout)
[16:14:01.231]         }, add = TRUE)
[16:14:01.231]     }
[16:14:01.231]     ...future.frame <- base::sys.nframe()
[16:14:01.231]     ...future.conditions <- base::list()
[16:14:01.231]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:01.231]     if (FALSE) {
[16:14:01.231]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:01.231]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:01.231]     }
[16:14:01.231]     ...future.result <- base::tryCatch({
[16:14:01.231]         base::withCallingHandlers({
[16:14:01.231]             ...future.value <- base::withVisible(base::local({
[16:14:01.231]                 ...future.makeSendCondition <- local({
[16:14:01.231]                   sendCondition <- NULL
[16:14:01.231]                   function(frame = 1L) {
[16:14:01.231]                     if (is.function(sendCondition)) 
[16:14:01.231]                       return(sendCondition)
[16:14:01.231]                     ns <- getNamespace("parallel")
[16:14:01.231]                     if (exists("sendData", mode = "function", 
[16:14:01.231]                       envir = ns)) {
[16:14:01.231]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:01.231]                         envir = ns)
[16:14:01.231]                       envir <- sys.frame(frame)
[16:14:01.231]                       master <- NULL
[16:14:01.231]                       while (!identical(envir, .GlobalEnv) && 
[16:14:01.231]                         !identical(envir, emptyenv())) {
[16:14:01.231]                         if (exists("master", mode = "list", envir = envir, 
[16:14:01.231]                           inherits = FALSE)) {
[16:14:01.231]                           master <- get("master", mode = "list", 
[16:14:01.231]                             envir = envir, inherits = FALSE)
[16:14:01.231]                           if (inherits(master, c("SOCKnode", 
[16:14:01.231]                             "SOCK0node"))) {
[16:14:01.231]                             sendCondition <<- function(cond) {
[16:14:01.231]                               data <- list(type = "VALUE", value = cond, 
[16:14:01.231]                                 success = TRUE)
[16:14:01.231]                               parallel_sendData(master, data)
[16:14:01.231]                             }
[16:14:01.231]                             return(sendCondition)
[16:14:01.231]                           }
[16:14:01.231]                         }
[16:14:01.231]                         frame <- frame + 1L
[16:14:01.231]                         envir <- sys.frame(frame)
[16:14:01.231]                       }
[16:14:01.231]                     }
[16:14:01.231]                     sendCondition <<- function(cond) NULL
[16:14:01.231]                   }
[16:14:01.231]                 })
[16:14:01.231]                 withCallingHandlers({
[16:14:01.231]                   {
[16:14:01.231]                     2
[16:14:01.231]                   }
[16:14:01.231]                 }, immediateCondition = function(cond) {
[16:14:01.231]                   sendCondition <- ...future.makeSendCondition()
[16:14:01.231]                   sendCondition(cond)
[16:14:01.231]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.231]                   {
[16:14:01.231]                     inherits <- base::inherits
[16:14:01.231]                     invokeRestart <- base::invokeRestart
[16:14:01.231]                     is.null <- base::is.null
[16:14:01.231]                     muffled <- FALSE
[16:14:01.231]                     if (inherits(cond, "message")) {
[16:14:01.231]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:01.231]                       if (muffled) 
[16:14:01.231]                         invokeRestart("muffleMessage")
[16:14:01.231]                     }
[16:14:01.231]                     else if (inherits(cond, "warning")) {
[16:14:01.231]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:01.231]                       if (muffled) 
[16:14:01.231]                         invokeRestart("muffleWarning")
[16:14:01.231]                     }
[16:14:01.231]                     else if (inherits(cond, "condition")) {
[16:14:01.231]                       if (!is.null(pattern)) {
[16:14:01.231]                         computeRestarts <- base::computeRestarts
[16:14:01.231]                         grepl <- base::grepl
[16:14:01.231]                         restarts <- computeRestarts(cond)
[16:14:01.231]                         for (restart in restarts) {
[16:14:01.231]                           name <- restart$name
[16:14:01.231]                           if (is.null(name)) 
[16:14:01.231]                             next
[16:14:01.231]                           if (!grepl(pattern, name)) 
[16:14:01.231]                             next
[16:14:01.231]                           invokeRestart(restart)
[16:14:01.231]                           muffled <- TRUE
[16:14:01.231]                           break
[16:14:01.231]                         }
[16:14:01.231]                       }
[16:14:01.231]                     }
[16:14:01.231]                     invisible(muffled)
[16:14:01.231]                   }
[16:14:01.231]                   muffleCondition(cond)
[16:14:01.231]                 })
[16:14:01.231]             }))
[16:14:01.231]             future::FutureResult(value = ...future.value$value, 
[16:14:01.231]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.231]                   ...future.rng), globalenv = if (FALSE) 
[16:14:01.231]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:01.231]                     ...future.globalenv.names))
[16:14:01.231]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:01.231]         }, condition = base::local({
[16:14:01.231]             c <- base::c
[16:14:01.231]             inherits <- base::inherits
[16:14:01.231]             invokeRestart <- base::invokeRestart
[16:14:01.231]             length <- base::length
[16:14:01.231]             list <- base::list
[16:14:01.231]             seq.int <- base::seq.int
[16:14:01.231]             signalCondition <- base::signalCondition
[16:14:01.231]             sys.calls <- base::sys.calls
[16:14:01.231]             `[[` <- base::`[[`
[16:14:01.231]             `+` <- base::`+`
[16:14:01.231]             `<<-` <- base::`<<-`
[16:14:01.231]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:01.231]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:01.231]                   3L)]
[16:14:01.231]             }
[16:14:01.231]             function(cond) {
[16:14:01.231]                 is_error <- inherits(cond, "error")
[16:14:01.231]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:01.231]                   NULL)
[16:14:01.231]                 if (is_error) {
[16:14:01.231]                   sessionInformation <- function() {
[16:14:01.231]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:01.231]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:01.231]                       search = base::search(), system = base::Sys.info())
[16:14:01.231]                   }
[16:14:01.231]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.231]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:01.231]                     cond$call), session = sessionInformation(), 
[16:14:01.231]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:01.231]                   signalCondition(cond)
[16:14:01.231]                 }
[16:14:01.231]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:01.231]                 "immediateCondition"))) {
[16:14:01.231]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:01.231]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.231]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:01.231]                   if (TRUE && !signal) {
[16:14:01.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.231]                     {
[16:14:01.231]                       inherits <- base::inherits
[16:14:01.231]                       invokeRestart <- base::invokeRestart
[16:14:01.231]                       is.null <- base::is.null
[16:14:01.231]                       muffled <- FALSE
[16:14:01.231]                       if (inherits(cond, "message")) {
[16:14:01.231]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.231]                         if (muffled) 
[16:14:01.231]                           invokeRestart("muffleMessage")
[16:14:01.231]                       }
[16:14:01.231]                       else if (inherits(cond, "warning")) {
[16:14:01.231]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.231]                         if (muffled) 
[16:14:01.231]                           invokeRestart("muffleWarning")
[16:14:01.231]                       }
[16:14:01.231]                       else if (inherits(cond, "condition")) {
[16:14:01.231]                         if (!is.null(pattern)) {
[16:14:01.231]                           computeRestarts <- base::computeRestarts
[16:14:01.231]                           grepl <- base::grepl
[16:14:01.231]                           restarts <- computeRestarts(cond)
[16:14:01.231]                           for (restart in restarts) {
[16:14:01.231]                             name <- restart$name
[16:14:01.231]                             if (is.null(name)) 
[16:14:01.231]                               next
[16:14:01.231]                             if (!grepl(pattern, name)) 
[16:14:01.231]                               next
[16:14:01.231]                             invokeRestart(restart)
[16:14:01.231]                             muffled <- TRUE
[16:14:01.231]                             break
[16:14:01.231]                           }
[16:14:01.231]                         }
[16:14:01.231]                       }
[16:14:01.231]                       invisible(muffled)
[16:14:01.231]                     }
[16:14:01.231]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.231]                   }
[16:14:01.231]                 }
[16:14:01.231]                 else {
[16:14:01.231]                   if (TRUE) {
[16:14:01.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.231]                     {
[16:14:01.231]                       inherits <- base::inherits
[16:14:01.231]                       invokeRestart <- base::invokeRestart
[16:14:01.231]                       is.null <- base::is.null
[16:14:01.231]                       muffled <- FALSE
[16:14:01.231]                       if (inherits(cond, "message")) {
[16:14:01.231]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.231]                         if (muffled) 
[16:14:01.231]                           invokeRestart("muffleMessage")
[16:14:01.231]                       }
[16:14:01.231]                       else if (inherits(cond, "warning")) {
[16:14:01.231]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.231]                         if (muffled) 
[16:14:01.231]                           invokeRestart("muffleWarning")
[16:14:01.231]                       }
[16:14:01.231]                       else if (inherits(cond, "condition")) {
[16:14:01.231]                         if (!is.null(pattern)) {
[16:14:01.231]                           computeRestarts <- base::computeRestarts
[16:14:01.231]                           grepl <- base::grepl
[16:14:01.231]                           restarts <- computeRestarts(cond)
[16:14:01.231]                           for (restart in restarts) {
[16:14:01.231]                             name <- restart$name
[16:14:01.231]                             if (is.null(name)) 
[16:14:01.231]                               next
[16:14:01.231]                             if (!grepl(pattern, name)) 
[16:14:01.231]                               next
[16:14:01.231]                             invokeRestart(restart)
[16:14:01.231]                             muffled <- TRUE
[16:14:01.231]                             break
[16:14:01.231]                           }
[16:14:01.231]                         }
[16:14:01.231]                       }
[16:14:01.231]                       invisible(muffled)
[16:14:01.231]                     }
[16:14:01.231]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.231]                   }
[16:14:01.231]                 }
[16:14:01.231]             }
[16:14:01.231]         }))
[16:14:01.231]     }, error = function(ex) {
[16:14:01.231]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:01.231]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.231]                 ...future.rng), started = ...future.startTime, 
[16:14:01.231]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:01.231]             version = "1.8"), class = "FutureResult")
[16:14:01.231]     }, finally = {
[16:14:01.231]         if (!identical(...future.workdir, getwd())) 
[16:14:01.231]             setwd(...future.workdir)
[16:14:01.231]         {
[16:14:01.231]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:01.231]                 ...future.oldOptions$nwarnings <- NULL
[16:14:01.231]             }
[16:14:01.231]             base::options(...future.oldOptions)
[16:14:01.231]             if (.Platform$OS.type == "windows") {
[16:14:01.231]                 old_names <- names(...future.oldEnvVars)
[16:14:01.231]                 envs <- base::Sys.getenv()
[16:14:01.231]                 names <- names(envs)
[16:14:01.231]                 common <- intersect(names, old_names)
[16:14:01.231]                 added <- setdiff(names, old_names)
[16:14:01.231]                 removed <- setdiff(old_names, names)
[16:14:01.231]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:01.231]                   envs[common]]
[16:14:01.231]                 NAMES <- toupper(changed)
[16:14:01.231]                 args <- list()
[16:14:01.231]                 for (kk in seq_along(NAMES)) {
[16:14:01.231]                   name <- changed[[kk]]
[16:14:01.231]                   NAME <- NAMES[[kk]]
[16:14:01.231]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.231]                     next
[16:14:01.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.231]                 }
[16:14:01.231]                 NAMES <- toupper(added)
[16:14:01.231]                 for (kk in seq_along(NAMES)) {
[16:14:01.231]                   name <- added[[kk]]
[16:14:01.231]                   NAME <- NAMES[[kk]]
[16:14:01.231]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.231]                     next
[16:14:01.231]                   args[[name]] <- ""
[16:14:01.231]                 }
[16:14:01.231]                 NAMES <- toupper(removed)
[16:14:01.231]                 for (kk in seq_along(NAMES)) {
[16:14:01.231]                   name <- removed[[kk]]
[16:14:01.231]                   NAME <- NAMES[[kk]]
[16:14:01.231]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.231]                     next
[16:14:01.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.231]                 }
[16:14:01.231]                 if (length(args) > 0) 
[16:14:01.231]                   base::do.call(base::Sys.setenv, args = args)
[16:14:01.231]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:01.231]             }
[16:14:01.231]             else {
[16:14:01.231]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:01.231]             }
[16:14:01.231]             {
[16:14:01.231]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:01.231]                   0L) {
[16:14:01.231]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:01.231]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:01.231]                   base::options(opts)
[16:14:01.231]                 }
[16:14:01.231]                 {
[16:14:01.231]                   {
[16:14:01.231]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:01.231]                     NULL
[16:14:01.231]                   }
[16:14:01.231]                   options(future.plan = NULL)
[16:14:01.231]                   if (is.na(NA_character_)) 
[16:14:01.231]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.231]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:01.231]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:01.231]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:01.231]                     envir = parent.frame()) 
[16:14:01.231]                   {
[16:14:01.231]                     if (is.function(workers)) 
[16:14:01.231]                       workers <- workers()
[16:14:01.231]                     workers <- structure(as.integer(workers), 
[16:14:01.231]                       class = class(workers))
[16:14:01.231]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:01.231]                       workers >= 1)
[16:14:01.231]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:01.231]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:01.231]                     }
[16:14:01.231]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:01.231]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:01.231]                       envir = envir)
[16:14:01.231]                     if (!future$lazy) 
[16:14:01.231]                       future <- run(future)
[16:14:01.231]                     invisible(future)
[16:14:01.231]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:01.231]                 }
[16:14:01.231]             }
[16:14:01.231]         }
[16:14:01.231]     })
[16:14:01.231]     if (TRUE) {
[16:14:01.231]         base::sink(type = "output", split = FALSE)
[16:14:01.231]         if (TRUE) {
[16:14:01.231]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:01.231]         }
[16:14:01.231]         else {
[16:14:01.231]             ...future.result["stdout"] <- base::list(NULL)
[16:14:01.231]         }
[16:14:01.231]         base::close(...future.stdout)
[16:14:01.231]         ...future.stdout <- NULL
[16:14:01.231]     }
[16:14:01.231]     ...future.result$conditions <- ...future.conditions
[16:14:01.231]     ...future.result$finished <- base::Sys.time()
[16:14:01.231]     ...future.result
[16:14:01.231] }
[16:14:01.235] MultisessionFuture started
[16:14:01.235] - Launch lazy future ... done
[16:14:01.235] run() for ‘MultisessionFuture’ ... done
[16:14:01.236] resolve() on environment ...
[16:14:01.236]  recursive: 0
[16:14:01.236]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[16:14:01.257]  length: 2 (resolved future 3)
[16:14:01.268] receiveMessageFromWorker() for ClusterFuture ...
[16:14:01.268] - Validating connection of MultisessionFuture
[16:14:01.269] - received message: FutureResult
[16:14:01.269] - Received FutureResult
[16:14:01.269] - Erased future from FutureRegistry
[16:14:01.269] result() for ClusterFuture ...
[16:14:01.269] - result already collected: FutureResult
[16:14:01.269] result() for ClusterFuture ... done
[16:14:01.269] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:01.269] Future #1
[16:14:01.270]  length: 1 (resolved future 1)
[16:14:01.291] receiveMessageFromWorker() for ClusterFuture ...
[16:14:01.291] - Validating connection of MultisessionFuture
[16:14:01.291] - received message: FutureResult
[16:14:01.291] - Received FutureResult
[16:14:01.291] - Erased future from FutureRegistry
[16:14:01.292] result() for ClusterFuture ...
[16:14:01.292] - result already collected: FutureResult
[16:14:01.292] result() for ClusterFuture ... done
[16:14:01.292] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:01.292] Future #2
[16:14:01.292]  length: 0 (resolved future 2)
[16:14:01.292] resolve() on environment ... DONE
[16:14:01.293] getGlobalsAndPackages() ...
[16:14:01.293] Searching for globals...
[16:14:01.293] - globals found: [1] ‘{’
[16:14:01.294] Searching for globals ... DONE
[16:14:01.294] Resolving globals: FALSE
[16:14:01.294] 
[16:14:01.294] 
[16:14:01.294] getGlobalsAndPackages() ... DONE
[16:14:01.294] run() for ‘Future’ ...
[16:14:01.294] - state: ‘created’
[16:14:01.295] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:01.309] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:01.309] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:01.309]   - Field: ‘node’
[16:14:01.310]   - Field: ‘label’
[16:14:01.310]   - Field: ‘local’
[16:14:01.310]   - Field: ‘owner’
[16:14:01.310]   - Field: ‘envir’
[16:14:01.310]   - Field: ‘workers’
[16:14:01.310]   - Field: ‘packages’
[16:14:01.310]   - Field: ‘gc’
[16:14:01.310]   - Field: ‘conditions’
[16:14:01.310]   - Field: ‘persistent’
[16:14:01.310]   - Field: ‘expr’
[16:14:01.311]   - Field: ‘uuid’
[16:14:01.311]   - Field: ‘seed’
[16:14:01.311]   - Field: ‘version’
[16:14:01.311]   - Field: ‘result’
[16:14:01.311]   - Field: ‘asynchronous’
[16:14:01.311]   - Field: ‘calls’
[16:14:01.311]   - Field: ‘globals’
[16:14:01.311]   - Field: ‘stdout’
[16:14:01.311]   - Field: ‘earlySignal’
[16:14:01.311]   - Field: ‘lazy’
[16:14:01.311]   - Field: ‘state’
[16:14:01.312] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:01.312] - Launch lazy future ...
[16:14:01.312] Packages needed by the future expression (n = 0): <none>
[16:14:01.312] Packages needed by future strategies (n = 0): <none>
[16:14:01.313] {
[16:14:01.313]     {
[16:14:01.313]         {
[16:14:01.313]             ...future.startTime <- base::Sys.time()
[16:14:01.313]             {
[16:14:01.313]                 {
[16:14:01.313]                   {
[16:14:01.313]                     {
[16:14:01.313]                       base::local({
[16:14:01.313]                         has_future <- base::requireNamespace("future", 
[16:14:01.313]                           quietly = TRUE)
[16:14:01.313]                         if (has_future) {
[16:14:01.313]                           ns <- base::getNamespace("future")
[16:14:01.313]                           version <- ns[[".package"]][["version"]]
[16:14:01.313]                           if (is.null(version)) 
[16:14:01.313]                             version <- utils::packageVersion("future")
[16:14:01.313]                         }
[16:14:01.313]                         else {
[16:14:01.313]                           version <- NULL
[16:14:01.313]                         }
[16:14:01.313]                         if (!has_future || version < "1.8.0") {
[16:14:01.313]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:01.313]                             "", base::R.version$version.string), 
[16:14:01.313]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:01.313]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:01.313]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:01.313]                               "release", "version")], collapse = " "), 
[16:14:01.313]                             hostname = base::Sys.info()[["nodename"]])
[16:14:01.313]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:01.313]                             info)
[16:14:01.313]                           info <- base::paste(info, collapse = "; ")
[16:14:01.313]                           if (!has_future) {
[16:14:01.313]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:01.313]                               info)
[16:14:01.313]                           }
[16:14:01.313]                           else {
[16:14:01.313]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:01.313]                               info, version)
[16:14:01.313]                           }
[16:14:01.313]                           base::stop(msg)
[16:14:01.313]                         }
[16:14:01.313]                       })
[16:14:01.313]                     }
[16:14:01.313]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:01.313]                     base::options(mc.cores = 1L)
[16:14:01.313]                   }
[16:14:01.313]                   options(future.plan = NULL)
[16:14:01.313]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.313]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:01.313]                 }
[16:14:01.313]                 ...future.workdir <- getwd()
[16:14:01.313]             }
[16:14:01.313]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:01.313]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:01.313]         }
[16:14:01.313]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:01.313]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:01.313]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:01.313]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:01.313]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:01.313]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:01.313]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:01.313]             base::names(...future.oldOptions))
[16:14:01.313]     }
[16:14:01.313]     if (FALSE) {
[16:14:01.313]     }
[16:14:01.313]     else {
[16:14:01.313]         if (TRUE) {
[16:14:01.313]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:01.313]                 open = "w")
[16:14:01.313]         }
[16:14:01.313]         else {
[16:14:01.313]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:01.313]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:01.313]         }
[16:14:01.313]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:01.313]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:01.313]             base::sink(type = "output", split = FALSE)
[16:14:01.313]             base::close(...future.stdout)
[16:14:01.313]         }, add = TRUE)
[16:14:01.313]     }
[16:14:01.313]     ...future.frame <- base::sys.nframe()
[16:14:01.313]     ...future.conditions <- base::list()
[16:14:01.313]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:01.313]     if (FALSE) {
[16:14:01.313]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:01.313]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:01.313]     }
[16:14:01.313]     ...future.result <- base::tryCatch({
[16:14:01.313]         base::withCallingHandlers({
[16:14:01.313]             ...future.value <- base::withVisible(base::local({
[16:14:01.313]                 ...future.makeSendCondition <- local({
[16:14:01.313]                   sendCondition <- NULL
[16:14:01.313]                   function(frame = 1L) {
[16:14:01.313]                     if (is.function(sendCondition)) 
[16:14:01.313]                       return(sendCondition)
[16:14:01.313]                     ns <- getNamespace("parallel")
[16:14:01.313]                     if (exists("sendData", mode = "function", 
[16:14:01.313]                       envir = ns)) {
[16:14:01.313]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:01.313]                         envir = ns)
[16:14:01.313]                       envir <- sys.frame(frame)
[16:14:01.313]                       master <- NULL
[16:14:01.313]                       while (!identical(envir, .GlobalEnv) && 
[16:14:01.313]                         !identical(envir, emptyenv())) {
[16:14:01.313]                         if (exists("master", mode = "list", envir = envir, 
[16:14:01.313]                           inherits = FALSE)) {
[16:14:01.313]                           master <- get("master", mode = "list", 
[16:14:01.313]                             envir = envir, inherits = FALSE)
[16:14:01.313]                           if (inherits(master, c("SOCKnode", 
[16:14:01.313]                             "SOCK0node"))) {
[16:14:01.313]                             sendCondition <<- function(cond) {
[16:14:01.313]                               data <- list(type = "VALUE", value = cond, 
[16:14:01.313]                                 success = TRUE)
[16:14:01.313]                               parallel_sendData(master, data)
[16:14:01.313]                             }
[16:14:01.313]                             return(sendCondition)
[16:14:01.313]                           }
[16:14:01.313]                         }
[16:14:01.313]                         frame <- frame + 1L
[16:14:01.313]                         envir <- sys.frame(frame)
[16:14:01.313]                       }
[16:14:01.313]                     }
[16:14:01.313]                     sendCondition <<- function(cond) NULL
[16:14:01.313]                   }
[16:14:01.313]                 })
[16:14:01.313]                 withCallingHandlers({
[16:14:01.313]                   {
[16:14:01.313]                     1
[16:14:01.313]                   }
[16:14:01.313]                 }, immediateCondition = function(cond) {
[16:14:01.313]                   sendCondition <- ...future.makeSendCondition()
[16:14:01.313]                   sendCondition(cond)
[16:14:01.313]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.313]                   {
[16:14:01.313]                     inherits <- base::inherits
[16:14:01.313]                     invokeRestart <- base::invokeRestart
[16:14:01.313]                     is.null <- base::is.null
[16:14:01.313]                     muffled <- FALSE
[16:14:01.313]                     if (inherits(cond, "message")) {
[16:14:01.313]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:01.313]                       if (muffled) 
[16:14:01.313]                         invokeRestart("muffleMessage")
[16:14:01.313]                     }
[16:14:01.313]                     else if (inherits(cond, "warning")) {
[16:14:01.313]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:01.313]                       if (muffled) 
[16:14:01.313]                         invokeRestart("muffleWarning")
[16:14:01.313]                     }
[16:14:01.313]                     else if (inherits(cond, "condition")) {
[16:14:01.313]                       if (!is.null(pattern)) {
[16:14:01.313]                         computeRestarts <- base::computeRestarts
[16:14:01.313]                         grepl <- base::grepl
[16:14:01.313]                         restarts <- computeRestarts(cond)
[16:14:01.313]                         for (restart in restarts) {
[16:14:01.313]                           name <- restart$name
[16:14:01.313]                           if (is.null(name)) 
[16:14:01.313]                             next
[16:14:01.313]                           if (!grepl(pattern, name)) 
[16:14:01.313]                             next
[16:14:01.313]                           invokeRestart(restart)
[16:14:01.313]                           muffled <- TRUE
[16:14:01.313]                           break
[16:14:01.313]                         }
[16:14:01.313]                       }
[16:14:01.313]                     }
[16:14:01.313]                     invisible(muffled)
[16:14:01.313]                   }
[16:14:01.313]                   muffleCondition(cond)
[16:14:01.313]                 })
[16:14:01.313]             }))
[16:14:01.313]             future::FutureResult(value = ...future.value$value, 
[16:14:01.313]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.313]                   ...future.rng), globalenv = if (FALSE) 
[16:14:01.313]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:01.313]                     ...future.globalenv.names))
[16:14:01.313]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:01.313]         }, condition = base::local({
[16:14:01.313]             c <- base::c
[16:14:01.313]             inherits <- base::inherits
[16:14:01.313]             invokeRestart <- base::invokeRestart
[16:14:01.313]             length <- base::length
[16:14:01.313]             list <- base::list
[16:14:01.313]             seq.int <- base::seq.int
[16:14:01.313]             signalCondition <- base::signalCondition
[16:14:01.313]             sys.calls <- base::sys.calls
[16:14:01.313]             `[[` <- base::`[[`
[16:14:01.313]             `+` <- base::`+`
[16:14:01.313]             `<<-` <- base::`<<-`
[16:14:01.313]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:01.313]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:01.313]                   3L)]
[16:14:01.313]             }
[16:14:01.313]             function(cond) {
[16:14:01.313]                 is_error <- inherits(cond, "error")
[16:14:01.313]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:01.313]                   NULL)
[16:14:01.313]                 if (is_error) {
[16:14:01.313]                   sessionInformation <- function() {
[16:14:01.313]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:01.313]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:01.313]                       search = base::search(), system = base::Sys.info())
[16:14:01.313]                   }
[16:14:01.313]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.313]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:01.313]                     cond$call), session = sessionInformation(), 
[16:14:01.313]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:01.313]                   signalCondition(cond)
[16:14:01.313]                 }
[16:14:01.313]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:01.313]                 "immediateCondition"))) {
[16:14:01.313]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:01.313]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.313]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:01.313]                   if (TRUE && !signal) {
[16:14:01.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.313]                     {
[16:14:01.313]                       inherits <- base::inherits
[16:14:01.313]                       invokeRestart <- base::invokeRestart
[16:14:01.313]                       is.null <- base::is.null
[16:14:01.313]                       muffled <- FALSE
[16:14:01.313]                       if (inherits(cond, "message")) {
[16:14:01.313]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.313]                         if (muffled) 
[16:14:01.313]                           invokeRestart("muffleMessage")
[16:14:01.313]                       }
[16:14:01.313]                       else if (inherits(cond, "warning")) {
[16:14:01.313]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.313]                         if (muffled) 
[16:14:01.313]                           invokeRestart("muffleWarning")
[16:14:01.313]                       }
[16:14:01.313]                       else if (inherits(cond, "condition")) {
[16:14:01.313]                         if (!is.null(pattern)) {
[16:14:01.313]                           computeRestarts <- base::computeRestarts
[16:14:01.313]                           grepl <- base::grepl
[16:14:01.313]                           restarts <- computeRestarts(cond)
[16:14:01.313]                           for (restart in restarts) {
[16:14:01.313]                             name <- restart$name
[16:14:01.313]                             if (is.null(name)) 
[16:14:01.313]                               next
[16:14:01.313]                             if (!grepl(pattern, name)) 
[16:14:01.313]                               next
[16:14:01.313]                             invokeRestart(restart)
[16:14:01.313]                             muffled <- TRUE
[16:14:01.313]                             break
[16:14:01.313]                           }
[16:14:01.313]                         }
[16:14:01.313]                       }
[16:14:01.313]                       invisible(muffled)
[16:14:01.313]                     }
[16:14:01.313]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.313]                   }
[16:14:01.313]                 }
[16:14:01.313]                 else {
[16:14:01.313]                   if (TRUE) {
[16:14:01.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.313]                     {
[16:14:01.313]                       inherits <- base::inherits
[16:14:01.313]                       invokeRestart <- base::invokeRestart
[16:14:01.313]                       is.null <- base::is.null
[16:14:01.313]                       muffled <- FALSE
[16:14:01.313]                       if (inherits(cond, "message")) {
[16:14:01.313]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.313]                         if (muffled) 
[16:14:01.313]                           invokeRestart("muffleMessage")
[16:14:01.313]                       }
[16:14:01.313]                       else if (inherits(cond, "warning")) {
[16:14:01.313]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.313]                         if (muffled) 
[16:14:01.313]                           invokeRestart("muffleWarning")
[16:14:01.313]                       }
[16:14:01.313]                       else if (inherits(cond, "condition")) {
[16:14:01.313]                         if (!is.null(pattern)) {
[16:14:01.313]                           computeRestarts <- base::computeRestarts
[16:14:01.313]                           grepl <- base::grepl
[16:14:01.313]                           restarts <- computeRestarts(cond)
[16:14:01.313]                           for (restart in restarts) {
[16:14:01.313]                             name <- restart$name
[16:14:01.313]                             if (is.null(name)) 
[16:14:01.313]                               next
[16:14:01.313]                             if (!grepl(pattern, name)) 
[16:14:01.313]                               next
[16:14:01.313]                             invokeRestart(restart)
[16:14:01.313]                             muffled <- TRUE
[16:14:01.313]                             break
[16:14:01.313]                           }
[16:14:01.313]                         }
[16:14:01.313]                       }
[16:14:01.313]                       invisible(muffled)
[16:14:01.313]                     }
[16:14:01.313]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.313]                   }
[16:14:01.313]                 }
[16:14:01.313]             }
[16:14:01.313]         }))
[16:14:01.313]     }, error = function(ex) {
[16:14:01.313]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:01.313]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.313]                 ...future.rng), started = ...future.startTime, 
[16:14:01.313]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:01.313]             version = "1.8"), class = "FutureResult")
[16:14:01.313]     }, finally = {
[16:14:01.313]         if (!identical(...future.workdir, getwd())) 
[16:14:01.313]             setwd(...future.workdir)
[16:14:01.313]         {
[16:14:01.313]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:01.313]                 ...future.oldOptions$nwarnings <- NULL
[16:14:01.313]             }
[16:14:01.313]             base::options(...future.oldOptions)
[16:14:01.313]             if (.Platform$OS.type == "windows") {
[16:14:01.313]                 old_names <- names(...future.oldEnvVars)
[16:14:01.313]                 envs <- base::Sys.getenv()
[16:14:01.313]                 names <- names(envs)
[16:14:01.313]                 common <- intersect(names, old_names)
[16:14:01.313]                 added <- setdiff(names, old_names)
[16:14:01.313]                 removed <- setdiff(old_names, names)
[16:14:01.313]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:01.313]                   envs[common]]
[16:14:01.313]                 NAMES <- toupper(changed)
[16:14:01.313]                 args <- list()
[16:14:01.313]                 for (kk in seq_along(NAMES)) {
[16:14:01.313]                   name <- changed[[kk]]
[16:14:01.313]                   NAME <- NAMES[[kk]]
[16:14:01.313]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.313]                     next
[16:14:01.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.313]                 }
[16:14:01.313]                 NAMES <- toupper(added)
[16:14:01.313]                 for (kk in seq_along(NAMES)) {
[16:14:01.313]                   name <- added[[kk]]
[16:14:01.313]                   NAME <- NAMES[[kk]]
[16:14:01.313]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.313]                     next
[16:14:01.313]                   args[[name]] <- ""
[16:14:01.313]                 }
[16:14:01.313]                 NAMES <- toupper(removed)
[16:14:01.313]                 for (kk in seq_along(NAMES)) {
[16:14:01.313]                   name <- removed[[kk]]
[16:14:01.313]                   NAME <- NAMES[[kk]]
[16:14:01.313]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.313]                     next
[16:14:01.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.313]                 }
[16:14:01.313]                 if (length(args) > 0) 
[16:14:01.313]                   base::do.call(base::Sys.setenv, args = args)
[16:14:01.313]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:01.313]             }
[16:14:01.313]             else {
[16:14:01.313]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:01.313]             }
[16:14:01.313]             {
[16:14:01.313]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:01.313]                   0L) {
[16:14:01.313]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:01.313]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:01.313]                   base::options(opts)
[16:14:01.313]                 }
[16:14:01.313]                 {
[16:14:01.313]                   {
[16:14:01.313]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:01.313]                     NULL
[16:14:01.313]                   }
[16:14:01.313]                   options(future.plan = NULL)
[16:14:01.313]                   if (is.na(NA_character_)) 
[16:14:01.313]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.313]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:01.313]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:01.313]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:01.313]                     envir = parent.frame()) 
[16:14:01.313]                   {
[16:14:01.313]                     if (is.function(workers)) 
[16:14:01.313]                       workers <- workers()
[16:14:01.313]                     workers <- structure(as.integer(workers), 
[16:14:01.313]                       class = class(workers))
[16:14:01.313]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:01.313]                       workers >= 1)
[16:14:01.313]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:01.313]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:01.313]                     }
[16:14:01.313]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:01.313]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:01.313]                       envir = envir)
[16:14:01.313]                     if (!future$lazy) 
[16:14:01.313]                       future <- run(future)
[16:14:01.313]                     invisible(future)
[16:14:01.313]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:01.313]                 }
[16:14:01.313]             }
[16:14:01.313]         }
[16:14:01.313]     })
[16:14:01.313]     if (TRUE) {
[16:14:01.313]         base::sink(type = "output", split = FALSE)
[16:14:01.313]         if (TRUE) {
[16:14:01.313]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:01.313]         }
[16:14:01.313]         else {
[16:14:01.313]             ...future.result["stdout"] <- base::list(NULL)
[16:14:01.313]         }
[16:14:01.313]         base::close(...future.stdout)
[16:14:01.313]         ...future.stdout <- NULL
[16:14:01.313]     }
[16:14:01.313]     ...future.result$conditions <- ...future.conditions
[16:14:01.313]     ...future.result$finished <- base::Sys.time()
[16:14:01.313]     ...future.result
[16:14:01.313] }
[16:14:01.316] MultisessionFuture started
[16:14:01.316] - Launch lazy future ... done
[16:14:01.316] run() for ‘MultisessionFuture’ ... done
[16:14:01.316] getGlobalsAndPackages() ...
[16:14:01.316] Searching for globals...
[16:14:01.317] - globals found: [1] ‘{’
[16:14:01.317] Searching for globals ... DONE
[16:14:01.317] Resolving globals: FALSE
[16:14:01.318] 
[16:14:01.318] 
[16:14:01.318] getGlobalsAndPackages() ... DONE
[16:14:01.318] run() for ‘Future’ ...
[16:14:01.318] - state: ‘created’
[16:14:01.318] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:01.333] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:01.333] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:01.333]   - Field: ‘node’
[16:14:01.333]   - Field: ‘label’
[16:14:01.333]   - Field: ‘local’
[16:14:01.333]   - Field: ‘owner’
[16:14:01.334]   - Field: ‘envir’
[16:14:01.334]   - Field: ‘workers’
[16:14:01.334]   - Field: ‘packages’
[16:14:01.334]   - Field: ‘gc’
[16:14:01.334]   - Field: ‘conditions’
[16:14:01.334]   - Field: ‘persistent’
[16:14:01.334]   - Field: ‘expr’
[16:14:01.334]   - Field: ‘uuid’
[16:14:01.334]   - Field: ‘seed’
[16:14:01.334]   - Field: ‘version’
[16:14:01.334]   - Field: ‘result’
[16:14:01.335]   - Field: ‘asynchronous’
[16:14:01.335]   - Field: ‘calls’
[16:14:01.335]   - Field: ‘globals’
[16:14:01.335]   - Field: ‘stdout’
[16:14:01.335]   - Field: ‘earlySignal’
[16:14:01.335]   - Field: ‘lazy’
[16:14:01.335]   - Field: ‘state’
[16:14:01.335] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:01.335] - Launch lazy future ...
[16:14:01.336] Packages needed by the future expression (n = 0): <none>
[16:14:01.336] Packages needed by future strategies (n = 0): <none>
[16:14:01.336] {
[16:14:01.336]     {
[16:14:01.336]         {
[16:14:01.336]             ...future.startTime <- base::Sys.time()
[16:14:01.336]             {
[16:14:01.336]                 {
[16:14:01.336]                   {
[16:14:01.336]                     {
[16:14:01.336]                       base::local({
[16:14:01.336]                         has_future <- base::requireNamespace("future", 
[16:14:01.336]                           quietly = TRUE)
[16:14:01.336]                         if (has_future) {
[16:14:01.336]                           ns <- base::getNamespace("future")
[16:14:01.336]                           version <- ns[[".package"]][["version"]]
[16:14:01.336]                           if (is.null(version)) 
[16:14:01.336]                             version <- utils::packageVersion("future")
[16:14:01.336]                         }
[16:14:01.336]                         else {
[16:14:01.336]                           version <- NULL
[16:14:01.336]                         }
[16:14:01.336]                         if (!has_future || version < "1.8.0") {
[16:14:01.336]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:01.336]                             "", base::R.version$version.string), 
[16:14:01.336]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:01.336]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:01.336]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:01.336]                               "release", "version")], collapse = " "), 
[16:14:01.336]                             hostname = base::Sys.info()[["nodename"]])
[16:14:01.336]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:01.336]                             info)
[16:14:01.336]                           info <- base::paste(info, collapse = "; ")
[16:14:01.336]                           if (!has_future) {
[16:14:01.336]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:01.336]                               info)
[16:14:01.336]                           }
[16:14:01.336]                           else {
[16:14:01.336]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:01.336]                               info, version)
[16:14:01.336]                           }
[16:14:01.336]                           base::stop(msg)
[16:14:01.336]                         }
[16:14:01.336]                       })
[16:14:01.336]                     }
[16:14:01.336]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:01.336]                     base::options(mc.cores = 1L)
[16:14:01.336]                   }
[16:14:01.336]                   options(future.plan = NULL)
[16:14:01.336]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.336]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:01.336]                 }
[16:14:01.336]                 ...future.workdir <- getwd()
[16:14:01.336]             }
[16:14:01.336]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:01.336]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:01.336]         }
[16:14:01.336]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:01.336]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:01.336]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:01.336]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:01.336]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:01.336]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:01.336]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:01.336]             base::names(...future.oldOptions))
[16:14:01.336]     }
[16:14:01.336]     if (FALSE) {
[16:14:01.336]     }
[16:14:01.336]     else {
[16:14:01.336]         if (TRUE) {
[16:14:01.336]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:01.336]                 open = "w")
[16:14:01.336]         }
[16:14:01.336]         else {
[16:14:01.336]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:01.336]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:01.336]         }
[16:14:01.336]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:01.336]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:01.336]             base::sink(type = "output", split = FALSE)
[16:14:01.336]             base::close(...future.stdout)
[16:14:01.336]         }, add = TRUE)
[16:14:01.336]     }
[16:14:01.336]     ...future.frame <- base::sys.nframe()
[16:14:01.336]     ...future.conditions <- base::list()
[16:14:01.336]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:01.336]     if (FALSE) {
[16:14:01.336]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:01.336]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:01.336]     }
[16:14:01.336]     ...future.result <- base::tryCatch({
[16:14:01.336]         base::withCallingHandlers({
[16:14:01.336]             ...future.value <- base::withVisible(base::local({
[16:14:01.336]                 ...future.makeSendCondition <- local({
[16:14:01.336]                   sendCondition <- NULL
[16:14:01.336]                   function(frame = 1L) {
[16:14:01.336]                     if (is.function(sendCondition)) 
[16:14:01.336]                       return(sendCondition)
[16:14:01.336]                     ns <- getNamespace("parallel")
[16:14:01.336]                     if (exists("sendData", mode = "function", 
[16:14:01.336]                       envir = ns)) {
[16:14:01.336]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:01.336]                         envir = ns)
[16:14:01.336]                       envir <- sys.frame(frame)
[16:14:01.336]                       master <- NULL
[16:14:01.336]                       while (!identical(envir, .GlobalEnv) && 
[16:14:01.336]                         !identical(envir, emptyenv())) {
[16:14:01.336]                         if (exists("master", mode = "list", envir = envir, 
[16:14:01.336]                           inherits = FALSE)) {
[16:14:01.336]                           master <- get("master", mode = "list", 
[16:14:01.336]                             envir = envir, inherits = FALSE)
[16:14:01.336]                           if (inherits(master, c("SOCKnode", 
[16:14:01.336]                             "SOCK0node"))) {
[16:14:01.336]                             sendCondition <<- function(cond) {
[16:14:01.336]                               data <- list(type = "VALUE", value = cond, 
[16:14:01.336]                                 success = TRUE)
[16:14:01.336]                               parallel_sendData(master, data)
[16:14:01.336]                             }
[16:14:01.336]                             return(sendCondition)
[16:14:01.336]                           }
[16:14:01.336]                         }
[16:14:01.336]                         frame <- frame + 1L
[16:14:01.336]                         envir <- sys.frame(frame)
[16:14:01.336]                       }
[16:14:01.336]                     }
[16:14:01.336]                     sendCondition <<- function(cond) NULL
[16:14:01.336]                   }
[16:14:01.336]                 })
[16:14:01.336]                 withCallingHandlers({
[16:14:01.336]                   {
[16:14:01.336]                     2
[16:14:01.336]                   }
[16:14:01.336]                 }, immediateCondition = function(cond) {
[16:14:01.336]                   sendCondition <- ...future.makeSendCondition()
[16:14:01.336]                   sendCondition(cond)
[16:14:01.336]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.336]                   {
[16:14:01.336]                     inherits <- base::inherits
[16:14:01.336]                     invokeRestart <- base::invokeRestart
[16:14:01.336]                     is.null <- base::is.null
[16:14:01.336]                     muffled <- FALSE
[16:14:01.336]                     if (inherits(cond, "message")) {
[16:14:01.336]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:01.336]                       if (muffled) 
[16:14:01.336]                         invokeRestart("muffleMessage")
[16:14:01.336]                     }
[16:14:01.336]                     else if (inherits(cond, "warning")) {
[16:14:01.336]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:01.336]                       if (muffled) 
[16:14:01.336]                         invokeRestart("muffleWarning")
[16:14:01.336]                     }
[16:14:01.336]                     else if (inherits(cond, "condition")) {
[16:14:01.336]                       if (!is.null(pattern)) {
[16:14:01.336]                         computeRestarts <- base::computeRestarts
[16:14:01.336]                         grepl <- base::grepl
[16:14:01.336]                         restarts <- computeRestarts(cond)
[16:14:01.336]                         for (restart in restarts) {
[16:14:01.336]                           name <- restart$name
[16:14:01.336]                           if (is.null(name)) 
[16:14:01.336]                             next
[16:14:01.336]                           if (!grepl(pattern, name)) 
[16:14:01.336]                             next
[16:14:01.336]                           invokeRestart(restart)
[16:14:01.336]                           muffled <- TRUE
[16:14:01.336]                           break
[16:14:01.336]                         }
[16:14:01.336]                       }
[16:14:01.336]                     }
[16:14:01.336]                     invisible(muffled)
[16:14:01.336]                   }
[16:14:01.336]                   muffleCondition(cond)
[16:14:01.336]                 })
[16:14:01.336]             }))
[16:14:01.336]             future::FutureResult(value = ...future.value$value, 
[16:14:01.336]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.336]                   ...future.rng), globalenv = if (FALSE) 
[16:14:01.336]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:01.336]                     ...future.globalenv.names))
[16:14:01.336]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:01.336]         }, condition = base::local({
[16:14:01.336]             c <- base::c
[16:14:01.336]             inherits <- base::inherits
[16:14:01.336]             invokeRestart <- base::invokeRestart
[16:14:01.336]             length <- base::length
[16:14:01.336]             list <- base::list
[16:14:01.336]             seq.int <- base::seq.int
[16:14:01.336]             signalCondition <- base::signalCondition
[16:14:01.336]             sys.calls <- base::sys.calls
[16:14:01.336]             `[[` <- base::`[[`
[16:14:01.336]             `+` <- base::`+`
[16:14:01.336]             `<<-` <- base::`<<-`
[16:14:01.336]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:01.336]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:01.336]                   3L)]
[16:14:01.336]             }
[16:14:01.336]             function(cond) {
[16:14:01.336]                 is_error <- inherits(cond, "error")
[16:14:01.336]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:01.336]                   NULL)
[16:14:01.336]                 if (is_error) {
[16:14:01.336]                   sessionInformation <- function() {
[16:14:01.336]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:01.336]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:01.336]                       search = base::search(), system = base::Sys.info())
[16:14:01.336]                   }
[16:14:01.336]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.336]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:01.336]                     cond$call), session = sessionInformation(), 
[16:14:01.336]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:01.336]                   signalCondition(cond)
[16:14:01.336]                 }
[16:14:01.336]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:01.336]                 "immediateCondition"))) {
[16:14:01.336]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:01.336]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.336]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:01.336]                   if (TRUE && !signal) {
[16:14:01.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.336]                     {
[16:14:01.336]                       inherits <- base::inherits
[16:14:01.336]                       invokeRestart <- base::invokeRestart
[16:14:01.336]                       is.null <- base::is.null
[16:14:01.336]                       muffled <- FALSE
[16:14:01.336]                       if (inherits(cond, "message")) {
[16:14:01.336]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.336]                         if (muffled) 
[16:14:01.336]                           invokeRestart("muffleMessage")
[16:14:01.336]                       }
[16:14:01.336]                       else if (inherits(cond, "warning")) {
[16:14:01.336]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.336]                         if (muffled) 
[16:14:01.336]                           invokeRestart("muffleWarning")
[16:14:01.336]                       }
[16:14:01.336]                       else if (inherits(cond, "condition")) {
[16:14:01.336]                         if (!is.null(pattern)) {
[16:14:01.336]                           computeRestarts <- base::computeRestarts
[16:14:01.336]                           grepl <- base::grepl
[16:14:01.336]                           restarts <- computeRestarts(cond)
[16:14:01.336]                           for (restart in restarts) {
[16:14:01.336]                             name <- restart$name
[16:14:01.336]                             if (is.null(name)) 
[16:14:01.336]                               next
[16:14:01.336]                             if (!grepl(pattern, name)) 
[16:14:01.336]                               next
[16:14:01.336]                             invokeRestart(restart)
[16:14:01.336]                             muffled <- TRUE
[16:14:01.336]                             break
[16:14:01.336]                           }
[16:14:01.336]                         }
[16:14:01.336]                       }
[16:14:01.336]                       invisible(muffled)
[16:14:01.336]                     }
[16:14:01.336]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.336]                   }
[16:14:01.336]                 }
[16:14:01.336]                 else {
[16:14:01.336]                   if (TRUE) {
[16:14:01.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.336]                     {
[16:14:01.336]                       inherits <- base::inherits
[16:14:01.336]                       invokeRestart <- base::invokeRestart
[16:14:01.336]                       is.null <- base::is.null
[16:14:01.336]                       muffled <- FALSE
[16:14:01.336]                       if (inherits(cond, "message")) {
[16:14:01.336]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.336]                         if (muffled) 
[16:14:01.336]                           invokeRestart("muffleMessage")
[16:14:01.336]                       }
[16:14:01.336]                       else if (inherits(cond, "warning")) {
[16:14:01.336]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.336]                         if (muffled) 
[16:14:01.336]                           invokeRestart("muffleWarning")
[16:14:01.336]                       }
[16:14:01.336]                       else if (inherits(cond, "condition")) {
[16:14:01.336]                         if (!is.null(pattern)) {
[16:14:01.336]                           computeRestarts <- base::computeRestarts
[16:14:01.336]                           grepl <- base::grepl
[16:14:01.336]                           restarts <- computeRestarts(cond)
[16:14:01.336]                           for (restart in restarts) {
[16:14:01.336]                             name <- restart$name
[16:14:01.336]                             if (is.null(name)) 
[16:14:01.336]                               next
[16:14:01.336]                             if (!grepl(pattern, name)) 
[16:14:01.336]                               next
[16:14:01.336]                             invokeRestart(restart)
[16:14:01.336]                             muffled <- TRUE
[16:14:01.336]                             break
[16:14:01.336]                           }
[16:14:01.336]                         }
[16:14:01.336]                       }
[16:14:01.336]                       invisible(muffled)
[16:14:01.336]                     }
[16:14:01.336]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.336]                   }
[16:14:01.336]                 }
[16:14:01.336]             }
[16:14:01.336]         }))
[16:14:01.336]     }, error = function(ex) {
[16:14:01.336]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:01.336]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.336]                 ...future.rng), started = ...future.startTime, 
[16:14:01.336]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:01.336]             version = "1.8"), class = "FutureResult")
[16:14:01.336]     }, finally = {
[16:14:01.336]         if (!identical(...future.workdir, getwd())) 
[16:14:01.336]             setwd(...future.workdir)
[16:14:01.336]         {
[16:14:01.336]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:01.336]                 ...future.oldOptions$nwarnings <- NULL
[16:14:01.336]             }
[16:14:01.336]             base::options(...future.oldOptions)
[16:14:01.336]             if (.Platform$OS.type == "windows") {
[16:14:01.336]                 old_names <- names(...future.oldEnvVars)
[16:14:01.336]                 envs <- base::Sys.getenv()
[16:14:01.336]                 names <- names(envs)
[16:14:01.336]                 common <- intersect(names, old_names)
[16:14:01.336]                 added <- setdiff(names, old_names)
[16:14:01.336]                 removed <- setdiff(old_names, names)
[16:14:01.336]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:01.336]                   envs[common]]
[16:14:01.336]                 NAMES <- toupper(changed)
[16:14:01.336]                 args <- list()
[16:14:01.336]                 for (kk in seq_along(NAMES)) {
[16:14:01.336]                   name <- changed[[kk]]
[16:14:01.336]                   NAME <- NAMES[[kk]]
[16:14:01.336]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.336]                     next
[16:14:01.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.336]                 }
[16:14:01.336]                 NAMES <- toupper(added)
[16:14:01.336]                 for (kk in seq_along(NAMES)) {
[16:14:01.336]                   name <- added[[kk]]
[16:14:01.336]                   NAME <- NAMES[[kk]]
[16:14:01.336]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.336]                     next
[16:14:01.336]                   args[[name]] <- ""
[16:14:01.336]                 }
[16:14:01.336]                 NAMES <- toupper(removed)
[16:14:01.336]                 for (kk in seq_along(NAMES)) {
[16:14:01.336]                   name <- removed[[kk]]
[16:14:01.336]                   NAME <- NAMES[[kk]]
[16:14:01.336]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.336]                     next
[16:14:01.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.336]                 }
[16:14:01.336]                 if (length(args) > 0) 
[16:14:01.336]                   base::do.call(base::Sys.setenv, args = args)
[16:14:01.336]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:01.336]             }
[16:14:01.336]             else {
[16:14:01.336]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:01.336]             }
[16:14:01.336]             {
[16:14:01.336]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:01.336]                   0L) {
[16:14:01.336]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:01.336]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:01.336]                   base::options(opts)
[16:14:01.336]                 }
[16:14:01.336]                 {
[16:14:01.336]                   {
[16:14:01.336]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:01.336]                     NULL
[16:14:01.336]                   }
[16:14:01.336]                   options(future.plan = NULL)
[16:14:01.336]                   if (is.na(NA_character_)) 
[16:14:01.336]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.336]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:01.336]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:01.336]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:01.336]                     envir = parent.frame()) 
[16:14:01.336]                   {
[16:14:01.336]                     if (is.function(workers)) 
[16:14:01.336]                       workers <- workers()
[16:14:01.336]                     workers <- structure(as.integer(workers), 
[16:14:01.336]                       class = class(workers))
[16:14:01.336]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:01.336]                       workers >= 1)
[16:14:01.336]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:01.336]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:01.336]                     }
[16:14:01.336]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:01.336]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:01.336]                       envir = envir)
[16:14:01.336]                     if (!future$lazy) 
[16:14:01.336]                       future <- run(future)
[16:14:01.336]                     invisible(future)
[16:14:01.336]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:01.336]                 }
[16:14:01.336]             }
[16:14:01.336]         }
[16:14:01.336]     })
[16:14:01.336]     if (TRUE) {
[16:14:01.336]         base::sink(type = "output", split = FALSE)
[16:14:01.336]         if (TRUE) {
[16:14:01.336]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:01.336]         }
[16:14:01.336]         else {
[16:14:01.336]             ...future.result["stdout"] <- base::list(NULL)
[16:14:01.336]         }
[16:14:01.336]         base::close(...future.stdout)
[16:14:01.336]         ...future.stdout <- NULL
[16:14:01.336]     }
[16:14:01.336]     ...future.result$conditions <- ...future.conditions
[16:14:01.336]     ...future.result$finished <- base::Sys.time()
[16:14:01.336]     ...future.result
[16:14:01.336] }
[16:14:01.340] MultisessionFuture started
[16:14:01.340] - Launch lazy future ... done
[16:14:01.340] run() for ‘MultisessionFuture’ ... done
[16:14:01.341] resolve() on environment ...
[16:14:01.341]  recursive: 0
[16:14:01.341]  elements: [3] ‘a’
[16:14:01.362]  length: 2 (resolved future 3)
[16:14:01.373] receiveMessageFromWorker() for ClusterFuture ...
[16:14:01.373] - Validating connection of MultisessionFuture
[16:14:01.373] - received message: FutureResult
[16:14:01.373] - Received FutureResult
[16:14:01.374] - Erased future from FutureRegistry
[16:14:01.374] result() for ClusterFuture ...
[16:14:01.374] - result already collected: FutureResult
[16:14:01.374] result() for ClusterFuture ... done
[16:14:01.374] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:01.374] Future #1
[16:14:01.374]  length: 1 (resolved future 1)
[16:14:01.395] receiveMessageFromWorker() for ClusterFuture ...
[16:14:01.395] - Validating connection of MultisessionFuture
[16:14:01.396] - received message: FutureResult
[16:14:01.396] - Received FutureResult
[16:14:01.396] - Erased future from FutureRegistry
[16:14:01.396] result() for ClusterFuture ...
[16:14:01.396] - result already collected: FutureResult
[16:14:01.396] result() for ClusterFuture ... done
[16:14:01.396] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:01.396] Future #2
[16:14:01.396]  length: 0 (resolved future 2)
[16:14:01.397] resolve() on environment ... DONE
[16:14:01.397] resolve() on environment ...
[16:14:01.397]  recursive: 0
[16:14:01.398]  elements: [3] ‘b’
[16:14:01.398] Future #1
[16:14:01.398]  length: 2 (resolved future 1)
[16:14:01.398] Future #2
[16:14:01.398]  length: 1 (resolved future 2)
[16:14:01.401]  length: 0 (resolved future 3)
[16:14:01.401] resolve() on environment ... DONE
[16:14:01.402] resolve() on environment ...
[16:14:01.402]  recursive: 0
[16:14:01.402]  elements: [3] ‘c’
[16:14:01.403] Future #1
[16:14:01.403]  length: 2 (resolved future 1)
[16:14:01.403] Future #2
[16:14:01.403]  length: 1 (resolved future 2)
[16:14:01.403]  length: 0 (resolved future 3)
[16:14:01.403] resolve() on environment ... DONE
[16:14:01.404] resolve() on environment ...
[16:14:01.404]  recursive: 0
[16:14:01.404]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[16:14:01.404] Future #1
[16:14:01.404] result() for ClusterFuture ...
[16:14:01.404] - result already collected: FutureResult
[16:14:01.405] result() for ClusterFuture ... done
[16:14:01.405] result() for ClusterFuture ...
[16:14:01.405] - result already collected: FutureResult
[16:14:01.405] result() for ClusterFuture ... done
[16:14:01.405]  length: 2 (resolved future 1)
[16:14:01.405] Future #2
[16:14:01.405] result() for ClusterFuture ...
[16:14:01.405] - result already collected: FutureResult
[16:14:01.405] result() for ClusterFuture ... done
[16:14:01.405] result() for ClusterFuture ...
[16:14:01.405] - result already collected: FutureResult
[16:14:01.406] result() for ClusterFuture ... done
[16:14:01.406]  length: 1 (resolved future 2)
[16:14:01.406]  length: 0 (resolved future 3)
[16:14:01.406] resolve() on environment ... DONE
[16:14:01.406] resolve() on environment ...
[16:14:01.406]  recursive: 99
[16:14:01.407]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[16:14:01.407] Future #1
[16:14:01.407] result() for ClusterFuture ...
[16:14:01.407] - result already collected: FutureResult
[16:14:01.407] result() for ClusterFuture ... done
[16:14:01.407] result() for ClusterFuture ...
[16:14:01.407] - result already collected: FutureResult
[16:14:01.408] result() for ClusterFuture ... done
[16:14:01.408] A MultisessionFuture was resolved
[16:14:01.408]  length: 2 (resolved future 1)
[16:14:01.408] Future #2
[16:14:01.408] result() for ClusterFuture ...
[16:14:01.408] - result already collected: FutureResult
[16:14:01.408] result() for ClusterFuture ... done
[16:14:01.408] result() for ClusterFuture ...
[16:14:01.408] - result already collected: FutureResult
[16:14:01.408] result() for ClusterFuture ... done
[16:14:01.409] A MultisessionFuture was resolved
[16:14:01.409]  length: 1 (resolved future 2)
[16:14:01.409]  length: 0 (resolved future 3)
[16:14:01.409] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[16:14:01.410] resolve() on list environment ...
[16:14:01.410]  recursive: 0
[16:14:01.410]  length: 2
[16:14:01.410]  elements: ‘a’, ‘b’
[16:14:01.410]  length: 1 (resolved future 1)
[16:14:01.411]  length: 0 (resolved future 2)
[16:14:01.411] resolve() on list environment ... DONE
[16:14:01.411] getGlobalsAndPackages() ...
[16:14:01.411] Searching for globals...
[16:14:01.411] 
[16:14:01.411] Searching for globals ... DONE
[16:14:01.411] - globals: [0] <none>
[16:14:01.411] getGlobalsAndPackages() ... DONE
[16:14:01.412] run() for ‘Future’ ...
[16:14:01.412] - state: ‘created’
[16:14:01.412] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:01.426] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:01.426] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:01.426]   - Field: ‘node’
[16:14:01.426]   - Field: ‘label’
[16:14:01.426]   - Field: ‘local’
[16:14:01.426]   - Field: ‘owner’
[16:14:01.427]   - Field: ‘envir’
[16:14:01.427]   - Field: ‘workers’
[16:14:01.427]   - Field: ‘packages’
[16:14:01.427]   - Field: ‘gc’
[16:14:01.427]   - Field: ‘conditions’
[16:14:01.427]   - Field: ‘persistent’
[16:14:01.427]   - Field: ‘expr’
[16:14:01.427]   - Field: ‘uuid’
[16:14:01.427]   - Field: ‘seed’
[16:14:01.427]   - Field: ‘version’
[16:14:01.427]   - Field: ‘result’
[16:14:01.428]   - Field: ‘asynchronous’
[16:14:01.428]   - Field: ‘calls’
[16:14:01.428]   - Field: ‘globals’
[16:14:01.428]   - Field: ‘stdout’
[16:14:01.428]   - Field: ‘earlySignal’
[16:14:01.428]   - Field: ‘lazy’
[16:14:01.428]   - Field: ‘state’
[16:14:01.428] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:01.428] - Launch lazy future ...
[16:14:01.429] Packages needed by the future expression (n = 0): <none>
[16:14:01.429] Packages needed by future strategies (n = 0): <none>
[16:14:01.429] {
[16:14:01.429]     {
[16:14:01.429]         {
[16:14:01.429]             ...future.startTime <- base::Sys.time()
[16:14:01.429]             {
[16:14:01.429]                 {
[16:14:01.429]                   {
[16:14:01.429]                     {
[16:14:01.429]                       base::local({
[16:14:01.429]                         has_future <- base::requireNamespace("future", 
[16:14:01.429]                           quietly = TRUE)
[16:14:01.429]                         if (has_future) {
[16:14:01.429]                           ns <- base::getNamespace("future")
[16:14:01.429]                           version <- ns[[".package"]][["version"]]
[16:14:01.429]                           if (is.null(version)) 
[16:14:01.429]                             version <- utils::packageVersion("future")
[16:14:01.429]                         }
[16:14:01.429]                         else {
[16:14:01.429]                           version <- NULL
[16:14:01.429]                         }
[16:14:01.429]                         if (!has_future || version < "1.8.0") {
[16:14:01.429]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:01.429]                             "", base::R.version$version.string), 
[16:14:01.429]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:01.429]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:01.429]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:01.429]                               "release", "version")], collapse = " "), 
[16:14:01.429]                             hostname = base::Sys.info()[["nodename"]])
[16:14:01.429]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:01.429]                             info)
[16:14:01.429]                           info <- base::paste(info, collapse = "; ")
[16:14:01.429]                           if (!has_future) {
[16:14:01.429]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:01.429]                               info)
[16:14:01.429]                           }
[16:14:01.429]                           else {
[16:14:01.429]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:01.429]                               info, version)
[16:14:01.429]                           }
[16:14:01.429]                           base::stop(msg)
[16:14:01.429]                         }
[16:14:01.429]                       })
[16:14:01.429]                     }
[16:14:01.429]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:01.429]                     base::options(mc.cores = 1L)
[16:14:01.429]                   }
[16:14:01.429]                   options(future.plan = NULL)
[16:14:01.429]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.429]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:01.429]                 }
[16:14:01.429]                 ...future.workdir <- getwd()
[16:14:01.429]             }
[16:14:01.429]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:01.429]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:01.429]         }
[16:14:01.429]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:01.429]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:01.429]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:01.429]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:01.429]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:01.429]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:01.429]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:01.429]             base::names(...future.oldOptions))
[16:14:01.429]     }
[16:14:01.429]     if (FALSE) {
[16:14:01.429]     }
[16:14:01.429]     else {
[16:14:01.429]         if (TRUE) {
[16:14:01.429]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:01.429]                 open = "w")
[16:14:01.429]         }
[16:14:01.429]         else {
[16:14:01.429]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:01.429]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:01.429]         }
[16:14:01.429]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:01.429]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:01.429]             base::sink(type = "output", split = FALSE)
[16:14:01.429]             base::close(...future.stdout)
[16:14:01.429]         }, add = TRUE)
[16:14:01.429]     }
[16:14:01.429]     ...future.frame <- base::sys.nframe()
[16:14:01.429]     ...future.conditions <- base::list()
[16:14:01.429]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:01.429]     if (FALSE) {
[16:14:01.429]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:01.429]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:01.429]     }
[16:14:01.429]     ...future.result <- base::tryCatch({
[16:14:01.429]         base::withCallingHandlers({
[16:14:01.429]             ...future.value <- base::withVisible(base::local({
[16:14:01.429]                 ...future.makeSendCondition <- local({
[16:14:01.429]                   sendCondition <- NULL
[16:14:01.429]                   function(frame = 1L) {
[16:14:01.429]                     if (is.function(sendCondition)) 
[16:14:01.429]                       return(sendCondition)
[16:14:01.429]                     ns <- getNamespace("parallel")
[16:14:01.429]                     if (exists("sendData", mode = "function", 
[16:14:01.429]                       envir = ns)) {
[16:14:01.429]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:01.429]                         envir = ns)
[16:14:01.429]                       envir <- sys.frame(frame)
[16:14:01.429]                       master <- NULL
[16:14:01.429]                       while (!identical(envir, .GlobalEnv) && 
[16:14:01.429]                         !identical(envir, emptyenv())) {
[16:14:01.429]                         if (exists("master", mode = "list", envir = envir, 
[16:14:01.429]                           inherits = FALSE)) {
[16:14:01.429]                           master <- get("master", mode = "list", 
[16:14:01.429]                             envir = envir, inherits = FALSE)
[16:14:01.429]                           if (inherits(master, c("SOCKnode", 
[16:14:01.429]                             "SOCK0node"))) {
[16:14:01.429]                             sendCondition <<- function(cond) {
[16:14:01.429]                               data <- list(type = "VALUE", value = cond, 
[16:14:01.429]                                 success = TRUE)
[16:14:01.429]                               parallel_sendData(master, data)
[16:14:01.429]                             }
[16:14:01.429]                             return(sendCondition)
[16:14:01.429]                           }
[16:14:01.429]                         }
[16:14:01.429]                         frame <- frame + 1L
[16:14:01.429]                         envir <- sys.frame(frame)
[16:14:01.429]                       }
[16:14:01.429]                     }
[16:14:01.429]                     sendCondition <<- function(cond) NULL
[16:14:01.429]                   }
[16:14:01.429]                 })
[16:14:01.429]                 withCallingHandlers({
[16:14:01.429]                   1
[16:14:01.429]                 }, immediateCondition = function(cond) {
[16:14:01.429]                   sendCondition <- ...future.makeSendCondition()
[16:14:01.429]                   sendCondition(cond)
[16:14:01.429]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.429]                   {
[16:14:01.429]                     inherits <- base::inherits
[16:14:01.429]                     invokeRestart <- base::invokeRestart
[16:14:01.429]                     is.null <- base::is.null
[16:14:01.429]                     muffled <- FALSE
[16:14:01.429]                     if (inherits(cond, "message")) {
[16:14:01.429]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:01.429]                       if (muffled) 
[16:14:01.429]                         invokeRestart("muffleMessage")
[16:14:01.429]                     }
[16:14:01.429]                     else if (inherits(cond, "warning")) {
[16:14:01.429]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:01.429]                       if (muffled) 
[16:14:01.429]                         invokeRestart("muffleWarning")
[16:14:01.429]                     }
[16:14:01.429]                     else if (inherits(cond, "condition")) {
[16:14:01.429]                       if (!is.null(pattern)) {
[16:14:01.429]                         computeRestarts <- base::computeRestarts
[16:14:01.429]                         grepl <- base::grepl
[16:14:01.429]                         restarts <- computeRestarts(cond)
[16:14:01.429]                         for (restart in restarts) {
[16:14:01.429]                           name <- restart$name
[16:14:01.429]                           if (is.null(name)) 
[16:14:01.429]                             next
[16:14:01.429]                           if (!grepl(pattern, name)) 
[16:14:01.429]                             next
[16:14:01.429]                           invokeRestart(restart)
[16:14:01.429]                           muffled <- TRUE
[16:14:01.429]                           break
[16:14:01.429]                         }
[16:14:01.429]                       }
[16:14:01.429]                     }
[16:14:01.429]                     invisible(muffled)
[16:14:01.429]                   }
[16:14:01.429]                   muffleCondition(cond)
[16:14:01.429]                 })
[16:14:01.429]             }))
[16:14:01.429]             future::FutureResult(value = ...future.value$value, 
[16:14:01.429]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.429]                   ...future.rng), globalenv = if (FALSE) 
[16:14:01.429]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:01.429]                     ...future.globalenv.names))
[16:14:01.429]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:01.429]         }, condition = base::local({
[16:14:01.429]             c <- base::c
[16:14:01.429]             inherits <- base::inherits
[16:14:01.429]             invokeRestart <- base::invokeRestart
[16:14:01.429]             length <- base::length
[16:14:01.429]             list <- base::list
[16:14:01.429]             seq.int <- base::seq.int
[16:14:01.429]             signalCondition <- base::signalCondition
[16:14:01.429]             sys.calls <- base::sys.calls
[16:14:01.429]             `[[` <- base::`[[`
[16:14:01.429]             `+` <- base::`+`
[16:14:01.429]             `<<-` <- base::`<<-`
[16:14:01.429]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:01.429]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:01.429]                   3L)]
[16:14:01.429]             }
[16:14:01.429]             function(cond) {
[16:14:01.429]                 is_error <- inherits(cond, "error")
[16:14:01.429]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:01.429]                   NULL)
[16:14:01.429]                 if (is_error) {
[16:14:01.429]                   sessionInformation <- function() {
[16:14:01.429]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:01.429]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:01.429]                       search = base::search(), system = base::Sys.info())
[16:14:01.429]                   }
[16:14:01.429]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.429]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:01.429]                     cond$call), session = sessionInformation(), 
[16:14:01.429]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:01.429]                   signalCondition(cond)
[16:14:01.429]                 }
[16:14:01.429]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:01.429]                 "immediateCondition"))) {
[16:14:01.429]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:01.429]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.429]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:01.429]                   if (TRUE && !signal) {
[16:14:01.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.429]                     {
[16:14:01.429]                       inherits <- base::inherits
[16:14:01.429]                       invokeRestart <- base::invokeRestart
[16:14:01.429]                       is.null <- base::is.null
[16:14:01.429]                       muffled <- FALSE
[16:14:01.429]                       if (inherits(cond, "message")) {
[16:14:01.429]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.429]                         if (muffled) 
[16:14:01.429]                           invokeRestart("muffleMessage")
[16:14:01.429]                       }
[16:14:01.429]                       else if (inherits(cond, "warning")) {
[16:14:01.429]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.429]                         if (muffled) 
[16:14:01.429]                           invokeRestart("muffleWarning")
[16:14:01.429]                       }
[16:14:01.429]                       else if (inherits(cond, "condition")) {
[16:14:01.429]                         if (!is.null(pattern)) {
[16:14:01.429]                           computeRestarts <- base::computeRestarts
[16:14:01.429]                           grepl <- base::grepl
[16:14:01.429]                           restarts <- computeRestarts(cond)
[16:14:01.429]                           for (restart in restarts) {
[16:14:01.429]                             name <- restart$name
[16:14:01.429]                             if (is.null(name)) 
[16:14:01.429]                               next
[16:14:01.429]                             if (!grepl(pattern, name)) 
[16:14:01.429]                               next
[16:14:01.429]                             invokeRestart(restart)
[16:14:01.429]                             muffled <- TRUE
[16:14:01.429]                             break
[16:14:01.429]                           }
[16:14:01.429]                         }
[16:14:01.429]                       }
[16:14:01.429]                       invisible(muffled)
[16:14:01.429]                     }
[16:14:01.429]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.429]                   }
[16:14:01.429]                 }
[16:14:01.429]                 else {
[16:14:01.429]                   if (TRUE) {
[16:14:01.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.429]                     {
[16:14:01.429]                       inherits <- base::inherits
[16:14:01.429]                       invokeRestart <- base::invokeRestart
[16:14:01.429]                       is.null <- base::is.null
[16:14:01.429]                       muffled <- FALSE
[16:14:01.429]                       if (inherits(cond, "message")) {
[16:14:01.429]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.429]                         if (muffled) 
[16:14:01.429]                           invokeRestart("muffleMessage")
[16:14:01.429]                       }
[16:14:01.429]                       else if (inherits(cond, "warning")) {
[16:14:01.429]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.429]                         if (muffled) 
[16:14:01.429]                           invokeRestart("muffleWarning")
[16:14:01.429]                       }
[16:14:01.429]                       else if (inherits(cond, "condition")) {
[16:14:01.429]                         if (!is.null(pattern)) {
[16:14:01.429]                           computeRestarts <- base::computeRestarts
[16:14:01.429]                           grepl <- base::grepl
[16:14:01.429]                           restarts <- computeRestarts(cond)
[16:14:01.429]                           for (restart in restarts) {
[16:14:01.429]                             name <- restart$name
[16:14:01.429]                             if (is.null(name)) 
[16:14:01.429]                               next
[16:14:01.429]                             if (!grepl(pattern, name)) 
[16:14:01.429]                               next
[16:14:01.429]                             invokeRestart(restart)
[16:14:01.429]                             muffled <- TRUE
[16:14:01.429]                             break
[16:14:01.429]                           }
[16:14:01.429]                         }
[16:14:01.429]                       }
[16:14:01.429]                       invisible(muffled)
[16:14:01.429]                     }
[16:14:01.429]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.429]                   }
[16:14:01.429]                 }
[16:14:01.429]             }
[16:14:01.429]         }))
[16:14:01.429]     }, error = function(ex) {
[16:14:01.429]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:01.429]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.429]                 ...future.rng), started = ...future.startTime, 
[16:14:01.429]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:01.429]             version = "1.8"), class = "FutureResult")
[16:14:01.429]     }, finally = {
[16:14:01.429]         if (!identical(...future.workdir, getwd())) 
[16:14:01.429]             setwd(...future.workdir)
[16:14:01.429]         {
[16:14:01.429]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:01.429]                 ...future.oldOptions$nwarnings <- NULL
[16:14:01.429]             }
[16:14:01.429]             base::options(...future.oldOptions)
[16:14:01.429]             if (.Platform$OS.type == "windows") {
[16:14:01.429]                 old_names <- names(...future.oldEnvVars)
[16:14:01.429]                 envs <- base::Sys.getenv()
[16:14:01.429]                 names <- names(envs)
[16:14:01.429]                 common <- intersect(names, old_names)
[16:14:01.429]                 added <- setdiff(names, old_names)
[16:14:01.429]                 removed <- setdiff(old_names, names)
[16:14:01.429]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:01.429]                   envs[common]]
[16:14:01.429]                 NAMES <- toupper(changed)
[16:14:01.429]                 args <- list()
[16:14:01.429]                 for (kk in seq_along(NAMES)) {
[16:14:01.429]                   name <- changed[[kk]]
[16:14:01.429]                   NAME <- NAMES[[kk]]
[16:14:01.429]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.429]                     next
[16:14:01.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.429]                 }
[16:14:01.429]                 NAMES <- toupper(added)
[16:14:01.429]                 for (kk in seq_along(NAMES)) {
[16:14:01.429]                   name <- added[[kk]]
[16:14:01.429]                   NAME <- NAMES[[kk]]
[16:14:01.429]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.429]                     next
[16:14:01.429]                   args[[name]] <- ""
[16:14:01.429]                 }
[16:14:01.429]                 NAMES <- toupper(removed)
[16:14:01.429]                 for (kk in seq_along(NAMES)) {
[16:14:01.429]                   name <- removed[[kk]]
[16:14:01.429]                   NAME <- NAMES[[kk]]
[16:14:01.429]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.429]                     next
[16:14:01.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.429]                 }
[16:14:01.429]                 if (length(args) > 0) 
[16:14:01.429]                   base::do.call(base::Sys.setenv, args = args)
[16:14:01.429]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:01.429]             }
[16:14:01.429]             else {
[16:14:01.429]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:01.429]             }
[16:14:01.429]             {
[16:14:01.429]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:01.429]                   0L) {
[16:14:01.429]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:01.429]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:01.429]                   base::options(opts)
[16:14:01.429]                 }
[16:14:01.429]                 {
[16:14:01.429]                   {
[16:14:01.429]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:01.429]                     NULL
[16:14:01.429]                   }
[16:14:01.429]                   options(future.plan = NULL)
[16:14:01.429]                   if (is.na(NA_character_)) 
[16:14:01.429]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.429]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:01.429]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:01.429]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:01.429]                     envir = parent.frame()) 
[16:14:01.429]                   {
[16:14:01.429]                     if (is.function(workers)) 
[16:14:01.429]                       workers <- workers()
[16:14:01.429]                     workers <- structure(as.integer(workers), 
[16:14:01.429]                       class = class(workers))
[16:14:01.429]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:01.429]                       workers >= 1)
[16:14:01.429]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:01.429]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:01.429]                     }
[16:14:01.429]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:01.429]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:01.429]                       envir = envir)
[16:14:01.429]                     if (!future$lazy) 
[16:14:01.429]                       future <- run(future)
[16:14:01.429]                     invisible(future)
[16:14:01.429]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:01.429]                 }
[16:14:01.429]             }
[16:14:01.429]         }
[16:14:01.429]     })
[16:14:01.429]     if (TRUE) {
[16:14:01.429]         base::sink(type = "output", split = FALSE)
[16:14:01.429]         if (TRUE) {
[16:14:01.429]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:01.429]         }
[16:14:01.429]         else {
[16:14:01.429]             ...future.result["stdout"] <- base::list(NULL)
[16:14:01.429]         }
[16:14:01.429]         base::close(...future.stdout)
[16:14:01.429]         ...future.stdout <- NULL
[16:14:01.429]     }
[16:14:01.429]     ...future.result$conditions <- ...future.conditions
[16:14:01.429]     ...future.result$finished <- base::Sys.time()
[16:14:01.429]     ...future.result
[16:14:01.429] }
[16:14:01.432] MultisessionFuture started
[16:14:01.432] - Launch lazy future ... done
[16:14:01.433] run() for ‘MultisessionFuture’ ... done
[16:14:01.433] getGlobalsAndPackages() ...
[16:14:01.433] Searching for globals...
[16:14:01.433] 
[16:14:01.433] Searching for globals ... DONE
[16:14:01.433] - globals: [0] <none>
[16:14:01.433] getGlobalsAndPackages() ... DONE
[16:14:01.434] run() for ‘Future’ ...
[16:14:01.434] - state: ‘created’
[16:14:01.434] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:01.449] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:01.449] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:01.449]   - Field: ‘node’
[16:14:01.449]   - Field: ‘label’
[16:14:01.449]   - Field: ‘local’
[16:14:01.449]   - Field: ‘owner’
[16:14:01.449]   - Field: ‘envir’
[16:14:01.449]   - Field: ‘workers’
[16:14:01.449]   - Field: ‘packages’
[16:14:01.449]   - Field: ‘gc’
[16:14:01.450]   - Field: ‘conditions’
[16:14:01.450]   - Field: ‘persistent’
[16:14:01.450]   - Field: ‘expr’
[16:14:01.450]   - Field: ‘uuid’
[16:14:01.450]   - Field: ‘seed’
[16:14:01.450]   - Field: ‘version’
[16:14:01.450]   - Field: ‘result’
[16:14:01.450]   - Field: ‘asynchronous’
[16:14:01.450]   - Field: ‘calls’
[16:14:01.450]   - Field: ‘globals’
[16:14:01.451]   - Field: ‘stdout’
[16:14:01.451]   - Field: ‘earlySignal’
[16:14:01.451]   - Field: ‘lazy’
[16:14:01.451]   - Field: ‘state’
[16:14:01.451] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:01.451] - Launch lazy future ...
[16:14:01.451] Packages needed by the future expression (n = 0): <none>
[16:14:01.451] Packages needed by future strategies (n = 0): <none>
[16:14:01.452] {
[16:14:01.452]     {
[16:14:01.452]         {
[16:14:01.452]             ...future.startTime <- base::Sys.time()
[16:14:01.452]             {
[16:14:01.452]                 {
[16:14:01.452]                   {
[16:14:01.452]                     {
[16:14:01.452]                       base::local({
[16:14:01.452]                         has_future <- base::requireNamespace("future", 
[16:14:01.452]                           quietly = TRUE)
[16:14:01.452]                         if (has_future) {
[16:14:01.452]                           ns <- base::getNamespace("future")
[16:14:01.452]                           version <- ns[[".package"]][["version"]]
[16:14:01.452]                           if (is.null(version)) 
[16:14:01.452]                             version <- utils::packageVersion("future")
[16:14:01.452]                         }
[16:14:01.452]                         else {
[16:14:01.452]                           version <- NULL
[16:14:01.452]                         }
[16:14:01.452]                         if (!has_future || version < "1.8.0") {
[16:14:01.452]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:01.452]                             "", base::R.version$version.string), 
[16:14:01.452]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:01.452]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:01.452]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:01.452]                               "release", "version")], collapse = " "), 
[16:14:01.452]                             hostname = base::Sys.info()[["nodename"]])
[16:14:01.452]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:01.452]                             info)
[16:14:01.452]                           info <- base::paste(info, collapse = "; ")
[16:14:01.452]                           if (!has_future) {
[16:14:01.452]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:01.452]                               info)
[16:14:01.452]                           }
[16:14:01.452]                           else {
[16:14:01.452]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:01.452]                               info, version)
[16:14:01.452]                           }
[16:14:01.452]                           base::stop(msg)
[16:14:01.452]                         }
[16:14:01.452]                       })
[16:14:01.452]                     }
[16:14:01.452]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:01.452]                     base::options(mc.cores = 1L)
[16:14:01.452]                   }
[16:14:01.452]                   options(future.plan = NULL)
[16:14:01.452]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.452]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:01.452]                 }
[16:14:01.452]                 ...future.workdir <- getwd()
[16:14:01.452]             }
[16:14:01.452]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:01.452]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:01.452]         }
[16:14:01.452]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:01.452]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:01.452]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:01.452]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:01.452]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:01.452]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:01.452]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:01.452]             base::names(...future.oldOptions))
[16:14:01.452]     }
[16:14:01.452]     if (FALSE) {
[16:14:01.452]     }
[16:14:01.452]     else {
[16:14:01.452]         if (TRUE) {
[16:14:01.452]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:01.452]                 open = "w")
[16:14:01.452]         }
[16:14:01.452]         else {
[16:14:01.452]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:01.452]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:01.452]         }
[16:14:01.452]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:01.452]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:01.452]             base::sink(type = "output", split = FALSE)
[16:14:01.452]             base::close(...future.stdout)
[16:14:01.452]         }, add = TRUE)
[16:14:01.452]     }
[16:14:01.452]     ...future.frame <- base::sys.nframe()
[16:14:01.452]     ...future.conditions <- base::list()
[16:14:01.452]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:01.452]     if (FALSE) {
[16:14:01.452]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:01.452]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:01.452]     }
[16:14:01.452]     ...future.result <- base::tryCatch({
[16:14:01.452]         base::withCallingHandlers({
[16:14:01.452]             ...future.value <- base::withVisible(base::local({
[16:14:01.452]                 ...future.makeSendCondition <- local({
[16:14:01.452]                   sendCondition <- NULL
[16:14:01.452]                   function(frame = 1L) {
[16:14:01.452]                     if (is.function(sendCondition)) 
[16:14:01.452]                       return(sendCondition)
[16:14:01.452]                     ns <- getNamespace("parallel")
[16:14:01.452]                     if (exists("sendData", mode = "function", 
[16:14:01.452]                       envir = ns)) {
[16:14:01.452]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:01.452]                         envir = ns)
[16:14:01.452]                       envir <- sys.frame(frame)
[16:14:01.452]                       master <- NULL
[16:14:01.452]                       while (!identical(envir, .GlobalEnv) && 
[16:14:01.452]                         !identical(envir, emptyenv())) {
[16:14:01.452]                         if (exists("master", mode = "list", envir = envir, 
[16:14:01.452]                           inherits = FALSE)) {
[16:14:01.452]                           master <- get("master", mode = "list", 
[16:14:01.452]                             envir = envir, inherits = FALSE)
[16:14:01.452]                           if (inherits(master, c("SOCKnode", 
[16:14:01.452]                             "SOCK0node"))) {
[16:14:01.452]                             sendCondition <<- function(cond) {
[16:14:01.452]                               data <- list(type = "VALUE", value = cond, 
[16:14:01.452]                                 success = TRUE)
[16:14:01.452]                               parallel_sendData(master, data)
[16:14:01.452]                             }
[16:14:01.452]                             return(sendCondition)
[16:14:01.452]                           }
[16:14:01.452]                         }
[16:14:01.452]                         frame <- frame + 1L
[16:14:01.452]                         envir <- sys.frame(frame)
[16:14:01.452]                       }
[16:14:01.452]                     }
[16:14:01.452]                     sendCondition <<- function(cond) NULL
[16:14:01.452]                   }
[16:14:01.452]                 })
[16:14:01.452]                 withCallingHandlers({
[16:14:01.452]                   2
[16:14:01.452]                 }, immediateCondition = function(cond) {
[16:14:01.452]                   sendCondition <- ...future.makeSendCondition()
[16:14:01.452]                   sendCondition(cond)
[16:14:01.452]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.452]                   {
[16:14:01.452]                     inherits <- base::inherits
[16:14:01.452]                     invokeRestart <- base::invokeRestart
[16:14:01.452]                     is.null <- base::is.null
[16:14:01.452]                     muffled <- FALSE
[16:14:01.452]                     if (inherits(cond, "message")) {
[16:14:01.452]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:01.452]                       if (muffled) 
[16:14:01.452]                         invokeRestart("muffleMessage")
[16:14:01.452]                     }
[16:14:01.452]                     else if (inherits(cond, "warning")) {
[16:14:01.452]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:01.452]                       if (muffled) 
[16:14:01.452]                         invokeRestart("muffleWarning")
[16:14:01.452]                     }
[16:14:01.452]                     else if (inherits(cond, "condition")) {
[16:14:01.452]                       if (!is.null(pattern)) {
[16:14:01.452]                         computeRestarts <- base::computeRestarts
[16:14:01.452]                         grepl <- base::grepl
[16:14:01.452]                         restarts <- computeRestarts(cond)
[16:14:01.452]                         for (restart in restarts) {
[16:14:01.452]                           name <- restart$name
[16:14:01.452]                           if (is.null(name)) 
[16:14:01.452]                             next
[16:14:01.452]                           if (!grepl(pattern, name)) 
[16:14:01.452]                             next
[16:14:01.452]                           invokeRestart(restart)
[16:14:01.452]                           muffled <- TRUE
[16:14:01.452]                           break
[16:14:01.452]                         }
[16:14:01.452]                       }
[16:14:01.452]                     }
[16:14:01.452]                     invisible(muffled)
[16:14:01.452]                   }
[16:14:01.452]                   muffleCondition(cond)
[16:14:01.452]                 })
[16:14:01.452]             }))
[16:14:01.452]             future::FutureResult(value = ...future.value$value, 
[16:14:01.452]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.452]                   ...future.rng), globalenv = if (FALSE) 
[16:14:01.452]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:01.452]                     ...future.globalenv.names))
[16:14:01.452]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:01.452]         }, condition = base::local({
[16:14:01.452]             c <- base::c
[16:14:01.452]             inherits <- base::inherits
[16:14:01.452]             invokeRestart <- base::invokeRestart
[16:14:01.452]             length <- base::length
[16:14:01.452]             list <- base::list
[16:14:01.452]             seq.int <- base::seq.int
[16:14:01.452]             signalCondition <- base::signalCondition
[16:14:01.452]             sys.calls <- base::sys.calls
[16:14:01.452]             `[[` <- base::`[[`
[16:14:01.452]             `+` <- base::`+`
[16:14:01.452]             `<<-` <- base::`<<-`
[16:14:01.452]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:01.452]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:01.452]                   3L)]
[16:14:01.452]             }
[16:14:01.452]             function(cond) {
[16:14:01.452]                 is_error <- inherits(cond, "error")
[16:14:01.452]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:01.452]                   NULL)
[16:14:01.452]                 if (is_error) {
[16:14:01.452]                   sessionInformation <- function() {
[16:14:01.452]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:01.452]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:01.452]                       search = base::search(), system = base::Sys.info())
[16:14:01.452]                   }
[16:14:01.452]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.452]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:01.452]                     cond$call), session = sessionInformation(), 
[16:14:01.452]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:01.452]                   signalCondition(cond)
[16:14:01.452]                 }
[16:14:01.452]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:01.452]                 "immediateCondition"))) {
[16:14:01.452]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:01.452]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.452]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:01.452]                   if (TRUE && !signal) {
[16:14:01.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.452]                     {
[16:14:01.452]                       inherits <- base::inherits
[16:14:01.452]                       invokeRestart <- base::invokeRestart
[16:14:01.452]                       is.null <- base::is.null
[16:14:01.452]                       muffled <- FALSE
[16:14:01.452]                       if (inherits(cond, "message")) {
[16:14:01.452]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.452]                         if (muffled) 
[16:14:01.452]                           invokeRestart("muffleMessage")
[16:14:01.452]                       }
[16:14:01.452]                       else if (inherits(cond, "warning")) {
[16:14:01.452]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.452]                         if (muffled) 
[16:14:01.452]                           invokeRestart("muffleWarning")
[16:14:01.452]                       }
[16:14:01.452]                       else if (inherits(cond, "condition")) {
[16:14:01.452]                         if (!is.null(pattern)) {
[16:14:01.452]                           computeRestarts <- base::computeRestarts
[16:14:01.452]                           grepl <- base::grepl
[16:14:01.452]                           restarts <- computeRestarts(cond)
[16:14:01.452]                           for (restart in restarts) {
[16:14:01.452]                             name <- restart$name
[16:14:01.452]                             if (is.null(name)) 
[16:14:01.452]                               next
[16:14:01.452]                             if (!grepl(pattern, name)) 
[16:14:01.452]                               next
[16:14:01.452]                             invokeRestart(restart)
[16:14:01.452]                             muffled <- TRUE
[16:14:01.452]                             break
[16:14:01.452]                           }
[16:14:01.452]                         }
[16:14:01.452]                       }
[16:14:01.452]                       invisible(muffled)
[16:14:01.452]                     }
[16:14:01.452]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.452]                   }
[16:14:01.452]                 }
[16:14:01.452]                 else {
[16:14:01.452]                   if (TRUE) {
[16:14:01.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.452]                     {
[16:14:01.452]                       inherits <- base::inherits
[16:14:01.452]                       invokeRestart <- base::invokeRestart
[16:14:01.452]                       is.null <- base::is.null
[16:14:01.452]                       muffled <- FALSE
[16:14:01.452]                       if (inherits(cond, "message")) {
[16:14:01.452]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.452]                         if (muffled) 
[16:14:01.452]                           invokeRestart("muffleMessage")
[16:14:01.452]                       }
[16:14:01.452]                       else if (inherits(cond, "warning")) {
[16:14:01.452]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.452]                         if (muffled) 
[16:14:01.452]                           invokeRestart("muffleWarning")
[16:14:01.452]                       }
[16:14:01.452]                       else if (inherits(cond, "condition")) {
[16:14:01.452]                         if (!is.null(pattern)) {
[16:14:01.452]                           computeRestarts <- base::computeRestarts
[16:14:01.452]                           grepl <- base::grepl
[16:14:01.452]                           restarts <- computeRestarts(cond)
[16:14:01.452]                           for (restart in restarts) {
[16:14:01.452]                             name <- restart$name
[16:14:01.452]                             if (is.null(name)) 
[16:14:01.452]                               next
[16:14:01.452]                             if (!grepl(pattern, name)) 
[16:14:01.452]                               next
[16:14:01.452]                             invokeRestart(restart)
[16:14:01.452]                             muffled <- TRUE
[16:14:01.452]                             break
[16:14:01.452]                           }
[16:14:01.452]                         }
[16:14:01.452]                       }
[16:14:01.452]                       invisible(muffled)
[16:14:01.452]                     }
[16:14:01.452]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.452]                   }
[16:14:01.452]                 }
[16:14:01.452]             }
[16:14:01.452]         }))
[16:14:01.452]     }, error = function(ex) {
[16:14:01.452]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:01.452]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.452]                 ...future.rng), started = ...future.startTime, 
[16:14:01.452]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:01.452]             version = "1.8"), class = "FutureResult")
[16:14:01.452]     }, finally = {
[16:14:01.452]         if (!identical(...future.workdir, getwd())) 
[16:14:01.452]             setwd(...future.workdir)
[16:14:01.452]         {
[16:14:01.452]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:01.452]                 ...future.oldOptions$nwarnings <- NULL
[16:14:01.452]             }
[16:14:01.452]             base::options(...future.oldOptions)
[16:14:01.452]             if (.Platform$OS.type == "windows") {
[16:14:01.452]                 old_names <- names(...future.oldEnvVars)
[16:14:01.452]                 envs <- base::Sys.getenv()
[16:14:01.452]                 names <- names(envs)
[16:14:01.452]                 common <- intersect(names, old_names)
[16:14:01.452]                 added <- setdiff(names, old_names)
[16:14:01.452]                 removed <- setdiff(old_names, names)
[16:14:01.452]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:01.452]                   envs[common]]
[16:14:01.452]                 NAMES <- toupper(changed)
[16:14:01.452]                 args <- list()
[16:14:01.452]                 for (kk in seq_along(NAMES)) {
[16:14:01.452]                   name <- changed[[kk]]
[16:14:01.452]                   NAME <- NAMES[[kk]]
[16:14:01.452]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.452]                     next
[16:14:01.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.452]                 }
[16:14:01.452]                 NAMES <- toupper(added)
[16:14:01.452]                 for (kk in seq_along(NAMES)) {
[16:14:01.452]                   name <- added[[kk]]
[16:14:01.452]                   NAME <- NAMES[[kk]]
[16:14:01.452]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.452]                     next
[16:14:01.452]                   args[[name]] <- ""
[16:14:01.452]                 }
[16:14:01.452]                 NAMES <- toupper(removed)
[16:14:01.452]                 for (kk in seq_along(NAMES)) {
[16:14:01.452]                   name <- removed[[kk]]
[16:14:01.452]                   NAME <- NAMES[[kk]]
[16:14:01.452]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.452]                     next
[16:14:01.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.452]                 }
[16:14:01.452]                 if (length(args) > 0) 
[16:14:01.452]                   base::do.call(base::Sys.setenv, args = args)
[16:14:01.452]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:01.452]             }
[16:14:01.452]             else {
[16:14:01.452]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:01.452]             }
[16:14:01.452]             {
[16:14:01.452]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:01.452]                   0L) {
[16:14:01.452]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:01.452]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:01.452]                   base::options(opts)
[16:14:01.452]                 }
[16:14:01.452]                 {
[16:14:01.452]                   {
[16:14:01.452]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:01.452]                     NULL
[16:14:01.452]                   }
[16:14:01.452]                   options(future.plan = NULL)
[16:14:01.452]                   if (is.na(NA_character_)) 
[16:14:01.452]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.452]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:01.452]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:01.452]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:01.452]                     envir = parent.frame()) 
[16:14:01.452]                   {
[16:14:01.452]                     if (is.function(workers)) 
[16:14:01.452]                       workers <- workers()
[16:14:01.452]                     workers <- structure(as.integer(workers), 
[16:14:01.452]                       class = class(workers))
[16:14:01.452]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:01.452]                       workers >= 1)
[16:14:01.452]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:01.452]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:01.452]                     }
[16:14:01.452]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:01.452]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:01.452]                       envir = envir)
[16:14:01.452]                     if (!future$lazy) 
[16:14:01.452]                       future <- run(future)
[16:14:01.452]                     invisible(future)
[16:14:01.452]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:01.452]                 }
[16:14:01.452]             }
[16:14:01.452]         }
[16:14:01.452]     })
[16:14:01.452]     if (TRUE) {
[16:14:01.452]         base::sink(type = "output", split = FALSE)
[16:14:01.452]         if (TRUE) {
[16:14:01.452]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:01.452]         }
[16:14:01.452]         else {
[16:14:01.452]             ...future.result["stdout"] <- base::list(NULL)
[16:14:01.452]         }
[16:14:01.452]         base::close(...future.stdout)
[16:14:01.452]         ...future.stdout <- NULL
[16:14:01.452]     }
[16:14:01.452]     ...future.result$conditions <- ...future.conditions
[16:14:01.452]     ...future.result$finished <- base::Sys.time()
[16:14:01.452]     ...future.result
[16:14:01.452] }
[16:14:01.455] MultisessionFuture started
[16:14:01.455] - Launch lazy future ... done
[16:14:01.455] run() for ‘MultisessionFuture’ ... done
[16:14:01.456] resolve() on list environment ...
[16:14:01.456]  recursive: 0
[16:14:01.456]  length: 3
[16:14:01.457]  elements: ‘a’, ‘b’, ‘c’
[16:14:01.478]  length: 2 (resolved future 3)
[16:14:01.488] receiveMessageFromWorker() for ClusterFuture ...
[16:14:01.488] - Validating connection of MultisessionFuture
[16:14:01.489] - received message: FutureResult
[16:14:01.489] - Received FutureResult
[16:14:01.489] - Erased future from FutureRegistry
[16:14:01.489] result() for ClusterFuture ...
[16:14:01.489] - result already collected: FutureResult
[16:14:01.489] result() for ClusterFuture ... done
[16:14:01.489] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:01.489] Future #1
[16:14:01.489]  length: 1 (resolved future 1)
[16:14:01.510] receiveMessageFromWorker() for ClusterFuture ...
[16:14:01.511] - Validating connection of MultisessionFuture
[16:14:01.511] - received message: FutureResult
[16:14:01.511] - Received FutureResult
[16:14:01.511] - Erased future from FutureRegistry
[16:14:01.511] result() for ClusterFuture ...
[16:14:01.511] - result already collected: FutureResult
[16:14:01.511] result() for ClusterFuture ... done
[16:14:01.511] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:01.512] Future #2
[16:14:01.512]  length: 0 (resolved future 2)
[16:14:01.512] resolve() on list environment ... DONE
[16:14:01.512] getGlobalsAndPackages() ...
[16:14:01.513] Searching for globals...
[16:14:01.513] - globals found: [1] ‘{’
[16:14:01.513] Searching for globals ... DONE
[16:14:01.513] Resolving globals: FALSE
[16:14:01.514] 
[16:14:01.514] 
[16:14:01.514] getGlobalsAndPackages() ... DONE
[16:14:01.514] run() for ‘Future’ ...
[16:14:01.514] - state: ‘created’
[16:14:01.514] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:01.529] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:01.529] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:01.529]   - Field: ‘node’
[16:14:01.529]   - Field: ‘label’
[16:14:01.529]   - Field: ‘local’
[16:14:01.529]   - Field: ‘owner’
[16:14:01.529]   - Field: ‘envir’
[16:14:01.529]   - Field: ‘workers’
[16:14:01.529]   - Field: ‘packages’
[16:14:01.530]   - Field: ‘gc’
[16:14:01.530]   - Field: ‘conditions’
[16:14:01.530]   - Field: ‘persistent’
[16:14:01.530]   - Field: ‘expr’
[16:14:01.530]   - Field: ‘uuid’
[16:14:01.530]   - Field: ‘seed’
[16:14:01.530]   - Field: ‘version’
[16:14:01.530]   - Field: ‘result’
[16:14:01.530]   - Field: ‘asynchronous’
[16:14:01.530]   - Field: ‘calls’
[16:14:01.530]   - Field: ‘globals’
[16:14:01.531]   - Field: ‘stdout’
[16:14:01.531]   - Field: ‘earlySignal’
[16:14:01.531]   - Field: ‘lazy’
[16:14:01.531]   - Field: ‘state’
[16:14:01.531] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:01.531] - Launch lazy future ...
[16:14:01.531] Packages needed by the future expression (n = 0): <none>
[16:14:01.531] Packages needed by future strategies (n = 0): <none>
[16:14:01.532] {
[16:14:01.532]     {
[16:14:01.532]         {
[16:14:01.532]             ...future.startTime <- base::Sys.time()
[16:14:01.532]             {
[16:14:01.532]                 {
[16:14:01.532]                   {
[16:14:01.532]                     {
[16:14:01.532]                       base::local({
[16:14:01.532]                         has_future <- base::requireNamespace("future", 
[16:14:01.532]                           quietly = TRUE)
[16:14:01.532]                         if (has_future) {
[16:14:01.532]                           ns <- base::getNamespace("future")
[16:14:01.532]                           version <- ns[[".package"]][["version"]]
[16:14:01.532]                           if (is.null(version)) 
[16:14:01.532]                             version <- utils::packageVersion("future")
[16:14:01.532]                         }
[16:14:01.532]                         else {
[16:14:01.532]                           version <- NULL
[16:14:01.532]                         }
[16:14:01.532]                         if (!has_future || version < "1.8.0") {
[16:14:01.532]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:01.532]                             "", base::R.version$version.string), 
[16:14:01.532]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:01.532]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:01.532]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:01.532]                               "release", "version")], collapse = " "), 
[16:14:01.532]                             hostname = base::Sys.info()[["nodename"]])
[16:14:01.532]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:01.532]                             info)
[16:14:01.532]                           info <- base::paste(info, collapse = "; ")
[16:14:01.532]                           if (!has_future) {
[16:14:01.532]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:01.532]                               info)
[16:14:01.532]                           }
[16:14:01.532]                           else {
[16:14:01.532]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:01.532]                               info, version)
[16:14:01.532]                           }
[16:14:01.532]                           base::stop(msg)
[16:14:01.532]                         }
[16:14:01.532]                       })
[16:14:01.532]                     }
[16:14:01.532]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:01.532]                     base::options(mc.cores = 1L)
[16:14:01.532]                   }
[16:14:01.532]                   options(future.plan = NULL)
[16:14:01.532]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.532]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:01.532]                 }
[16:14:01.532]                 ...future.workdir <- getwd()
[16:14:01.532]             }
[16:14:01.532]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:01.532]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:01.532]         }
[16:14:01.532]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:01.532]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:01.532]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:01.532]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:01.532]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:01.532]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:01.532]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:01.532]             base::names(...future.oldOptions))
[16:14:01.532]     }
[16:14:01.532]     if (FALSE) {
[16:14:01.532]     }
[16:14:01.532]     else {
[16:14:01.532]         if (TRUE) {
[16:14:01.532]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:01.532]                 open = "w")
[16:14:01.532]         }
[16:14:01.532]         else {
[16:14:01.532]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:01.532]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:01.532]         }
[16:14:01.532]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:01.532]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:01.532]             base::sink(type = "output", split = FALSE)
[16:14:01.532]             base::close(...future.stdout)
[16:14:01.532]         }, add = TRUE)
[16:14:01.532]     }
[16:14:01.532]     ...future.frame <- base::sys.nframe()
[16:14:01.532]     ...future.conditions <- base::list()
[16:14:01.532]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:01.532]     if (FALSE) {
[16:14:01.532]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:01.532]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:01.532]     }
[16:14:01.532]     ...future.result <- base::tryCatch({
[16:14:01.532]         base::withCallingHandlers({
[16:14:01.532]             ...future.value <- base::withVisible(base::local({
[16:14:01.532]                 ...future.makeSendCondition <- local({
[16:14:01.532]                   sendCondition <- NULL
[16:14:01.532]                   function(frame = 1L) {
[16:14:01.532]                     if (is.function(sendCondition)) 
[16:14:01.532]                       return(sendCondition)
[16:14:01.532]                     ns <- getNamespace("parallel")
[16:14:01.532]                     if (exists("sendData", mode = "function", 
[16:14:01.532]                       envir = ns)) {
[16:14:01.532]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:01.532]                         envir = ns)
[16:14:01.532]                       envir <- sys.frame(frame)
[16:14:01.532]                       master <- NULL
[16:14:01.532]                       while (!identical(envir, .GlobalEnv) && 
[16:14:01.532]                         !identical(envir, emptyenv())) {
[16:14:01.532]                         if (exists("master", mode = "list", envir = envir, 
[16:14:01.532]                           inherits = FALSE)) {
[16:14:01.532]                           master <- get("master", mode = "list", 
[16:14:01.532]                             envir = envir, inherits = FALSE)
[16:14:01.532]                           if (inherits(master, c("SOCKnode", 
[16:14:01.532]                             "SOCK0node"))) {
[16:14:01.532]                             sendCondition <<- function(cond) {
[16:14:01.532]                               data <- list(type = "VALUE", value = cond, 
[16:14:01.532]                                 success = TRUE)
[16:14:01.532]                               parallel_sendData(master, data)
[16:14:01.532]                             }
[16:14:01.532]                             return(sendCondition)
[16:14:01.532]                           }
[16:14:01.532]                         }
[16:14:01.532]                         frame <- frame + 1L
[16:14:01.532]                         envir <- sys.frame(frame)
[16:14:01.532]                       }
[16:14:01.532]                     }
[16:14:01.532]                     sendCondition <<- function(cond) NULL
[16:14:01.532]                   }
[16:14:01.532]                 })
[16:14:01.532]                 withCallingHandlers({
[16:14:01.532]                   {
[16:14:01.532]                     1
[16:14:01.532]                   }
[16:14:01.532]                 }, immediateCondition = function(cond) {
[16:14:01.532]                   sendCondition <- ...future.makeSendCondition()
[16:14:01.532]                   sendCondition(cond)
[16:14:01.532]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.532]                   {
[16:14:01.532]                     inherits <- base::inherits
[16:14:01.532]                     invokeRestart <- base::invokeRestart
[16:14:01.532]                     is.null <- base::is.null
[16:14:01.532]                     muffled <- FALSE
[16:14:01.532]                     if (inherits(cond, "message")) {
[16:14:01.532]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:01.532]                       if (muffled) 
[16:14:01.532]                         invokeRestart("muffleMessage")
[16:14:01.532]                     }
[16:14:01.532]                     else if (inherits(cond, "warning")) {
[16:14:01.532]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:01.532]                       if (muffled) 
[16:14:01.532]                         invokeRestart("muffleWarning")
[16:14:01.532]                     }
[16:14:01.532]                     else if (inherits(cond, "condition")) {
[16:14:01.532]                       if (!is.null(pattern)) {
[16:14:01.532]                         computeRestarts <- base::computeRestarts
[16:14:01.532]                         grepl <- base::grepl
[16:14:01.532]                         restarts <- computeRestarts(cond)
[16:14:01.532]                         for (restart in restarts) {
[16:14:01.532]                           name <- restart$name
[16:14:01.532]                           if (is.null(name)) 
[16:14:01.532]                             next
[16:14:01.532]                           if (!grepl(pattern, name)) 
[16:14:01.532]                             next
[16:14:01.532]                           invokeRestart(restart)
[16:14:01.532]                           muffled <- TRUE
[16:14:01.532]                           break
[16:14:01.532]                         }
[16:14:01.532]                       }
[16:14:01.532]                     }
[16:14:01.532]                     invisible(muffled)
[16:14:01.532]                   }
[16:14:01.532]                   muffleCondition(cond)
[16:14:01.532]                 })
[16:14:01.532]             }))
[16:14:01.532]             future::FutureResult(value = ...future.value$value, 
[16:14:01.532]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.532]                   ...future.rng), globalenv = if (FALSE) 
[16:14:01.532]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:01.532]                     ...future.globalenv.names))
[16:14:01.532]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:01.532]         }, condition = base::local({
[16:14:01.532]             c <- base::c
[16:14:01.532]             inherits <- base::inherits
[16:14:01.532]             invokeRestart <- base::invokeRestart
[16:14:01.532]             length <- base::length
[16:14:01.532]             list <- base::list
[16:14:01.532]             seq.int <- base::seq.int
[16:14:01.532]             signalCondition <- base::signalCondition
[16:14:01.532]             sys.calls <- base::sys.calls
[16:14:01.532]             `[[` <- base::`[[`
[16:14:01.532]             `+` <- base::`+`
[16:14:01.532]             `<<-` <- base::`<<-`
[16:14:01.532]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:01.532]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:01.532]                   3L)]
[16:14:01.532]             }
[16:14:01.532]             function(cond) {
[16:14:01.532]                 is_error <- inherits(cond, "error")
[16:14:01.532]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:01.532]                   NULL)
[16:14:01.532]                 if (is_error) {
[16:14:01.532]                   sessionInformation <- function() {
[16:14:01.532]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:01.532]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:01.532]                       search = base::search(), system = base::Sys.info())
[16:14:01.532]                   }
[16:14:01.532]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.532]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:01.532]                     cond$call), session = sessionInformation(), 
[16:14:01.532]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:01.532]                   signalCondition(cond)
[16:14:01.532]                 }
[16:14:01.532]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:01.532]                 "immediateCondition"))) {
[16:14:01.532]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:01.532]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.532]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:01.532]                   if (TRUE && !signal) {
[16:14:01.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.532]                     {
[16:14:01.532]                       inherits <- base::inherits
[16:14:01.532]                       invokeRestart <- base::invokeRestart
[16:14:01.532]                       is.null <- base::is.null
[16:14:01.532]                       muffled <- FALSE
[16:14:01.532]                       if (inherits(cond, "message")) {
[16:14:01.532]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.532]                         if (muffled) 
[16:14:01.532]                           invokeRestart("muffleMessage")
[16:14:01.532]                       }
[16:14:01.532]                       else if (inherits(cond, "warning")) {
[16:14:01.532]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.532]                         if (muffled) 
[16:14:01.532]                           invokeRestart("muffleWarning")
[16:14:01.532]                       }
[16:14:01.532]                       else if (inherits(cond, "condition")) {
[16:14:01.532]                         if (!is.null(pattern)) {
[16:14:01.532]                           computeRestarts <- base::computeRestarts
[16:14:01.532]                           grepl <- base::grepl
[16:14:01.532]                           restarts <- computeRestarts(cond)
[16:14:01.532]                           for (restart in restarts) {
[16:14:01.532]                             name <- restart$name
[16:14:01.532]                             if (is.null(name)) 
[16:14:01.532]                               next
[16:14:01.532]                             if (!grepl(pattern, name)) 
[16:14:01.532]                               next
[16:14:01.532]                             invokeRestart(restart)
[16:14:01.532]                             muffled <- TRUE
[16:14:01.532]                             break
[16:14:01.532]                           }
[16:14:01.532]                         }
[16:14:01.532]                       }
[16:14:01.532]                       invisible(muffled)
[16:14:01.532]                     }
[16:14:01.532]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.532]                   }
[16:14:01.532]                 }
[16:14:01.532]                 else {
[16:14:01.532]                   if (TRUE) {
[16:14:01.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.532]                     {
[16:14:01.532]                       inherits <- base::inherits
[16:14:01.532]                       invokeRestart <- base::invokeRestart
[16:14:01.532]                       is.null <- base::is.null
[16:14:01.532]                       muffled <- FALSE
[16:14:01.532]                       if (inherits(cond, "message")) {
[16:14:01.532]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.532]                         if (muffled) 
[16:14:01.532]                           invokeRestart("muffleMessage")
[16:14:01.532]                       }
[16:14:01.532]                       else if (inherits(cond, "warning")) {
[16:14:01.532]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.532]                         if (muffled) 
[16:14:01.532]                           invokeRestart("muffleWarning")
[16:14:01.532]                       }
[16:14:01.532]                       else if (inherits(cond, "condition")) {
[16:14:01.532]                         if (!is.null(pattern)) {
[16:14:01.532]                           computeRestarts <- base::computeRestarts
[16:14:01.532]                           grepl <- base::grepl
[16:14:01.532]                           restarts <- computeRestarts(cond)
[16:14:01.532]                           for (restart in restarts) {
[16:14:01.532]                             name <- restart$name
[16:14:01.532]                             if (is.null(name)) 
[16:14:01.532]                               next
[16:14:01.532]                             if (!grepl(pattern, name)) 
[16:14:01.532]                               next
[16:14:01.532]                             invokeRestart(restart)
[16:14:01.532]                             muffled <- TRUE
[16:14:01.532]                             break
[16:14:01.532]                           }
[16:14:01.532]                         }
[16:14:01.532]                       }
[16:14:01.532]                       invisible(muffled)
[16:14:01.532]                     }
[16:14:01.532]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.532]                   }
[16:14:01.532]                 }
[16:14:01.532]             }
[16:14:01.532]         }))
[16:14:01.532]     }, error = function(ex) {
[16:14:01.532]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:01.532]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.532]                 ...future.rng), started = ...future.startTime, 
[16:14:01.532]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:01.532]             version = "1.8"), class = "FutureResult")
[16:14:01.532]     }, finally = {
[16:14:01.532]         if (!identical(...future.workdir, getwd())) 
[16:14:01.532]             setwd(...future.workdir)
[16:14:01.532]         {
[16:14:01.532]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:01.532]                 ...future.oldOptions$nwarnings <- NULL
[16:14:01.532]             }
[16:14:01.532]             base::options(...future.oldOptions)
[16:14:01.532]             if (.Platform$OS.type == "windows") {
[16:14:01.532]                 old_names <- names(...future.oldEnvVars)
[16:14:01.532]                 envs <- base::Sys.getenv()
[16:14:01.532]                 names <- names(envs)
[16:14:01.532]                 common <- intersect(names, old_names)
[16:14:01.532]                 added <- setdiff(names, old_names)
[16:14:01.532]                 removed <- setdiff(old_names, names)
[16:14:01.532]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:01.532]                   envs[common]]
[16:14:01.532]                 NAMES <- toupper(changed)
[16:14:01.532]                 args <- list()
[16:14:01.532]                 for (kk in seq_along(NAMES)) {
[16:14:01.532]                   name <- changed[[kk]]
[16:14:01.532]                   NAME <- NAMES[[kk]]
[16:14:01.532]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.532]                     next
[16:14:01.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.532]                 }
[16:14:01.532]                 NAMES <- toupper(added)
[16:14:01.532]                 for (kk in seq_along(NAMES)) {
[16:14:01.532]                   name <- added[[kk]]
[16:14:01.532]                   NAME <- NAMES[[kk]]
[16:14:01.532]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.532]                     next
[16:14:01.532]                   args[[name]] <- ""
[16:14:01.532]                 }
[16:14:01.532]                 NAMES <- toupper(removed)
[16:14:01.532]                 for (kk in seq_along(NAMES)) {
[16:14:01.532]                   name <- removed[[kk]]
[16:14:01.532]                   NAME <- NAMES[[kk]]
[16:14:01.532]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.532]                     next
[16:14:01.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.532]                 }
[16:14:01.532]                 if (length(args) > 0) 
[16:14:01.532]                   base::do.call(base::Sys.setenv, args = args)
[16:14:01.532]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:01.532]             }
[16:14:01.532]             else {
[16:14:01.532]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:01.532]             }
[16:14:01.532]             {
[16:14:01.532]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:01.532]                   0L) {
[16:14:01.532]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:01.532]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:01.532]                   base::options(opts)
[16:14:01.532]                 }
[16:14:01.532]                 {
[16:14:01.532]                   {
[16:14:01.532]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:01.532]                     NULL
[16:14:01.532]                   }
[16:14:01.532]                   options(future.plan = NULL)
[16:14:01.532]                   if (is.na(NA_character_)) 
[16:14:01.532]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.532]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:01.532]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:01.532]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:01.532]                     envir = parent.frame()) 
[16:14:01.532]                   {
[16:14:01.532]                     if (is.function(workers)) 
[16:14:01.532]                       workers <- workers()
[16:14:01.532]                     workers <- structure(as.integer(workers), 
[16:14:01.532]                       class = class(workers))
[16:14:01.532]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:01.532]                       workers >= 1)
[16:14:01.532]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:01.532]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:01.532]                     }
[16:14:01.532]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:01.532]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:01.532]                       envir = envir)
[16:14:01.532]                     if (!future$lazy) 
[16:14:01.532]                       future <- run(future)
[16:14:01.532]                     invisible(future)
[16:14:01.532]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:01.532]                 }
[16:14:01.532]             }
[16:14:01.532]         }
[16:14:01.532]     })
[16:14:01.532]     if (TRUE) {
[16:14:01.532]         base::sink(type = "output", split = FALSE)
[16:14:01.532]         if (TRUE) {
[16:14:01.532]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:01.532]         }
[16:14:01.532]         else {
[16:14:01.532]             ...future.result["stdout"] <- base::list(NULL)
[16:14:01.532]         }
[16:14:01.532]         base::close(...future.stdout)
[16:14:01.532]         ...future.stdout <- NULL
[16:14:01.532]     }
[16:14:01.532]     ...future.result$conditions <- ...future.conditions
[16:14:01.532]     ...future.result$finished <- base::Sys.time()
[16:14:01.532]     ...future.result
[16:14:01.532] }
[16:14:01.535] MultisessionFuture started
[16:14:01.535] - Launch lazy future ... done
[16:14:01.535] run() for ‘MultisessionFuture’ ... done
[16:14:01.536] getGlobalsAndPackages() ...
[16:14:01.536] Searching for globals...
[16:14:01.536] - globals found: [1] ‘{’
[16:14:01.536] Searching for globals ... DONE
[16:14:01.537] Resolving globals: FALSE
[16:14:01.537] 
[16:14:01.537] 
[16:14:01.537] getGlobalsAndPackages() ... DONE
[16:14:01.537] run() for ‘Future’ ...
[16:14:01.537] - state: ‘created’
[16:14:01.537] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:01.552] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:01.552] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:01.552]   - Field: ‘node’
[16:14:01.552]   - Field: ‘label’
[16:14:01.552]   - Field: ‘local’
[16:14:01.552]   - Field: ‘owner’
[16:14:01.552]   - Field: ‘envir’
[16:14:01.552]   - Field: ‘workers’
[16:14:01.552]   - Field: ‘packages’
[16:14:01.553]   - Field: ‘gc’
[16:14:01.553]   - Field: ‘conditions’
[16:14:01.553]   - Field: ‘persistent’
[16:14:01.553]   - Field: ‘expr’
[16:14:01.553]   - Field: ‘uuid’
[16:14:01.553]   - Field: ‘seed’
[16:14:01.553]   - Field: ‘version’
[16:14:01.553]   - Field: ‘result’
[16:14:01.553]   - Field: ‘asynchronous’
[16:14:01.553]   - Field: ‘calls’
[16:14:01.553]   - Field: ‘globals’
[16:14:01.554]   - Field: ‘stdout’
[16:14:01.554]   - Field: ‘earlySignal’
[16:14:01.554]   - Field: ‘lazy’
[16:14:01.554]   - Field: ‘state’
[16:14:01.554] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:01.554] - Launch lazy future ...
[16:14:01.554] Packages needed by the future expression (n = 0): <none>
[16:14:01.554] Packages needed by future strategies (n = 0): <none>
[16:14:01.555] {
[16:14:01.555]     {
[16:14:01.555]         {
[16:14:01.555]             ...future.startTime <- base::Sys.time()
[16:14:01.555]             {
[16:14:01.555]                 {
[16:14:01.555]                   {
[16:14:01.555]                     {
[16:14:01.555]                       base::local({
[16:14:01.555]                         has_future <- base::requireNamespace("future", 
[16:14:01.555]                           quietly = TRUE)
[16:14:01.555]                         if (has_future) {
[16:14:01.555]                           ns <- base::getNamespace("future")
[16:14:01.555]                           version <- ns[[".package"]][["version"]]
[16:14:01.555]                           if (is.null(version)) 
[16:14:01.555]                             version <- utils::packageVersion("future")
[16:14:01.555]                         }
[16:14:01.555]                         else {
[16:14:01.555]                           version <- NULL
[16:14:01.555]                         }
[16:14:01.555]                         if (!has_future || version < "1.8.0") {
[16:14:01.555]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:01.555]                             "", base::R.version$version.string), 
[16:14:01.555]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:01.555]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:01.555]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:01.555]                               "release", "version")], collapse = " "), 
[16:14:01.555]                             hostname = base::Sys.info()[["nodename"]])
[16:14:01.555]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:01.555]                             info)
[16:14:01.555]                           info <- base::paste(info, collapse = "; ")
[16:14:01.555]                           if (!has_future) {
[16:14:01.555]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:01.555]                               info)
[16:14:01.555]                           }
[16:14:01.555]                           else {
[16:14:01.555]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:01.555]                               info, version)
[16:14:01.555]                           }
[16:14:01.555]                           base::stop(msg)
[16:14:01.555]                         }
[16:14:01.555]                       })
[16:14:01.555]                     }
[16:14:01.555]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:01.555]                     base::options(mc.cores = 1L)
[16:14:01.555]                   }
[16:14:01.555]                   options(future.plan = NULL)
[16:14:01.555]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.555]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:01.555]                 }
[16:14:01.555]                 ...future.workdir <- getwd()
[16:14:01.555]             }
[16:14:01.555]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:01.555]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:01.555]         }
[16:14:01.555]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:01.555]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:01.555]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:01.555]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:01.555]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:01.555]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:01.555]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:01.555]             base::names(...future.oldOptions))
[16:14:01.555]     }
[16:14:01.555]     if (FALSE) {
[16:14:01.555]     }
[16:14:01.555]     else {
[16:14:01.555]         if (TRUE) {
[16:14:01.555]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:01.555]                 open = "w")
[16:14:01.555]         }
[16:14:01.555]         else {
[16:14:01.555]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:01.555]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:01.555]         }
[16:14:01.555]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:01.555]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:01.555]             base::sink(type = "output", split = FALSE)
[16:14:01.555]             base::close(...future.stdout)
[16:14:01.555]         }, add = TRUE)
[16:14:01.555]     }
[16:14:01.555]     ...future.frame <- base::sys.nframe()
[16:14:01.555]     ...future.conditions <- base::list()
[16:14:01.555]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:01.555]     if (FALSE) {
[16:14:01.555]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:01.555]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:01.555]     }
[16:14:01.555]     ...future.result <- base::tryCatch({
[16:14:01.555]         base::withCallingHandlers({
[16:14:01.555]             ...future.value <- base::withVisible(base::local({
[16:14:01.555]                 ...future.makeSendCondition <- local({
[16:14:01.555]                   sendCondition <- NULL
[16:14:01.555]                   function(frame = 1L) {
[16:14:01.555]                     if (is.function(sendCondition)) 
[16:14:01.555]                       return(sendCondition)
[16:14:01.555]                     ns <- getNamespace("parallel")
[16:14:01.555]                     if (exists("sendData", mode = "function", 
[16:14:01.555]                       envir = ns)) {
[16:14:01.555]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:01.555]                         envir = ns)
[16:14:01.555]                       envir <- sys.frame(frame)
[16:14:01.555]                       master <- NULL
[16:14:01.555]                       while (!identical(envir, .GlobalEnv) && 
[16:14:01.555]                         !identical(envir, emptyenv())) {
[16:14:01.555]                         if (exists("master", mode = "list", envir = envir, 
[16:14:01.555]                           inherits = FALSE)) {
[16:14:01.555]                           master <- get("master", mode = "list", 
[16:14:01.555]                             envir = envir, inherits = FALSE)
[16:14:01.555]                           if (inherits(master, c("SOCKnode", 
[16:14:01.555]                             "SOCK0node"))) {
[16:14:01.555]                             sendCondition <<- function(cond) {
[16:14:01.555]                               data <- list(type = "VALUE", value = cond, 
[16:14:01.555]                                 success = TRUE)
[16:14:01.555]                               parallel_sendData(master, data)
[16:14:01.555]                             }
[16:14:01.555]                             return(sendCondition)
[16:14:01.555]                           }
[16:14:01.555]                         }
[16:14:01.555]                         frame <- frame + 1L
[16:14:01.555]                         envir <- sys.frame(frame)
[16:14:01.555]                       }
[16:14:01.555]                     }
[16:14:01.555]                     sendCondition <<- function(cond) NULL
[16:14:01.555]                   }
[16:14:01.555]                 })
[16:14:01.555]                 withCallingHandlers({
[16:14:01.555]                   {
[16:14:01.555]                     2
[16:14:01.555]                   }
[16:14:01.555]                 }, immediateCondition = function(cond) {
[16:14:01.555]                   sendCondition <- ...future.makeSendCondition()
[16:14:01.555]                   sendCondition(cond)
[16:14:01.555]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.555]                   {
[16:14:01.555]                     inherits <- base::inherits
[16:14:01.555]                     invokeRestart <- base::invokeRestart
[16:14:01.555]                     is.null <- base::is.null
[16:14:01.555]                     muffled <- FALSE
[16:14:01.555]                     if (inherits(cond, "message")) {
[16:14:01.555]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:01.555]                       if (muffled) 
[16:14:01.555]                         invokeRestart("muffleMessage")
[16:14:01.555]                     }
[16:14:01.555]                     else if (inherits(cond, "warning")) {
[16:14:01.555]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:01.555]                       if (muffled) 
[16:14:01.555]                         invokeRestart("muffleWarning")
[16:14:01.555]                     }
[16:14:01.555]                     else if (inherits(cond, "condition")) {
[16:14:01.555]                       if (!is.null(pattern)) {
[16:14:01.555]                         computeRestarts <- base::computeRestarts
[16:14:01.555]                         grepl <- base::grepl
[16:14:01.555]                         restarts <- computeRestarts(cond)
[16:14:01.555]                         for (restart in restarts) {
[16:14:01.555]                           name <- restart$name
[16:14:01.555]                           if (is.null(name)) 
[16:14:01.555]                             next
[16:14:01.555]                           if (!grepl(pattern, name)) 
[16:14:01.555]                             next
[16:14:01.555]                           invokeRestart(restart)
[16:14:01.555]                           muffled <- TRUE
[16:14:01.555]                           break
[16:14:01.555]                         }
[16:14:01.555]                       }
[16:14:01.555]                     }
[16:14:01.555]                     invisible(muffled)
[16:14:01.555]                   }
[16:14:01.555]                   muffleCondition(cond)
[16:14:01.555]                 })
[16:14:01.555]             }))
[16:14:01.555]             future::FutureResult(value = ...future.value$value, 
[16:14:01.555]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.555]                   ...future.rng), globalenv = if (FALSE) 
[16:14:01.555]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:01.555]                     ...future.globalenv.names))
[16:14:01.555]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:01.555]         }, condition = base::local({
[16:14:01.555]             c <- base::c
[16:14:01.555]             inherits <- base::inherits
[16:14:01.555]             invokeRestart <- base::invokeRestart
[16:14:01.555]             length <- base::length
[16:14:01.555]             list <- base::list
[16:14:01.555]             seq.int <- base::seq.int
[16:14:01.555]             signalCondition <- base::signalCondition
[16:14:01.555]             sys.calls <- base::sys.calls
[16:14:01.555]             `[[` <- base::`[[`
[16:14:01.555]             `+` <- base::`+`
[16:14:01.555]             `<<-` <- base::`<<-`
[16:14:01.555]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:01.555]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:01.555]                   3L)]
[16:14:01.555]             }
[16:14:01.555]             function(cond) {
[16:14:01.555]                 is_error <- inherits(cond, "error")
[16:14:01.555]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:01.555]                   NULL)
[16:14:01.555]                 if (is_error) {
[16:14:01.555]                   sessionInformation <- function() {
[16:14:01.555]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:01.555]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:01.555]                       search = base::search(), system = base::Sys.info())
[16:14:01.555]                   }
[16:14:01.555]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.555]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:01.555]                     cond$call), session = sessionInformation(), 
[16:14:01.555]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:01.555]                   signalCondition(cond)
[16:14:01.555]                 }
[16:14:01.555]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:01.555]                 "immediateCondition"))) {
[16:14:01.555]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:01.555]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.555]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:01.555]                   if (TRUE && !signal) {
[16:14:01.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.555]                     {
[16:14:01.555]                       inherits <- base::inherits
[16:14:01.555]                       invokeRestart <- base::invokeRestart
[16:14:01.555]                       is.null <- base::is.null
[16:14:01.555]                       muffled <- FALSE
[16:14:01.555]                       if (inherits(cond, "message")) {
[16:14:01.555]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.555]                         if (muffled) 
[16:14:01.555]                           invokeRestart("muffleMessage")
[16:14:01.555]                       }
[16:14:01.555]                       else if (inherits(cond, "warning")) {
[16:14:01.555]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.555]                         if (muffled) 
[16:14:01.555]                           invokeRestart("muffleWarning")
[16:14:01.555]                       }
[16:14:01.555]                       else if (inherits(cond, "condition")) {
[16:14:01.555]                         if (!is.null(pattern)) {
[16:14:01.555]                           computeRestarts <- base::computeRestarts
[16:14:01.555]                           grepl <- base::grepl
[16:14:01.555]                           restarts <- computeRestarts(cond)
[16:14:01.555]                           for (restart in restarts) {
[16:14:01.555]                             name <- restart$name
[16:14:01.555]                             if (is.null(name)) 
[16:14:01.555]                               next
[16:14:01.555]                             if (!grepl(pattern, name)) 
[16:14:01.555]                               next
[16:14:01.555]                             invokeRestart(restart)
[16:14:01.555]                             muffled <- TRUE
[16:14:01.555]                             break
[16:14:01.555]                           }
[16:14:01.555]                         }
[16:14:01.555]                       }
[16:14:01.555]                       invisible(muffled)
[16:14:01.555]                     }
[16:14:01.555]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.555]                   }
[16:14:01.555]                 }
[16:14:01.555]                 else {
[16:14:01.555]                   if (TRUE) {
[16:14:01.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.555]                     {
[16:14:01.555]                       inherits <- base::inherits
[16:14:01.555]                       invokeRestart <- base::invokeRestart
[16:14:01.555]                       is.null <- base::is.null
[16:14:01.555]                       muffled <- FALSE
[16:14:01.555]                       if (inherits(cond, "message")) {
[16:14:01.555]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.555]                         if (muffled) 
[16:14:01.555]                           invokeRestart("muffleMessage")
[16:14:01.555]                       }
[16:14:01.555]                       else if (inherits(cond, "warning")) {
[16:14:01.555]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.555]                         if (muffled) 
[16:14:01.555]                           invokeRestart("muffleWarning")
[16:14:01.555]                       }
[16:14:01.555]                       else if (inherits(cond, "condition")) {
[16:14:01.555]                         if (!is.null(pattern)) {
[16:14:01.555]                           computeRestarts <- base::computeRestarts
[16:14:01.555]                           grepl <- base::grepl
[16:14:01.555]                           restarts <- computeRestarts(cond)
[16:14:01.555]                           for (restart in restarts) {
[16:14:01.555]                             name <- restart$name
[16:14:01.555]                             if (is.null(name)) 
[16:14:01.555]                               next
[16:14:01.555]                             if (!grepl(pattern, name)) 
[16:14:01.555]                               next
[16:14:01.555]                             invokeRestart(restart)
[16:14:01.555]                             muffled <- TRUE
[16:14:01.555]                             break
[16:14:01.555]                           }
[16:14:01.555]                         }
[16:14:01.555]                       }
[16:14:01.555]                       invisible(muffled)
[16:14:01.555]                     }
[16:14:01.555]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.555]                   }
[16:14:01.555]                 }
[16:14:01.555]             }
[16:14:01.555]         }))
[16:14:01.555]     }, error = function(ex) {
[16:14:01.555]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:01.555]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.555]                 ...future.rng), started = ...future.startTime, 
[16:14:01.555]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:01.555]             version = "1.8"), class = "FutureResult")
[16:14:01.555]     }, finally = {
[16:14:01.555]         if (!identical(...future.workdir, getwd())) 
[16:14:01.555]             setwd(...future.workdir)
[16:14:01.555]         {
[16:14:01.555]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:01.555]                 ...future.oldOptions$nwarnings <- NULL
[16:14:01.555]             }
[16:14:01.555]             base::options(...future.oldOptions)
[16:14:01.555]             if (.Platform$OS.type == "windows") {
[16:14:01.555]                 old_names <- names(...future.oldEnvVars)
[16:14:01.555]                 envs <- base::Sys.getenv()
[16:14:01.555]                 names <- names(envs)
[16:14:01.555]                 common <- intersect(names, old_names)
[16:14:01.555]                 added <- setdiff(names, old_names)
[16:14:01.555]                 removed <- setdiff(old_names, names)
[16:14:01.555]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:01.555]                   envs[common]]
[16:14:01.555]                 NAMES <- toupper(changed)
[16:14:01.555]                 args <- list()
[16:14:01.555]                 for (kk in seq_along(NAMES)) {
[16:14:01.555]                   name <- changed[[kk]]
[16:14:01.555]                   NAME <- NAMES[[kk]]
[16:14:01.555]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.555]                     next
[16:14:01.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.555]                 }
[16:14:01.555]                 NAMES <- toupper(added)
[16:14:01.555]                 for (kk in seq_along(NAMES)) {
[16:14:01.555]                   name <- added[[kk]]
[16:14:01.555]                   NAME <- NAMES[[kk]]
[16:14:01.555]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.555]                     next
[16:14:01.555]                   args[[name]] <- ""
[16:14:01.555]                 }
[16:14:01.555]                 NAMES <- toupper(removed)
[16:14:01.555]                 for (kk in seq_along(NAMES)) {
[16:14:01.555]                   name <- removed[[kk]]
[16:14:01.555]                   NAME <- NAMES[[kk]]
[16:14:01.555]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.555]                     next
[16:14:01.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.555]                 }
[16:14:01.555]                 if (length(args) > 0) 
[16:14:01.555]                   base::do.call(base::Sys.setenv, args = args)
[16:14:01.555]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:01.555]             }
[16:14:01.555]             else {
[16:14:01.555]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:01.555]             }
[16:14:01.555]             {
[16:14:01.555]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:01.555]                   0L) {
[16:14:01.555]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:01.555]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:01.555]                   base::options(opts)
[16:14:01.555]                 }
[16:14:01.555]                 {
[16:14:01.555]                   {
[16:14:01.555]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:01.555]                     NULL
[16:14:01.555]                   }
[16:14:01.555]                   options(future.plan = NULL)
[16:14:01.555]                   if (is.na(NA_character_)) 
[16:14:01.555]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.555]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:01.555]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:01.555]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:01.555]                     envir = parent.frame()) 
[16:14:01.555]                   {
[16:14:01.555]                     if (is.function(workers)) 
[16:14:01.555]                       workers <- workers()
[16:14:01.555]                     workers <- structure(as.integer(workers), 
[16:14:01.555]                       class = class(workers))
[16:14:01.555]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:01.555]                       workers >= 1)
[16:14:01.555]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:01.555]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:01.555]                     }
[16:14:01.555]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:01.555]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:01.555]                       envir = envir)
[16:14:01.555]                     if (!future$lazy) 
[16:14:01.555]                       future <- run(future)
[16:14:01.555]                     invisible(future)
[16:14:01.555]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:01.555]                 }
[16:14:01.555]             }
[16:14:01.555]         }
[16:14:01.555]     })
[16:14:01.555]     if (TRUE) {
[16:14:01.555]         base::sink(type = "output", split = FALSE)
[16:14:01.555]         if (TRUE) {
[16:14:01.555]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:01.555]         }
[16:14:01.555]         else {
[16:14:01.555]             ...future.result["stdout"] <- base::list(NULL)
[16:14:01.555]         }
[16:14:01.555]         base::close(...future.stdout)
[16:14:01.555]         ...future.stdout <- NULL
[16:14:01.555]     }
[16:14:01.555]     ...future.result$conditions <- ...future.conditions
[16:14:01.555]     ...future.result$finished <- base::Sys.time()
[16:14:01.555]     ...future.result
[16:14:01.555] }
[16:14:01.558] MultisessionFuture started
[16:14:01.558] - Launch lazy future ... done
[16:14:01.558] run() for ‘MultisessionFuture’ ... done
[16:14:01.559] resolve() on list environment ...
[16:14:01.559]  recursive: 0
[16:14:01.559]  length: 3
[16:14:01.559]  elements: ‘a’, ‘b’, ‘c’
[16:14:01.580]  length: 2 (resolved future 3)
[16:14:01.591] receiveMessageFromWorker() for ClusterFuture ...
[16:14:01.591] - Validating connection of MultisessionFuture
[16:14:01.591] - received message: FutureResult
[16:14:01.592] - Received FutureResult
[16:14:01.592] - Erased future from FutureRegistry
[16:14:01.592] result() for ClusterFuture ...
[16:14:01.592] - result already collected: FutureResult
[16:14:01.592] result() for ClusterFuture ... done
[16:14:01.592] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:01.592] Future #1
[16:14:01.592]  length: 1 (resolved future 1)
[16:14:01.613] receiveMessageFromWorker() for ClusterFuture ...
[16:14:01.613] - Validating connection of MultisessionFuture
[16:14:01.614] - received message: FutureResult
[16:14:01.614] - Received FutureResult
[16:14:01.614] - Erased future from FutureRegistry
[16:14:01.614] result() for ClusterFuture ...
[16:14:01.614] - result already collected: FutureResult
[16:14:01.614] result() for ClusterFuture ... done
[16:14:01.614] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:01.614] Future #2
[16:14:01.614]  length: 0 (resolved future 2)
[16:14:01.615] resolve() on list environment ... DONE
[16:14:01.615] getGlobalsAndPackages() ...
[16:14:01.615] Searching for globals...
[16:14:01.616] - globals found: [1] ‘{’
[16:14:01.616] Searching for globals ... DONE
[16:14:01.616] Resolving globals: FALSE
[16:14:01.616] 
[16:14:01.616] 
[16:14:01.616] getGlobalsAndPackages() ... DONE
[16:14:01.617] run() for ‘Future’ ...
[16:14:01.617] - state: ‘created’
[16:14:01.617] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:01.631] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:01.631] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:01.631]   - Field: ‘node’
[16:14:01.631]   - Field: ‘label’
[16:14:01.631]   - Field: ‘local’
[16:14:01.632]   - Field: ‘owner’
[16:14:01.632]   - Field: ‘envir’
[16:14:01.632]   - Field: ‘workers’
[16:14:01.632]   - Field: ‘packages’
[16:14:01.632]   - Field: ‘gc’
[16:14:01.632]   - Field: ‘conditions’
[16:14:01.632]   - Field: ‘persistent’
[16:14:01.632]   - Field: ‘expr’
[16:14:01.632]   - Field: ‘uuid’
[16:14:01.633]   - Field: ‘seed’
[16:14:01.633]   - Field: ‘version’
[16:14:01.633]   - Field: ‘result’
[16:14:01.633]   - Field: ‘asynchronous’
[16:14:01.633]   - Field: ‘calls’
[16:14:01.633]   - Field: ‘globals’
[16:14:01.633]   - Field: ‘stdout’
[16:14:01.633]   - Field: ‘earlySignal’
[16:14:01.633]   - Field: ‘lazy’
[16:14:01.633]   - Field: ‘state’
[16:14:01.633] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:01.634] - Launch lazy future ...
[16:14:01.634] Packages needed by the future expression (n = 0): <none>
[16:14:01.634] Packages needed by future strategies (n = 0): <none>
[16:14:01.634] {
[16:14:01.634]     {
[16:14:01.634]         {
[16:14:01.634]             ...future.startTime <- base::Sys.time()
[16:14:01.634]             {
[16:14:01.634]                 {
[16:14:01.634]                   {
[16:14:01.634]                     {
[16:14:01.634]                       base::local({
[16:14:01.634]                         has_future <- base::requireNamespace("future", 
[16:14:01.634]                           quietly = TRUE)
[16:14:01.634]                         if (has_future) {
[16:14:01.634]                           ns <- base::getNamespace("future")
[16:14:01.634]                           version <- ns[[".package"]][["version"]]
[16:14:01.634]                           if (is.null(version)) 
[16:14:01.634]                             version <- utils::packageVersion("future")
[16:14:01.634]                         }
[16:14:01.634]                         else {
[16:14:01.634]                           version <- NULL
[16:14:01.634]                         }
[16:14:01.634]                         if (!has_future || version < "1.8.0") {
[16:14:01.634]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:01.634]                             "", base::R.version$version.string), 
[16:14:01.634]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:01.634]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:01.634]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:01.634]                               "release", "version")], collapse = " "), 
[16:14:01.634]                             hostname = base::Sys.info()[["nodename"]])
[16:14:01.634]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:01.634]                             info)
[16:14:01.634]                           info <- base::paste(info, collapse = "; ")
[16:14:01.634]                           if (!has_future) {
[16:14:01.634]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:01.634]                               info)
[16:14:01.634]                           }
[16:14:01.634]                           else {
[16:14:01.634]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:01.634]                               info, version)
[16:14:01.634]                           }
[16:14:01.634]                           base::stop(msg)
[16:14:01.634]                         }
[16:14:01.634]                       })
[16:14:01.634]                     }
[16:14:01.634]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:01.634]                     base::options(mc.cores = 1L)
[16:14:01.634]                   }
[16:14:01.634]                   options(future.plan = NULL)
[16:14:01.634]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.634]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:01.634]                 }
[16:14:01.634]                 ...future.workdir <- getwd()
[16:14:01.634]             }
[16:14:01.634]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:01.634]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:01.634]         }
[16:14:01.634]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:01.634]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:01.634]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:01.634]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:01.634]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:01.634]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:01.634]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:01.634]             base::names(...future.oldOptions))
[16:14:01.634]     }
[16:14:01.634]     if (FALSE) {
[16:14:01.634]     }
[16:14:01.634]     else {
[16:14:01.634]         if (TRUE) {
[16:14:01.634]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:01.634]                 open = "w")
[16:14:01.634]         }
[16:14:01.634]         else {
[16:14:01.634]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:01.634]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:01.634]         }
[16:14:01.634]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:01.634]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:01.634]             base::sink(type = "output", split = FALSE)
[16:14:01.634]             base::close(...future.stdout)
[16:14:01.634]         }, add = TRUE)
[16:14:01.634]     }
[16:14:01.634]     ...future.frame <- base::sys.nframe()
[16:14:01.634]     ...future.conditions <- base::list()
[16:14:01.634]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:01.634]     if (FALSE) {
[16:14:01.634]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:01.634]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:01.634]     }
[16:14:01.634]     ...future.result <- base::tryCatch({
[16:14:01.634]         base::withCallingHandlers({
[16:14:01.634]             ...future.value <- base::withVisible(base::local({
[16:14:01.634]                 ...future.makeSendCondition <- local({
[16:14:01.634]                   sendCondition <- NULL
[16:14:01.634]                   function(frame = 1L) {
[16:14:01.634]                     if (is.function(sendCondition)) 
[16:14:01.634]                       return(sendCondition)
[16:14:01.634]                     ns <- getNamespace("parallel")
[16:14:01.634]                     if (exists("sendData", mode = "function", 
[16:14:01.634]                       envir = ns)) {
[16:14:01.634]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:01.634]                         envir = ns)
[16:14:01.634]                       envir <- sys.frame(frame)
[16:14:01.634]                       master <- NULL
[16:14:01.634]                       while (!identical(envir, .GlobalEnv) && 
[16:14:01.634]                         !identical(envir, emptyenv())) {
[16:14:01.634]                         if (exists("master", mode = "list", envir = envir, 
[16:14:01.634]                           inherits = FALSE)) {
[16:14:01.634]                           master <- get("master", mode = "list", 
[16:14:01.634]                             envir = envir, inherits = FALSE)
[16:14:01.634]                           if (inherits(master, c("SOCKnode", 
[16:14:01.634]                             "SOCK0node"))) {
[16:14:01.634]                             sendCondition <<- function(cond) {
[16:14:01.634]                               data <- list(type = "VALUE", value = cond, 
[16:14:01.634]                                 success = TRUE)
[16:14:01.634]                               parallel_sendData(master, data)
[16:14:01.634]                             }
[16:14:01.634]                             return(sendCondition)
[16:14:01.634]                           }
[16:14:01.634]                         }
[16:14:01.634]                         frame <- frame + 1L
[16:14:01.634]                         envir <- sys.frame(frame)
[16:14:01.634]                       }
[16:14:01.634]                     }
[16:14:01.634]                     sendCondition <<- function(cond) NULL
[16:14:01.634]                   }
[16:14:01.634]                 })
[16:14:01.634]                 withCallingHandlers({
[16:14:01.634]                   {
[16:14:01.634]                     1
[16:14:01.634]                   }
[16:14:01.634]                 }, immediateCondition = function(cond) {
[16:14:01.634]                   sendCondition <- ...future.makeSendCondition()
[16:14:01.634]                   sendCondition(cond)
[16:14:01.634]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.634]                   {
[16:14:01.634]                     inherits <- base::inherits
[16:14:01.634]                     invokeRestart <- base::invokeRestart
[16:14:01.634]                     is.null <- base::is.null
[16:14:01.634]                     muffled <- FALSE
[16:14:01.634]                     if (inherits(cond, "message")) {
[16:14:01.634]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:01.634]                       if (muffled) 
[16:14:01.634]                         invokeRestart("muffleMessage")
[16:14:01.634]                     }
[16:14:01.634]                     else if (inherits(cond, "warning")) {
[16:14:01.634]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:01.634]                       if (muffled) 
[16:14:01.634]                         invokeRestart("muffleWarning")
[16:14:01.634]                     }
[16:14:01.634]                     else if (inherits(cond, "condition")) {
[16:14:01.634]                       if (!is.null(pattern)) {
[16:14:01.634]                         computeRestarts <- base::computeRestarts
[16:14:01.634]                         grepl <- base::grepl
[16:14:01.634]                         restarts <- computeRestarts(cond)
[16:14:01.634]                         for (restart in restarts) {
[16:14:01.634]                           name <- restart$name
[16:14:01.634]                           if (is.null(name)) 
[16:14:01.634]                             next
[16:14:01.634]                           if (!grepl(pattern, name)) 
[16:14:01.634]                             next
[16:14:01.634]                           invokeRestart(restart)
[16:14:01.634]                           muffled <- TRUE
[16:14:01.634]                           break
[16:14:01.634]                         }
[16:14:01.634]                       }
[16:14:01.634]                     }
[16:14:01.634]                     invisible(muffled)
[16:14:01.634]                   }
[16:14:01.634]                   muffleCondition(cond)
[16:14:01.634]                 })
[16:14:01.634]             }))
[16:14:01.634]             future::FutureResult(value = ...future.value$value, 
[16:14:01.634]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.634]                   ...future.rng), globalenv = if (FALSE) 
[16:14:01.634]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:01.634]                     ...future.globalenv.names))
[16:14:01.634]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:01.634]         }, condition = base::local({
[16:14:01.634]             c <- base::c
[16:14:01.634]             inherits <- base::inherits
[16:14:01.634]             invokeRestart <- base::invokeRestart
[16:14:01.634]             length <- base::length
[16:14:01.634]             list <- base::list
[16:14:01.634]             seq.int <- base::seq.int
[16:14:01.634]             signalCondition <- base::signalCondition
[16:14:01.634]             sys.calls <- base::sys.calls
[16:14:01.634]             `[[` <- base::`[[`
[16:14:01.634]             `+` <- base::`+`
[16:14:01.634]             `<<-` <- base::`<<-`
[16:14:01.634]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:01.634]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:01.634]                   3L)]
[16:14:01.634]             }
[16:14:01.634]             function(cond) {
[16:14:01.634]                 is_error <- inherits(cond, "error")
[16:14:01.634]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:01.634]                   NULL)
[16:14:01.634]                 if (is_error) {
[16:14:01.634]                   sessionInformation <- function() {
[16:14:01.634]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:01.634]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:01.634]                       search = base::search(), system = base::Sys.info())
[16:14:01.634]                   }
[16:14:01.634]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.634]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:01.634]                     cond$call), session = sessionInformation(), 
[16:14:01.634]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:01.634]                   signalCondition(cond)
[16:14:01.634]                 }
[16:14:01.634]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:01.634]                 "immediateCondition"))) {
[16:14:01.634]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:01.634]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.634]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:01.634]                   if (TRUE && !signal) {
[16:14:01.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.634]                     {
[16:14:01.634]                       inherits <- base::inherits
[16:14:01.634]                       invokeRestart <- base::invokeRestart
[16:14:01.634]                       is.null <- base::is.null
[16:14:01.634]                       muffled <- FALSE
[16:14:01.634]                       if (inherits(cond, "message")) {
[16:14:01.634]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.634]                         if (muffled) 
[16:14:01.634]                           invokeRestart("muffleMessage")
[16:14:01.634]                       }
[16:14:01.634]                       else if (inherits(cond, "warning")) {
[16:14:01.634]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.634]                         if (muffled) 
[16:14:01.634]                           invokeRestart("muffleWarning")
[16:14:01.634]                       }
[16:14:01.634]                       else if (inherits(cond, "condition")) {
[16:14:01.634]                         if (!is.null(pattern)) {
[16:14:01.634]                           computeRestarts <- base::computeRestarts
[16:14:01.634]                           grepl <- base::grepl
[16:14:01.634]                           restarts <- computeRestarts(cond)
[16:14:01.634]                           for (restart in restarts) {
[16:14:01.634]                             name <- restart$name
[16:14:01.634]                             if (is.null(name)) 
[16:14:01.634]                               next
[16:14:01.634]                             if (!grepl(pattern, name)) 
[16:14:01.634]                               next
[16:14:01.634]                             invokeRestart(restart)
[16:14:01.634]                             muffled <- TRUE
[16:14:01.634]                             break
[16:14:01.634]                           }
[16:14:01.634]                         }
[16:14:01.634]                       }
[16:14:01.634]                       invisible(muffled)
[16:14:01.634]                     }
[16:14:01.634]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.634]                   }
[16:14:01.634]                 }
[16:14:01.634]                 else {
[16:14:01.634]                   if (TRUE) {
[16:14:01.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.634]                     {
[16:14:01.634]                       inherits <- base::inherits
[16:14:01.634]                       invokeRestart <- base::invokeRestart
[16:14:01.634]                       is.null <- base::is.null
[16:14:01.634]                       muffled <- FALSE
[16:14:01.634]                       if (inherits(cond, "message")) {
[16:14:01.634]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.634]                         if (muffled) 
[16:14:01.634]                           invokeRestart("muffleMessage")
[16:14:01.634]                       }
[16:14:01.634]                       else if (inherits(cond, "warning")) {
[16:14:01.634]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.634]                         if (muffled) 
[16:14:01.634]                           invokeRestart("muffleWarning")
[16:14:01.634]                       }
[16:14:01.634]                       else if (inherits(cond, "condition")) {
[16:14:01.634]                         if (!is.null(pattern)) {
[16:14:01.634]                           computeRestarts <- base::computeRestarts
[16:14:01.634]                           grepl <- base::grepl
[16:14:01.634]                           restarts <- computeRestarts(cond)
[16:14:01.634]                           for (restart in restarts) {
[16:14:01.634]                             name <- restart$name
[16:14:01.634]                             if (is.null(name)) 
[16:14:01.634]                               next
[16:14:01.634]                             if (!grepl(pattern, name)) 
[16:14:01.634]                               next
[16:14:01.634]                             invokeRestart(restart)
[16:14:01.634]                             muffled <- TRUE
[16:14:01.634]                             break
[16:14:01.634]                           }
[16:14:01.634]                         }
[16:14:01.634]                       }
[16:14:01.634]                       invisible(muffled)
[16:14:01.634]                     }
[16:14:01.634]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.634]                   }
[16:14:01.634]                 }
[16:14:01.634]             }
[16:14:01.634]         }))
[16:14:01.634]     }, error = function(ex) {
[16:14:01.634]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:01.634]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.634]                 ...future.rng), started = ...future.startTime, 
[16:14:01.634]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:01.634]             version = "1.8"), class = "FutureResult")
[16:14:01.634]     }, finally = {
[16:14:01.634]         if (!identical(...future.workdir, getwd())) 
[16:14:01.634]             setwd(...future.workdir)
[16:14:01.634]         {
[16:14:01.634]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:01.634]                 ...future.oldOptions$nwarnings <- NULL
[16:14:01.634]             }
[16:14:01.634]             base::options(...future.oldOptions)
[16:14:01.634]             if (.Platform$OS.type == "windows") {
[16:14:01.634]                 old_names <- names(...future.oldEnvVars)
[16:14:01.634]                 envs <- base::Sys.getenv()
[16:14:01.634]                 names <- names(envs)
[16:14:01.634]                 common <- intersect(names, old_names)
[16:14:01.634]                 added <- setdiff(names, old_names)
[16:14:01.634]                 removed <- setdiff(old_names, names)
[16:14:01.634]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:01.634]                   envs[common]]
[16:14:01.634]                 NAMES <- toupper(changed)
[16:14:01.634]                 args <- list()
[16:14:01.634]                 for (kk in seq_along(NAMES)) {
[16:14:01.634]                   name <- changed[[kk]]
[16:14:01.634]                   NAME <- NAMES[[kk]]
[16:14:01.634]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.634]                     next
[16:14:01.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.634]                 }
[16:14:01.634]                 NAMES <- toupper(added)
[16:14:01.634]                 for (kk in seq_along(NAMES)) {
[16:14:01.634]                   name <- added[[kk]]
[16:14:01.634]                   NAME <- NAMES[[kk]]
[16:14:01.634]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.634]                     next
[16:14:01.634]                   args[[name]] <- ""
[16:14:01.634]                 }
[16:14:01.634]                 NAMES <- toupper(removed)
[16:14:01.634]                 for (kk in seq_along(NAMES)) {
[16:14:01.634]                   name <- removed[[kk]]
[16:14:01.634]                   NAME <- NAMES[[kk]]
[16:14:01.634]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.634]                     next
[16:14:01.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.634]                 }
[16:14:01.634]                 if (length(args) > 0) 
[16:14:01.634]                   base::do.call(base::Sys.setenv, args = args)
[16:14:01.634]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:01.634]             }
[16:14:01.634]             else {
[16:14:01.634]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:01.634]             }
[16:14:01.634]             {
[16:14:01.634]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:01.634]                   0L) {
[16:14:01.634]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:01.634]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:01.634]                   base::options(opts)
[16:14:01.634]                 }
[16:14:01.634]                 {
[16:14:01.634]                   {
[16:14:01.634]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:01.634]                     NULL
[16:14:01.634]                   }
[16:14:01.634]                   options(future.plan = NULL)
[16:14:01.634]                   if (is.na(NA_character_)) 
[16:14:01.634]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.634]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:01.634]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:01.634]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:01.634]                     envir = parent.frame()) 
[16:14:01.634]                   {
[16:14:01.634]                     if (is.function(workers)) 
[16:14:01.634]                       workers <- workers()
[16:14:01.634]                     workers <- structure(as.integer(workers), 
[16:14:01.634]                       class = class(workers))
[16:14:01.634]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:01.634]                       workers >= 1)
[16:14:01.634]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:01.634]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:01.634]                     }
[16:14:01.634]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:01.634]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:01.634]                       envir = envir)
[16:14:01.634]                     if (!future$lazy) 
[16:14:01.634]                       future <- run(future)
[16:14:01.634]                     invisible(future)
[16:14:01.634]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:01.634]                 }
[16:14:01.634]             }
[16:14:01.634]         }
[16:14:01.634]     })
[16:14:01.634]     if (TRUE) {
[16:14:01.634]         base::sink(type = "output", split = FALSE)
[16:14:01.634]         if (TRUE) {
[16:14:01.634]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:01.634]         }
[16:14:01.634]         else {
[16:14:01.634]             ...future.result["stdout"] <- base::list(NULL)
[16:14:01.634]         }
[16:14:01.634]         base::close(...future.stdout)
[16:14:01.634]         ...future.stdout <- NULL
[16:14:01.634]     }
[16:14:01.634]     ...future.result$conditions <- ...future.conditions
[16:14:01.634]     ...future.result$finished <- base::Sys.time()
[16:14:01.634]     ...future.result
[16:14:01.634] }
[16:14:01.637] MultisessionFuture started
[16:14:01.637] - Launch lazy future ... done
[16:14:01.638] run() for ‘MultisessionFuture’ ... done
[16:14:01.638] getGlobalsAndPackages() ...
[16:14:01.638] Searching for globals...
[16:14:01.639] - globals found: [2] ‘{’, ‘Sys.sleep’
[16:14:01.639] Searching for globals ... DONE
[16:14:01.639] Resolving globals: FALSE
[16:14:01.639] 
[16:14:01.640] 
[16:14:01.640] getGlobalsAndPackages() ... DONE
[16:14:01.643] run() for ‘Future’ ...
[16:14:01.643] - state: ‘created’
[16:14:01.643] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:01.658] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:01.658] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:01.658]   - Field: ‘node’
[16:14:01.658]   - Field: ‘label’
[16:14:01.658]   - Field: ‘local’
[16:14:01.658]   - Field: ‘owner’
[16:14:01.658]   - Field: ‘envir’
[16:14:01.658]   - Field: ‘workers’
[16:14:01.658]   - Field: ‘packages’
[16:14:01.659]   - Field: ‘gc’
[16:14:01.659]   - Field: ‘conditions’
[16:14:01.659]   - Field: ‘persistent’
[16:14:01.659]   - Field: ‘expr’
[16:14:01.659]   - Field: ‘uuid’
[16:14:01.659]   - Field: ‘seed’
[16:14:01.659]   - Field: ‘version’
[16:14:01.659]   - Field: ‘result’
[16:14:01.659]   - Field: ‘asynchronous’
[16:14:01.659]   - Field: ‘calls’
[16:14:01.659]   - Field: ‘globals’
[16:14:01.660]   - Field: ‘stdout’
[16:14:01.660]   - Field: ‘earlySignal’
[16:14:01.660]   - Field: ‘lazy’
[16:14:01.660]   - Field: ‘state’
[16:14:01.660] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:01.660] - Launch lazy future ...
[16:14:01.660] Packages needed by the future expression (n = 0): <none>
[16:14:01.660] Packages needed by future strategies (n = 0): <none>
[16:14:01.661] {
[16:14:01.661]     {
[16:14:01.661]         {
[16:14:01.661]             ...future.startTime <- base::Sys.time()
[16:14:01.661]             {
[16:14:01.661]                 {
[16:14:01.661]                   {
[16:14:01.661]                     {
[16:14:01.661]                       base::local({
[16:14:01.661]                         has_future <- base::requireNamespace("future", 
[16:14:01.661]                           quietly = TRUE)
[16:14:01.661]                         if (has_future) {
[16:14:01.661]                           ns <- base::getNamespace("future")
[16:14:01.661]                           version <- ns[[".package"]][["version"]]
[16:14:01.661]                           if (is.null(version)) 
[16:14:01.661]                             version <- utils::packageVersion("future")
[16:14:01.661]                         }
[16:14:01.661]                         else {
[16:14:01.661]                           version <- NULL
[16:14:01.661]                         }
[16:14:01.661]                         if (!has_future || version < "1.8.0") {
[16:14:01.661]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:01.661]                             "", base::R.version$version.string), 
[16:14:01.661]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:01.661]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:01.661]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:01.661]                               "release", "version")], collapse = " "), 
[16:14:01.661]                             hostname = base::Sys.info()[["nodename"]])
[16:14:01.661]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:01.661]                             info)
[16:14:01.661]                           info <- base::paste(info, collapse = "; ")
[16:14:01.661]                           if (!has_future) {
[16:14:01.661]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:01.661]                               info)
[16:14:01.661]                           }
[16:14:01.661]                           else {
[16:14:01.661]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:01.661]                               info, version)
[16:14:01.661]                           }
[16:14:01.661]                           base::stop(msg)
[16:14:01.661]                         }
[16:14:01.661]                       })
[16:14:01.661]                     }
[16:14:01.661]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:01.661]                     base::options(mc.cores = 1L)
[16:14:01.661]                   }
[16:14:01.661]                   options(future.plan = NULL)
[16:14:01.661]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.661]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:01.661]                 }
[16:14:01.661]                 ...future.workdir <- getwd()
[16:14:01.661]             }
[16:14:01.661]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:01.661]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:01.661]         }
[16:14:01.661]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:01.661]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:01.661]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:01.661]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:01.661]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:01.661]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:01.661]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:01.661]             base::names(...future.oldOptions))
[16:14:01.661]     }
[16:14:01.661]     if (FALSE) {
[16:14:01.661]     }
[16:14:01.661]     else {
[16:14:01.661]         if (TRUE) {
[16:14:01.661]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:01.661]                 open = "w")
[16:14:01.661]         }
[16:14:01.661]         else {
[16:14:01.661]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:01.661]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:01.661]         }
[16:14:01.661]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:01.661]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:01.661]             base::sink(type = "output", split = FALSE)
[16:14:01.661]             base::close(...future.stdout)
[16:14:01.661]         }, add = TRUE)
[16:14:01.661]     }
[16:14:01.661]     ...future.frame <- base::sys.nframe()
[16:14:01.661]     ...future.conditions <- base::list()
[16:14:01.661]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:01.661]     if (FALSE) {
[16:14:01.661]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:01.661]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:01.661]     }
[16:14:01.661]     ...future.result <- base::tryCatch({
[16:14:01.661]         base::withCallingHandlers({
[16:14:01.661]             ...future.value <- base::withVisible(base::local({
[16:14:01.661]                 ...future.makeSendCondition <- local({
[16:14:01.661]                   sendCondition <- NULL
[16:14:01.661]                   function(frame = 1L) {
[16:14:01.661]                     if (is.function(sendCondition)) 
[16:14:01.661]                       return(sendCondition)
[16:14:01.661]                     ns <- getNamespace("parallel")
[16:14:01.661]                     if (exists("sendData", mode = "function", 
[16:14:01.661]                       envir = ns)) {
[16:14:01.661]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:01.661]                         envir = ns)
[16:14:01.661]                       envir <- sys.frame(frame)
[16:14:01.661]                       master <- NULL
[16:14:01.661]                       while (!identical(envir, .GlobalEnv) && 
[16:14:01.661]                         !identical(envir, emptyenv())) {
[16:14:01.661]                         if (exists("master", mode = "list", envir = envir, 
[16:14:01.661]                           inherits = FALSE)) {
[16:14:01.661]                           master <- get("master", mode = "list", 
[16:14:01.661]                             envir = envir, inherits = FALSE)
[16:14:01.661]                           if (inherits(master, c("SOCKnode", 
[16:14:01.661]                             "SOCK0node"))) {
[16:14:01.661]                             sendCondition <<- function(cond) {
[16:14:01.661]                               data <- list(type = "VALUE", value = cond, 
[16:14:01.661]                                 success = TRUE)
[16:14:01.661]                               parallel_sendData(master, data)
[16:14:01.661]                             }
[16:14:01.661]                             return(sendCondition)
[16:14:01.661]                           }
[16:14:01.661]                         }
[16:14:01.661]                         frame <- frame + 1L
[16:14:01.661]                         envir <- sys.frame(frame)
[16:14:01.661]                       }
[16:14:01.661]                     }
[16:14:01.661]                     sendCondition <<- function(cond) NULL
[16:14:01.661]                   }
[16:14:01.661]                 })
[16:14:01.661]                 withCallingHandlers({
[16:14:01.661]                   {
[16:14:01.661]                     Sys.sleep(0.5)
[16:14:01.661]                     2
[16:14:01.661]                   }
[16:14:01.661]                 }, immediateCondition = function(cond) {
[16:14:01.661]                   sendCondition <- ...future.makeSendCondition()
[16:14:01.661]                   sendCondition(cond)
[16:14:01.661]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.661]                   {
[16:14:01.661]                     inherits <- base::inherits
[16:14:01.661]                     invokeRestart <- base::invokeRestart
[16:14:01.661]                     is.null <- base::is.null
[16:14:01.661]                     muffled <- FALSE
[16:14:01.661]                     if (inherits(cond, "message")) {
[16:14:01.661]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:01.661]                       if (muffled) 
[16:14:01.661]                         invokeRestart("muffleMessage")
[16:14:01.661]                     }
[16:14:01.661]                     else if (inherits(cond, "warning")) {
[16:14:01.661]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:01.661]                       if (muffled) 
[16:14:01.661]                         invokeRestart("muffleWarning")
[16:14:01.661]                     }
[16:14:01.661]                     else if (inherits(cond, "condition")) {
[16:14:01.661]                       if (!is.null(pattern)) {
[16:14:01.661]                         computeRestarts <- base::computeRestarts
[16:14:01.661]                         grepl <- base::grepl
[16:14:01.661]                         restarts <- computeRestarts(cond)
[16:14:01.661]                         for (restart in restarts) {
[16:14:01.661]                           name <- restart$name
[16:14:01.661]                           if (is.null(name)) 
[16:14:01.661]                             next
[16:14:01.661]                           if (!grepl(pattern, name)) 
[16:14:01.661]                             next
[16:14:01.661]                           invokeRestart(restart)
[16:14:01.661]                           muffled <- TRUE
[16:14:01.661]                           break
[16:14:01.661]                         }
[16:14:01.661]                       }
[16:14:01.661]                     }
[16:14:01.661]                     invisible(muffled)
[16:14:01.661]                   }
[16:14:01.661]                   muffleCondition(cond)
[16:14:01.661]                 })
[16:14:01.661]             }))
[16:14:01.661]             future::FutureResult(value = ...future.value$value, 
[16:14:01.661]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.661]                   ...future.rng), globalenv = if (FALSE) 
[16:14:01.661]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:01.661]                     ...future.globalenv.names))
[16:14:01.661]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:01.661]         }, condition = base::local({
[16:14:01.661]             c <- base::c
[16:14:01.661]             inherits <- base::inherits
[16:14:01.661]             invokeRestart <- base::invokeRestart
[16:14:01.661]             length <- base::length
[16:14:01.661]             list <- base::list
[16:14:01.661]             seq.int <- base::seq.int
[16:14:01.661]             signalCondition <- base::signalCondition
[16:14:01.661]             sys.calls <- base::sys.calls
[16:14:01.661]             `[[` <- base::`[[`
[16:14:01.661]             `+` <- base::`+`
[16:14:01.661]             `<<-` <- base::`<<-`
[16:14:01.661]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:01.661]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:01.661]                   3L)]
[16:14:01.661]             }
[16:14:01.661]             function(cond) {
[16:14:01.661]                 is_error <- inherits(cond, "error")
[16:14:01.661]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:01.661]                   NULL)
[16:14:01.661]                 if (is_error) {
[16:14:01.661]                   sessionInformation <- function() {
[16:14:01.661]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:01.661]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:01.661]                       search = base::search(), system = base::Sys.info())
[16:14:01.661]                   }
[16:14:01.661]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.661]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:01.661]                     cond$call), session = sessionInformation(), 
[16:14:01.661]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:01.661]                   signalCondition(cond)
[16:14:01.661]                 }
[16:14:01.661]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:01.661]                 "immediateCondition"))) {
[16:14:01.661]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:01.661]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.661]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:01.661]                   if (TRUE && !signal) {
[16:14:01.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.661]                     {
[16:14:01.661]                       inherits <- base::inherits
[16:14:01.661]                       invokeRestart <- base::invokeRestart
[16:14:01.661]                       is.null <- base::is.null
[16:14:01.661]                       muffled <- FALSE
[16:14:01.661]                       if (inherits(cond, "message")) {
[16:14:01.661]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.661]                         if (muffled) 
[16:14:01.661]                           invokeRestart("muffleMessage")
[16:14:01.661]                       }
[16:14:01.661]                       else if (inherits(cond, "warning")) {
[16:14:01.661]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.661]                         if (muffled) 
[16:14:01.661]                           invokeRestart("muffleWarning")
[16:14:01.661]                       }
[16:14:01.661]                       else if (inherits(cond, "condition")) {
[16:14:01.661]                         if (!is.null(pattern)) {
[16:14:01.661]                           computeRestarts <- base::computeRestarts
[16:14:01.661]                           grepl <- base::grepl
[16:14:01.661]                           restarts <- computeRestarts(cond)
[16:14:01.661]                           for (restart in restarts) {
[16:14:01.661]                             name <- restart$name
[16:14:01.661]                             if (is.null(name)) 
[16:14:01.661]                               next
[16:14:01.661]                             if (!grepl(pattern, name)) 
[16:14:01.661]                               next
[16:14:01.661]                             invokeRestart(restart)
[16:14:01.661]                             muffled <- TRUE
[16:14:01.661]                             break
[16:14:01.661]                           }
[16:14:01.661]                         }
[16:14:01.661]                       }
[16:14:01.661]                       invisible(muffled)
[16:14:01.661]                     }
[16:14:01.661]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.661]                   }
[16:14:01.661]                 }
[16:14:01.661]                 else {
[16:14:01.661]                   if (TRUE) {
[16:14:01.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.661]                     {
[16:14:01.661]                       inherits <- base::inherits
[16:14:01.661]                       invokeRestart <- base::invokeRestart
[16:14:01.661]                       is.null <- base::is.null
[16:14:01.661]                       muffled <- FALSE
[16:14:01.661]                       if (inherits(cond, "message")) {
[16:14:01.661]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.661]                         if (muffled) 
[16:14:01.661]                           invokeRestart("muffleMessage")
[16:14:01.661]                       }
[16:14:01.661]                       else if (inherits(cond, "warning")) {
[16:14:01.661]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.661]                         if (muffled) 
[16:14:01.661]                           invokeRestart("muffleWarning")
[16:14:01.661]                       }
[16:14:01.661]                       else if (inherits(cond, "condition")) {
[16:14:01.661]                         if (!is.null(pattern)) {
[16:14:01.661]                           computeRestarts <- base::computeRestarts
[16:14:01.661]                           grepl <- base::grepl
[16:14:01.661]                           restarts <- computeRestarts(cond)
[16:14:01.661]                           for (restart in restarts) {
[16:14:01.661]                             name <- restart$name
[16:14:01.661]                             if (is.null(name)) 
[16:14:01.661]                               next
[16:14:01.661]                             if (!grepl(pattern, name)) 
[16:14:01.661]                               next
[16:14:01.661]                             invokeRestart(restart)
[16:14:01.661]                             muffled <- TRUE
[16:14:01.661]                             break
[16:14:01.661]                           }
[16:14:01.661]                         }
[16:14:01.661]                       }
[16:14:01.661]                       invisible(muffled)
[16:14:01.661]                     }
[16:14:01.661]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.661]                   }
[16:14:01.661]                 }
[16:14:01.661]             }
[16:14:01.661]         }))
[16:14:01.661]     }, error = function(ex) {
[16:14:01.661]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:01.661]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.661]                 ...future.rng), started = ...future.startTime, 
[16:14:01.661]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:01.661]             version = "1.8"), class = "FutureResult")
[16:14:01.661]     }, finally = {
[16:14:01.661]         if (!identical(...future.workdir, getwd())) 
[16:14:01.661]             setwd(...future.workdir)
[16:14:01.661]         {
[16:14:01.661]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:01.661]                 ...future.oldOptions$nwarnings <- NULL
[16:14:01.661]             }
[16:14:01.661]             base::options(...future.oldOptions)
[16:14:01.661]             if (.Platform$OS.type == "windows") {
[16:14:01.661]                 old_names <- names(...future.oldEnvVars)
[16:14:01.661]                 envs <- base::Sys.getenv()
[16:14:01.661]                 names <- names(envs)
[16:14:01.661]                 common <- intersect(names, old_names)
[16:14:01.661]                 added <- setdiff(names, old_names)
[16:14:01.661]                 removed <- setdiff(old_names, names)
[16:14:01.661]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:01.661]                   envs[common]]
[16:14:01.661]                 NAMES <- toupper(changed)
[16:14:01.661]                 args <- list()
[16:14:01.661]                 for (kk in seq_along(NAMES)) {
[16:14:01.661]                   name <- changed[[kk]]
[16:14:01.661]                   NAME <- NAMES[[kk]]
[16:14:01.661]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.661]                     next
[16:14:01.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.661]                 }
[16:14:01.661]                 NAMES <- toupper(added)
[16:14:01.661]                 for (kk in seq_along(NAMES)) {
[16:14:01.661]                   name <- added[[kk]]
[16:14:01.661]                   NAME <- NAMES[[kk]]
[16:14:01.661]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.661]                     next
[16:14:01.661]                   args[[name]] <- ""
[16:14:01.661]                 }
[16:14:01.661]                 NAMES <- toupper(removed)
[16:14:01.661]                 for (kk in seq_along(NAMES)) {
[16:14:01.661]                   name <- removed[[kk]]
[16:14:01.661]                   NAME <- NAMES[[kk]]
[16:14:01.661]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.661]                     next
[16:14:01.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.661]                 }
[16:14:01.661]                 if (length(args) > 0) 
[16:14:01.661]                   base::do.call(base::Sys.setenv, args = args)
[16:14:01.661]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:01.661]             }
[16:14:01.661]             else {
[16:14:01.661]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:01.661]             }
[16:14:01.661]             {
[16:14:01.661]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:01.661]                   0L) {
[16:14:01.661]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:01.661]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:01.661]                   base::options(opts)
[16:14:01.661]                 }
[16:14:01.661]                 {
[16:14:01.661]                   {
[16:14:01.661]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:01.661]                     NULL
[16:14:01.661]                   }
[16:14:01.661]                   options(future.plan = NULL)
[16:14:01.661]                   if (is.na(NA_character_)) 
[16:14:01.661]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.661]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:01.661]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:01.661]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:01.661]                     envir = parent.frame()) 
[16:14:01.661]                   {
[16:14:01.661]                     if (is.function(workers)) 
[16:14:01.661]                       workers <- workers()
[16:14:01.661]                     workers <- structure(as.integer(workers), 
[16:14:01.661]                       class = class(workers))
[16:14:01.661]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:01.661]                       workers >= 1)
[16:14:01.661]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:01.661]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:01.661]                     }
[16:14:01.661]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:01.661]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:01.661]                       envir = envir)
[16:14:01.661]                     if (!future$lazy) 
[16:14:01.661]                       future <- run(future)
[16:14:01.661]                     invisible(future)
[16:14:01.661]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:01.661]                 }
[16:14:01.661]             }
[16:14:01.661]         }
[16:14:01.661]     })
[16:14:01.661]     if (TRUE) {
[16:14:01.661]         base::sink(type = "output", split = FALSE)
[16:14:01.661]         if (TRUE) {
[16:14:01.661]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:01.661]         }
[16:14:01.661]         else {
[16:14:01.661]             ...future.result["stdout"] <- base::list(NULL)
[16:14:01.661]         }
[16:14:01.661]         base::close(...future.stdout)
[16:14:01.661]         ...future.stdout <- NULL
[16:14:01.661]     }
[16:14:01.661]     ...future.result$conditions <- ...future.conditions
[16:14:01.661]     ...future.result$finished <- base::Sys.time()
[16:14:01.661]     ...future.result
[16:14:01.661] }
[16:14:01.664] MultisessionFuture started
[16:14:01.664] - Launch lazy future ... done
[16:14:01.664] run() for ‘MultisessionFuture’ ... done
[16:14:01.664] getGlobalsAndPackages() ...
[16:14:01.665] Searching for globals...
[16:14:01.665] - globals found: [1] ‘{’
[16:14:01.665] Searching for globals ... DONE
[16:14:01.665] Resolving globals: FALSE
[16:14:01.666] 
[16:14:01.666] 
[16:14:01.666] getGlobalsAndPackages() ... DONE
[16:14:01.666] run() for ‘Future’ ...
[16:14:01.666] - state: ‘created’
[16:14:01.666] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:14:01.680] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:14:01.680] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:14:01.680]   - Field: ‘node’
[16:14:01.680]   - Field: ‘label’
[16:14:01.680]   - Field: ‘local’
[16:14:01.681]   - Field: ‘owner’
[16:14:01.681]   - Field: ‘envir’
[16:14:01.681]   - Field: ‘workers’
[16:14:01.681]   - Field: ‘packages’
[16:14:01.681]   - Field: ‘gc’
[16:14:01.681]   - Field: ‘conditions’
[16:14:01.681]   - Field: ‘persistent’
[16:14:01.681]   - Field: ‘expr’
[16:14:01.681]   - Field: ‘uuid’
[16:14:01.681]   - Field: ‘seed’
[16:14:01.682]   - Field: ‘version’
[16:14:01.682]   - Field: ‘result’
[16:14:01.682]   - Field: ‘asynchronous’
[16:14:01.682]   - Field: ‘calls’
[16:14:01.682]   - Field: ‘globals’
[16:14:01.682]   - Field: ‘stdout’
[16:14:01.682]   - Field: ‘earlySignal’
[16:14:01.682]   - Field: ‘lazy’
[16:14:01.682]   - Field: ‘state’
[16:14:01.682] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:14:01.683] - Launch lazy future ...
[16:14:01.683] Packages needed by the future expression (n = 0): <none>
[16:14:01.683] Packages needed by future strategies (n = 0): <none>
[16:14:01.683] {
[16:14:01.683]     {
[16:14:01.683]         {
[16:14:01.683]             ...future.startTime <- base::Sys.time()
[16:14:01.683]             {
[16:14:01.683]                 {
[16:14:01.683]                   {
[16:14:01.683]                     {
[16:14:01.683]                       base::local({
[16:14:01.683]                         has_future <- base::requireNamespace("future", 
[16:14:01.683]                           quietly = TRUE)
[16:14:01.683]                         if (has_future) {
[16:14:01.683]                           ns <- base::getNamespace("future")
[16:14:01.683]                           version <- ns[[".package"]][["version"]]
[16:14:01.683]                           if (is.null(version)) 
[16:14:01.683]                             version <- utils::packageVersion("future")
[16:14:01.683]                         }
[16:14:01.683]                         else {
[16:14:01.683]                           version <- NULL
[16:14:01.683]                         }
[16:14:01.683]                         if (!has_future || version < "1.8.0") {
[16:14:01.683]                           info <- base::c(r_version = base::gsub("R version ", 
[16:14:01.683]                             "", base::R.version$version.string), 
[16:14:01.683]                             platform = base::sprintf("%s (%s-bit)", 
[16:14:01.683]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:14:01.683]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:14:01.683]                               "release", "version")], collapse = " "), 
[16:14:01.683]                             hostname = base::Sys.info()[["nodename"]])
[16:14:01.683]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:14:01.683]                             info)
[16:14:01.683]                           info <- base::paste(info, collapse = "; ")
[16:14:01.683]                           if (!has_future) {
[16:14:01.683]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:14:01.683]                               info)
[16:14:01.683]                           }
[16:14:01.683]                           else {
[16:14:01.683]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:14:01.683]                               info, version)
[16:14:01.683]                           }
[16:14:01.683]                           base::stop(msg)
[16:14:01.683]                         }
[16:14:01.683]                       })
[16:14:01.683]                     }
[16:14:01.683]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:14:01.683]                     base::options(mc.cores = 1L)
[16:14:01.683]                   }
[16:14:01.683]                   options(future.plan = NULL)
[16:14:01.683]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.683]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:14:01.683]                 }
[16:14:01.683]                 ...future.workdir <- getwd()
[16:14:01.683]             }
[16:14:01.683]             ...future.oldOptions <- base::as.list(base::.Options)
[16:14:01.683]             ...future.oldEnvVars <- base::Sys.getenv()
[16:14:01.683]         }
[16:14:01.683]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:14:01.683]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:14:01.683]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:14:01.683]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:14:01.683]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:14:01.683]             future.stdout.windows.reencode = NULL, width = 80L)
[16:14:01.683]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:14:01.683]             base::names(...future.oldOptions))
[16:14:01.683]     }
[16:14:01.683]     if (FALSE) {
[16:14:01.683]     }
[16:14:01.683]     else {
[16:14:01.683]         if (TRUE) {
[16:14:01.683]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:14:01.683]                 open = "w")
[16:14:01.683]         }
[16:14:01.683]         else {
[16:14:01.683]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:14:01.683]                 windows = "NUL", "/dev/null"), open = "w")
[16:14:01.683]         }
[16:14:01.683]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:14:01.683]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:14:01.683]             base::sink(type = "output", split = FALSE)
[16:14:01.683]             base::close(...future.stdout)
[16:14:01.683]         }, add = TRUE)
[16:14:01.683]     }
[16:14:01.683]     ...future.frame <- base::sys.nframe()
[16:14:01.683]     ...future.conditions <- base::list()
[16:14:01.683]     ...future.rng <- base::globalenv()$.Random.seed
[16:14:01.683]     if (FALSE) {
[16:14:01.683]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:14:01.683]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:14:01.683]     }
[16:14:01.683]     ...future.result <- base::tryCatch({
[16:14:01.683]         base::withCallingHandlers({
[16:14:01.683]             ...future.value <- base::withVisible(base::local({
[16:14:01.683]                 ...future.makeSendCondition <- local({
[16:14:01.683]                   sendCondition <- NULL
[16:14:01.683]                   function(frame = 1L) {
[16:14:01.683]                     if (is.function(sendCondition)) 
[16:14:01.683]                       return(sendCondition)
[16:14:01.683]                     ns <- getNamespace("parallel")
[16:14:01.683]                     if (exists("sendData", mode = "function", 
[16:14:01.683]                       envir = ns)) {
[16:14:01.683]                       parallel_sendData <- get("sendData", mode = "function", 
[16:14:01.683]                         envir = ns)
[16:14:01.683]                       envir <- sys.frame(frame)
[16:14:01.683]                       master <- NULL
[16:14:01.683]                       while (!identical(envir, .GlobalEnv) && 
[16:14:01.683]                         !identical(envir, emptyenv())) {
[16:14:01.683]                         if (exists("master", mode = "list", envir = envir, 
[16:14:01.683]                           inherits = FALSE)) {
[16:14:01.683]                           master <- get("master", mode = "list", 
[16:14:01.683]                             envir = envir, inherits = FALSE)
[16:14:01.683]                           if (inherits(master, c("SOCKnode", 
[16:14:01.683]                             "SOCK0node"))) {
[16:14:01.683]                             sendCondition <<- function(cond) {
[16:14:01.683]                               data <- list(type = "VALUE", value = cond, 
[16:14:01.683]                                 success = TRUE)
[16:14:01.683]                               parallel_sendData(master, data)
[16:14:01.683]                             }
[16:14:01.683]                             return(sendCondition)
[16:14:01.683]                           }
[16:14:01.683]                         }
[16:14:01.683]                         frame <- frame + 1L
[16:14:01.683]                         envir <- sys.frame(frame)
[16:14:01.683]                       }
[16:14:01.683]                     }
[16:14:01.683]                     sendCondition <<- function(cond) NULL
[16:14:01.683]                   }
[16:14:01.683]                 })
[16:14:01.683]                 withCallingHandlers({
[16:14:01.683]                   {
[16:14:01.683]                     3
[16:14:01.683]                   }
[16:14:01.683]                 }, immediateCondition = function(cond) {
[16:14:01.683]                   sendCondition <- ...future.makeSendCondition()
[16:14:01.683]                   sendCondition(cond)
[16:14:01.683]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.683]                   {
[16:14:01.683]                     inherits <- base::inherits
[16:14:01.683]                     invokeRestart <- base::invokeRestart
[16:14:01.683]                     is.null <- base::is.null
[16:14:01.683]                     muffled <- FALSE
[16:14:01.683]                     if (inherits(cond, "message")) {
[16:14:01.683]                       muffled <- grepl(pattern, "muffleMessage")
[16:14:01.683]                       if (muffled) 
[16:14:01.683]                         invokeRestart("muffleMessage")
[16:14:01.683]                     }
[16:14:01.683]                     else if (inherits(cond, "warning")) {
[16:14:01.683]                       muffled <- grepl(pattern, "muffleWarning")
[16:14:01.683]                       if (muffled) 
[16:14:01.683]                         invokeRestart("muffleWarning")
[16:14:01.683]                     }
[16:14:01.683]                     else if (inherits(cond, "condition")) {
[16:14:01.683]                       if (!is.null(pattern)) {
[16:14:01.683]                         computeRestarts <- base::computeRestarts
[16:14:01.683]                         grepl <- base::grepl
[16:14:01.683]                         restarts <- computeRestarts(cond)
[16:14:01.683]                         for (restart in restarts) {
[16:14:01.683]                           name <- restart$name
[16:14:01.683]                           if (is.null(name)) 
[16:14:01.683]                             next
[16:14:01.683]                           if (!grepl(pattern, name)) 
[16:14:01.683]                             next
[16:14:01.683]                           invokeRestart(restart)
[16:14:01.683]                           muffled <- TRUE
[16:14:01.683]                           break
[16:14:01.683]                         }
[16:14:01.683]                       }
[16:14:01.683]                     }
[16:14:01.683]                     invisible(muffled)
[16:14:01.683]                   }
[16:14:01.683]                   muffleCondition(cond)
[16:14:01.683]                 })
[16:14:01.683]             }))
[16:14:01.683]             future::FutureResult(value = ...future.value$value, 
[16:14:01.683]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.683]                   ...future.rng), globalenv = if (FALSE) 
[16:14:01.683]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:14:01.683]                     ...future.globalenv.names))
[16:14:01.683]                 else NULL, started = ...future.startTime, version = "1.8")
[16:14:01.683]         }, condition = base::local({
[16:14:01.683]             c <- base::c
[16:14:01.683]             inherits <- base::inherits
[16:14:01.683]             invokeRestart <- base::invokeRestart
[16:14:01.683]             length <- base::length
[16:14:01.683]             list <- base::list
[16:14:01.683]             seq.int <- base::seq.int
[16:14:01.683]             signalCondition <- base::signalCondition
[16:14:01.683]             sys.calls <- base::sys.calls
[16:14:01.683]             `[[` <- base::`[[`
[16:14:01.683]             `+` <- base::`+`
[16:14:01.683]             `<<-` <- base::`<<-`
[16:14:01.683]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:14:01.683]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:14:01.683]                   3L)]
[16:14:01.683]             }
[16:14:01.683]             function(cond) {
[16:14:01.683]                 is_error <- inherits(cond, "error")
[16:14:01.683]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:14:01.683]                   NULL)
[16:14:01.683]                 if (is_error) {
[16:14:01.683]                   sessionInformation <- function() {
[16:14:01.683]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:14:01.683]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:14:01.683]                       search = base::search(), system = base::Sys.info())
[16:14:01.683]                   }
[16:14:01.683]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.683]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:14:01.683]                     cond$call), session = sessionInformation(), 
[16:14:01.683]                     timestamp = base::Sys.time(), signaled = 0L)
[16:14:01.683]                   signalCondition(cond)
[16:14:01.683]                 }
[16:14:01.683]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:14:01.683]                 "immediateCondition"))) {
[16:14:01.683]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:14:01.683]                   ...future.conditions[[length(...future.conditions) + 
[16:14:01.683]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:14:01.683]                   if (TRUE && !signal) {
[16:14:01.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.683]                     {
[16:14:01.683]                       inherits <- base::inherits
[16:14:01.683]                       invokeRestart <- base::invokeRestart
[16:14:01.683]                       is.null <- base::is.null
[16:14:01.683]                       muffled <- FALSE
[16:14:01.683]                       if (inherits(cond, "message")) {
[16:14:01.683]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.683]                         if (muffled) 
[16:14:01.683]                           invokeRestart("muffleMessage")
[16:14:01.683]                       }
[16:14:01.683]                       else if (inherits(cond, "warning")) {
[16:14:01.683]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.683]                         if (muffled) 
[16:14:01.683]                           invokeRestart("muffleWarning")
[16:14:01.683]                       }
[16:14:01.683]                       else if (inherits(cond, "condition")) {
[16:14:01.683]                         if (!is.null(pattern)) {
[16:14:01.683]                           computeRestarts <- base::computeRestarts
[16:14:01.683]                           grepl <- base::grepl
[16:14:01.683]                           restarts <- computeRestarts(cond)
[16:14:01.683]                           for (restart in restarts) {
[16:14:01.683]                             name <- restart$name
[16:14:01.683]                             if (is.null(name)) 
[16:14:01.683]                               next
[16:14:01.683]                             if (!grepl(pattern, name)) 
[16:14:01.683]                               next
[16:14:01.683]                             invokeRestart(restart)
[16:14:01.683]                             muffled <- TRUE
[16:14:01.683]                             break
[16:14:01.683]                           }
[16:14:01.683]                         }
[16:14:01.683]                       }
[16:14:01.683]                       invisible(muffled)
[16:14:01.683]                     }
[16:14:01.683]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.683]                   }
[16:14:01.683]                 }
[16:14:01.683]                 else {
[16:14:01.683]                   if (TRUE) {
[16:14:01.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:14:01.683]                     {
[16:14:01.683]                       inherits <- base::inherits
[16:14:01.683]                       invokeRestart <- base::invokeRestart
[16:14:01.683]                       is.null <- base::is.null
[16:14:01.683]                       muffled <- FALSE
[16:14:01.683]                       if (inherits(cond, "message")) {
[16:14:01.683]                         muffled <- grepl(pattern, "muffleMessage")
[16:14:01.683]                         if (muffled) 
[16:14:01.683]                           invokeRestart("muffleMessage")
[16:14:01.683]                       }
[16:14:01.683]                       else if (inherits(cond, "warning")) {
[16:14:01.683]                         muffled <- grepl(pattern, "muffleWarning")
[16:14:01.683]                         if (muffled) 
[16:14:01.683]                           invokeRestart("muffleWarning")
[16:14:01.683]                       }
[16:14:01.683]                       else if (inherits(cond, "condition")) {
[16:14:01.683]                         if (!is.null(pattern)) {
[16:14:01.683]                           computeRestarts <- base::computeRestarts
[16:14:01.683]                           grepl <- base::grepl
[16:14:01.683]                           restarts <- computeRestarts(cond)
[16:14:01.683]                           for (restart in restarts) {
[16:14:01.683]                             name <- restart$name
[16:14:01.683]                             if (is.null(name)) 
[16:14:01.683]                               next
[16:14:01.683]                             if (!grepl(pattern, name)) 
[16:14:01.683]                               next
[16:14:01.683]                             invokeRestart(restart)
[16:14:01.683]                             muffled <- TRUE
[16:14:01.683]                             break
[16:14:01.683]                           }
[16:14:01.683]                         }
[16:14:01.683]                       }
[16:14:01.683]                       invisible(muffled)
[16:14:01.683]                     }
[16:14:01.683]                     muffleCondition(cond, pattern = "^muffle")
[16:14:01.683]                   }
[16:14:01.683]                 }
[16:14:01.683]             }
[16:14:01.683]         }))
[16:14:01.683]     }, error = function(ex) {
[16:14:01.683]         base::structure(base::list(value = NULL, visible = NULL, 
[16:14:01.683]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:14:01.683]                 ...future.rng), started = ...future.startTime, 
[16:14:01.683]             finished = Sys.time(), session_uuid = NA_character_, 
[16:14:01.683]             version = "1.8"), class = "FutureResult")
[16:14:01.683]     }, finally = {
[16:14:01.683]         if (!identical(...future.workdir, getwd())) 
[16:14:01.683]             setwd(...future.workdir)
[16:14:01.683]         {
[16:14:01.683]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:14:01.683]                 ...future.oldOptions$nwarnings <- NULL
[16:14:01.683]             }
[16:14:01.683]             base::options(...future.oldOptions)
[16:14:01.683]             if (.Platform$OS.type == "windows") {
[16:14:01.683]                 old_names <- names(...future.oldEnvVars)
[16:14:01.683]                 envs <- base::Sys.getenv()
[16:14:01.683]                 names <- names(envs)
[16:14:01.683]                 common <- intersect(names, old_names)
[16:14:01.683]                 added <- setdiff(names, old_names)
[16:14:01.683]                 removed <- setdiff(old_names, names)
[16:14:01.683]                 changed <- common[...future.oldEnvVars[common] != 
[16:14:01.683]                   envs[common]]
[16:14:01.683]                 NAMES <- toupper(changed)
[16:14:01.683]                 args <- list()
[16:14:01.683]                 for (kk in seq_along(NAMES)) {
[16:14:01.683]                   name <- changed[[kk]]
[16:14:01.683]                   NAME <- NAMES[[kk]]
[16:14:01.683]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.683]                     next
[16:14:01.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.683]                 }
[16:14:01.683]                 NAMES <- toupper(added)
[16:14:01.683]                 for (kk in seq_along(NAMES)) {
[16:14:01.683]                   name <- added[[kk]]
[16:14:01.683]                   NAME <- NAMES[[kk]]
[16:14:01.683]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.683]                     next
[16:14:01.683]                   args[[name]] <- ""
[16:14:01.683]                 }
[16:14:01.683]                 NAMES <- toupper(removed)
[16:14:01.683]                 for (kk in seq_along(NAMES)) {
[16:14:01.683]                   name <- removed[[kk]]
[16:14:01.683]                   NAME <- NAMES[[kk]]
[16:14:01.683]                   if (name != NAME && is.element(NAME, old_names)) 
[16:14:01.683]                     next
[16:14:01.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:14:01.683]                 }
[16:14:01.683]                 if (length(args) > 0) 
[16:14:01.683]                   base::do.call(base::Sys.setenv, args = args)
[16:14:01.683]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:14:01.683]             }
[16:14:01.683]             else {
[16:14:01.683]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:14:01.683]             }
[16:14:01.683]             {
[16:14:01.683]                 if (base::length(...future.futureOptionsAdded) > 
[16:14:01.683]                   0L) {
[16:14:01.683]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:14:01.683]                   base::names(opts) <- ...future.futureOptionsAdded
[16:14:01.683]                   base::options(opts)
[16:14:01.683]                 }
[16:14:01.683]                 {
[16:14:01.683]                   {
[16:14:01.683]                     base::options(mc.cores = ...future.mc.cores.old)
[16:14:01.683]                     NULL
[16:14:01.683]                   }
[16:14:01.683]                   options(future.plan = NULL)
[16:14:01.683]                   if (is.na(NA_character_)) 
[16:14:01.683]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:14:01.683]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:14:01.683]                   future::plan(list(function (..., workers = availableCores(), 
[16:14:01.683]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:14:01.683]                     envir = parent.frame()) 
[16:14:01.683]                   {
[16:14:01.683]                     if (is.function(workers)) 
[16:14:01.683]                       workers <- workers()
[16:14:01.683]                     workers <- structure(as.integer(workers), 
[16:14:01.683]                       class = class(workers))
[16:14:01.683]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:14:01.683]                       workers >= 1)
[16:14:01.683]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:14:01.683]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:14:01.683]                     }
[16:14:01.683]                     future <- MultisessionFuture(..., workers = workers, 
[16:14:01.683]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:14:01.683]                       envir = envir)
[16:14:01.683]                     if (!future$lazy) 
[16:14:01.683]                       future <- run(future)
[16:14:01.683]                     invisible(future)
[16:14:01.683]                   }), .cleanup = FALSE, .init = FALSE)
[16:14:01.683]                 }
[16:14:01.683]             }
[16:14:01.683]         }
[16:14:01.683]     })
[16:14:01.683]     if (TRUE) {
[16:14:01.683]         base::sink(type = "output", split = FALSE)
[16:14:01.683]         if (TRUE) {
[16:14:01.683]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:14:01.683]         }
[16:14:01.683]         else {
[16:14:01.683]             ...future.result["stdout"] <- base::list(NULL)
[16:14:01.683]         }
[16:14:01.683]         base::close(...future.stdout)
[16:14:01.683]         ...future.stdout <- NULL
[16:14:01.683]     }
[16:14:01.683]     ...future.result$conditions <- ...future.conditions
[16:14:01.683]     ...future.result$finished <- base::Sys.time()
[16:14:01.683]     ...future.result
[16:14:01.683] }
[16:14:01.686] Poll #1 (0): usedNodes() = 2, workers = 2
[16:14:01.696] receiveMessageFromWorker() for ClusterFuture ...
[16:14:01.697] - Validating connection of MultisessionFuture
[16:14:01.697] - received message: FutureResult
[16:14:01.697] - Received FutureResult
[16:14:01.697] - Erased future from FutureRegistry
[16:14:01.697] result() for ClusterFuture ...
[16:14:01.697] - result already collected: FutureResult
[16:14:01.697] result() for ClusterFuture ... done
[16:14:01.697] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:01.697] result() for ClusterFuture ...
[16:14:01.698] - result already collected: FutureResult
[16:14:01.698] result() for ClusterFuture ... done
[16:14:01.698] result() for ClusterFuture ...
[16:14:01.698] - result already collected: FutureResult
[16:14:01.698] result() for ClusterFuture ... done
[16:14:01.699] MultisessionFuture started
[16:14:01.699] - Launch lazy future ... done
[16:14:01.699] run() for ‘MultisessionFuture’ ... done
[16:14:01.700] resolve() on list environment ...
[16:14:01.700]  recursive: 0
[16:14:01.701]  length: 4
[16:14:01.701]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:14:01.701] Future #1
[16:14:01.701]  length: 3 (resolved future 1)
[16:14:01.722]  length: 2 (resolved future 4)
[16:14:01.745] receiveMessageFromWorker() for ClusterFuture ...
[16:14:01.745] - Validating connection of MultisessionFuture
[16:14:01.745] - received message: FutureResult
[16:14:01.745] - Received FutureResult
[16:14:01.745] - Erased future from FutureRegistry
[16:14:01.745] result() for ClusterFuture ...
[16:14:01.745] - result already collected: FutureResult
[16:14:01.745] result() for ClusterFuture ... done
[16:14:01.746] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:01.746] Future #3
[16:14:01.746]  length: 1 (resolved future 3)
[16:14:02.214] receiveMessageFromWorker() for ClusterFuture ...
[16:14:02.214] - Validating connection of MultisessionFuture
[16:14:02.214] - received message: FutureResult
[16:14:02.214] - Received FutureResult
[16:14:02.214] - Erased future from FutureRegistry
[16:14:02.215] result() for ClusterFuture ...
[16:14:02.215] - result already collected: FutureResult
[16:14:02.215] result() for ClusterFuture ... done
[16:14:02.215] receiveMessageFromWorker() for ClusterFuture ... done
[16:14:02.215] Future #2
[16:14:02.215]  length: 0 (resolved future 2)
[16:14:02.215] resolve() on list environment ... DONE
[16:14:02.216] resolve() on list environment ...
[16:14:02.216]  recursive: 0
[16:14:02.216]  length: 4
[16:14:02.217]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:14:02.217] Future #1
[16:14:02.217]  length: 3 (resolved future 1)
[16:14:02.217] Future #2
[16:14:02.217]  length: 2 (resolved future 2)
[16:14:02.217] Future #3
[16:14:02.217]  length: 1 (resolved future 3)
[16:14:02.217]  length: 0 (resolved future 4)
[16:14:02.217] resolve() on list environment ... DONE
[16:14:02.218] resolve() on list environment ...
[16:14:02.218]  recursive: 0
[16:14:02.219]  length: 4
[16:14:02.219]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:14:02.219] Future #1
[16:14:02.219]  length: 3 (resolved future 1)
[16:14:02.219] Future #2
[16:14:02.219]  length: 2 (resolved future 2)
[16:14:02.219] Future #3
[16:14:02.220]  length: 1 (resolved future 3)
[16:14:02.220]  length: 0 (resolved future 4)
[16:14:02.220] resolve() on list environment ... DONE
[16:14:02.220] resolve() on list environment ...
[16:14:02.220]  recursive: 0
[16:14:02.221]  length: 4
[16:14:02.221]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:14:02.221] Future #1
[16:14:02.221]  length: 3 (resolved future 1)
[16:14:02.221] Future #2
[16:14:02.221]  length: 2 (resolved future 2)
[16:14:02.222] Future #3
[16:14:02.222]  length: 1 (resolved future 3)
[16:14:02.222]  length: 0 (resolved future 4)
[16:14:02.222] resolve() on list environment ... DONE
[16:14:02.222] resolve() on list environment ...
[16:14:02.222]  recursive: 0
[16:14:02.223]  length: 4
[16:14:02.223]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:14:02.223] Future #1
[16:14:02.223] result() for ClusterFuture ...
[16:14:02.223] - result already collected: FutureResult
[16:14:02.223] result() for ClusterFuture ... done
[16:14:02.224] result() for ClusterFuture ...
[16:14:02.224] - result already collected: FutureResult
[16:14:02.224] result() for ClusterFuture ... done
[16:14:02.224]  length: 3 (resolved future 1)
[16:14:02.224] Future #2
[16:14:02.224] result() for ClusterFuture ...
[16:14:02.224] - result already collected: FutureResult
[16:14:02.224] result() for ClusterFuture ... done
[16:14:02.224] result() for ClusterFuture ...
[16:14:02.225] - result already collected: FutureResult
[16:14:02.225] result() for ClusterFuture ... done
[16:14:02.225]  length: 2 (resolved future 2)
[16:14:02.225] Future #3
[16:14:02.225] result() for ClusterFuture ...
[16:14:02.225] - result already collected: FutureResult
[16:14:02.225] result() for ClusterFuture ... done
[16:14:02.225] result() for ClusterFuture ...
[16:14:02.225] - result already collected: FutureResult
[16:14:02.225] result() for ClusterFuture ... done
[16:14:02.226]  length: 1 (resolved future 3)
[16:14:02.226]  length: 0 (resolved future 4)
[16:14:02.226] resolve() on list environment ... DONE
[16:14:02.226] resolve() on list environment ...
[16:14:02.226]  recursive: 99
[16:14:02.227]  length: 4
[16:14:02.227]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:14:02.227] Future #1
[16:14:02.227] result() for ClusterFuture ...
[16:14:02.228] - result already collected: FutureResult
[16:14:02.228] result() for ClusterFuture ... done
[16:14:02.228] result() for ClusterFuture ...
[16:14:02.228] - result already collected: FutureResult
[16:14:02.228] result() for ClusterFuture ... done
[16:14:02.228] A MultisessionFuture was resolved
[16:14:02.228]  length: 3 (resolved future 1)
[16:14:02.229] Future #2
[16:14:02.229] result() for ClusterFuture ...
[16:14:02.229] - result already collected: FutureResult
[16:14:02.229] result() for ClusterFuture ... done
[16:14:02.229] result() for ClusterFuture ...
[16:14:02.229] - result already collected: FutureResult
[16:14:02.229] result() for ClusterFuture ... done
[16:14:02.229] A MultisessionFuture was resolved
[16:14:02.229]  length: 2 (resolved future 2)
[16:14:02.229] Future #3
[16:14:02.230] result() for ClusterFuture ...
[16:14:02.230] - result already collected: FutureResult
[16:14:02.230] result() for ClusterFuture ... done
[16:14:02.230] result() for ClusterFuture ...
[16:14:02.230] - result already collected: FutureResult
[16:14:02.230] result() for ClusterFuture ... done
[16:14:02.230] A MultisessionFuture was resolved
[16:14:02.230]  length: 1 (resolved future 3)
[16:14:02.230]  length: 0 (resolved future 4)
[16:14:02.230] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multisession') ...
> 
> 
> message("*** resolve() - globals with non-trustful length() ...")
*** resolve() - globals with non-trustful length() ...
> 
> length.CantTrustLength <- function(x) length(unclass(x)) + 1L
> 
> .length <- future:::.length
> 
> x <- structure(as.list(1:3), class = c("CantTrustLength", "list"))
> str(list(n = length(x), n_true = .length(x)))
List of 2
 $ n     : int 4
 $ n_true: int 3
> stopifnot(length(x) > .length(x))
> x <- resolve(x)
[16:14:02.234] resolve() on list ...
[16:14:02.234]  recursive: 0
[16:14:02.234]  length: 3
[16:14:02.234] 
[16:14:02.234]  length: 2 (resolved future 1)
[16:14:02.234]  length: 1 (resolved future 2)
[16:14:02.234]  length: 0 (resolved future 3)
[16:14:02.234] resolve() on list ... DONE
> 
> message("*** resolve() - globals with non-trustful length() ... DONE")
*** resolve() - globals with non-trustful length() ... DONE
> 
> 
> message("*** resolved() - default ...")
*** resolved() - default ...
> 
> res <- resolved(42L)
> stopifnot(isTRUE(res))
> 
> message("*** resolved() - default ... DONE")
*** resolved() - default ... DONE
> 
> 
> message("*** resolve() ... DONE")
*** resolve() ... DONE
> 
> source("incl/end.R")
[16:14:02.235] plan(): Setting new future strategy stack:
[16:14:02.235] List of future strategies:
[16:14:02.235] 1. FutureStrategy:
[16:14:02.235]    - args: function (..., envir = parent.frame())
[16:14:02.235]    - tweaked: FALSE
[16:14:02.235]    - call: future::plan(oplan)
[16:14:02.236] plan(): nbrOfWorkers() = 1
> 
