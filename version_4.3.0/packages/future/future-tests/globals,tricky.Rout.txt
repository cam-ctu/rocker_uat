
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:12:50.719] plan(): Setting new future strategy stack:
[16:12:50.720] List of future strategies:
[16:12:50.720] 1. sequential:
[16:12:50.720]    - args: function (..., envir = parent.frame())
[16:12:50.720]    - tweaked: FALSE
[16:12:50.720]    - call: future::plan("sequential")
[16:12:50.733] plan(): nbrOfWorkers() = 1
> library("listenv")
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Tricky use cases related to globals ...")
*** Tricky use cases related to globals ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   message("- Local variables with the same name as globals ...")
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     methods <- c("conservative", "ordered")
+     for (method in methods) {
+       options(future.globals.method = method)
+       message(sprintf("Method for identifying globals: '%s' ...", method))
+ 
+       a <- 3
+ 
+       yTruth <- local({
+         b <- a
+         a <- 2
+         a * b
+       })
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       }
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       a <- 3
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       } %lazy% TRUE
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         }
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         } %lazy% TRUE
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Assert that `a` is resolved and turned into a constant future
+       ## at the moment when future `b` is created.
+       ## Requires options(future.globals.resolve = TRUE).
+       a <- future(1)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+ 
+       ## BUG FIX: In future (<= 1.0.0) a global 'pkg' would be
+       ## overwritten by the name of the last package attached
+       ## by the future.
+       pkg <- "foo"
+       f <- sequential({ pkg })
+       v <- value(f)
+       message(sprintf("value(f) = %s", sQuote(v)))
+       stopifnot(pkg == "foo", v == "foo")
+       
+       message(sprintf("Method for identifying globals: '%s' ... DONE", method))
+     }
+ 
+     ## BUG FIX: In globals (<= 0.10.3) a global 'x' in LHS of an assignment
+     ## would be missed.
+     options(future.globals.method = "ordered")
+ 
+     ## A local
+     x <- 1
+     f <- future({ x <- 0; x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 1)
+     
+     ## A global
+     x <- 1
+     f <- future({ x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 2)
+ 
+     ## A global
+     x <- function() TRUE
+     f <- future({ x <- x(); x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == TRUE)
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- Local variables with the same name as globals ...
- plan('sequential') ...
[16:12:50.827] plan(): Setting new future strategy stack:
[16:12:50.827] List of future strategies:
[16:12:50.827] 1. sequential:
[16:12:50.827]    - args: function (..., envir = parent.frame())
[16:12:50.827]    - tweaked: FALSE
[16:12:50.827]    - call: plan(strategy)
[16:12:50.838] plan(): nbrOfWorkers() = 1
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:50.841] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:50.841] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:50.848] - globals found: [3] ‘{’, ‘<-’, ‘*’
[16:12:50.848] Searching for globals ... DONE
[16:12:50.848] Resolving globals: TRUE
[16:12:50.848] Resolving any globals that are futures ...
[16:12:50.848] - globals: [3] ‘{’, ‘<-’, ‘*’
[16:12:50.848] Resolving any globals that are futures ... DONE
[16:12:50.849] 
[16:12:50.849] 
[16:12:50.849] getGlobalsAndPackages() ... DONE
[16:12:50.850] run() for ‘Future’ ...
[16:12:50.850] - state: ‘created’
[16:12:50.850] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:50.851] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:50.851] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:50.851]   - Field: ‘label’
[16:12:50.851]   - Field: ‘local’
[16:12:50.851]   - Field: ‘owner’
[16:12:50.851]   - Field: ‘envir’
[16:12:50.851]   - Field: ‘packages’
[16:12:50.851]   - Field: ‘gc’
[16:12:50.851]   - Field: ‘conditions’
[16:12:50.852]   - Field: ‘expr’
[16:12:50.852]   - Field: ‘uuid’
[16:12:50.852]   - Field: ‘seed’
[16:12:50.854]   - Field: ‘version’
[16:12:50.854]   - Field: ‘result’
[16:12:50.854]   - Field: ‘asynchronous’
[16:12:50.854]   - Field: ‘calls’
[16:12:50.854]   - Field: ‘globals’
[16:12:50.854]   - Field: ‘stdout’
[16:12:50.855]   - Field: ‘earlySignal’
[16:12:50.855]   - Field: ‘lazy’
[16:12:50.855]   - Field: ‘state’
[16:12:50.855] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:50.855] - Launch lazy future ...
[16:12:50.856] Packages needed by the future expression (n = 0): <none>
[16:12:50.856] Packages needed by future strategies (n = 0): <none>
[16:12:50.857] {
[16:12:50.857]     {
[16:12:50.857]         {
[16:12:50.857]             ...future.startTime <- base::Sys.time()
[16:12:50.857]             {
[16:12:50.857]                 {
[16:12:50.857]                   {
[16:12:50.857]                     base::local({
[16:12:50.857]                       has_future <- base::requireNamespace("future", 
[16:12:50.857]                         quietly = TRUE)
[16:12:50.857]                       if (has_future) {
[16:12:50.857]                         ns <- base::getNamespace("future")
[16:12:50.857]                         version <- ns[[".package"]][["version"]]
[16:12:50.857]                         if (is.null(version)) 
[16:12:50.857]                           version <- utils::packageVersion("future")
[16:12:50.857]                       }
[16:12:50.857]                       else {
[16:12:50.857]                         version <- NULL
[16:12:50.857]                       }
[16:12:50.857]                       if (!has_future || version < "1.8.0") {
[16:12:50.857]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:50.857]                           "", base::R.version$version.string), 
[16:12:50.857]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:50.857]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:50.857]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:50.857]                             "release", "version")], collapse = " "), 
[16:12:50.857]                           hostname = base::Sys.info()[["nodename"]])
[16:12:50.857]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:50.857]                           info)
[16:12:50.857]                         info <- base::paste(info, collapse = "; ")
[16:12:50.857]                         if (!has_future) {
[16:12:50.857]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:50.857]                             info)
[16:12:50.857]                         }
[16:12:50.857]                         else {
[16:12:50.857]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:50.857]                             info, version)
[16:12:50.857]                         }
[16:12:50.857]                         base::stop(msg)
[16:12:50.857]                       }
[16:12:50.857]                     })
[16:12:50.857]                   }
[16:12:50.857]                   options(future.plan = NULL)
[16:12:50.857]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:50.857]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:50.857]                 }
[16:12:50.857]                 ...future.workdir <- getwd()
[16:12:50.857]             }
[16:12:50.857]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:50.857]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:50.857]         }
[16:12:50.857]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:50.857]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:50.857]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:50.857]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:50.857]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:50.857]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:50.857]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:50.857]             base::names(...future.oldOptions))
[16:12:50.857]     }
[16:12:50.857]     if (FALSE) {
[16:12:50.857]     }
[16:12:50.857]     else {
[16:12:50.857]         if (TRUE) {
[16:12:50.857]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:50.857]                 open = "w")
[16:12:50.857]         }
[16:12:50.857]         else {
[16:12:50.857]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:50.857]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:50.857]         }
[16:12:50.857]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:50.857]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:50.857]             base::sink(type = "output", split = FALSE)
[16:12:50.857]             base::close(...future.stdout)
[16:12:50.857]         }, add = TRUE)
[16:12:50.857]     }
[16:12:50.857]     ...future.frame <- base::sys.nframe()
[16:12:50.857]     ...future.conditions <- base::list()
[16:12:50.857]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:50.857]     if (FALSE) {
[16:12:50.857]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:50.857]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:50.857]     }
[16:12:50.857]     ...future.result <- base::tryCatch({
[16:12:50.857]         base::withCallingHandlers({
[16:12:50.857]             ...future.value <- base::withVisible(base::local({
[16:12:50.857]                 b <- a
[16:12:50.857]                 a <- 2
[16:12:50.857]                 a * b
[16:12:50.857]             }))
[16:12:50.857]             future::FutureResult(value = ...future.value$value, 
[16:12:50.857]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:50.857]                   ...future.rng), globalenv = if (FALSE) 
[16:12:50.857]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:50.857]                     ...future.globalenv.names))
[16:12:50.857]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:50.857]         }, condition = base::local({
[16:12:50.857]             c <- base::c
[16:12:50.857]             inherits <- base::inherits
[16:12:50.857]             invokeRestart <- base::invokeRestart
[16:12:50.857]             length <- base::length
[16:12:50.857]             list <- base::list
[16:12:50.857]             seq.int <- base::seq.int
[16:12:50.857]             signalCondition <- base::signalCondition
[16:12:50.857]             sys.calls <- base::sys.calls
[16:12:50.857]             `[[` <- base::`[[`
[16:12:50.857]             `+` <- base::`+`
[16:12:50.857]             `<<-` <- base::`<<-`
[16:12:50.857]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:50.857]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:50.857]                   3L)]
[16:12:50.857]             }
[16:12:50.857]             function(cond) {
[16:12:50.857]                 is_error <- inherits(cond, "error")
[16:12:50.857]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:50.857]                   NULL)
[16:12:50.857]                 if (is_error) {
[16:12:50.857]                   sessionInformation <- function() {
[16:12:50.857]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:50.857]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:50.857]                       search = base::search(), system = base::Sys.info())
[16:12:50.857]                   }
[16:12:50.857]                   ...future.conditions[[length(...future.conditions) + 
[16:12:50.857]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:50.857]                     cond$call), session = sessionInformation(), 
[16:12:50.857]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:50.857]                   signalCondition(cond)
[16:12:50.857]                 }
[16:12:50.857]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:50.857]                 "immediateCondition"))) {
[16:12:50.857]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:50.857]                   ...future.conditions[[length(...future.conditions) + 
[16:12:50.857]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:50.857]                   if (TRUE && !signal) {
[16:12:50.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:50.857]                     {
[16:12:50.857]                       inherits <- base::inherits
[16:12:50.857]                       invokeRestart <- base::invokeRestart
[16:12:50.857]                       is.null <- base::is.null
[16:12:50.857]                       muffled <- FALSE
[16:12:50.857]                       if (inherits(cond, "message")) {
[16:12:50.857]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:50.857]                         if (muffled) 
[16:12:50.857]                           invokeRestart("muffleMessage")
[16:12:50.857]                       }
[16:12:50.857]                       else if (inherits(cond, "warning")) {
[16:12:50.857]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:50.857]                         if (muffled) 
[16:12:50.857]                           invokeRestart("muffleWarning")
[16:12:50.857]                       }
[16:12:50.857]                       else if (inherits(cond, "condition")) {
[16:12:50.857]                         if (!is.null(pattern)) {
[16:12:50.857]                           computeRestarts <- base::computeRestarts
[16:12:50.857]                           grepl <- base::grepl
[16:12:50.857]                           restarts <- computeRestarts(cond)
[16:12:50.857]                           for (restart in restarts) {
[16:12:50.857]                             name <- restart$name
[16:12:50.857]                             if (is.null(name)) 
[16:12:50.857]                               next
[16:12:50.857]                             if (!grepl(pattern, name)) 
[16:12:50.857]                               next
[16:12:50.857]                             invokeRestart(restart)
[16:12:50.857]                             muffled <- TRUE
[16:12:50.857]                             break
[16:12:50.857]                           }
[16:12:50.857]                         }
[16:12:50.857]                       }
[16:12:50.857]                       invisible(muffled)
[16:12:50.857]                     }
[16:12:50.857]                     muffleCondition(cond, pattern = "^muffle")
[16:12:50.857]                   }
[16:12:50.857]                 }
[16:12:50.857]                 else {
[16:12:50.857]                   if (TRUE) {
[16:12:50.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:50.857]                     {
[16:12:50.857]                       inherits <- base::inherits
[16:12:50.857]                       invokeRestart <- base::invokeRestart
[16:12:50.857]                       is.null <- base::is.null
[16:12:50.857]                       muffled <- FALSE
[16:12:50.857]                       if (inherits(cond, "message")) {
[16:12:50.857]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:50.857]                         if (muffled) 
[16:12:50.857]                           invokeRestart("muffleMessage")
[16:12:50.857]                       }
[16:12:50.857]                       else if (inherits(cond, "warning")) {
[16:12:50.857]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:50.857]                         if (muffled) 
[16:12:50.857]                           invokeRestart("muffleWarning")
[16:12:50.857]                       }
[16:12:50.857]                       else if (inherits(cond, "condition")) {
[16:12:50.857]                         if (!is.null(pattern)) {
[16:12:50.857]                           computeRestarts <- base::computeRestarts
[16:12:50.857]                           grepl <- base::grepl
[16:12:50.857]                           restarts <- computeRestarts(cond)
[16:12:50.857]                           for (restart in restarts) {
[16:12:50.857]                             name <- restart$name
[16:12:50.857]                             if (is.null(name)) 
[16:12:50.857]                               next
[16:12:50.857]                             if (!grepl(pattern, name)) 
[16:12:50.857]                               next
[16:12:50.857]                             invokeRestart(restart)
[16:12:50.857]                             muffled <- TRUE
[16:12:50.857]                             break
[16:12:50.857]                           }
[16:12:50.857]                         }
[16:12:50.857]                       }
[16:12:50.857]                       invisible(muffled)
[16:12:50.857]                     }
[16:12:50.857]                     muffleCondition(cond, pattern = "^muffle")
[16:12:50.857]                   }
[16:12:50.857]                 }
[16:12:50.857]             }
[16:12:50.857]         }))
[16:12:50.857]     }, error = function(ex) {
[16:12:50.857]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:50.857]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:50.857]                 ...future.rng), started = ...future.startTime, 
[16:12:50.857]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:50.857]             version = "1.8"), class = "FutureResult")
[16:12:50.857]     }, finally = {
[16:12:50.857]         if (!identical(...future.workdir, getwd())) 
[16:12:50.857]             setwd(...future.workdir)
[16:12:50.857]         {
[16:12:50.857]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:50.857]                 ...future.oldOptions$nwarnings <- NULL
[16:12:50.857]             }
[16:12:50.857]             base::options(...future.oldOptions)
[16:12:50.857]             if (.Platform$OS.type == "windows") {
[16:12:50.857]                 old_names <- names(...future.oldEnvVars)
[16:12:50.857]                 envs <- base::Sys.getenv()
[16:12:50.857]                 names <- names(envs)
[16:12:50.857]                 common <- intersect(names, old_names)
[16:12:50.857]                 added <- setdiff(names, old_names)
[16:12:50.857]                 removed <- setdiff(old_names, names)
[16:12:50.857]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:50.857]                   envs[common]]
[16:12:50.857]                 NAMES <- toupper(changed)
[16:12:50.857]                 args <- list()
[16:12:50.857]                 for (kk in seq_along(NAMES)) {
[16:12:50.857]                   name <- changed[[kk]]
[16:12:50.857]                   NAME <- NAMES[[kk]]
[16:12:50.857]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:50.857]                     next
[16:12:50.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:50.857]                 }
[16:12:50.857]                 NAMES <- toupper(added)
[16:12:50.857]                 for (kk in seq_along(NAMES)) {
[16:12:50.857]                   name <- added[[kk]]
[16:12:50.857]                   NAME <- NAMES[[kk]]
[16:12:50.857]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:50.857]                     next
[16:12:50.857]                   args[[name]] <- ""
[16:12:50.857]                 }
[16:12:50.857]                 NAMES <- toupper(removed)
[16:12:50.857]                 for (kk in seq_along(NAMES)) {
[16:12:50.857]                   name <- removed[[kk]]
[16:12:50.857]                   NAME <- NAMES[[kk]]
[16:12:50.857]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:50.857]                     next
[16:12:50.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:50.857]                 }
[16:12:50.857]                 if (length(args) > 0) 
[16:12:50.857]                   base::do.call(base::Sys.setenv, args = args)
[16:12:50.857]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:50.857]             }
[16:12:50.857]             else {
[16:12:50.857]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:50.857]             }
[16:12:50.857]             {
[16:12:50.857]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:50.857]                   0L) {
[16:12:50.857]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:50.857]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:50.857]                   base::options(opts)
[16:12:50.857]                 }
[16:12:50.857]                 {
[16:12:50.857]                   {
[16:12:50.857]                     NULL
[16:12:50.857]                     RNGkind("Mersenne-Twister")
[16:12:50.857]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:50.857]                       inherits = FALSE)
[16:12:50.857]                   }
[16:12:50.857]                   options(future.plan = NULL)
[16:12:50.857]                   if (is.na(NA_character_)) 
[16:12:50.857]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:50.857]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:50.857]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:50.857]                   {
[16:12:50.857]                     future <- SequentialFuture(..., envir = envir)
[16:12:50.857]                     if (!future$lazy) 
[16:12:50.857]                       future <- run(future)
[16:12:50.857]                     invisible(future)
[16:12:50.857]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:50.857]                 }
[16:12:50.857]             }
[16:12:50.857]         }
[16:12:50.857]     })
[16:12:50.857]     if (TRUE) {
[16:12:50.857]         base::sink(type = "output", split = FALSE)
[16:12:50.857]         if (TRUE) {
[16:12:50.857]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:50.857]         }
[16:12:50.857]         else {
[16:12:50.857]             ...future.result["stdout"] <- base::list(NULL)
[16:12:50.857]         }
[16:12:50.857]         base::close(...future.stdout)
[16:12:50.857]         ...future.stdout <- NULL
[16:12:50.857]     }
[16:12:50.857]     ...future.result$conditions <- ...future.conditions
[16:12:50.857]     ...future.result$finished <- base::Sys.time()
[16:12:50.857]     ...future.result
[16:12:50.857] }
[16:12:50.859] plan(): Setting new future strategy stack:
[16:12:50.859] List of future strategies:
[16:12:50.859] 1. sequential:
[16:12:50.859]    - args: function (..., envir = parent.frame())
[16:12:50.859]    - tweaked: FALSE
[16:12:50.859]    - call: NULL
[16:12:50.859] plan(): nbrOfWorkers() = 1
[16:12:50.860] plan(): Setting new future strategy stack:
[16:12:50.860] List of future strategies:
[16:12:50.860] 1. sequential:
[16:12:50.860]    - args: function (..., envir = parent.frame())
[16:12:50.860]    - tweaked: FALSE
[16:12:50.860]    - call: plan(strategy)
[16:12:50.861] plan(): nbrOfWorkers() = 1
[16:12:50.861] SequentialFuture started (and completed)
[16:12:50.862] - Launch lazy future ... done
[16:12:50.862] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:50.862] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:50.863] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:50.864] - globals found: [3] ‘{’, ‘<-’, ‘*’
[16:12:50.864] Searching for globals ... DONE
[16:12:50.864] Resolving globals: TRUE
[16:12:50.864] Resolving any globals that are futures ...
[16:12:50.864] - globals: [3] ‘{’, ‘<-’, ‘*’
[16:12:50.864] Resolving any globals that are futures ... DONE
[16:12:50.865] 
[16:12:50.865] 
[16:12:50.865] getGlobalsAndPackages() ... DONE
[16:12:50.865] run() for ‘Future’ ...
[16:12:50.865] - state: ‘created’
[16:12:50.865] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:50.866] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:50.866] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:50.866]   - Field: ‘label’
[16:12:50.866]   - Field: ‘local’
[16:12:50.866]   - Field: ‘owner’
[16:12:50.866]   - Field: ‘envir’
[16:12:50.866]   - Field: ‘packages’
[16:12:50.866]   - Field: ‘gc’
[16:12:50.866]   - Field: ‘conditions’
[16:12:50.867]   - Field: ‘expr’
[16:12:50.867]   - Field: ‘uuid’
[16:12:50.867]   - Field: ‘seed’
[16:12:50.867]   - Field: ‘version’
[16:12:50.867]   - Field: ‘result’
[16:12:50.867]   - Field: ‘asynchronous’
[16:12:50.867]   - Field: ‘calls’
[16:12:50.867]   - Field: ‘globals’
[16:12:50.867]   - Field: ‘stdout’
[16:12:50.867]   - Field: ‘earlySignal’
[16:12:50.867]   - Field: ‘lazy’
[16:12:50.868]   - Field: ‘state’
[16:12:50.868] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:50.868] - Launch lazy future ...
[16:12:50.868] Packages needed by the future expression (n = 0): <none>
[16:12:50.868] Packages needed by future strategies (n = 0): <none>
[16:12:50.868] {
[16:12:50.868]     {
[16:12:50.868]         {
[16:12:50.868]             ...future.startTime <- base::Sys.time()
[16:12:50.868]             {
[16:12:50.868]                 {
[16:12:50.868]                   {
[16:12:50.868]                     base::local({
[16:12:50.868]                       has_future <- base::requireNamespace("future", 
[16:12:50.868]                         quietly = TRUE)
[16:12:50.868]                       if (has_future) {
[16:12:50.868]                         ns <- base::getNamespace("future")
[16:12:50.868]                         version <- ns[[".package"]][["version"]]
[16:12:50.868]                         if (is.null(version)) 
[16:12:50.868]                           version <- utils::packageVersion("future")
[16:12:50.868]                       }
[16:12:50.868]                       else {
[16:12:50.868]                         version <- NULL
[16:12:50.868]                       }
[16:12:50.868]                       if (!has_future || version < "1.8.0") {
[16:12:50.868]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:50.868]                           "", base::R.version$version.string), 
[16:12:50.868]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:50.868]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:50.868]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:50.868]                             "release", "version")], collapse = " "), 
[16:12:50.868]                           hostname = base::Sys.info()[["nodename"]])
[16:12:50.868]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:50.868]                           info)
[16:12:50.868]                         info <- base::paste(info, collapse = "; ")
[16:12:50.868]                         if (!has_future) {
[16:12:50.868]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:50.868]                             info)
[16:12:50.868]                         }
[16:12:50.868]                         else {
[16:12:50.868]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:50.868]                             info, version)
[16:12:50.868]                         }
[16:12:50.868]                         base::stop(msg)
[16:12:50.868]                       }
[16:12:50.868]                     })
[16:12:50.868]                   }
[16:12:50.868]                   options(future.plan = NULL)
[16:12:50.868]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:50.868]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:50.868]                 }
[16:12:50.868]                 ...future.workdir <- getwd()
[16:12:50.868]             }
[16:12:50.868]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:50.868]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:50.868]         }
[16:12:50.868]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:50.868]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:50.868]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:50.868]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:50.868]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:50.868]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:50.868]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:50.868]             base::names(...future.oldOptions))
[16:12:50.868]     }
[16:12:50.868]     if (FALSE) {
[16:12:50.868]     }
[16:12:50.868]     else {
[16:12:50.868]         if (TRUE) {
[16:12:50.868]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:50.868]                 open = "w")
[16:12:50.868]         }
[16:12:50.868]         else {
[16:12:50.868]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:50.868]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:50.868]         }
[16:12:50.868]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:50.868]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:50.868]             base::sink(type = "output", split = FALSE)
[16:12:50.868]             base::close(...future.stdout)
[16:12:50.868]         }, add = TRUE)
[16:12:50.868]     }
[16:12:50.868]     ...future.frame <- base::sys.nframe()
[16:12:50.868]     ...future.conditions <- base::list()
[16:12:50.868]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:50.868]     if (FALSE) {
[16:12:50.868]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:50.868]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:50.868]     }
[16:12:50.868]     ...future.result <- base::tryCatch({
[16:12:50.868]         base::withCallingHandlers({
[16:12:50.868]             ...future.value <- base::withVisible(base::local({
[16:12:50.868]                 b <- a
[16:12:50.868]                 a <- 2
[16:12:50.868]                 a * b
[16:12:50.868]             }))
[16:12:50.868]             future::FutureResult(value = ...future.value$value, 
[16:12:50.868]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:50.868]                   ...future.rng), globalenv = if (FALSE) 
[16:12:50.868]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:50.868]                     ...future.globalenv.names))
[16:12:50.868]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:50.868]         }, condition = base::local({
[16:12:50.868]             c <- base::c
[16:12:50.868]             inherits <- base::inherits
[16:12:50.868]             invokeRestart <- base::invokeRestart
[16:12:50.868]             length <- base::length
[16:12:50.868]             list <- base::list
[16:12:50.868]             seq.int <- base::seq.int
[16:12:50.868]             signalCondition <- base::signalCondition
[16:12:50.868]             sys.calls <- base::sys.calls
[16:12:50.868]             `[[` <- base::`[[`
[16:12:50.868]             `+` <- base::`+`
[16:12:50.868]             `<<-` <- base::`<<-`
[16:12:50.868]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:50.868]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:50.868]                   3L)]
[16:12:50.868]             }
[16:12:50.868]             function(cond) {
[16:12:50.868]                 is_error <- inherits(cond, "error")
[16:12:50.868]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:50.868]                   NULL)
[16:12:50.868]                 if (is_error) {
[16:12:50.868]                   sessionInformation <- function() {
[16:12:50.868]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:50.868]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:50.868]                       search = base::search(), system = base::Sys.info())
[16:12:50.868]                   }
[16:12:50.868]                   ...future.conditions[[length(...future.conditions) + 
[16:12:50.868]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:50.868]                     cond$call), session = sessionInformation(), 
[16:12:50.868]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:50.868]                   signalCondition(cond)
[16:12:50.868]                 }
[16:12:50.868]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:50.868]                 "immediateCondition"))) {
[16:12:50.868]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:50.868]                   ...future.conditions[[length(...future.conditions) + 
[16:12:50.868]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:50.868]                   if (TRUE && !signal) {
[16:12:50.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:50.868]                     {
[16:12:50.868]                       inherits <- base::inherits
[16:12:50.868]                       invokeRestart <- base::invokeRestart
[16:12:50.868]                       is.null <- base::is.null
[16:12:50.868]                       muffled <- FALSE
[16:12:50.868]                       if (inherits(cond, "message")) {
[16:12:50.868]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:50.868]                         if (muffled) 
[16:12:50.868]                           invokeRestart("muffleMessage")
[16:12:50.868]                       }
[16:12:50.868]                       else if (inherits(cond, "warning")) {
[16:12:50.868]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:50.868]                         if (muffled) 
[16:12:50.868]                           invokeRestart("muffleWarning")
[16:12:50.868]                       }
[16:12:50.868]                       else if (inherits(cond, "condition")) {
[16:12:50.868]                         if (!is.null(pattern)) {
[16:12:50.868]                           computeRestarts <- base::computeRestarts
[16:12:50.868]                           grepl <- base::grepl
[16:12:50.868]                           restarts <- computeRestarts(cond)
[16:12:50.868]                           for (restart in restarts) {
[16:12:50.868]                             name <- restart$name
[16:12:50.868]                             if (is.null(name)) 
[16:12:50.868]                               next
[16:12:50.868]                             if (!grepl(pattern, name)) 
[16:12:50.868]                               next
[16:12:50.868]                             invokeRestart(restart)
[16:12:50.868]                             muffled <- TRUE
[16:12:50.868]                             break
[16:12:50.868]                           }
[16:12:50.868]                         }
[16:12:50.868]                       }
[16:12:50.868]                       invisible(muffled)
[16:12:50.868]                     }
[16:12:50.868]                     muffleCondition(cond, pattern = "^muffle")
[16:12:50.868]                   }
[16:12:50.868]                 }
[16:12:50.868]                 else {
[16:12:50.868]                   if (TRUE) {
[16:12:50.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:50.868]                     {
[16:12:50.868]                       inherits <- base::inherits
[16:12:50.868]                       invokeRestart <- base::invokeRestart
[16:12:50.868]                       is.null <- base::is.null
[16:12:50.868]                       muffled <- FALSE
[16:12:50.868]                       if (inherits(cond, "message")) {
[16:12:50.868]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:50.868]                         if (muffled) 
[16:12:50.868]                           invokeRestart("muffleMessage")
[16:12:50.868]                       }
[16:12:50.868]                       else if (inherits(cond, "warning")) {
[16:12:50.868]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:50.868]                         if (muffled) 
[16:12:50.868]                           invokeRestart("muffleWarning")
[16:12:50.868]                       }
[16:12:50.868]                       else if (inherits(cond, "condition")) {
[16:12:50.868]                         if (!is.null(pattern)) {
[16:12:50.868]                           computeRestarts <- base::computeRestarts
[16:12:50.868]                           grepl <- base::grepl
[16:12:50.868]                           restarts <- computeRestarts(cond)
[16:12:50.868]                           for (restart in restarts) {
[16:12:50.868]                             name <- restart$name
[16:12:50.868]                             if (is.null(name)) 
[16:12:50.868]                               next
[16:12:50.868]                             if (!grepl(pattern, name)) 
[16:12:50.868]                               next
[16:12:50.868]                             invokeRestart(restart)
[16:12:50.868]                             muffled <- TRUE
[16:12:50.868]                             break
[16:12:50.868]                           }
[16:12:50.868]                         }
[16:12:50.868]                       }
[16:12:50.868]                       invisible(muffled)
[16:12:50.868]                     }
[16:12:50.868]                     muffleCondition(cond, pattern = "^muffle")
[16:12:50.868]                   }
[16:12:50.868]                 }
[16:12:50.868]             }
[16:12:50.868]         }))
[16:12:50.868]     }, error = function(ex) {
[16:12:50.868]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:50.868]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:50.868]                 ...future.rng), started = ...future.startTime, 
[16:12:50.868]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:50.868]             version = "1.8"), class = "FutureResult")
[16:12:50.868]     }, finally = {
[16:12:50.868]         if (!identical(...future.workdir, getwd())) 
[16:12:50.868]             setwd(...future.workdir)
[16:12:50.868]         {
[16:12:50.868]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:50.868]                 ...future.oldOptions$nwarnings <- NULL
[16:12:50.868]             }
[16:12:50.868]             base::options(...future.oldOptions)
[16:12:50.868]             if (.Platform$OS.type == "windows") {
[16:12:50.868]                 old_names <- names(...future.oldEnvVars)
[16:12:50.868]                 envs <- base::Sys.getenv()
[16:12:50.868]                 names <- names(envs)
[16:12:50.868]                 common <- intersect(names, old_names)
[16:12:50.868]                 added <- setdiff(names, old_names)
[16:12:50.868]                 removed <- setdiff(old_names, names)
[16:12:50.868]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:50.868]                   envs[common]]
[16:12:50.868]                 NAMES <- toupper(changed)
[16:12:50.868]                 args <- list()
[16:12:50.868]                 for (kk in seq_along(NAMES)) {
[16:12:50.868]                   name <- changed[[kk]]
[16:12:50.868]                   NAME <- NAMES[[kk]]
[16:12:50.868]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:50.868]                     next
[16:12:50.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:50.868]                 }
[16:12:50.868]                 NAMES <- toupper(added)
[16:12:50.868]                 for (kk in seq_along(NAMES)) {
[16:12:50.868]                   name <- added[[kk]]
[16:12:50.868]                   NAME <- NAMES[[kk]]
[16:12:50.868]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:50.868]                     next
[16:12:50.868]                   args[[name]] <- ""
[16:12:50.868]                 }
[16:12:50.868]                 NAMES <- toupper(removed)
[16:12:50.868]                 for (kk in seq_along(NAMES)) {
[16:12:50.868]                   name <- removed[[kk]]
[16:12:50.868]                   NAME <- NAMES[[kk]]
[16:12:50.868]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:50.868]                     next
[16:12:50.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:50.868]                 }
[16:12:50.868]                 if (length(args) > 0) 
[16:12:50.868]                   base::do.call(base::Sys.setenv, args = args)
[16:12:50.868]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:50.868]             }
[16:12:50.868]             else {
[16:12:50.868]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:50.868]             }
[16:12:50.868]             {
[16:12:50.868]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:50.868]                   0L) {
[16:12:50.868]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:50.868]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:50.868]                   base::options(opts)
[16:12:50.868]                 }
[16:12:50.868]                 {
[16:12:50.868]                   {
[16:12:50.868]                     NULL
[16:12:50.868]                     RNGkind("Mersenne-Twister")
[16:12:50.868]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:50.868]                       inherits = FALSE)
[16:12:50.868]                   }
[16:12:50.868]                   options(future.plan = NULL)
[16:12:50.868]                   if (is.na(NA_character_)) 
[16:12:50.868]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:50.868]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:50.868]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:50.868]                   {
[16:12:50.868]                     future <- SequentialFuture(..., envir = envir)
[16:12:50.868]                     if (!future$lazy) 
[16:12:50.868]                       future <- run(future)
[16:12:50.868]                     invisible(future)
[16:12:50.868]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:50.868]                 }
[16:12:50.868]             }
[16:12:50.868]         }
[16:12:50.868]     })
[16:12:50.868]     if (TRUE) {
[16:12:50.868]         base::sink(type = "output", split = FALSE)
[16:12:50.868]         if (TRUE) {
[16:12:50.868]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:50.868]         }
[16:12:50.868]         else {
[16:12:50.868]             ...future.result["stdout"] <- base::list(NULL)
[16:12:50.868]         }
[16:12:50.868]         base::close(...future.stdout)
[16:12:50.868]         ...future.stdout <- NULL
[16:12:50.868]     }
[16:12:50.868]     ...future.result$conditions <- ...future.conditions
[16:12:50.868]     ...future.result$finished <- base::Sys.time()
[16:12:50.868]     ...future.result
[16:12:50.868] }
[16:12:50.870] plan(): Setting new future strategy stack:
[16:12:50.870] List of future strategies:
[16:12:50.870] 1. sequential:
[16:12:50.870]    - args: function (..., envir = parent.frame())
[16:12:50.870]    - tweaked: FALSE
[16:12:50.870]    - call: NULL
[16:12:50.871] plan(): nbrOfWorkers() = 1
[16:12:50.872] plan(): Setting new future strategy stack:
[16:12:50.872] List of future strategies:
[16:12:50.872] 1. sequential:
[16:12:50.872]    - args: function (..., envir = parent.frame())
[16:12:50.872]    - tweaked: FALSE
[16:12:50.872]    - call: plan(strategy)
[16:12:50.872] plan(): nbrOfWorkers() = 1
[16:12:50.872] SequentialFuture started (and completed)
[16:12:50.873] signalConditions() ...
[16:12:50.873]  - include = ‘immediateCondition’
[16:12:50.873]  - exclude = 
[16:12:50.873]  - resignal = FALSE
[16:12:50.873]  - Number of conditions: 1
[16:12:50.873] signalConditions() ... done
[16:12:50.873] - Launch lazy future ... done
[16:12:50.873] run() for ‘SequentialFuture’ ... done
[16:12:50.873] signalConditions() ...
[16:12:50.873]  - include = ‘immediateCondition’
[16:12:50.874]  - exclude = 
[16:12:50.874]  - resignal = FALSE
[16:12:50.874]  - Number of conditions: 1
[16:12:50.874] signalConditions() ... done
[16:12:50.874] Future state: ‘finished’
[16:12:50.874] signalConditions() ...
[16:12:50.874]  - include = ‘condition’
[16:12:50.874]  - exclude = ‘immediateCondition’
[16:12:50.874]  - resignal = TRUE
[16:12:50.874]  - Number of conditions: 1
[16:12:50.874]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:12:50.875] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2729ef2608da" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:12:50"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:50.895] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:50.895] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:50.896] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:50.896] Searching for globals ... DONE
[16:12:50.896] Resolving globals: TRUE
[16:12:50.897] Resolving any globals that are futures ...
[16:12:50.897] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:50.897] Resolving any globals that are futures ... DONE
[16:12:50.897] Resolving futures part of globals (recursively) ...
[16:12:50.898] resolve() on list ...
[16:12:50.898]  recursive: 99
[16:12:50.898]  length: 1
[16:12:50.899]  elements: ‘ii’
[16:12:50.899]  length: 0 (resolved future 1)
[16:12:50.899] resolve() on list ... DONE
[16:12:50.899] - globals: [1] ‘ii’
[16:12:50.899] Resolving futures part of globals (recursively) ... DONE
[16:12:50.899] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:50.900] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:12:50.900] - globals: [1] ‘ii’
[16:12:50.900] 
[16:12:50.900] getGlobalsAndPackages() ... DONE
[16:12:50.901] run() for ‘Future’ ...
[16:12:50.901] - state: ‘created’
[16:12:50.901] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:50.901] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:50.901] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:50.901]   - Field: ‘label’
[16:12:50.901]   - Field: ‘local’
[16:12:50.902]   - Field: ‘owner’
[16:12:50.902]   - Field: ‘envir’
[16:12:50.902]   - Field: ‘packages’
[16:12:50.902]   - Field: ‘gc’
[16:12:50.902]   - Field: ‘conditions’
[16:12:50.902]   - Field: ‘expr’
[16:12:50.902]   - Field: ‘uuid’
[16:12:50.902]   - Field: ‘seed’
[16:12:50.902]   - Field: ‘version’
[16:12:50.902]   - Field: ‘result’
[16:12:50.903]   - Field: ‘asynchronous’
[16:12:50.903]   - Field: ‘calls’
[16:12:50.903]   - Field: ‘globals’
[16:12:50.903]   - Field: ‘stdout’
[16:12:50.903]   - Field: ‘earlySignal’
[16:12:50.903]   - Field: ‘lazy’
[16:12:50.903]   - Field: ‘state’
[16:12:50.903] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:50.903] - Launch lazy future ...
[16:12:50.903] Packages needed by the future expression (n = 0): <none>
[16:12:50.904] Packages needed by future strategies (n = 0): <none>
[16:12:50.904] {
[16:12:50.904]     {
[16:12:50.904]         {
[16:12:50.904]             ...future.startTime <- base::Sys.time()
[16:12:50.904]             {
[16:12:50.904]                 {
[16:12:50.904]                   {
[16:12:50.904]                     base::local({
[16:12:50.904]                       has_future <- base::requireNamespace("future", 
[16:12:50.904]                         quietly = TRUE)
[16:12:50.904]                       if (has_future) {
[16:12:50.904]                         ns <- base::getNamespace("future")
[16:12:50.904]                         version <- ns[[".package"]][["version"]]
[16:12:50.904]                         if (is.null(version)) 
[16:12:50.904]                           version <- utils::packageVersion("future")
[16:12:50.904]                       }
[16:12:50.904]                       else {
[16:12:50.904]                         version <- NULL
[16:12:50.904]                       }
[16:12:50.904]                       if (!has_future || version < "1.8.0") {
[16:12:50.904]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:50.904]                           "", base::R.version$version.string), 
[16:12:50.904]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:50.904]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:50.904]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:50.904]                             "release", "version")], collapse = " "), 
[16:12:50.904]                           hostname = base::Sys.info()[["nodename"]])
[16:12:50.904]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:50.904]                           info)
[16:12:50.904]                         info <- base::paste(info, collapse = "; ")
[16:12:50.904]                         if (!has_future) {
[16:12:50.904]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:50.904]                             info)
[16:12:50.904]                         }
[16:12:50.904]                         else {
[16:12:50.904]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:50.904]                             info, version)
[16:12:50.904]                         }
[16:12:50.904]                         base::stop(msg)
[16:12:50.904]                       }
[16:12:50.904]                     })
[16:12:50.904]                   }
[16:12:50.904]                   options(future.plan = NULL)
[16:12:50.904]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:50.904]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:50.904]                 }
[16:12:50.904]                 ...future.workdir <- getwd()
[16:12:50.904]             }
[16:12:50.904]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:50.904]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:50.904]         }
[16:12:50.904]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:50.904]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:50.904]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:50.904]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:50.904]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:50.904]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:50.904]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:50.904]             base::names(...future.oldOptions))
[16:12:50.904]     }
[16:12:50.904]     if (FALSE) {
[16:12:50.904]     }
[16:12:50.904]     else {
[16:12:50.904]         if (TRUE) {
[16:12:50.904]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:50.904]                 open = "w")
[16:12:50.904]         }
[16:12:50.904]         else {
[16:12:50.904]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:50.904]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:50.904]         }
[16:12:50.904]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:50.904]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:50.904]             base::sink(type = "output", split = FALSE)
[16:12:50.904]             base::close(...future.stdout)
[16:12:50.904]         }, add = TRUE)
[16:12:50.904]     }
[16:12:50.904]     ...future.frame <- base::sys.nframe()
[16:12:50.904]     ...future.conditions <- base::list()
[16:12:50.904]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:50.904]     if (FALSE) {
[16:12:50.904]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:50.904]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:50.904]     }
[16:12:50.904]     ...future.result <- base::tryCatch({
[16:12:50.904]         base::withCallingHandlers({
[16:12:50.904]             ...future.value <- base::withVisible(base::local({
[16:12:50.904]                 b <- a * ii
[16:12:50.904]                 a <- 0
[16:12:50.904]                 b
[16:12:50.904]             }))
[16:12:50.904]             future::FutureResult(value = ...future.value$value, 
[16:12:50.904]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:50.904]                   ...future.rng), globalenv = if (FALSE) 
[16:12:50.904]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:50.904]                     ...future.globalenv.names))
[16:12:50.904]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:50.904]         }, condition = base::local({
[16:12:50.904]             c <- base::c
[16:12:50.904]             inherits <- base::inherits
[16:12:50.904]             invokeRestart <- base::invokeRestart
[16:12:50.904]             length <- base::length
[16:12:50.904]             list <- base::list
[16:12:50.904]             seq.int <- base::seq.int
[16:12:50.904]             signalCondition <- base::signalCondition
[16:12:50.904]             sys.calls <- base::sys.calls
[16:12:50.904]             `[[` <- base::`[[`
[16:12:50.904]             `+` <- base::`+`
[16:12:50.904]             `<<-` <- base::`<<-`
[16:12:50.904]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:50.904]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:50.904]                   3L)]
[16:12:50.904]             }
[16:12:50.904]             function(cond) {
[16:12:50.904]                 is_error <- inherits(cond, "error")
[16:12:50.904]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:50.904]                   NULL)
[16:12:50.904]                 if (is_error) {
[16:12:50.904]                   sessionInformation <- function() {
[16:12:50.904]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:50.904]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:50.904]                       search = base::search(), system = base::Sys.info())
[16:12:50.904]                   }
[16:12:50.904]                   ...future.conditions[[length(...future.conditions) + 
[16:12:50.904]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:50.904]                     cond$call), session = sessionInformation(), 
[16:12:50.904]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:50.904]                   signalCondition(cond)
[16:12:50.904]                 }
[16:12:50.904]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:50.904]                 "immediateCondition"))) {
[16:12:50.904]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:50.904]                   ...future.conditions[[length(...future.conditions) + 
[16:12:50.904]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:50.904]                   if (TRUE && !signal) {
[16:12:50.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:50.904]                     {
[16:12:50.904]                       inherits <- base::inherits
[16:12:50.904]                       invokeRestart <- base::invokeRestart
[16:12:50.904]                       is.null <- base::is.null
[16:12:50.904]                       muffled <- FALSE
[16:12:50.904]                       if (inherits(cond, "message")) {
[16:12:50.904]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:50.904]                         if (muffled) 
[16:12:50.904]                           invokeRestart("muffleMessage")
[16:12:50.904]                       }
[16:12:50.904]                       else if (inherits(cond, "warning")) {
[16:12:50.904]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:50.904]                         if (muffled) 
[16:12:50.904]                           invokeRestart("muffleWarning")
[16:12:50.904]                       }
[16:12:50.904]                       else if (inherits(cond, "condition")) {
[16:12:50.904]                         if (!is.null(pattern)) {
[16:12:50.904]                           computeRestarts <- base::computeRestarts
[16:12:50.904]                           grepl <- base::grepl
[16:12:50.904]                           restarts <- computeRestarts(cond)
[16:12:50.904]                           for (restart in restarts) {
[16:12:50.904]                             name <- restart$name
[16:12:50.904]                             if (is.null(name)) 
[16:12:50.904]                               next
[16:12:50.904]                             if (!grepl(pattern, name)) 
[16:12:50.904]                               next
[16:12:50.904]                             invokeRestart(restart)
[16:12:50.904]                             muffled <- TRUE
[16:12:50.904]                             break
[16:12:50.904]                           }
[16:12:50.904]                         }
[16:12:50.904]                       }
[16:12:50.904]                       invisible(muffled)
[16:12:50.904]                     }
[16:12:50.904]                     muffleCondition(cond, pattern = "^muffle")
[16:12:50.904]                   }
[16:12:50.904]                 }
[16:12:50.904]                 else {
[16:12:50.904]                   if (TRUE) {
[16:12:50.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:50.904]                     {
[16:12:50.904]                       inherits <- base::inherits
[16:12:50.904]                       invokeRestart <- base::invokeRestart
[16:12:50.904]                       is.null <- base::is.null
[16:12:50.904]                       muffled <- FALSE
[16:12:50.904]                       if (inherits(cond, "message")) {
[16:12:50.904]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:50.904]                         if (muffled) 
[16:12:50.904]                           invokeRestart("muffleMessage")
[16:12:50.904]                       }
[16:12:50.904]                       else if (inherits(cond, "warning")) {
[16:12:50.904]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:50.904]                         if (muffled) 
[16:12:50.904]                           invokeRestart("muffleWarning")
[16:12:50.904]                       }
[16:12:50.904]                       else if (inherits(cond, "condition")) {
[16:12:50.904]                         if (!is.null(pattern)) {
[16:12:50.904]                           computeRestarts <- base::computeRestarts
[16:12:50.904]                           grepl <- base::grepl
[16:12:50.904]                           restarts <- computeRestarts(cond)
[16:12:50.904]                           for (restart in restarts) {
[16:12:50.904]                             name <- restart$name
[16:12:50.904]                             if (is.null(name)) 
[16:12:50.904]                               next
[16:12:50.904]                             if (!grepl(pattern, name)) 
[16:12:50.904]                               next
[16:12:50.904]                             invokeRestart(restart)
[16:12:50.904]                             muffled <- TRUE
[16:12:50.904]                             break
[16:12:50.904]                           }
[16:12:50.904]                         }
[16:12:50.904]                       }
[16:12:50.904]                       invisible(muffled)
[16:12:50.904]                     }
[16:12:50.904]                     muffleCondition(cond, pattern = "^muffle")
[16:12:50.904]                   }
[16:12:50.904]                 }
[16:12:50.904]             }
[16:12:50.904]         }))
[16:12:50.904]     }, error = function(ex) {
[16:12:50.904]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:50.904]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:50.904]                 ...future.rng), started = ...future.startTime, 
[16:12:50.904]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:50.904]             version = "1.8"), class = "FutureResult")
[16:12:50.904]     }, finally = {
[16:12:50.904]         if (!identical(...future.workdir, getwd())) 
[16:12:50.904]             setwd(...future.workdir)
[16:12:50.904]         {
[16:12:50.904]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:50.904]                 ...future.oldOptions$nwarnings <- NULL
[16:12:50.904]             }
[16:12:50.904]             base::options(...future.oldOptions)
[16:12:50.904]             if (.Platform$OS.type == "windows") {
[16:12:50.904]                 old_names <- names(...future.oldEnvVars)
[16:12:50.904]                 envs <- base::Sys.getenv()
[16:12:50.904]                 names <- names(envs)
[16:12:50.904]                 common <- intersect(names, old_names)
[16:12:50.904]                 added <- setdiff(names, old_names)
[16:12:50.904]                 removed <- setdiff(old_names, names)
[16:12:50.904]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:50.904]                   envs[common]]
[16:12:50.904]                 NAMES <- toupper(changed)
[16:12:50.904]                 args <- list()
[16:12:50.904]                 for (kk in seq_along(NAMES)) {
[16:12:50.904]                   name <- changed[[kk]]
[16:12:50.904]                   NAME <- NAMES[[kk]]
[16:12:50.904]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:50.904]                     next
[16:12:50.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:50.904]                 }
[16:12:50.904]                 NAMES <- toupper(added)
[16:12:50.904]                 for (kk in seq_along(NAMES)) {
[16:12:50.904]                   name <- added[[kk]]
[16:12:50.904]                   NAME <- NAMES[[kk]]
[16:12:50.904]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:50.904]                     next
[16:12:50.904]                   args[[name]] <- ""
[16:12:50.904]                 }
[16:12:50.904]                 NAMES <- toupper(removed)
[16:12:50.904]                 for (kk in seq_along(NAMES)) {
[16:12:50.904]                   name <- removed[[kk]]
[16:12:50.904]                   NAME <- NAMES[[kk]]
[16:12:50.904]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:50.904]                     next
[16:12:50.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:50.904]                 }
[16:12:50.904]                 if (length(args) > 0) 
[16:12:50.904]                   base::do.call(base::Sys.setenv, args = args)
[16:12:50.904]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:50.904]             }
[16:12:50.904]             else {
[16:12:50.904]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:50.904]             }
[16:12:50.904]             {
[16:12:50.904]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:50.904]                   0L) {
[16:12:50.904]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:50.904]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:50.904]                   base::options(opts)
[16:12:50.904]                 }
[16:12:50.904]                 {
[16:12:50.904]                   {
[16:12:50.904]                     NULL
[16:12:50.904]                     RNGkind("Mersenne-Twister")
[16:12:50.904]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:50.904]                       inherits = FALSE)
[16:12:50.904]                   }
[16:12:50.904]                   options(future.plan = NULL)
[16:12:50.904]                   if (is.na(NA_character_)) 
[16:12:50.904]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:50.904]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:50.904]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:50.904]                   {
[16:12:50.904]                     future <- SequentialFuture(..., envir = envir)
[16:12:50.904]                     if (!future$lazy) 
[16:12:50.904]                       future <- run(future)
[16:12:50.904]                     invisible(future)
[16:12:50.904]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:50.904]                 }
[16:12:50.904]             }
[16:12:50.904]         }
[16:12:50.904]     })
[16:12:50.904]     if (TRUE) {
[16:12:50.904]         base::sink(type = "output", split = FALSE)
[16:12:50.904]         if (TRUE) {
[16:12:50.904]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:50.904]         }
[16:12:50.904]         else {
[16:12:50.904]             ...future.result["stdout"] <- base::list(NULL)
[16:12:50.904]         }
[16:12:50.904]         base::close(...future.stdout)
[16:12:50.904]         ...future.stdout <- NULL
[16:12:50.904]     }
[16:12:50.904]     ...future.result$conditions <- ...future.conditions
[16:12:50.904]     ...future.result$finished <- base::Sys.time()
[16:12:50.904]     ...future.result
[16:12:50.904] }
[16:12:50.906] assign_globals() ...
[16:12:50.906] List of 1
[16:12:50.906]  $ ii: int 1
[16:12:50.906]  - attr(*, "where")=List of 1
[16:12:50.906]   ..$ ii:<environment: R_EmptyEnv> 
[16:12:50.906]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:50.906]  - attr(*, "resolved")= logi TRUE
[16:12:50.906]  - attr(*, "total_size")= num 56
[16:12:50.906]  - attr(*, "already-done")= logi TRUE
[16:12:50.909] - copied ‘ii’ to environment
[16:12:50.909] assign_globals() ... done
[16:12:50.909] plan(): Setting new future strategy stack:
[16:12:50.909] List of future strategies:
[16:12:50.909] 1. sequential:
[16:12:50.909]    - args: function (..., envir = parent.frame())
[16:12:50.909]    - tweaked: FALSE
[16:12:50.909]    - call: NULL
[16:12:50.910] plan(): nbrOfWorkers() = 1
[16:12:50.910] plan(): Setting new future strategy stack:
[16:12:50.910] List of future strategies:
[16:12:50.910] 1. sequential:
[16:12:50.910]    - args: function (..., envir = parent.frame())
[16:12:50.910]    - tweaked: FALSE
[16:12:50.910]    - call: plan(strategy)
[16:12:50.911] plan(): nbrOfWorkers() = 1
[16:12:50.911] SequentialFuture started (and completed)
[16:12:50.911] - Launch lazy future ... done
[16:12:50.911] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:50.912] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:50.912] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:50.913] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:50.914] Searching for globals ... DONE
[16:12:50.914] Resolving globals: TRUE
[16:12:50.914] Resolving any globals that are futures ...
[16:12:50.914] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:50.914] Resolving any globals that are futures ... DONE
[16:12:50.914] Resolving futures part of globals (recursively) ...
[16:12:50.915] resolve() on list ...
[16:12:50.915]  recursive: 99
[16:12:50.915]  length: 1
[16:12:50.915]  elements: ‘ii’
[16:12:50.915]  length: 0 (resolved future 1)
[16:12:50.915] resolve() on list ... DONE
[16:12:50.915] - globals: [1] ‘ii’
[16:12:50.915] Resolving futures part of globals (recursively) ... DONE
[16:12:50.915] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:50.916] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:12:50.916] - globals: [1] ‘ii’
[16:12:50.916] 
[16:12:50.916] getGlobalsAndPackages() ... DONE
[16:12:50.916] run() for ‘Future’ ...
[16:12:50.916] - state: ‘created’
[16:12:50.917] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:50.917] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:50.917] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:50.917]   - Field: ‘label’
[16:12:50.917]   - Field: ‘local’
[16:12:50.917]   - Field: ‘owner’
[16:12:50.917]   - Field: ‘envir’
[16:12:50.917]   - Field: ‘packages’
[16:12:50.918]   - Field: ‘gc’
[16:12:50.918]   - Field: ‘conditions’
[16:12:50.918]   - Field: ‘expr’
[16:12:50.918]   - Field: ‘uuid’
[16:12:50.918]   - Field: ‘seed’
[16:12:50.918]   - Field: ‘version’
[16:12:50.918]   - Field: ‘result’
[16:12:50.918]   - Field: ‘asynchronous’
[16:12:50.918]   - Field: ‘calls’
[16:12:50.918]   - Field: ‘globals’
[16:12:50.918]   - Field: ‘stdout’
[16:12:50.919]   - Field: ‘earlySignal’
[16:12:50.921]   - Field: ‘lazy’
[16:12:50.921]   - Field: ‘state’
[16:12:50.921] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:50.921] - Launch lazy future ...
[16:12:50.921] Packages needed by the future expression (n = 0): <none>
[16:12:50.922] Packages needed by future strategies (n = 0): <none>
[16:12:50.922] {
[16:12:50.922]     {
[16:12:50.922]         {
[16:12:50.922]             ...future.startTime <- base::Sys.time()
[16:12:50.922]             {
[16:12:50.922]                 {
[16:12:50.922]                   {
[16:12:50.922]                     base::local({
[16:12:50.922]                       has_future <- base::requireNamespace("future", 
[16:12:50.922]                         quietly = TRUE)
[16:12:50.922]                       if (has_future) {
[16:12:50.922]                         ns <- base::getNamespace("future")
[16:12:50.922]                         version <- ns[[".package"]][["version"]]
[16:12:50.922]                         if (is.null(version)) 
[16:12:50.922]                           version <- utils::packageVersion("future")
[16:12:50.922]                       }
[16:12:50.922]                       else {
[16:12:50.922]                         version <- NULL
[16:12:50.922]                       }
[16:12:50.922]                       if (!has_future || version < "1.8.0") {
[16:12:50.922]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:50.922]                           "", base::R.version$version.string), 
[16:12:50.922]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:50.922]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:50.922]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:50.922]                             "release", "version")], collapse = " "), 
[16:12:50.922]                           hostname = base::Sys.info()[["nodename"]])
[16:12:50.922]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:50.922]                           info)
[16:12:50.922]                         info <- base::paste(info, collapse = "; ")
[16:12:50.922]                         if (!has_future) {
[16:12:50.922]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:50.922]                             info)
[16:12:50.922]                         }
[16:12:50.922]                         else {
[16:12:50.922]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:50.922]                             info, version)
[16:12:50.922]                         }
[16:12:50.922]                         base::stop(msg)
[16:12:50.922]                       }
[16:12:50.922]                     })
[16:12:50.922]                   }
[16:12:50.922]                   options(future.plan = NULL)
[16:12:50.922]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:50.922]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:50.922]                 }
[16:12:50.922]                 ...future.workdir <- getwd()
[16:12:50.922]             }
[16:12:50.922]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:50.922]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:50.922]         }
[16:12:50.922]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:50.922]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:50.922]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:50.922]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:50.922]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:50.922]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:50.922]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:50.922]             base::names(...future.oldOptions))
[16:12:50.922]     }
[16:12:50.922]     if (FALSE) {
[16:12:50.922]     }
[16:12:50.922]     else {
[16:12:50.922]         if (TRUE) {
[16:12:50.922]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:50.922]                 open = "w")
[16:12:50.922]         }
[16:12:50.922]         else {
[16:12:50.922]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:50.922]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:50.922]         }
[16:12:50.922]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:50.922]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:50.922]             base::sink(type = "output", split = FALSE)
[16:12:50.922]             base::close(...future.stdout)
[16:12:50.922]         }, add = TRUE)
[16:12:50.922]     }
[16:12:50.922]     ...future.frame <- base::sys.nframe()
[16:12:50.922]     ...future.conditions <- base::list()
[16:12:50.922]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:50.922]     if (FALSE) {
[16:12:50.922]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:50.922]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:50.922]     }
[16:12:50.922]     ...future.result <- base::tryCatch({
[16:12:50.922]         base::withCallingHandlers({
[16:12:50.922]             ...future.value <- base::withVisible(base::local({
[16:12:50.922]                 b <- a * ii
[16:12:50.922]                 a <- 0
[16:12:50.922]                 b
[16:12:50.922]             }))
[16:12:50.922]             future::FutureResult(value = ...future.value$value, 
[16:12:50.922]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:50.922]                   ...future.rng), globalenv = if (FALSE) 
[16:12:50.922]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:50.922]                     ...future.globalenv.names))
[16:12:50.922]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:50.922]         }, condition = base::local({
[16:12:50.922]             c <- base::c
[16:12:50.922]             inherits <- base::inherits
[16:12:50.922]             invokeRestart <- base::invokeRestart
[16:12:50.922]             length <- base::length
[16:12:50.922]             list <- base::list
[16:12:50.922]             seq.int <- base::seq.int
[16:12:50.922]             signalCondition <- base::signalCondition
[16:12:50.922]             sys.calls <- base::sys.calls
[16:12:50.922]             `[[` <- base::`[[`
[16:12:50.922]             `+` <- base::`+`
[16:12:50.922]             `<<-` <- base::`<<-`
[16:12:50.922]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:50.922]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:50.922]                   3L)]
[16:12:50.922]             }
[16:12:50.922]             function(cond) {
[16:12:50.922]                 is_error <- inherits(cond, "error")
[16:12:50.922]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:50.922]                   NULL)
[16:12:50.922]                 if (is_error) {
[16:12:50.922]                   sessionInformation <- function() {
[16:12:50.922]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:50.922]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:50.922]                       search = base::search(), system = base::Sys.info())
[16:12:50.922]                   }
[16:12:50.922]                   ...future.conditions[[length(...future.conditions) + 
[16:12:50.922]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:50.922]                     cond$call), session = sessionInformation(), 
[16:12:50.922]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:50.922]                   signalCondition(cond)
[16:12:50.922]                 }
[16:12:50.922]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:50.922]                 "immediateCondition"))) {
[16:12:50.922]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:50.922]                   ...future.conditions[[length(...future.conditions) + 
[16:12:50.922]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:50.922]                   if (TRUE && !signal) {
[16:12:50.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:50.922]                     {
[16:12:50.922]                       inherits <- base::inherits
[16:12:50.922]                       invokeRestart <- base::invokeRestart
[16:12:50.922]                       is.null <- base::is.null
[16:12:50.922]                       muffled <- FALSE
[16:12:50.922]                       if (inherits(cond, "message")) {
[16:12:50.922]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:50.922]                         if (muffled) 
[16:12:50.922]                           invokeRestart("muffleMessage")
[16:12:50.922]                       }
[16:12:50.922]                       else if (inherits(cond, "warning")) {
[16:12:50.922]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:50.922]                         if (muffled) 
[16:12:50.922]                           invokeRestart("muffleWarning")
[16:12:50.922]                       }
[16:12:50.922]                       else if (inherits(cond, "condition")) {
[16:12:50.922]                         if (!is.null(pattern)) {
[16:12:50.922]                           computeRestarts <- base::computeRestarts
[16:12:50.922]                           grepl <- base::grepl
[16:12:50.922]                           restarts <- computeRestarts(cond)
[16:12:50.922]                           for (restart in restarts) {
[16:12:50.922]                             name <- restart$name
[16:12:50.922]                             if (is.null(name)) 
[16:12:50.922]                               next
[16:12:50.922]                             if (!grepl(pattern, name)) 
[16:12:50.922]                               next
[16:12:50.922]                             invokeRestart(restart)
[16:12:50.922]                             muffled <- TRUE
[16:12:50.922]                             break
[16:12:50.922]                           }
[16:12:50.922]                         }
[16:12:50.922]                       }
[16:12:50.922]                       invisible(muffled)
[16:12:50.922]                     }
[16:12:50.922]                     muffleCondition(cond, pattern = "^muffle")
[16:12:50.922]                   }
[16:12:50.922]                 }
[16:12:50.922]                 else {
[16:12:50.922]                   if (TRUE) {
[16:12:50.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:50.922]                     {
[16:12:50.922]                       inherits <- base::inherits
[16:12:50.922]                       invokeRestart <- base::invokeRestart
[16:12:50.922]                       is.null <- base::is.null
[16:12:50.922]                       muffled <- FALSE
[16:12:50.922]                       if (inherits(cond, "message")) {
[16:12:50.922]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:50.922]                         if (muffled) 
[16:12:50.922]                           invokeRestart("muffleMessage")
[16:12:50.922]                       }
[16:12:50.922]                       else if (inherits(cond, "warning")) {
[16:12:50.922]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:50.922]                         if (muffled) 
[16:12:50.922]                           invokeRestart("muffleWarning")
[16:12:50.922]                       }
[16:12:50.922]                       else if (inherits(cond, "condition")) {
[16:12:50.922]                         if (!is.null(pattern)) {
[16:12:50.922]                           computeRestarts <- base::computeRestarts
[16:12:50.922]                           grepl <- base::grepl
[16:12:50.922]                           restarts <- computeRestarts(cond)
[16:12:50.922]                           for (restart in restarts) {
[16:12:50.922]                             name <- restart$name
[16:12:50.922]                             if (is.null(name)) 
[16:12:50.922]                               next
[16:12:50.922]                             if (!grepl(pattern, name)) 
[16:12:50.922]                               next
[16:12:50.922]                             invokeRestart(restart)
[16:12:50.922]                             muffled <- TRUE
[16:12:50.922]                             break
[16:12:50.922]                           }
[16:12:50.922]                         }
[16:12:50.922]                       }
[16:12:50.922]                       invisible(muffled)
[16:12:50.922]                     }
[16:12:50.922]                     muffleCondition(cond, pattern = "^muffle")
[16:12:50.922]                   }
[16:12:50.922]                 }
[16:12:50.922]             }
[16:12:50.922]         }))
[16:12:50.922]     }, error = function(ex) {
[16:12:50.922]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:50.922]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:50.922]                 ...future.rng), started = ...future.startTime, 
[16:12:50.922]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:50.922]             version = "1.8"), class = "FutureResult")
[16:12:50.922]     }, finally = {
[16:12:50.922]         if (!identical(...future.workdir, getwd())) 
[16:12:50.922]             setwd(...future.workdir)
[16:12:50.922]         {
[16:12:50.922]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:50.922]                 ...future.oldOptions$nwarnings <- NULL
[16:12:50.922]             }
[16:12:50.922]             base::options(...future.oldOptions)
[16:12:50.922]             if (.Platform$OS.type == "windows") {
[16:12:50.922]                 old_names <- names(...future.oldEnvVars)
[16:12:50.922]                 envs <- base::Sys.getenv()
[16:12:50.922]                 names <- names(envs)
[16:12:50.922]                 common <- intersect(names, old_names)
[16:12:50.922]                 added <- setdiff(names, old_names)
[16:12:50.922]                 removed <- setdiff(old_names, names)
[16:12:50.922]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:50.922]                   envs[common]]
[16:12:50.922]                 NAMES <- toupper(changed)
[16:12:50.922]                 args <- list()
[16:12:50.922]                 for (kk in seq_along(NAMES)) {
[16:12:50.922]                   name <- changed[[kk]]
[16:12:50.922]                   NAME <- NAMES[[kk]]
[16:12:50.922]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:50.922]                     next
[16:12:50.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:50.922]                 }
[16:12:50.922]                 NAMES <- toupper(added)
[16:12:50.922]                 for (kk in seq_along(NAMES)) {
[16:12:50.922]                   name <- added[[kk]]
[16:12:50.922]                   NAME <- NAMES[[kk]]
[16:12:50.922]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:50.922]                     next
[16:12:50.922]                   args[[name]] <- ""
[16:12:50.922]                 }
[16:12:50.922]                 NAMES <- toupper(removed)
[16:12:50.922]                 for (kk in seq_along(NAMES)) {
[16:12:50.922]                   name <- removed[[kk]]
[16:12:50.922]                   NAME <- NAMES[[kk]]
[16:12:50.922]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:50.922]                     next
[16:12:50.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:50.922]                 }
[16:12:50.922]                 if (length(args) > 0) 
[16:12:50.922]                   base::do.call(base::Sys.setenv, args = args)
[16:12:50.922]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:50.922]             }
[16:12:50.922]             else {
[16:12:50.922]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:50.922]             }
[16:12:50.922]             {
[16:12:50.922]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:50.922]                   0L) {
[16:12:50.922]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:50.922]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:50.922]                   base::options(opts)
[16:12:50.922]                 }
[16:12:50.922]                 {
[16:12:50.922]                   {
[16:12:50.922]                     NULL
[16:12:50.922]                     RNGkind("Mersenne-Twister")
[16:12:50.922]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:50.922]                       inherits = FALSE)
[16:12:50.922]                   }
[16:12:50.922]                   options(future.plan = NULL)
[16:12:50.922]                   if (is.na(NA_character_)) 
[16:12:50.922]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:50.922]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:50.922]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:50.922]                   {
[16:12:50.922]                     future <- SequentialFuture(..., envir = envir)
[16:12:50.922]                     if (!future$lazy) 
[16:12:50.922]                       future <- run(future)
[16:12:50.922]                     invisible(future)
[16:12:50.922]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:50.922]                 }
[16:12:50.922]             }
[16:12:50.922]         }
[16:12:50.922]     })
[16:12:50.922]     if (TRUE) {
[16:12:50.922]         base::sink(type = "output", split = FALSE)
[16:12:50.922]         if (TRUE) {
[16:12:50.922]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:50.922]         }
[16:12:50.922]         else {
[16:12:50.922]             ...future.result["stdout"] <- base::list(NULL)
[16:12:50.922]         }
[16:12:50.922]         base::close(...future.stdout)
[16:12:50.922]         ...future.stdout <- NULL
[16:12:50.922]     }
[16:12:50.922]     ...future.result$conditions <- ...future.conditions
[16:12:50.922]     ...future.result$finished <- base::Sys.time()
[16:12:50.922]     ...future.result
[16:12:50.922] }
[16:12:50.924] assign_globals() ...
[16:12:50.924] List of 1
[16:12:50.924]  $ ii: int 2
[16:12:50.924]  - attr(*, "where")=List of 1
[16:12:50.924]   ..$ ii:<environment: R_EmptyEnv> 
[16:12:50.924]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:50.924]  - attr(*, "resolved")= logi TRUE
[16:12:50.924]  - attr(*, "total_size")= num 56
[16:12:50.924]  - attr(*, "already-done")= logi TRUE
[16:12:50.927] - copied ‘ii’ to environment
[16:12:50.927] assign_globals() ... done
[16:12:50.927] plan(): Setting new future strategy stack:
[16:12:50.927] List of future strategies:
[16:12:50.927] 1. sequential:
[16:12:50.927]    - args: function (..., envir = parent.frame())
[16:12:50.927]    - tweaked: FALSE
[16:12:50.927]    - call: NULL
[16:12:50.928] plan(): nbrOfWorkers() = 1
[16:12:50.929] plan(): Setting new future strategy stack:
[16:12:50.929] List of future strategies:
[16:12:50.929] 1. sequential:
[16:12:50.929]    - args: function (..., envir = parent.frame())
[16:12:50.929]    - tweaked: FALSE
[16:12:50.929]    - call: plan(strategy)
[16:12:50.929] plan(): nbrOfWorkers() = 1
[16:12:50.929] SequentialFuture started (and completed)
[16:12:50.929] - Launch lazy future ... done
[16:12:50.930] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:50.930] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:50.930] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:50.932] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:50.932] Searching for globals ... DONE
[16:12:50.932] Resolving globals: TRUE
[16:12:50.932] Resolving any globals that are futures ...
[16:12:50.932] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:50.932] Resolving any globals that are futures ... DONE
[16:12:50.933] Resolving futures part of globals (recursively) ...
[16:12:50.933] resolve() on list ...
[16:12:50.933]  recursive: 99
[16:12:50.933]  length: 1
[16:12:50.933]  elements: ‘ii’
[16:12:50.933]  length: 0 (resolved future 1)
[16:12:50.933] resolve() on list ... DONE
[16:12:50.933] - globals: [1] ‘ii’
[16:12:50.934] Resolving futures part of globals (recursively) ... DONE
[16:12:50.934] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:50.934] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:12:50.934] - globals: [1] ‘ii’
[16:12:50.934] 
[16:12:50.934] getGlobalsAndPackages() ... DONE
[16:12:50.935] run() for ‘Future’ ...
[16:12:50.935] - state: ‘created’
[16:12:50.935] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:50.935] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:50.935] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:50.935]   - Field: ‘label’
[16:12:50.935]   - Field: ‘local’
[16:12:50.936]   - Field: ‘owner’
[16:12:50.936]   - Field: ‘envir’
[16:12:50.936]   - Field: ‘packages’
[16:12:50.936]   - Field: ‘gc’
[16:12:50.936]   - Field: ‘conditions’
[16:12:50.936]   - Field: ‘expr’
[16:12:50.936]   - Field: ‘uuid’
[16:12:50.936]   - Field: ‘seed’
[16:12:50.936]   - Field: ‘version’
[16:12:50.936]   - Field: ‘result’
[16:12:50.937]   - Field: ‘asynchronous’
[16:12:50.937]   - Field: ‘calls’
[16:12:50.937]   - Field: ‘globals’
[16:12:50.937]   - Field: ‘stdout’
[16:12:50.937]   - Field: ‘earlySignal’
[16:12:50.937]   - Field: ‘lazy’
[16:12:50.937]   - Field: ‘state’
[16:12:50.937] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:50.937] - Launch lazy future ...
[16:12:50.937] Packages needed by the future expression (n = 0): <none>
[16:12:50.938] Packages needed by future strategies (n = 0): <none>
[16:12:50.938] {
[16:12:50.938]     {
[16:12:50.938]         {
[16:12:50.938]             ...future.startTime <- base::Sys.time()
[16:12:50.938]             {
[16:12:50.938]                 {
[16:12:50.938]                   {
[16:12:50.938]                     base::local({
[16:12:50.938]                       has_future <- base::requireNamespace("future", 
[16:12:50.938]                         quietly = TRUE)
[16:12:50.938]                       if (has_future) {
[16:12:50.938]                         ns <- base::getNamespace("future")
[16:12:50.938]                         version <- ns[[".package"]][["version"]]
[16:12:50.938]                         if (is.null(version)) 
[16:12:50.938]                           version <- utils::packageVersion("future")
[16:12:50.938]                       }
[16:12:50.938]                       else {
[16:12:50.938]                         version <- NULL
[16:12:50.938]                       }
[16:12:50.938]                       if (!has_future || version < "1.8.0") {
[16:12:50.938]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:50.938]                           "", base::R.version$version.string), 
[16:12:50.938]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:50.938]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:50.938]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:50.938]                             "release", "version")], collapse = " "), 
[16:12:50.938]                           hostname = base::Sys.info()[["nodename"]])
[16:12:50.938]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:50.938]                           info)
[16:12:50.938]                         info <- base::paste(info, collapse = "; ")
[16:12:50.938]                         if (!has_future) {
[16:12:50.938]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:50.938]                             info)
[16:12:50.938]                         }
[16:12:50.938]                         else {
[16:12:50.938]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:50.938]                             info, version)
[16:12:50.938]                         }
[16:12:50.938]                         base::stop(msg)
[16:12:50.938]                       }
[16:12:50.938]                     })
[16:12:50.938]                   }
[16:12:50.938]                   options(future.plan = NULL)
[16:12:50.938]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:50.938]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:50.938]                 }
[16:12:50.938]                 ...future.workdir <- getwd()
[16:12:50.938]             }
[16:12:50.938]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:50.938]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:50.938]         }
[16:12:50.938]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:50.938]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:50.938]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:50.938]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:50.938]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:50.938]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:50.938]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:50.938]             base::names(...future.oldOptions))
[16:12:50.938]     }
[16:12:50.938]     if (FALSE) {
[16:12:50.938]     }
[16:12:50.938]     else {
[16:12:50.938]         if (TRUE) {
[16:12:50.938]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:50.938]                 open = "w")
[16:12:50.938]         }
[16:12:50.938]         else {
[16:12:50.938]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:50.938]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:50.938]         }
[16:12:50.938]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:50.938]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:50.938]             base::sink(type = "output", split = FALSE)
[16:12:50.938]             base::close(...future.stdout)
[16:12:50.938]         }, add = TRUE)
[16:12:50.938]     }
[16:12:50.938]     ...future.frame <- base::sys.nframe()
[16:12:50.938]     ...future.conditions <- base::list()
[16:12:50.938]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:50.938]     if (FALSE) {
[16:12:50.938]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:50.938]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:50.938]     }
[16:12:50.938]     ...future.result <- base::tryCatch({
[16:12:50.938]         base::withCallingHandlers({
[16:12:50.938]             ...future.value <- base::withVisible(base::local({
[16:12:50.938]                 b <- a * ii
[16:12:50.938]                 a <- 0
[16:12:50.938]                 b
[16:12:50.938]             }))
[16:12:50.938]             future::FutureResult(value = ...future.value$value, 
[16:12:50.938]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:50.938]                   ...future.rng), globalenv = if (FALSE) 
[16:12:50.938]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:50.938]                     ...future.globalenv.names))
[16:12:50.938]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:50.938]         }, condition = base::local({
[16:12:50.938]             c <- base::c
[16:12:50.938]             inherits <- base::inherits
[16:12:50.938]             invokeRestart <- base::invokeRestart
[16:12:50.938]             length <- base::length
[16:12:50.938]             list <- base::list
[16:12:50.938]             seq.int <- base::seq.int
[16:12:50.938]             signalCondition <- base::signalCondition
[16:12:50.938]             sys.calls <- base::sys.calls
[16:12:50.938]             `[[` <- base::`[[`
[16:12:50.938]             `+` <- base::`+`
[16:12:50.938]             `<<-` <- base::`<<-`
[16:12:50.938]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:50.938]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:50.938]                   3L)]
[16:12:50.938]             }
[16:12:50.938]             function(cond) {
[16:12:50.938]                 is_error <- inherits(cond, "error")
[16:12:50.938]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:50.938]                   NULL)
[16:12:50.938]                 if (is_error) {
[16:12:50.938]                   sessionInformation <- function() {
[16:12:50.938]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:50.938]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:50.938]                       search = base::search(), system = base::Sys.info())
[16:12:50.938]                   }
[16:12:50.938]                   ...future.conditions[[length(...future.conditions) + 
[16:12:50.938]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:50.938]                     cond$call), session = sessionInformation(), 
[16:12:50.938]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:50.938]                   signalCondition(cond)
[16:12:50.938]                 }
[16:12:50.938]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:50.938]                 "immediateCondition"))) {
[16:12:50.938]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:50.938]                   ...future.conditions[[length(...future.conditions) + 
[16:12:50.938]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:50.938]                   if (TRUE && !signal) {
[16:12:50.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:50.938]                     {
[16:12:50.938]                       inherits <- base::inherits
[16:12:50.938]                       invokeRestart <- base::invokeRestart
[16:12:50.938]                       is.null <- base::is.null
[16:12:50.938]                       muffled <- FALSE
[16:12:50.938]                       if (inherits(cond, "message")) {
[16:12:50.938]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:50.938]                         if (muffled) 
[16:12:50.938]                           invokeRestart("muffleMessage")
[16:12:50.938]                       }
[16:12:50.938]                       else if (inherits(cond, "warning")) {
[16:12:50.938]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:50.938]                         if (muffled) 
[16:12:50.938]                           invokeRestart("muffleWarning")
[16:12:50.938]                       }
[16:12:50.938]                       else if (inherits(cond, "condition")) {
[16:12:50.938]                         if (!is.null(pattern)) {
[16:12:50.938]                           computeRestarts <- base::computeRestarts
[16:12:50.938]                           grepl <- base::grepl
[16:12:50.938]                           restarts <- computeRestarts(cond)
[16:12:50.938]                           for (restart in restarts) {
[16:12:50.938]                             name <- restart$name
[16:12:50.938]                             if (is.null(name)) 
[16:12:50.938]                               next
[16:12:50.938]                             if (!grepl(pattern, name)) 
[16:12:50.938]                               next
[16:12:50.938]                             invokeRestart(restart)
[16:12:50.938]                             muffled <- TRUE
[16:12:50.938]                             break
[16:12:50.938]                           }
[16:12:50.938]                         }
[16:12:50.938]                       }
[16:12:50.938]                       invisible(muffled)
[16:12:50.938]                     }
[16:12:50.938]                     muffleCondition(cond, pattern = "^muffle")
[16:12:50.938]                   }
[16:12:50.938]                 }
[16:12:50.938]                 else {
[16:12:50.938]                   if (TRUE) {
[16:12:50.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:50.938]                     {
[16:12:50.938]                       inherits <- base::inherits
[16:12:50.938]                       invokeRestart <- base::invokeRestart
[16:12:50.938]                       is.null <- base::is.null
[16:12:50.938]                       muffled <- FALSE
[16:12:50.938]                       if (inherits(cond, "message")) {
[16:12:50.938]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:50.938]                         if (muffled) 
[16:12:50.938]                           invokeRestart("muffleMessage")
[16:12:50.938]                       }
[16:12:50.938]                       else if (inherits(cond, "warning")) {
[16:12:50.938]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:50.938]                         if (muffled) 
[16:12:50.938]                           invokeRestart("muffleWarning")
[16:12:50.938]                       }
[16:12:50.938]                       else if (inherits(cond, "condition")) {
[16:12:50.938]                         if (!is.null(pattern)) {
[16:12:50.938]                           computeRestarts <- base::computeRestarts
[16:12:50.938]                           grepl <- base::grepl
[16:12:50.938]                           restarts <- computeRestarts(cond)
[16:12:50.938]                           for (restart in restarts) {
[16:12:50.938]                             name <- restart$name
[16:12:50.938]                             if (is.null(name)) 
[16:12:50.938]                               next
[16:12:50.938]                             if (!grepl(pattern, name)) 
[16:12:50.938]                               next
[16:12:50.938]                             invokeRestart(restart)
[16:12:50.938]                             muffled <- TRUE
[16:12:50.938]                             break
[16:12:50.938]                           }
[16:12:50.938]                         }
[16:12:50.938]                       }
[16:12:50.938]                       invisible(muffled)
[16:12:50.938]                     }
[16:12:50.938]                     muffleCondition(cond, pattern = "^muffle")
[16:12:50.938]                   }
[16:12:50.938]                 }
[16:12:50.938]             }
[16:12:50.938]         }))
[16:12:50.938]     }, error = function(ex) {
[16:12:50.938]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:50.938]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:50.938]                 ...future.rng), started = ...future.startTime, 
[16:12:50.938]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:50.938]             version = "1.8"), class = "FutureResult")
[16:12:50.938]     }, finally = {
[16:12:50.938]         if (!identical(...future.workdir, getwd())) 
[16:12:50.938]             setwd(...future.workdir)
[16:12:50.938]         {
[16:12:50.938]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:50.938]                 ...future.oldOptions$nwarnings <- NULL
[16:12:50.938]             }
[16:12:50.938]             base::options(...future.oldOptions)
[16:12:50.938]             if (.Platform$OS.type == "windows") {
[16:12:50.938]                 old_names <- names(...future.oldEnvVars)
[16:12:50.938]                 envs <- base::Sys.getenv()
[16:12:50.938]                 names <- names(envs)
[16:12:50.938]                 common <- intersect(names, old_names)
[16:12:50.938]                 added <- setdiff(names, old_names)
[16:12:50.938]                 removed <- setdiff(old_names, names)
[16:12:50.938]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:50.938]                   envs[common]]
[16:12:50.938]                 NAMES <- toupper(changed)
[16:12:50.938]                 args <- list()
[16:12:50.938]                 for (kk in seq_along(NAMES)) {
[16:12:50.938]                   name <- changed[[kk]]
[16:12:50.938]                   NAME <- NAMES[[kk]]
[16:12:50.938]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:50.938]                     next
[16:12:50.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:50.938]                 }
[16:12:50.938]                 NAMES <- toupper(added)
[16:12:50.938]                 for (kk in seq_along(NAMES)) {
[16:12:50.938]                   name <- added[[kk]]
[16:12:50.938]                   NAME <- NAMES[[kk]]
[16:12:50.938]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:50.938]                     next
[16:12:50.938]                   args[[name]] <- ""
[16:12:50.938]                 }
[16:12:50.938]                 NAMES <- toupper(removed)
[16:12:50.938]                 for (kk in seq_along(NAMES)) {
[16:12:50.938]                   name <- removed[[kk]]
[16:12:50.938]                   NAME <- NAMES[[kk]]
[16:12:50.938]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:50.938]                     next
[16:12:50.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:50.938]                 }
[16:12:50.938]                 if (length(args) > 0) 
[16:12:50.938]                   base::do.call(base::Sys.setenv, args = args)
[16:12:50.938]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:50.938]             }
[16:12:50.938]             else {
[16:12:50.938]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:50.938]             }
[16:12:50.938]             {
[16:12:50.938]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:50.938]                   0L) {
[16:12:50.938]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:50.938]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:50.938]                   base::options(opts)
[16:12:50.938]                 }
[16:12:50.938]                 {
[16:12:50.938]                   {
[16:12:50.938]                     NULL
[16:12:50.938]                     RNGkind("Mersenne-Twister")
[16:12:50.938]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:50.938]                       inherits = FALSE)
[16:12:50.938]                   }
[16:12:50.938]                   options(future.plan = NULL)
[16:12:50.938]                   if (is.na(NA_character_)) 
[16:12:50.938]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:50.938]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:50.938]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:50.938]                   {
[16:12:50.938]                     future <- SequentialFuture(..., envir = envir)
[16:12:50.938]                     if (!future$lazy) 
[16:12:50.938]                       future <- run(future)
[16:12:50.938]                     invisible(future)
[16:12:50.938]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:50.938]                 }
[16:12:50.938]             }
[16:12:50.938]         }
[16:12:50.938]     })
[16:12:50.938]     if (TRUE) {
[16:12:50.938]         base::sink(type = "output", split = FALSE)
[16:12:50.938]         if (TRUE) {
[16:12:50.938]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:50.938]         }
[16:12:50.938]         else {
[16:12:50.938]             ...future.result["stdout"] <- base::list(NULL)
[16:12:50.938]         }
[16:12:50.938]         base::close(...future.stdout)
[16:12:50.938]         ...future.stdout <- NULL
[16:12:50.938]     }
[16:12:50.938]     ...future.result$conditions <- ...future.conditions
[16:12:50.938]     ...future.result$finished <- base::Sys.time()
[16:12:50.938]     ...future.result
[16:12:50.938] }
[16:12:50.940] assign_globals() ...
[16:12:50.940] List of 1
[16:12:50.940]  $ ii: int 3
[16:12:50.940]  - attr(*, "where")=List of 1
[16:12:50.940]   ..$ ii:<environment: R_EmptyEnv> 
[16:12:50.940]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:50.940]  - attr(*, "resolved")= logi TRUE
[16:12:50.940]  - attr(*, "total_size")= num 56
[16:12:50.940]  - attr(*, "already-done")= logi TRUE
[16:12:50.942] - copied ‘ii’ to environment
[16:12:50.942] assign_globals() ... done
[16:12:50.943] plan(): Setting new future strategy stack:
[16:12:50.943] List of future strategies:
[16:12:50.943] 1. sequential:
[16:12:50.943]    - args: function (..., envir = parent.frame())
[16:12:50.943]    - tweaked: FALSE
[16:12:50.943]    - call: NULL
[16:12:50.943] plan(): nbrOfWorkers() = 1
[16:12:50.944] plan(): Setting new future strategy stack:
[16:12:50.944] List of future strategies:
[16:12:50.944] 1. sequential:
[16:12:50.944]    - args: function (..., envir = parent.frame())
[16:12:50.944]    - tweaked: FALSE
[16:12:50.944]    - call: plan(strategy)
[16:12:50.944] plan(): nbrOfWorkers() = 1
[16:12:50.944] SequentialFuture started (and completed)
[16:12:50.944] - Launch lazy future ... done
[16:12:50.945] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:50.946] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:50.946] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:50.947] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:50.947] Searching for globals ... DONE
[16:12:50.947] Resolving globals: TRUE
[16:12:50.947] Resolving any globals that are futures ...
[16:12:50.948] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:50.948] Resolving any globals that are futures ... DONE
[16:12:50.948] Resolving futures part of globals (recursively) ...
[16:12:50.948] resolve() on list ...
[16:12:50.948]  recursive: 99
[16:12:50.948]  length: 1
[16:12:50.949]  elements: ‘ii’
[16:12:50.949]  length: 0 (resolved future 1)
[16:12:50.949] resolve() on list ... DONE
[16:12:50.949] - globals: [1] ‘ii’
[16:12:50.949] Resolving futures part of globals (recursively) ... DONE
[16:12:50.951] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:50.951] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:12:50.951] - globals: [1] ‘ii’
[16:12:50.951] 
[16:12:50.951] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:50.952] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:50.952] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:50.953] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:50.954] Searching for globals ... DONE
[16:12:50.954] Resolving globals: TRUE
[16:12:50.954] Resolving any globals that are futures ...
[16:12:50.954] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:50.954] Resolving any globals that are futures ... DONE
[16:12:50.954] Resolving futures part of globals (recursively) ...
[16:12:50.955] resolve() on list ...
[16:12:50.955]  recursive: 99
[16:12:50.955]  length: 1
[16:12:50.955]  elements: ‘ii’
[16:12:50.955]  length: 0 (resolved future 1)
[16:12:50.955] resolve() on list ... DONE
[16:12:50.955] - globals: [1] ‘ii’
[16:12:50.955] Resolving futures part of globals (recursively) ... DONE
[16:12:50.955] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:50.956] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:12:50.956] - globals: [1] ‘ii’
[16:12:50.956] 
[16:12:50.956] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:50.957] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:50.957] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:50.958] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:50.958] Searching for globals ... DONE
[16:12:50.958] Resolving globals: TRUE
[16:12:50.958] Resolving any globals that are futures ...
[16:12:50.958] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:50.958] Resolving any globals that are futures ... DONE
[16:12:50.959] Resolving futures part of globals (recursively) ...
[16:12:50.959] resolve() on list ...
[16:12:50.959]  recursive: 99
[16:12:50.959]  length: 1
[16:12:50.959]  elements: ‘ii’
[16:12:50.959]  length: 0 (resolved future 1)
[16:12:50.959] resolve() on list ... DONE
[16:12:50.960] - globals: [1] ‘ii’
[16:12:50.960] Resolving futures part of globals (recursively) ... DONE
[16:12:50.960] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:50.960] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:12:50.960] - globals: [1] ‘ii’
[16:12:50.960] 
[16:12:50.960] getGlobalsAndPackages() ... DONE
[16:12:50.961] run() for ‘Future’ ...
[16:12:50.961] - state: ‘created’
[16:12:50.961] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:50.961] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:50.961] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:50.961]   - Field: ‘label’
[16:12:50.962]   - Field: ‘local’
[16:12:50.962]   - Field: ‘owner’
[16:12:50.962]   - Field: ‘envir’
[16:12:50.962]   - Field: ‘packages’
[16:12:50.962]   - Field: ‘gc’
[16:12:50.962]   - Field: ‘conditions’
[16:12:50.962]   - Field: ‘expr’
[16:12:50.962]   - Field: ‘uuid’
[16:12:50.962]   - Field: ‘seed’
[16:12:50.962]   - Field: ‘version’
[16:12:50.963]   - Field: ‘result’
[16:12:50.963]   - Field: ‘asynchronous’
[16:12:50.963]   - Field: ‘calls’
[16:12:50.963]   - Field: ‘globals’
[16:12:50.963]   - Field: ‘stdout’
[16:12:50.963]   - Field: ‘earlySignal’
[16:12:50.963]   - Field: ‘lazy’
[16:12:50.963]   - Field: ‘state’
[16:12:50.963] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:50.963] - Launch lazy future ...
[16:12:50.963] Packages needed by the future expression (n = 0): <none>
[16:12:50.964] Packages needed by future strategies (n = 0): <none>
[16:12:50.964] {
[16:12:50.964]     {
[16:12:50.964]         {
[16:12:50.964]             ...future.startTime <- base::Sys.time()
[16:12:50.964]             {
[16:12:50.964]                 {
[16:12:50.964]                   {
[16:12:50.964]                     base::local({
[16:12:50.964]                       has_future <- base::requireNamespace("future", 
[16:12:50.964]                         quietly = TRUE)
[16:12:50.964]                       if (has_future) {
[16:12:50.964]                         ns <- base::getNamespace("future")
[16:12:50.964]                         version <- ns[[".package"]][["version"]]
[16:12:50.964]                         if (is.null(version)) 
[16:12:50.964]                           version <- utils::packageVersion("future")
[16:12:50.964]                       }
[16:12:50.964]                       else {
[16:12:50.964]                         version <- NULL
[16:12:50.964]                       }
[16:12:50.964]                       if (!has_future || version < "1.8.0") {
[16:12:50.964]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:50.964]                           "", base::R.version$version.string), 
[16:12:50.964]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:50.964]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:50.964]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:50.964]                             "release", "version")], collapse = " "), 
[16:12:50.964]                           hostname = base::Sys.info()[["nodename"]])
[16:12:50.964]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:50.964]                           info)
[16:12:50.964]                         info <- base::paste(info, collapse = "; ")
[16:12:50.964]                         if (!has_future) {
[16:12:50.964]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:50.964]                             info)
[16:12:50.964]                         }
[16:12:50.964]                         else {
[16:12:50.964]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:50.964]                             info, version)
[16:12:50.964]                         }
[16:12:50.964]                         base::stop(msg)
[16:12:50.964]                       }
[16:12:50.964]                     })
[16:12:50.964]                   }
[16:12:50.964]                   options(future.plan = NULL)
[16:12:50.964]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:50.964]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:50.964]                 }
[16:12:50.964]                 ...future.workdir <- getwd()
[16:12:50.964]             }
[16:12:50.964]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:50.964]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:50.964]         }
[16:12:50.964]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:50.964]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:50.964]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:50.964]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:50.964]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:50.964]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:50.964]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:50.964]             base::names(...future.oldOptions))
[16:12:50.964]     }
[16:12:50.964]     if (FALSE) {
[16:12:50.964]     }
[16:12:50.964]     else {
[16:12:50.964]         if (TRUE) {
[16:12:50.964]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:50.964]                 open = "w")
[16:12:50.964]         }
[16:12:50.964]         else {
[16:12:50.964]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:50.964]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:50.964]         }
[16:12:50.964]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:50.964]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:50.964]             base::sink(type = "output", split = FALSE)
[16:12:50.964]             base::close(...future.stdout)
[16:12:50.964]         }, add = TRUE)
[16:12:50.964]     }
[16:12:50.964]     ...future.frame <- base::sys.nframe()
[16:12:50.964]     ...future.conditions <- base::list()
[16:12:50.964]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:50.964]     if (FALSE) {
[16:12:50.964]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:50.964]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:50.964]     }
[16:12:50.964]     ...future.result <- base::tryCatch({
[16:12:50.964]         base::withCallingHandlers({
[16:12:50.964]             ...future.value <- base::withVisible(base::local({
[16:12:50.964]                 b <- a * ii
[16:12:50.964]                 a <- 0
[16:12:50.964]                 b
[16:12:50.964]             }))
[16:12:50.964]             future::FutureResult(value = ...future.value$value, 
[16:12:50.964]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:50.964]                   ...future.rng), globalenv = if (FALSE) 
[16:12:50.964]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:50.964]                     ...future.globalenv.names))
[16:12:50.964]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:50.964]         }, condition = base::local({
[16:12:50.964]             c <- base::c
[16:12:50.964]             inherits <- base::inherits
[16:12:50.964]             invokeRestart <- base::invokeRestart
[16:12:50.964]             length <- base::length
[16:12:50.964]             list <- base::list
[16:12:50.964]             seq.int <- base::seq.int
[16:12:50.964]             signalCondition <- base::signalCondition
[16:12:50.964]             sys.calls <- base::sys.calls
[16:12:50.964]             `[[` <- base::`[[`
[16:12:50.964]             `+` <- base::`+`
[16:12:50.964]             `<<-` <- base::`<<-`
[16:12:50.964]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:50.964]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:50.964]                   3L)]
[16:12:50.964]             }
[16:12:50.964]             function(cond) {
[16:12:50.964]                 is_error <- inherits(cond, "error")
[16:12:50.964]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:50.964]                   NULL)
[16:12:50.964]                 if (is_error) {
[16:12:50.964]                   sessionInformation <- function() {
[16:12:50.964]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:50.964]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:50.964]                       search = base::search(), system = base::Sys.info())
[16:12:50.964]                   }
[16:12:50.964]                   ...future.conditions[[length(...future.conditions) + 
[16:12:50.964]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:50.964]                     cond$call), session = sessionInformation(), 
[16:12:50.964]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:50.964]                   signalCondition(cond)
[16:12:50.964]                 }
[16:12:50.964]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:50.964]                 "immediateCondition"))) {
[16:12:50.964]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:50.964]                   ...future.conditions[[length(...future.conditions) + 
[16:12:50.964]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:50.964]                   if (TRUE && !signal) {
[16:12:50.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:50.964]                     {
[16:12:50.964]                       inherits <- base::inherits
[16:12:50.964]                       invokeRestart <- base::invokeRestart
[16:12:50.964]                       is.null <- base::is.null
[16:12:50.964]                       muffled <- FALSE
[16:12:50.964]                       if (inherits(cond, "message")) {
[16:12:50.964]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:50.964]                         if (muffled) 
[16:12:50.964]                           invokeRestart("muffleMessage")
[16:12:50.964]                       }
[16:12:50.964]                       else if (inherits(cond, "warning")) {
[16:12:50.964]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:50.964]                         if (muffled) 
[16:12:50.964]                           invokeRestart("muffleWarning")
[16:12:50.964]                       }
[16:12:50.964]                       else if (inherits(cond, "condition")) {
[16:12:50.964]                         if (!is.null(pattern)) {
[16:12:50.964]                           computeRestarts <- base::computeRestarts
[16:12:50.964]                           grepl <- base::grepl
[16:12:50.964]                           restarts <- computeRestarts(cond)
[16:12:50.964]                           for (restart in restarts) {
[16:12:50.964]                             name <- restart$name
[16:12:50.964]                             if (is.null(name)) 
[16:12:50.964]                               next
[16:12:50.964]                             if (!grepl(pattern, name)) 
[16:12:50.964]                               next
[16:12:50.964]                             invokeRestart(restart)
[16:12:50.964]                             muffled <- TRUE
[16:12:50.964]                             break
[16:12:50.964]                           }
[16:12:50.964]                         }
[16:12:50.964]                       }
[16:12:50.964]                       invisible(muffled)
[16:12:50.964]                     }
[16:12:50.964]                     muffleCondition(cond, pattern = "^muffle")
[16:12:50.964]                   }
[16:12:50.964]                 }
[16:12:50.964]                 else {
[16:12:50.964]                   if (TRUE) {
[16:12:50.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:50.964]                     {
[16:12:50.964]                       inherits <- base::inherits
[16:12:50.964]                       invokeRestart <- base::invokeRestart
[16:12:50.964]                       is.null <- base::is.null
[16:12:50.964]                       muffled <- FALSE
[16:12:50.964]                       if (inherits(cond, "message")) {
[16:12:50.964]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:50.964]                         if (muffled) 
[16:12:50.964]                           invokeRestart("muffleMessage")
[16:12:50.964]                       }
[16:12:50.964]                       else if (inherits(cond, "warning")) {
[16:12:50.964]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:50.964]                         if (muffled) 
[16:12:50.964]                           invokeRestart("muffleWarning")
[16:12:50.964]                       }
[16:12:50.964]                       else if (inherits(cond, "condition")) {
[16:12:50.964]                         if (!is.null(pattern)) {
[16:12:50.964]                           computeRestarts <- base::computeRestarts
[16:12:50.964]                           grepl <- base::grepl
[16:12:50.964]                           restarts <- computeRestarts(cond)
[16:12:50.964]                           for (restart in restarts) {
[16:12:50.964]                             name <- restart$name
[16:12:50.964]                             if (is.null(name)) 
[16:12:50.964]                               next
[16:12:50.964]                             if (!grepl(pattern, name)) 
[16:12:50.964]                               next
[16:12:50.964]                             invokeRestart(restart)
[16:12:50.964]                             muffled <- TRUE
[16:12:50.964]                             break
[16:12:50.964]                           }
[16:12:50.964]                         }
[16:12:50.964]                       }
[16:12:50.964]                       invisible(muffled)
[16:12:50.964]                     }
[16:12:50.964]                     muffleCondition(cond, pattern = "^muffle")
[16:12:50.964]                   }
[16:12:50.964]                 }
[16:12:50.964]             }
[16:12:50.964]         }))
[16:12:50.964]     }, error = function(ex) {
[16:12:50.964]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:50.964]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:50.964]                 ...future.rng), started = ...future.startTime, 
[16:12:50.964]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:50.964]             version = "1.8"), class = "FutureResult")
[16:12:50.964]     }, finally = {
[16:12:50.964]         if (!identical(...future.workdir, getwd())) 
[16:12:50.964]             setwd(...future.workdir)
[16:12:50.964]         {
[16:12:50.964]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:50.964]                 ...future.oldOptions$nwarnings <- NULL
[16:12:50.964]             }
[16:12:50.964]             base::options(...future.oldOptions)
[16:12:50.964]             if (.Platform$OS.type == "windows") {
[16:12:50.964]                 old_names <- names(...future.oldEnvVars)
[16:12:50.964]                 envs <- base::Sys.getenv()
[16:12:50.964]                 names <- names(envs)
[16:12:50.964]                 common <- intersect(names, old_names)
[16:12:50.964]                 added <- setdiff(names, old_names)
[16:12:50.964]                 removed <- setdiff(old_names, names)
[16:12:50.964]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:50.964]                   envs[common]]
[16:12:50.964]                 NAMES <- toupper(changed)
[16:12:50.964]                 args <- list()
[16:12:50.964]                 for (kk in seq_along(NAMES)) {
[16:12:50.964]                   name <- changed[[kk]]
[16:12:50.964]                   NAME <- NAMES[[kk]]
[16:12:50.964]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:50.964]                     next
[16:12:50.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:50.964]                 }
[16:12:50.964]                 NAMES <- toupper(added)
[16:12:50.964]                 for (kk in seq_along(NAMES)) {
[16:12:50.964]                   name <- added[[kk]]
[16:12:50.964]                   NAME <- NAMES[[kk]]
[16:12:50.964]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:50.964]                     next
[16:12:50.964]                   args[[name]] <- ""
[16:12:50.964]                 }
[16:12:50.964]                 NAMES <- toupper(removed)
[16:12:50.964]                 for (kk in seq_along(NAMES)) {
[16:12:50.964]                   name <- removed[[kk]]
[16:12:50.964]                   NAME <- NAMES[[kk]]
[16:12:50.964]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:50.964]                     next
[16:12:50.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:50.964]                 }
[16:12:50.964]                 if (length(args) > 0) 
[16:12:50.964]                   base::do.call(base::Sys.setenv, args = args)
[16:12:50.964]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:50.964]             }
[16:12:50.964]             else {
[16:12:50.964]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:50.964]             }
[16:12:50.964]             {
[16:12:50.964]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:50.964]                   0L) {
[16:12:50.964]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:50.964]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:50.964]                   base::options(opts)
[16:12:50.964]                 }
[16:12:50.964]                 {
[16:12:50.964]                   {
[16:12:50.964]                     NULL
[16:12:50.964]                     RNGkind("Mersenne-Twister")
[16:12:50.964]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:50.964]                       inherits = FALSE)
[16:12:50.964]                   }
[16:12:50.964]                   options(future.plan = NULL)
[16:12:50.964]                   if (is.na(NA_character_)) 
[16:12:50.964]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:50.964]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:50.964]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:50.964]                   {
[16:12:50.964]                     future <- SequentialFuture(..., envir = envir)
[16:12:50.964]                     if (!future$lazy) 
[16:12:50.964]                       future <- run(future)
[16:12:50.964]                     invisible(future)
[16:12:50.964]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:50.964]                 }
[16:12:50.964]             }
[16:12:50.964]         }
[16:12:50.964]     })
[16:12:50.964]     if (TRUE) {
[16:12:50.964]         base::sink(type = "output", split = FALSE)
[16:12:50.964]         if (TRUE) {
[16:12:50.964]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:50.964]         }
[16:12:50.964]         else {
[16:12:50.964]             ...future.result["stdout"] <- base::list(NULL)
[16:12:50.964]         }
[16:12:50.964]         base::close(...future.stdout)
[16:12:50.964]         ...future.stdout <- NULL
[16:12:50.964]     }
[16:12:50.964]     ...future.result$conditions <- ...future.conditions
[16:12:50.964]     ...future.result$finished <- base::Sys.time()
[16:12:50.964]     ...future.result
[16:12:50.964] }
[16:12:50.966] assign_globals() ...
[16:12:50.966] List of 1
[16:12:50.966]  $ ii: int 1
[16:12:50.966]  - attr(*, "where")=List of 1
[16:12:50.966]   ..$ ii:<environment: R_EmptyEnv> 
[16:12:50.966]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:50.966]  - attr(*, "resolved")= logi TRUE
[16:12:50.966]  - attr(*, "total_size")= num 56
[16:12:50.966]  - attr(*, "already-done")= logi TRUE
[16:12:50.968] - copied ‘ii’ to environment
[16:12:50.968] assign_globals() ... done
[16:12:50.969] plan(): Setting new future strategy stack:
[16:12:50.969] List of future strategies:
[16:12:50.969] 1. sequential:
[16:12:50.969]    - args: function (..., envir = parent.frame())
[16:12:50.969]    - tweaked: FALSE
[16:12:50.969]    - call: NULL
[16:12:50.969] plan(): nbrOfWorkers() = 1
[16:12:50.970] plan(): Setting new future strategy stack:
[16:12:50.970] List of future strategies:
[16:12:50.970] 1. sequential:
[16:12:50.970]    - args: function (..., envir = parent.frame())
[16:12:50.970]    - tweaked: FALSE
[16:12:50.970]    - call: plan(strategy)
[16:12:50.970] plan(): nbrOfWorkers() = 1
[16:12:50.971] SequentialFuture started (and completed)
[16:12:50.971] signalConditions() ...
[16:12:50.971]  - include = ‘immediateCondition’
[16:12:50.971]  - exclude = 
[16:12:50.971]  - resignal = FALSE
[16:12:50.971]  - Number of conditions: 1
[16:12:50.971] signalConditions() ... done
[16:12:50.971] - Launch lazy future ... done
[16:12:50.971] run() for ‘SequentialFuture’ ... done
[16:12:50.971] signalConditions() ...
[16:12:50.971]  - include = ‘immediateCondition’
[16:12:50.972]  - exclude = 
[16:12:50.972]  - resignal = FALSE
[16:12:50.972]  - Number of conditions: 1
[16:12:50.972] signalConditions() ... done
[16:12:50.972] Future state: ‘finished’
[16:12:50.972] signalConditions() ...
[16:12:50.972]  - include = ‘condition’
[16:12:50.972]  - exclude = ‘immediateCondition’
[16:12:50.972]  - resignal = TRUE
[16:12:50.972]  - Number of conditions: 1
[16:12:50.973]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:12:50.973] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a * ii ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a * ii ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2729ef2608da" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:12:50"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:50.987] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:50.987] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:50.988] 
[16:12:50.988] Searching for globals ... DONE
[16:12:50.988] - globals: [0] <none>
[16:12:50.988] getGlobalsAndPackages() ... DONE
[16:12:50.988] run() for ‘Future’ ...
[16:12:50.989] - state: ‘created’
[16:12:50.989] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:50.989] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:50.989] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:50.989]   - Field: ‘label’
[16:12:50.989]   - Field: ‘local’
[16:12:50.989]   - Field: ‘owner’
[16:12:50.989]   - Field: ‘envir’
[16:12:50.990]   - Field: ‘packages’
[16:12:50.990]   - Field: ‘gc’
[16:12:50.990]   - Field: ‘conditions’
[16:12:50.990]   - Field: ‘expr’
[16:12:50.990]   - Field: ‘uuid’
[16:12:50.990]   - Field: ‘seed’
[16:12:50.990]   - Field: ‘version’
[16:12:50.990]   - Field: ‘result’
[16:12:50.990]   - Field: ‘asynchronous’
[16:12:50.990]   - Field: ‘calls’
[16:12:50.990]   - Field: ‘globals’
[16:12:50.991]   - Field: ‘stdout’
[16:12:50.991]   - Field: ‘earlySignal’
[16:12:50.991]   - Field: ‘lazy’
[16:12:50.991]   - Field: ‘state’
[16:12:50.991] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:50.991] - Launch lazy future ...
[16:12:50.991] Packages needed by the future expression (n = 0): <none>
[16:12:50.991] Packages needed by future strategies (n = 0): <none>
[16:12:50.992] {
[16:12:50.992]     {
[16:12:50.992]         {
[16:12:50.992]             ...future.startTime <- base::Sys.time()
[16:12:50.992]             {
[16:12:50.992]                 {
[16:12:50.992]                   {
[16:12:50.992]                     base::local({
[16:12:50.992]                       has_future <- base::requireNamespace("future", 
[16:12:50.992]                         quietly = TRUE)
[16:12:50.992]                       if (has_future) {
[16:12:50.992]                         ns <- base::getNamespace("future")
[16:12:50.992]                         version <- ns[[".package"]][["version"]]
[16:12:50.992]                         if (is.null(version)) 
[16:12:50.992]                           version <- utils::packageVersion("future")
[16:12:50.992]                       }
[16:12:50.992]                       else {
[16:12:50.992]                         version <- NULL
[16:12:50.992]                       }
[16:12:50.992]                       if (!has_future || version < "1.8.0") {
[16:12:50.992]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:50.992]                           "", base::R.version$version.string), 
[16:12:50.992]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:50.992]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:50.992]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:50.992]                             "release", "version")], collapse = " "), 
[16:12:50.992]                           hostname = base::Sys.info()[["nodename"]])
[16:12:50.992]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:50.992]                           info)
[16:12:50.992]                         info <- base::paste(info, collapse = "; ")
[16:12:50.992]                         if (!has_future) {
[16:12:50.992]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:50.992]                             info)
[16:12:50.992]                         }
[16:12:50.992]                         else {
[16:12:50.992]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:50.992]                             info, version)
[16:12:50.992]                         }
[16:12:50.992]                         base::stop(msg)
[16:12:50.992]                       }
[16:12:50.992]                     })
[16:12:50.992]                   }
[16:12:50.992]                   options(future.plan = NULL)
[16:12:50.992]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:50.992]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:50.992]                 }
[16:12:50.992]                 ...future.workdir <- getwd()
[16:12:50.992]             }
[16:12:50.992]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:50.992]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:50.992]         }
[16:12:50.992]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:50.992]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:50.992]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:50.992]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:50.992]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:50.992]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:50.992]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:50.992]             base::names(...future.oldOptions))
[16:12:50.992]     }
[16:12:50.992]     if (FALSE) {
[16:12:50.992]     }
[16:12:50.992]     else {
[16:12:50.992]         if (TRUE) {
[16:12:50.992]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:50.992]                 open = "w")
[16:12:50.992]         }
[16:12:50.992]         else {
[16:12:50.992]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:50.992]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:50.992]         }
[16:12:50.992]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:50.992]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:50.992]             base::sink(type = "output", split = FALSE)
[16:12:50.992]             base::close(...future.stdout)
[16:12:50.992]         }, add = TRUE)
[16:12:50.992]     }
[16:12:50.992]     ...future.frame <- base::sys.nframe()
[16:12:50.992]     ...future.conditions <- base::list()
[16:12:50.992]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:50.992]     if (FALSE) {
[16:12:50.992]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:50.992]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:50.992]     }
[16:12:50.992]     ...future.result <- base::tryCatch({
[16:12:50.992]         base::withCallingHandlers({
[16:12:50.992]             ...future.value <- base::withVisible(base::local(1))
[16:12:50.992]             future::FutureResult(value = ...future.value$value, 
[16:12:50.992]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:50.992]                   ...future.rng), globalenv = if (FALSE) 
[16:12:50.992]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:50.992]                     ...future.globalenv.names))
[16:12:50.992]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:50.992]         }, condition = base::local({
[16:12:50.992]             c <- base::c
[16:12:50.992]             inherits <- base::inherits
[16:12:50.992]             invokeRestart <- base::invokeRestart
[16:12:50.992]             length <- base::length
[16:12:50.992]             list <- base::list
[16:12:50.992]             seq.int <- base::seq.int
[16:12:50.992]             signalCondition <- base::signalCondition
[16:12:50.992]             sys.calls <- base::sys.calls
[16:12:50.992]             `[[` <- base::`[[`
[16:12:50.992]             `+` <- base::`+`
[16:12:50.992]             `<<-` <- base::`<<-`
[16:12:50.992]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:50.992]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:50.992]                   3L)]
[16:12:50.992]             }
[16:12:50.992]             function(cond) {
[16:12:50.992]                 is_error <- inherits(cond, "error")
[16:12:50.992]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:50.992]                   NULL)
[16:12:50.992]                 if (is_error) {
[16:12:50.992]                   sessionInformation <- function() {
[16:12:50.992]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:50.992]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:50.992]                       search = base::search(), system = base::Sys.info())
[16:12:50.992]                   }
[16:12:50.992]                   ...future.conditions[[length(...future.conditions) + 
[16:12:50.992]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:50.992]                     cond$call), session = sessionInformation(), 
[16:12:50.992]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:50.992]                   signalCondition(cond)
[16:12:50.992]                 }
[16:12:50.992]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:50.992]                 "immediateCondition"))) {
[16:12:50.992]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:50.992]                   ...future.conditions[[length(...future.conditions) + 
[16:12:50.992]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:50.992]                   if (TRUE && !signal) {
[16:12:50.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:50.992]                     {
[16:12:50.992]                       inherits <- base::inherits
[16:12:50.992]                       invokeRestart <- base::invokeRestart
[16:12:50.992]                       is.null <- base::is.null
[16:12:50.992]                       muffled <- FALSE
[16:12:50.992]                       if (inherits(cond, "message")) {
[16:12:50.992]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:50.992]                         if (muffled) 
[16:12:50.992]                           invokeRestart("muffleMessage")
[16:12:50.992]                       }
[16:12:50.992]                       else if (inherits(cond, "warning")) {
[16:12:50.992]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:50.992]                         if (muffled) 
[16:12:50.992]                           invokeRestart("muffleWarning")
[16:12:50.992]                       }
[16:12:50.992]                       else if (inherits(cond, "condition")) {
[16:12:50.992]                         if (!is.null(pattern)) {
[16:12:50.992]                           computeRestarts <- base::computeRestarts
[16:12:50.992]                           grepl <- base::grepl
[16:12:50.992]                           restarts <- computeRestarts(cond)
[16:12:50.992]                           for (restart in restarts) {
[16:12:50.992]                             name <- restart$name
[16:12:50.992]                             if (is.null(name)) 
[16:12:50.992]                               next
[16:12:50.992]                             if (!grepl(pattern, name)) 
[16:12:50.992]                               next
[16:12:50.992]                             invokeRestart(restart)
[16:12:50.992]                             muffled <- TRUE
[16:12:50.992]                             break
[16:12:50.992]                           }
[16:12:50.992]                         }
[16:12:50.992]                       }
[16:12:50.992]                       invisible(muffled)
[16:12:50.992]                     }
[16:12:50.992]                     muffleCondition(cond, pattern = "^muffle")
[16:12:50.992]                   }
[16:12:50.992]                 }
[16:12:50.992]                 else {
[16:12:50.992]                   if (TRUE) {
[16:12:50.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:50.992]                     {
[16:12:50.992]                       inherits <- base::inherits
[16:12:50.992]                       invokeRestart <- base::invokeRestart
[16:12:50.992]                       is.null <- base::is.null
[16:12:50.992]                       muffled <- FALSE
[16:12:50.992]                       if (inherits(cond, "message")) {
[16:12:50.992]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:50.992]                         if (muffled) 
[16:12:50.992]                           invokeRestart("muffleMessage")
[16:12:50.992]                       }
[16:12:50.992]                       else if (inherits(cond, "warning")) {
[16:12:50.992]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:50.992]                         if (muffled) 
[16:12:50.992]                           invokeRestart("muffleWarning")
[16:12:50.992]                       }
[16:12:50.992]                       else if (inherits(cond, "condition")) {
[16:12:50.992]                         if (!is.null(pattern)) {
[16:12:50.992]                           computeRestarts <- base::computeRestarts
[16:12:50.992]                           grepl <- base::grepl
[16:12:50.992]                           restarts <- computeRestarts(cond)
[16:12:50.992]                           for (restart in restarts) {
[16:12:50.992]                             name <- restart$name
[16:12:50.992]                             if (is.null(name)) 
[16:12:50.992]                               next
[16:12:50.992]                             if (!grepl(pattern, name)) 
[16:12:50.992]                               next
[16:12:50.992]                             invokeRestart(restart)
[16:12:50.992]                             muffled <- TRUE
[16:12:50.992]                             break
[16:12:50.992]                           }
[16:12:50.992]                         }
[16:12:50.992]                       }
[16:12:50.992]                       invisible(muffled)
[16:12:50.992]                     }
[16:12:50.992]                     muffleCondition(cond, pattern = "^muffle")
[16:12:50.992]                   }
[16:12:50.992]                 }
[16:12:50.992]             }
[16:12:50.992]         }))
[16:12:50.992]     }, error = function(ex) {
[16:12:50.992]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:50.992]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:50.992]                 ...future.rng), started = ...future.startTime, 
[16:12:50.992]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:50.992]             version = "1.8"), class = "FutureResult")
[16:12:50.992]     }, finally = {
[16:12:50.992]         if (!identical(...future.workdir, getwd())) 
[16:12:50.992]             setwd(...future.workdir)
[16:12:50.992]         {
[16:12:50.992]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:50.992]                 ...future.oldOptions$nwarnings <- NULL
[16:12:50.992]             }
[16:12:50.992]             base::options(...future.oldOptions)
[16:12:50.992]             if (.Platform$OS.type == "windows") {
[16:12:50.992]                 old_names <- names(...future.oldEnvVars)
[16:12:50.992]                 envs <- base::Sys.getenv()
[16:12:50.992]                 names <- names(envs)
[16:12:50.992]                 common <- intersect(names, old_names)
[16:12:50.992]                 added <- setdiff(names, old_names)
[16:12:50.992]                 removed <- setdiff(old_names, names)
[16:12:50.992]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:50.992]                   envs[common]]
[16:12:50.992]                 NAMES <- toupper(changed)
[16:12:50.992]                 args <- list()
[16:12:50.992]                 for (kk in seq_along(NAMES)) {
[16:12:50.992]                   name <- changed[[kk]]
[16:12:50.992]                   NAME <- NAMES[[kk]]
[16:12:50.992]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:50.992]                     next
[16:12:50.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:50.992]                 }
[16:12:50.992]                 NAMES <- toupper(added)
[16:12:50.992]                 for (kk in seq_along(NAMES)) {
[16:12:50.992]                   name <- added[[kk]]
[16:12:50.992]                   NAME <- NAMES[[kk]]
[16:12:50.992]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:50.992]                     next
[16:12:50.992]                   args[[name]] <- ""
[16:12:50.992]                 }
[16:12:50.992]                 NAMES <- toupper(removed)
[16:12:50.992]                 for (kk in seq_along(NAMES)) {
[16:12:50.992]                   name <- removed[[kk]]
[16:12:50.992]                   NAME <- NAMES[[kk]]
[16:12:50.992]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:50.992]                     next
[16:12:50.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:50.992]                 }
[16:12:50.992]                 if (length(args) > 0) 
[16:12:50.992]                   base::do.call(base::Sys.setenv, args = args)
[16:12:50.992]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:50.992]             }
[16:12:50.992]             else {
[16:12:50.992]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:50.992]             }
[16:12:50.992]             {
[16:12:50.992]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:50.992]                   0L) {
[16:12:50.992]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:50.992]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:50.992]                   base::options(opts)
[16:12:50.992]                 }
[16:12:50.992]                 {
[16:12:50.992]                   {
[16:12:50.992]                     NULL
[16:12:50.992]                     RNGkind("Mersenne-Twister")
[16:12:50.992]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:50.992]                       inherits = FALSE)
[16:12:50.992]                   }
[16:12:50.992]                   options(future.plan = NULL)
[16:12:50.992]                   if (is.na(NA_character_)) 
[16:12:50.992]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:50.992]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:50.992]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:50.992]                   {
[16:12:50.992]                     future <- SequentialFuture(..., envir = envir)
[16:12:50.992]                     if (!future$lazy) 
[16:12:50.992]                       future <- run(future)
[16:12:50.992]                     invisible(future)
[16:12:50.992]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:50.992]                 }
[16:12:50.992]             }
[16:12:50.992]         }
[16:12:50.992]     })
[16:12:50.992]     if (TRUE) {
[16:12:50.992]         base::sink(type = "output", split = FALSE)
[16:12:50.992]         if (TRUE) {
[16:12:50.992]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:50.992]         }
[16:12:50.992]         else {
[16:12:50.992]             ...future.result["stdout"] <- base::list(NULL)
[16:12:50.992]         }
[16:12:50.992]         base::close(...future.stdout)
[16:12:50.992]         ...future.stdout <- NULL
[16:12:50.992]     }
[16:12:50.992]     ...future.result$conditions <- ...future.conditions
[16:12:50.992]     ...future.result$finished <- base::Sys.time()
[16:12:50.992]     ...future.result
[16:12:50.992] }
[16:12:50.993] plan(): Setting new future strategy stack:
[16:12:50.994] List of future strategies:
[16:12:50.994] 1. sequential:
[16:12:50.994]    - args: function (..., envir = parent.frame())
[16:12:50.994]    - tweaked: FALSE
[16:12:50.994]    - call: NULL
[16:12:50.994] plan(): nbrOfWorkers() = 1
[16:12:50.995] plan(): Setting new future strategy stack:
[16:12:50.995] List of future strategies:
[16:12:50.995] 1. sequential:
[16:12:50.995]    - args: function (..., envir = parent.frame())
[16:12:50.995]    - tweaked: FALSE
[16:12:50.995]    - call: plan(strategy)
[16:12:50.995] plan(): nbrOfWorkers() = 1
[16:12:50.995] SequentialFuture started (and completed)
[16:12:50.995] - Launch lazy future ... done
[16:12:50.995] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:50.996] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:50.996] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:50.997] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:50.997] Searching for globals ... DONE
[16:12:50.997] Resolving globals: TRUE
[16:12:50.997] Resolving any globals that are futures ...
[16:12:50.997] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:50.997] Resolving any globals that are futures ... DONE
[16:12:50.997] Resolving futures part of globals (recursively) ...
[16:12:50.998] resolve() on list ...
[16:12:50.998]  recursive: 99
[16:12:50.998]  length: 1
[16:12:50.998]  elements: ‘a’
[16:12:50.998] resolved() for ‘SequentialFuture’ ...
[16:12:50.998] - state: ‘finished’
[16:12:50.998] - run: TRUE
[16:12:50.998] - result: ‘FutureResult’
[16:12:50.999] resolved() for ‘SequentialFuture’ ... done
[16:12:50.999] Future #1
[16:12:50.999] resolved() for ‘SequentialFuture’ ...
[16:12:50.999] - state: ‘finished’
[16:12:50.999] - run: TRUE
[16:12:50.999] - result: ‘FutureResult’
[16:12:50.999] resolved() for ‘SequentialFuture’ ... done
[16:12:50.999] A SequentialFuture was resolved
[16:12:51.000]  length: 0 (resolved future 1)
[16:12:51.000] resolve() on list ... DONE
[16:12:51.000] - globals: [1] ‘a’
[16:12:51.000] Resolving futures part of globals (recursively) ... DONE
[16:12:51.001] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[16:12:51.002] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[16:12:51.002] - globals: [1] ‘a’
[16:12:51.002] - packages: [1] ‘future’
[16:12:51.003] getGlobalsAndPackages() ... DONE
[16:12:51.003] run() for ‘Future’ ...
[16:12:51.003] - state: ‘created’
[16:12:51.003] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.003] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.003] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.003]   - Field: ‘label’
[16:12:51.004]   - Field: ‘local’
[16:12:51.004]   - Field: ‘owner’
[16:12:51.004]   - Field: ‘envir’
[16:12:51.004]   - Field: ‘packages’
[16:12:51.004]   - Field: ‘gc’
[16:12:51.004]   - Field: ‘conditions’
[16:12:51.004]   - Field: ‘expr’
[16:12:51.004]   - Field: ‘uuid’
[16:12:51.004]   - Field: ‘seed’
[16:12:51.004]   - Field: ‘version’
[16:12:51.005]   - Field: ‘result’
[16:12:51.005]   - Field: ‘asynchronous’
[16:12:51.005]   - Field: ‘calls’
[16:12:51.005]   - Field: ‘globals’
[16:12:51.005]   - Field: ‘stdout’
[16:12:51.005]   - Field: ‘earlySignal’
[16:12:51.005]   - Field: ‘lazy’
[16:12:51.005]   - Field: ‘state’
[16:12:51.005] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.005] - Launch lazy future ...
[16:12:51.006] Packages needed by the future expression (n = 1): ‘future’
[16:12:51.006] Packages needed by future strategies (n = 0): <none>
[16:12:51.006] {
[16:12:51.006]     {
[16:12:51.006]         {
[16:12:51.006]             ...future.startTime <- base::Sys.time()
[16:12:51.006]             {
[16:12:51.006]                 {
[16:12:51.006]                   {
[16:12:51.006]                     {
[16:12:51.006]                       base::local({
[16:12:51.006]                         has_future <- base::requireNamespace("future", 
[16:12:51.006]                           quietly = TRUE)
[16:12:51.006]                         if (has_future) {
[16:12:51.006]                           ns <- base::getNamespace("future")
[16:12:51.006]                           version <- ns[[".package"]][["version"]]
[16:12:51.006]                           if (is.null(version)) 
[16:12:51.006]                             version <- utils::packageVersion("future")
[16:12:51.006]                         }
[16:12:51.006]                         else {
[16:12:51.006]                           version <- NULL
[16:12:51.006]                         }
[16:12:51.006]                         if (!has_future || version < "1.8.0") {
[16:12:51.006]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.006]                             "", base::R.version$version.string), 
[16:12:51.006]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:51.006]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.006]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.006]                               "release", "version")], collapse = " "), 
[16:12:51.006]                             hostname = base::Sys.info()[["nodename"]])
[16:12:51.006]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.006]                             info)
[16:12:51.006]                           info <- base::paste(info, collapse = "; ")
[16:12:51.006]                           if (!has_future) {
[16:12:51.006]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.006]                               info)
[16:12:51.006]                           }
[16:12:51.006]                           else {
[16:12:51.006]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.006]                               info, version)
[16:12:51.006]                           }
[16:12:51.006]                           base::stop(msg)
[16:12:51.006]                         }
[16:12:51.006]                       })
[16:12:51.006]                     }
[16:12:51.006]                     base::local({
[16:12:51.006]                       for (pkg in "future") {
[16:12:51.006]                         base::loadNamespace(pkg)
[16:12:51.006]                         base::library(pkg, character.only = TRUE)
[16:12:51.006]                       }
[16:12:51.006]                     })
[16:12:51.006]                   }
[16:12:51.006]                   options(future.plan = NULL)
[16:12:51.006]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.006]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.006]                 }
[16:12:51.006]                 ...future.workdir <- getwd()
[16:12:51.006]             }
[16:12:51.006]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.006]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.006]         }
[16:12:51.006]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.006]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:51.006]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.006]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.006]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.006]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.006]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.006]             base::names(...future.oldOptions))
[16:12:51.006]     }
[16:12:51.006]     if (FALSE) {
[16:12:51.006]     }
[16:12:51.006]     else {
[16:12:51.006]         if (TRUE) {
[16:12:51.006]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.006]                 open = "w")
[16:12:51.006]         }
[16:12:51.006]         else {
[16:12:51.006]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.006]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.006]         }
[16:12:51.006]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.006]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.006]             base::sink(type = "output", split = FALSE)
[16:12:51.006]             base::close(...future.stdout)
[16:12:51.006]         }, add = TRUE)
[16:12:51.006]     }
[16:12:51.006]     ...future.frame <- base::sys.nframe()
[16:12:51.006]     ...future.conditions <- base::list()
[16:12:51.006]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.006]     if (FALSE) {
[16:12:51.006]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.006]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.006]     }
[16:12:51.006]     ...future.result <- base::tryCatch({
[16:12:51.006]         base::withCallingHandlers({
[16:12:51.006]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:12:51.006]                 1))
[16:12:51.006]             future::FutureResult(value = ...future.value$value, 
[16:12:51.006]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.006]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.006]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.006]                     ...future.globalenv.names))
[16:12:51.006]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.006]         }, condition = base::local({
[16:12:51.006]             c <- base::c
[16:12:51.006]             inherits <- base::inherits
[16:12:51.006]             invokeRestart <- base::invokeRestart
[16:12:51.006]             length <- base::length
[16:12:51.006]             list <- base::list
[16:12:51.006]             seq.int <- base::seq.int
[16:12:51.006]             signalCondition <- base::signalCondition
[16:12:51.006]             sys.calls <- base::sys.calls
[16:12:51.006]             `[[` <- base::`[[`
[16:12:51.006]             `+` <- base::`+`
[16:12:51.006]             `<<-` <- base::`<<-`
[16:12:51.006]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.006]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.006]                   3L)]
[16:12:51.006]             }
[16:12:51.006]             function(cond) {
[16:12:51.006]                 is_error <- inherits(cond, "error")
[16:12:51.006]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.006]                   NULL)
[16:12:51.006]                 if (is_error) {
[16:12:51.006]                   sessionInformation <- function() {
[16:12:51.006]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.006]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.006]                       search = base::search(), system = base::Sys.info())
[16:12:51.006]                   }
[16:12:51.006]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.006]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.006]                     cond$call), session = sessionInformation(), 
[16:12:51.006]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.006]                   signalCondition(cond)
[16:12:51.006]                 }
[16:12:51.006]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.006]                 "immediateCondition"))) {
[16:12:51.006]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.006]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.006]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.006]                   if (TRUE && !signal) {
[16:12:51.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.006]                     {
[16:12:51.006]                       inherits <- base::inherits
[16:12:51.006]                       invokeRestart <- base::invokeRestart
[16:12:51.006]                       is.null <- base::is.null
[16:12:51.006]                       muffled <- FALSE
[16:12:51.006]                       if (inherits(cond, "message")) {
[16:12:51.006]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.006]                         if (muffled) 
[16:12:51.006]                           invokeRestart("muffleMessage")
[16:12:51.006]                       }
[16:12:51.006]                       else if (inherits(cond, "warning")) {
[16:12:51.006]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.006]                         if (muffled) 
[16:12:51.006]                           invokeRestart("muffleWarning")
[16:12:51.006]                       }
[16:12:51.006]                       else if (inherits(cond, "condition")) {
[16:12:51.006]                         if (!is.null(pattern)) {
[16:12:51.006]                           computeRestarts <- base::computeRestarts
[16:12:51.006]                           grepl <- base::grepl
[16:12:51.006]                           restarts <- computeRestarts(cond)
[16:12:51.006]                           for (restart in restarts) {
[16:12:51.006]                             name <- restart$name
[16:12:51.006]                             if (is.null(name)) 
[16:12:51.006]                               next
[16:12:51.006]                             if (!grepl(pattern, name)) 
[16:12:51.006]                               next
[16:12:51.006]                             invokeRestart(restart)
[16:12:51.006]                             muffled <- TRUE
[16:12:51.006]                             break
[16:12:51.006]                           }
[16:12:51.006]                         }
[16:12:51.006]                       }
[16:12:51.006]                       invisible(muffled)
[16:12:51.006]                     }
[16:12:51.006]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.006]                   }
[16:12:51.006]                 }
[16:12:51.006]                 else {
[16:12:51.006]                   if (TRUE) {
[16:12:51.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.006]                     {
[16:12:51.006]                       inherits <- base::inherits
[16:12:51.006]                       invokeRestart <- base::invokeRestart
[16:12:51.006]                       is.null <- base::is.null
[16:12:51.006]                       muffled <- FALSE
[16:12:51.006]                       if (inherits(cond, "message")) {
[16:12:51.006]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.006]                         if (muffled) 
[16:12:51.006]                           invokeRestart("muffleMessage")
[16:12:51.006]                       }
[16:12:51.006]                       else if (inherits(cond, "warning")) {
[16:12:51.006]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.006]                         if (muffled) 
[16:12:51.006]                           invokeRestart("muffleWarning")
[16:12:51.006]                       }
[16:12:51.006]                       else if (inherits(cond, "condition")) {
[16:12:51.006]                         if (!is.null(pattern)) {
[16:12:51.006]                           computeRestarts <- base::computeRestarts
[16:12:51.006]                           grepl <- base::grepl
[16:12:51.006]                           restarts <- computeRestarts(cond)
[16:12:51.006]                           for (restart in restarts) {
[16:12:51.006]                             name <- restart$name
[16:12:51.006]                             if (is.null(name)) 
[16:12:51.006]                               next
[16:12:51.006]                             if (!grepl(pattern, name)) 
[16:12:51.006]                               next
[16:12:51.006]                             invokeRestart(restart)
[16:12:51.006]                             muffled <- TRUE
[16:12:51.006]                             break
[16:12:51.006]                           }
[16:12:51.006]                         }
[16:12:51.006]                       }
[16:12:51.006]                       invisible(muffled)
[16:12:51.006]                     }
[16:12:51.006]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.006]                   }
[16:12:51.006]                 }
[16:12:51.006]             }
[16:12:51.006]         }))
[16:12:51.006]     }, error = function(ex) {
[16:12:51.006]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.006]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.006]                 ...future.rng), started = ...future.startTime, 
[16:12:51.006]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.006]             version = "1.8"), class = "FutureResult")
[16:12:51.006]     }, finally = {
[16:12:51.006]         if (!identical(...future.workdir, getwd())) 
[16:12:51.006]             setwd(...future.workdir)
[16:12:51.006]         {
[16:12:51.006]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.006]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.006]             }
[16:12:51.006]             base::options(...future.oldOptions)
[16:12:51.006]             if (.Platform$OS.type == "windows") {
[16:12:51.006]                 old_names <- names(...future.oldEnvVars)
[16:12:51.006]                 envs <- base::Sys.getenv()
[16:12:51.006]                 names <- names(envs)
[16:12:51.006]                 common <- intersect(names, old_names)
[16:12:51.006]                 added <- setdiff(names, old_names)
[16:12:51.006]                 removed <- setdiff(old_names, names)
[16:12:51.006]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.006]                   envs[common]]
[16:12:51.006]                 NAMES <- toupper(changed)
[16:12:51.006]                 args <- list()
[16:12:51.006]                 for (kk in seq_along(NAMES)) {
[16:12:51.006]                   name <- changed[[kk]]
[16:12:51.006]                   NAME <- NAMES[[kk]]
[16:12:51.006]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.006]                     next
[16:12:51.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.006]                 }
[16:12:51.006]                 NAMES <- toupper(added)
[16:12:51.006]                 for (kk in seq_along(NAMES)) {
[16:12:51.006]                   name <- added[[kk]]
[16:12:51.006]                   NAME <- NAMES[[kk]]
[16:12:51.006]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.006]                     next
[16:12:51.006]                   args[[name]] <- ""
[16:12:51.006]                 }
[16:12:51.006]                 NAMES <- toupper(removed)
[16:12:51.006]                 for (kk in seq_along(NAMES)) {
[16:12:51.006]                   name <- removed[[kk]]
[16:12:51.006]                   NAME <- NAMES[[kk]]
[16:12:51.006]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.006]                     next
[16:12:51.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.006]                 }
[16:12:51.006]                 if (length(args) > 0) 
[16:12:51.006]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.006]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.006]             }
[16:12:51.006]             else {
[16:12:51.006]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.006]             }
[16:12:51.006]             {
[16:12:51.006]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.006]                   0L) {
[16:12:51.006]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.006]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.006]                   base::options(opts)
[16:12:51.006]                 }
[16:12:51.006]                 {
[16:12:51.006]                   {
[16:12:51.006]                     NULL
[16:12:51.006]                     RNGkind("Mersenne-Twister")
[16:12:51.006]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.006]                       inherits = FALSE)
[16:12:51.006]                   }
[16:12:51.006]                   options(future.plan = NULL)
[16:12:51.006]                   if (is.na(NA_character_)) 
[16:12:51.006]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.006]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.006]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.006]                   {
[16:12:51.006]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.006]                     if (!future$lazy) 
[16:12:51.006]                       future <- run(future)
[16:12:51.006]                     invisible(future)
[16:12:51.006]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.006]                 }
[16:12:51.006]             }
[16:12:51.006]         }
[16:12:51.006]     })
[16:12:51.006]     if (TRUE) {
[16:12:51.006]         base::sink(type = "output", split = FALSE)
[16:12:51.006]         if (TRUE) {
[16:12:51.006]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.006]         }
[16:12:51.006]         else {
[16:12:51.006]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.006]         }
[16:12:51.006]         base::close(...future.stdout)
[16:12:51.006]         ...future.stdout <- NULL
[16:12:51.006]     }
[16:12:51.006]     ...future.result$conditions <- ...future.conditions
[16:12:51.006]     ...future.result$finished <- base::Sys.time()
[16:12:51.006]     ...future.result
[16:12:51.006] }
[16:12:51.008] assign_globals() ...
[16:12:51.008] List of 1
[16:12:51.008]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x56233d3d10d0> 
[16:12:51.008]  - attr(*, "where")=List of 1
[16:12:51.008]   ..$ a:<environment: R_EmptyEnv> 
[16:12:51.008]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.008]  - attr(*, "resolved")= logi TRUE
[16:12:51.008]  - attr(*, "total_size")= num 10424
[16:12:51.008]  - attr(*, "already-done")= logi TRUE
[16:12:51.010] - copied ‘a’ to environment
[16:12:51.010] assign_globals() ... done
[16:12:51.011] plan(): Setting new future strategy stack:
[16:12:51.011] List of future strategies:
[16:12:51.011] 1. sequential:
[16:12:51.011]    - args: function (..., envir = parent.frame())
[16:12:51.011]    - tweaked: FALSE
[16:12:51.011]    - call: NULL
[16:12:51.011] plan(): nbrOfWorkers() = 1
[16:12:51.012] plan(): Setting new future strategy stack:
[16:12:51.012] List of future strategies:
[16:12:51.012] 1. sequential:
[16:12:51.012]    - args: function (..., envir = parent.frame())
[16:12:51.012]    - tweaked: FALSE
[16:12:51.012]    - call: plan(strategy)
[16:12:51.012] plan(): nbrOfWorkers() = 1
[16:12:51.012] SequentialFuture started (and completed)
[16:12:51.013] - Launch lazy future ... done
[16:12:51.013] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.013] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.013] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.014] 
[16:12:51.014] Searching for globals ... DONE
[16:12:51.014] - globals: [0] <none>
[16:12:51.014] getGlobalsAndPackages() ... DONE
[16:12:51.014] run() for ‘Future’ ...
[16:12:51.014] - state: ‘created’
[16:12:51.014] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.015] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.015] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.015]   - Field: ‘label’
[16:12:51.015]   - Field: ‘local’
[16:12:51.015]   - Field: ‘owner’
[16:12:51.015]   - Field: ‘envir’
[16:12:51.015]   - Field: ‘packages’
[16:12:51.015]   - Field: ‘gc’
[16:12:51.015]   - Field: ‘conditions’
[16:12:51.015]   - Field: ‘expr’
[16:12:51.016]   - Field: ‘uuid’
[16:12:51.016]   - Field: ‘seed’
[16:12:51.016]   - Field: ‘version’
[16:12:51.016]   - Field: ‘result’
[16:12:51.016]   - Field: ‘asynchronous’
[16:12:51.016]   - Field: ‘calls’
[16:12:51.016]   - Field: ‘globals’
[16:12:51.016]   - Field: ‘stdout’
[16:12:51.016]   - Field: ‘earlySignal’
[16:12:51.016]   - Field: ‘lazy’
[16:12:51.017]   - Field: ‘state’
[16:12:51.017] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.017] - Launch lazy future ...
[16:12:51.017] Packages needed by the future expression (n = 0): <none>
[16:12:51.017] Packages needed by future strategies (n = 0): <none>
[16:12:51.017] {
[16:12:51.017]     {
[16:12:51.017]         {
[16:12:51.017]             ...future.startTime <- base::Sys.time()
[16:12:51.017]             {
[16:12:51.017]                 {
[16:12:51.017]                   {
[16:12:51.017]                     base::local({
[16:12:51.017]                       has_future <- base::requireNamespace("future", 
[16:12:51.017]                         quietly = TRUE)
[16:12:51.017]                       if (has_future) {
[16:12:51.017]                         ns <- base::getNamespace("future")
[16:12:51.017]                         version <- ns[[".package"]][["version"]]
[16:12:51.017]                         if (is.null(version)) 
[16:12:51.017]                           version <- utils::packageVersion("future")
[16:12:51.017]                       }
[16:12:51.017]                       else {
[16:12:51.017]                         version <- NULL
[16:12:51.017]                       }
[16:12:51.017]                       if (!has_future || version < "1.8.0") {
[16:12:51.017]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.017]                           "", base::R.version$version.string), 
[16:12:51.017]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:51.017]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.017]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.017]                             "release", "version")], collapse = " "), 
[16:12:51.017]                           hostname = base::Sys.info()[["nodename"]])
[16:12:51.017]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.017]                           info)
[16:12:51.017]                         info <- base::paste(info, collapse = "; ")
[16:12:51.017]                         if (!has_future) {
[16:12:51.017]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.017]                             info)
[16:12:51.017]                         }
[16:12:51.017]                         else {
[16:12:51.017]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.017]                             info, version)
[16:12:51.017]                         }
[16:12:51.017]                         base::stop(msg)
[16:12:51.017]                       }
[16:12:51.017]                     })
[16:12:51.017]                   }
[16:12:51.017]                   options(future.plan = NULL)
[16:12:51.017]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.017]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.017]                 }
[16:12:51.017]                 ...future.workdir <- getwd()
[16:12:51.017]             }
[16:12:51.017]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.017]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.017]         }
[16:12:51.017]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.017]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:51.017]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.017]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.017]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.017]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.017]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.017]             base::names(...future.oldOptions))
[16:12:51.017]     }
[16:12:51.017]     if (FALSE) {
[16:12:51.017]     }
[16:12:51.017]     else {
[16:12:51.017]         if (TRUE) {
[16:12:51.017]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.017]                 open = "w")
[16:12:51.017]         }
[16:12:51.017]         else {
[16:12:51.017]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.017]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.017]         }
[16:12:51.017]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.017]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.017]             base::sink(type = "output", split = FALSE)
[16:12:51.017]             base::close(...future.stdout)
[16:12:51.017]         }, add = TRUE)
[16:12:51.017]     }
[16:12:51.017]     ...future.frame <- base::sys.nframe()
[16:12:51.017]     ...future.conditions <- base::list()
[16:12:51.017]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.017]     if (FALSE) {
[16:12:51.017]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.017]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.017]     }
[16:12:51.017]     ...future.result <- base::tryCatch({
[16:12:51.017]         base::withCallingHandlers({
[16:12:51.017]             ...future.value <- base::withVisible(base::local(1))
[16:12:51.017]             future::FutureResult(value = ...future.value$value, 
[16:12:51.017]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.017]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.017]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.017]                     ...future.globalenv.names))
[16:12:51.017]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.017]         }, condition = base::local({
[16:12:51.017]             c <- base::c
[16:12:51.017]             inherits <- base::inherits
[16:12:51.017]             invokeRestart <- base::invokeRestart
[16:12:51.017]             length <- base::length
[16:12:51.017]             list <- base::list
[16:12:51.017]             seq.int <- base::seq.int
[16:12:51.017]             signalCondition <- base::signalCondition
[16:12:51.017]             sys.calls <- base::sys.calls
[16:12:51.017]             `[[` <- base::`[[`
[16:12:51.017]             `+` <- base::`+`
[16:12:51.017]             `<<-` <- base::`<<-`
[16:12:51.017]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.017]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.017]                   3L)]
[16:12:51.017]             }
[16:12:51.017]             function(cond) {
[16:12:51.017]                 is_error <- inherits(cond, "error")
[16:12:51.017]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.017]                   NULL)
[16:12:51.017]                 if (is_error) {
[16:12:51.017]                   sessionInformation <- function() {
[16:12:51.017]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.017]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.017]                       search = base::search(), system = base::Sys.info())
[16:12:51.017]                   }
[16:12:51.017]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.017]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.017]                     cond$call), session = sessionInformation(), 
[16:12:51.017]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.017]                   signalCondition(cond)
[16:12:51.017]                 }
[16:12:51.017]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.017]                 "immediateCondition"))) {
[16:12:51.017]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.017]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.017]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.017]                   if (TRUE && !signal) {
[16:12:51.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.017]                     {
[16:12:51.017]                       inherits <- base::inherits
[16:12:51.017]                       invokeRestart <- base::invokeRestart
[16:12:51.017]                       is.null <- base::is.null
[16:12:51.017]                       muffled <- FALSE
[16:12:51.017]                       if (inherits(cond, "message")) {
[16:12:51.017]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.017]                         if (muffled) 
[16:12:51.017]                           invokeRestart("muffleMessage")
[16:12:51.017]                       }
[16:12:51.017]                       else if (inherits(cond, "warning")) {
[16:12:51.017]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.017]                         if (muffled) 
[16:12:51.017]                           invokeRestart("muffleWarning")
[16:12:51.017]                       }
[16:12:51.017]                       else if (inherits(cond, "condition")) {
[16:12:51.017]                         if (!is.null(pattern)) {
[16:12:51.017]                           computeRestarts <- base::computeRestarts
[16:12:51.017]                           grepl <- base::grepl
[16:12:51.017]                           restarts <- computeRestarts(cond)
[16:12:51.017]                           for (restart in restarts) {
[16:12:51.017]                             name <- restart$name
[16:12:51.017]                             if (is.null(name)) 
[16:12:51.017]                               next
[16:12:51.017]                             if (!grepl(pattern, name)) 
[16:12:51.017]                               next
[16:12:51.017]                             invokeRestart(restart)
[16:12:51.017]                             muffled <- TRUE
[16:12:51.017]                             break
[16:12:51.017]                           }
[16:12:51.017]                         }
[16:12:51.017]                       }
[16:12:51.017]                       invisible(muffled)
[16:12:51.017]                     }
[16:12:51.017]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.017]                   }
[16:12:51.017]                 }
[16:12:51.017]                 else {
[16:12:51.017]                   if (TRUE) {
[16:12:51.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.017]                     {
[16:12:51.017]                       inherits <- base::inherits
[16:12:51.017]                       invokeRestart <- base::invokeRestart
[16:12:51.017]                       is.null <- base::is.null
[16:12:51.017]                       muffled <- FALSE
[16:12:51.017]                       if (inherits(cond, "message")) {
[16:12:51.017]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.017]                         if (muffled) 
[16:12:51.017]                           invokeRestart("muffleMessage")
[16:12:51.017]                       }
[16:12:51.017]                       else if (inherits(cond, "warning")) {
[16:12:51.017]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.017]                         if (muffled) 
[16:12:51.017]                           invokeRestart("muffleWarning")
[16:12:51.017]                       }
[16:12:51.017]                       else if (inherits(cond, "condition")) {
[16:12:51.017]                         if (!is.null(pattern)) {
[16:12:51.017]                           computeRestarts <- base::computeRestarts
[16:12:51.017]                           grepl <- base::grepl
[16:12:51.017]                           restarts <- computeRestarts(cond)
[16:12:51.017]                           for (restart in restarts) {
[16:12:51.017]                             name <- restart$name
[16:12:51.017]                             if (is.null(name)) 
[16:12:51.017]                               next
[16:12:51.017]                             if (!grepl(pattern, name)) 
[16:12:51.017]                               next
[16:12:51.017]                             invokeRestart(restart)
[16:12:51.017]                             muffled <- TRUE
[16:12:51.017]                             break
[16:12:51.017]                           }
[16:12:51.017]                         }
[16:12:51.017]                       }
[16:12:51.017]                       invisible(muffled)
[16:12:51.017]                     }
[16:12:51.017]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.017]                   }
[16:12:51.017]                 }
[16:12:51.017]             }
[16:12:51.017]         }))
[16:12:51.017]     }, error = function(ex) {
[16:12:51.017]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.017]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.017]                 ...future.rng), started = ...future.startTime, 
[16:12:51.017]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.017]             version = "1.8"), class = "FutureResult")
[16:12:51.017]     }, finally = {
[16:12:51.017]         if (!identical(...future.workdir, getwd())) 
[16:12:51.017]             setwd(...future.workdir)
[16:12:51.017]         {
[16:12:51.017]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.017]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.017]             }
[16:12:51.017]             base::options(...future.oldOptions)
[16:12:51.017]             if (.Platform$OS.type == "windows") {
[16:12:51.017]                 old_names <- names(...future.oldEnvVars)
[16:12:51.017]                 envs <- base::Sys.getenv()
[16:12:51.017]                 names <- names(envs)
[16:12:51.017]                 common <- intersect(names, old_names)
[16:12:51.017]                 added <- setdiff(names, old_names)
[16:12:51.017]                 removed <- setdiff(old_names, names)
[16:12:51.017]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.017]                   envs[common]]
[16:12:51.017]                 NAMES <- toupper(changed)
[16:12:51.017]                 args <- list()
[16:12:51.017]                 for (kk in seq_along(NAMES)) {
[16:12:51.017]                   name <- changed[[kk]]
[16:12:51.017]                   NAME <- NAMES[[kk]]
[16:12:51.017]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.017]                     next
[16:12:51.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.017]                 }
[16:12:51.017]                 NAMES <- toupper(added)
[16:12:51.017]                 for (kk in seq_along(NAMES)) {
[16:12:51.017]                   name <- added[[kk]]
[16:12:51.017]                   NAME <- NAMES[[kk]]
[16:12:51.017]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.017]                     next
[16:12:51.017]                   args[[name]] <- ""
[16:12:51.017]                 }
[16:12:51.017]                 NAMES <- toupper(removed)
[16:12:51.017]                 for (kk in seq_along(NAMES)) {
[16:12:51.017]                   name <- removed[[kk]]
[16:12:51.017]                   NAME <- NAMES[[kk]]
[16:12:51.017]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.017]                     next
[16:12:51.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.017]                 }
[16:12:51.017]                 if (length(args) > 0) 
[16:12:51.017]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.017]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.017]             }
[16:12:51.017]             else {
[16:12:51.017]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.017]             }
[16:12:51.017]             {
[16:12:51.017]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.017]                   0L) {
[16:12:51.017]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.017]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.017]                   base::options(opts)
[16:12:51.017]                 }
[16:12:51.017]                 {
[16:12:51.017]                   {
[16:12:51.017]                     NULL
[16:12:51.017]                     RNGkind("Mersenne-Twister")
[16:12:51.017]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.017]                       inherits = FALSE)
[16:12:51.017]                   }
[16:12:51.017]                   options(future.plan = NULL)
[16:12:51.017]                   if (is.na(NA_character_)) 
[16:12:51.017]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.017]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.017]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.017]                   {
[16:12:51.017]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.017]                     if (!future$lazy) 
[16:12:51.017]                       future <- run(future)
[16:12:51.017]                     invisible(future)
[16:12:51.017]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.017]                 }
[16:12:51.017]             }
[16:12:51.017]         }
[16:12:51.017]     })
[16:12:51.017]     if (TRUE) {
[16:12:51.017]         base::sink(type = "output", split = FALSE)
[16:12:51.017]         if (TRUE) {
[16:12:51.017]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.017]         }
[16:12:51.017]         else {
[16:12:51.017]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.017]         }
[16:12:51.017]         base::close(...future.stdout)
[16:12:51.017]         ...future.stdout <- NULL
[16:12:51.017]     }
[16:12:51.017]     ...future.result$conditions <- ...future.conditions
[16:12:51.017]     ...future.result$finished <- base::Sys.time()
[16:12:51.017]     ...future.result
[16:12:51.017] }
[16:12:51.019] plan(): Setting new future strategy stack:
[16:12:51.019] List of future strategies:
[16:12:51.019] 1. sequential:
[16:12:51.019]    - args: function (..., envir = parent.frame())
[16:12:51.019]    - tweaked: FALSE
[16:12:51.019]    - call: NULL
[16:12:51.019] plan(): nbrOfWorkers() = 1
[16:12:51.021] plan(): Setting new future strategy stack:
[16:12:51.021] List of future strategies:
[16:12:51.021] 1. sequential:
[16:12:51.021]    - args: function (..., envir = parent.frame())
[16:12:51.021]    - tweaked: FALSE
[16:12:51.021]    - call: plan(strategy)
[16:12:51.021] plan(): nbrOfWorkers() = 1
[16:12:51.021] SequentialFuture started (and completed)
[16:12:51.022] - Launch lazy future ... done
[16:12:51.022] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.022] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.022] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.023] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:51.023] Searching for globals ... DONE
[16:12:51.023] Resolving globals: TRUE
[16:12:51.023] Resolving any globals that are futures ...
[16:12:51.023] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:51.024] Resolving any globals that are futures ... DONE
[16:12:51.024] Resolving futures part of globals (recursively) ...
[16:12:51.024] resolve() on list ...
[16:12:51.024]  recursive: 99
[16:12:51.024]  length: 1
[16:12:51.024]  elements: ‘a’
[16:12:51.025] resolved() for ‘SequentialFuture’ ...
[16:12:51.025] - state: ‘finished’
[16:12:51.025] - run: TRUE
[16:12:51.025] - result: ‘FutureResult’
[16:12:51.025] resolved() for ‘SequentialFuture’ ... done
[16:12:51.025] Future #1
[16:12:51.025] resolved() for ‘SequentialFuture’ ...
[16:12:51.025] - state: ‘finished’
[16:12:51.025] - run: TRUE
[16:12:51.025] - result: ‘FutureResult’
[16:12:51.026] resolved() for ‘SequentialFuture’ ... done
[16:12:51.026] A SequentialFuture was resolved
[16:12:51.026]  length: 0 (resolved future 1)
[16:12:51.026] resolve() on list ... DONE
[16:12:51.026] - globals: [1] ‘a’
[16:12:51.026] Resolving futures part of globals (recursively) ... DONE
[16:12:51.027] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[16:12:51.027] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[16:12:51.027] - globals: [1] ‘a’
[16:12:51.027] - packages: [1] ‘future’
[16:12:51.027] getGlobalsAndPackages() ... DONE
[16:12:51.028] run() for ‘Future’ ...
[16:12:51.028] - state: ‘created’
[16:12:51.028] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.028] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.028] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.028]   - Field: ‘label’
[16:12:51.028]   - Field: ‘local’
[16:12:51.028]   - Field: ‘owner’
[16:12:51.030]   - Field: ‘envir’
[16:12:51.030]   - Field: ‘packages’
[16:12:51.030]   - Field: ‘gc’
[16:12:51.030]   - Field: ‘conditions’
[16:12:51.030]   - Field: ‘expr’
[16:12:51.030]   - Field: ‘uuid’
[16:12:51.030]   - Field: ‘seed’
[16:12:51.030]   - Field: ‘version’
[16:12:51.031]   - Field: ‘result’
[16:12:51.031]   - Field: ‘asynchronous’
[16:12:51.031]   - Field: ‘calls’
[16:12:51.031]   - Field: ‘globals’
[16:12:51.031]   - Field: ‘stdout’
[16:12:51.031]   - Field: ‘earlySignal’
[16:12:51.031]   - Field: ‘lazy’
[16:12:51.031]   - Field: ‘state’
[16:12:51.031] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.031] - Launch lazy future ...
[16:12:51.032] Packages needed by the future expression (n = 1): ‘future’
[16:12:51.032] Packages needed by future strategies (n = 0): <none>
[16:12:51.032] {
[16:12:51.032]     {
[16:12:51.032]         {
[16:12:51.032]             ...future.startTime <- base::Sys.time()
[16:12:51.032]             {
[16:12:51.032]                 {
[16:12:51.032]                   {
[16:12:51.032]                     {
[16:12:51.032]                       base::local({
[16:12:51.032]                         has_future <- base::requireNamespace("future", 
[16:12:51.032]                           quietly = TRUE)
[16:12:51.032]                         if (has_future) {
[16:12:51.032]                           ns <- base::getNamespace("future")
[16:12:51.032]                           version <- ns[[".package"]][["version"]]
[16:12:51.032]                           if (is.null(version)) 
[16:12:51.032]                             version <- utils::packageVersion("future")
[16:12:51.032]                         }
[16:12:51.032]                         else {
[16:12:51.032]                           version <- NULL
[16:12:51.032]                         }
[16:12:51.032]                         if (!has_future || version < "1.8.0") {
[16:12:51.032]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.032]                             "", base::R.version$version.string), 
[16:12:51.032]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:51.032]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.032]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.032]                               "release", "version")], collapse = " "), 
[16:12:51.032]                             hostname = base::Sys.info()[["nodename"]])
[16:12:51.032]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.032]                             info)
[16:12:51.032]                           info <- base::paste(info, collapse = "; ")
[16:12:51.032]                           if (!has_future) {
[16:12:51.032]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.032]                               info)
[16:12:51.032]                           }
[16:12:51.032]                           else {
[16:12:51.032]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.032]                               info, version)
[16:12:51.032]                           }
[16:12:51.032]                           base::stop(msg)
[16:12:51.032]                         }
[16:12:51.032]                       })
[16:12:51.032]                     }
[16:12:51.032]                     base::local({
[16:12:51.032]                       for (pkg in "future") {
[16:12:51.032]                         base::loadNamespace(pkg)
[16:12:51.032]                         base::library(pkg, character.only = TRUE)
[16:12:51.032]                       }
[16:12:51.032]                     })
[16:12:51.032]                   }
[16:12:51.032]                   options(future.plan = NULL)
[16:12:51.032]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.032]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.032]                 }
[16:12:51.032]                 ...future.workdir <- getwd()
[16:12:51.032]             }
[16:12:51.032]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.032]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.032]         }
[16:12:51.032]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.032]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:51.032]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.032]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.032]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.032]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.032]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.032]             base::names(...future.oldOptions))
[16:12:51.032]     }
[16:12:51.032]     if (FALSE) {
[16:12:51.032]     }
[16:12:51.032]     else {
[16:12:51.032]         if (TRUE) {
[16:12:51.032]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.032]                 open = "w")
[16:12:51.032]         }
[16:12:51.032]         else {
[16:12:51.032]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.032]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.032]         }
[16:12:51.032]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.032]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.032]             base::sink(type = "output", split = FALSE)
[16:12:51.032]             base::close(...future.stdout)
[16:12:51.032]         }, add = TRUE)
[16:12:51.032]     }
[16:12:51.032]     ...future.frame <- base::sys.nframe()
[16:12:51.032]     ...future.conditions <- base::list()
[16:12:51.032]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.032]     if (FALSE) {
[16:12:51.032]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.032]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.032]     }
[16:12:51.032]     ...future.result <- base::tryCatch({
[16:12:51.032]         base::withCallingHandlers({
[16:12:51.032]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:12:51.032]                 1))
[16:12:51.032]             future::FutureResult(value = ...future.value$value, 
[16:12:51.032]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.032]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.032]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.032]                     ...future.globalenv.names))
[16:12:51.032]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.032]         }, condition = base::local({
[16:12:51.032]             c <- base::c
[16:12:51.032]             inherits <- base::inherits
[16:12:51.032]             invokeRestart <- base::invokeRestart
[16:12:51.032]             length <- base::length
[16:12:51.032]             list <- base::list
[16:12:51.032]             seq.int <- base::seq.int
[16:12:51.032]             signalCondition <- base::signalCondition
[16:12:51.032]             sys.calls <- base::sys.calls
[16:12:51.032]             `[[` <- base::`[[`
[16:12:51.032]             `+` <- base::`+`
[16:12:51.032]             `<<-` <- base::`<<-`
[16:12:51.032]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.032]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.032]                   3L)]
[16:12:51.032]             }
[16:12:51.032]             function(cond) {
[16:12:51.032]                 is_error <- inherits(cond, "error")
[16:12:51.032]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.032]                   NULL)
[16:12:51.032]                 if (is_error) {
[16:12:51.032]                   sessionInformation <- function() {
[16:12:51.032]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.032]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.032]                       search = base::search(), system = base::Sys.info())
[16:12:51.032]                   }
[16:12:51.032]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.032]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.032]                     cond$call), session = sessionInformation(), 
[16:12:51.032]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.032]                   signalCondition(cond)
[16:12:51.032]                 }
[16:12:51.032]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.032]                 "immediateCondition"))) {
[16:12:51.032]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.032]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.032]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.032]                   if (TRUE && !signal) {
[16:12:51.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.032]                     {
[16:12:51.032]                       inherits <- base::inherits
[16:12:51.032]                       invokeRestart <- base::invokeRestart
[16:12:51.032]                       is.null <- base::is.null
[16:12:51.032]                       muffled <- FALSE
[16:12:51.032]                       if (inherits(cond, "message")) {
[16:12:51.032]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.032]                         if (muffled) 
[16:12:51.032]                           invokeRestart("muffleMessage")
[16:12:51.032]                       }
[16:12:51.032]                       else if (inherits(cond, "warning")) {
[16:12:51.032]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.032]                         if (muffled) 
[16:12:51.032]                           invokeRestart("muffleWarning")
[16:12:51.032]                       }
[16:12:51.032]                       else if (inherits(cond, "condition")) {
[16:12:51.032]                         if (!is.null(pattern)) {
[16:12:51.032]                           computeRestarts <- base::computeRestarts
[16:12:51.032]                           grepl <- base::grepl
[16:12:51.032]                           restarts <- computeRestarts(cond)
[16:12:51.032]                           for (restart in restarts) {
[16:12:51.032]                             name <- restart$name
[16:12:51.032]                             if (is.null(name)) 
[16:12:51.032]                               next
[16:12:51.032]                             if (!grepl(pattern, name)) 
[16:12:51.032]                               next
[16:12:51.032]                             invokeRestart(restart)
[16:12:51.032]                             muffled <- TRUE
[16:12:51.032]                             break
[16:12:51.032]                           }
[16:12:51.032]                         }
[16:12:51.032]                       }
[16:12:51.032]                       invisible(muffled)
[16:12:51.032]                     }
[16:12:51.032]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.032]                   }
[16:12:51.032]                 }
[16:12:51.032]                 else {
[16:12:51.032]                   if (TRUE) {
[16:12:51.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.032]                     {
[16:12:51.032]                       inherits <- base::inherits
[16:12:51.032]                       invokeRestart <- base::invokeRestart
[16:12:51.032]                       is.null <- base::is.null
[16:12:51.032]                       muffled <- FALSE
[16:12:51.032]                       if (inherits(cond, "message")) {
[16:12:51.032]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.032]                         if (muffled) 
[16:12:51.032]                           invokeRestart("muffleMessage")
[16:12:51.032]                       }
[16:12:51.032]                       else if (inherits(cond, "warning")) {
[16:12:51.032]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.032]                         if (muffled) 
[16:12:51.032]                           invokeRestart("muffleWarning")
[16:12:51.032]                       }
[16:12:51.032]                       else if (inherits(cond, "condition")) {
[16:12:51.032]                         if (!is.null(pattern)) {
[16:12:51.032]                           computeRestarts <- base::computeRestarts
[16:12:51.032]                           grepl <- base::grepl
[16:12:51.032]                           restarts <- computeRestarts(cond)
[16:12:51.032]                           for (restart in restarts) {
[16:12:51.032]                             name <- restart$name
[16:12:51.032]                             if (is.null(name)) 
[16:12:51.032]                               next
[16:12:51.032]                             if (!grepl(pattern, name)) 
[16:12:51.032]                               next
[16:12:51.032]                             invokeRestart(restart)
[16:12:51.032]                             muffled <- TRUE
[16:12:51.032]                             break
[16:12:51.032]                           }
[16:12:51.032]                         }
[16:12:51.032]                       }
[16:12:51.032]                       invisible(muffled)
[16:12:51.032]                     }
[16:12:51.032]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.032]                   }
[16:12:51.032]                 }
[16:12:51.032]             }
[16:12:51.032]         }))
[16:12:51.032]     }, error = function(ex) {
[16:12:51.032]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.032]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.032]                 ...future.rng), started = ...future.startTime, 
[16:12:51.032]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.032]             version = "1.8"), class = "FutureResult")
[16:12:51.032]     }, finally = {
[16:12:51.032]         if (!identical(...future.workdir, getwd())) 
[16:12:51.032]             setwd(...future.workdir)
[16:12:51.032]         {
[16:12:51.032]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.032]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.032]             }
[16:12:51.032]             base::options(...future.oldOptions)
[16:12:51.032]             if (.Platform$OS.type == "windows") {
[16:12:51.032]                 old_names <- names(...future.oldEnvVars)
[16:12:51.032]                 envs <- base::Sys.getenv()
[16:12:51.032]                 names <- names(envs)
[16:12:51.032]                 common <- intersect(names, old_names)
[16:12:51.032]                 added <- setdiff(names, old_names)
[16:12:51.032]                 removed <- setdiff(old_names, names)
[16:12:51.032]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.032]                   envs[common]]
[16:12:51.032]                 NAMES <- toupper(changed)
[16:12:51.032]                 args <- list()
[16:12:51.032]                 for (kk in seq_along(NAMES)) {
[16:12:51.032]                   name <- changed[[kk]]
[16:12:51.032]                   NAME <- NAMES[[kk]]
[16:12:51.032]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.032]                     next
[16:12:51.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.032]                 }
[16:12:51.032]                 NAMES <- toupper(added)
[16:12:51.032]                 for (kk in seq_along(NAMES)) {
[16:12:51.032]                   name <- added[[kk]]
[16:12:51.032]                   NAME <- NAMES[[kk]]
[16:12:51.032]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.032]                     next
[16:12:51.032]                   args[[name]] <- ""
[16:12:51.032]                 }
[16:12:51.032]                 NAMES <- toupper(removed)
[16:12:51.032]                 for (kk in seq_along(NAMES)) {
[16:12:51.032]                   name <- removed[[kk]]
[16:12:51.032]                   NAME <- NAMES[[kk]]
[16:12:51.032]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.032]                     next
[16:12:51.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.032]                 }
[16:12:51.032]                 if (length(args) > 0) 
[16:12:51.032]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.032]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.032]             }
[16:12:51.032]             else {
[16:12:51.032]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.032]             }
[16:12:51.032]             {
[16:12:51.032]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.032]                   0L) {
[16:12:51.032]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.032]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.032]                   base::options(opts)
[16:12:51.032]                 }
[16:12:51.032]                 {
[16:12:51.032]                   {
[16:12:51.032]                     NULL
[16:12:51.032]                     RNGkind("Mersenne-Twister")
[16:12:51.032]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.032]                       inherits = FALSE)
[16:12:51.032]                   }
[16:12:51.032]                   options(future.plan = NULL)
[16:12:51.032]                   if (is.na(NA_character_)) 
[16:12:51.032]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.032]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.032]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.032]                   {
[16:12:51.032]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.032]                     if (!future$lazy) 
[16:12:51.032]                       future <- run(future)
[16:12:51.032]                     invisible(future)
[16:12:51.032]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.032]                 }
[16:12:51.032]             }
[16:12:51.032]         }
[16:12:51.032]     })
[16:12:51.032]     if (TRUE) {
[16:12:51.032]         base::sink(type = "output", split = FALSE)
[16:12:51.032]         if (TRUE) {
[16:12:51.032]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.032]         }
[16:12:51.032]         else {
[16:12:51.032]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.032]         }
[16:12:51.032]         base::close(...future.stdout)
[16:12:51.032]         ...future.stdout <- NULL
[16:12:51.032]     }
[16:12:51.032]     ...future.result$conditions <- ...future.conditions
[16:12:51.032]     ...future.result$finished <- base::Sys.time()
[16:12:51.032]     ...future.result
[16:12:51.032] }
[16:12:51.034] assign_globals() ...
[16:12:51.034] List of 1
[16:12:51.034]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x56233d18aaf8> 
[16:12:51.034]  - attr(*, "where")=List of 1
[16:12:51.034]   ..$ a:<environment: R_EmptyEnv> 
[16:12:51.034]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.034]  - attr(*, "resolved")= logi TRUE
[16:12:51.034]  - attr(*, "total_size")= num 10424
[16:12:51.034]  - attr(*, "already-done")= logi TRUE
[16:12:51.036] - copied ‘a’ to environment
[16:12:51.036] assign_globals() ... done
[16:12:51.037] plan(): Setting new future strategy stack:
[16:12:51.037] List of future strategies:
[16:12:51.037] 1. sequential:
[16:12:51.037]    - args: function (..., envir = parent.frame())
[16:12:51.037]    - tweaked: FALSE
[16:12:51.037]    - call: NULL
[16:12:51.037] plan(): nbrOfWorkers() = 1
[16:12:51.038] plan(): Setting new future strategy stack:
[16:12:51.038] List of future strategies:
[16:12:51.038] 1. sequential:
[16:12:51.038]    - args: function (..., envir = parent.frame())
[16:12:51.038]    - tweaked: FALSE
[16:12:51.038]    - call: plan(strategy)
[16:12:51.038] plan(): nbrOfWorkers() = 1
[16:12:51.038] SequentialFuture started (and completed)
[16:12:51.039] - Launch lazy future ... done
[16:12:51.039] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.039] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.039] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.040] 
[16:12:51.040] Searching for globals ... DONE
[16:12:51.040] - globals: [0] <none>
[16:12:51.040] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.040] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.040] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.041] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:51.041] Searching for globals ... DONE
[16:12:51.042] Resolving globals: TRUE
[16:12:51.042] Resolving any globals that are futures ...
[16:12:51.042] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:51.042] Resolving any globals that are futures ... DONE
[16:12:51.042] Resolving futures part of globals (recursively) ...
[16:12:51.042] resolve() on list ...
[16:12:51.042]  recursive: 99
[16:12:51.042]  length: 1
[16:12:51.043]  elements: ‘a’
[16:12:51.043] run() for ‘Future’ ...
[16:12:51.043] - state: ‘created’
[16:12:51.043] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.043] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.043] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.043]   - Field: ‘label’
[16:12:51.043]   - Field: ‘local’
[16:12:51.044]   - Field: ‘owner’
[16:12:51.044]   - Field: ‘envir’
[16:12:51.044]   - Field: ‘packages’
[16:12:51.044]   - Field: ‘gc’
[16:12:51.044]   - Field: ‘conditions’
[16:12:51.044]   - Field: ‘expr’
[16:12:51.044]   - Field: ‘uuid’
[16:12:51.044]   - Field: ‘seed’
[16:12:51.044]   - Field: ‘version’
[16:12:51.044]   - Field: ‘result’
[16:12:51.044]   - Field: ‘asynchronous’
[16:12:51.045]   - Field: ‘calls’
[16:12:51.045]   - Field: ‘globals’
[16:12:51.045]   - Field: ‘stdout’
[16:12:51.045]   - Field: ‘earlySignal’
[16:12:51.045]   - Field: ‘lazy’
[16:12:51.045]   - Field: ‘state’
[16:12:51.045] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.045] - Launch lazy future ...
[16:12:51.045] Packages needed by the future expression (n = 0): <none>
[16:12:51.045] Packages needed by future strategies (n = 0): <none>
[16:12:51.046] {
[16:12:51.046]     {
[16:12:51.046]         {
[16:12:51.046]             ...future.startTime <- base::Sys.time()
[16:12:51.046]             {
[16:12:51.046]                 {
[16:12:51.046]                   {
[16:12:51.046]                     base::local({
[16:12:51.046]                       has_future <- base::requireNamespace("future", 
[16:12:51.046]                         quietly = TRUE)
[16:12:51.046]                       if (has_future) {
[16:12:51.046]                         ns <- base::getNamespace("future")
[16:12:51.046]                         version <- ns[[".package"]][["version"]]
[16:12:51.046]                         if (is.null(version)) 
[16:12:51.046]                           version <- utils::packageVersion("future")
[16:12:51.046]                       }
[16:12:51.046]                       else {
[16:12:51.046]                         version <- NULL
[16:12:51.046]                       }
[16:12:51.046]                       if (!has_future || version < "1.8.0") {
[16:12:51.046]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.046]                           "", base::R.version$version.string), 
[16:12:51.046]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:51.046]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.046]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.046]                             "release", "version")], collapse = " "), 
[16:12:51.046]                           hostname = base::Sys.info()[["nodename"]])
[16:12:51.046]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.046]                           info)
[16:12:51.046]                         info <- base::paste(info, collapse = "; ")
[16:12:51.046]                         if (!has_future) {
[16:12:51.046]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.046]                             info)
[16:12:51.046]                         }
[16:12:51.046]                         else {
[16:12:51.046]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.046]                             info, version)
[16:12:51.046]                         }
[16:12:51.046]                         base::stop(msg)
[16:12:51.046]                       }
[16:12:51.046]                     })
[16:12:51.046]                   }
[16:12:51.046]                   options(future.plan = NULL)
[16:12:51.046]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.046]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.046]                 }
[16:12:51.046]                 ...future.workdir <- getwd()
[16:12:51.046]             }
[16:12:51.046]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.046]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.046]         }
[16:12:51.046]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.046]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:51.046]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.046]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.046]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.046]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.046]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.046]             base::names(...future.oldOptions))
[16:12:51.046]     }
[16:12:51.046]     if (FALSE) {
[16:12:51.046]     }
[16:12:51.046]     else {
[16:12:51.046]         if (TRUE) {
[16:12:51.046]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.046]                 open = "w")
[16:12:51.046]         }
[16:12:51.046]         else {
[16:12:51.046]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.046]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.046]         }
[16:12:51.046]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.046]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.046]             base::sink(type = "output", split = FALSE)
[16:12:51.046]             base::close(...future.stdout)
[16:12:51.046]         }, add = TRUE)
[16:12:51.046]     }
[16:12:51.046]     ...future.frame <- base::sys.nframe()
[16:12:51.046]     ...future.conditions <- base::list()
[16:12:51.046]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.046]     if (FALSE) {
[16:12:51.046]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.046]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.046]     }
[16:12:51.046]     ...future.result <- base::tryCatch({
[16:12:51.046]         base::withCallingHandlers({
[16:12:51.046]             ...future.value <- base::withVisible(base::local(1))
[16:12:51.046]             future::FutureResult(value = ...future.value$value, 
[16:12:51.046]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.046]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.046]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.046]                     ...future.globalenv.names))
[16:12:51.046]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.046]         }, condition = base::local({
[16:12:51.046]             c <- base::c
[16:12:51.046]             inherits <- base::inherits
[16:12:51.046]             invokeRestart <- base::invokeRestart
[16:12:51.046]             length <- base::length
[16:12:51.046]             list <- base::list
[16:12:51.046]             seq.int <- base::seq.int
[16:12:51.046]             signalCondition <- base::signalCondition
[16:12:51.046]             sys.calls <- base::sys.calls
[16:12:51.046]             `[[` <- base::`[[`
[16:12:51.046]             `+` <- base::`+`
[16:12:51.046]             `<<-` <- base::`<<-`
[16:12:51.046]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.046]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.046]                   3L)]
[16:12:51.046]             }
[16:12:51.046]             function(cond) {
[16:12:51.046]                 is_error <- inherits(cond, "error")
[16:12:51.046]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.046]                   NULL)
[16:12:51.046]                 if (is_error) {
[16:12:51.046]                   sessionInformation <- function() {
[16:12:51.046]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.046]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.046]                       search = base::search(), system = base::Sys.info())
[16:12:51.046]                   }
[16:12:51.046]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.046]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.046]                     cond$call), session = sessionInformation(), 
[16:12:51.046]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.046]                   signalCondition(cond)
[16:12:51.046]                 }
[16:12:51.046]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.046]                 "immediateCondition"))) {
[16:12:51.046]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.046]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.046]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.046]                   if (TRUE && !signal) {
[16:12:51.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.046]                     {
[16:12:51.046]                       inherits <- base::inherits
[16:12:51.046]                       invokeRestart <- base::invokeRestart
[16:12:51.046]                       is.null <- base::is.null
[16:12:51.046]                       muffled <- FALSE
[16:12:51.046]                       if (inherits(cond, "message")) {
[16:12:51.046]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.046]                         if (muffled) 
[16:12:51.046]                           invokeRestart("muffleMessage")
[16:12:51.046]                       }
[16:12:51.046]                       else if (inherits(cond, "warning")) {
[16:12:51.046]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.046]                         if (muffled) 
[16:12:51.046]                           invokeRestart("muffleWarning")
[16:12:51.046]                       }
[16:12:51.046]                       else if (inherits(cond, "condition")) {
[16:12:51.046]                         if (!is.null(pattern)) {
[16:12:51.046]                           computeRestarts <- base::computeRestarts
[16:12:51.046]                           grepl <- base::grepl
[16:12:51.046]                           restarts <- computeRestarts(cond)
[16:12:51.046]                           for (restart in restarts) {
[16:12:51.046]                             name <- restart$name
[16:12:51.046]                             if (is.null(name)) 
[16:12:51.046]                               next
[16:12:51.046]                             if (!grepl(pattern, name)) 
[16:12:51.046]                               next
[16:12:51.046]                             invokeRestart(restart)
[16:12:51.046]                             muffled <- TRUE
[16:12:51.046]                             break
[16:12:51.046]                           }
[16:12:51.046]                         }
[16:12:51.046]                       }
[16:12:51.046]                       invisible(muffled)
[16:12:51.046]                     }
[16:12:51.046]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.046]                   }
[16:12:51.046]                 }
[16:12:51.046]                 else {
[16:12:51.046]                   if (TRUE) {
[16:12:51.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.046]                     {
[16:12:51.046]                       inherits <- base::inherits
[16:12:51.046]                       invokeRestart <- base::invokeRestart
[16:12:51.046]                       is.null <- base::is.null
[16:12:51.046]                       muffled <- FALSE
[16:12:51.046]                       if (inherits(cond, "message")) {
[16:12:51.046]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.046]                         if (muffled) 
[16:12:51.046]                           invokeRestart("muffleMessage")
[16:12:51.046]                       }
[16:12:51.046]                       else if (inherits(cond, "warning")) {
[16:12:51.046]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.046]                         if (muffled) 
[16:12:51.046]                           invokeRestart("muffleWarning")
[16:12:51.046]                       }
[16:12:51.046]                       else if (inherits(cond, "condition")) {
[16:12:51.046]                         if (!is.null(pattern)) {
[16:12:51.046]                           computeRestarts <- base::computeRestarts
[16:12:51.046]                           grepl <- base::grepl
[16:12:51.046]                           restarts <- computeRestarts(cond)
[16:12:51.046]                           for (restart in restarts) {
[16:12:51.046]                             name <- restart$name
[16:12:51.046]                             if (is.null(name)) 
[16:12:51.046]                               next
[16:12:51.046]                             if (!grepl(pattern, name)) 
[16:12:51.046]                               next
[16:12:51.046]                             invokeRestart(restart)
[16:12:51.046]                             muffled <- TRUE
[16:12:51.046]                             break
[16:12:51.046]                           }
[16:12:51.046]                         }
[16:12:51.046]                       }
[16:12:51.046]                       invisible(muffled)
[16:12:51.046]                     }
[16:12:51.046]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.046]                   }
[16:12:51.046]                 }
[16:12:51.046]             }
[16:12:51.046]         }))
[16:12:51.046]     }, error = function(ex) {
[16:12:51.046]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.046]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.046]                 ...future.rng), started = ...future.startTime, 
[16:12:51.046]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.046]             version = "1.8"), class = "FutureResult")
[16:12:51.046]     }, finally = {
[16:12:51.046]         if (!identical(...future.workdir, getwd())) 
[16:12:51.046]             setwd(...future.workdir)
[16:12:51.046]         {
[16:12:51.046]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.046]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.046]             }
[16:12:51.046]             base::options(...future.oldOptions)
[16:12:51.046]             if (.Platform$OS.type == "windows") {
[16:12:51.046]                 old_names <- names(...future.oldEnvVars)
[16:12:51.046]                 envs <- base::Sys.getenv()
[16:12:51.046]                 names <- names(envs)
[16:12:51.046]                 common <- intersect(names, old_names)
[16:12:51.046]                 added <- setdiff(names, old_names)
[16:12:51.046]                 removed <- setdiff(old_names, names)
[16:12:51.046]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.046]                   envs[common]]
[16:12:51.046]                 NAMES <- toupper(changed)
[16:12:51.046]                 args <- list()
[16:12:51.046]                 for (kk in seq_along(NAMES)) {
[16:12:51.046]                   name <- changed[[kk]]
[16:12:51.046]                   NAME <- NAMES[[kk]]
[16:12:51.046]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.046]                     next
[16:12:51.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.046]                 }
[16:12:51.046]                 NAMES <- toupper(added)
[16:12:51.046]                 for (kk in seq_along(NAMES)) {
[16:12:51.046]                   name <- added[[kk]]
[16:12:51.046]                   NAME <- NAMES[[kk]]
[16:12:51.046]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.046]                     next
[16:12:51.046]                   args[[name]] <- ""
[16:12:51.046]                 }
[16:12:51.046]                 NAMES <- toupper(removed)
[16:12:51.046]                 for (kk in seq_along(NAMES)) {
[16:12:51.046]                   name <- removed[[kk]]
[16:12:51.046]                   NAME <- NAMES[[kk]]
[16:12:51.046]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.046]                     next
[16:12:51.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.046]                 }
[16:12:51.046]                 if (length(args) > 0) 
[16:12:51.046]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.046]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.046]             }
[16:12:51.046]             else {
[16:12:51.046]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.046]             }
[16:12:51.046]             {
[16:12:51.046]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.046]                   0L) {
[16:12:51.046]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.046]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.046]                   base::options(opts)
[16:12:51.046]                 }
[16:12:51.046]                 {
[16:12:51.046]                   {
[16:12:51.046]                     NULL
[16:12:51.046]                     RNGkind("Mersenne-Twister")
[16:12:51.046]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.046]                       inherits = FALSE)
[16:12:51.046]                   }
[16:12:51.046]                   options(future.plan = NULL)
[16:12:51.046]                   if (is.na(NA_character_)) 
[16:12:51.046]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.046]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.046]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.046]                   {
[16:12:51.046]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.046]                     if (!future$lazy) 
[16:12:51.046]                       future <- run(future)
[16:12:51.046]                     invisible(future)
[16:12:51.046]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.046]                 }
[16:12:51.046]             }
[16:12:51.046]         }
[16:12:51.046]     })
[16:12:51.046]     if (TRUE) {
[16:12:51.046]         base::sink(type = "output", split = FALSE)
[16:12:51.046]         if (TRUE) {
[16:12:51.046]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.046]         }
[16:12:51.046]         else {
[16:12:51.046]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.046]         }
[16:12:51.046]         base::close(...future.stdout)
[16:12:51.046]         ...future.stdout <- NULL
[16:12:51.046]     }
[16:12:51.046]     ...future.result$conditions <- ...future.conditions
[16:12:51.046]     ...future.result$finished <- base::Sys.time()
[16:12:51.046]     ...future.result
[16:12:51.046] }
[16:12:51.047] plan(): Setting new future strategy stack:
[16:12:51.048] List of future strategies:
[16:12:51.048] 1. sequential:
[16:12:51.048]    - args: function (..., envir = parent.frame())
[16:12:51.048]    - tweaked: FALSE
[16:12:51.048]    - call: NULL
[16:12:51.048] plan(): nbrOfWorkers() = 1
[16:12:51.049] plan(): Setting new future strategy stack:
[16:12:51.049] List of future strategies:
[16:12:51.049] 1. sequential:
[16:12:51.049]    - args: function (..., envir = parent.frame())
[16:12:51.049]    - tweaked: FALSE
[16:12:51.049]    - call: plan(strategy)
[16:12:51.049] plan(): nbrOfWorkers() = 1
[16:12:51.049] SequentialFuture started (and completed)
[16:12:51.049] - Launch lazy future ... done
[16:12:51.049] run() for ‘SequentialFuture’ ... done
[16:12:51.049] resolved() for ‘SequentialFuture’ ...
[16:12:51.050] - state: ‘finished’
[16:12:51.050] - run: TRUE
[16:12:51.050] - result: ‘FutureResult’
[16:12:51.050] resolved() for ‘SequentialFuture’ ... done
[16:12:51.050] Future #1
[16:12:51.050] resolved() for ‘SequentialFuture’ ...
[16:12:51.050] - state: ‘finished’
[16:12:51.050] - run: TRUE
[16:12:51.050] - result: ‘FutureResult’
[16:12:51.050] resolved() for ‘SequentialFuture’ ... done
[16:12:51.051] A SequentialFuture was resolved
[16:12:51.051]  length: 0 (resolved future 1)
[16:12:51.051] resolve() on list ... DONE
[16:12:51.051] - globals: [1] ‘a’
[16:12:51.051] Resolving futures part of globals (recursively) ... DONE
[16:12:51.052] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[16:12:51.052] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[16:12:51.052] - globals: [1] ‘a’
[16:12:51.052] - packages: [1] ‘future’
[16:12:51.052] getGlobalsAndPackages() ... DONE
[16:12:51.053] run() for ‘Future’ ...
[16:12:51.053] - state: ‘created’
[16:12:51.053] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.053] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.053] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.053]   - Field: ‘label’
[16:12:51.053]   - Field: ‘local’
[16:12:51.053]   - Field: ‘owner’
[16:12:51.053]   - Field: ‘envir’
[16:12:51.054]   - Field: ‘packages’
[16:12:51.054]   - Field: ‘gc’
[16:12:51.054]   - Field: ‘conditions’
[16:12:51.054]   - Field: ‘expr’
[16:12:51.054]   - Field: ‘uuid’
[16:12:51.054]   - Field: ‘seed’
[16:12:51.054]   - Field: ‘version’
[16:12:51.054]   - Field: ‘result’
[16:12:51.054]   - Field: ‘asynchronous’
[16:12:51.054]   - Field: ‘calls’
[16:12:51.054]   - Field: ‘globals’
[16:12:51.055]   - Field: ‘stdout’
[16:12:51.056]   - Field: ‘earlySignal’
[16:12:51.056]   - Field: ‘lazy’
[16:12:51.056]   - Field: ‘state’
[16:12:51.056] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.056] - Launch lazy future ...
[16:12:51.056] Packages needed by the future expression (n = 1): ‘future’
[16:12:51.056] Packages needed by future strategies (n = 0): <none>
[16:12:51.057] {
[16:12:51.057]     {
[16:12:51.057]         {
[16:12:51.057]             ...future.startTime <- base::Sys.time()
[16:12:51.057]             {
[16:12:51.057]                 {
[16:12:51.057]                   {
[16:12:51.057]                     {
[16:12:51.057]                       base::local({
[16:12:51.057]                         has_future <- base::requireNamespace("future", 
[16:12:51.057]                           quietly = TRUE)
[16:12:51.057]                         if (has_future) {
[16:12:51.057]                           ns <- base::getNamespace("future")
[16:12:51.057]                           version <- ns[[".package"]][["version"]]
[16:12:51.057]                           if (is.null(version)) 
[16:12:51.057]                             version <- utils::packageVersion("future")
[16:12:51.057]                         }
[16:12:51.057]                         else {
[16:12:51.057]                           version <- NULL
[16:12:51.057]                         }
[16:12:51.057]                         if (!has_future || version < "1.8.0") {
[16:12:51.057]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.057]                             "", base::R.version$version.string), 
[16:12:51.057]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:51.057]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.057]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.057]                               "release", "version")], collapse = " "), 
[16:12:51.057]                             hostname = base::Sys.info()[["nodename"]])
[16:12:51.057]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.057]                             info)
[16:12:51.057]                           info <- base::paste(info, collapse = "; ")
[16:12:51.057]                           if (!has_future) {
[16:12:51.057]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.057]                               info)
[16:12:51.057]                           }
[16:12:51.057]                           else {
[16:12:51.057]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.057]                               info, version)
[16:12:51.057]                           }
[16:12:51.057]                           base::stop(msg)
[16:12:51.057]                         }
[16:12:51.057]                       })
[16:12:51.057]                     }
[16:12:51.057]                     base::local({
[16:12:51.057]                       for (pkg in "future") {
[16:12:51.057]                         base::loadNamespace(pkg)
[16:12:51.057]                         base::library(pkg, character.only = TRUE)
[16:12:51.057]                       }
[16:12:51.057]                     })
[16:12:51.057]                   }
[16:12:51.057]                   options(future.plan = NULL)
[16:12:51.057]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.057]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.057]                 }
[16:12:51.057]                 ...future.workdir <- getwd()
[16:12:51.057]             }
[16:12:51.057]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.057]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.057]         }
[16:12:51.057]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.057]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:51.057]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.057]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.057]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.057]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.057]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.057]             base::names(...future.oldOptions))
[16:12:51.057]     }
[16:12:51.057]     if (FALSE) {
[16:12:51.057]     }
[16:12:51.057]     else {
[16:12:51.057]         if (TRUE) {
[16:12:51.057]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.057]                 open = "w")
[16:12:51.057]         }
[16:12:51.057]         else {
[16:12:51.057]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.057]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.057]         }
[16:12:51.057]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.057]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.057]             base::sink(type = "output", split = FALSE)
[16:12:51.057]             base::close(...future.stdout)
[16:12:51.057]         }, add = TRUE)
[16:12:51.057]     }
[16:12:51.057]     ...future.frame <- base::sys.nframe()
[16:12:51.057]     ...future.conditions <- base::list()
[16:12:51.057]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.057]     if (FALSE) {
[16:12:51.057]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.057]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.057]     }
[16:12:51.057]     ...future.result <- base::tryCatch({
[16:12:51.057]         base::withCallingHandlers({
[16:12:51.057]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:12:51.057]                 1))
[16:12:51.057]             future::FutureResult(value = ...future.value$value, 
[16:12:51.057]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.057]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.057]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.057]                     ...future.globalenv.names))
[16:12:51.057]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.057]         }, condition = base::local({
[16:12:51.057]             c <- base::c
[16:12:51.057]             inherits <- base::inherits
[16:12:51.057]             invokeRestart <- base::invokeRestart
[16:12:51.057]             length <- base::length
[16:12:51.057]             list <- base::list
[16:12:51.057]             seq.int <- base::seq.int
[16:12:51.057]             signalCondition <- base::signalCondition
[16:12:51.057]             sys.calls <- base::sys.calls
[16:12:51.057]             `[[` <- base::`[[`
[16:12:51.057]             `+` <- base::`+`
[16:12:51.057]             `<<-` <- base::`<<-`
[16:12:51.057]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.057]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.057]                   3L)]
[16:12:51.057]             }
[16:12:51.057]             function(cond) {
[16:12:51.057]                 is_error <- inherits(cond, "error")
[16:12:51.057]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.057]                   NULL)
[16:12:51.057]                 if (is_error) {
[16:12:51.057]                   sessionInformation <- function() {
[16:12:51.057]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.057]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.057]                       search = base::search(), system = base::Sys.info())
[16:12:51.057]                   }
[16:12:51.057]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.057]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.057]                     cond$call), session = sessionInformation(), 
[16:12:51.057]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.057]                   signalCondition(cond)
[16:12:51.057]                 }
[16:12:51.057]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.057]                 "immediateCondition"))) {
[16:12:51.057]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.057]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.057]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.057]                   if (TRUE && !signal) {
[16:12:51.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.057]                     {
[16:12:51.057]                       inherits <- base::inherits
[16:12:51.057]                       invokeRestart <- base::invokeRestart
[16:12:51.057]                       is.null <- base::is.null
[16:12:51.057]                       muffled <- FALSE
[16:12:51.057]                       if (inherits(cond, "message")) {
[16:12:51.057]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.057]                         if (muffled) 
[16:12:51.057]                           invokeRestart("muffleMessage")
[16:12:51.057]                       }
[16:12:51.057]                       else if (inherits(cond, "warning")) {
[16:12:51.057]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.057]                         if (muffled) 
[16:12:51.057]                           invokeRestart("muffleWarning")
[16:12:51.057]                       }
[16:12:51.057]                       else if (inherits(cond, "condition")) {
[16:12:51.057]                         if (!is.null(pattern)) {
[16:12:51.057]                           computeRestarts <- base::computeRestarts
[16:12:51.057]                           grepl <- base::grepl
[16:12:51.057]                           restarts <- computeRestarts(cond)
[16:12:51.057]                           for (restart in restarts) {
[16:12:51.057]                             name <- restart$name
[16:12:51.057]                             if (is.null(name)) 
[16:12:51.057]                               next
[16:12:51.057]                             if (!grepl(pattern, name)) 
[16:12:51.057]                               next
[16:12:51.057]                             invokeRestart(restart)
[16:12:51.057]                             muffled <- TRUE
[16:12:51.057]                             break
[16:12:51.057]                           }
[16:12:51.057]                         }
[16:12:51.057]                       }
[16:12:51.057]                       invisible(muffled)
[16:12:51.057]                     }
[16:12:51.057]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.057]                   }
[16:12:51.057]                 }
[16:12:51.057]                 else {
[16:12:51.057]                   if (TRUE) {
[16:12:51.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.057]                     {
[16:12:51.057]                       inherits <- base::inherits
[16:12:51.057]                       invokeRestart <- base::invokeRestart
[16:12:51.057]                       is.null <- base::is.null
[16:12:51.057]                       muffled <- FALSE
[16:12:51.057]                       if (inherits(cond, "message")) {
[16:12:51.057]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.057]                         if (muffled) 
[16:12:51.057]                           invokeRestart("muffleMessage")
[16:12:51.057]                       }
[16:12:51.057]                       else if (inherits(cond, "warning")) {
[16:12:51.057]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.057]                         if (muffled) 
[16:12:51.057]                           invokeRestart("muffleWarning")
[16:12:51.057]                       }
[16:12:51.057]                       else if (inherits(cond, "condition")) {
[16:12:51.057]                         if (!is.null(pattern)) {
[16:12:51.057]                           computeRestarts <- base::computeRestarts
[16:12:51.057]                           grepl <- base::grepl
[16:12:51.057]                           restarts <- computeRestarts(cond)
[16:12:51.057]                           for (restart in restarts) {
[16:12:51.057]                             name <- restart$name
[16:12:51.057]                             if (is.null(name)) 
[16:12:51.057]                               next
[16:12:51.057]                             if (!grepl(pattern, name)) 
[16:12:51.057]                               next
[16:12:51.057]                             invokeRestart(restart)
[16:12:51.057]                             muffled <- TRUE
[16:12:51.057]                             break
[16:12:51.057]                           }
[16:12:51.057]                         }
[16:12:51.057]                       }
[16:12:51.057]                       invisible(muffled)
[16:12:51.057]                     }
[16:12:51.057]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.057]                   }
[16:12:51.057]                 }
[16:12:51.057]             }
[16:12:51.057]         }))
[16:12:51.057]     }, error = function(ex) {
[16:12:51.057]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.057]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.057]                 ...future.rng), started = ...future.startTime, 
[16:12:51.057]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.057]             version = "1.8"), class = "FutureResult")
[16:12:51.057]     }, finally = {
[16:12:51.057]         if (!identical(...future.workdir, getwd())) 
[16:12:51.057]             setwd(...future.workdir)
[16:12:51.057]         {
[16:12:51.057]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.057]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.057]             }
[16:12:51.057]             base::options(...future.oldOptions)
[16:12:51.057]             if (.Platform$OS.type == "windows") {
[16:12:51.057]                 old_names <- names(...future.oldEnvVars)
[16:12:51.057]                 envs <- base::Sys.getenv()
[16:12:51.057]                 names <- names(envs)
[16:12:51.057]                 common <- intersect(names, old_names)
[16:12:51.057]                 added <- setdiff(names, old_names)
[16:12:51.057]                 removed <- setdiff(old_names, names)
[16:12:51.057]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.057]                   envs[common]]
[16:12:51.057]                 NAMES <- toupper(changed)
[16:12:51.057]                 args <- list()
[16:12:51.057]                 for (kk in seq_along(NAMES)) {
[16:12:51.057]                   name <- changed[[kk]]
[16:12:51.057]                   NAME <- NAMES[[kk]]
[16:12:51.057]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.057]                     next
[16:12:51.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.057]                 }
[16:12:51.057]                 NAMES <- toupper(added)
[16:12:51.057]                 for (kk in seq_along(NAMES)) {
[16:12:51.057]                   name <- added[[kk]]
[16:12:51.057]                   NAME <- NAMES[[kk]]
[16:12:51.057]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.057]                     next
[16:12:51.057]                   args[[name]] <- ""
[16:12:51.057]                 }
[16:12:51.057]                 NAMES <- toupper(removed)
[16:12:51.057]                 for (kk in seq_along(NAMES)) {
[16:12:51.057]                   name <- removed[[kk]]
[16:12:51.057]                   NAME <- NAMES[[kk]]
[16:12:51.057]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.057]                     next
[16:12:51.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.057]                 }
[16:12:51.057]                 if (length(args) > 0) 
[16:12:51.057]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.057]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.057]             }
[16:12:51.057]             else {
[16:12:51.057]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.057]             }
[16:12:51.057]             {
[16:12:51.057]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.057]                   0L) {
[16:12:51.057]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.057]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.057]                   base::options(opts)
[16:12:51.057]                 }
[16:12:51.057]                 {
[16:12:51.057]                   {
[16:12:51.057]                     NULL
[16:12:51.057]                     RNGkind("Mersenne-Twister")
[16:12:51.057]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.057]                       inherits = FALSE)
[16:12:51.057]                   }
[16:12:51.057]                   options(future.plan = NULL)
[16:12:51.057]                   if (is.na(NA_character_)) 
[16:12:51.057]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.057]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.057]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.057]                   {
[16:12:51.057]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.057]                     if (!future$lazy) 
[16:12:51.057]                       future <- run(future)
[16:12:51.057]                     invisible(future)
[16:12:51.057]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.057]                 }
[16:12:51.057]             }
[16:12:51.057]         }
[16:12:51.057]     })
[16:12:51.057]     if (TRUE) {
[16:12:51.057]         base::sink(type = "output", split = FALSE)
[16:12:51.057]         if (TRUE) {
[16:12:51.057]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.057]         }
[16:12:51.057]         else {
[16:12:51.057]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.057]         }
[16:12:51.057]         base::close(...future.stdout)
[16:12:51.057]         ...future.stdout <- NULL
[16:12:51.057]     }
[16:12:51.057]     ...future.result$conditions <- ...future.conditions
[16:12:51.057]     ...future.result$finished <- base::Sys.time()
[16:12:51.057]     ...future.result
[16:12:51.057] }
[16:12:51.059] assign_globals() ...
[16:12:51.059] List of 1
[16:12:51.059]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x56233d079148> 
[16:12:51.059]  - attr(*, "where")=List of 1
[16:12:51.059]   ..$ a:<environment: R_EmptyEnv> 
[16:12:51.059]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.059]  - attr(*, "resolved")= logi TRUE
[16:12:51.059]  - attr(*, "total_size")= num 10592
[16:12:51.059]  - attr(*, "already-done")= logi TRUE
[16:12:51.061] - copied ‘a’ to environment
[16:12:51.061] assign_globals() ... done
[16:12:51.061] plan(): Setting new future strategy stack:
[16:12:51.061] List of future strategies:
[16:12:51.061] 1. sequential:
[16:12:51.061]    - args: function (..., envir = parent.frame())
[16:12:51.061]    - tweaked: FALSE
[16:12:51.061]    - call: NULL
[16:12:51.062] plan(): nbrOfWorkers() = 1
[16:12:51.063] plan(): Setting new future strategy stack:
[16:12:51.063] List of future strategies:
[16:12:51.063] 1. sequential:
[16:12:51.063]    - args: function (..., envir = parent.frame())
[16:12:51.063]    - tweaked: FALSE
[16:12:51.063]    - call: plan(strategy)
[16:12:51.063] plan(): nbrOfWorkers() = 1
[16:12:51.063] SequentialFuture started (and completed)
[16:12:51.063] - Launch lazy future ... done
[16:12:51.063] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.064] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.064] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.065] 
[16:12:51.065] Searching for globals ... DONE
[16:12:51.065] - globals: [0] <none>
[16:12:51.065] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.065] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.065] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.066] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:51.066] Searching for globals ... DONE
[16:12:51.066] Resolving globals: TRUE
[16:12:51.066] Resolving any globals that are futures ...
[16:12:51.067] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:51.067] Resolving any globals that are futures ... DONE
[16:12:51.067] Resolving futures part of globals (recursively) ...
[16:12:51.067] resolve() on list ...
[16:12:51.067]  recursive: 99
[16:12:51.067]  length: 1
[16:12:51.067]  elements: ‘a’
[16:12:51.068] run() for ‘Future’ ...
[16:12:51.068] - state: ‘created’
[16:12:51.068] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.068] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.068] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.068]   - Field: ‘label’
[16:12:51.068]   - Field: ‘local’
[16:12:51.068]   - Field: ‘owner’
[16:12:51.069]   - Field: ‘envir’
[16:12:51.069]   - Field: ‘packages’
[16:12:51.069]   - Field: ‘gc’
[16:12:51.069]   - Field: ‘conditions’
[16:12:51.069]   - Field: ‘expr’
[16:12:51.069]   - Field: ‘uuid’
[16:12:51.069]   - Field: ‘seed’
[16:12:51.069]   - Field: ‘version’
[16:12:51.069]   - Field: ‘result’
[16:12:51.069]   - Field: ‘asynchronous’
[16:12:51.069]   - Field: ‘calls’
[16:12:51.070]   - Field: ‘globals’
[16:12:51.070]   - Field: ‘stdout’
[16:12:51.070]   - Field: ‘earlySignal’
[16:12:51.070]   - Field: ‘lazy’
[16:12:51.070]   - Field: ‘state’
[16:12:51.070] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.070] - Launch lazy future ...
[16:12:51.070] Packages needed by the future expression (n = 0): <none>
[16:12:51.070] Packages needed by future strategies (n = 0): <none>
[16:12:51.071] {
[16:12:51.071]     {
[16:12:51.071]         {
[16:12:51.071]             ...future.startTime <- base::Sys.time()
[16:12:51.071]             {
[16:12:51.071]                 {
[16:12:51.071]                   {
[16:12:51.071]                     base::local({
[16:12:51.071]                       has_future <- base::requireNamespace("future", 
[16:12:51.071]                         quietly = TRUE)
[16:12:51.071]                       if (has_future) {
[16:12:51.071]                         ns <- base::getNamespace("future")
[16:12:51.071]                         version <- ns[[".package"]][["version"]]
[16:12:51.071]                         if (is.null(version)) 
[16:12:51.071]                           version <- utils::packageVersion("future")
[16:12:51.071]                       }
[16:12:51.071]                       else {
[16:12:51.071]                         version <- NULL
[16:12:51.071]                       }
[16:12:51.071]                       if (!has_future || version < "1.8.0") {
[16:12:51.071]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.071]                           "", base::R.version$version.string), 
[16:12:51.071]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:51.071]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.071]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.071]                             "release", "version")], collapse = " "), 
[16:12:51.071]                           hostname = base::Sys.info()[["nodename"]])
[16:12:51.071]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.071]                           info)
[16:12:51.071]                         info <- base::paste(info, collapse = "; ")
[16:12:51.071]                         if (!has_future) {
[16:12:51.071]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.071]                             info)
[16:12:51.071]                         }
[16:12:51.071]                         else {
[16:12:51.071]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.071]                             info, version)
[16:12:51.071]                         }
[16:12:51.071]                         base::stop(msg)
[16:12:51.071]                       }
[16:12:51.071]                     })
[16:12:51.071]                   }
[16:12:51.071]                   options(future.plan = NULL)
[16:12:51.071]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.071]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.071]                 }
[16:12:51.071]                 ...future.workdir <- getwd()
[16:12:51.071]             }
[16:12:51.071]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.071]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.071]         }
[16:12:51.071]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.071]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:51.071]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.071]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.071]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.071]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.071]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.071]             base::names(...future.oldOptions))
[16:12:51.071]     }
[16:12:51.071]     if (FALSE) {
[16:12:51.071]     }
[16:12:51.071]     else {
[16:12:51.071]         if (TRUE) {
[16:12:51.071]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.071]                 open = "w")
[16:12:51.071]         }
[16:12:51.071]         else {
[16:12:51.071]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.071]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.071]         }
[16:12:51.071]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.071]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.071]             base::sink(type = "output", split = FALSE)
[16:12:51.071]             base::close(...future.stdout)
[16:12:51.071]         }, add = TRUE)
[16:12:51.071]     }
[16:12:51.071]     ...future.frame <- base::sys.nframe()
[16:12:51.071]     ...future.conditions <- base::list()
[16:12:51.071]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.071]     if (FALSE) {
[16:12:51.071]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.071]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.071]     }
[16:12:51.071]     ...future.result <- base::tryCatch({
[16:12:51.071]         base::withCallingHandlers({
[16:12:51.071]             ...future.value <- base::withVisible(base::local(1))
[16:12:51.071]             future::FutureResult(value = ...future.value$value, 
[16:12:51.071]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.071]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.071]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.071]                     ...future.globalenv.names))
[16:12:51.071]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.071]         }, condition = base::local({
[16:12:51.071]             c <- base::c
[16:12:51.071]             inherits <- base::inherits
[16:12:51.071]             invokeRestart <- base::invokeRestart
[16:12:51.071]             length <- base::length
[16:12:51.071]             list <- base::list
[16:12:51.071]             seq.int <- base::seq.int
[16:12:51.071]             signalCondition <- base::signalCondition
[16:12:51.071]             sys.calls <- base::sys.calls
[16:12:51.071]             `[[` <- base::`[[`
[16:12:51.071]             `+` <- base::`+`
[16:12:51.071]             `<<-` <- base::`<<-`
[16:12:51.071]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.071]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.071]                   3L)]
[16:12:51.071]             }
[16:12:51.071]             function(cond) {
[16:12:51.071]                 is_error <- inherits(cond, "error")
[16:12:51.071]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.071]                   NULL)
[16:12:51.071]                 if (is_error) {
[16:12:51.071]                   sessionInformation <- function() {
[16:12:51.071]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.071]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.071]                       search = base::search(), system = base::Sys.info())
[16:12:51.071]                   }
[16:12:51.071]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.071]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.071]                     cond$call), session = sessionInformation(), 
[16:12:51.071]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.071]                   signalCondition(cond)
[16:12:51.071]                 }
[16:12:51.071]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.071]                 "immediateCondition"))) {
[16:12:51.071]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.071]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.071]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.071]                   if (TRUE && !signal) {
[16:12:51.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.071]                     {
[16:12:51.071]                       inherits <- base::inherits
[16:12:51.071]                       invokeRestart <- base::invokeRestart
[16:12:51.071]                       is.null <- base::is.null
[16:12:51.071]                       muffled <- FALSE
[16:12:51.071]                       if (inherits(cond, "message")) {
[16:12:51.071]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.071]                         if (muffled) 
[16:12:51.071]                           invokeRestart("muffleMessage")
[16:12:51.071]                       }
[16:12:51.071]                       else if (inherits(cond, "warning")) {
[16:12:51.071]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.071]                         if (muffled) 
[16:12:51.071]                           invokeRestart("muffleWarning")
[16:12:51.071]                       }
[16:12:51.071]                       else if (inherits(cond, "condition")) {
[16:12:51.071]                         if (!is.null(pattern)) {
[16:12:51.071]                           computeRestarts <- base::computeRestarts
[16:12:51.071]                           grepl <- base::grepl
[16:12:51.071]                           restarts <- computeRestarts(cond)
[16:12:51.071]                           for (restart in restarts) {
[16:12:51.071]                             name <- restart$name
[16:12:51.071]                             if (is.null(name)) 
[16:12:51.071]                               next
[16:12:51.071]                             if (!grepl(pattern, name)) 
[16:12:51.071]                               next
[16:12:51.071]                             invokeRestart(restart)
[16:12:51.071]                             muffled <- TRUE
[16:12:51.071]                             break
[16:12:51.071]                           }
[16:12:51.071]                         }
[16:12:51.071]                       }
[16:12:51.071]                       invisible(muffled)
[16:12:51.071]                     }
[16:12:51.071]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.071]                   }
[16:12:51.071]                 }
[16:12:51.071]                 else {
[16:12:51.071]                   if (TRUE) {
[16:12:51.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.071]                     {
[16:12:51.071]                       inherits <- base::inherits
[16:12:51.071]                       invokeRestart <- base::invokeRestart
[16:12:51.071]                       is.null <- base::is.null
[16:12:51.071]                       muffled <- FALSE
[16:12:51.071]                       if (inherits(cond, "message")) {
[16:12:51.071]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.071]                         if (muffled) 
[16:12:51.071]                           invokeRestart("muffleMessage")
[16:12:51.071]                       }
[16:12:51.071]                       else if (inherits(cond, "warning")) {
[16:12:51.071]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.071]                         if (muffled) 
[16:12:51.071]                           invokeRestart("muffleWarning")
[16:12:51.071]                       }
[16:12:51.071]                       else if (inherits(cond, "condition")) {
[16:12:51.071]                         if (!is.null(pattern)) {
[16:12:51.071]                           computeRestarts <- base::computeRestarts
[16:12:51.071]                           grepl <- base::grepl
[16:12:51.071]                           restarts <- computeRestarts(cond)
[16:12:51.071]                           for (restart in restarts) {
[16:12:51.071]                             name <- restart$name
[16:12:51.071]                             if (is.null(name)) 
[16:12:51.071]                               next
[16:12:51.071]                             if (!grepl(pattern, name)) 
[16:12:51.071]                               next
[16:12:51.071]                             invokeRestart(restart)
[16:12:51.071]                             muffled <- TRUE
[16:12:51.071]                             break
[16:12:51.071]                           }
[16:12:51.071]                         }
[16:12:51.071]                       }
[16:12:51.071]                       invisible(muffled)
[16:12:51.071]                     }
[16:12:51.071]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.071]                   }
[16:12:51.071]                 }
[16:12:51.071]             }
[16:12:51.071]         }))
[16:12:51.071]     }, error = function(ex) {
[16:12:51.071]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.071]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.071]                 ...future.rng), started = ...future.startTime, 
[16:12:51.071]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.071]             version = "1.8"), class = "FutureResult")
[16:12:51.071]     }, finally = {
[16:12:51.071]         if (!identical(...future.workdir, getwd())) 
[16:12:51.071]             setwd(...future.workdir)
[16:12:51.071]         {
[16:12:51.071]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.071]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.071]             }
[16:12:51.071]             base::options(...future.oldOptions)
[16:12:51.071]             if (.Platform$OS.type == "windows") {
[16:12:51.071]                 old_names <- names(...future.oldEnvVars)
[16:12:51.071]                 envs <- base::Sys.getenv()
[16:12:51.071]                 names <- names(envs)
[16:12:51.071]                 common <- intersect(names, old_names)
[16:12:51.071]                 added <- setdiff(names, old_names)
[16:12:51.071]                 removed <- setdiff(old_names, names)
[16:12:51.071]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.071]                   envs[common]]
[16:12:51.071]                 NAMES <- toupper(changed)
[16:12:51.071]                 args <- list()
[16:12:51.071]                 for (kk in seq_along(NAMES)) {
[16:12:51.071]                   name <- changed[[kk]]
[16:12:51.071]                   NAME <- NAMES[[kk]]
[16:12:51.071]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.071]                     next
[16:12:51.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.071]                 }
[16:12:51.071]                 NAMES <- toupper(added)
[16:12:51.071]                 for (kk in seq_along(NAMES)) {
[16:12:51.071]                   name <- added[[kk]]
[16:12:51.071]                   NAME <- NAMES[[kk]]
[16:12:51.071]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.071]                     next
[16:12:51.071]                   args[[name]] <- ""
[16:12:51.071]                 }
[16:12:51.071]                 NAMES <- toupper(removed)
[16:12:51.071]                 for (kk in seq_along(NAMES)) {
[16:12:51.071]                   name <- removed[[kk]]
[16:12:51.071]                   NAME <- NAMES[[kk]]
[16:12:51.071]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.071]                     next
[16:12:51.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.071]                 }
[16:12:51.071]                 if (length(args) > 0) 
[16:12:51.071]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.071]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.071]             }
[16:12:51.071]             else {
[16:12:51.071]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.071]             }
[16:12:51.071]             {
[16:12:51.071]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.071]                   0L) {
[16:12:51.071]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.071]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.071]                   base::options(opts)
[16:12:51.071]                 }
[16:12:51.071]                 {
[16:12:51.071]                   {
[16:12:51.071]                     NULL
[16:12:51.071]                     RNGkind("Mersenne-Twister")
[16:12:51.071]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.071]                       inherits = FALSE)
[16:12:51.071]                   }
[16:12:51.071]                   options(future.plan = NULL)
[16:12:51.071]                   if (is.na(NA_character_)) 
[16:12:51.071]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.071]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.071]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.071]                   {
[16:12:51.071]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.071]                     if (!future$lazy) 
[16:12:51.071]                       future <- run(future)
[16:12:51.071]                     invisible(future)
[16:12:51.071]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.071]                 }
[16:12:51.071]             }
[16:12:51.071]         }
[16:12:51.071]     })
[16:12:51.071]     if (TRUE) {
[16:12:51.071]         base::sink(type = "output", split = FALSE)
[16:12:51.071]         if (TRUE) {
[16:12:51.071]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.071]         }
[16:12:51.071]         else {
[16:12:51.071]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.071]         }
[16:12:51.071]         base::close(...future.stdout)
[16:12:51.071]         ...future.stdout <- NULL
[16:12:51.071]     }
[16:12:51.071]     ...future.result$conditions <- ...future.conditions
[16:12:51.071]     ...future.result$finished <- base::Sys.time()
[16:12:51.071]     ...future.result
[16:12:51.071] }
[16:12:51.073] plan(): Setting new future strategy stack:
[16:12:51.073] List of future strategies:
[16:12:51.073] 1. sequential:
[16:12:51.073]    - args: function (..., envir = parent.frame())
[16:12:51.073]    - tweaked: FALSE
[16:12:51.073]    - call: NULL
[16:12:51.073] plan(): nbrOfWorkers() = 1
[16:12:51.074] plan(): Setting new future strategy stack:
[16:12:51.074] List of future strategies:
[16:12:51.074] 1. sequential:
[16:12:51.074]    - args: function (..., envir = parent.frame())
[16:12:51.074]    - tweaked: FALSE
[16:12:51.074]    - call: plan(strategy)
[16:12:51.074] plan(): nbrOfWorkers() = 1
[16:12:51.074] SequentialFuture started (and completed)
[16:12:51.074] - Launch lazy future ... done
[16:12:51.075] run() for ‘SequentialFuture’ ... done
[16:12:51.075] resolved() for ‘SequentialFuture’ ...
[16:12:51.075] - state: ‘finished’
[16:12:51.075] - run: TRUE
[16:12:51.075] - result: ‘FutureResult’
[16:12:51.075] resolved() for ‘SequentialFuture’ ... done
[16:12:51.075] Future #1
[16:12:51.075] resolved() for ‘SequentialFuture’ ...
[16:12:51.075] - state: ‘finished’
[16:12:51.076] - run: TRUE
[16:12:51.076] - result: ‘FutureResult’
[16:12:51.076] resolved() for ‘SequentialFuture’ ... done
[16:12:51.076] A SequentialFuture was resolved
[16:12:51.076]  length: 0 (resolved future 1)
[16:12:51.076] resolve() on list ... DONE
[16:12:51.076] - globals: [1] ‘a’
[16:12:51.076] Resolving futures part of globals (recursively) ... DONE
[16:12:51.077] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[16:12:51.077] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[16:12:51.078] - globals: [1] ‘a’
[16:12:51.078] - packages: [1] ‘future’
[16:12:51.078] getGlobalsAndPackages() ... DONE
[16:12:51.078] run() for ‘Future’ ...
[16:12:51.078] - state: ‘created’
[16:12:51.078] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.078] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.079] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.079]   - Field: ‘label’
[16:12:51.079]   - Field: ‘local’
[16:12:51.079]   - Field: ‘owner’
[16:12:51.079]   - Field: ‘envir’
[16:12:51.079]   - Field: ‘packages’
[16:12:51.079]   - Field: ‘gc’
[16:12:51.079]   - Field: ‘conditions’
[16:12:51.079]   - Field: ‘expr’
[16:12:51.079]   - Field: ‘uuid’
[16:12:51.080]   - Field: ‘seed’
[16:12:51.080]   - Field: ‘version’
[16:12:51.080]   - Field: ‘result’
[16:12:51.080]   - Field: ‘asynchronous’
[16:12:51.080]   - Field: ‘calls’
[16:12:51.080]   - Field: ‘globals’
[16:12:51.080]   - Field: ‘stdout’
[16:12:51.080]   - Field: ‘earlySignal’
[16:12:51.080]   - Field: ‘lazy’
[16:12:51.080]   - Field: ‘state’
[16:12:51.080] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.081] - Launch lazy future ...
[16:12:51.081] Packages needed by the future expression (n = 1): ‘future’
[16:12:51.081] Packages needed by future strategies (n = 0): <none>
[16:12:51.083] {
[16:12:51.083]     {
[16:12:51.083]         {
[16:12:51.083]             ...future.startTime <- base::Sys.time()
[16:12:51.083]             {
[16:12:51.083]                 {
[16:12:51.083]                   {
[16:12:51.083]                     {
[16:12:51.083]                       base::local({
[16:12:51.083]                         has_future <- base::requireNamespace("future", 
[16:12:51.083]                           quietly = TRUE)
[16:12:51.083]                         if (has_future) {
[16:12:51.083]                           ns <- base::getNamespace("future")
[16:12:51.083]                           version <- ns[[".package"]][["version"]]
[16:12:51.083]                           if (is.null(version)) 
[16:12:51.083]                             version <- utils::packageVersion("future")
[16:12:51.083]                         }
[16:12:51.083]                         else {
[16:12:51.083]                           version <- NULL
[16:12:51.083]                         }
[16:12:51.083]                         if (!has_future || version < "1.8.0") {
[16:12:51.083]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.083]                             "", base::R.version$version.string), 
[16:12:51.083]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:51.083]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.083]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.083]                               "release", "version")], collapse = " "), 
[16:12:51.083]                             hostname = base::Sys.info()[["nodename"]])
[16:12:51.083]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.083]                             info)
[16:12:51.083]                           info <- base::paste(info, collapse = "; ")
[16:12:51.083]                           if (!has_future) {
[16:12:51.083]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.083]                               info)
[16:12:51.083]                           }
[16:12:51.083]                           else {
[16:12:51.083]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.083]                               info, version)
[16:12:51.083]                           }
[16:12:51.083]                           base::stop(msg)
[16:12:51.083]                         }
[16:12:51.083]                       })
[16:12:51.083]                     }
[16:12:51.083]                     base::local({
[16:12:51.083]                       for (pkg in "future") {
[16:12:51.083]                         base::loadNamespace(pkg)
[16:12:51.083]                         base::library(pkg, character.only = TRUE)
[16:12:51.083]                       }
[16:12:51.083]                     })
[16:12:51.083]                   }
[16:12:51.083]                   options(future.plan = NULL)
[16:12:51.083]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.083]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.083]                 }
[16:12:51.083]                 ...future.workdir <- getwd()
[16:12:51.083]             }
[16:12:51.083]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.083]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.083]         }
[16:12:51.083]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.083]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:51.083]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.083]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.083]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.083]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.083]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.083]             base::names(...future.oldOptions))
[16:12:51.083]     }
[16:12:51.083]     if (FALSE) {
[16:12:51.083]     }
[16:12:51.083]     else {
[16:12:51.083]         if (TRUE) {
[16:12:51.083]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.083]                 open = "w")
[16:12:51.083]         }
[16:12:51.083]         else {
[16:12:51.083]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.083]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.083]         }
[16:12:51.083]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.083]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.083]             base::sink(type = "output", split = FALSE)
[16:12:51.083]             base::close(...future.stdout)
[16:12:51.083]         }, add = TRUE)
[16:12:51.083]     }
[16:12:51.083]     ...future.frame <- base::sys.nframe()
[16:12:51.083]     ...future.conditions <- base::list()
[16:12:51.083]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.083]     if (FALSE) {
[16:12:51.083]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.083]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.083]     }
[16:12:51.083]     ...future.result <- base::tryCatch({
[16:12:51.083]         base::withCallingHandlers({
[16:12:51.083]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:12:51.083]                 1))
[16:12:51.083]             future::FutureResult(value = ...future.value$value, 
[16:12:51.083]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.083]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.083]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.083]                     ...future.globalenv.names))
[16:12:51.083]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.083]         }, condition = base::local({
[16:12:51.083]             c <- base::c
[16:12:51.083]             inherits <- base::inherits
[16:12:51.083]             invokeRestart <- base::invokeRestart
[16:12:51.083]             length <- base::length
[16:12:51.083]             list <- base::list
[16:12:51.083]             seq.int <- base::seq.int
[16:12:51.083]             signalCondition <- base::signalCondition
[16:12:51.083]             sys.calls <- base::sys.calls
[16:12:51.083]             `[[` <- base::`[[`
[16:12:51.083]             `+` <- base::`+`
[16:12:51.083]             `<<-` <- base::`<<-`
[16:12:51.083]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.083]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.083]                   3L)]
[16:12:51.083]             }
[16:12:51.083]             function(cond) {
[16:12:51.083]                 is_error <- inherits(cond, "error")
[16:12:51.083]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.083]                   NULL)
[16:12:51.083]                 if (is_error) {
[16:12:51.083]                   sessionInformation <- function() {
[16:12:51.083]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.083]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.083]                       search = base::search(), system = base::Sys.info())
[16:12:51.083]                   }
[16:12:51.083]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.083]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.083]                     cond$call), session = sessionInformation(), 
[16:12:51.083]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.083]                   signalCondition(cond)
[16:12:51.083]                 }
[16:12:51.083]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.083]                 "immediateCondition"))) {
[16:12:51.083]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.083]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.083]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.083]                   if (TRUE && !signal) {
[16:12:51.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.083]                     {
[16:12:51.083]                       inherits <- base::inherits
[16:12:51.083]                       invokeRestart <- base::invokeRestart
[16:12:51.083]                       is.null <- base::is.null
[16:12:51.083]                       muffled <- FALSE
[16:12:51.083]                       if (inherits(cond, "message")) {
[16:12:51.083]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.083]                         if (muffled) 
[16:12:51.083]                           invokeRestart("muffleMessage")
[16:12:51.083]                       }
[16:12:51.083]                       else if (inherits(cond, "warning")) {
[16:12:51.083]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.083]                         if (muffled) 
[16:12:51.083]                           invokeRestart("muffleWarning")
[16:12:51.083]                       }
[16:12:51.083]                       else if (inherits(cond, "condition")) {
[16:12:51.083]                         if (!is.null(pattern)) {
[16:12:51.083]                           computeRestarts <- base::computeRestarts
[16:12:51.083]                           grepl <- base::grepl
[16:12:51.083]                           restarts <- computeRestarts(cond)
[16:12:51.083]                           for (restart in restarts) {
[16:12:51.083]                             name <- restart$name
[16:12:51.083]                             if (is.null(name)) 
[16:12:51.083]                               next
[16:12:51.083]                             if (!grepl(pattern, name)) 
[16:12:51.083]                               next
[16:12:51.083]                             invokeRestart(restart)
[16:12:51.083]                             muffled <- TRUE
[16:12:51.083]                             break
[16:12:51.083]                           }
[16:12:51.083]                         }
[16:12:51.083]                       }
[16:12:51.083]                       invisible(muffled)
[16:12:51.083]                     }
[16:12:51.083]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.083]                   }
[16:12:51.083]                 }
[16:12:51.083]                 else {
[16:12:51.083]                   if (TRUE) {
[16:12:51.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.083]                     {
[16:12:51.083]                       inherits <- base::inherits
[16:12:51.083]                       invokeRestart <- base::invokeRestart
[16:12:51.083]                       is.null <- base::is.null
[16:12:51.083]                       muffled <- FALSE
[16:12:51.083]                       if (inherits(cond, "message")) {
[16:12:51.083]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.083]                         if (muffled) 
[16:12:51.083]                           invokeRestart("muffleMessage")
[16:12:51.083]                       }
[16:12:51.083]                       else if (inherits(cond, "warning")) {
[16:12:51.083]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.083]                         if (muffled) 
[16:12:51.083]                           invokeRestart("muffleWarning")
[16:12:51.083]                       }
[16:12:51.083]                       else if (inherits(cond, "condition")) {
[16:12:51.083]                         if (!is.null(pattern)) {
[16:12:51.083]                           computeRestarts <- base::computeRestarts
[16:12:51.083]                           grepl <- base::grepl
[16:12:51.083]                           restarts <- computeRestarts(cond)
[16:12:51.083]                           for (restart in restarts) {
[16:12:51.083]                             name <- restart$name
[16:12:51.083]                             if (is.null(name)) 
[16:12:51.083]                               next
[16:12:51.083]                             if (!grepl(pattern, name)) 
[16:12:51.083]                               next
[16:12:51.083]                             invokeRestart(restart)
[16:12:51.083]                             muffled <- TRUE
[16:12:51.083]                             break
[16:12:51.083]                           }
[16:12:51.083]                         }
[16:12:51.083]                       }
[16:12:51.083]                       invisible(muffled)
[16:12:51.083]                     }
[16:12:51.083]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.083]                   }
[16:12:51.083]                 }
[16:12:51.083]             }
[16:12:51.083]         }))
[16:12:51.083]     }, error = function(ex) {
[16:12:51.083]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.083]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.083]                 ...future.rng), started = ...future.startTime, 
[16:12:51.083]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.083]             version = "1.8"), class = "FutureResult")
[16:12:51.083]     }, finally = {
[16:12:51.083]         if (!identical(...future.workdir, getwd())) 
[16:12:51.083]             setwd(...future.workdir)
[16:12:51.083]         {
[16:12:51.083]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.083]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.083]             }
[16:12:51.083]             base::options(...future.oldOptions)
[16:12:51.083]             if (.Platform$OS.type == "windows") {
[16:12:51.083]                 old_names <- names(...future.oldEnvVars)
[16:12:51.083]                 envs <- base::Sys.getenv()
[16:12:51.083]                 names <- names(envs)
[16:12:51.083]                 common <- intersect(names, old_names)
[16:12:51.083]                 added <- setdiff(names, old_names)
[16:12:51.083]                 removed <- setdiff(old_names, names)
[16:12:51.083]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.083]                   envs[common]]
[16:12:51.083]                 NAMES <- toupper(changed)
[16:12:51.083]                 args <- list()
[16:12:51.083]                 for (kk in seq_along(NAMES)) {
[16:12:51.083]                   name <- changed[[kk]]
[16:12:51.083]                   NAME <- NAMES[[kk]]
[16:12:51.083]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.083]                     next
[16:12:51.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.083]                 }
[16:12:51.083]                 NAMES <- toupper(added)
[16:12:51.083]                 for (kk in seq_along(NAMES)) {
[16:12:51.083]                   name <- added[[kk]]
[16:12:51.083]                   NAME <- NAMES[[kk]]
[16:12:51.083]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.083]                     next
[16:12:51.083]                   args[[name]] <- ""
[16:12:51.083]                 }
[16:12:51.083]                 NAMES <- toupper(removed)
[16:12:51.083]                 for (kk in seq_along(NAMES)) {
[16:12:51.083]                   name <- removed[[kk]]
[16:12:51.083]                   NAME <- NAMES[[kk]]
[16:12:51.083]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.083]                     next
[16:12:51.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.083]                 }
[16:12:51.083]                 if (length(args) > 0) 
[16:12:51.083]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.083]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.083]             }
[16:12:51.083]             else {
[16:12:51.083]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.083]             }
[16:12:51.083]             {
[16:12:51.083]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.083]                   0L) {
[16:12:51.083]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.083]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.083]                   base::options(opts)
[16:12:51.083]                 }
[16:12:51.083]                 {
[16:12:51.083]                   {
[16:12:51.083]                     NULL
[16:12:51.083]                     RNGkind("Mersenne-Twister")
[16:12:51.083]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.083]                       inherits = FALSE)
[16:12:51.083]                   }
[16:12:51.083]                   options(future.plan = NULL)
[16:12:51.083]                   if (is.na(NA_character_)) 
[16:12:51.083]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.083]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.083]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.083]                   {
[16:12:51.083]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.083]                     if (!future$lazy) 
[16:12:51.083]                       future <- run(future)
[16:12:51.083]                     invisible(future)
[16:12:51.083]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.083]                 }
[16:12:51.083]             }
[16:12:51.083]         }
[16:12:51.083]     })
[16:12:51.083]     if (TRUE) {
[16:12:51.083]         base::sink(type = "output", split = FALSE)
[16:12:51.083]         if (TRUE) {
[16:12:51.083]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.083]         }
[16:12:51.083]         else {
[16:12:51.083]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.083]         }
[16:12:51.083]         base::close(...future.stdout)
[16:12:51.083]         ...future.stdout <- NULL
[16:12:51.083]     }
[16:12:51.083]     ...future.result$conditions <- ...future.conditions
[16:12:51.083]     ...future.result$finished <- base::Sys.time()
[16:12:51.083]     ...future.result
[16:12:51.083] }
[16:12:51.085] assign_globals() ...
[16:12:51.085] List of 1
[16:12:51.085]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x56233cf1bc18> 
[16:12:51.085]  - attr(*, "where")=List of 1
[16:12:51.085]   ..$ a:<environment: R_EmptyEnv> 
[16:12:51.085]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.085]  - attr(*, "resolved")= logi TRUE
[16:12:51.085]  - attr(*, "total_size")= num 10592
[16:12:51.085]  - attr(*, "already-done")= logi TRUE
[16:12:51.087] - copied ‘a’ to environment
[16:12:51.087] assign_globals() ... done
[16:12:51.088] plan(): Setting new future strategy stack:
[16:12:51.088] List of future strategies:
[16:12:51.088] 1. sequential:
[16:12:51.088]    - args: function (..., envir = parent.frame())
[16:12:51.088]    - tweaked: FALSE
[16:12:51.088]    - call: NULL
[16:12:51.088] plan(): nbrOfWorkers() = 1
[16:12:51.089] plan(): Setting new future strategy stack:
[16:12:51.089] List of future strategies:
[16:12:51.089] 1. sequential:
[16:12:51.089]    - args: function (..., envir = parent.frame())
[16:12:51.089]    - tweaked: FALSE
[16:12:51.089]    - call: plan(strategy)
[16:12:51.089] plan(): nbrOfWorkers() = 1
[16:12:51.090] SequentialFuture started (and completed)
[16:12:51.090] - Launch lazy future ... done
[16:12:51.090] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.090] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.090] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.091] - globals found: [2] ‘{’, ‘pkg’
[16:12:51.091] Searching for globals ... DONE
[16:12:51.091] Resolving globals: TRUE
[16:12:51.091] Resolving any globals that are futures ...
[16:12:51.092] - globals: [2] ‘{’, ‘pkg’
[16:12:51.092] Resolving any globals that are futures ... DONE
[16:12:51.092] Resolving futures part of globals (recursively) ...
[16:12:51.092] resolve() on list ...
[16:12:51.092]  recursive: 99
[16:12:51.092]  length: 1
[16:12:51.092]  elements: ‘pkg’
[16:12:51.093]  length: 0 (resolved future 1)
[16:12:51.093] resolve() on list ... DONE
[16:12:51.093] - globals: [1] ‘pkg’
[16:12:51.093] Resolving futures part of globals (recursively) ... DONE
[16:12:51.093] The total size of the 1 globals is 112 bytes (112 bytes)
[16:12:51.093] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[16:12:51.093] - globals: [1] ‘pkg’
[16:12:51.094] 
[16:12:51.094] getGlobalsAndPackages() ... DONE
[16:12:51.094] Packages needed by the future expression (n = 0): <none>
[16:12:51.094] Packages needed by future strategies (n = 0): <none>
[16:12:51.094] {
[16:12:51.094]     {
[16:12:51.094]         {
[16:12:51.094]             ...future.startTime <- base::Sys.time()
[16:12:51.094]             {
[16:12:51.094]                 {
[16:12:51.094]                   {
[16:12:51.094]                     base::local({
[16:12:51.094]                       has_future <- base::requireNamespace("future", 
[16:12:51.094]                         quietly = TRUE)
[16:12:51.094]                       if (has_future) {
[16:12:51.094]                         ns <- base::getNamespace("future")
[16:12:51.094]                         version <- ns[[".package"]][["version"]]
[16:12:51.094]                         if (is.null(version)) 
[16:12:51.094]                           version <- utils::packageVersion("future")
[16:12:51.094]                       }
[16:12:51.094]                       else {
[16:12:51.094]                         version <- NULL
[16:12:51.094]                       }
[16:12:51.094]                       if (!has_future || version < "1.8.0") {
[16:12:51.094]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.094]                           "", base::R.version$version.string), 
[16:12:51.094]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:51.094]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.094]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.094]                             "release", "version")], collapse = " "), 
[16:12:51.094]                           hostname = base::Sys.info()[["nodename"]])
[16:12:51.094]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.094]                           info)
[16:12:51.094]                         info <- base::paste(info, collapse = "; ")
[16:12:51.094]                         if (!has_future) {
[16:12:51.094]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.094]                             info)
[16:12:51.094]                         }
[16:12:51.094]                         else {
[16:12:51.094]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.094]                             info, version)
[16:12:51.094]                         }
[16:12:51.094]                         base::stop(msg)
[16:12:51.094]                       }
[16:12:51.094]                     })
[16:12:51.094]                   }
[16:12:51.094]                   options(future.plan = NULL)
[16:12:51.094]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.094]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.094]                 }
[16:12:51.094]                 ...future.workdir <- getwd()
[16:12:51.094]             }
[16:12:51.094]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.094]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.094]         }
[16:12:51.094]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.094]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:51.094]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.094]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.094]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.094]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.094]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.094]             base::names(...future.oldOptions))
[16:12:51.094]     }
[16:12:51.094]     if (FALSE) {
[16:12:51.094]     }
[16:12:51.094]     else {
[16:12:51.094]         if (TRUE) {
[16:12:51.094]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.094]                 open = "w")
[16:12:51.094]         }
[16:12:51.094]         else {
[16:12:51.094]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.094]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.094]         }
[16:12:51.094]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.094]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.094]             base::sink(type = "output", split = FALSE)
[16:12:51.094]             base::close(...future.stdout)
[16:12:51.094]         }, add = TRUE)
[16:12:51.094]     }
[16:12:51.094]     ...future.frame <- base::sys.nframe()
[16:12:51.094]     ...future.conditions <- base::list()
[16:12:51.094]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.094]     if (FALSE) {
[16:12:51.094]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.094]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.094]     }
[16:12:51.094]     ...future.result <- base::tryCatch({
[16:12:51.094]         base::withCallingHandlers({
[16:12:51.094]             ...future.value <- base::withVisible(base::local({
[16:12:51.094]                 pkg
[16:12:51.094]             }))
[16:12:51.094]             future::FutureResult(value = ...future.value$value, 
[16:12:51.094]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.094]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.094]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.094]                     ...future.globalenv.names))
[16:12:51.094]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.094]         }, condition = base::local({
[16:12:51.094]             c <- base::c
[16:12:51.094]             inherits <- base::inherits
[16:12:51.094]             invokeRestart <- base::invokeRestart
[16:12:51.094]             length <- base::length
[16:12:51.094]             list <- base::list
[16:12:51.094]             seq.int <- base::seq.int
[16:12:51.094]             signalCondition <- base::signalCondition
[16:12:51.094]             sys.calls <- base::sys.calls
[16:12:51.094]             `[[` <- base::`[[`
[16:12:51.094]             `+` <- base::`+`
[16:12:51.094]             `<<-` <- base::`<<-`
[16:12:51.094]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.094]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.094]                   3L)]
[16:12:51.094]             }
[16:12:51.094]             function(cond) {
[16:12:51.094]                 is_error <- inherits(cond, "error")
[16:12:51.094]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.094]                   NULL)
[16:12:51.094]                 if (is_error) {
[16:12:51.094]                   sessionInformation <- function() {
[16:12:51.094]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.094]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.094]                       search = base::search(), system = base::Sys.info())
[16:12:51.094]                   }
[16:12:51.094]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.094]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.094]                     cond$call), session = sessionInformation(), 
[16:12:51.094]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.094]                   signalCondition(cond)
[16:12:51.094]                 }
[16:12:51.094]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.094]                 "immediateCondition"))) {
[16:12:51.094]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.094]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.094]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.094]                   if (TRUE && !signal) {
[16:12:51.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.094]                     {
[16:12:51.094]                       inherits <- base::inherits
[16:12:51.094]                       invokeRestart <- base::invokeRestart
[16:12:51.094]                       is.null <- base::is.null
[16:12:51.094]                       muffled <- FALSE
[16:12:51.094]                       if (inherits(cond, "message")) {
[16:12:51.094]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.094]                         if (muffled) 
[16:12:51.094]                           invokeRestart("muffleMessage")
[16:12:51.094]                       }
[16:12:51.094]                       else if (inherits(cond, "warning")) {
[16:12:51.094]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.094]                         if (muffled) 
[16:12:51.094]                           invokeRestart("muffleWarning")
[16:12:51.094]                       }
[16:12:51.094]                       else if (inherits(cond, "condition")) {
[16:12:51.094]                         if (!is.null(pattern)) {
[16:12:51.094]                           computeRestarts <- base::computeRestarts
[16:12:51.094]                           grepl <- base::grepl
[16:12:51.094]                           restarts <- computeRestarts(cond)
[16:12:51.094]                           for (restart in restarts) {
[16:12:51.094]                             name <- restart$name
[16:12:51.094]                             if (is.null(name)) 
[16:12:51.094]                               next
[16:12:51.094]                             if (!grepl(pattern, name)) 
[16:12:51.094]                               next
[16:12:51.094]                             invokeRestart(restart)
[16:12:51.094]                             muffled <- TRUE
[16:12:51.094]                             break
[16:12:51.094]                           }
[16:12:51.094]                         }
[16:12:51.094]                       }
[16:12:51.094]                       invisible(muffled)
[16:12:51.094]                     }
[16:12:51.094]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.094]                   }
[16:12:51.094]                 }
[16:12:51.094]                 else {
[16:12:51.094]                   if (TRUE) {
[16:12:51.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.094]                     {
[16:12:51.094]                       inherits <- base::inherits
[16:12:51.094]                       invokeRestart <- base::invokeRestart
[16:12:51.094]                       is.null <- base::is.null
[16:12:51.094]                       muffled <- FALSE
[16:12:51.094]                       if (inherits(cond, "message")) {
[16:12:51.094]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.094]                         if (muffled) 
[16:12:51.094]                           invokeRestart("muffleMessage")
[16:12:51.094]                       }
[16:12:51.094]                       else if (inherits(cond, "warning")) {
[16:12:51.094]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.094]                         if (muffled) 
[16:12:51.094]                           invokeRestart("muffleWarning")
[16:12:51.094]                       }
[16:12:51.094]                       else if (inherits(cond, "condition")) {
[16:12:51.094]                         if (!is.null(pattern)) {
[16:12:51.094]                           computeRestarts <- base::computeRestarts
[16:12:51.094]                           grepl <- base::grepl
[16:12:51.094]                           restarts <- computeRestarts(cond)
[16:12:51.094]                           for (restart in restarts) {
[16:12:51.094]                             name <- restart$name
[16:12:51.094]                             if (is.null(name)) 
[16:12:51.094]                               next
[16:12:51.094]                             if (!grepl(pattern, name)) 
[16:12:51.094]                               next
[16:12:51.094]                             invokeRestart(restart)
[16:12:51.094]                             muffled <- TRUE
[16:12:51.094]                             break
[16:12:51.094]                           }
[16:12:51.094]                         }
[16:12:51.094]                       }
[16:12:51.094]                       invisible(muffled)
[16:12:51.094]                     }
[16:12:51.094]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.094]                   }
[16:12:51.094]                 }
[16:12:51.094]             }
[16:12:51.094]         }))
[16:12:51.094]     }, error = function(ex) {
[16:12:51.094]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.094]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.094]                 ...future.rng), started = ...future.startTime, 
[16:12:51.094]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.094]             version = "1.8"), class = "FutureResult")
[16:12:51.094]     }, finally = {
[16:12:51.094]         if (!identical(...future.workdir, getwd())) 
[16:12:51.094]             setwd(...future.workdir)
[16:12:51.094]         {
[16:12:51.094]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.094]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.094]             }
[16:12:51.094]             base::options(...future.oldOptions)
[16:12:51.094]             if (.Platform$OS.type == "windows") {
[16:12:51.094]                 old_names <- names(...future.oldEnvVars)
[16:12:51.094]                 envs <- base::Sys.getenv()
[16:12:51.094]                 names <- names(envs)
[16:12:51.094]                 common <- intersect(names, old_names)
[16:12:51.094]                 added <- setdiff(names, old_names)
[16:12:51.094]                 removed <- setdiff(old_names, names)
[16:12:51.094]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.094]                   envs[common]]
[16:12:51.094]                 NAMES <- toupper(changed)
[16:12:51.094]                 args <- list()
[16:12:51.094]                 for (kk in seq_along(NAMES)) {
[16:12:51.094]                   name <- changed[[kk]]
[16:12:51.094]                   NAME <- NAMES[[kk]]
[16:12:51.094]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.094]                     next
[16:12:51.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.094]                 }
[16:12:51.094]                 NAMES <- toupper(added)
[16:12:51.094]                 for (kk in seq_along(NAMES)) {
[16:12:51.094]                   name <- added[[kk]]
[16:12:51.094]                   NAME <- NAMES[[kk]]
[16:12:51.094]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.094]                     next
[16:12:51.094]                   args[[name]] <- ""
[16:12:51.094]                 }
[16:12:51.094]                 NAMES <- toupper(removed)
[16:12:51.094]                 for (kk in seq_along(NAMES)) {
[16:12:51.094]                   name <- removed[[kk]]
[16:12:51.094]                   NAME <- NAMES[[kk]]
[16:12:51.094]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.094]                     next
[16:12:51.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.094]                 }
[16:12:51.094]                 if (length(args) > 0) 
[16:12:51.094]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.094]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.094]             }
[16:12:51.094]             else {
[16:12:51.094]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.094]             }
[16:12:51.094]             {
[16:12:51.094]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.094]                   0L) {
[16:12:51.094]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.094]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.094]                   base::options(opts)
[16:12:51.094]                 }
[16:12:51.094]                 {
[16:12:51.094]                   {
[16:12:51.094]                     NULL
[16:12:51.094]                     RNGkind("Mersenne-Twister")
[16:12:51.094]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.094]                       inherits = FALSE)
[16:12:51.094]                   }
[16:12:51.094]                   options(future.plan = NULL)
[16:12:51.094]                   if (is.na(NA_character_)) 
[16:12:51.094]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.094]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.094]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.094]                   {
[16:12:51.094]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.094]                     if (!future$lazy) 
[16:12:51.094]                       future <- run(future)
[16:12:51.094]                     invisible(future)
[16:12:51.094]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.094]                 }
[16:12:51.094]             }
[16:12:51.094]         }
[16:12:51.094]     })
[16:12:51.094]     if (TRUE) {
[16:12:51.094]         base::sink(type = "output", split = FALSE)
[16:12:51.094]         if (TRUE) {
[16:12:51.094]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.094]         }
[16:12:51.094]         else {
[16:12:51.094]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.094]         }
[16:12:51.094]         base::close(...future.stdout)
[16:12:51.094]         ...future.stdout <- NULL
[16:12:51.094]     }
[16:12:51.094]     ...future.result$conditions <- ...future.conditions
[16:12:51.094]     ...future.result$finished <- base::Sys.time()
[16:12:51.094]     ...future.result
[16:12:51.094] }
[16:12:51.096] assign_globals() ...
[16:12:51.096] List of 1
[16:12:51.096]  $ pkg: chr "foo"
[16:12:51.096]  - attr(*, "where")=List of 1
[16:12:51.096]   ..$ pkg:<environment: R_EmptyEnv> 
[16:12:51.096]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.096]  - attr(*, "resolved")= logi TRUE
[16:12:51.096]  - attr(*, "total_size")= num 112
[16:12:51.098] - copied ‘pkg’ to environment
[16:12:51.098] assign_globals() ... done
[16:12:51.098] plan(): Setting new future strategy stack:
[16:12:51.099] List of future strategies:
[16:12:51.099] 1. sequential:
[16:12:51.099]    - args: function (..., envir = parent.frame())
[16:12:51.099]    - tweaked: FALSE
[16:12:51.099]    - call: NULL
[16:12:51.099] plan(): nbrOfWorkers() = 1
[16:12:51.100] plan(): Setting new future strategy stack:
[16:12:51.100] List of future strategies:
[16:12:51.100] 1. sequential:
[16:12:51.100]    - args: function (..., envir = parent.frame())
[16:12:51.100]    - tweaked: FALSE
[16:12:51.100]    - call: plan(strategy)
[16:12:51.100] plan(): nbrOfWorkers() = 1
[16:12:51.100] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.101] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.101] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:51.103] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:12:51.103] Searching for globals ... DONE
[16:12:51.104] Resolving globals: TRUE
[16:12:51.104] Resolving any globals that are futures ...
[16:12:51.104] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:12:51.104] Resolving any globals that are futures ... DONE
[16:12:51.104] Resolving futures part of globals (recursively) ...
[16:12:51.104] resolve() on list ...
[16:12:51.104]  recursive: 99
[16:12:51.105]  length: 1
[16:12:51.105]  elements: ‘a’
[16:12:51.105]  length: 0 (resolved future 1)
[16:12:51.105] resolve() on list ... DONE
[16:12:51.105] - globals: [1] ‘a’
[16:12:51.105] Resolving futures part of globals (recursively) ... DONE
[16:12:51.105] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:51.106] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:12:51.106] - globals: [1] ‘a’
[16:12:51.106] 
[16:12:51.106] getGlobalsAndPackages() ... DONE
[16:12:51.106] run() for ‘Future’ ...
[16:12:51.106] - state: ‘created’
[16:12:51.106] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.107] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.107] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.107]   - Field: ‘label’
[16:12:51.107]   - Field: ‘local’
[16:12:51.107]   - Field: ‘owner’
[16:12:51.107]   - Field: ‘envir’
[16:12:51.107]   - Field: ‘packages’
[16:12:51.107]   - Field: ‘gc’
[16:12:51.107]   - Field: ‘conditions’
[16:12:51.107]   - Field: ‘expr’
[16:12:51.107]   - Field: ‘uuid’
[16:12:51.108]   - Field: ‘seed’
[16:12:51.108]   - Field: ‘version’
[16:12:51.108]   - Field: ‘result’
[16:12:51.108]   - Field: ‘asynchronous’
[16:12:51.108]   - Field: ‘calls’
[16:12:51.108]   - Field: ‘globals’
[16:12:51.108]   - Field: ‘stdout’
[16:12:51.108]   - Field: ‘earlySignal’
[16:12:51.108]   - Field: ‘lazy’
[16:12:51.108]   - Field: ‘state’
[16:12:51.110] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.110] - Launch lazy future ...
[16:12:51.110] Packages needed by the future expression (n = 0): <none>
[16:12:51.111] Packages needed by future strategies (n = 0): <none>
[16:12:51.111] {
[16:12:51.111]     {
[16:12:51.111]         {
[16:12:51.111]             ...future.startTime <- base::Sys.time()
[16:12:51.111]             {
[16:12:51.111]                 {
[16:12:51.111]                   {
[16:12:51.111]                     base::local({
[16:12:51.111]                       has_future <- base::requireNamespace("future", 
[16:12:51.111]                         quietly = TRUE)
[16:12:51.111]                       if (has_future) {
[16:12:51.111]                         ns <- base::getNamespace("future")
[16:12:51.111]                         version <- ns[[".package"]][["version"]]
[16:12:51.111]                         if (is.null(version)) 
[16:12:51.111]                           version <- utils::packageVersion("future")
[16:12:51.111]                       }
[16:12:51.111]                       else {
[16:12:51.111]                         version <- NULL
[16:12:51.111]                       }
[16:12:51.111]                       if (!has_future || version < "1.8.0") {
[16:12:51.111]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.111]                           "", base::R.version$version.string), 
[16:12:51.111]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:51.111]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.111]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.111]                             "release", "version")], collapse = " "), 
[16:12:51.111]                           hostname = base::Sys.info()[["nodename"]])
[16:12:51.111]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.111]                           info)
[16:12:51.111]                         info <- base::paste(info, collapse = "; ")
[16:12:51.111]                         if (!has_future) {
[16:12:51.111]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.111]                             info)
[16:12:51.111]                         }
[16:12:51.111]                         else {
[16:12:51.111]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.111]                             info, version)
[16:12:51.111]                         }
[16:12:51.111]                         base::stop(msg)
[16:12:51.111]                       }
[16:12:51.111]                     })
[16:12:51.111]                   }
[16:12:51.111]                   options(future.plan = NULL)
[16:12:51.111]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.111]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.111]                 }
[16:12:51.111]                 ...future.workdir <- getwd()
[16:12:51.111]             }
[16:12:51.111]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.111]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.111]         }
[16:12:51.111]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.111]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:51.111]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.111]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.111]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.111]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.111]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.111]             base::names(...future.oldOptions))
[16:12:51.111]     }
[16:12:51.111]     if (FALSE) {
[16:12:51.111]     }
[16:12:51.111]     else {
[16:12:51.111]         if (TRUE) {
[16:12:51.111]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.111]                 open = "w")
[16:12:51.111]         }
[16:12:51.111]         else {
[16:12:51.111]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.111]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.111]         }
[16:12:51.111]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.111]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.111]             base::sink(type = "output", split = FALSE)
[16:12:51.111]             base::close(...future.stdout)
[16:12:51.111]         }, add = TRUE)
[16:12:51.111]     }
[16:12:51.111]     ...future.frame <- base::sys.nframe()
[16:12:51.111]     ...future.conditions <- base::list()
[16:12:51.111]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.111]     if (FALSE) {
[16:12:51.111]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.111]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.111]     }
[16:12:51.111]     ...future.result <- base::tryCatch({
[16:12:51.111]         base::withCallingHandlers({
[16:12:51.111]             ...future.value <- base::withVisible(base::local({
[16:12:51.111]                 b <- a
[16:12:51.111]                 a <- 2
[16:12:51.111]                 a * b
[16:12:51.111]             }))
[16:12:51.111]             future::FutureResult(value = ...future.value$value, 
[16:12:51.111]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.111]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.111]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.111]                     ...future.globalenv.names))
[16:12:51.111]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.111]         }, condition = base::local({
[16:12:51.111]             c <- base::c
[16:12:51.111]             inherits <- base::inherits
[16:12:51.111]             invokeRestart <- base::invokeRestart
[16:12:51.111]             length <- base::length
[16:12:51.111]             list <- base::list
[16:12:51.111]             seq.int <- base::seq.int
[16:12:51.111]             signalCondition <- base::signalCondition
[16:12:51.111]             sys.calls <- base::sys.calls
[16:12:51.111]             `[[` <- base::`[[`
[16:12:51.111]             `+` <- base::`+`
[16:12:51.111]             `<<-` <- base::`<<-`
[16:12:51.111]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.111]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.111]                   3L)]
[16:12:51.111]             }
[16:12:51.111]             function(cond) {
[16:12:51.111]                 is_error <- inherits(cond, "error")
[16:12:51.111]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.111]                   NULL)
[16:12:51.111]                 if (is_error) {
[16:12:51.111]                   sessionInformation <- function() {
[16:12:51.111]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.111]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.111]                       search = base::search(), system = base::Sys.info())
[16:12:51.111]                   }
[16:12:51.111]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.111]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.111]                     cond$call), session = sessionInformation(), 
[16:12:51.111]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.111]                   signalCondition(cond)
[16:12:51.111]                 }
[16:12:51.111]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.111]                 "immediateCondition"))) {
[16:12:51.111]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.111]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.111]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.111]                   if (TRUE && !signal) {
[16:12:51.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.111]                     {
[16:12:51.111]                       inherits <- base::inherits
[16:12:51.111]                       invokeRestart <- base::invokeRestart
[16:12:51.111]                       is.null <- base::is.null
[16:12:51.111]                       muffled <- FALSE
[16:12:51.111]                       if (inherits(cond, "message")) {
[16:12:51.111]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.111]                         if (muffled) 
[16:12:51.111]                           invokeRestart("muffleMessage")
[16:12:51.111]                       }
[16:12:51.111]                       else if (inherits(cond, "warning")) {
[16:12:51.111]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.111]                         if (muffled) 
[16:12:51.111]                           invokeRestart("muffleWarning")
[16:12:51.111]                       }
[16:12:51.111]                       else if (inherits(cond, "condition")) {
[16:12:51.111]                         if (!is.null(pattern)) {
[16:12:51.111]                           computeRestarts <- base::computeRestarts
[16:12:51.111]                           grepl <- base::grepl
[16:12:51.111]                           restarts <- computeRestarts(cond)
[16:12:51.111]                           for (restart in restarts) {
[16:12:51.111]                             name <- restart$name
[16:12:51.111]                             if (is.null(name)) 
[16:12:51.111]                               next
[16:12:51.111]                             if (!grepl(pattern, name)) 
[16:12:51.111]                               next
[16:12:51.111]                             invokeRestart(restart)
[16:12:51.111]                             muffled <- TRUE
[16:12:51.111]                             break
[16:12:51.111]                           }
[16:12:51.111]                         }
[16:12:51.111]                       }
[16:12:51.111]                       invisible(muffled)
[16:12:51.111]                     }
[16:12:51.111]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.111]                   }
[16:12:51.111]                 }
[16:12:51.111]                 else {
[16:12:51.111]                   if (TRUE) {
[16:12:51.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.111]                     {
[16:12:51.111]                       inherits <- base::inherits
[16:12:51.111]                       invokeRestart <- base::invokeRestart
[16:12:51.111]                       is.null <- base::is.null
[16:12:51.111]                       muffled <- FALSE
[16:12:51.111]                       if (inherits(cond, "message")) {
[16:12:51.111]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.111]                         if (muffled) 
[16:12:51.111]                           invokeRestart("muffleMessage")
[16:12:51.111]                       }
[16:12:51.111]                       else if (inherits(cond, "warning")) {
[16:12:51.111]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.111]                         if (muffled) 
[16:12:51.111]                           invokeRestart("muffleWarning")
[16:12:51.111]                       }
[16:12:51.111]                       else if (inherits(cond, "condition")) {
[16:12:51.111]                         if (!is.null(pattern)) {
[16:12:51.111]                           computeRestarts <- base::computeRestarts
[16:12:51.111]                           grepl <- base::grepl
[16:12:51.111]                           restarts <- computeRestarts(cond)
[16:12:51.111]                           for (restart in restarts) {
[16:12:51.111]                             name <- restart$name
[16:12:51.111]                             if (is.null(name)) 
[16:12:51.111]                               next
[16:12:51.111]                             if (!grepl(pattern, name)) 
[16:12:51.111]                               next
[16:12:51.111]                             invokeRestart(restart)
[16:12:51.111]                             muffled <- TRUE
[16:12:51.111]                             break
[16:12:51.111]                           }
[16:12:51.111]                         }
[16:12:51.111]                       }
[16:12:51.111]                       invisible(muffled)
[16:12:51.111]                     }
[16:12:51.111]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.111]                   }
[16:12:51.111]                 }
[16:12:51.111]             }
[16:12:51.111]         }))
[16:12:51.111]     }, error = function(ex) {
[16:12:51.111]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.111]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.111]                 ...future.rng), started = ...future.startTime, 
[16:12:51.111]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.111]             version = "1.8"), class = "FutureResult")
[16:12:51.111]     }, finally = {
[16:12:51.111]         if (!identical(...future.workdir, getwd())) 
[16:12:51.111]             setwd(...future.workdir)
[16:12:51.111]         {
[16:12:51.111]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.111]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.111]             }
[16:12:51.111]             base::options(...future.oldOptions)
[16:12:51.111]             if (.Platform$OS.type == "windows") {
[16:12:51.111]                 old_names <- names(...future.oldEnvVars)
[16:12:51.111]                 envs <- base::Sys.getenv()
[16:12:51.111]                 names <- names(envs)
[16:12:51.111]                 common <- intersect(names, old_names)
[16:12:51.111]                 added <- setdiff(names, old_names)
[16:12:51.111]                 removed <- setdiff(old_names, names)
[16:12:51.111]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.111]                   envs[common]]
[16:12:51.111]                 NAMES <- toupper(changed)
[16:12:51.111]                 args <- list()
[16:12:51.111]                 for (kk in seq_along(NAMES)) {
[16:12:51.111]                   name <- changed[[kk]]
[16:12:51.111]                   NAME <- NAMES[[kk]]
[16:12:51.111]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.111]                     next
[16:12:51.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.111]                 }
[16:12:51.111]                 NAMES <- toupper(added)
[16:12:51.111]                 for (kk in seq_along(NAMES)) {
[16:12:51.111]                   name <- added[[kk]]
[16:12:51.111]                   NAME <- NAMES[[kk]]
[16:12:51.111]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.111]                     next
[16:12:51.111]                   args[[name]] <- ""
[16:12:51.111]                 }
[16:12:51.111]                 NAMES <- toupper(removed)
[16:12:51.111]                 for (kk in seq_along(NAMES)) {
[16:12:51.111]                   name <- removed[[kk]]
[16:12:51.111]                   NAME <- NAMES[[kk]]
[16:12:51.111]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.111]                     next
[16:12:51.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.111]                 }
[16:12:51.111]                 if (length(args) > 0) 
[16:12:51.111]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.111]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.111]             }
[16:12:51.111]             else {
[16:12:51.111]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.111]             }
[16:12:51.111]             {
[16:12:51.111]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.111]                   0L) {
[16:12:51.111]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.111]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.111]                   base::options(opts)
[16:12:51.111]                 }
[16:12:51.111]                 {
[16:12:51.111]                   {
[16:12:51.111]                     NULL
[16:12:51.111]                     RNGkind("Mersenne-Twister")
[16:12:51.111]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.111]                       inherits = FALSE)
[16:12:51.111]                   }
[16:12:51.111]                   options(future.plan = NULL)
[16:12:51.111]                   if (is.na(NA_character_)) 
[16:12:51.111]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.111]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.111]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.111]                   {
[16:12:51.111]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.111]                     if (!future$lazy) 
[16:12:51.111]                       future <- run(future)
[16:12:51.111]                     invisible(future)
[16:12:51.111]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.111]                 }
[16:12:51.111]             }
[16:12:51.111]         }
[16:12:51.111]     })
[16:12:51.111]     if (TRUE) {
[16:12:51.111]         base::sink(type = "output", split = FALSE)
[16:12:51.111]         if (TRUE) {
[16:12:51.111]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.111]         }
[16:12:51.111]         else {
[16:12:51.111]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.111]         }
[16:12:51.111]         base::close(...future.stdout)
[16:12:51.111]         ...future.stdout <- NULL
[16:12:51.111]     }
[16:12:51.111]     ...future.result$conditions <- ...future.conditions
[16:12:51.111]     ...future.result$finished <- base::Sys.time()
[16:12:51.111]     ...future.result
[16:12:51.111] }
[16:12:51.113] assign_globals() ...
[16:12:51.113] List of 1
[16:12:51.113]  $ a: num 3
[16:12:51.113]  - attr(*, "where")=List of 1
[16:12:51.113]   ..$ a:<environment: R_EmptyEnv> 
[16:12:51.113]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.113]  - attr(*, "resolved")= logi TRUE
[16:12:51.113]  - attr(*, "total_size")= num 56
[16:12:51.113]  - attr(*, "already-done")= logi TRUE
[16:12:51.115] - copied ‘a’ to environment
[16:12:51.115] assign_globals() ... done
[16:12:51.115] plan(): Setting new future strategy stack:
[16:12:51.115] List of future strategies:
[16:12:51.115] 1. sequential:
[16:12:51.115]    - args: function (..., envir = parent.frame())
[16:12:51.115]    - tweaked: FALSE
[16:12:51.115]    - call: NULL
[16:12:51.116] plan(): nbrOfWorkers() = 1
[16:12:51.117] plan(): Setting new future strategy stack:
[16:12:51.117] List of future strategies:
[16:12:51.117] 1. sequential:
[16:12:51.117]    - args: function (..., envir = parent.frame())
[16:12:51.117]    - tweaked: FALSE
[16:12:51.117]    - call: plan(strategy)
[16:12:51.117] plan(): nbrOfWorkers() = 1
[16:12:51.117] SequentialFuture started (and completed)
[16:12:51.117] - Launch lazy future ... done
[16:12:51.117] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.118] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.118] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:51.120] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:12:51.120] Searching for globals ... DONE
[16:12:51.120] Resolving globals: TRUE
[16:12:51.120] Resolving any globals that are futures ...
[16:12:51.120] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:12:51.120] Resolving any globals that are futures ... DONE
[16:12:51.121] Resolving futures part of globals (recursively) ...
[16:12:51.121] resolve() on list ...
[16:12:51.121]  recursive: 99
[16:12:51.121]  length: 1
[16:12:51.121]  elements: ‘a’
[16:12:51.121]  length: 0 (resolved future 1)
[16:12:51.121] resolve() on list ... DONE
[16:12:51.121] - globals: [1] ‘a’
[16:12:51.121] Resolving futures part of globals (recursively) ... DONE
[16:12:51.122] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:51.122] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:12:51.122] - globals: [1] ‘a’
[16:12:51.122] 
[16:12:51.122] getGlobalsAndPackages() ... DONE
[16:12:51.123] run() for ‘Future’ ...
[16:12:51.123] - state: ‘created’
[16:12:51.123] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.123] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.123] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.123]   - Field: ‘label’
[16:12:51.123]   - Field: ‘local’
[16:12:51.123]   - Field: ‘owner’
[16:12:51.124]   - Field: ‘envir’
[16:12:51.124]   - Field: ‘packages’
[16:12:51.124]   - Field: ‘gc’
[16:12:51.124]   - Field: ‘conditions’
[16:12:51.124]   - Field: ‘expr’
[16:12:51.124]   - Field: ‘uuid’
[16:12:51.124]   - Field: ‘seed’
[16:12:51.124]   - Field: ‘version’
[16:12:51.124]   - Field: ‘result’
[16:12:51.124]   - Field: ‘asynchronous’
[16:12:51.125]   - Field: ‘calls’
[16:12:51.125]   - Field: ‘globals’
[16:12:51.125]   - Field: ‘stdout’
[16:12:51.125]   - Field: ‘earlySignal’
[16:12:51.125]   - Field: ‘lazy’
[16:12:51.125]   - Field: ‘state’
[16:12:51.125] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.125] - Launch lazy future ...
[16:12:51.125] Packages needed by the future expression (n = 0): <none>
[16:12:51.125] Packages needed by future strategies (n = 0): <none>
[16:12:51.126] {
[16:12:51.126]     {
[16:12:51.126]         {
[16:12:51.126]             ...future.startTime <- base::Sys.time()
[16:12:51.126]             {
[16:12:51.126]                 {
[16:12:51.126]                   {
[16:12:51.126]                     base::local({
[16:12:51.126]                       has_future <- base::requireNamespace("future", 
[16:12:51.126]                         quietly = TRUE)
[16:12:51.126]                       if (has_future) {
[16:12:51.126]                         ns <- base::getNamespace("future")
[16:12:51.126]                         version <- ns[[".package"]][["version"]]
[16:12:51.126]                         if (is.null(version)) 
[16:12:51.126]                           version <- utils::packageVersion("future")
[16:12:51.126]                       }
[16:12:51.126]                       else {
[16:12:51.126]                         version <- NULL
[16:12:51.126]                       }
[16:12:51.126]                       if (!has_future || version < "1.8.0") {
[16:12:51.126]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.126]                           "", base::R.version$version.string), 
[16:12:51.126]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:51.126]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.126]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.126]                             "release", "version")], collapse = " "), 
[16:12:51.126]                           hostname = base::Sys.info()[["nodename"]])
[16:12:51.126]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.126]                           info)
[16:12:51.126]                         info <- base::paste(info, collapse = "; ")
[16:12:51.126]                         if (!has_future) {
[16:12:51.126]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.126]                             info)
[16:12:51.126]                         }
[16:12:51.126]                         else {
[16:12:51.126]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.126]                             info, version)
[16:12:51.126]                         }
[16:12:51.126]                         base::stop(msg)
[16:12:51.126]                       }
[16:12:51.126]                     })
[16:12:51.126]                   }
[16:12:51.126]                   options(future.plan = NULL)
[16:12:51.126]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.126]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.126]                 }
[16:12:51.126]                 ...future.workdir <- getwd()
[16:12:51.126]             }
[16:12:51.126]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.126]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.126]         }
[16:12:51.126]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.126]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:51.126]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.126]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.126]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.126]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.126]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.126]             base::names(...future.oldOptions))
[16:12:51.126]     }
[16:12:51.126]     if (FALSE) {
[16:12:51.126]     }
[16:12:51.126]     else {
[16:12:51.126]         if (TRUE) {
[16:12:51.126]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.126]                 open = "w")
[16:12:51.126]         }
[16:12:51.126]         else {
[16:12:51.126]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.126]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.126]         }
[16:12:51.126]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.126]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.126]             base::sink(type = "output", split = FALSE)
[16:12:51.126]             base::close(...future.stdout)
[16:12:51.126]         }, add = TRUE)
[16:12:51.126]     }
[16:12:51.126]     ...future.frame <- base::sys.nframe()
[16:12:51.126]     ...future.conditions <- base::list()
[16:12:51.126]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.126]     if (FALSE) {
[16:12:51.126]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.126]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.126]     }
[16:12:51.126]     ...future.result <- base::tryCatch({
[16:12:51.126]         base::withCallingHandlers({
[16:12:51.126]             ...future.value <- base::withVisible(base::local({
[16:12:51.126]                 b <- a
[16:12:51.126]                 a <- 2
[16:12:51.126]                 a * b
[16:12:51.126]             }))
[16:12:51.126]             future::FutureResult(value = ...future.value$value, 
[16:12:51.126]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.126]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.126]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.126]                     ...future.globalenv.names))
[16:12:51.126]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.126]         }, condition = base::local({
[16:12:51.126]             c <- base::c
[16:12:51.126]             inherits <- base::inherits
[16:12:51.126]             invokeRestart <- base::invokeRestart
[16:12:51.126]             length <- base::length
[16:12:51.126]             list <- base::list
[16:12:51.126]             seq.int <- base::seq.int
[16:12:51.126]             signalCondition <- base::signalCondition
[16:12:51.126]             sys.calls <- base::sys.calls
[16:12:51.126]             `[[` <- base::`[[`
[16:12:51.126]             `+` <- base::`+`
[16:12:51.126]             `<<-` <- base::`<<-`
[16:12:51.126]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.126]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.126]                   3L)]
[16:12:51.126]             }
[16:12:51.126]             function(cond) {
[16:12:51.126]                 is_error <- inherits(cond, "error")
[16:12:51.126]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.126]                   NULL)
[16:12:51.126]                 if (is_error) {
[16:12:51.126]                   sessionInformation <- function() {
[16:12:51.126]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.126]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.126]                       search = base::search(), system = base::Sys.info())
[16:12:51.126]                   }
[16:12:51.126]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.126]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.126]                     cond$call), session = sessionInformation(), 
[16:12:51.126]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.126]                   signalCondition(cond)
[16:12:51.126]                 }
[16:12:51.126]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.126]                 "immediateCondition"))) {
[16:12:51.126]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.126]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.126]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.126]                   if (TRUE && !signal) {
[16:12:51.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.126]                     {
[16:12:51.126]                       inherits <- base::inherits
[16:12:51.126]                       invokeRestart <- base::invokeRestart
[16:12:51.126]                       is.null <- base::is.null
[16:12:51.126]                       muffled <- FALSE
[16:12:51.126]                       if (inherits(cond, "message")) {
[16:12:51.126]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.126]                         if (muffled) 
[16:12:51.126]                           invokeRestart("muffleMessage")
[16:12:51.126]                       }
[16:12:51.126]                       else if (inherits(cond, "warning")) {
[16:12:51.126]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.126]                         if (muffled) 
[16:12:51.126]                           invokeRestart("muffleWarning")
[16:12:51.126]                       }
[16:12:51.126]                       else if (inherits(cond, "condition")) {
[16:12:51.126]                         if (!is.null(pattern)) {
[16:12:51.126]                           computeRestarts <- base::computeRestarts
[16:12:51.126]                           grepl <- base::grepl
[16:12:51.126]                           restarts <- computeRestarts(cond)
[16:12:51.126]                           for (restart in restarts) {
[16:12:51.126]                             name <- restart$name
[16:12:51.126]                             if (is.null(name)) 
[16:12:51.126]                               next
[16:12:51.126]                             if (!grepl(pattern, name)) 
[16:12:51.126]                               next
[16:12:51.126]                             invokeRestart(restart)
[16:12:51.126]                             muffled <- TRUE
[16:12:51.126]                             break
[16:12:51.126]                           }
[16:12:51.126]                         }
[16:12:51.126]                       }
[16:12:51.126]                       invisible(muffled)
[16:12:51.126]                     }
[16:12:51.126]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.126]                   }
[16:12:51.126]                 }
[16:12:51.126]                 else {
[16:12:51.126]                   if (TRUE) {
[16:12:51.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.126]                     {
[16:12:51.126]                       inherits <- base::inherits
[16:12:51.126]                       invokeRestart <- base::invokeRestart
[16:12:51.126]                       is.null <- base::is.null
[16:12:51.126]                       muffled <- FALSE
[16:12:51.126]                       if (inherits(cond, "message")) {
[16:12:51.126]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.126]                         if (muffled) 
[16:12:51.126]                           invokeRestart("muffleMessage")
[16:12:51.126]                       }
[16:12:51.126]                       else if (inherits(cond, "warning")) {
[16:12:51.126]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.126]                         if (muffled) 
[16:12:51.126]                           invokeRestart("muffleWarning")
[16:12:51.126]                       }
[16:12:51.126]                       else if (inherits(cond, "condition")) {
[16:12:51.126]                         if (!is.null(pattern)) {
[16:12:51.126]                           computeRestarts <- base::computeRestarts
[16:12:51.126]                           grepl <- base::grepl
[16:12:51.126]                           restarts <- computeRestarts(cond)
[16:12:51.126]                           for (restart in restarts) {
[16:12:51.126]                             name <- restart$name
[16:12:51.126]                             if (is.null(name)) 
[16:12:51.126]                               next
[16:12:51.126]                             if (!grepl(pattern, name)) 
[16:12:51.126]                               next
[16:12:51.126]                             invokeRestart(restart)
[16:12:51.126]                             muffled <- TRUE
[16:12:51.126]                             break
[16:12:51.126]                           }
[16:12:51.126]                         }
[16:12:51.126]                       }
[16:12:51.126]                       invisible(muffled)
[16:12:51.126]                     }
[16:12:51.126]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.126]                   }
[16:12:51.126]                 }
[16:12:51.126]             }
[16:12:51.126]         }))
[16:12:51.126]     }, error = function(ex) {
[16:12:51.126]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.126]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.126]                 ...future.rng), started = ...future.startTime, 
[16:12:51.126]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.126]             version = "1.8"), class = "FutureResult")
[16:12:51.126]     }, finally = {
[16:12:51.126]         if (!identical(...future.workdir, getwd())) 
[16:12:51.126]             setwd(...future.workdir)
[16:12:51.126]         {
[16:12:51.126]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.126]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.126]             }
[16:12:51.126]             base::options(...future.oldOptions)
[16:12:51.126]             if (.Platform$OS.type == "windows") {
[16:12:51.126]                 old_names <- names(...future.oldEnvVars)
[16:12:51.126]                 envs <- base::Sys.getenv()
[16:12:51.126]                 names <- names(envs)
[16:12:51.126]                 common <- intersect(names, old_names)
[16:12:51.126]                 added <- setdiff(names, old_names)
[16:12:51.126]                 removed <- setdiff(old_names, names)
[16:12:51.126]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.126]                   envs[common]]
[16:12:51.126]                 NAMES <- toupper(changed)
[16:12:51.126]                 args <- list()
[16:12:51.126]                 for (kk in seq_along(NAMES)) {
[16:12:51.126]                   name <- changed[[kk]]
[16:12:51.126]                   NAME <- NAMES[[kk]]
[16:12:51.126]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.126]                     next
[16:12:51.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.126]                 }
[16:12:51.126]                 NAMES <- toupper(added)
[16:12:51.126]                 for (kk in seq_along(NAMES)) {
[16:12:51.126]                   name <- added[[kk]]
[16:12:51.126]                   NAME <- NAMES[[kk]]
[16:12:51.126]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.126]                     next
[16:12:51.126]                   args[[name]] <- ""
[16:12:51.126]                 }
[16:12:51.126]                 NAMES <- toupper(removed)
[16:12:51.126]                 for (kk in seq_along(NAMES)) {
[16:12:51.126]                   name <- removed[[kk]]
[16:12:51.126]                   NAME <- NAMES[[kk]]
[16:12:51.126]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.126]                     next
[16:12:51.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.126]                 }
[16:12:51.126]                 if (length(args) > 0) 
[16:12:51.126]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.126]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.126]             }
[16:12:51.126]             else {
[16:12:51.126]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.126]             }
[16:12:51.126]             {
[16:12:51.126]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.126]                   0L) {
[16:12:51.126]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.126]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.126]                   base::options(opts)
[16:12:51.126]                 }
[16:12:51.126]                 {
[16:12:51.126]                   {
[16:12:51.126]                     NULL
[16:12:51.126]                     RNGkind("Mersenne-Twister")
[16:12:51.126]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.126]                       inherits = FALSE)
[16:12:51.126]                   }
[16:12:51.126]                   options(future.plan = NULL)
[16:12:51.126]                   if (is.na(NA_character_)) 
[16:12:51.126]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.126]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.126]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.126]                   {
[16:12:51.126]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.126]                     if (!future$lazy) 
[16:12:51.126]                       future <- run(future)
[16:12:51.126]                     invisible(future)
[16:12:51.126]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.126]                 }
[16:12:51.126]             }
[16:12:51.126]         }
[16:12:51.126]     })
[16:12:51.126]     if (TRUE) {
[16:12:51.126]         base::sink(type = "output", split = FALSE)
[16:12:51.126]         if (TRUE) {
[16:12:51.126]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.126]         }
[16:12:51.126]         else {
[16:12:51.126]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.126]         }
[16:12:51.126]         base::close(...future.stdout)
[16:12:51.126]         ...future.stdout <- NULL
[16:12:51.126]     }
[16:12:51.126]     ...future.result$conditions <- ...future.conditions
[16:12:51.126]     ...future.result$finished <- base::Sys.time()
[16:12:51.126]     ...future.result
[16:12:51.126] }
[16:12:51.127] assign_globals() ...
[16:12:51.128] List of 1
[16:12:51.128]  $ a: num 3
[16:12:51.128]  - attr(*, "where")=List of 1
[16:12:51.128]   ..$ a:<environment: R_EmptyEnv> 
[16:12:51.128]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.128]  - attr(*, "resolved")= logi TRUE
[16:12:51.128]  - attr(*, "total_size")= num 56
[16:12:51.128]  - attr(*, "already-done")= logi TRUE
[16:12:51.130] - copied ‘a’ to environment
[16:12:51.130] assign_globals() ... done
[16:12:51.130] plan(): Setting new future strategy stack:
[16:12:51.130] List of future strategies:
[16:12:51.130] 1. sequential:
[16:12:51.130]    - args: function (..., envir = parent.frame())
[16:12:51.130]    - tweaked: FALSE
[16:12:51.130]    - call: NULL
[16:12:51.131] plan(): nbrOfWorkers() = 1
[16:12:51.131] plan(): Setting new future strategy stack:
[16:12:51.131] List of future strategies:
[16:12:51.131] 1. sequential:
[16:12:51.131]    - args: function (..., envir = parent.frame())
[16:12:51.131]    - tweaked: FALSE
[16:12:51.131]    - call: plan(strategy)
[16:12:51.132] plan(): nbrOfWorkers() = 1
[16:12:51.132] SequentialFuture started (and completed)
[16:12:51.132] - Launch lazy future ... done
[16:12:51.132] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.133] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.133] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:51.136] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:51.137] Searching for globals ... DONE
[16:12:51.137] Resolving globals: TRUE
[16:12:51.137] Resolving any globals that are futures ...
[16:12:51.137] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:51.137] Resolving any globals that are futures ... DONE
[16:12:51.137] Resolving futures part of globals (recursively) ...
[16:12:51.138] resolve() on list ...
[16:12:51.138]  recursive: 99
[16:12:51.138]  length: 2
[16:12:51.138]  elements: ‘a’, ‘ii’
[16:12:51.138]  length: 1 (resolved future 1)
[16:12:51.138]  length: 0 (resolved future 2)
[16:12:51.138] resolve() on list ... DONE
[16:12:51.138] - globals: [2] ‘a’, ‘ii’
[16:12:51.138] Resolving futures part of globals (recursively) ... DONE
[16:12:51.139] The total size of the 2 globals is 112 bytes (112 bytes)
[16:12:51.139] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:12:51.139] - globals: [2] ‘a’, ‘ii’
[16:12:51.139] 
[16:12:51.139] getGlobalsAndPackages() ... DONE
[16:12:51.139] run() for ‘Future’ ...
[16:12:51.140] - state: ‘created’
[16:12:51.140] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.140] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.140] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.140]   - Field: ‘label’
[16:12:51.140]   - Field: ‘local’
[16:12:51.140]   - Field: ‘owner’
[16:12:51.140]   - Field: ‘envir’
[16:12:51.141]   - Field: ‘packages’
[16:12:51.141]   - Field: ‘gc’
[16:12:51.141]   - Field: ‘conditions’
[16:12:51.141]   - Field: ‘expr’
[16:12:51.141]   - Field: ‘uuid’
[16:12:51.141]   - Field: ‘seed’
[16:12:51.141]   - Field: ‘version’
[16:12:51.141]   - Field: ‘result’
[16:12:51.141]   - Field: ‘asynchronous’
[16:12:51.141]   - Field: ‘calls’
[16:12:51.142]   - Field: ‘globals’
[16:12:51.142]   - Field: ‘stdout’
[16:12:51.142]   - Field: ‘earlySignal’
[16:12:51.142]   - Field: ‘lazy’
[16:12:51.142]   - Field: ‘state’
[16:12:51.142] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.142] - Launch lazy future ...
[16:12:51.142] Packages needed by the future expression (n = 0): <none>
[16:12:51.142] Packages needed by future strategies (n = 0): <none>
[16:12:51.143] {
[16:12:51.143]     {
[16:12:51.143]         {
[16:12:51.143]             ...future.startTime <- base::Sys.time()
[16:12:51.143]             {
[16:12:51.143]                 {
[16:12:51.143]                   {
[16:12:51.143]                     base::local({
[16:12:51.143]                       has_future <- base::requireNamespace("future", 
[16:12:51.143]                         quietly = TRUE)
[16:12:51.143]                       if (has_future) {
[16:12:51.143]                         ns <- base::getNamespace("future")
[16:12:51.143]                         version <- ns[[".package"]][["version"]]
[16:12:51.143]                         if (is.null(version)) 
[16:12:51.143]                           version <- utils::packageVersion("future")
[16:12:51.143]                       }
[16:12:51.143]                       else {
[16:12:51.143]                         version <- NULL
[16:12:51.143]                       }
[16:12:51.143]                       if (!has_future || version < "1.8.0") {
[16:12:51.143]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.143]                           "", base::R.version$version.string), 
[16:12:51.143]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:51.143]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.143]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.143]                             "release", "version")], collapse = " "), 
[16:12:51.143]                           hostname = base::Sys.info()[["nodename"]])
[16:12:51.143]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.143]                           info)
[16:12:51.143]                         info <- base::paste(info, collapse = "; ")
[16:12:51.143]                         if (!has_future) {
[16:12:51.143]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.143]                             info)
[16:12:51.143]                         }
[16:12:51.143]                         else {
[16:12:51.143]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.143]                             info, version)
[16:12:51.143]                         }
[16:12:51.143]                         base::stop(msg)
[16:12:51.143]                       }
[16:12:51.143]                     })
[16:12:51.143]                   }
[16:12:51.143]                   options(future.plan = NULL)
[16:12:51.143]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.143]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.143]                 }
[16:12:51.143]                 ...future.workdir <- getwd()
[16:12:51.143]             }
[16:12:51.143]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.143]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.143]         }
[16:12:51.143]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.143]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:51.143]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.143]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.143]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.143]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.143]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.143]             base::names(...future.oldOptions))
[16:12:51.143]     }
[16:12:51.143]     if (FALSE) {
[16:12:51.143]     }
[16:12:51.143]     else {
[16:12:51.143]         if (TRUE) {
[16:12:51.143]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.143]                 open = "w")
[16:12:51.143]         }
[16:12:51.143]         else {
[16:12:51.143]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.143]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.143]         }
[16:12:51.143]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.143]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.143]             base::sink(type = "output", split = FALSE)
[16:12:51.143]             base::close(...future.stdout)
[16:12:51.143]         }, add = TRUE)
[16:12:51.143]     }
[16:12:51.143]     ...future.frame <- base::sys.nframe()
[16:12:51.143]     ...future.conditions <- base::list()
[16:12:51.143]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.143]     if (FALSE) {
[16:12:51.143]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.143]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.143]     }
[16:12:51.143]     ...future.result <- base::tryCatch({
[16:12:51.143]         base::withCallingHandlers({
[16:12:51.143]             ...future.value <- base::withVisible(base::local({
[16:12:51.143]                 b <- a * ii
[16:12:51.143]                 a <- 0
[16:12:51.143]                 b
[16:12:51.143]             }))
[16:12:51.143]             future::FutureResult(value = ...future.value$value, 
[16:12:51.143]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.143]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.143]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.143]                     ...future.globalenv.names))
[16:12:51.143]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.143]         }, condition = base::local({
[16:12:51.143]             c <- base::c
[16:12:51.143]             inherits <- base::inherits
[16:12:51.143]             invokeRestart <- base::invokeRestart
[16:12:51.143]             length <- base::length
[16:12:51.143]             list <- base::list
[16:12:51.143]             seq.int <- base::seq.int
[16:12:51.143]             signalCondition <- base::signalCondition
[16:12:51.143]             sys.calls <- base::sys.calls
[16:12:51.143]             `[[` <- base::`[[`
[16:12:51.143]             `+` <- base::`+`
[16:12:51.143]             `<<-` <- base::`<<-`
[16:12:51.143]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.143]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.143]                   3L)]
[16:12:51.143]             }
[16:12:51.143]             function(cond) {
[16:12:51.143]                 is_error <- inherits(cond, "error")
[16:12:51.143]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.143]                   NULL)
[16:12:51.143]                 if (is_error) {
[16:12:51.143]                   sessionInformation <- function() {
[16:12:51.143]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.143]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.143]                       search = base::search(), system = base::Sys.info())
[16:12:51.143]                   }
[16:12:51.143]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.143]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.143]                     cond$call), session = sessionInformation(), 
[16:12:51.143]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.143]                   signalCondition(cond)
[16:12:51.143]                 }
[16:12:51.143]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.143]                 "immediateCondition"))) {
[16:12:51.143]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.143]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.143]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.143]                   if (TRUE && !signal) {
[16:12:51.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.143]                     {
[16:12:51.143]                       inherits <- base::inherits
[16:12:51.143]                       invokeRestart <- base::invokeRestart
[16:12:51.143]                       is.null <- base::is.null
[16:12:51.143]                       muffled <- FALSE
[16:12:51.143]                       if (inherits(cond, "message")) {
[16:12:51.143]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.143]                         if (muffled) 
[16:12:51.143]                           invokeRestart("muffleMessage")
[16:12:51.143]                       }
[16:12:51.143]                       else if (inherits(cond, "warning")) {
[16:12:51.143]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.143]                         if (muffled) 
[16:12:51.143]                           invokeRestart("muffleWarning")
[16:12:51.143]                       }
[16:12:51.143]                       else if (inherits(cond, "condition")) {
[16:12:51.143]                         if (!is.null(pattern)) {
[16:12:51.143]                           computeRestarts <- base::computeRestarts
[16:12:51.143]                           grepl <- base::grepl
[16:12:51.143]                           restarts <- computeRestarts(cond)
[16:12:51.143]                           for (restart in restarts) {
[16:12:51.143]                             name <- restart$name
[16:12:51.143]                             if (is.null(name)) 
[16:12:51.143]                               next
[16:12:51.143]                             if (!grepl(pattern, name)) 
[16:12:51.143]                               next
[16:12:51.143]                             invokeRestart(restart)
[16:12:51.143]                             muffled <- TRUE
[16:12:51.143]                             break
[16:12:51.143]                           }
[16:12:51.143]                         }
[16:12:51.143]                       }
[16:12:51.143]                       invisible(muffled)
[16:12:51.143]                     }
[16:12:51.143]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.143]                   }
[16:12:51.143]                 }
[16:12:51.143]                 else {
[16:12:51.143]                   if (TRUE) {
[16:12:51.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.143]                     {
[16:12:51.143]                       inherits <- base::inherits
[16:12:51.143]                       invokeRestart <- base::invokeRestart
[16:12:51.143]                       is.null <- base::is.null
[16:12:51.143]                       muffled <- FALSE
[16:12:51.143]                       if (inherits(cond, "message")) {
[16:12:51.143]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.143]                         if (muffled) 
[16:12:51.143]                           invokeRestart("muffleMessage")
[16:12:51.143]                       }
[16:12:51.143]                       else if (inherits(cond, "warning")) {
[16:12:51.143]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.143]                         if (muffled) 
[16:12:51.143]                           invokeRestart("muffleWarning")
[16:12:51.143]                       }
[16:12:51.143]                       else if (inherits(cond, "condition")) {
[16:12:51.143]                         if (!is.null(pattern)) {
[16:12:51.143]                           computeRestarts <- base::computeRestarts
[16:12:51.143]                           grepl <- base::grepl
[16:12:51.143]                           restarts <- computeRestarts(cond)
[16:12:51.143]                           for (restart in restarts) {
[16:12:51.143]                             name <- restart$name
[16:12:51.143]                             if (is.null(name)) 
[16:12:51.143]                               next
[16:12:51.143]                             if (!grepl(pattern, name)) 
[16:12:51.143]                               next
[16:12:51.143]                             invokeRestart(restart)
[16:12:51.143]                             muffled <- TRUE
[16:12:51.143]                             break
[16:12:51.143]                           }
[16:12:51.143]                         }
[16:12:51.143]                       }
[16:12:51.143]                       invisible(muffled)
[16:12:51.143]                     }
[16:12:51.143]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.143]                   }
[16:12:51.143]                 }
[16:12:51.143]             }
[16:12:51.143]         }))
[16:12:51.143]     }, error = function(ex) {
[16:12:51.143]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.143]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.143]                 ...future.rng), started = ...future.startTime, 
[16:12:51.143]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.143]             version = "1.8"), class = "FutureResult")
[16:12:51.143]     }, finally = {
[16:12:51.143]         if (!identical(...future.workdir, getwd())) 
[16:12:51.143]             setwd(...future.workdir)
[16:12:51.143]         {
[16:12:51.143]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.143]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.143]             }
[16:12:51.143]             base::options(...future.oldOptions)
[16:12:51.143]             if (.Platform$OS.type == "windows") {
[16:12:51.143]                 old_names <- names(...future.oldEnvVars)
[16:12:51.143]                 envs <- base::Sys.getenv()
[16:12:51.143]                 names <- names(envs)
[16:12:51.143]                 common <- intersect(names, old_names)
[16:12:51.143]                 added <- setdiff(names, old_names)
[16:12:51.143]                 removed <- setdiff(old_names, names)
[16:12:51.143]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.143]                   envs[common]]
[16:12:51.143]                 NAMES <- toupper(changed)
[16:12:51.143]                 args <- list()
[16:12:51.143]                 for (kk in seq_along(NAMES)) {
[16:12:51.143]                   name <- changed[[kk]]
[16:12:51.143]                   NAME <- NAMES[[kk]]
[16:12:51.143]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.143]                     next
[16:12:51.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.143]                 }
[16:12:51.143]                 NAMES <- toupper(added)
[16:12:51.143]                 for (kk in seq_along(NAMES)) {
[16:12:51.143]                   name <- added[[kk]]
[16:12:51.143]                   NAME <- NAMES[[kk]]
[16:12:51.143]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.143]                     next
[16:12:51.143]                   args[[name]] <- ""
[16:12:51.143]                 }
[16:12:51.143]                 NAMES <- toupper(removed)
[16:12:51.143]                 for (kk in seq_along(NAMES)) {
[16:12:51.143]                   name <- removed[[kk]]
[16:12:51.143]                   NAME <- NAMES[[kk]]
[16:12:51.143]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.143]                     next
[16:12:51.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.143]                 }
[16:12:51.143]                 if (length(args) > 0) 
[16:12:51.143]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.143]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.143]             }
[16:12:51.143]             else {
[16:12:51.143]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.143]             }
[16:12:51.143]             {
[16:12:51.143]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.143]                   0L) {
[16:12:51.143]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.143]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.143]                   base::options(opts)
[16:12:51.143]                 }
[16:12:51.143]                 {
[16:12:51.143]                   {
[16:12:51.143]                     NULL
[16:12:51.143]                     RNGkind("Mersenne-Twister")
[16:12:51.143]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.143]                       inherits = FALSE)
[16:12:51.143]                   }
[16:12:51.143]                   options(future.plan = NULL)
[16:12:51.143]                   if (is.na(NA_character_)) 
[16:12:51.143]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.143]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.143]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.143]                   {
[16:12:51.143]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.143]                     if (!future$lazy) 
[16:12:51.143]                       future <- run(future)
[16:12:51.143]                     invisible(future)
[16:12:51.143]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.143]                 }
[16:12:51.143]             }
[16:12:51.143]         }
[16:12:51.143]     })
[16:12:51.143]     if (TRUE) {
[16:12:51.143]         base::sink(type = "output", split = FALSE)
[16:12:51.143]         if (TRUE) {
[16:12:51.143]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.143]         }
[16:12:51.143]         else {
[16:12:51.143]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.143]         }
[16:12:51.143]         base::close(...future.stdout)
[16:12:51.143]         ...future.stdout <- NULL
[16:12:51.143]     }
[16:12:51.143]     ...future.result$conditions <- ...future.conditions
[16:12:51.143]     ...future.result$finished <- base::Sys.time()
[16:12:51.143]     ...future.result
[16:12:51.143] }
[16:12:51.144] assign_globals() ...
[16:12:51.145] List of 2
[16:12:51.145]  $ a : num 1
[16:12:51.145]  $ ii: int 1
[16:12:51.145]  - attr(*, "where")=List of 2
[16:12:51.145]   ..$ a :<environment: R_EmptyEnv> 
[16:12:51.145]   ..$ ii:<environment: R_EmptyEnv> 
[16:12:51.145]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.145]  - attr(*, "resolved")= logi TRUE
[16:12:51.145]  - attr(*, "total_size")= num 112
[16:12:51.145]  - attr(*, "already-done")= logi TRUE
[16:12:51.147] - copied ‘a’ to environment
[16:12:51.148] - copied ‘ii’ to environment
[16:12:51.148] assign_globals() ... done
[16:12:51.148] plan(): Setting new future strategy stack:
[16:12:51.148] List of future strategies:
[16:12:51.148] 1. sequential:
[16:12:51.148]    - args: function (..., envir = parent.frame())
[16:12:51.148]    - tweaked: FALSE
[16:12:51.148]    - call: NULL
[16:12:51.148] plan(): nbrOfWorkers() = 1
[16:12:51.149] plan(): Setting new future strategy stack:
[16:12:51.149] List of future strategies:
[16:12:51.149] 1. sequential:
[16:12:51.149]    - args: function (..., envir = parent.frame())
[16:12:51.149]    - tweaked: FALSE
[16:12:51.149]    - call: plan(strategy)
[16:12:51.149] plan(): nbrOfWorkers() = 1
[16:12:51.150] SequentialFuture started (and completed)
[16:12:51.150] - Launch lazy future ... done
[16:12:51.150] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.150] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.151] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:51.152] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:51.152] Searching for globals ... DONE
[16:12:51.153] Resolving globals: TRUE
[16:12:51.153] Resolving any globals that are futures ...
[16:12:51.153] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:51.153] Resolving any globals that are futures ... DONE
[16:12:51.153] Resolving futures part of globals (recursively) ...
[16:12:51.153] resolve() on list ...
[16:12:51.153]  recursive: 99
[16:12:51.154]  length: 2
[16:12:51.154]  elements: ‘a’, ‘ii’
[16:12:51.154]  length: 1 (resolved future 1)
[16:12:51.154]  length: 0 (resolved future 2)
[16:12:51.154] resolve() on list ... DONE
[16:12:51.154] - globals: [2] ‘a’, ‘ii’
[16:12:51.154] Resolving futures part of globals (recursively) ... DONE
[16:12:51.154] The total size of the 2 globals is 112 bytes (112 bytes)
[16:12:51.155] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:12:51.155] - globals: [2] ‘a’, ‘ii’
[16:12:51.155] 
[16:12:51.155] getGlobalsAndPackages() ... DONE
[16:12:51.155] run() for ‘Future’ ...
[16:12:51.155] - state: ‘created’
[16:12:51.155] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.156] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.156] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.156]   - Field: ‘label’
[16:12:51.156]   - Field: ‘local’
[16:12:51.156]   - Field: ‘owner’
[16:12:51.156]   - Field: ‘envir’
[16:12:51.156]   - Field: ‘packages’
[16:12:51.156]   - Field: ‘gc’
[16:12:51.156]   - Field: ‘conditions’
[16:12:51.157]   - Field: ‘expr’
[16:12:51.157]   - Field: ‘uuid’
[16:12:51.157]   - Field: ‘seed’
[16:12:51.157]   - Field: ‘version’
[16:12:51.157]   - Field: ‘result’
[16:12:51.157]   - Field: ‘asynchronous’
[16:12:51.157]   - Field: ‘calls’
[16:12:51.157]   - Field: ‘globals’
[16:12:51.157]   - Field: ‘stdout’
[16:12:51.157]   - Field: ‘earlySignal’
[16:12:51.157]   - Field: ‘lazy’
[16:12:51.158]   - Field: ‘state’
[16:12:51.158] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.158] - Launch lazy future ...
[16:12:51.158] Packages needed by the future expression (n = 0): <none>
[16:12:51.158] Packages needed by future strategies (n = 0): <none>
[16:12:51.158] {
[16:12:51.158]     {
[16:12:51.158]         {
[16:12:51.158]             ...future.startTime <- base::Sys.time()
[16:12:51.158]             {
[16:12:51.158]                 {
[16:12:51.158]                   {
[16:12:51.158]                     base::local({
[16:12:51.158]                       has_future <- base::requireNamespace("future", 
[16:12:51.158]                         quietly = TRUE)
[16:12:51.158]                       if (has_future) {
[16:12:51.158]                         ns <- base::getNamespace("future")
[16:12:51.158]                         version <- ns[[".package"]][["version"]]
[16:12:51.158]                         if (is.null(version)) 
[16:12:51.158]                           version <- utils::packageVersion("future")
[16:12:51.158]                       }
[16:12:51.158]                       else {
[16:12:51.158]                         version <- NULL
[16:12:51.158]                       }
[16:12:51.158]                       if (!has_future || version < "1.8.0") {
[16:12:51.158]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.158]                           "", base::R.version$version.string), 
[16:12:51.158]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:51.158]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.158]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.158]                             "release", "version")], collapse = " "), 
[16:12:51.158]                           hostname = base::Sys.info()[["nodename"]])
[16:12:51.158]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.158]                           info)
[16:12:51.158]                         info <- base::paste(info, collapse = "; ")
[16:12:51.158]                         if (!has_future) {
[16:12:51.158]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.158]                             info)
[16:12:51.158]                         }
[16:12:51.158]                         else {
[16:12:51.158]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.158]                             info, version)
[16:12:51.158]                         }
[16:12:51.158]                         base::stop(msg)
[16:12:51.158]                       }
[16:12:51.158]                     })
[16:12:51.158]                   }
[16:12:51.158]                   options(future.plan = NULL)
[16:12:51.158]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.158]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.158]                 }
[16:12:51.158]                 ...future.workdir <- getwd()
[16:12:51.158]             }
[16:12:51.158]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.158]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.158]         }
[16:12:51.158]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.158]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:51.158]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.158]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.158]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.158]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.158]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.158]             base::names(...future.oldOptions))
[16:12:51.158]     }
[16:12:51.158]     if (FALSE) {
[16:12:51.158]     }
[16:12:51.158]     else {
[16:12:51.158]         if (TRUE) {
[16:12:51.158]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.158]                 open = "w")
[16:12:51.158]         }
[16:12:51.158]         else {
[16:12:51.158]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.158]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.158]         }
[16:12:51.158]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.158]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.158]             base::sink(type = "output", split = FALSE)
[16:12:51.158]             base::close(...future.stdout)
[16:12:51.158]         }, add = TRUE)
[16:12:51.158]     }
[16:12:51.158]     ...future.frame <- base::sys.nframe()
[16:12:51.158]     ...future.conditions <- base::list()
[16:12:51.158]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.158]     if (FALSE) {
[16:12:51.158]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.158]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.158]     }
[16:12:51.158]     ...future.result <- base::tryCatch({
[16:12:51.158]         base::withCallingHandlers({
[16:12:51.158]             ...future.value <- base::withVisible(base::local({
[16:12:51.158]                 b <- a * ii
[16:12:51.158]                 a <- 0
[16:12:51.158]                 b
[16:12:51.158]             }))
[16:12:51.158]             future::FutureResult(value = ...future.value$value, 
[16:12:51.158]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.158]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.158]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.158]                     ...future.globalenv.names))
[16:12:51.158]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.158]         }, condition = base::local({
[16:12:51.158]             c <- base::c
[16:12:51.158]             inherits <- base::inherits
[16:12:51.158]             invokeRestart <- base::invokeRestart
[16:12:51.158]             length <- base::length
[16:12:51.158]             list <- base::list
[16:12:51.158]             seq.int <- base::seq.int
[16:12:51.158]             signalCondition <- base::signalCondition
[16:12:51.158]             sys.calls <- base::sys.calls
[16:12:51.158]             `[[` <- base::`[[`
[16:12:51.158]             `+` <- base::`+`
[16:12:51.158]             `<<-` <- base::`<<-`
[16:12:51.158]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.158]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.158]                   3L)]
[16:12:51.158]             }
[16:12:51.158]             function(cond) {
[16:12:51.158]                 is_error <- inherits(cond, "error")
[16:12:51.158]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.158]                   NULL)
[16:12:51.158]                 if (is_error) {
[16:12:51.158]                   sessionInformation <- function() {
[16:12:51.158]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.158]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.158]                       search = base::search(), system = base::Sys.info())
[16:12:51.158]                   }
[16:12:51.158]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.158]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.158]                     cond$call), session = sessionInformation(), 
[16:12:51.158]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.158]                   signalCondition(cond)
[16:12:51.158]                 }
[16:12:51.158]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.158]                 "immediateCondition"))) {
[16:12:51.158]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.158]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.158]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.158]                   if (TRUE && !signal) {
[16:12:51.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.158]                     {
[16:12:51.158]                       inherits <- base::inherits
[16:12:51.158]                       invokeRestart <- base::invokeRestart
[16:12:51.158]                       is.null <- base::is.null
[16:12:51.158]                       muffled <- FALSE
[16:12:51.158]                       if (inherits(cond, "message")) {
[16:12:51.158]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.158]                         if (muffled) 
[16:12:51.158]                           invokeRestart("muffleMessage")
[16:12:51.158]                       }
[16:12:51.158]                       else if (inherits(cond, "warning")) {
[16:12:51.158]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.158]                         if (muffled) 
[16:12:51.158]                           invokeRestart("muffleWarning")
[16:12:51.158]                       }
[16:12:51.158]                       else if (inherits(cond, "condition")) {
[16:12:51.158]                         if (!is.null(pattern)) {
[16:12:51.158]                           computeRestarts <- base::computeRestarts
[16:12:51.158]                           grepl <- base::grepl
[16:12:51.158]                           restarts <- computeRestarts(cond)
[16:12:51.158]                           for (restart in restarts) {
[16:12:51.158]                             name <- restart$name
[16:12:51.158]                             if (is.null(name)) 
[16:12:51.158]                               next
[16:12:51.158]                             if (!grepl(pattern, name)) 
[16:12:51.158]                               next
[16:12:51.158]                             invokeRestart(restart)
[16:12:51.158]                             muffled <- TRUE
[16:12:51.158]                             break
[16:12:51.158]                           }
[16:12:51.158]                         }
[16:12:51.158]                       }
[16:12:51.158]                       invisible(muffled)
[16:12:51.158]                     }
[16:12:51.158]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.158]                   }
[16:12:51.158]                 }
[16:12:51.158]                 else {
[16:12:51.158]                   if (TRUE) {
[16:12:51.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.158]                     {
[16:12:51.158]                       inherits <- base::inherits
[16:12:51.158]                       invokeRestart <- base::invokeRestart
[16:12:51.158]                       is.null <- base::is.null
[16:12:51.158]                       muffled <- FALSE
[16:12:51.158]                       if (inherits(cond, "message")) {
[16:12:51.158]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.158]                         if (muffled) 
[16:12:51.158]                           invokeRestart("muffleMessage")
[16:12:51.158]                       }
[16:12:51.158]                       else if (inherits(cond, "warning")) {
[16:12:51.158]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.158]                         if (muffled) 
[16:12:51.158]                           invokeRestart("muffleWarning")
[16:12:51.158]                       }
[16:12:51.158]                       else if (inherits(cond, "condition")) {
[16:12:51.158]                         if (!is.null(pattern)) {
[16:12:51.158]                           computeRestarts <- base::computeRestarts
[16:12:51.158]                           grepl <- base::grepl
[16:12:51.158]                           restarts <- computeRestarts(cond)
[16:12:51.158]                           for (restart in restarts) {
[16:12:51.158]                             name <- restart$name
[16:12:51.158]                             if (is.null(name)) 
[16:12:51.158]                               next
[16:12:51.158]                             if (!grepl(pattern, name)) 
[16:12:51.158]                               next
[16:12:51.158]                             invokeRestart(restart)
[16:12:51.158]                             muffled <- TRUE
[16:12:51.158]                             break
[16:12:51.158]                           }
[16:12:51.158]                         }
[16:12:51.158]                       }
[16:12:51.158]                       invisible(muffled)
[16:12:51.158]                     }
[16:12:51.158]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.158]                   }
[16:12:51.158]                 }
[16:12:51.158]             }
[16:12:51.158]         }))
[16:12:51.158]     }, error = function(ex) {
[16:12:51.158]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.158]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.158]                 ...future.rng), started = ...future.startTime, 
[16:12:51.158]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.158]             version = "1.8"), class = "FutureResult")
[16:12:51.158]     }, finally = {
[16:12:51.158]         if (!identical(...future.workdir, getwd())) 
[16:12:51.158]             setwd(...future.workdir)
[16:12:51.158]         {
[16:12:51.158]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.158]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.158]             }
[16:12:51.158]             base::options(...future.oldOptions)
[16:12:51.158]             if (.Platform$OS.type == "windows") {
[16:12:51.158]                 old_names <- names(...future.oldEnvVars)
[16:12:51.158]                 envs <- base::Sys.getenv()
[16:12:51.158]                 names <- names(envs)
[16:12:51.158]                 common <- intersect(names, old_names)
[16:12:51.158]                 added <- setdiff(names, old_names)
[16:12:51.158]                 removed <- setdiff(old_names, names)
[16:12:51.158]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.158]                   envs[common]]
[16:12:51.158]                 NAMES <- toupper(changed)
[16:12:51.158]                 args <- list()
[16:12:51.158]                 for (kk in seq_along(NAMES)) {
[16:12:51.158]                   name <- changed[[kk]]
[16:12:51.158]                   NAME <- NAMES[[kk]]
[16:12:51.158]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.158]                     next
[16:12:51.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.158]                 }
[16:12:51.158]                 NAMES <- toupper(added)
[16:12:51.158]                 for (kk in seq_along(NAMES)) {
[16:12:51.158]                   name <- added[[kk]]
[16:12:51.158]                   NAME <- NAMES[[kk]]
[16:12:51.158]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.158]                     next
[16:12:51.158]                   args[[name]] <- ""
[16:12:51.158]                 }
[16:12:51.158]                 NAMES <- toupper(removed)
[16:12:51.158]                 for (kk in seq_along(NAMES)) {
[16:12:51.158]                   name <- removed[[kk]]
[16:12:51.158]                   NAME <- NAMES[[kk]]
[16:12:51.158]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.158]                     next
[16:12:51.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.158]                 }
[16:12:51.158]                 if (length(args) > 0) 
[16:12:51.158]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.158]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.158]             }
[16:12:51.158]             else {
[16:12:51.158]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.158]             }
[16:12:51.158]             {
[16:12:51.158]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.158]                   0L) {
[16:12:51.158]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.158]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.158]                   base::options(opts)
[16:12:51.158]                 }
[16:12:51.158]                 {
[16:12:51.158]                   {
[16:12:51.158]                     NULL
[16:12:51.158]                     RNGkind("Mersenne-Twister")
[16:12:51.158]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.158]                       inherits = FALSE)
[16:12:51.158]                   }
[16:12:51.158]                   options(future.plan = NULL)
[16:12:51.158]                   if (is.na(NA_character_)) 
[16:12:51.158]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.158]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.158]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.158]                   {
[16:12:51.158]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.158]                     if (!future$lazy) 
[16:12:51.158]                       future <- run(future)
[16:12:51.158]                     invisible(future)
[16:12:51.158]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.158]                 }
[16:12:51.158]             }
[16:12:51.158]         }
[16:12:51.158]     })
[16:12:51.158]     if (TRUE) {
[16:12:51.158]         base::sink(type = "output", split = FALSE)
[16:12:51.158]         if (TRUE) {
[16:12:51.158]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.158]         }
[16:12:51.158]         else {
[16:12:51.158]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.158]         }
[16:12:51.158]         base::close(...future.stdout)
[16:12:51.158]         ...future.stdout <- NULL
[16:12:51.158]     }
[16:12:51.158]     ...future.result$conditions <- ...future.conditions
[16:12:51.158]     ...future.result$finished <- base::Sys.time()
[16:12:51.158]     ...future.result
[16:12:51.158] }
[16:12:51.162] assign_globals() ...
[16:12:51.162] List of 2
[16:12:51.162]  $ a : num 1
[16:12:51.162]  $ ii: int 2
[16:12:51.162]  - attr(*, "where")=List of 2
[16:12:51.162]   ..$ a :<environment: R_EmptyEnv> 
[16:12:51.162]   ..$ ii:<environment: R_EmptyEnv> 
[16:12:51.162]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.162]  - attr(*, "resolved")= logi TRUE
[16:12:51.162]  - attr(*, "total_size")= num 112
[16:12:51.162]  - attr(*, "already-done")= logi TRUE
[16:12:51.165] - copied ‘a’ to environment
[16:12:51.165] - copied ‘ii’ to environment
[16:12:51.165] assign_globals() ... done
[16:12:51.165] plan(): Setting new future strategy stack:
[16:12:51.165] List of future strategies:
[16:12:51.165] 1. sequential:
[16:12:51.165]    - args: function (..., envir = parent.frame())
[16:12:51.165]    - tweaked: FALSE
[16:12:51.165]    - call: NULL
[16:12:51.166] plan(): nbrOfWorkers() = 1
[16:12:51.166] plan(): Setting new future strategy stack:
[16:12:51.166] List of future strategies:
[16:12:51.166] 1. sequential:
[16:12:51.166]    - args: function (..., envir = parent.frame())
[16:12:51.166]    - tweaked: FALSE
[16:12:51.166]    - call: plan(strategy)
[16:12:51.167] plan(): nbrOfWorkers() = 1
[16:12:51.167] SequentialFuture started (and completed)
[16:12:51.167] - Launch lazy future ... done
[16:12:51.167] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.168] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.168] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:51.170] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:51.170] Searching for globals ... DONE
[16:12:51.170] Resolving globals: TRUE
[16:12:51.170] Resolving any globals that are futures ...
[16:12:51.170] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:51.170] Resolving any globals that are futures ... DONE
[16:12:51.170] Resolving futures part of globals (recursively) ...
[16:12:51.171] resolve() on list ...
[16:12:51.171]  recursive: 99
[16:12:51.171]  length: 2
[16:12:51.171]  elements: ‘a’, ‘ii’
[16:12:51.171]  length: 1 (resolved future 1)
[16:12:51.171]  length: 0 (resolved future 2)
[16:12:51.171] resolve() on list ... DONE
[16:12:51.171] - globals: [2] ‘a’, ‘ii’
[16:12:51.171] Resolving futures part of globals (recursively) ... DONE
[16:12:51.172] The total size of the 2 globals is 112 bytes (112 bytes)
[16:12:51.172] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:12:51.172] - globals: [2] ‘a’, ‘ii’
[16:12:51.172] 
[16:12:51.172] getGlobalsAndPackages() ... DONE
[16:12:51.173] run() for ‘Future’ ...
[16:12:51.173] - state: ‘created’
[16:12:51.173] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.173] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.173] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.173]   - Field: ‘label’
[16:12:51.173]   - Field: ‘local’
[16:12:51.173]   - Field: ‘owner’
[16:12:51.173]   - Field: ‘envir’
[16:12:51.174]   - Field: ‘packages’
[16:12:51.174]   - Field: ‘gc’
[16:12:51.174]   - Field: ‘conditions’
[16:12:51.174]   - Field: ‘expr’
[16:12:51.174]   - Field: ‘uuid’
[16:12:51.174]   - Field: ‘seed’
[16:12:51.174]   - Field: ‘version’
[16:12:51.174]   - Field: ‘result’
[16:12:51.174]   - Field: ‘asynchronous’
[16:12:51.174]   - Field: ‘calls’
[16:12:51.174]   - Field: ‘globals’
[16:12:51.175]   - Field: ‘stdout’
[16:12:51.175]   - Field: ‘earlySignal’
[16:12:51.175]   - Field: ‘lazy’
[16:12:51.175]   - Field: ‘state’
[16:12:51.175] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.175] - Launch lazy future ...
[16:12:51.175] Packages needed by the future expression (n = 0): <none>
[16:12:51.175] Packages needed by future strategies (n = 0): <none>
[16:12:51.176] {
[16:12:51.176]     {
[16:12:51.176]         {
[16:12:51.176]             ...future.startTime <- base::Sys.time()
[16:12:51.176]             {
[16:12:51.176]                 {
[16:12:51.176]                   {
[16:12:51.176]                     base::local({
[16:12:51.176]                       has_future <- base::requireNamespace("future", 
[16:12:51.176]                         quietly = TRUE)
[16:12:51.176]                       if (has_future) {
[16:12:51.176]                         ns <- base::getNamespace("future")
[16:12:51.176]                         version <- ns[[".package"]][["version"]]
[16:12:51.176]                         if (is.null(version)) 
[16:12:51.176]                           version <- utils::packageVersion("future")
[16:12:51.176]                       }
[16:12:51.176]                       else {
[16:12:51.176]                         version <- NULL
[16:12:51.176]                       }
[16:12:51.176]                       if (!has_future || version < "1.8.0") {
[16:12:51.176]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.176]                           "", base::R.version$version.string), 
[16:12:51.176]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:51.176]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.176]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.176]                             "release", "version")], collapse = " "), 
[16:12:51.176]                           hostname = base::Sys.info()[["nodename"]])
[16:12:51.176]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.176]                           info)
[16:12:51.176]                         info <- base::paste(info, collapse = "; ")
[16:12:51.176]                         if (!has_future) {
[16:12:51.176]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.176]                             info)
[16:12:51.176]                         }
[16:12:51.176]                         else {
[16:12:51.176]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.176]                             info, version)
[16:12:51.176]                         }
[16:12:51.176]                         base::stop(msg)
[16:12:51.176]                       }
[16:12:51.176]                     })
[16:12:51.176]                   }
[16:12:51.176]                   options(future.plan = NULL)
[16:12:51.176]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.176]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.176]                 }
[16:12:51.176]                 ...future.workdir <- getwd()
[16:12:51.176]             }
[16:12:51.176]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.176]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.176]         }
[16:12:51.176]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.176]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:51.176]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.176]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.176]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.176]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.176]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.176]             base::names(...future.oldOptions))
[16:12:51.176]     }
[16:12:51.176]     if (FALSE) {
[16:12:51.176]     }
[16:12:51.176]     else {
[16:12:51.176]         if (TRUE) {
[16:12:51.176]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.176]                 open = "w")
[16:12:51.176]         }
[16:12:51.176]         else {
[16:12:51.176]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.176]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.176]         }
[16:12:51.176]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.176]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.176]             base::sink(type = "output", split = FALSE)
[16:12:51.176]             base::close(...future.stdout)
[16:12:51.176]         }, add = TRUE)
[16:12:51.176]     }
[16:12:51.176]     ...future.frame <- base::sys.nframe()
[16:12:51.176]     ...future.conditions <- base::list()
[16:12:51.176]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.176]     if (FALSE) {
[16:12:51.176]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.176]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.176]     }
[16:12:51.176]     ...future.result <- base::tryCatch({
[16:12:51.176]         base::withCallingHandlers({
[16:12:51.176]             ...future.value <- base::withVisible(base::local({
[16:12:51.176]                 b <- a * ii
[16:12:51.176]                 a <- 0
[16:12:51.176]                 b
[16:12:51.176]             }))
[16:12:51.176]             future::FutureResult(value = ...future.value$value, 
[16:12:51.176]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.176]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.176]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.176]                     ...future.globalenv.names))
[16:12:51.176]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.176]         }, condition = base::local({
[16:12:51.176]             c <- base::c
[16:12:51.176]             inherits <- base::inherits
[16:12:51.176]             invokeRestart <- base::invokeRestart
[16:12:51.176]             length <- base::length
[16:12:51.176]             list <- base::list
[16:12:51.176]             seq.int <- base::seq.int
[16:12:51.176]             signalCondition <- base::signalCondition
[16:12:51.176]             sys.calls <- base::sys.calls
[16:12:51.176]             `[[` <- base::`[[`
[16:12:51.176]             `+` <- base::`+`
[16:12:51.176]             `<<-` <- base::`<<-`
[16:12:51.176]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.176]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.176]                   3L)]
[16:12:51.176]             }
[16:12:51.176]             function(cond) {
[16:12:51.176]                 is_error <- inherits(cond, "error")
[16:12:51.176]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.176]                   NULL)
[16:12:51.176]                 if (is_error) {
[16:12:51.176]                   sessionInformation <- function() {
[16:12:51.176]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.176]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.176]                       search = base::search(), system = base::Sys.info())
[16:12:51.176]                   }
[16:12:51.176]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.176]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.176]                     cond$call), session = sessionInformation(), 
[16:12:51.176]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.176]                   signalCondition(cond)
[16:12:51.176]                 }
[16:12:51.176]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.176]                 "immediateCondition"))) {
[16:12:51.176]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.176]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.176]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.176]                   if (TRUE && !signal) {
[16:12:51.176]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.176]                     {
[16:12:51.176]                       inherits <- base::inherits
[16:12:51.176]                       invokeRestart <- base::invokeRestart
[16:12:51.176]                       is.null <- base::is.null
[16:12:51.176]                       muffled <- FALSE
[16:12:51.176]                       if (inherits(cond, "message")) {
[16:12:51.176]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.176]                         if (muffled) 
[16:12:51.176]                           invokeRestart("muffleMessage")
[16:12:51.176]                       }
[16:12:51.176]                       else if (inherits(cond, "warning")) {
[16:12:51.176]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.176]                         if (muffled) 
[16:12:51.176]                           invokeRestart("muffleWarning")
[16:12:51.176]                       }
[16:12:51.176]                       else if (inherits(cond, "condition")) {
[16:12:51.176]                         if (!is.null(pattern)) {
[16:12:51.176]                           computeRestarts <- base::computeRestarts
[16:12:51.176]                           grepl <- base::grepl
[16:12:51.176]                           restarts <- computeRestarts(cond)
[16:12:51.176]                           for (restart in restarts) {
[16:12:51.176]                             name <- restart$name
[16:12:51.176]                             if (is.null(name)) 
[16:12:51.176]                               next
[16:12:51.176]                             if (!grepl(pattern, name)) 
[16:12:51.176]                               next
[16:12:51.176]                             invokeRestart(restart)
[16:12:51.176]                             muffled <- TRUE
[16:12:51.176]                             break
[16:12:51.176]                           }
[16:12:51.176]                         }
[16:12:51.176]                       }
[16:12:51.176]                       invisible(muffled)
[16:12:51.176]                     }
[16:12:51.176]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.176]                   }
[16:12:51.176]                 }
[16:12:51.176]                 else {
[16:12:51.176]                   if (TRUE) {
[16:12:51.176]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.176]                     {
[16:12:51.176]                       inherits <- base::inherits
[16:12:51.176]                       invokeRestart <- base::invokeRestart
[16:12:51.176]                       is.null <- base::is.null
[16:12:51.176]                       muffled <- FALSE
[16:12:51.176]                       if (inherits(cond, "message")) {
[16:12:51.176]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.176]                         if (muffled) 
[16:12:51.176]                           invokeRestart("muffleMessage")
[16:12:51.176]                       }
[16:12:51.176]                       else if (inherits(cond, "warning")) {
[16:12:51.176]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.176]                         if (muffled) 
[16:12:51.176]                           invokeRestart("muffleWarning")
[16:12:51.176]                       }
[16:12:51.176]                       else if (inherits(cond, "condition")) {
[16:12:51.176]                         if (!is.null(pattern)) {
[16:12:51.176]                           computeRestarts <- base::computeRestarts
[16:12:51.176]                           grepl <- base::grepl
[16:12:51.176]                           restarts <- computeRestarts(cond)
[16:12:51.176]                           for (restart in restarts) {
[16:12:51.176]                             name <- restart$name
[16:12:51.176]                             if (is.null(name)) 
[16:12:51.176]                               next
[16:12:51.176]                             if (!grepl(pattern, name)) 
[16:12:51.176]                               next
[16:12:51.176]                             invokeRestart(restart)
[16:12:51.176]                             muffled <- TRUE
[16:12:51.176]                             break
[16:12:51.176]                           }
[16:12:51.176]                         }
[16:12:51.176]                       }
[16:12:51.176]                       invisible(muffled)
[16:12:51.176]                     }
[16:12:51.176]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.176]                   }
[16:12:51.176]                 }
[16:12:51.176]             }
[16:12:51.176]         }))
[16:12:51.176]     }, error = function(ex) {
[16:12:51.176]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.176]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.176]                 ...future.rng), started = ...future.startTime, 
[16:12:51.176]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.176]             version = "1.8"), class = "FutureResult")
[16:12:51.176]     }, finally = {
[16:12:51.176]         if (!identical(...future.workdir, getwd())) 
[16:12:51.176]             setwd(...future.workdir)
[16:12:51.176]         {
[16:12:51.176]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.176]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.176]             }
[16:12:51.176]             base::options(...future.oldOptions)
[16:12:51.176]             if (.Platform$OS.type == "windows") {
[16:12:51.176]                 old_names <- names(...future.oldEnvVars)
[16:12:51.176]                 envs <- base::Sys.getenv()
[16:12:51.176]                 names <- names(envs)
[16:12:51.176]                 common <- intersect(names, old_names)
[16:12:51.176]                 added <- setdiff(names, old_names)
[16:12:51.176]                 removed <- setdiff(old_names, names)
[16:12:51.176]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.176]                   envs[common]]
[16:12:51.176]                 NAMES <- toupper(changed)
[16:12:51.176]                 args <- list()
[16:12:51.176]                 for (kk in seq_along(NAMES)) {
[16:12:51.176]                   name <- changed[[kk]]
[16:12:51.176]                   NAME <- NAMES[[kk]]
[16:12:51.176]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.176]                     next
[16:12:51.176]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.176]                 }
[16:12:51.176]                 NAMES <- toupper(added)
[16:12:51.176]                 for (kk in seq_along(NAMES)) {
[16:12:51.176]                   name <- added[[kk]]
[16:12:51.176]                   NAME <- NAMES[[kk]]
[16:12:51.176]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.176]                     next
[16:12:51.176]                   args[[name]] <- ""
[16:12:51.176]                 }
[16:12:51.176]                 NAMES <- toupper(removed)
[16:12:51.176]                 for (kk in seq_along(NAMES)) {
[16:12:51.176]                   name <- removed[[kk]]
[16:12:51.176]                   NAME <- NAMES[[kk]]
[16:12:51.176]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.176]                     next
[16:12:51.176]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.176]                 }
[16:12:51.176]                 if (length(args) > 0) 
[16:12:51.176]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.176]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.176]             }
[16:12:51.176]             else {
[16:12:51.176]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.176]             }
[16:12:51.176]             {
[16:12:51.176]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.176]                   0L) {
[16:12:51.176]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.176]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.176]                   base::options(opts)
[16:12:51.176]                 }
[16:12:51.176]                 {
[16:12:51.176]                   {
[16:12:51.176]                     NULL
[16:12:51.176]                     RNGkind("Mersenne-Twister")
[16:12:51.176]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.176]                       inherits = FALSE)
[16:12:51.176]                   }
[16:12:51.176]                   options(future.plan = NULL)
[16:12:51.176]                   if (is.na(NA_character_)) 
[16:12:51.176]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.176]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.176]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.176]                   {
[16:12:51.176]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.176]                     if (!future$lazy) 
[16:12:51.176]                       future <- run(future)
[16:12:51.176]                     invisible(future)
[16:12:51.176]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.176]                 }
[16:12:51.176]             }
[16:12:51.176]         }
[16:12:51.176]     })
[16:12:51.176]     if (TRUE) {
[16:12:51.176]         base::sink(type = "output", split = FALSE)
[16:12:51.176]         if (TRUE) {
[16:12:51.176]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.176]         }
[16:12:51.176]         else {
[16:12:51.176]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.176]         }
[16:12:51.176]         base::close(...future.stdout)
[16:12:51.176]         ...future.stdout <- NULL
[16:12:51.176]     }
[16:12:51.176]     ...future.result$conditions <- ...future.conditions
[16:12:51.176]     ...future.result$finished <- base::Sys.time()
[16:12:51.176]     ...future.result
[16:12:51.176] }
[16:12:51.177] assign_globals() ...
[16:12:51.177] List of 2
[16:12:51.177]  $ a : num 1
[16:12:51.177]  $ ii: int 3
[16:12:51.177]  - attr(*, "where")=List of 2
[16:12:51.177]   ..$ a :<environment: R_EmptyEnv> 
[16:12:51.177]   ..$ ii:<environment: R_EmptyEnv> 
[16:12:51.177]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.177]  - attr(*, "resolved")= logi TRUE
[16:12:51.177]  - attr(*, "total_size")= num 112
[16:12:51.177]  - attr(*, "already-done")= logi TRUE
[16:12:51.180] - copied ‘a’ to environment
[16:12:51.180] - copied ‘ii’ to environment
[16:12:51.181] assign_globals() ... done
[16:12:51.181] plan(): Setting new future strategy stack:
[16:12:51.181] List of future strategies:
[16:12:51.181] 1. sequential:
[16:12:51.181]    - args: function (..., envir = parent.frame())
[16:12:51.181]    - tweaked: FALSE
[16:12:51.181]    - call: NULL
[16:12:51.181] plan(): nbrOfWorkers() = 1
[16:12:51.182] plan(): Setting new future strategy stack:
[16:12:51.182] List of future strategies:
[16:12:51.182] 1. sequential:
[16:12:51.182]    - args: function (..., envir = parent.frame())
[16:12:51.182]    - tweaked: FALSE
[16:12:51.182]    - call: plan(strategy)
[16:12:51.182] plan(): nbrOfWorkers() = 1
[16:12:51.183] SequentialFuture started (and completed)
[16:12:51.183] - Launch lazy future ... done
[16:12:51.183] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.184] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.184] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:51.187] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:51.187] Searching for globals ... DONE
[16:12:51.187] Resolving globals: TRUE
[16:12:51.187] Resolving any globals that are futures ...
[16:12:51.188] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:51.188] Resolving any globals that are futures ... DONE
[16:12:51.188] Resolving futures part of globals (recursively) ...
[16:12:51.188] resolve() on list ...
[16:12:51.188]  recursive: 99
[16:12:51.188]  length: 2
[16:12:51.189]  elements: ‘a’, ‘ii’
[16:12:51.189]  length: 1 (resolved future 1)
[16:12:51.189]  length: 0 (resolved future 2)
[16:12:51.189] resolve() on list ... DONE
[16:12:51.189] - globals: [2] ‘a’, ‘ii’
[16:12:51.189] Resolving futures part of globals (recursively) ... DONE
[16:12:51.189] The total size of the 2 globals is 112 bytes (112 bytes)
[16:12:51.190] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:12:51.190] - globals: [2] ‘a’, ‘ii’
[16:12:51.190] 
[16:12:51.190] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.190] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.191] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:51.192] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:51.192] Searching for globals ... DONE
[16:12:51.193] Resolving globals: TRUE
[16:12:51.193] Resolving any globals that are futures ...
[16:12:51.193] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:51.193] Resolving any globals that are futures ... DONE
[16:12:51.193] Resolving futures part of globals (recursively) ...
[16:12:51.193] resolve() on list ...
[16:12:51.193]  recursive: 99
[16:12:51.194]  length: 2
[16:12:51.194]  elements: ‘a’, ‘ii’
[16:12:51.194]  length: 1 (resolved future 1)
[16:12:51.194]  length: 0 (resolved future 2)
[16:12:51.194] resolve() on list ... DONE
[16:12:51.194] - globals: [2] ‘a’, ‘ii’
[16:12:51.194] Resolving futures part of globals (recursively) ... DONE
[16:12:51.194] The total size of the 2 globals is 112 bytes (112 bytes)
[16:12:51.195] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:12:51.195] - globals: [2] ‘a’, ‘ii’
[16:12:51.195] 
[16:12:51.195] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.196] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.196] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:51.197] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:51.198] Searching for globals ... DONE
[16:12:51.198] Resolving globals: TRUE
[16:12:51.198] Resolving any globals that are futures ...
[16:12:51.198] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:51.198] Resolving any globals that are futures ... DONE
[16:12:51.198] Resolving futures part of globals (recursively) ...
[16:12:51.199] resolve() on list ...
[16:12:51.199]  recursive: 99
[16:12:51.199]  length: 2
[16:12:51.199]  elements: ‘a’, ‘ii’
[16:12:51.199]  length: 1 (resolved future 1)
[16:12:51.199]  length: 0 (resolved future 2)
[16:12:51.199] resolve() on list ... DONE
[16:12:51.199] - globals: [2] ‘a’, ‘ii’
[16:12:51.199] Resolving futures part of globals (recursively) ... DONE
[16:12:51.199] The total size of the 2 globals is 112 bytes (112 bytes)
[16:12:51.200] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:12:51.200] - globals: [2] ‘a’, ‘ii’
[16:12:51.200] 
[16:12:51.200] getGlobalsAndPackages() ... DONE
[16:12:51.200] run() for ‘Future’ ...
[16:12:51.201] - state: ‘created’
[16:12:51.201] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.201] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.201] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.201]   - Field: ‘label’
[16:12:51.201]   - Field: ‘local’
[16:12:51.201]   - Field: ‘owner’
[16:12:51.201]   - Field: ‘envir’
[16:12:51.202]   - Field: ‘packages’
[16:12:51.202]   - Field: ‘gc’
[16:12:51.202]   - Field: ‘conditions’
[16:12:51.202]   - Field: ‘expr’
[16:12:51.202]   - Field: ‘uuid’
[16:12:51.202]   - Field: ‘seed’
[16:12:51.202]   - Field: ‘version’
[16:12:51.202]   - Field: ‘result’
[16:12:51.202]   - Field: ‘asynchronous’
[16:12:51.202]   - Field: ‘calls’
[16:12:51.202]   - Field: ‘globals’
[16:12:51.203]   - Field: ‘stdout’
[16:12:51.203]   - Field: ‘earlySignal’
[16:12:51.203]   - Field: ‘lazy’
[16:12:51.203]   - Field: ‘state’
[16:12:51.203] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.203] - Launch lazy future ...
[16:12:51.203] Packages needed by the future expression (n = 0): <none>
[16:12:51.203] Packages needed by future strategies (n = 0): <none>
[16:12:51.204] {
[16:12:51.204]     {
[16:12:51.204]         {
[16:12:51.204]             ...future.startTime <- base::Sys.time()
[16:12:51.204]             {
[16:12:51.204]                 {
[16:12:51.204]                   {
[16:12:51.204]                     base::local({
[16:12:51.204]                       has_future <- base::requireNamespace("future", 
[16:12:51.204]                         quietly = TRUE)
[16:12:51.204]                       if (has_future) {
[16:12:51.204]                         ns <- base::getNamespace("future")
[16:12:51.204]                         version <- ns[[".package"]][["version"]]
[16:12:51.204]                         if (is.null(version)) 
[16:12:51.204]                           version <- utils::packageVersion("future")
[16:12:51.204]                       }
[16:12:51.204]                       else {
[16:12:51.204]                         version <- NULL
[16:12:51.204]                       }
[16:12:51.204]                       if (!has_future || version < "1.8.0") {
[16:12:51.204]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.204]                           "", base::R.version$version.string), 
[16:12:51.204]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:51.204]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.204]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.204]                             "release", "version")], collapse = " "), 
[16:12:51.204]                           hostname = base::Sys.info()[["nodename"]])
[16:12:51.204]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.204]                           info)
[16:12:51.204]                         info <- base::paste(info, collapse = "; ")
[16:12:51.204]                         if (!has_future) {
[16:12:51.204]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.204]                             info)
[16:12:51.204]                         }
[16:12:51.204]                         else {
[16:12:51.204]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.204]                             info, version)
[16:12:51.204]                         }
[16:12:51.204]                         base::stop(msg)
[16:12:51.204]                       }
[16:12:51.204]                     })
[16:12:51.204]                   }
[16:12:51.204]                   options(future.plan = NULL)
[16:12:51.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.204]                 }
[16:12:51.204]                 ...future.workdir <- getwd()
[16:12:51.204]             }
[16:12:51.204]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.204]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.204]         }
[16:12:51.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.204]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:51.204]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.204]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.204]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.204]             base::names(...future.oldOptions))
[16:12:51.204]     }
[16:12:51.204]     if (FALSE) {
[16:12:51.204]     }
[16:12:51.204]     else {
[16:12:51.204]         if (TRUE) {
[16:12:51.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.204]                 open = "w")
[16:12:51.204]         }
[16:12:51.204]         else {
[16:12:51.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.204]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.204]         }
[16:12:51.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.204]             base::sink(type = "output", split = FALSE)
[16:12:51.204]             base::close(...future.stdout)
[16:12:51.204]         }, add = TRUE)
[16:12:51.204]     }
[16:12:51.204]     ...future.frame <- base::sys.nframe()
[16:12:51.204]     ...future.conditions <- base::list()
[16:12:51.204]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.204]     if (FALSE) {
[16:12:51.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.204]     }
[16:12:51.204]     ...future.result <- base::tryCatch({
[16:12:51.204]         base::withCallingHandlers({
[16:12:51.204]             ...future.value <- base::withVisible(base::local({
[16:12:51.204]                 b <- a * ii
[16:12:51.204]                 a <- 0
[16:12:51.204]                 b
[16:12:51.204]             }))
[16:12:51.204]             future::FutureResult(value = ...future.value$value, 
[16:12:51.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.204]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.204]                     ...future.globalenv.names))
[16:12:51.204]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.204]         }, condition = base::local({
[16:12:51.204]             c <- base::c
[16:12:51.204]             inherits <- base::inherits
[16:12:51.204]             invokeRestart <- base::invokeRestart
[16:12:51.204]             length <- base::length
[16:12:51.204]             list <- base::list
[16:12:51.204]             seq.int <- base::seq.int
[16:12:51.204]             signalCondition <- base::signalCondition
[16:12:51.204]             sys.calls <- base::sys.calls
[16:12:51.204]             `[[` <- base::`[[`
[16:12:51.204]             `+` <- base::`+`
[16:12:51.204]             `<<-` <- base::`<<-`
[16:12:51.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.204]                   3L)]
[16:12:51.204]             }
[16:12:51.204]             function(cond) {
[16:12:51.204]                 is_error <- inherits(cond, "error")
[16:12:51.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.204]                   NULL)
[16:12:51.204]                 if (is_error) {
[16:12:51.204]                   sessionInformation <- function() {
[16:12:51.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.204]                       search = base::search(), system = base::Sys.info())
[16:12:51.204]                   }
[16:12:51.204]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.204]                     cond$call), session = sessionInformation(), 
[16:12:51.204]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.204]                   signalCondition(cond)
[16:12:51.204]                 }
[16:12:51.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.204]                 "immediateCondition"))) {
[16:12:51.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.204]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.204]                   if (TRUE && !signal) {
[16:12:51.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.204]                     {
[16:12:51.204]                       inherits <- base::inherits
[16:12:51.204]                       invokeRestart <- base::invokeRestart
[16:12:51.204]                       is.null <- base::is.null
[16:12:51.204]                       muffled <- FALSE
[16:12:51.204]                       if (inherits(cond, "message")) {
[16:12:51.204]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.204]                         if (muffled) 
[16:12:51.204]                           invokeRestart("muffleMessage")
[16:12:51.204]                       }
[16:12:51.204]                       else if (inherits(cond, "warning")) {
[16:12:51.204]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.204]                         if (muffled) 
[16:12:51.204]                           invokeRestart("muffleWarning")
[16:12:51.204]                       }
[16:12:51.204]                       else if (inherits(cond, "condition")) {
[16:12:51.204]                         if (!is.null(pattern)) {
[16:12:51.204]                           computeRestarts <- base::computeRestarts
[16:12:51.204]                           grepl <- base::grepl
[16:12:51.204]                           restarts <- computeRestarts(cond)
[16:12:51.204]                           for (restart in restarts) {
[16:12:51.204]                             name <- restart$name
[16:12:51.204]                             if (is.null(name)) 
[16:12:51.204]                               next
[16:12:51.204]                             if (!grepl(pattern, name)) 
[16:12:51.204]                               next
[16:12:51.204]                             invokeRestart(restart)
[16:12:51.204]                             muffled <- TRUE
[16:12:51.204]                             break
[16:12:51.204]                           }
[16:12:51.204]                         }
[16:12:51.204]                       }
[16:12:51.204]                       invisible(muffled)
[16:12:51.204]                     }
[16:12:51.204]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.204]                   }
[16:12:51.204]                 }
[16:12:51.204]                 else {
[16:12:51.204]                   if (TRUE) {
[16:12:51.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.204]                     {
[16:12:51.204]                       inherits <- base::inherits
[16:12:51.204]                       invokeRestart <- base::invokeRestart
[16:12:51.204]                       is.null <- base::is.null
[16:12:51.204]                       muffled <- FALSE
[16:12:51.204]                       if (inherits(cond, "message")) {
[16:12:51.204]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.204]                         if (muffled) 
[16:12:51.204]                           invokeRestart("muffleMessage")
[16:12:51.204]                       }
[16:12:51.204]                       else if (inherits(cond, "warning")) {
[16:12:51.204]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.204]                         if (muffled) 
[16:12:51.204]                           invokeRestart("muffleWarning")
[16:12:51.204]                       }
[16:12:51.204]                       else if (inherits(cond, "condition")) {
[16:12:51.204]                         if (!is.null(pattern)) {
[16:12:51.204]                           computeRestarts <- base::computeRestarts
[16:12:51.204]                           grepl <- base::grepl
[16:12:51.204]                           restarts <- computeRestarts(cond)
[16:12:51.204]                           for (restart in restarts) {
[16:12:51.204]                             name <- restart$name
[16:12:51.204]                             if (is.null(name)) 
[16:12:51.204]                               next
[16:12:51.204]                             if (!grepl(pattern, name)) 
[16:12:51.204]                               next
[16:12:51.204]                             invokeRestart(restart)
[16:12:51.204]                             muffled <- TRUE
[16:12:51.204]                             break
[16:12:51.204]                           }
[16:12:51.204]                         }
[16:12:51.204]                       }
[16:12:51.204]                       invisible(muffled)
[16:12:51.204]                     }
[16:12:51.204]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.204]                   }
[16:12:51.204]                 }
[16:12:51.204]             }
[16:12:51.204]         }))
[16:12:51.204]     }, error = function(ex) {
[16:12:51.204]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.204]                 ...future.rng), started = ...future.startTime, 
[16:12:51.204]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.204]             version = "1.8"), class = "FutureResult")
[16:12:51.204]     }, finally = {
[16:12:51.204]         if (!identical(...future.workdir, getwd())) 
[16:12:51.204]             setwd(...future.workdir)
[16:12:51.204]         {
[16:12:51.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.204]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.204]             }
[16:12:51.204]             base::options(...future.oldOptions)
[16:12:51.204]             if (.Platform$OS.type == "windows") {
[16:12:51.204]                 old_names <- names(...future.oldEnvVars)
[16:12:51.204]                 envs <- base::Sys.getenv()
[16:12:51.204]                 names <- names(envs)
[16:12:51.204]                 common <- intersect(names, old_names)
[16:12:51.204]                 added <- setdiff(names, old_names)
[16:12:51.204]                 removed <- setdiff(old_names, names)
[16:12:51.204]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.204]                   envs[common]]
[16:12:51.204]                 NAMES <- toupper(changed)
[16:12:51.204]                 args <- list()
[16:12:51.204]                 for (kk in seq_along(NAMES)) {
[16:12:51.204]                   name <- changed[[kk]]
[16:12:51.204]                   NAME <- NAMES[[kk]]
[16:12:51.204]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.204]                     next
[16:12:51.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.204]                 }
[16:12:51.204]                 NAMES <- toupper(added)
[16:12:51.204]                 for (kk in seq_along(NAMES)) {
[16:12:51.204]                   name <- added[[kk]]
[16:12:51.204]                   NAME <- NAMES[[kk]]
[16:12:51.204]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.204]                     next
[16:12:51.204]                   args[[name]] <- ""
[16:12:51.204]                 }
[16:12:51.204]                 NAMES <- toupper(removed)
[16:12:51.204]                 for (kk in seq_along(NAMES)) {
[16:12:51.204]                   name <- removed[[kk]]
[16:12:51.204]                   NAME <- NAMES[[kk]]
[16:12:51.204]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.204]                     next
[16:12:51.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.204]                 }
[16:12:51.204]                 if (length(args) > 0) 
[16:12:51.204]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.204]             }
[16:12:51.204]             else {
[16:12:51.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.204]             }
[16:12:51.204]             {
[16:12:51.204]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.204]                   0L) {
[16:12:51.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.204]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.204]                   base::options(opts)
[16:12:51.204]                 }
[16:12:51.204]                 {
[16:12:51.204]                   {
[16:12:51.204]                     NULL
[16:12:51.204]                     RNGkind("Mersenne-Twister")
[16:12:51.204]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.204]                       inherits = FALSE)
[16:12:51.204]                   }
[16:12:51.204]                   options(future.plan = NULL)
[16:12:51.204]                   if (is.na(NA_character_)) 
[16:12:51.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.204]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.204]                   {
[16:12:51.204]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.204]                     if (!future$lazy) 
[16:12:51.204]                       future <- run(future)
[16:12:51.204]                     invisible(future)
[16:12:51.204]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.204]                 }
[16:12:51.204]             }
[16:12:51.204]         }
[16:12:51.204]     })
[16:12:51.204]     if (TRUE) {
[16:12:51.204]         base::sink(type = "output", split = FALSE)
[16:12:51.204]         if (TRUE) {
[16:12:51.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.204]         }
[16:12:51.204]         else {
[16:12:51.204]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.204]         }
[16:12:51.204]         base::close(...future.stdout)
[16:12:51.204]         ...future.stdout <- NULL
[16:12:51.204]     }
[16:12:51.204]     ...future.result$conditions <- ...future.conditions
[16:12:51.204]     ...future.result$finished <- base::Sys.time()
[16:12:51.204]     ...future.result
[16:12:51.204] }
[16:12:51.205] assign_globals() ...
[16:12:51.205] List of 2
[16:12:51.205]  $ a : num 1
[16:12:51.205]  $ ii: int 1
[16:12:51.205]  - attr(*, "where")=List of 2
[16:12:51.205]   ..$ a :<environment: R_EmptyEnv> 
[16:12:51.205]   ..$ ii:<environment: R_EmptyEnv> 
[16:12:51.205]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.205]  - attr(*, "resolved")= logi TRUE
[16:12:51.205]  - attr(*, "total_size")= num 112
[16:12:51.205]  - attr(*, "already-done")= logi TRUE
[16:12:51.210] - copied ‘a’ to environment
[16:12:51.210] - copied ‘ii’ to environment
[16:12:51.210] assign_globals() ... done
[16:12:51.210] plan(): Setting new future strategy stack:
[16:12:51.211] List of future strategies:
[16:12:51.211] 1. sequential:
[16:12:51.211]    - args: function (..., envir = parent.frame())
[16:12:51.211]    - tweaked: FALSE
[16:12:51.211]    - call: NULL
[16:12:51.211] plan(): nbrOfWorkers() = 1
[16:12:51.212] plan(): Setting new future strategy stack:
[16:12:51.212] List of future strategies:
[16:12:51.212] 1. sequential:
[16:12:51.212]    - args: function (..., envir = parent.frame())
[16:12:51.212]    - tweaked: FALSE
[16:12:51.212]    - call: plan(strategy)
[16:12:51.212] plan(): nbrOfWorkers() = 1
[16:12:51.212] SequentialFuture started (and completed)
[16:12:51.212] - Launch lazy future ... done
[16:12:51.212] run() for ‘SequentialFuture’ ... done
[16:12:51.213] run() for ‘Future’ ...
[16:12:51.213] - state: ‘created’
[16:12:51.213] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.213] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.213] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.213]   - Field: ‘label’
[16:12:51.213]   - Field: ‘local’
[16:12:51.214]   - Field: ‘owner’
[16:12:51.214]   - Field: ‘envir’
[16:12:51.214]   - Field: ‘packages’
[16:12:51.214]   - Field: ‘gc’
[16:12:51.214]   - Field: ‘conditions’
[16:12:51.214]   - Field: ‘expr’
[16:12:51.214]   - Field: ‘uuid’
[16:12:51.214]   - Field: ‘seed’
[16:12:51.214]   - Field: ‘version’
[16:12:51.214]   - Field: ‘result’
[16:12:51.214]   - Field: ‘asynchronous’
[16:12:51.215]   - Field: ‘calls’
[16:12:51.215]   - Field: ‘globals’
[16:12:51.215]   - Field: ‘stdout’
[16:12:51.215]   - Field: ‘earlySignal’
[16:12:51.215]   - Field: ‘lazy’
[16:12:51.215]   - Field: ‘state’
[16:12:51.215] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.215] - Launch lazy future ...
[16:12:51.215] Packages needed by the future expression (n = 0): <none>
[16:12:51.215] Packages needed by future strategies (n = 0): <none>
[16:12:51.216] {
[16:12:51.216]     {
[16:12:51.216]         {
[16:12:51.216]             ...future.startTime <- base::Sys.time()
[16:12:51.216]             {
[16:12:51.216]                 {
[16:12:51.216]                   {
[16:12:51.216]                     base::local({
[16:12:51.216]                       has_future <- base::requireNamespace("future", 
[16:12:51.216]                         quietly = TRUE)
[16:12:51.216]                       if (has_future) {
[16:12:51.216]                         ns <- base::getNamespace("future")
[16:12:51.216]                         version <- ns[[".package"]][["version"]]
[16:12:51.216]                         if (is.null(version)) 
[16:12:51.216]                           version <- utils::packageVersion("future")
[16:12:51.216]                       }
[16:12:51.216]                       else {
[16:12:51.216]                         version <- NULL
[16:12:51.216]                       }
[16:12:51.216]                       if (!has_future || version < "1.8.0") {
[16:12:51.216]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.216]                           "", base::R.version$version.string), 
[16:12:51.216]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:51.216]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.216]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.216]                             "release", "version")], collapse = " "), 
[16:12:51.216]                           hostname = base::Sys.info()[["nodename"]])
[16:12:51.216]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.216]                           info)
[16:12:51.216]                         info <- base::paste(info, collapse = "; ")
[16:12:51.216]                         if (!has_future) {
[16:12:51.216]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.216]                             info)
[16:12:51.216]                         }
[16:12:51.216]                         else {
[16:12:51.216]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.216]                             info, version)
[16:12:51.216]                         }
[16:12:51.216]                         base::stop(msg)
[16:12:51.216]                       }
[16:12:51.216]                     })
[16:12:51.216]                   }
[16:12:51.216]                   options(future.plan = NULL)
[16:12:51.216]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.216]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.216]                 }
[16:12:51.216]                 ...future.workdir <- getwd()
[16:12:51.216]             }
[16:12:51.216]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.216]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.216]         }
[16:12:51.216]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.216]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:51.216]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.216]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.216]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.216]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.216]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.216]             base::names(...future.oldOptions))
[16:12:51.216]     }
[16:12:51.216]     if (FALSE) {
[16:12:51.216]     }
[16:12:51.216]     else {
[16:12:51.216]         if (TRUE) {
[16:12:51.216]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.216]                 open = "w")
[16:12:51.216]         }
[16:12:51.216]         else {
[16:12:51.216]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.216]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.216]         }
[16:12:51.216]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.216]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.216]             base::sink(type = "output", split = FALSE)
[16:12:51.216]             base::close(...future.stdout)
[16:12:51.216]         }, add = TRUE)
[16:12:51.216]     }
[16:12:51.216]     ...future.frame <- base::sys.nframe()
[16:12:51.216]     ...future.conditions <- base::list()
[16:12:51.216]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.216]     if (FALSE) {
[16:12:51.216]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.216]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.216]     }
[16:12:51.216]     ...future.result <- base::tryCatch({
[16:12:51.216]         base::withCallingHandlers({
[16:12:51.216]             ...future.value <- base::withVisible(base::local({
[16:12:51.216]                 b <- a * ii
[16:12:51.216]                 a <- 0
[16:12:51.216]                 b
[16:12:51.216]             }))
[16:12:51.216]             future::FutureResult(value = ...future.value$value, 
[16:12:51.216]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.216]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.216]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.216]                     ...future.globalenv.names))
[16:12:51.216]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.216]         }, condition = base::local({
[16:12:51.216]             c <- base::c
[16:12:51.216]             inherits <- base::inherits
[16:12:51.216]             invokeRestart <- base::invokeRestart
[16:12:51.216]             length <- base::length
[16:12:51.216]             list <- base::list
[16:12:51.216]             seq.int <- base::seq.int
[16:12:51.216]             signalCondition <- base::signalCondition
[16:12:51.216]             sys.calls <- base::sys.calls
[16:12:51.216]             `[[` <- base::`[[`
[16:12:51.216]             `+` <- base::`+`
[16:12:51.216]             `<<-` <- base::`<<-`
[16:12:51.216]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.216]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.216]                   3L)]
[16:12:51.216]             }
[16:12:51.216]             function(cond) {
[16:12:51.216]                 is_error <- inherits(cond, "error")
[16:12:51.216]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.216]                   NULL)
[16:12:51.216]                 if (is_error) {
[16:12:51.216]                   sessionInformation <- function() {
[16:12:51.216]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.216]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.216]                       search = base::search(), system = base::Sys.info())
[16:12:51.216]                   }
[16:12:51.216]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.216]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.216]                     cond$call), session = sessionInformation(), 
[16:12:51.216]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.216]                   signalCondition(cond)
[16:12:51.216]                 }
[16:12:51.216]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.216]                 "immediateCondition"))) {
[16:12:51.216]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.216]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.216]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.216]                   if (TRUE && !signal) {
[16:12:51.216]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.216]                     {
[16:12:51.216]                       inherits <- base::inherits
[16:12:51.216]                       invokeRestart <- base::invokeRestart
[16:12:51.216]                       is.null <- base::is.null
[16:12:51.216]                       muffled <- FALSE
[16:12:51.216]                       if (inherits(cond, "message")) {
[16:12:51.216]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.216]                         if (muffled) 
[16:12:51.216]                           invokeRestart("muffleMessage")
[16:12:51.216]                       }
[16:12:51.216]                       else if (inherits(cond, "warning")) {
[16:12:51.216]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.216]                         if (muffled) 
[16:12:51.216]                           invokeRestart("muffleWarning")
[16:12:51.216]                       }
[16:12:51.216]                       else if (inherits(cond, "condition")) {
[16:12:51.216]                         if (!is.null(pattern)) {
[16:12:51.216]                           computeRestarts <- base::computeRestarts
[16:12:51.216]                           grepl <- base::grepl
[16:12:51.216]                           restarts <- computeRestarts(cond)
[16:12:51.216]                           for (restart in restarts) {
[16:12:51.216]                             name <- restart$name
[16:12:51.216]                             if (is.null(name)) 
[16:12:51.216]                               next
[16:12:51.216]                             if (!grepl(pattern, name)) 
[16:12:51.216]                               next
[16:12:51.216]                             invokeRestart(restart)
[16:12:51.216]                             muffled <- TRUE
[16:12:51.216]                             break
[16:12:51.216]                           }
[16:12:51.216]                         }
[16:12:51.216]                       }
[16:12:51.216]                       invisible(muffled)
[16:12:51.216]                     }
[16:12:51.216]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.216]                   }
[16:12:51.216]                 }
[16:12:51.216]                 else {
[16:12:51.216]                   if (TRUE) {
[16:12:51.216]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.216]                     {
[16:12:51.216]                       inherits <- base::inherits
[16:12:51.216]                       invokeRestart <- base::invokeRestart
[16:12:51.216]                       is.null <- base::is.null
[16:12:51.216]                       muffled <- FALSE
[16:12:51.216]                       if (inherits(cond, "message")) {
[16:12:51.216]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.216]                         if (muffled) 
[16:12:51.216]                           invokeRestart("muffleMessage")
[16:12:51.216]                       }
[16:12:51.216]                       else if (inherits(cond, "warning")) {
[16:12:51.216]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.216]                         if (muffled) 
[16:12:51.216]                           invokeRestart("muffleWarning")
[16:12:51.216]                       }
[16:12:51.216]                       else if (inherits(cond, "condition")) {
[16:12:51.216]                         if (!is.null(pattern)) {
[16:12:51.216]                           computeRestarts <- base::computeRestarts
[16:12:51.216]                           grepl <- base::grepl
[16:12:51.216]                           restarts <- computeRestarts(cond)
[16:12:51.216]                           for (restart in restarts) {
[16:12:51.216]                             name <- restart$name
[16:12:51.216]                             if (is.null(name)) 
[16:12:51.216]                               next
[16:12:51.216]                             if (!grepl(pattern, name)) 
[16:12:51.216]                               next
[16:12:51.216]                             invokeRestart(restart)
[16:12:51.216]                             muffled <- TRUE
[16:12:51.216]                             break
[16:12:51.216]                           }
[16:12:51.216]                         }
[16:12:51.216]                       }
[16:12:51.216]                       invisible(muffled)
[16:12:51.216]                     }
[16:12:51.216]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.216]                   }
[16:12:51.216]                 }
[16:12:51.216]             }
[16:12:51.216]         }))
[16:12:51.216]     }, error = function(ex) {
[16:12:51.216]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.216]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.216]                 ...future.rng), started = ...future.startTime, 
[16:12:51.216]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.216]             version = "1.8"), class = "FutureResult")
[16:12:51.216]     }, finally = {
[16:12:51.216]         if (!identical(...future.workdir, getwd())) 
[16:12:51.216]             setwd(...future.workdir)
[16:12:51.216]         {
[16:12:51.216]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.216]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.216]             }
[16:12:51.216]             base::options(...future.oldOptions)
[16:12:51.216]             if (.Platform$OS.type == "windows") {
[16:12:51.216]                 old_names <- names(...future.oldEnvVars)
[16:12:51.216]                 envs <- base::Sys.getenv()
[16:12:51.216]                 names <- names(envs)
[16:12:51.216]                 common <- intersect(names, old_names)
[16:12:51.216]                 added <- setdiff(names, old_names)
[16:12:51.216]                 removed <- setdiff(old_names, names)
[16:12:51.216]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.216]                   envs[common]]
[16:12:51.216]                 NAMES <- toupper(changed)
[16:12:51.216]                 args <- list()
[16:12:51.216]                 for (kk in seq_along(NAMES)) {
[16:12:51.216]                   name <- changed[[kk]]
[16:12:51.216]                   NAME <- NAMES[[kk]]
[16:12:51.216]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.216]                     next
[16:12:51.216]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.216]                 }
[16:12:51.216]                 NAMES <- toupper(added)
[16:12:51.216]                 for (kk in seq_along(NAMES)) {
[16:12:51.216]                   name <- added[[kk]]
[16:12:51.216]                   NAME <- NAMES[[kk]]
[16:12:51.216]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.216]                     next
[16:12:51.216]                   args[[name]] <- ""
[16:12:51.216]                 }
[16:12:51.216]                 NAMES <- toupper(removed)
[16:12:51.216]                 for (kk in seq_along(NAMES)) {
[16:12:51.216]                   name <- removed[[kk]]
[16:12:51.216]                   NAME <- NAMES[[kk]]
[16:12:51.216]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.216]                     next
[16:12:51.216]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.216]                 }
[16:12:51.216]                 if (length(args) > 0) 
[16:12:51.216]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.216]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.216]             }
[16:12:51.216]             else {
[16:12:51.216]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.216]             }
[16:12:51.216]             {
[16:12:51.216]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.216]                   0L) {
[16:12:51.216]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.216]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.216]                   base::options(opts)
[16:12:51.216]                 }
[16:12:51.216]                 {
[16:12:51.216]                   {
[16:12:51.216]                     NULL
[16:12:51.216]                     RNGkind("Mersenne-Twister")
[16:12:51.216]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.216]                       inherits = FALSE)
[16:12:51.216]                   }
[16:12:51.216]                   options(future.plan = NULL)
[16:12:51.216]                   if (is.na(NA_character_)) 
[16:12:51.216]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.216]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.216]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.216]                   {
[16:12:51.216]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.216]                     if (!future$lazy) 
[16:12:51.216]                       future <- run(future)
[16:12:51.216]                     invisible(future)
[16:12:51.216]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.216]                 }
[16:12:51.216]             }
[16:12:51.216]         }
[16:12:51.216]     })
[16:12:51.216]     if (TRUE) {
[16:12:51.216]         base::sink(type = "output", split = FALSE)
[16:12:51.216]         if (TRUE) {
[16:12:51.216]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.216]         }
[16:12:51.216]         else {
[16:12:51.216]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.216]         }
[16:12:51.216]         base::close(...future.stdout)
[16:12:51.216]         ...future.stdout <- NULL
[16:12:51.216]     }
[16:12:51.216]     ...future.result$conditions <- ...future.conditions
[16:12:51.216]     ...future.result$finished <- base::Sys.time()
[16:12:51.216]     ...future.result
[16:12:51.216] }
[16:12:51.217] assign_globals() ...
[16:12:51.218] List of 2
[16:12:51.218]  $ a : num 1
[16:12:51.218]  $ ii: int 2
[16:12:51.218]  - attr(*, "where")=List of 2
[16:12:51.218]   ..$ a :<environment: R_EmptyEnv> 
[16:12:51.218]   ..$ ii:<environment: R_EmptyEnv> 
[16:12:51.218]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.218]  - attr(*, "resolved")= logi TRUE
[16:12:51.218]  - attr(*, "total_size")= num 112
[16:12:51.218]  - attr(*, "already-done")= logi TRUE
[16:12:51.220] - copied ‘a’ to environment
[16:12:51.221] - copied ‘ii’ to environment
[16:12:51.221] assign_globals() ... done
[16:12:51.221] plan(): Setting new future strategy stack:
[16:12:51.221] List of future strategies:
[16:12:51.221] 1. sequential:
[16:12:51.221]    - args: function (..., envir = parent.frame())
[16:12:51.221]    - tweaked: FALSE
[16:12:51.221]    - call: NULL
[16:12:51.221] plan(): nbrOfWorkers() = 1
[16:12:51.222] plan(): Setting new future strategy stack:
[16:12:51.222] List of future strategies:
[16:12:51.222] 1. sequential:
[16:12:51.222]    - args: function (..., envir = parent.frame())
[16:12:51.222]    - tweaked: FALSE
[16:12:51.222]    - call: plan(strategy)
[16:12:51.222] plan(): nbrOfWorkers() = 1
[16:12:51.223] SequentialFuture started (and completed)
[16:12:51.223] - Launch lazy future ... done
[16:12:51.223] run() for ‘SequentialFuture’ ... done
[16:12:51.223] run() for ‘Future’ ...
[16:12:51.223] - state: ‘created’
[16:12:51.223] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.224] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.224] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.224]   - Field: ‘label’
[16:12:51.224]   - Field: ‘local’
[16:12:51.224]   - Field: ‘owner’
[16:12:51.224]   - Field: ‘envir’
[16:12:51.224]   - Field: ‘packages’
[16:12:51.224]   - Field: ‘gc’
[16:12:51.224]   - Field: ‘conditions’
[16:12:51.224]   - Field: ‘expr’
[16:12:51.225]   - Field: ‘uuid’
[16:12:51.225]   - Field: ‘seed’
[16:12:51.225]   - Field: ‘version’
[16:12:51.225]   - Field: ‘result’
[16:12:51.225]   - Field: ‘asynchronous’
[16:12:51.225]   - Field: ‘calls’
[16:12:51.225]   - Field: ‘globals’
[16:12:51.225]   - Field: ‘stdout’
[16:12:51.225]   - Field: ‘earlySignal’
[16:12:51.225]   - Field: ‘lazy’
[16:12:51.225]   - Field: ‘state’
[16:12:51.226] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.226] - Launch lazy future ...
[16:12:51.226] Packages needed by the future expression (n = 0): <none>
[16:12:51.226] Packages needed by future strategies (n = 0): <none>
[16:12:51.226] {
[16:12:51.226]     {
[16:12:51.226]         {
[16:12:51.226]             ...future.startTime <- base::Sys.time()
[16:12:51.226]             {
[16:12:51.226]                 {
[16:12:51.226]                   {
[16:12:51.226]                     base::local({
[16:12:51.226]                       has_future <- base::requireNamespace("future", 
[16:12:51.226]                         quietly = TRUE)
[16:12:51.226]                       if (has_future) {
[16:12:51.226]                         ns <- base::getNamespace("future")
[16:12:51.226]                         version <- ns[[".package"]][["version"]]
[16:12:51.226]                         if (is.null(version)) 
[16:12:51.226]                           version <- utils::packageVersion("future")
[16:12:51.226]                       }
[16:12:51.226]                       else {
[16:12:51.226]                         version <- NULL
[16:12:51.226]                       }
[16:12:51.226]                       if (!has_future || version < "1.8.0") {
[16:12:51.226]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.226]                           "", base::R.version$version.string), 
[16:12:51.226]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:51.226]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.226]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.226]                             "release", "version")], collapse = " "), 
[16:12:51.226]                           hostname = base::Sys.info()[["nodename"]])
[16:12:51.226]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.226]                           info)
[16:12:51.226]                         info <- base::paste(info, collapse = "; ")
[16:12:51.226]                         if (!has_future) {
[16:12:51.226]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.226]                             info)
[16:12:51.226]                         }
[16:12:51.226]                         else {
[16:12:51.226]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.226]                             info, version)
[16:12:51.226]                         }
[16:12:51.226]                         base::stop(msg)
[16:12:51.226]                       }
[16:12:51.226]                     })
[16:12:51.226]                   }
[16:12:51.226]                   options(future.plan = NULL)
[16:12:51.226]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.226]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.226]                 }
[16:12:51.226]                 ...future.workdir <- getwd()
[16:12:51.226]             }
[16:12:51.226]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.226]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.226]         }
[16:12:51.226]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.226]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:51.226]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.226]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.226]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.226]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.226]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.226]             base::names(...future.oldOptions))
[16:12:51.226]     }
[16:12:51.226]     if (FALSE) {
[16:12:51.226]     }
[16:12:51.226]     else {
[16:12:51.226]         if (TRUE) {
[16:12:51.226]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.226]                 open = "w")
[16:12:51.226]         }
[16:12:51.226]         else {
[16:12:51.226]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.226]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.226]         }
[16:12:51.226]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.226]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.226]             base::sink(type = "output", split = FALSE)
[16:12:51.226]             base::close(...future.stdout)
[16:12:51.226]         }, add = TRUE)
[16:12:51.226]     }
[16:12:51.226]     ...future.frame <- base::sys.nframe()
[16:12:51.226]     ...future.conditions <- base::list()
[16:12:51.226]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.226]     if (FALSE) {
[16:12:51.226]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.226]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.226]     }
[16:12:51.226]     ...future.result <- base::tryCatch({
[16:12:51.226]         base::withCallingHandlers({
[16:12:51.226]             ...future.value <- base::withVisible(base::local({
[16:12:51.226]                 b <- a * ii
[16:12:51.226]                 a <- 0
[16:12:51.226]                 b
[16:12:51.226]             }))
[16:12:51.226]             future::FutureResult(value = ...future.value$value, 
[16:12:51.226]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.226]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.226]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.226]                     ...future.globalenv.names))
[16:12:51.226]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.226]         }, condition = base::local({
[16:12:51.226]             c <- base::c
[16:12:51.226]             inherits <- base::inherits
[16:12:51.226]             invokeRestart <- base::invokeRestart
[16:12:51.226]             length <- base::length
[16:12:51.226]             list <- base::list
[16:12:51.226]             seq.int <- base::seq.int
[16:12:51.226]             signalCondition <- base::signalCondition
[16:12:51.226]             sys.calls <- base::sys.calls
[16:12:51.226]             `[[` <- base::`[[`
[16:12:51.226]             `+` <- base::`+`
[16:12:51.226]             `<<-` <- base::`<<-`
[16:12:51.226]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.226]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.226]                   3L)]
[16:12:51.226]             }
[16:12:51.226]             function(cond) {
[16:12:51.226]                 is_error <- inherits(cond, "error")
[16:12:51.226]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.226]                   NULL)
[16:12:51.226]                 if (is_error) {
[16:12:51.226]                   sessionInformation <- function() {
[16:12:51.226]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.226]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.226]                       search = base::search(), system = base::Sys.info())
[16:12:51.226]                   }
[16:12:51.226]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.226]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.226]                     cond$call), session = sessionInformation(), 
[16:12:51.226]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.226]                   signalCondition(cond)
[16:12:51.226]                 }
[16:12:51.226]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.226]                 "immediateCondition"))) {
[16:12:51.226]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.226]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.226]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.226]                   if (TRUE && !signal) {
[16:12:51.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.226]                     {
[16:12:51.226]                       inherits <- base::inherits
[16:12:51.226]                       invokeRestart <- base::invokeRestart
[16:12:51.226]                       is.null <- base::is.null
[16:12:51.226]                       muffled <- FALSE
[16:12:51.226]                       if (inherits(cond, "message")) {
[16:12:51.226]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.226]                         if (muffled) 
[16:12:51.226]                           invokeRestart("muffleMessage")
[16:12:51.226]                       }
[16:12:51.226]                       else if (inherits(cond, "warning")) {
[16:12:51.226]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.226]                         if (muffled) 
[16:12:51.226]                           invokeRestart("muffleWarning")
[16:12:51.226]                       }
[16:12:51.226]                       else if (inherits(cond, "condition")) {
[16:12:51.226]                         if (!is.null(pattern)) {
[16:12:51.226]                           computeRestarts <- base::computeRestarts
[16:12:51.226]                           grepl <- base::grepl
[16:12:51.226]                           restarts <- computeRestarts(cond)
[16:12:51.226]                           for (restart in restarts) {
[16:12:51.226]                             name <- restart$name
[16:12:51.226]                             if (is.null(name)) 
[16:12:51.226]                               next
[16:12:51.226]                             if (!grepl(pattern, name)) 
[16:12:51.226]                               next
[16:12:51.226]                             invokeRestart(restart)
[16:12:51.226]                             muffled <- TRUE
[16:12:51.226]                             break
[16:12:51.226]                           }
[16:12:51.226]                         }
[16:12:51.226]                       }
[16:12:51.226]                       invisible(muffled)
[16:12:51.226]                     }
[16:12:51.226]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.226]                   }
[16:12:51.226]                 }
[16:12:51.226]                 else {
[16:12:51.226]                   if (TRUE) {
[16:12:51.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.226]                     {
[16:12:51.226]                       inherits <- base::inherits
[16:12:51.226]                       invokeRestart <- base::invokeRestart
[16:12:51.226]                       is.null <- base::is.null
[16:12:51.226]                       muffled <- FALSE
[16:12:51.226]                       if (inherits(cond, "message")) {
[16:12:51.226]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.226]                         if (muffled) 
[16:12:51.226]                           invokeRestart("muffleMessage")
[16:12:51.226]                       }
[16:12:51.226]                       else if (inherits(cond, "warning")) {
[16:12:51.226]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.226]                         if (muffled) 
[16:12:51.226]                           invokeRestart("muffleWarning")
[16:12:51.226]                       }
[16:12:51.226]                       else if (inherits(cond, "condition")) {
[16:12:51.226]                         if (!is.null(pattern)) {
[16:12:51.226]                           computeRestarts <- base::computeRestarts
[16:12:51.226]                           grepl <- base::grepl
[16:12:51.226]                           restarts <- computeRestarts(cond)
[16:12:51.226]                           for (restart in restarts) {
[16:12:51.226]                             name <- restart$name
[16:12:51.226]                             if (is.null(name)) 
[16:12:51.226]                               next
[16:12:51.226]                             if (!grepl(pattern, name)) 
[16:12:51.226]                               next
[16:12:51.226]                             invokeRestart(restart)
[16:12:51.226]                             muffled <- TRUE
[16:12:51.226]                             break
[16:12:51.226]                           }
[16:12:51.226]                         }
[16:12:51.226]                       }
[16:12:51.226]                       invisible(muffled)
[16:12:51.226]                     }
[16:12:51.226]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.226]                   }
[16:12:51.226]                 }
[16:12:51.226]             }
[16:12:51.226]         }))
[16:12:51.226]     }, error = function(ex) {
[16:12:51.226]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.226]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.226]                 ...future.rng), started = ...future.startTime, 
[16:12:51.226]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.226]             version = "1.8"), class = "FutureResult")
[16:12:51.226]     }, finally = {
[16:12:51.226]         if (!identical(...future.workdir, getwd())) 
[16:12:51.226]             setwd(...future.workdir)
[16:12:51.226]         {
[16:12:51.226]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.226]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.226]             }
[16:12:51.226]             base::options(...future.oldOptions)
[16:12:51.226]             if (.Platform$OS.type == "windows") {
[16:12:51.226]                 old_names <- names(...future.oldEnvVars)
[16:12:51.226]                 envs <- base::Sys.getenv()
[16:12:51.226]                 names <- names(envs)
[16:12:51.226]                 common <- intersect(names, old_names)
[16:12:51.226]                 added <- setdiff(names, old_names)
[16:12:51.226]                 removed <- setdiff(old_names, names)
[16:12:51.226]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.226]                   envs[common]]
[16:12:51.226]                 NAMES <- toupper(changed)
[16:12:51.226]                 args <- list()
[16:12:51.226]                 for (kk in seq_along(NAMES)) {
[16:12:51.226]                   name <- changed[[kk]]
[16:12:51.226]                   NAME <- NAMES[[kk]]
[16:12:51.226]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.226]                     next
[16:12:51.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.226]                 }
[16:12:51.226]                 NAMES <- toupper(added)
[16:12:51.226]                 for (kk in seq_along(NAMES)) {
[16:12:51.226]                   name <- added[[kk]]
[16:12:51.226]                   NAME <- NAMES[[kk]]
[16:12:51.226]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.226]                     next
[16:12:51.226]                   args[[name]] <- ""
[16:12:51.226]                 }
[16:12:51.226]                 NAMES <- toupper(removed)
[16:12:51.226]                 for (kk in seq_along(NAMES)) {
[16:12:51.226]                   name <- removed[[kk]]
[16:12:51.226]                   NAME <- NAMES[[kk]]
[16:12:51.226]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.226]                     next
[16:12:51.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.226]                 }
[16:12:51.226]                 if (length(args) > 0) 
[16:12:51.226]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.226]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.226]             }
[16:12:51.226]             else {
[16:12:51.226]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.226]             }
[16:12:51.226]             {
[16:12:51.226]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.226]                   0L) {
[16:12:51.226]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.226]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.226]                   base::options(opts)
[16:12:51.226]                 }
[16:12:51.226]                 {
[16:12:51.226]                   {
[16:12:51.226]                     NULL
[16:12:51.226]                     RNGkind("Mersenne-Twister")
[16:12:51.226]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.226]                       inherits = FALSE)
[16:12:51.226]                   }
[16:12:51.226]                   options(future.plan = NULL)
[16:12:51.226]                   if (is.na(NA_character_)) 
[16:12:51.226]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.226]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.226]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.226]                   {
[16:12:51.226]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.226]                     if (!future$lazy) 
[16:12:51.226]                       future <- run(future)
[16:12:51.226]                     invisible(future)
[16:12:51.226]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.226]                 }
[16:12:51.226]             }
[16:12:51.226]         }
[16:12:51.226]     })
[16:12:51.226]     if (TRUE) {
[16:12:51.226]         base::sink(type = "output", split = FALSE)
[16:12:51.226]         if (TRUE) {
[16:12:51.226]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.226]         }
[16:12:51.226]         else {
[16:12:51.226]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.226]         }
[16:12:51.226]         base::close(...future.stdout)
[16:12:51.226]         ...future.stdout <- NULL
[16:12:51.226]     }
[16:12:51.226]     ...future.result$conditions <- ...future.conditions
[16:12:51.226]     ...future.result$finished <- base::Sys.time()
[16:12:51.226]     ...future.result
[16:12:51.226] }
[16:12:51.228] assign_globals() ...
[16:12:51.228] List of 2
[16:12:51.228]  $ a : num 1
[16:12:51.228]  $ ii: int 3
[16:12:51.228]  - attr(*, "where")=List of 2
[16:12:51.228]   ..$ a :<environment: R_EmptyEnv> 
[16:12:51.228]   ..$ ii:<environment: R_EmptyEnv> 
[16:12:51.228]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.228]  - attr(*, "resolved")= logi TRUE
[16:12:51.228]  - attr(*, "total_size")= num 112
[16:12:51.228]  - attr(*, "already-done")= logi TRUE
[16:12:51.231] - copied ‘a’ to environment
[16:12:51.231] - copied ‘ii’ to environment
[16:12:51.231] assign_globals() ... done
[16:12:51.231] plan(): Setting new future strategy stack:
[16:12:51.231] List of future strategies:
[16:12:51.231] 1. sequential:
[16:12:51.231]    - args: function (..., envir = parent.frame())
[16:12:51.231]    - tweaked: FALSE
[16:12:51.231]    - call: NULL
[16:12:51.232] plan(): nbrOfWorkers() = 1
[16:12:51.234] plan(): Setting new future strategy stack:
[16:12:51.234] List of future strategies:
[16:12:51.234] 1. sequential:
[16:12:51.234]    - args: function (..., envir = parent.frame())
[16:12:51.234]    - tweaked: FALSE
[16:12:51.234]    - call: plan(strategy)
[16:12:51.235] plan(): nbrOfWorkers() = 1
[16:12:51.235] SequentialFuture started (and completed)
[16:12:51.235] - Launch lazy future ... done
[16:12:51.235] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.235] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.236] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:51.236] 
[16:12:51.236] Searching for globals ... DONE
[16:12:51.236] - globals: [0] <none>
[16:12:51.236] getGlobalsAndPackages() ... DONE
[16:12:51.236] run() for ‘Future’ ...
[16:12:51.237] - state: ‘created’
[16:12:51.237] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.237] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.237] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.237]   - Field: ‘label’
[16:12:51.237]   - Field: ‘local’
[16:12:51.237]   - Field: ‘owner’
[16:12:51.237]   - Field: ‘envir’
[16:12:51.238]   - Field: ‘packages’
[16:12:51.238]   - Field: ‘gc’
[16:12:51.238]   - Field: ‘conditions’
[16:12:51.238]   - Field: ‘expr’
[16:12:51.238]   - Field: ‘uuid’
[16:12:51.238]   - Field: ‘seed’
[16:12:51.238]   - Field: ‘version’
[16:12:51.238]   - Field: ‘result’
[16:12:51.238]   - Field: ‘asynchronous’
[16:12:51.238]   - Field: ‘calls’
[16:12:51.238]   - Field: ‘globals’
[16:12:51.239]   - Field: ‘stdout’
[16:12:51.239]   - Field: ‘earlySignal’
[16:12:51.239]   - Field: ‘lazy’
[16:12:51.239]   - Field: ‘state’
[16:12:51.239] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.239] - Launch lazy future ...
[16:12:51.239] Packages needed by the future expression (n = 0): <none>
[16:12:51.239] Packages needed by future strategies (n = 0): <none>
[16:12:51.240] {
[16:12:51.240]     {
[16:12:51.240]         {
[16:12:51.240]             ...future.startTime <- base::Sys.time()
[16:12:51.240]             {
[16:12:51.240]                 {
[16:12:51.240]                   {
[16:12:51.240]                     base::local({
[16:12:51.240]                       has_future <- base::requireNamespace("future", 
[16:12:51.240]                         quietly = TRUE)
[16:12:51.240]                       if (has_future) {
[16:12:51.240]                         ns <- base::getNamespace("future")
[16:12:51.240]                         version <- ns[[".package"]][["version"]]
[16:12:51.240]                         if (is.null(version)) 
[16:12:51.240]                           version <- utils::packageVersion("future")
[16:12:51.240]                       }
[16:12:51.240]                       else {
[16:12:51.240]                         version <- NULL
[16:12:51.240]                       }
[16:12:51.240]                       if (!has_future || version < "1.8.0") {
[16:12:51.240]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.240]                           "", base::R.version$version.string), 
[16:12:51.240]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:51.240]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.240]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.240]                             "release", "version")], collapse = " "), 
[16:12:51.240]                           hostname = base::Sys.info()[["nodename"]])
[16:12:51.240]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.240]                           info)
[16:12:51.240]                         info <- base::paste(info, collapse = "; ")
[16:12:51.240]                         if (!has_future) {
[16:12:51.240]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.240]                             info)
[16:12:51.240]                         }
[16:12:51.240]                         else {
[16:12:51.240]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.240]                             info, version)
[16:12:51.240]                         }
[16:12:51.240]                         base::stop(msg)
[16:12:51.240]                       }
[16:12:51.240]                     })
[16:12:51.240]                   }
[16:12:51.240]                   options(future.plan = NULL)
[16:12:51.240]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.240]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.240]                 }
[16:12:51.240]                 ...future.workdir <- getwd()
[16:12:51.240]             }
[16:12:51.240]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.240]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.240]         }
[16:12:51.240]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.240]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:51.240]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.240]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.240]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.240]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.240]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.240]             base::names(...future.oldOptions))
[16:12:51.240]     }
[16:12:51.240]     if (FALSE) {
[16:12:51.240]     }
[16:12:51.240]     else {
[16:12:51.240]         if (TRUE) {
[16:12:51.240]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.240]                 open = "w")
[16:12:51.240]         }
[16:12:51.240]         else {
[16:12:51.240]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.240]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.240]         }
[16:12:51.240]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.240]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.240]             base::sink(type = "output", split = FALSE)
[16:12:51.240]             base::close(...future.stdout)
[16:12:51.240]         }, add = TRUE)
[16:12:51.240]     }
[16:12:51.240]     ...future.frame <- base::sys.nframe()
[16:12:51.240]     ...future.conditions <- base::list()
[16:12:51.240]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.240]     if (FALSE) {
[16:12:51.240]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.240]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.240]     }
[16:12:51.240]     ...future.result <- base::tryCatch({
[16:12:51.240]         base::withCallingHandlers({
[16:12:51.240]             ...future.value <- base::withVisible(base::local(1))
[16:12:51.240]             future::FutureResult(value = ...future.value$value, 
[16:12:51.240]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.240]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.240]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.240]                     ...future.globalenv.names))
[16:12:51.240]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.240]         }, condition = base::local({
[16:12:51.240]             c <- base::c
[16:12:51.240]             inherits <- base::inherits
[16:12:51.240]             invokeRestart <- base::invokeRestart
[16:12:51.240]             length <- base::length
[16:12:51.240]             list <- base::list
[16:12:51.240]             seq.int <- base::seq.int
[16:12:51.240]             signalCondition <- base::signalCondition
[16:12:51.240]             sys.calls <- base::sys.calls
[16:12:51.240]             `[[` <- base::`[[`
[16:12:51.240]             `+` <- base::`+`
[16:12:51.240]             `<<-` <- base::`<<-`
[16:12:51.240]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.240]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.240]                   3L)]
[16:12:51.240]             }
[16:12:51.240]             function(cond) {
[16:12:51.240]                 is_error <- inherits(cond, "error")
[16:12:51.240]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.240]                   NULL)
[16:12:51.240]                 if (is_error) {
[16:12:51.240]                   sessionInformation <- function() {
[16:12:51.240]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.240]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.240]                       search = base::search(), system = base::Sys.info())
[16:12:51.240]                   }
[16:12:51.240]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.240]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.240]                     cond$call), session = sessionInformation(), 
[16:12:51.240]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.240]                   signalCondition(cond)
[16:12:51.240]                 }
[16:12:51.240]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.240]                 "immediateCondition"))) {
[16:12:51.240]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.240]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.240]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.240]                   if (TRUE && !signal) {
[16:12:51.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.240]                     {
[16:12:51.240]                       inherits <- base::inherits
[16:12:51.240]                       invokeRestart <- base::invokeRestart
[16:12:51.240]                       is.null <- base::is.null
[16:12:51.240]                       muffled <- FALSE
[16:12:51.240]                       if (inherits(cond, "message")) {
[16:12:51.240]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.240]                         if (muffled) 
[16:12:51.240]                           invokeRestart("muffleMessage")
[16:12:51.240]                       }
[16:12:51.240]                       else if (inherits(cond, "warning")) {
[16:12:51.240]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.240]                         if (muffled) 
[16:12:51.240]                           invokeRestart("muffleWarning")
[16:12:51.240]                       }
[16:12:51.240]                       else if (inherits(cond, "condition")) {
[16:12:51.240]                         if (!is.null(pattern)) {
[16:12:51.240]                           computeRestarts <- base::computeRestarts
[16:12:51.240]                           grepl <- base::grepl
[16:12:51.240]                           restarts <- computeRestarts(cond)
[16:12:51.240]                           for (restart in restarts) {
[16:12:51.240]                             name <- restart$name
[16:12:51.240]                             if (is.null(name)) 
[16:12:51.240]                               next
[16:12:51.240]                             if (!grepl(pattern, name)) 
[16:12:51.240]                               next
[16:12:51.240]                             invokeRestart(restart)
[16:12:51.240]                             muffled <- TRUE
[16:12:51.240]                             break
[16:12:51.240]                           }
[16:12:51.240]                         }
[16:12:51.240]                       }
[16:12:51.240]                       invisible(muffled)
[16:12:51.240]                     }
[16:12:51.240]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.240]                   }
[16:12:51.240]                 }
[16:12:51.240]                 else {
[16:12:51.240]                   if (TRUE) {
[16:12:51.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.240]                     {
[16:12:51.240]                       inherits <- base::inherits
[16:12:51.240]                       invokeRestart <- base::invokeRestart
[16:12:51.240]                       is.null <- base::is.null
[16:12:51.240]                       muffled <- FALSE
[16:12:51.240]                       if (inherits(cond, "message")) {
[16:12:51.240]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.240]                         if (muffled) 
[16:12:51.240]                           invokeRestart("muffleMessage")
[16:12:51.240]                       }
[16:12:51.240]                       else if (inherits(cond, "warning")) {
[16:12:51.240]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.240]                         if (muffled) 
[16:12:51.240]                           invokeRestart("muffleWarning")
[16:12:51.240]                       }
[16:12:51.240]                       else if (inherits(cond, "condition")) {
[16:12:51.240]                         if (!is.null(pattern)) {
[16:12:51.240]                           computeRestarts <- base::computeRestarts
[16:12:51.240]                           grepl <- base::grepl
[16:12:51.240]                           restarts <- computeRestarts(cond)
[16:12:51.240]                           for (restart in restarts) {
[16:12:51.240]                             name <- restart$name
[16:12:51.240]                             if (is.null(name)) 
[16:12:51.240]                               next
[16:12:51.240]                             if (!grepl(pattern, name)) 
[16:12:51.240]                               next
[16:12:51.240]                             invokeRestart(restart)
[16:12:51.240]                             muffled <- TRUE
[16:12:51.240]                             break
[16:12:51.240]                           }
[16:12:51.240]                         }
[16:12:51.240]                       }
[16:12:51.240]                       invisible(muffled)
[16:12:51.240]                     }
[16:12:51.240]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.240]                   }
[16:12:51.240]                 }
[16:12:51.240]             }
[16:12:51.240]         }))
[16:12:51.240]     }, error = function(ex) {
[16:12:51.240]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.240]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.240]                 ...future.rng), started = ...future.startTime, 
[16:12:51.240]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.240]             version = "1.8"), class = "FutureResult")
[16:12:51.240]     }, finally = {
[16:12:51.240]         if (!identical(...future.workdir, getwd())) 
[16:12:51.240]             setwd(...future.workdir)
[16:12:51.240]         {
[16:12:51.240]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.240]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.240]             }
[16:12:51.240]             base::options(...future.oldOptions)
[16:12:51.240]             if (.Platform$OS.type == "windows") {
[16:12:51.240]                 old_names <- names(...future.oldEnvVars)
[16:12:51.240]                 envs <- base::Sys.getenv()
[16:12:51.240]                 names <- names(envs)
[16:12:51.240]                 common <- intersect(names, old_names)
[16:12:51.240]                 added <- setdiff(names, old_names)
[16:12:51.240]                 removed <- setdiff(old_names, names)
[16:12:51.240]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.240]                   envs[common]]
[16:12:51.240]                 NAMES <- toupper(changed)
[16:12:51.240]                 args <- list()
[16:12:51.240]                 for (kk in seq_along(NAMES)) {
[16:12:51.240]                   name <- changed[[kk]]
[16:12:51.240]                   NAME <- NAMES[[kk]]
[16:12:51.240]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.240]                     next
[16:12:51.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.240]                 }
[16:12:51.240]                 NAMES <- toupper(added)
[16:12:51.240]                 for (kk in seq_along(NAMES)) {
[16:12:51.240]                   name <- added[[kk]]
[16:12:51.240]                   NAME <- NAMES[[kk]]
[16:12:51.240]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.240]                     next
[16:12:51.240]                   args[[name]] <- ""
[16:12:51.240]                 }
[16:12:51.240]                 NAMES <- toupper(removed)
[16:12:51.240]                 for (kk in seq_along(NAMES)) {
[16:12:51.240]                   name <- removed[[kk]]
[16:12:51.240]                   NAME <- NAMES[[kk]]
[16:12:51.240]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.240]                     next
[16:12:51.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.240]                 }
[16:12:51.240]                 if (length(args) > 0) 
[16:12:51.240]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.240]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.240]             }
[16:12:51.240]             else {
[16:12:51.240]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.240]             }
[16:12:51.240]             {
[16:12:51.240]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.240]                   0L) {
[16:12:51.240]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.240]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.240]                   base::options(opts)
[16:12:51.240]                 }
[16:12:51.240]                 {
[16:12:51.240]                   {
[16:12:51.240]                     NULL
[16:12:51.240]                     RNGkind("Mersenne-Twister")
[16:12:51.240]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.240]                       inherits = FALSE)
[16:12:51.240]                   }
[16:12:51.240]                   options(future.plan = NULL)
[16:12:51.240]                   if (is.na(NA_character_)) 
[16:12:51.240]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.240]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.240]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.240]                   {
[16:12:51.240]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.240]                     if (!future$lazy) 
[16:12:51.240]                       future <- run(future)
[16:12:51.240]                     invisible(future)
[16:12:51.240]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.240]                 }
[16:12:51.240]             }
[16:12:51.240]         }
[16:12:51.240]     })
[16:12:51.240]     if (TRUE) {
[16:12:51.240]         base::sink(type = "output", split = FALSE)
[16:12:51.240]         if (TRUE) {
[16:12:51.240]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.240]         }
[16:12:51.240]         else {
[16:12:51.240]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.240]         }
[16:12:51.240]         base::close(...future.stdout)
[16:12:51.240]         ...future.stdout <- NULL
[16:12:51.240]     }
[16:12:51.240]     ...future.result$conditions <- ...future.conditions
[16:12:51.240]     ...future.result$finished <- base::Sys.time()
[16:12:51.240]     ...future.result
[16:12:51.240] }
[16:12:51.241] plan(): Setting new future strategy stack:
[16:12:51.242] List of future strategies:
[16:12:51.242] 1. sequential:
[16:12:51.242]    - args: function (..., envir = parent.frame())
[16:12:51.242]    - tweaked: FALSE
[16:12:51.242]    - call: NULL
[16:12:51.242] plan(): nbrOfWorkers() = 1
[16:12:51.243] plan(): Setting new future strategy stack:
[16:12:51.243] List of future strategies:
[16:12:51.243] 1. sequential:
[16:12:51.243]    - args: function (..., envir = parent.frame())
[16:12:51.243]    - tweaked: FALSE
[16:12:51.243]    - call: plan(strategy)
[16:12:51.243] plan(): nbrOfWorkers() = 1
[16:12:51.243] SequentialFuture started (and completed)
[16:12:51.243] - Launch lazy future ... done
[16:12:51.243] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.244] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.244] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:51.244] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:51.245] Searching for globals ... DONE
[16:12:51.245] Resolving globals: TRUE
[16:12:51.245] Resolving any globals that are futures ...
[16:12:51.245] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:51.245] Resolving any globals that are futures ... DONE
[16:12:51.245] Resolving futures part of globals (recursively) ...
[16:12:51.246] resolve() on list ...
[16:12:51.246]  recursive: 99
[16:12:51.246]  length: 1
[16:12:51.246]  elements: ‘a’
[16:12:51.246] resolved() for ‘SequentialFuture’ ...
[16:12:51.246] - state: ‘finished’
[16:12:51.246] - run: TRUE
[16:12:51.246] - result: ‘FutureResult’
[16:12:51.246] resolved() for ‘SequentialFuture’ ... done
[16:12:51.246] Future #1
[16:12:51.247] resolved() for ‘SequentialFuture’ ...
[16:12:51.247] - state: ‘finished’
[16:12:51.247] - run: TRUE
[16:12:51.247] - result: ‘FutureResult’
[16:12:51.247] resolved() for ‘SequentialFuture’ ... done
[16:12:51.247] A SequentialFuture was resolved
[16:12:51.247]  length: 0 (resolved future 1)
[16:12:51.247] resolve() on list ... DONE
[16:12:51.247] - globals: [1] ‘a’
[16:12:51.247] Resolving futures part of globals (recursively) ... DONE
[16:12:51.249] The total size of the 1 globals is 1.52 MiB (1596048 bytes)
[16:12:51.249] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.52 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.52 MiB of class ‘environment’)
[16:12:51.250] - globals: [1] ‘a’
[16:12:51.250] - packages: [1] ‘future’
[16:12:51.250] getGlobalsAndPackages() ... DONE
[16:12:51.250] run() for ‘Future’ ...
[16:12:51.250] - state: ‘created’
[16:12:51.250] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.251] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.251] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.251]   - Field: ‘label’
[16:12:51.251]   - Field: ‘local’
[16:12:51.251]   - Field: ‘owner’
[16:12:51.251]   - Field: ‘envir’
[16:12:51.251]   - Field: ‘packages’
[16:12:51.251]   - Field: ‘gc’
[16:12:51.251]   - Field: ‘conditions’
[16:12:51.251]   - Field: ‘expr’
[16:12:51.252]   - Field: ‘uuid’
[16:12:51.252]   - Field: ‘seed’
[16:12:51.252]   - Field: ‘version’
[16:12:51.252]   - Field: ‘result’
[16:12:51.252]   - Field: ‘asynchronous’
[16:12:51.252]   - Field: ‘calls’
[16:12:51.252]   - Field: ‘globals’
[16:12:51.252]   - Field: ‘stdout’
[16:12:51.252]   - Field: ‘earlySignal’
[16:12:51.252]   - Field: ‘lazy’
[16:12:51.252]   - Field: ‘state’
[16:12:51.253] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.253] - Launch lazy future ...
[16:12:51.253] Packages needed by the future expression (n = 1): ‘future’
[16:12:51.253] Packages needed by future strategies (n = 0): <none>
[16:12:51.253] {
[16:12:51.253]     {
[16:12:51.253]         {
[16:12:51.253]             ...future.startTime <- base::Sys.time()
[16:12:51.253]             {
[16:12:51.253]                 {
[16:12:51.253]                   {
[16:12:51.253]                     {
[16:12:51.253]                       base::local({
[16:12:51.253]                         has_future <- base::requireNamespace("future", 
[16:12:51.253]                           quietly = TRUE)
[16:12:51.253]                         if (has_future) {
[16:12:51.253]                           ns <- base::getNamespace("future")
[16:12:51.253]                           version <- ns[[".package"]][["version"]]
[16:12:51.253]                           if (is.null(version)) 
[16:12:51.253]                             version <- utils::packageVersion("future")
[16:12:51.253]                         }
[16:12:51.253]                         else {
[16:12:51.253]                           version <- NULL
[16:12:51.253]                         }
[16:12:51.253]                         if (!has_future || version < "1.8.0") {
[16:12:51.253]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.253]                             "", base::R.version$version.string), 
[16:12:51.253]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:51.253]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.253]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.253]                               "release", "version")], collapse = " "), 
[16:12:51.253]                             hostname = base::Sys.info()[["nodename"]])
[16:12:51.253]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.253]                             info)
[16:12:51.253]                           info <- base::paste(info, collapse = "; ")
[16:12:51.253]                           if (!has_future) {
[16:12:51.253]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.253]                               info)
[16:12:51.253]                           }
[16:12:51.253]                           else {
[16:12:51.253]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.253]                               info, version)
[16:12:51.253]                           }
[16:12:51.253]                           base::stop(msg)
[16:12:51.253]                         }
[16:12:51.253]                       })
[16:12:51.253]                     }
[16:12:51.253]                     base::local({
[16:12:51.253]                       for (pkg in "future") {
[16:12:51.253]                         base::loadNamespace(pkg)
[16:12:51.253]                         base::library(pkg, character.only = TRUE)
[16:12:51.253]                       }
[16:12:51.253]                     })
[16:12:51.253]                   }
[16:12:51.253]                   options(future.plan = NULL)
[16:12:51.253]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.253]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.253]                 }
[16:12:51.253]                 ...future.workdir <- getwd()
[16:12:51.253]             }
[16:12:51.253]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.253]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.253]         }
[16:12:51.253]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.253]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:51.253]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.253]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.253]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.253]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.253]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.253]             base::names(...future.oldOptions))
[16:12:51.253]     }
[16:12:51.253]     if (FALSE) {
[16:12:51.253]     }
[16:12:51.253]     else {
[16:12:51.253]         if (TRUE) {
[16:12:51.253]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.253]                 open = "w")
[16:12:51.253]         }
[16:12:51.253]         else {
[16:12:51.253]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.253]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.253]         }
[16:12:51.253]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.253]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.253]             base::sink(type = "output", split = FALSE)
[16:12:51.253]             base::close(...future.stdout)
[16:12:51.253]         }, add = TRUE)
[16:12:51.253]     }
[16:12:51.253]     ...future.frame <- base::sys.nframe()
[16:12:51.253]     ...future.conditions <- base::list()
[16:12:51.253]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.253]     if (FALSE) {
[16:12:51.253]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.253]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.253]     }
[16:12:51.253]     ...future.result <- base::tryCatch({
[16:12:51.253]         base::withCallingHandlers({
[16:12:51.253]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:12:51.253]                 1))
[16:12:51.253]             future::FutureResult(value = ...future.value$value, 
[16:12:51.253]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.253]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.253]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.253]                     ...future.globalenv.names))
[16:12:51.253]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.253]         }, condition = base::local({
[16:12:51.253]             c <- base::c
[16:12:51.253]             inherits <- base::inherits
[16:12:51.253]             invokeRestart <- base::invokeRestart
[16:12:51.253]             length <- base::length
[16:12:51.253]             list <- base::list
[16:12:51.253]             seq.int <- base::seq.int
[16:12:51.253]             signalCondition <- base::signalCondition
[16:12:51.253]             sys.calls <- base::sys.calls
[16:12:51.253]             `[[` <- base::`[[`
[16:12:51.253]             `+` <- base::`+`
[16:12:51.253]             `<<-` <- base::`<<-`
[16:12:51.253]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.253]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.253]                   3L)]
[16:12:51.253]             }
[16:12:51.253]             function(cond) {
[16:12:51.253]                 is_error <- inherits(cond, "error")
[16:12:51.253]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.253]                   NULL)
[16:12:51.253]                 if (is_error) {
[16:12:51.253]                   sessionInformation <- function() {
[16:12:51.253]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.253]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.253]                       search = base::search(), system = base::Sys.info())
[16:12:51.253]                   }
[16:12:51.253]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.253]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.253]                     cond$call), session = sessionInformation(), 
[16:12:51.253]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.253]                   signalCondition(cond)
[16:12:51.253]                 }
[16:12:51.253]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.253]                 "immediateCondition"))) {
[16:12:51.253]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.253]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.253]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.253]                   if (TRUE && !signal) {
[16:12:51.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.253]                     {
[16:12:51.253]                       inherits <- base::inherits
[16:12:51.253]                       invokeRestart <- base::invokeRestart
[16:12:51.253]                       is.null <- base::is.null
[16:12:51.253]                       muffled <- FALSE
[16:12:51.253]                       if (inherits(cond, "message")) {
[16:12:51.253]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.253]                         if (muffled) 
[16:12:51.253]                           invokeRestart("muffleMessage")
[16:12:51.253]                       }
[16:12:51.253]                       else if (inherits(cond, "warning")) {
[16:12:51.253]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.253]                         if (muffled) 
[16:12:51.253]                           invokeRestart("muffleWarning")
[16:12:51.253]                       }
[16:12:51.253]                       else if (inherits(cond, "condition")) {
[16:12:51.253]                         if (!is.null(pattern)) {
[16:12:51.253]                           computeRestarts <- base::computeRestarts
[16:12:51.253]                           grepl <- base::grepl
[16:12:51.253]                           restarts <- computeRestarts(cond)
[16:12:51.253]                           for (restart in restarts) {
[16:12:51.253]                             name <- restart$name
[16:12:51.253]                             if (is.null(name)) 
[16:12:51.253]                               next
[16:12:51.253]                             if (!grepl(pattern, name)) 
[16:12:51.253]                               next
[16:12:51.253]                             invokeRestart(restart)
[16:12:51.253]                             muffled <- TRUE
[16:12:51.253]                             break
[16:12:51.253]                           }
[16:12:51.253]                         }
[16:12:51.253]                       }
[16:12:51.253]                       invisible(muffled)
[16:12:51.253]                     }
[16:12:51.253]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.253]                   }
[16:12:51.253]                 }
[16:12:51.253]                 else {
[16:12:51.253]                   if (TRUE) {
[16:12:51.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.253]                     {
[16:12:51.253]                       inherits <- base::inherits
[16:12:51.253]                       invokeRestart <- base::invokeRestart
[16:12:51.253]                       is.null <- base::is.null
[16:12:51.253]                       muffled <- FALSE
[16:12:51.253]                       if (inherits(cond, "message")) {
[16:12:51.253]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.253]                         if (muffled) 
[16:12:51.253]                           invokeRestart("muffleMessage")
[16:12:51.253]                       }
[16:12:51.253]                       else if (inherits(cond, "warning")) {
[16:12:51.253]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.253]                         if (muffled) 
[16:12:51.253]                           invokeRestart("muffleWarning")
[16:12:51.253]                       }
[16:12:51.253]                       else if (inherits(cond, "condition")) {
[16:12:51.253]                         if (!is.null(pattern)) {
[16:12:51.253]                           computeRestarts <- base::computeRestarts
[16:12:51.253]                           grepl <- base::grepl
[16:12:51.253]                           restarts <- computeRestarts(cond)
[16:12:51.253]                           for (restart in restarts) {
[16:12:51.253]                             name <- restart$name
[16:12:51.253]                             if (is.null(name)) 
[16:12:51.253]                               next
[16:12:51.253]                             if (!grepl(pattern, name)) 
[16:12:51.253]                               next
[16:12:51.253]                             invokeRestart(restart)
[16:12:51.253]                             muffled <- TRUE
[16:12:51.253]                             break
[16:12:51.253]                           }
[16:12:51.253]                         }
[16:12:51.253]                       }
[16:12:51.253]                       invisible(muffled)
[16:12:51.253]                     }
[16:12:51.253]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.253]                   }
[16:12:51.253]                 }
[16:12:51.253]             }
[16:12:51.253]         }))
[16:12:51.253]     }, error = function(ex) {
[16:12:51.253]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.253]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.253]                 ...future.rng), started = ...future.startTime, 
[16:12:51.253]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.253]             version = "1.8"), class = "FutureResult")
[16:12:51.253]     }, finally = {
[16:12:51.253]         if (!identical(...future.workdir, getwd())) 
[16:12:51.253]             setwd(...future.workdir)
[16:12:51.253]         {
[16:12:51.253]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.253]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.253]             }
[16:12:51.253]             base::options(...future.oldOptions)
[16:12:51.253]             if (.Platform$OS.type == "windows") {
[16:12:51.253]                 old_names <- names(...future.oldEnvVars)
[16:12:51.253]                 envs <- base::Sys.getenv()
[16:12:51.253]                 names <- names(envs)
[16:12:51.253]                 common <- intersect(names, old_names)
[16:12:51.253]                 added <- setdiff(names, old_names)
[16:12:51.253]                 removed <- setdiff(old_names, names)
[16:12:51.253]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.253]                   envs[common]]
[16:12:51.253]                 NAMES <- toupper(changed)
[16:12:51.253]                 args <- list()
[16:12:51.253]                 for (kk in seq_along(NAMES)) {
[16:12:51.253]                   name <- changed[[kk]]
[16:12:51.253]                   NAME <- NAMES[[kk]]
[16:12:51.253]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.253]                     next
[16:12:51.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.253]                 }
[16:12:51.253]                 NAMES <- toupper(added)
[16:12:51.253]                 for (kk in seq_along(NAMES)) {
[16:12:51.253]                   name <- added[[kk]]
[16:12:51.253]                   NAME <- NAMES[[kk]]
[16:12:51.253]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.253]                     next
[16:12:51.253]                   args[[name]] <- ""
[16:12:51.253]                 }
[16:12:51.253]                 NAMES <- toupper(removed)
[16:12:51.253]                 for (kk in seq_along(NAMES)) {
[16:12:51.253]                   name <- removed[[kk]]
[16:12:51.253]                   NAME <- NAMES[[kk]]
[16:12:51.253]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.253]                     next
[16:12:51.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.253]                 }
[16:12:51.253]                 if (length(args) > 0) 
[16:12:51.253]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.253]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.253]             }
[16:12:51.253]             else {
[16:12:51.253]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.253]             }
[16:12:51.253]             {
[16:12:51.253]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.253]                   0L) {
[16:12:51.253]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.253]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.253]                   base::options(opts)
[16:12:51.253]                 }
[16:12:51.253]                 {
[16:12:51.253]                   {
[16:12:51.253]                     NULL
[16:12:51.253]                     RNGkind("Mersenne-Twister")
[16:12:51.253]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.253]                       inherits = FALSE)
[16:12:51.253]                   }
[16:12:51.253]                   options(future.plan = NULL)
[16:12:51.253]                   if (is.na(NA_character_)) 
[16:12:51.253]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.253]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.253]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.253]                   {
[16:12:51.253]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.253]                     if (!future$lazy) 
[16:12:51.253]                       future <- run(future)
[16:12:51.253]                     invisible(future)
[16:12:51.253]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.253]                 }
[16:12:51.253]             }
[16:12:51.253]         }
[16:12:51.253]     })
[16:12:51.253]     if (TRUE) {
[16:12:51.253]         base::sink(type = "output", split = FALSE)
[16:12:51.253]         if (TRUE) {
[16:12:51.253]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.253]         }
[16:12:51.253]         else {
[16:12:51.253]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.253]         }
[16:12:51.253]         base::close(...future.stdout)
[16:12:51.253]         ...future.stdout <- NULL
[16:12:51.253]     }
[16:12:51.253]     ...future.result$conditions <- ...future.conditions
[16:12:51.253]     ...future.result$finished <- base::Sys.time()
[16:12:51.253]     ...future.result
[16:12:51.253] }
[16:12:51.255] assign_globals() ...
[16:12:51.255] List of 1
[16:12:51.255]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x56233bf01190> 
[16:12:51.255]  - attr(*, "where")=List of 1
[16:12:51.255]   ..$ a:<environment: R_EmptyEnv> 
[16:12:51.255]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.255]  - attr(*, "resolved")= logi TRUE
[16:12:51.255]  - attr(*, "total_size")= num 1596048
[16:12:51.255]  - attr(*, "already-done")= logi TRUE
[16:12:51.285] - copied ‘a’ to environment
[16:12:51.285] assign_globals() ... done
[16:12:51.286] plan(): Setting new future strategy stack:
[16:12:51.286] List of future strategies:
[16:12:51.286] 1. sequential:
[16:12:51.286]    - args: function (..., envir = parent.frame())
[16:12:51.286]    - tweaked: FALSE
[16:12:51.286]    - call: NULL
[16:12:51.286] plan(): nbrOfWorkers() = 1
[16:12:51.287] plan(): Setting new future strategy stack:
[16:12:51.287] List of future strategies:
[16:12:51.287] 1. sequential:
[16:12:51.287]    - args: function (..., envir = parent.frame())
[16:12:51.287]    - tweaked: FALSE
[16:12:51.287]    - call: plan(strategy)
[16:12:51.288] plan(): nbrOfWorkers() = 1
[16:12:51.288] SequentialFuture started (and completed)
[16:12:51.288] - Launch lazy future ... done
[16:12:51.288] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.289] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.289] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:51.289] 
[16:12:51.289] Searching for globals ... DONE
[16:12:51.289] - globals: [0] <none>
[16:12:51.289] getGlobalsAndPackages() ... DONE
[16:12:51.290] run() for ‘Future’ ...
[16:12:51.290] - state: ‘created’
[16:12:51.290] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.290] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.290] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.290]   - Field: ‘label’
[16:12:51.291]   - Field: ‘local’
[16:12:51.291]   - Field: ‘owner’
[16:12:51.291]   - Field: ‘envir’
[16:12:51.291]   - Field: ‘packages’
[16:12:51.291]   - Field: ‘gc’
[16:12:51.291]   - Field: ‘conditions’
[16:12:51.291]   - Field: ‘expr’
[16:12:51.291]   - Field: ‘uuid’
[16:12:51.291]   - Field: ‘seed’
[16:12:51.291]   - Field: ‘version’
[16:12:51.291]   - Field: ‘result’
[16:12:51.292]   - Field: ‘asynchronous’
[16:12:51.292]   - Field: ‘calls’
[16:12:51.292]   - Field: ‘globals’
[16:12:51.292]   - Field: ‘stdout’
[16:12:51.292]   - Field: ‘earlySignal’
[16:12:51.292]   - Field: ‘lazy’
[16:12:51.292]   - Field: ‘state’
[16:12:51.292] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.292] - Launch lazy future ...
[16:12:51.292] Packages needed by the future expression (n = 0): <none>
[16:12:51.293] Packages needed by future strategies (n = 0): <none>
[16:12:51.293] {
[16:12:51.293]     {
[16:12:51.293]         {
[16:12:51.293]             ...future.startTime <- base::Sys.time()
[16:12:51.293]             {
[16:12:51.293]                 {
[16:12:51.293]                   {
[16:12:51.293]                     base::local({
[16:12:51.293]                       has_future <- base::requireNamespace("future", 
[16:12:51.293]                         quietly = TRUE)
[16:12:51.293]                       if (has_future) {
[16:12:51.293]                         ns <- base::getNamespace("future")
[16:12:51.293]                         version <- ns[[".package"]][["version"]]
[16:12:51.293]                         if (is.null(version)) 
[16:12:51.293]                           version <- utils::packageVersion("future")
[16:12:51.293]                       }
[16:12:51.293]                       else {
[16:12:51.293]                         version <- NULL
[16:12:51.293]                       }
[16:12:51.293]                       if (!has_future || version < "1.8.0") {
[16:12:51.293]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.293]                           "", base::R.version$version.string), 
[16:12:51.293]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:51.293]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.293]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.293]                             "release", "version")], collapse = " "), 
[16:12:51.293]                           hostname = base::Sys.info()[["nodename"]])
[16:12:51.293]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.293]                           info)
[16:12:51.293]                         info <- base::paste(info, collapse = "; ")
[16:12:51.293]                         if (!has_future) {
[16:12:51.293]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.293]                             info)
[16:12:51.293]                         }
[16:12:51.293]                         else {
[16:12:51.293]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.293]                             info, version)
[16:12:51.293]                         }
[16:12:51.293]                         base::stop(msg)
[16:12:51.293]                       }
[16:12:51.293]                     })
[16:12:51.293]                   }
[16:12:51.293]                   options(future.plan = NULL)
[16:12:51.293]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.293]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.293]                 }
[16:12:51.293]                 ...future.workdir <- getwd()
[16:12:51.293]             }
[16:12:51.293]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.293]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.293]         }
[16:12:51.293]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.293]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:51.293]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.293]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.293]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.293]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.293]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.293]             base::names(...future.oldOptions))
[16:12:51.293]     }
[16:12:51.293]     if (FALSE) {
[16:12:51.293]     }
[16:12:51.293]     else {
[16:12:51.293]         if (TRUE) {
[16:12:51.293]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.293]                 open = "w")
[16:12:51.293]         }
[16:12:51.293]         else {
[16:12:51.293]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.293]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.293]         }
[16:12:51.293]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.293]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.293]             base::sink(type = "output", split = FALSE)
[16:12:51.293]             base::close(...future.stdout)
[16:12:51.293]         }, add = TRUE)
[16:12:51.293]     }
[16:12:51.293]     ...future.frame <- base::sys.nframe()
[16:12:51.293]     ...future.conditions <- base::list()
[16:12:51.293]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.293]     if (FALSE) {
[16:12:51.293]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.293]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.293]     }
[16:12:51.293]     ...future.result <- base::tryCatch({
[16:12:51.293]         base::withCallingHandlers({
[16:12:51.293]             ...future.value <- base::withVisible(base::local(1))
[16:12:51.293]             future::FutureResult(value = ...future.value$value, 
[16:12:51.293]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.293]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.293]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.293]                     ...future.globalenv.names))
[16:12:51.293]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.293]         }, condition = base::local({
[16:12:51.293]             c <- base::c
[16:12:51.293]             inherits <- base::inherits
[16:12:51.293]             invokeRestart <- base::invokeRestart
[16:12:51.293]             length <- base::length
[16:12:51.293]             list <- base::list
[16:12:51.293]             seq.int <- base::seq.int
[16:12:51.293]             signalCondition <- base::signalCondition
[16:12:51.293]             sys.calls <- base::sys.calls
[16:12:51.293]             `[[` <- base::`[[`
[16:12:51.293]             `+` <- base::`+`
[16:12:51.293]             `<<-` <- base::`<<-`
[16:12:51.293]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.293]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.293]                   3L)]
[16:12:51.293]             }
[16:12:51.293]             function(cond) {
[16:12:51.293]                 is_error <- inherits(cond, "error")
[16:12:51.293]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.293]                   NULL)
[16:12:51.293]                 if (is_error) {
[16:12:51.293]                   sessionInformation <- function() {
[16:12:51.293]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.293]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.293]                       search = base::search(), system = base::Sys.info())
[16:12:51.293]                   }
[16:12:51.293]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.293]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.293]                     cond$call), session = sessionInformation(), 
[16:12:51.293]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.293]                   signalCondition(cond)
[16:12:51.293]                 }
[16:12:51.293]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.293]                 "immediateCondition"))) {
[16:12:51.293]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.293]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.293]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.293]                   if (TRUE && !signal) {
[16:12:51.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.293]                     {
[16:12:51.293]                       inherits <- base::inherits
[16:12:51.293]                       invokeRestart <- base::invokeRestart
[16:12:51.293]                       is.null <- base::is.null
[16:12:51.293]                       muffled <- FALSE
[16:12:51.293]                       if (inherits(cond, "message")) {
[16:12:51.293]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.293]                         if (muffled) 
[16:12:51.293]                           invokeRestart("muffleMessage")
[16:12:51.293]                       }
[16:12:51.293]                       else if (inherits(cond, "warning")) {
[16:12:51.293]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.293]                         if (muffled) 
[16:12:51.293]                           invokeRestart("muffleWarning")
[16:12:51.293]                       }
[16:12:51.293]                       else if (inherits(cond, "condition")) {
[16:12:51.293]                         if (!is.null(pattern)) {
[16:12:51.293]                           computeRestarts <- base::computeRestarts
[16:12:51.293]                           grepl <- base::grepl
[16:12:51.293]                           restarts <- computeRestarts(cond)
[16:12:51.293]                           for (restart in restarts) {
[16:12:51.293]                             name <- restart$name
[16:12:51.293]                             if (is.null(name)) 
[16:12:51.293]                               next
[16:12:51.293]                             if (!grepl(pattern, name)) 
[16:12:51.293]                               next
[16:12:51.293]                             invokeRestart(restart)
[16:12:51.293]                             muffled <- TRUE
[16:12:51.293]                             break
[16:12:51.293]                           }
[16:12:51.293]                         }
[16:12:51.293]                       }
[16:12:51.293]                       invisible(muffled)
[16:12:51.293]                     }
[16:12:51.293]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.293]                   }
[16:12:51.293]                 }
[16:12:51.293]                 else {
[16:12:51.293]                   if (TRUE) {
[16:12:51.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.293]                     {
[16:12:51.293]                       inherits <- base::inherits
[16:12:51.293]                       invokeRestart <- base::invokeRestart
[16:12:51.293]                       is.null <- base::is.null
[16:12:51.293]                       muffled <- FALSE
[16:12:51.293]                       if (inherits(cond, "message")) {
[16:12:51.293]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.293]                         if (muffled) 
[16:12:51.293]                           invokeRestart("muffleMessage")
[16:12:51.293]                       }
[16:12:51.293]                       else if (inherits(cond, "warning")) {
[16:12:51.293]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.293]                         if (muffled) 
[16:12:51.293]                           invokeRestart("muffleWarning")
[16:12:51.293]                       }
[16:12:51.293]                       else if (inherits(cond, "condition")) {
[16:12:51.293]                         if (!is.null(pattern)) {
[16:12:51.293]                           computeRestarts <- base::computeRestarts
[16:12:51.293]                           grepl <- base::grepl
[16:12:51.293]                           restarts <- computeRestarts(cond)
[16:12:51.293]                           for (restart in restarts) {
[16:12:51.293]                             name <- restart$name
[16:12:51.293]                             if (is.null(name)) 
[16:12:51.293]                               next
[16:12:51.293]                             if (!grepl(pattern, name)) 
[16:12:51.293]                               next
[16:12:51.293]                             invokeRestart(restart)
[16:12:51.293]                             muffled <- TRUE
[16:12:51.293]                             break
[16:12:51.293]                           }
[16:12:51.293]                         }
[16:12:51.293]                       }
[16:12:51.293]                       invisible(muffled)
[16:12:51.293]                     }
[16:12:51.293]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.293]                   }
[16:12:51.293]                 }
[16:12:51.293]             }
[16:12:51.293]         }))
[16:12:51.293]     }, error = function(ex) {
[16:12:51.293]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.293]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.293]                 ...future.rng), started = ...future.startTime, 
[16:12:51.293]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.293]             version = "1.8"), class = "FutureResult")
[16:12:51.293]     }, finally = {
[16:12:51.293]         if (!identical(...future.workdir, getwd())) 
[16:12:51.293]             setwd(...future.workdir)
[16:12:51.293]         {
[16:12:51.293]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.293]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.293]             }
[16:12:51.293]             base::options(...future.oldOptions)
[16:12:51.293]             if (.Platform$OS.type == "windows") {
[16:12:51.293]                 old_names <- names(...future.oldEnvVars)
[16:12:51.293]                 envs <- base::Sys.getenv()
[16:12:51.293]                 names <- names(envs)
[16:12:51.293]                 common <- intersect(names, old_names)
[16:12:51.293]                 added <- setdiff(names, old_names)
[16:12:51.293]                 removed <- setdiff(old_names, names)
[16:12:51.293]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.293]                   envs[common]]
[16:12:51.293]                 NAMES <- toupper(changed)
[16:12:51.293]                 args <- list()
[16:12:51.293]                 for (kk in seq_along(NAMES)) {
[16:12:51.293]                   name <- changed[[kk]]
[16:12:51.293]                   NAME <- NAMES[[kk]]
[16:12:51.293]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.293]                     next
[16:12:51.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.293]                 }
[16:12:51.293]                 NAMES <- toupper(added)
[16:12:51.293]                 for (kk in seq_along(NAMES)) {
[16:12:51.293]                   name <- added[[kk]]
[16:12:51.293]                   NAME <- NAMES[[kk]]
[16:12:51.293]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.293]                     next
[16:12:51.293]                   args[[name]] <- ""
[16:12:51.293]                 }
[16:12:51.293]                 NAMES <- toupper(removed)
[16:12:51.293]                 for (kk in seq_along(NAMES)) {
[16:12:51.293]                   name <- removed[[kk]]
[16:12:51.293]                   NAME <- NAMES[[kk]]
[16:12:51.293]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.293]                     next
[16:12:51.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.293]                 }
[16:12:51.293]                 if (length(args) > 0) 
[16:12:51.293]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.293]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.293]             }
[16:12:51.293]             else {
[16:12:51.293]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.293]             }
[16:12:51.293]             {
[16:12:51.293]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.293]                   0L) {
[16:12:51.293]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.293]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.293]                   base::options(opts)
[16:12:51.293]                 }
[16:12:51.293]                 {
[16:12:51.293]                   {
[16:12:51.293]                     NULL
[16:12:51.293]                     RNGkind("Mersenne-Twister")
[16:12:51.293]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.293]                       inherits = FALSE)
[16:12:51.293]                   }
[16:12:51.293]                   options(future.plan = NULL)
[16:12:51.293]                   if (is.na(NA_character_)) 
[16:12:51.293]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.293]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.293]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.293]                   {
[16:12:51.293]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.293]                     if (!future$lazy) 
[16:12:51.293]                       future <- run(future)
[16:12:51.293]                     invisible(future)
[16:12:51.293]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.293]                 }
[16:12:51.293]             }
[16:12:51.293]         }
[16:12:51.293]     })
[16:12:51.293]     if (TRUE) {
[16:12:51.293]         base::sink(type = "output", split = FALSE)
[16:12:51.293]         if (TRUE) {
[16:12:51.293]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.293]         }
[16:12:51.293]         else {
[16:12:51.293]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.293]         }
[16:12:51.293]         base::close(...future.stdout)
[16:12:51.293]         ...future.stdout <- NULL
[16:12:51.293]     }
[16:12:51.293]     ...future.result$conditions <- ...future.conditions
[16:12:51.293]     ...future.result$finished <- base::Sys.time()
[16:12:51.293]     ...future.result
[16:12:51.293] }
[16:12:51.295] plan(): Setting new future strategy stack:
[16:12:51.295] List of future strategies:
[16:12:51.295] 1. sequential:
[16:12:51.295]    - args: function (..., envir = parent.frame())
[16:12:51.295]    - tweaked: FALSE
[16:12:51.295]    - call: NULL
[16:12:51.295] plan(): nbrOfWorkers() = 1
[16:12:51.296] plan(): Setting new future strategy stack:
[16:12:51.296] List of future strategies:
[16:12:51.296] 1. sequential:
[16:12:51.296]    - args: function (..., envir = parent.frame())
[16:12:51.296]    - tweaked: FALSE
[16:12:51.296]    - call: plan(strategy)
[16:12:51.296] plan(): nbrOfWorkers() = 1
[16:12:51.297] SequentialFuture started (and completed)
[16:12:51.297] - Launch lazy future ... done
[16:12:51.297] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.297] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.297] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:51.298] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:51.298] Searching for globals ... DONE
[16:12:51.298] Resolving globals: TRUE
[16:12:51.298] Resolving any globals that are futures ...
[16:12:51.298] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:51.298] Resolving any globals that are futures ... DONE
[16:12:51.299] Resolving futures part of globals (recursively) ...
[16:12:51.299] resolve() on list ...
[16:12:51.299]  recursive: 99
[16:12:51.299]  length: 1
[16:12:51.299]  elements: ‘a’
[16:12:51.299] resolved() for ‘SequentialFuture’ ...
[16:12:51.299] - state: ‘finished’
[16:12:51.300] - run: TRUE
[16:12:51.300] - result: ‘FutureResult’
[16:12:51.300] resolved() for ‘SequentialFuture’ ... done
[16:12:51.300] Future #1
[16:12:51.300] resolved() for ‘SequentialFuture’ ...
[16:12:51.300] - state: ‘finished’
[16:12:51.300] - run: TRUE
[16:12:51.300] - result: ‘FutureResult’
[16:12:51.300] resolved() for ‘SequentialFuture’ ... done
[16:12:51.300] A SequentialFuture was resolved
[16:12:51.301]  length: 0 (resolved future 1)
[16:12:51.301] resolve() on list ... DONE
[16:12:51.301] - globals: [1] ‘a’
[16:12:51.301] Resolving futures part of globals (recursively) ... DONE
[16:12:51.303] The total size of the 1 globals is 1.52 MiB (1596048 bytes)
[16:12:51.303] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.52 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.52 MiB of class ‘environment’)
[16:12:51.303] - globals: [1] ‘a’
[16:12:51.303] - packages: [1] ‘future’
[16:12:51.303] getGlobalsAndPackages() ... DONE
[16:12:51.304] run() for ‘Future’ ...
[16:12:51.304] - state: ‘created’
[16:12:51.304] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.304] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.304] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.304]   - Field: ‘label’
[16:12:51.304]   - Field: ‘local’
[16:12:51.304]   - Field: ‘owner’
[16:12:51.305]   - Field: ‘envir’
[16:12:51.305]   - Field: ‘packages’
[16:12:51.305]   - Field: ‘gc’
[16:12:51.305]   - Field: ‘conditions’
[16:12:51.305]   - Field: ‘expr’
[16:12:51.305]   - Field: ‘uuid’
[16:12:51.305]   - Field: ‘seed’
[16:12:51.305]   - Field: ‘version’
[16:12:51.305]   - Field: ‘result’
[16:12:51.305]   - Field: ‘asynchronous’
[16:12:51.305]   - Field: ‘calls’
[16:12:51.306]   - Field: ‘globals’
[16:12:51.306]   - Field: ‘stdout’
[16:12:51.306]   - Field: ‘earlySignal’
[16:12:51.306]   - Field: ‘lazy’
[16:12:51.306]   - Field: ‘state’
[16:12:51.306] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.306] - Launch lazy future ...
[16:12:51.306] Packages needed by the future expression (n = 1): ‘future’
[16:12:51.306] Packages needed by future strategies (n = 0): <none>
[16:12:51.307] {
[16:12:51.307]     {
[16:12:51.307]         {
[16:12:51.307]             ...future.startTime <- base::Sys.time()
[16:12:51.307]             {
[16:12:51.307]                 {
[16:12:51.307]                   {
[16:12:51.307]                     {
[16:12:51.307]                       base::local({
[16:12:51.307]                         has_future <- base::requireNamespace("future", 
[16:12:51.307]                           quietly = TRUE)
[16:12:51.307]                         if (has_future) {
[16:12:51.307]                           ns <- base::getNamespace("future")
[16:12:51.307]                           version <- ns[[".package"]][["version"]]
[16:12:51.307]                           if (is.null(version)) 
[16:12:51.307]                             version <- utils::packageVersion("future")
[16:12:51.307]                         }
[16:12:51.307]                         else {
[16:12:51.307]                           version <- NULL
[16:12:51.307]                         }
[16:12:51.307]                         if (!has_future || version < "1.8.0") {
[16:12:51.307]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.307]                             "", base::R.version$version.string), 
[16:12:51.307]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:51.307]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.307]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.307]                               "release", "version")], collapse = " "), 
[16:12:51.307]                             hostname = base::Sys.info()[["nodename"]])
[16:12:51.307]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.307]                             info)
[16:12:51.307]                           info <- base::paste(info, collapse = "; ")
[16:12:51.307]                           if (!has_future) {
[16:12:51.307]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.307]                               info)
[16:12:51.307]                           }
[16:12:51.307]                           else {
[16:12:51.307]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.307]                               info, version)
[16:12:51.307]                           }
[16:12:51.307]                           base::stop(msg)
[16:12:51.307]                         }
[16:12:51.307]                       })
[16:12:51.307]                     }
[16:12:51.307]                     base::local({
[16:12:51.307]                       for (pkg in "future") {
[16:12:51.307]                         base::loadNamespace(pkg)
[16:12:51.307]                         base::library(pkg, character.only = TRUE)
[16:12:51.307]                       }
[16:12:51.307]                     })
[16:12:51.307]                   }
[16:12:51.307]                   options(future.plan = NULL)
[16:12:51.307]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.307]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.307]                 }
[16:12:51.307]                 ...future.workdir <- getwd()
[16:12:51.307]             }
[16:12:51.307]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.307]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.307]         }
[16:12:51.307]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.307]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:51.307]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.307]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.307]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.307]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.307]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.307]             base::names(...future.oldOptions))
[16:12:51.307]     }
[16:12:51.307]     if (FALSE) {
[16:12:51.307]     }
[16:12:51.307]     else {
[16:12:51.307]         if (TRUE) {
[16:12:51.307]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.307]                 open = "w")
[16:12:51.307]         }
[16:12:51.307]         else {
[16:12:51.307]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.307]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.307]         }
[16:12:51.307]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.307]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.307]             base::sink(type = "output", split = FALSE)
[16:12:51.307]             base::close(...future.stdout)
[16:12:51.307]         }, add = TRUE)
[16:12:51.307]     }
[16:12:51.307]     ...future.frame <- base::sys.nframe()
[16:12:51.307]     ...future.conditions <- base::list()
[16:12:51.307]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.307]     if (FALSE) {
[16:12:51.307]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.307]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.307]     }
[16:12:51.307]     ...future.result <- base::tryCatch({
[16:12:51.307]         base::withCallingHandlers({
[16:12:51.307]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:12:51.307]                 1))
[16:12:51.307]             future::FutureResult(value = ...future.value$value, 
[16:12:51.307]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.307]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.307]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.307]                     ...future.globalenv.names))
[16:12:51.307]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.307]         }, condition = base::local({
[16:12:51.307]             c <- base::c
[16:12:51.307]             inherits <- base::inherits
[16:12:51.307]             invokeRestart <- base::invokeRestart
[16:12:51.307]             length <- base::length
[16:12:51.307]             list <- base::list
[16:12:51.307]             seq.int <- base::seq.int
[16:12:51.307]             signalCondition <- base::signalCondition
[16:12:51.307]             sys.calls <- base::sys.calls
[16:12:51.307]             `[[` <- base::`[[`
[16:12:51.307]             `+` <- base::`+`
[16:12:51.307]             `<<-` <- base::`<<-`
[16:12:51.307]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.307]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.307]                   3L)]
[16:12:51.307]             }
[16:12:51.307]             function(cond) {
[16:12:51.307]                 is_error <- inherits(cond, "error")
[16:12:51.307]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.307]                   NULL)
[16:12:51.307]                 if (is_error) {
[16:12:51.307]                   sessionInformation <- function() {
[16:12:51.307]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.307]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.307]                       search = base::search(), system = base::Sys.info())
[16:12:51.307]                   }
[16:12:51.307]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.307]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.307]                     cond$call), session = sessionInformation(), 
[16:12:51.307]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.307]                   signalCondition(cond)
[16:12:51.307]                 }
[16:12:51.307]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.307]                 "immediateCondition"))) {
[16:12:51.307]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.307]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.307]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.307]                   if (TRUE && !signal) {
[16:12:51.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.307]                     {
[16:12:51.307]                       inherits <- base::inherits
[16:12:51.307]                       invokeRestart <- base::invokeRestart
[16:12:51.307]                       is.null <- base::is.null
[16:12:51.307]                       muffled <- FALSE
[16:12:51.307]                       if (inherits(cond, "message")) {
[16:12:51.307]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.307]                         if (muffled) 
[16:12:51.307]                           invokeRestart("muffleMessage")
[16:12:51.307]                       }
[16:12:51.307]                       else if (inherits(cond, "warning")) {
[16:12:51.307]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.307]                         if (muffled) 
[16:12:51.307]                           invokeRestart("muffleWarning")
[16:12:51.307]                       }
[16:12:51.307]                       else if (inherits(cond, "condition")) {
[16:12:51.307]                         if (!is.null(pattern)) {
[16:12:51.307]                           computeRestarts <- base::computeRestarts
[16:12:51.307]                           grepl <- base::grepl
[16:12:51.307]                           restarts <- computeRestarts(cond)
[16:12:51.307]                           for (restart in restarts) {
[16:12:51.307]                             name <- restart$name
[16:12:51.307]                             if (is.null(name)) 
[16:12:51.307]                               next
[16:12:51.307]                             if (!grepl(pattern, name)) 
[16:12:51.307]                               next
[16:12:51.307]                             invokeRestart(restart)
[16:12:51.307]                             muffled <- TRUE
[16:12:51.307]                             break
[16:12:51.307]                           }
[16:12:51.307]                         }
[16:12:51.307]                       }
[16:12:51.307]                       invisible(muffled)
[16:12:51.307]                     }
[16:12:51.307]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.307]                   }
[16:12:51.307]                 }
[16:12:51.307]                 else {
[16:12:51.307]                   if (TRUE) {
[16:12:51.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.307]                     {
[16:12:51.307]                       inherits <- base::inherits
[16:12:51.307]                       invokeRestart <- base::invokeRestart
[16:12:51.307]                       is.null <- base::is.null
[16:12:51.307]                       muffled <- FALSE
[16:12:51.307]                       if (inherits(cond, "message")) {
[16:12:51.307]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.307]                         if (muffled) 
[16:12:51.307]                           invokeRestart("muffleMessage")
[16:12:51.307]                       }
[16:12:51.307]                       else if (inherits(cond, "warning")) {
[16:12:51.307]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.307]                         if (muffled) 
[16:12:51.307]                           invokeRestart("muffleWarning")
[16:12:51.307]                       }
[16:12:51.307]                       else if (inherits(cond, "condition")) {
[16:12:51.307]                         if (!is.null(pattern)) {
[16:12:51.307]                           computeRestarts <- base::computeRestarts
[16:12:51.307]                           grepl <- base::grepl
[16:12:51.307]                           restarts <- computeRestarts(cond)
[16:12:51.307]                           for (restart in restarts) {
[16:12:51.307]                             name <- restart$name
[16:12:51.307]                             if (is.null(name)) 
[16:12:51.307]                               next
[16:12:51.307]                             if (!grepl(pattern, name)) 
[16:12:51.307]                               next
[16:12:51.307]                             invokeRestart(restart)
[16:12:51.307]                             muffled <- TRUE
[16:12:51.307]                             break
[16:12:51.307]                           }
[16:12:51.307]                         }
[16:12:51.307]                       }
[16:12:51.307]                       invisible(muffled)
[16:12:51.307]                     }
[16:12:51.307]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.307]                   }
[16:12:51.307]                 }
[16:12:51.307]             }
[16:12:51.307]         }))
[16:12:51.307]     }, error = function(ex) {
[16:12:51.307]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.307]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.307]                 ...future.rng), started = ...future.startTime, 
[16:12:51.307]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.307]             version = "1.8"), class = "FutureResult")
[16:12:51.307]     }, finally = {
[16:12:51.307]         if (!identical(...future.workdir, getwd())) 
[16:12:51.307]             setwd(...future.workdir)
[16:12:51.307]         {
[16:12:51.307]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.307]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.307]             }
[16:12:51.307]             base::options(...future.oldOptions)
[16:12:51.307]             if (.Platform$OS.type == "windows") {
[16:12:51.307]                 old_names <- names(...future.oldEnvVars)
[16:12:51.307]                 envs <- base::Sys.getenv()
[16:12:51.307]                 names <- names(envs)
[16:12:51.307]                 common <- intersect(names, old_names)
[16:12:51.307]                 added <- setdiff(names, old_names)
[16:12:51.307]                 removed <- setdiff(old_names, names)
[16:12:51.307]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.307]                   envs[common]]
[16:12:51.307]                 NAMES <- toupper(changed)
[16:12:51.307]                 args <- list()
[16:12:51.307]                 for (kk in seq_along(NAMES)) {
[16:12:51.307]                   name <- changed[[kk]]
[16:12:51.307]                   NAME <- NAMES[[kk]]
[16:12:51.307]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.307]                     next
[16:12:51.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.307]                 }
[16:12:51.307]                 NAMES <- toupper(added)
[16:12:51.307]                 for (kk in seq_along(NAMES)) {
[16:12:51.307]                   name <- added[[kk]]
[16:12:51.307]                   NAME <- NAMES[[kk]]
[16:12:51.307]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.307]                     next
[16:12:51.307]                   args[[name]] <- ""
[16:12:51.307]                 }
[16:12:51.307]                 NAMES <- toupper(removed)
[16:12:51.307]                 for (kk in seq_along(NAMES)) {
[16:12:51.307]                   name <- removed[[kk]]
[16:12:51.307]                   NAME <- NAMES[[kk]]
[16:12:51.307]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.307]                     next
[16:12:51.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.307]                 }
[16:12:51.307]                 if (length(args) > 0) 
[16:12:51.307]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.307]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.307]             }
[16:12:51.307]             else {
[16:12:51.307]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.307]             }
[16:12:51.307]             {
[16:12:51.307]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.307]                   0L) {
[16:12:51.307]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.307]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.307]                   base::options(opts)
[16:12:51.307]                 }
[16:12:51.307]                 {
[16:12:51.307]                   {
[16:12:51.307]                     NULL
[16:12:51.307]                     RNGkind("Mersenne-Twister")
[16:12:51.307]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.307]                       inherits = FALSE)
[16:12:51.307]                   }
[16:12:51.307]                   options(future.plan = NULL)
[16:12:51.307]                   if (is.na(NA_character_)) 
[16:12:51.307]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.307]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.307]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.307]                   {
[16:12:51.307]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.307]                     if (!future$lazy) 
[16:12:51.307]                       future <- run(future)
[16:12:51.307]                     invisible(future)
[16:12:51.307]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.307]                 }
[16:12:51.307]             }
[16:12:51.307]         }
[16:12:51.307]     })
[16:12:51.307]     if (TRUE) {
[16:12:51.307]         base::sink(type = "output", split = FALSE)
[16:12:51.307]         if (TRUE) {
[16:12:51.307]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.307]         }
[16:12:51.307]         else {
[16:12:51.307]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.307]         }
[16:12:51.307]         base::close(...future.stdout)
[16:12:51.307]         ...future.stdout <- NULL
[16:12:51.307]     }
[16:12:51.307]     ...future.result$conditions <- ...future.conditions
[16:12:51.307]     ...future.result$finished <- base::Sys.time()
[16:12:51.307]     ...future.result
[16:12:51.307] }
[16:12:51.309] assign_globals() ...
[16:12:51.309] List of 1
[16:12:51.309]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x56233c12da78> 
[16:12:51.309]  - attr(*, "where")=List of 1
[16:12:51.309]   ..$ a:<environment: R_EmptyEnv> 
[16:12:51.309]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.309]  - attr(*, "resolved")= logi TRUE
[16:12:51.309]  - attr(*, "total_size")= num 1596048
[16:12:51.309]  - attr(*, "already-done")= logi TRUE
[16:12:51.311] - copied ‘a’ to environment
[16:12:51.311] assign_globals() ... done
[16:12:51.312] plan(): Setting new future strategy stack:
[16:12:51.312] List of future strategies:
[16:12:51.312] 1. sequential:
[16:12:51.312]    - args: function (..., envir = parent.frame())
[16:12:51.312]    - tweaked: FALSE
[16:12:51.312]    - call: NULL
[16:12:51.312] plan(): nbrOfWorkers() = 1
[16:12:51.313] plan(): Setting new future strategy stack:
[16:12:51.313] List of future strategies:
[16:12:51.313] 1. sequential:
[16:12:51.313]    - args: function (..., envir = parent.frame())
[16:12:51.313]    - tweaked: FALSE
[16:12:51.313]    - call: plan(strategy)
[16:12:51.315] plan(): nbrOfWorkers() = 1
[16:12:51.315] SequentialFuture started (and completed)
[16:12:51.315] - Launch lazy future ... done
[16:12:51.315] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.315] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.316] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:51.316] 
[16:12:51.316] Searching for globals ... DONE
[16:12:51.316] - globals: [0] <none>
[16:12:51.316] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.317] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.317] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:51.318] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:51.318] Searching for globals ... DONE
[16:12:51.318] Resolving globals: TRUE
[16:12:51.318] Resolving any globals that are futures ...
[16:12:51.318] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:51.318] Resolving any globals that are futures ... DONE
[16:12:51.319] Resolving futures part of globals (recursively) ...
[16:12:51.319] resolve() on list ...
[16:12:51.319]  recursive: 99
[16:12:51.319]  length: 1
[16:12:51.319]  elements: ‘a’
[16:12:51.319] run() for ‘Future’ ...
[16:12:51.319] - state: ‘created’
[16:12:51.319] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.320] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.320] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.320]   - Field: ‘label’
[16:12:51.320]   - Field: ‘local’
[16:12:51.320]   - Field: ‘owner’
[16:12:51.320]   - Field: ‘envir’
[16:12:51.320]   - Field: ‘packages’
[16:12:51.320]   - Field: ‘gc’
[16:12:51.321]   - Field: ‘conditions’
[16:12:51.321]   - Field: ‘expr’
[16:12:51.321]   - Field: ‘uuid’
[16:12:51.321]   - Field: ‘seed’
[16:12:51.321]   - Field: ‘version’
[16:12:51.321]   - Field: ‘result’
[16:12:51.321]   - Field: ‘asynchronous’
[16:12:51.321]   - Field: ‘calls’
[16:12:51.321]   - Field: ‘globals’
[16:12:51.321]   - Field: ‘stdout’
[16:12:51.321]   - Field: ‘earlySignal’
[16:12:51.322]   - Field: ‘lazy’
[16:12:51.322]   - Field: ‘state’
[16:12:51.322] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.322] - Launch lazy future ...
[16:12:51.322] Packages needed by the future expression (n = 0): <none>
[16:12:51.322] Packages needed by future strategies (n = 0): <none>
[16:12:51.322] {
[16:12:51.322]     {
[16:12:51.322]         {
[16:12:51.322]             ...future.startTime <- base::Sys.time()
[16:12:51.322]             {
[16:12:51.322]                 {
[16:12:51.322]                   {
[16:12:51.322]                     base::local({
[16:12:51.322]                       has_future <- base::requireNamespace("future", 
[16:12:51.322]                         quietly = TRUE)
[16:12:51.322]                       if (has_future) {
[16:12:51.322]                         ns <- base::getNamespace("future")
[16:12:51.322]                         version <- ns[[".package"]][["version"]]
[16:12:51.322]                         if (is.null(version)) 
[16:12:51.322]                           version <- utils::packageVersion("future")
[16:12:51.322]                       }
[16:12:51.322]                       else {
[16:12:51.322]                         version <- NULL
[16:12:51.322]                       }
[16:12:51.322]                       if (!has_future || version < "1.8.0") {
[16:12:51.322]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.322]                           "", base::R.version$version.string), 
[16:12:51.322]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:51.322]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.322]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.322]                             "release", "version")], collapse = " "), 
[16:12:51.322]                           hostname = base::Sys.info()[["nodename"]])
[16:12:51.322]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.322]                           info)
[16:12:51.322]                         info <- base::paste(info, collapse = "; ")
[16:12:51.322]                         if (!has_future) {
[16:12:51.322]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.322]                             info)
[16:12:51.322]                         }
[16:12:51.322]                         else {
[16:12:51.322]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.322]                             info, version)
[16:12:51.322]                         }
[16:12:51.322]                         base::stop(msg)
[16:12:51.322]                       }
[16:12:51.322]                     })
[16:12:51.322]                   }
[16:12:51.322]                   options(future.plan = NULL)
[16:12:51.322]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.322]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.322]                 }
[16:12:51.322]                 ...future.workdir <- getwd()
[16:12:51.322]             }
[16:12:51.322]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.322]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.322]         }
[16:12:51.322]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.322]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:51.322]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.322]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.322]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.322]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.322]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.322]             base::names(...future.oldOptions))
[16:12:51.322]     }
[16:12:51.322]     if (FALSE) {
[16:12:51.322]     }
[16:12:51.322]     else {
[16:12:51.322]         if (TRUE) {
[16:12:51.322]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.322]                 open = "w")
[16:12:51.322]         }
[16:12:51.322]         else {
[16:12:51.322]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.322]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.322]         }
[16:12:51.322]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.322]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.322]             base::sink(type = "output", split = FALSE)
[16:12:51.322]             base::close(...future.stdout)
[16:12:51.322]         }, add = TRUE)
[16:12:51.322]     }
[16:12:51.322]     ...future.frame <- base::sys.nframe()
[16:12:51.322]     ...future.conditions <- base::list()
[16:12:51.322]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.322]     if (FALSE) {
[16:12:51.322]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.322]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.322]     }
[16:12:51.322]     ...future.result <- base::tryCatch({
[16:12:51.322]         base::withCallingHandlers({
[16:12:51.322]             ...future.value <- base::withVisible(base::local(1))
[16:12:51.322]             future::FutureResult(value = ...future.value$value, 
[16:12:51.322]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.322]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.322]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.322]                     ...future.globalenv.names))
[16:12:51.322]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.322]         }, condition = base::local({
[16:12:51.322]             c <- base::c
[16:12:51.322]             inherits <- base::inherits
[16:12:51.322]             invokeRestart <- base::invokeRestart
[16:12:51.322]             length <- base::length
[16:12:51.322]             list <- base::list
[16:12:51.322]             seq.int <- base::seq.int
[16:12:51.322]             signalCondition <- base::signalCondition
[16:12:51.322]             sys.calls <- base::sys.calls
[16:12:51.322]             `[[` <- base::`[[`
[16:12:51.322]             `+` <- base::`+`
[16:12:51.322]             `<<-` <- base::`<<-`
[16:12:51.322]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.322]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.322]                   3L)]
[16:12:51.322]             }
[16:12:51.322]             function(cond) {
[16:12:51.322]                 is_error <- inherits(cond, "error")
[16:12:51.322]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.322]                   NULL)
[16:12:51.322]                 if (is_error) {
[16:12:51.322]                   sessionInformation <- function() {
[16:12:51.322]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.322]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.322]                       search = base::search(), system = base::Sys.info())
[16:12:51.322]                   }
[16:12:51.322]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.322]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.322]                     cond$call), session = sessionInformation(), 
[16:12:51.322]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.322]                   signalCondition(cond)
[16:12:51.322]                 }
[16:12:51.322]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.322]                 "immediateCondition"))) {
[16:12:51.322]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.322]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.322]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.322]                   if (TRUE && !signal) {
[16:12:51.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.322]                     {
[16:12:51.322]                       inherits <- base::inherits
[16:12:51.322]                       invokeRestart <- base::invokeRestart
[16:12:51.322]                       is.null <- base::is.null
[16:12:51.322]                       muffled <- FALSE
[16:12:51.322]                       if (inherits(cond, "message")) {
[16:12:51.322]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.322]                         if (muffled) 
[16:12:51.322]                           invokeRestart("muffleMessage")
[16:12:51.322]                       }
[16:12:51.322]                       else if (inherits(cond, "warning")) {
[16:12:51.322]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.322]                         if (muffled) 
[16:12:51.322]                           invokeRestart("muffleWarning")
[16:12:51.322]                       }
[16:12:51.322]                       else if (inherits(cond, "condition")) {
[16:12:51.322]                         if (!is.null(pattern)) {
[16:12:51.322]                           computeRestarts <- base::computeRestarts
[16:12:51.322]                           grepl <- base::grepl
[16:12:51.322]                           restarts <- computeRestarts(cond)
[16:12:51.322]                           for (restart in restarts) {
[16:12:51.322]                             name <- restart$name
[16:12:51.322]                             if (is.null(name)) 
[16:12:51.322]                               next
[16:12:51.322]                             if (!grepl(pattern, name)) 
[16:12:51.322]                               next
[16:12:51.322]                             invokeRestart(restart)
[16:12:51.322]                             muffled <- TRUE
[16:12:51.322]                             break
[16:12:51.322]                           }
[16:12:51.322]                         }
[16:12:51.322]                       }
[16:12:51.322]                       invisible(muffled)
[16:12:51.322]                     }
[16:12:51.322]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.322]                   }
[16:12:51.322]                 }
[16:12:51.322]                 else {
[16:12:51.322]                   if (TRUE) {
[16:12:51.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.322]                     {
[16:12:51.322]                       inherits <- base::inherits
[16:12:51.322]                       invokeRestart <- base::invokeRestart
[16:12:51.322]                       is.null <- base::is.null
[16:12:51.322]                       muffled <- FALSE
[16:12:51.322]                       if (inherits(cond, "message")) {
[16:12:51.322]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.322]                         if (muffled) 
[16:12:51.322]                           invokeRestart("muffleMessage")
[16:12:51.322]                       }
[16:12:51.322]                       else if (inherits(cond, "warning")) {
[16:12:51.322]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.322]                         if (muffled) 
[16:12:51.322]                           invokeRestart("muffleWarning")
[16:12:51.322]                       }
[16:12:51.322]                       else if (inherits(cond, "condition")) {
[16:12:51.322]                         if (!is.null(pattern)) {
[16:12:51.322]                           computeRestarts <- base::computeRestarts
[16:12:51.322]                           grepl <- base::grepl
[16:12:51.322]                           restarts <- computeRestarts(cond)
[16:12:51.322]                           for (restart in restarts) {
[16:12:51.322]                             name <- restart$name
[16:12:51.322]                             if (is.null(name)) 
[16:12:51.322]                               next
[16:12:51.322]                             if (!grepl(pattern, name)) 
[16:12:51.322]                               next
[16:12:51.322]                             invokeRestart(restart)
[16:12:51.322]                             muffled <- TRUE
[16:12:51.322]                             break
[16:12:51.322]                           }
[16:12:51.322]                         }
[16:12:51.322]                       }
[16:12:51.322]                       invisible(muffled)
[16:12:51.322]                     }
[16:12:51.322]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.322]                   }
[16:12:51.322]                 }
[16:12:51.322]             }
[16:12:51.322]         }))
[16:12:51.322]     }, error = function(ex) {
[16:12:51.322]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.322]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.322]                 ...future.rng), started = ...future.startTime, 
[16:12:51.322]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.322]             version = "1.8"), class = "FutureResult")
[16:12:51.322]     }, finally = {
[16:12:51.322]         if (!identical(...future.workdir, getwd())) 
[16:12:51.322]             setwd(...future.workdir)
[16:12:51.322]         {
[16:12:51.322]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.322]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.322]             }
[16:12:51.322]             base::options(...future.oldOptions)
[16:12:51.322]             if (.Platform$OS.type == "windows") {
[16:12:51.322]                 old_names <- names(...future.oldEnvVars)
[16:12:51.322]                 envs <- base::Sys.getenv()
[16:12:51.322]                 names <- names(envs)
[16:12:51.322]                 common <- intersect(names, old_names)
[16:12:51.322]                 added <- setdiff(names, old_names)
[16:12:51.322]                 removed <- setdiff(old_names, names)
[16:12:51.322]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.322]                   envs[common]]
[16:12:51.322]                 NAMES <- toupper(changed)
[16:12:51.322]                 args <- list()
[16:12:51.322]                 for (kk in seq_along(NAMES)) {
[16:12:51.322]                   name <- changed[[kk]]
[16:12:51.322]                   NAME <- NAMES[[kk]]
[16:12:51.322]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.322]                     next
[16:12:51.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.322]                 }
[16:12:51.322]                 NAMES <- toupper(added)
[16:12:51.322]                 for (kk in seq_along(NAMES)) {
[16:12:51.322]                   name <- added[[kk]]
[16:12:51.322]                   NAME <- NAMES[[kk]]
[16:12:51.322]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.322]                     next
[16:12:51.322]                   args[[name]] <- ""
[16:12:51.322]                 }
[16:12:51.322]                 NAMES <- toupper(removed)
[16:12:51.322]                 for (kk in seq_along(NAMES)) {
[16:12:51.322]                   name <- removed[[kk]]
[16:12:51.322]                   NAME <- NAMES[[kk]]
[16:12:51.322]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.322]                     next
[16:12:51.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.322]                 }
[16:12:51.322]                 if (length(args) > 0) 
[16:12:51.322]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.322]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.322]             }
[16:12:51.322]             else {
[16:12:51.322]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.322]             }
[16:12:51.322]             {
[16:12:51.322]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.322]                   0L) {
[16:12:51.322]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.322]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.322]                   base::options(opts)
[16:12:51.322]                 }
[16:12:51.322]                 {
[16:12:51.322]                   {
[16:12:51.322]                     NULL
[16:12:51.322]                     RNGkind("Mersenne-Twister")
[16:12:51.322]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.322]                       inherits = FALSE)
[16:12:51.322]                   }
[16:12:51.322]                   options(future.plan = NULL)
[16:12:51.322]                   if (is.na(NA_character_)) 
[16:12:51.322]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.322]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.322]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.322]                   {
[16:12:51.322]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.322]                     if (!future$lazy) 
[16:12:51.322]                       future <- run(future)
[16:12:51.322]                     invisible(future)
[16:12:51.322]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.322]                 }
[16:12:51.322]             }
[16:12:51.322]         }
[16:12:51.322]     })
[16:12:51.322]     if (TRUE) {
[16:12:51.322]         base::sink(type = "output", split = FALSE)
[16:12:51.322]         if (TRUE) {
[16:12:51.322]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.322]         }
[16:12:51.322]         else {
[16:12:51.322]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.322]         }
[16:12:51.322]         base::close(...future.stdout)
[16:12:51.322]         ...future.stdout <- NULL
[16:12:51.322]     }
[16:12:51.322]     ...future.result$conditions <- ...future.conditions
[16:12:51.322]     ...future.result$finished <- base::Sys.time()
[16:12:51.322]     ...future.result
[16:12:51.322] }
[16:12:51.324] plan(): Setting new future strategy stack:
[16:12:51.324] List of future strategies:
[16:12:51.324] 1. sequential:
[16:12:51.324]    - args: function (..., envir = parent.frame())
[16:12:51.324]    - tweaked: FALSE
[16:12:51.324]    - call: NULL
[16:12:51.325] plan(): nbrOfWorkers() = 1
[16:12:51.325] plan(): Setting new future strategy stack:
[16:12:51.325] List of future strategies:
[16:12:51.325] 1. sequential:
[16:12:51.325]    - args: function (..., envir = parent.frame())
[16:12:51.325]    - tweaked: FALSE
[16:12:51.325]    - call: plan(strategy)
[16:12:51.326] plan(): nbrOfWorkers() = 1
[16:12:51.326] SequentialFuture started (and completed)
[16:12:51.326] - Launch lazy future ... done
[16:12:51.326] run() for ‘SequentialFuture’ ... done
[16:12:51.326] resolved() for ‘SequentialFuture’ ...
[16:12:51.326] - state: ‘finished’
[16:12:51.327] - run: TRUE
[16:12:51.327] - result: ‘FutureResult’
[16:12:51.327] resolved() for ‘SequentialFuture’ ... done
[16:12:51.327] Future #1
[16:12:51.327] resolved() for ‘SequentialFuture’ ...
[16:12:51.327] - state: ‘finished’
[16:12:51.327] - run: TRUE
[16:12:51.327] - result: ‘FutureResult’
[16:12:51.327] resolved() for ‘SequentialFuture’ ... done
[16:12:51.327] A SequentialFuture was resolved
[16:12:51.328]  length: 0 (resolved future 1)
[16:12:51.328] resolve() on list ... DONE
[16:12:51.328] - globals: [1] ‘a’
[16:12:51.328] Resolving futures part of globals (recursively) ... DONE
[16:12:51.330] The total size of the 1 globals is 1.52 MiB (1596216 bytes)
[16:12:51.330] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.52 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.52 MiB of class ‘environment’)
[16:12:51.330] - globals: [1] ‘a’
[16:12:51.330] - packages: [1] ‘future’
[16:12:51.330] getGlobalsAndPackages() ... DONE
[16:12:51.331] run() for ‘Future’ ...
[16:12:51.331] - state: ‘created’
[16:12:51.331] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.331] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.331] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.331]   - Field: ‘label’
[16:12:51.331]   - Field: ‘local’
[16:12:51.331]   - Field: ‘owner’
[16:12:51.332]   - Field: ‘envir’
[16:12:51.332]   - Field: ‘packages’
[16:12:51.332]   - Field: ‘gc’
[16:12:51.332]   - Field: ‘conditions’
[16:12:51.332]   - Field: ‘expr’
[16:12:51.332]   - Field: ‘uuid’
[16:12:51.332]   - Field: ‘seed’
[16:12:51.332]   - Field: ‘version’
[16:12:51.332]   - Field: ‘result’
[16:12:51.332]   - Field: ‘asynchronous’
[16:12:51.332]   - Field: ‘calls’
[16:12:51.333]   - Field: ‘globals’
[16:12:51.333]   - Field: ‘stdout’
[16:12:51.333]   - Field: ‘earlySignal’
[16:12:51.333]   - Field: ‘lazy’
[16:12:51.333]   - Field: ‘state’
[16:12:51.333] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.333] - Launch lazy future ...
[16:12:51.333] Packages needed by the future expression (n = 1): ‘future’
[16:12:51.333] Packages needed by future strategies (n = 0): <none>
[16:12:51.334] {
[16:12:51.334]     {
[16:12:51.334]         {
[16:12:51.334]             ...future.startTime <- base::Sys.time()
[16:12:51.334]             {
[16:12:51.334]                 {
[16:12:51.334]                   {
[16:12:51.334]                     {
[16:12:51.334]                       base::local({
[16:12:51.334]                         has_future <- base::requireNamespace("future", 
[16:12:51.334]                           quietly = TRUE)
[16:12:51.334]                         if (has_future) {
[16:12:51.334]                           ns <- base::getNamespace("future")
[16:12:51.334]                           version <- ns[[".package"]][["version"]]
[16:12:51.334]                           if (is.null(version)) 
[16:12:51.334]                             version <- utils::packageVersion("future")
[16:12:51.334]                         }
[16:12:51.334]                         else {
[16:12:51.334]                           version <- NULL
[16:12:51.334]                         }
[16:12:51.334]                         if (!has_future || version < "1.8.0") {
[16:12:51.334]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.334]                             "", base::R.version$version.string), 
[16:12:51.334]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:51.334]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.334]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.334]                               "release", "version")], collapse = " "), 
[16:12:51.334]                             hostname = base::Sys.info()[["nodename"]])
[16:12:51.334]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.334]                             info)
[16:12:51.334]                           info <- base::paste(info, collapse = "; ")
[16:12:51.334]                           if (!has_future) {
[16:12:51.334]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.334]                               info)
[16:12:51.334]                           }
[16:12:51.334]                           else {
[16:12:51.334]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.334]                               info, version)
[16:12:51.334]                           }
[16:12:51.334]                           base::stop(msg)
[16:12:51.334]                         }
[16:12:51.334]                       })
[16:12:51.334]                     }
[16:12:51.334]                     base::local({
[16:12:51.334]                       for (pkg in "future") {
[16:12:51.334]                         base::loadNamespace(pkg)
[16:12:51.334]                         base::library(pkg, character.only = TRUE)
[16:12:51.334]                       }
[16:12:51.334]                     })
[16:12:51.334]                   }
[16:12:51.334]                   options(future.plan = NULL)
[16:12:51.334]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.334]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.334]                 }
[16:12:51.334]                 ...future.workdir <- getwd()
[16:12:51.334]             }
[16:12:51.334]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.334]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.334]         }
[16:12:51.334]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.334]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:51.334]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.334]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.334]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.334]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.334]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.334]             base::names(...future.oldOptions))
[16:12:51.334]     }
[16:12:51.334]     if (FALSE) {
[16:12:51.334]     }
[16:12:51.334]     else {
[16:12:51.334]         if (TRUE) {
[16:12:51.334]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.334]                 open = "w")
[16:12:51.334]         }
[16:12:51.334]         else {
[16:12:51.334]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.334]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.334]         }
[16:12:51.334]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.334]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.334]             base::sink(type = "output", split = FALSE)
[16:12:51.334]             base::close(...future.stdout)
[16:12:51.334]         }, add = TRUE)
[16:12:51.334]     }
[16:12:51.334]     ...future.frame <- base::sys.nframe()
[16:12:51.334]     ...future.conditions <- base::list()
[16:12:51.334]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.334]     if (FALSE) {
[16:12:51.334]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.334]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.334]     }
[16:12:51.334]     ...future.result <- base::tryCatch({
[16:12:51.334]         base::withCallingHandlers({
[16:12:51.334]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:12:51.334]                 1))
[16:12:51.334]             future::FutureResult(value = ...future.value$value, 
[16:12:51.334]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.334]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.334]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.334]                     ...future.globalenv.names))
[16:12:51.334]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.334]         }, condition = base::local({
[16:12:51.334]             c <- base::c
[16:12:51.334]             inherits <- base::inherits
[16:12:51.334]             invokeRestart <- base::invokeRestart
[16:12:51.334]             length <- base::length
[16:12:51.334]             list <- base::list
[16:12:51.334]             seq.int <- base::seq.int
[16:12:51.334]             signalCondition <- base::signalCondition
[16:12:51.334]             sys.calls <- base::sys.calls
[16:12:51.334]             `[[` <- base::`[[`
[16:12:51.334]             `+` <- base::`+`
[16:12:51.334]             `<<-` <- base::`<<-`
[16:12:51.334]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.334]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.334]                   3L)]
[16:12:51.334]             }
[16:12:51.334]             function(cond) {
[16:12:51.334]                 is_error <- inherits(cond, "error")
[16:12:51.334]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.334]                   NULL)
[16:12:51.334]                 if (is_error) {
[16:12:51.334]                   sessionInformation <- function() {
[16:12:51.334]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.334]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.334]                       search = base::search(), system = base::Sys.info())
[16:12:51.334]                   }
[16:12:51.334]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.334]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.334]                     cond$call), session = sessionInformation(), 
[16:12:51.334]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.334]                   signalCondition(cond)
[16:12:51.334]                 }
[16:12:51.334]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.334]                 "immediateCondition"))) {
[16:12:51.334]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.334]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.334]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.334]                   if (TRUE && !signal) {
[16:12:51.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.334]                     {
[16:12:51.334]                       inherits <- base::inherits
[16:12:51.334]                       invokeRestart <- base::invokeRestart
[16:12:51.334]                       is.null <- base::is.null
[16:12:51.334]                       muffled <- FALSE
[16:12:51.334]                       if (inherits(cond, "message")) {
[16:12:51.334]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.334]                         if (muffled) 
[16:12:51.334]                           invokeRestart("muffleMessage")
[16:12:51.334]                       }
[16:12:51.334]                       else if (inherits(cond, "warning")) {
[16:12:51.334]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.334]                         if (muffled) 
[16:12:51.334]                           invokeRestart("muffleWarning")
[16:12:51.334]                       }
[16:12:51.334]                       else if (inherits(cond, "condition")) {
[16:12:51.334]                         if (!is.null(pattern)) {
[16:12:51.334]                           computeRestarts <- base::computeRestarts
[16:12:51.334]                           grepl <- base::grepl
[16:12:51.334]                           restarts <- computeRestarts(cond)
[16:12:51.334]                           for (restart in restarts) {
[16:12:51.334]                             name <- restart$name
[16:12:51.334]                             if (is.null(name)) 
[16:12:51.334]                               next
[16:12:51.334]                             if (!grepl(pattern, name)) 
[16:12:51.334]                               next
[16:12:51.334]                             invokeRestart(restart)
[16:12:51.334]                             muffled <- TRUE
[16:12:51.334]                             break
[16:12:51.334]                           }
[16:12:51.334]                         }
[16:12:51.334]                       }
[16:12:51.334]                       invisible(muffled)
[16:12:51.334]                     }
[16:12:51.334]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.334]                   }
[16:12:51.334]                 }
[16:12:51.334]                 else {
[16:12:51.334]                   if (TRUE) {
[16:12:51.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.334]                     {
[16:12:51.334]                       inherits <- base::inherits
[16:12:51.334]                       invokeRestart <- base::invokeRestart
[16:12:51.334]                       is.null <- base::is.null
[16:12:51.334]                       muffled <- FALSE
[16:12:51.334]                       if (inherits(cond, "message")) {
[16:12:51.334]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.334]                         if (muffled) 
[16:12:51.334]                           invokeRestart("muffleMessage")
[16:12:51.334]                       }
[16:12:51.334]                       else if (inherits(cond, "warning")) {
[16:12:51.334]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.334]                         if (muffled) 
[16:12:51.334]                           invokeRestart("muffleWarning")
[16:12:51.334]                       }
[16:12:51.334]                       else if (inherits(cond, "condition")) {
[16:12:51.334]                         if (!is.null(pattern)) {
[16:12:51.334]                           computeRestarts <- base::computeRestarts
[16:12:51.334]                           grepl <- base::grepl
[16:12:51.334]                           restarts <- computeRestarts(cond)
[16:12:51.334]                           for (restart in restarts) {
[16:12:51.334]                             name <- restart$name
[16:12:51.334]                             if (is.null(name)) 
[16:12:51.334]                               next
[16:12:51.334]                             if (!grepl(pattern, name)) 
[16:12:51.334]                               next
[16:12:51.334]                             invokeRestart(restart)
[16:12:51.334]                             muffled <- TRUE
[16:12:51.334]                             break
[16:12:51.334]                           }
[16:12:51.334]                         }
[16:12:51.334]                       }
[16:12:51.334]                       invisible(muffled)
[16:12:51.334]                     }
[16:12:51.334]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.334]                   }
[16:12:51.334]                 }
[16:12:51.334]             }
[16:12:51.334]         }))
[16:12:51.334]     }, error = function(ex) {
[16:12:51.334]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.334]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.334]                 ...future.rng), started = ...future.startTime, 
[16:12:51.334]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.334]             version = "1.8"), class = "FutureResult")
[16:12:51.334]     }, finally = {
[16:12:51.334]         if (!identical(...future.workdir, getwd())) 
[16:12:51.334]             setwd(...future.workdir)
[16:12:51.334]         {
[16:12:51.334]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.334]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.334]             }
[16:12:51.334]             base::options(...future.oldOptions)
[16:12:51.334]             if (.Platform$OS.type == "windows") {
[16:12:51.334]                 old_names <- names(...future.oldEnvVars)
[16:12:51.334]                 envs <- base::Sys.getenv()
[16:12:51.334]                 names <- names(envs)
[16:12:51.334]                 common <- intersect(names, old_names)
[16:12:51.334]                 added <- setdiff(names, old_names)
[16:12:51.334]                 removed <- setdiff(old_names, names)
[16:12:51.334]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.334]                   envs[common]]
[16:12:51.334]                 NAMES <- toupper(changed)
[16:12:51.334]                 args <- list()
[16:12:51.334]                 for (kk in seq_along(NAMES)) {
[16:12:51.334]                   name <- changed[[kk]]
[16:12:51.334]                   NAME <- NAMES[[kk]]
[16:12:51.334]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.334]                     next
[16:12:51.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.334]                 }
[16:12:51.334]                 NAMES <- toupper(added)
[16:12:51.334]                 for (kk in seq_along(NAMES)) {
[16:12:51.334]                   name <- added[[kk]]
[16:12:51.334]                   NAME <- NAMES[[kk]]
[16:12:51.334]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.334]                     next
[16:12:51.334]                   args[[name]] <- ""
[16:12:51.334]                 }
[16:12:51.334]                 NAMES <- toupper(removed)
[16:12:51.334]                 for (kk in seq_along(NAMES)) {
[16:12:51.334]                   name <- removed[[kk]]
[16:12:51.334]                   NAME <- NAMES[[kk]]
[16:12:51.334]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.334]                     next
[16:12:51.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.334]                 }
[16:12:51.334]                 if (length(args) > 0) 
[16:12:51.334]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.334]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.334]             }
[16:12:51.334]             else {
[16:12:51.334]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.334]             }
[16:12:51.334]             {
[16:12:51.334]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.334]                   0L) {
[16:12:51.334]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.334]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.334]                   base::options(opts)
[16:12:51.334]                 }
[16:12:51.334]                 {
[16:12:51.334]                   {
[16:12:51.334]                     NULL
[16:12:51.334]                     RNGkind("Mersenne-Twister")
[16:12:51.334]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.334]                       inherits = FALSE)
[16:12:51.334]                   }
[16:12:51.334]                   options(future.plan = NULL)
[16:12:51.334]                   if (is.na(NA_character_)) 
[16:12:51.334]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.334]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.334]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.334]                   {
[16:12:51.334]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.334]                     if (!future$lazy) 
[16:12:51.334]                       future <- run(future)
[16:12:51.334]                     invisible(future)
[16:12:51.334]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.334]                 }
[16:12:51.334]             }
[16:12:51.334]         }
[16:12:51.334]     })
[16:12:51.334]     if (TRUE) {
[16:12:51.334]         base::sink(type = "output", split = FALSE)
[16:12:51.334]         if (TRUE) {
[16:12:51.334]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.334]         }
[16:12:51.334]         else {
[16:12:51.334]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.334]         }
[16:12:51.334]         base::close(...future.stdout)
[16:12:51.334]         ...future.stdout <- NULL
[16:12:51.334]     }
[16:12:51.334]     ...future.result$conditions <- ...future.conditions
[16:12:51.334]     ...future.result$finished <- base::Sys.time()
[16:12:51.334]     ...future.result
[16:12:51.334] }
[16:12:51.336] assign_globals() ...
[16:12:51.336] List of 1
[16:12:51.336]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x56233db78868> 
[16:12:51.336]  - attr(*, "where")=List of 1
[16:12:51.336]   ..$ a:<environment: R_EmptyEnv> 
[16:12:51.336]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.336]  - attr(*, "resolved")= logi TRUE
[16:12:51.336]  - attr(*, "total_size")= num 1596216
[16:12:51.336]  - attr(*, "already-done")= logi TRUE
[16:12:51.338] - copied ‘a’ to environment
[16:12:51.338] assign_globals() ... done
[16:12:51.339] plan(): Setting new future strategy stack:
[16:12:51.339] List of future strategies:
[16:12:51.339] 1. sequential:
[16:12:51.339]    - args: function (..., envir = parent.frame())
[16:12:51.339]    - tweaked: FALSE
[16:12:51.339]    - call: NULL
[16:12:51.339] plan(): nbrOfWorkers() = 1
[16:12:51.340] plan(): Setting new future strategy stack:
[16:12:51.340] List of future strategies:
[16:12:51.340] 1. sequential:
[16:12:51.340]    - args: function (..., envir = parent.frame())
[16:12:51.340]    - tweaked: FALSE
[16:12:51.340]    - call: plan(strategy)
[16:12:51.340] plan(): nbrOfWorkers() = 1
[16:12:51.341] SequentialFuture started (and completed)
[16:12:51.341] - Launch lazy future ... done
[16:12:51.341] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.341] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.341] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:51.342] 
[16:12:51.342] Searching for globals ... DONE
[16:12:51.342] - globals: [0] <none>
[16:12:51.342] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.344] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.344] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:51.345] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:51.345] Searching for globals ... DONE
[16:12:51.345] Resolving globals: TRUE
[16:12:51.345] Resolving any globals that are futures ...
[16:12:51.345] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:51.345] Resolving any globals that are futures ... DONE
[16:12:51.346] Resolving futures part of globals (recursively) ...
[16:12:51.346] resolve() on list ...
[16:12:51.346]  recursive: 99
[16:12:51.346]  length: 1
[16:12:51.346]  elements: ‘a’
[16:12:51.346] run() for ‘Future’ ...
[16:12:51.347] - state: ‘created’
[16:12:51.347] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.347] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.347] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.347]   - Field: ‘label’
[16:12:51.347]   - Field: ‘local’
[16:12:51.347]   - Field: ‘owner’
[16:12:51.347]   - Field: ‘envir’
[16:12:51.348]   - Field: ‘packages’
[16:12:51.348]   - Field: ‘gc’
[16:12:51.348]   - Field: ‘conditions’
[16:12:51.348]   - Field: ‘expr’
[16:12:51.348]   - Field: ‘uuid’
[16:12:51.348]   - Field: ‘seed’
[16:12:51.348]   - Field: ‘version’
[16:12:51.348]   - Field: ‘result’
[16:12:51.348]   - Field: ‘asynchronous’
[16:12:51.348]   - Field: ‘calls’
[16:12:51.349]   - Field: ‘globals’
[16:12:51.349]   - Field: ‘stdout’
[16:12:51.349]   - Field: ‘earlySignal’
[16:12:51.349]   - Field: ‘lazy’
[16:12:51.349]   - Field: ‘state’
[16:12:51.349] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.349] - Launch lazy future ...
[16:12:51.349] Packages needed by the future expression (n = 0): <none>
[16:12:51.349] Packages needed by future strategies (n = 0): <none>
[16:12:51.350] {
[16:12:51.350]     {
[16:12:51.350]         {
[16:12:51.350]             ...future.startTime <- base::Sys.time()
[16:12:51.350]             {
[16:12:51.350]                 {
[16:12:51.350]                   {
[16:12:51.350]                     base::local({
[16:12:51.350]                       has_future <- base::requireNamespace("future", 
[16:12:51.350]                         quietly = TRUE)
[16:12:51.350]                       if (has_future) {
[16:12:51.350]                         ns <- base::getNamespace("future")
[16:12:51.350]                         version <- ns[[".package"]][["version"]]
[16:12:51.350]                         if (is.null(version)) 
[16:12:51.350]                           version <- utils::packageVersion("future")
[16:12:51.350]                       }
[16:12:51.350]                       else {
[16:12:51.350]                         version <- NULL
[16:12:51.350]                       }
[16:12:51.350]                       if (!has_future || version < "1.8.0") {
[16:12:51.350]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.350]                           "", base::R.version$version.string), 
[16:12:51.350]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:51.350]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.350]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.350]                             "release", "version")], collapse = " "), 
[16:12:51.350]                           hostname = base::Sys.info()[["nodename"]])
[16:12:51.350]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.350]                           info)
[16:12:51.350]                         info <- base::paste(info, collapse = "; ")
[16:12:51.350]                         if (!has_future) {
[16:12:51.350]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.350]                             info)
[16:12:51.350]                         }
[16:12:51.350]                         else {
[16:12:51.350]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.350]                             info, version)
[16:12:51.350]                         }
[16:12:51.350]                         base::stop(msg)
[16:12:51.350]                       }
[16:12:51.350]                     })
[16:12:51.350]                   }
[16:12:51.350]                   options(future.plan = NULL)
[16:12:51.350]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.350]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.350]                 }
[16:12:51.350]                 ...future.workdir <- getwd()
[16:12:51.350]             }
[16:12:51.350]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.350]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.350]         }
[16:12:51.350]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.350]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:51.350]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.350]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.350]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.350]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.350]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.350]             base::names(...future.oldOptions))
[16:12:51.350]     }
[16:12:51.350]     if (FALSE) {
[16:12:51.350]     }
[16:12:51.350]     else {
[16:12:51.350]         if (TRUE) {
[16:12:51.350]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.350]                 open = "w")
[16:12:51.350]         }
[16:12:51.350]         else {
[16:12:51.350]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.350]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.350]         }
[16:12:51.350]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.350]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.350]             base::sink(type = "output", split = FALSE)
[16:12:51.350]             base::close(...future.stdout)
[16:12:51.350]         }, add = TRUE)
[16:12:51.350]     }
[16:12:51.350]     ...future.frame <- base::sys.nframe()
[16:12:51.350]     ...future.conditions <- base::list()
[16:12:51.350]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.350]     if (FALSE) {
[16:12:51.350]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.350]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.350]     }
[16:12:51.350]     ...future.result <- base::tryCatch({
[16:12:51.350]         base::withCallingHandlers({
[16:12:51.350]             ...future.value <- base::withVisible(base::local(1))
[16:12:51.350]             future::FutureResult(value = ...future.value$value, 
[16:12:51.350]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.350]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.350]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.350]                     ...future.globalenv.names))
[16:12:51.350]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.350]         }, condition = base::local({
[16:12:51.350]             c <- base::c
[16:12:51.350]             inherits <- base::inherits
[16:12:51.350]             invokeRestart <- base::invokeRestart
[16:12:51.350]             length <- base::length
[16:12:51.350]             list <- base::list
[16:12:51.350]             seq.int <- base::seq.int
[16:12:51.350]             signalCondition <- base::signalCondition
[16:12:51.350]             sys.calls <- base::sys.calls
[16:12:51.350]             `[[` <- base::`[[`
[16:12:51.350]             `+` <- base::`+`
[16:12:51.350]             `<<-` <- base::`<<-`
[16:12:51.350]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.350]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.350]                   3L)]
[16:12:51.350]             }
[16:12:51.350]             function(cond) {
[16:12:51.350]                 is_error <- inherits(cond, "error")
[16:12:51.350]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.350]                   NULL)
[16:12:51.350]                 if (is_error) {
[16:12:51.350]                   sessionInformation <- function() {
[16:12:51.350]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.350]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.350]                       search = base::search(), system = base::Sys.info())
[16:12:51.350]                   }
[16:12:51.350]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.350]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.350]                     cond$call), session = sessionInformation(), 
[16:12:51.350]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.350]                   signalCondition(cond)
[16:12:51.350]                 }
[16:12:51.350]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.350]                 "immediateCondition"))) {
[16:12:51.350]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.350]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.350]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.350]                   if (TRUE && !signal) {
[16:12:51.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.350]                     {
[16:12:51.350]                       inherits <- base::inherits
[16:12:51.350]                       invokeRestart <- base::invokeRestart
[16:12:51.350]                       is.null <- base::is.null
[16:12:51.350]                       muffled <- FALSE
[16:12:51.350]                       if (inherits(cond, "message")) {
[16:12:51.350]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.350]                         if (muffled) 
[16:12:51.350]                           invokeRestart("muffleMessage")
[16:12:51.350]                       }
[16:12:51.350]                       else if (inherits(cond, "warning")) {
[16:12:51.350]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.350]                         if (muffled) 
[16:12:51.350]                           invokeRestart("muffleWarning")
[16:12:51.350]                       }
[16:12:51.350]                       else if (inherits(cond, "condition")) {
[16:12:51.350]                         if (!is.null(pattern)) {
[16:12:51.350]                           computeRestarts <- base::computeRestarts
[16:12:51.350]                           grepl <- base::grepl
[16:12:51.350]                           restarts <- computeRestarts(cond)
[16:12:51.350]                           for (restart in restarts) {
[16:12:51.350]                             name <- restart$name
[16:12:51.350]                             if (is.null(name)) 
[16:12:51.350]                               next
[16:12:51.350]                             if (!grepl(pattern, name)) 
[16:12:51.350]                               next
[16:12:51.350]                             invokeRestart(restart)
[16:12:51.350]                             muffled <- TRUE
[16:12:51.350]                             break
[16:12:51.350]                           }
[16:12:51.350]                         }
[16:12:51.350]                       }
[16:12:51.350]                       invisible(muffled)
[16:12:51.350]                     }
[16:12:51.350]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.350]                   }
[16:12:51.350]                 }
[16:12:51.350]                 else {
[16:12:51.350]                   if (TRUE) {
[16:12:51.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.350]                     {
[16:12:51.350]                       inherits <- base::inherits
[16:12:51.350]                       invokeRestart <- base::invokeRestart
[16:12:51.350]                       is.null <- base::is.null
[16:12:51.350]                       muffled <- FALSE
[16:12:51.350]                       if (inherits(cond, "message")) {
[16:12:51.350]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.350]                         if (muffled) 
[16:12:51.350]                           invokeRestart("muffleMessage")
[16:12:51.350]                       }
[16:12:51.350]                       else if (inherits(cond, "warning")) {
[16:12:51.350]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.350]                         if (muffled) 
[16:12:51.350]                           invokeRestart("muffleWarning")
[16:12:51.350]                       }
[16:12:51.350]                       else if (inherits(cond, "condition")) {
[16:12:51.350]                         if (!is.null(pattern)) {
[16:12:51.350]                           computeRestarts <- base::computeRestarts
[16:12:51.350]                           grepl <- base::grepl
[16:12:51.350]                           restarts <- computeRestarts(cond)
[16:12:51.350]                           for (restart in restarts) {
[16:12:51.350]                             name <- restart$name
[16:12:51.350]                             if (is.null(name)) 
[16:12:51.350]                               next
[16:12:51.350]                             if (!grepl(pattern, name)) 
[16:12:51.350]                               next
[16:12:51.350]                             invokeRestart(restart)
[16:12:51.350]                             muffled <- TRUE
[16:12:51.350]                             break
[16:12:51.350]                           }
[16:12:51.350]                         }
[16:12:51.350]                       }
[16:12:51.350]                       invisible(muffled)
[16:12:51.350]                     }
[16:12:51.350]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.350]                   }
[16:12:51.350]                 }
[16:12:51.350]             }
[16:12:51.350]         }))
[16:12:51.350]     }, error = function(ex) {
[16:12:51.350]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.350]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.350]                 ...future.rng), started = ...future.startTime, 
[16:12:51.350]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.350]             version = "1.8"), class = "FutureResult")
[16:12:51.350]     }, finally = {
[16:12:51.350]         if (!identical(...future.workdir, getwd())) 
[16:12:51.350]             setwd(...future.workdir)
[16:12:51.350]         {
[16:12:51.350]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.350]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.350]             }
[16:12:51.350]             base::options(...future.oldOptions)
[16:12:51.350]             if (.Platform$OS.type == "windows") {
[16:12:51.350]                 old_names <- names(...future.oldEnvVars)
[16:12:51.350]                 envs <- base::Sys.getenv()
[16:12:51.350]                 names <- names(envs)
[16:12:51.350]                 common <- intersect(names, old_names)
[16:12:51.350]                 added <- setdiff(names, old_names)
[16:12:51.350]                 removed <- setdiff(old_names, names)
[16:12:51.350]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.350]                   envs[common]]
[16:12:51.350]                 NAMES <- toupper(changed)
[16:12:51.350]                 args <- list()
[16:12:51.350]                 for (kk in seq_along(NAMES)) {
[16:12:51.350]                   name <- changed[[kk]]
[16:12:51.350]                   NAME <- NAMES[[kk]]
[16:12:51.350]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.350]                     next
[16:12:51.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.350]                 }
[16:12:51.350]                 NAMES <- toupper(added)
[16:12:51.350]                 for (kk in seq_along(NAMES)) {
[16:12:51.350]                   name <- added[[kk]]
[16:12:51.350]                   NAME <- NAMES[[kk]]
[16:12:51.350]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.350]                     next
[16:12:51.350]                   args[[name]] <- ""
[16:12:51.350]                 }
[16:12:51.350]                 NAMES <- toupper(removed)
[16:12:51.350]                 for (kk in seq_along(NAMES)) {
[16:12:51.350]                   name <- removed[[kk]]
[16:12:51.350]                   NAME <- NAMES[[kk]]
[16:12:51.350]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.350]                     next
[16:12:51.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.350]                 }
[16:12:51.350]                 if (length(args) > 0) 
[16:12:51.350]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.350]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.350]             }
[16:12:51.350]             else {
[16:12:51.350]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.350]             }
[16:12:51.350]             {
[16:12:51.350]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.350]                   0L) {
[16:12:51.350]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.350]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.350]                   base::options(opts)
[16:12:51.350]                 }
[16:12:51.350]                 {
[16:12:51.350]                   {
[16:12:51.350]                     NULL
[16:12:51.350]                     RNGkind("Mersenne-Twister")
[16:12:51.350]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.350]                       inherits = FALSE)
[16:12:51.350]                   }
[16:12:51.350]                   options(future.plan = NULL)
[16:12:51.350]                   if (is.na(NA_character_)) 
[16:12:51.350]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.350]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.350]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.350]                   {
[16:12:51.350]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.350]                     if (!future$lazy) 
[16:12:51.350]                       future <- run(future)
[16:12:51.350]                     invisible(future)
[16:12:51.350]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.350]                 }
[16:12:51.350]             }
[16:12:51.350]         }
[16:12:51.350]     })
[16:12:51.350]     if (TRUE) {
[16:12:51.350]         base::sink(type = "output", split = FALSE)
[16:12:51.350]         if (TRUE) {
[16:12:51.350]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.350]         }
[16:12:51.350]         else {
[16:12:51.350]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.350]         }
[16:12:51.350]         base::close(...future.stdout)
[16:12:51.350]         ...future.stdout <- NULL
[16:12:51.350]     }
[16:12:51.350]     ...future.result$conditions <- ...future.conditions
[16:12:51.350]     ...future.result$finished <- base::Sys.time()
[16:12:51.350]     ...future.result
[16:12:51.350] }
[16:12:51.352] plan(): Setting new future strategy stack:
[16:12:51.352] List of future strategies:
[16:12:51.352] 1. sequential:
[16:12:51.352]    - args: function (..., envir = parent.frame())
[16:12:51.352]    - tweaked: FALSE
[16:12:51.352]    - call: NULL
[16:12:51.352] plan(): nbrOfWorkers() = 1
[16:12:51.353] plan(): Setting new future strategy stack:
[16:12:51.353] List of future strategies:
[16:12:51.353] 1. sequential:
[16:12:51.353]    - args: function (..., envir = parent.frame())
[16:12:51.353]    - tweaked: FALSE
[16:12:51.353]    - call: plan(strategy)
[16:12:51.353] plan(): nbrOfWorkers() = 1
[16:12:51.353] SequentialFuture started (and completed)
[16:12:51.353] - Launch lazy future ... done
[16:12:51.354] run() for ‘SequentialFuture’ ... done
[16:12:51.354] resolved() for ‘SequentialFuture’ ...
[16:12:51.354] - state: ‘finished’
[16:12:51.354] - run: TRUE
[16:12:51.354] - result: ‘FutureResult’
[16:12:51.354] resolved() for ‘SequentialFuture’ ... done
[16:12:51.354] Future #1
[16:12:51.354] resolved() for ‘SequentialFuture’ ...
[16:12:51.354] - state: ‘finished’
[16:12:51.355] - run: TRUE
[16:12:51.355] - result: ‘FutureResult’
[16:12:51.355] resolved() for ‘SequentialFuture’ ... done
[16:12:51.355] A SequentialFuture was resolved
[16:12:51.355]  length: 0 (resolved future 1)
[16:12:51.355] resolve() on list ... DONE
[16:12:51.355] - globals: [1] ‘a’
[16:12:51.355] Resolving futures part of globals (recursively) ... DONE
[16:12:51.357] The total size of the 1 globals is 1.52 MiB (1596216 bytes)
[16:12:51.357] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.52 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.52 MiB of class ‘environment’)
[16:12:51.357] - globals: [1] ‘a’
[16:12:51.358] - packages: [1] ‘future’
[16:12:51.358] getGlobalsAndPackages() ... DONE
[16:12:51.358] run() for ‘Future’ ...
[16:12:51.358] - state: ‘created’
[16:12:51.358] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.358] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.359] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.359]   - Field: ‘label’
[16:12:51.359]   - Field: ‘local’
[16:12:51.359]   - Field: ‘owner’
[16:12:51.359]   - Field: ‘envir’
[16:12:51.359]   - Field: ‘packages’
[16:12:51.359]   - Field: ‘gc’
[16:12:51.359]   - Field: ‘conditions’
[16:12:51.359]   - Field: ‘expr’
[16:12:51.359]   - Field: ‘uuid’
[16:12:51.360]   - Field: ‘seed’
[16:12:51.360]   - Field: ‘version’
[16:12:51.360]   - Field: ‘result’
[16:12:51.360]   - Field: ‘asynchronous’
[16:12:51.360]   - Field: ‘calls’
[16:12:51.360]   - Field: ‘globals’
[16:12:51.360]   - Field: ‘stdout’
[16:12:51.360]   - Field: ‘earlySignal’
[16:12:51.360]   - Field: ‘lazy’
[16:12:51.360]   - Field: ‘state’
[16:12:51.361] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.361] - Launch lazy future ...
[16:12:51.361] Packages needed by the future expression (n = 1): ‘future’
[16:12:51.361] Packages needed by future strategies (n = 0): <none>
[16:12:51.361] {
[16:12:51.361]     {
[16:12:51.361]         {
[16:12:51.361]             ...future.startTime <- base::Sys.time()
[16:12:51.361]             {
[16:12:51.361]                 {
[16:12:51.361]                   {
[16:12:51.361]                     {
[16:12:51.361]                       base::local({
[16:12:51.361]                         has_future <- base::requireNamespace("future", 
[16:12:51.361]                           quietly = TRUE)
[16:12:51.361]                         if (has_future) {
[16:12:51.361]                           ns <- base::getNamespace("future")
[16:12:51.361]                           version <- ns[[".package"]][["version"]]
[16:12:51.361]                           if (is.null(version)) 
[16:12:51.361]                             version <- utils::packageVersion("future")
[16:12:51.361]                         }
[16:12:51.361]                         else {
[16:12:51.361]                           version <- NULL
[16:12:51.361]                         }
[16:12:51.361]                         if (!has_future || version < "1.8.0") {
[16:12:51.361]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.361]                             "", base::R.version$version.string), 
[16:12:51.361]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:51.361]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.361]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.361]                               "release", "version")], collapse = " "), 
[16:12:51.361]                             hostname = base::Sys.info()[["nodename"]])
[16:12:51.361]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.361]                             info)
[16:12:51.361]                           info <- base::paste(info, collapse = "; ")
[16:12:51.361]                           if (!has_future) {
[16:12:51.361]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.361]                               info)
[16:12:51.361]                           }
[16:12:51.361]                           else {
[16:12:51.361]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.361]                               info, version)
[16:12:51.361]                           }
[16:12:51.361]                           base::stop(msg)
[16:12:51.361]                         }
[16:12:51.361]                       })
[16:12:51.361]                     }
[16:12:51.361]                     base::local({
[16:12:51.361]                       for (pkg in "future") {
[16:12:51.361]                         base::loadNamespace(pkg)
[16:12:51.361]                         base::library(pkg, character.only = TRUE)
[16:12:51.361]                       }
[16:12:51.361]                     })
[16:12:51.361]                   }
[16:12:51.361]                   options(future.plan = NULL)
[16:12:51.361]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.361]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.361]                 }
[16:12:51.361]                 ...future.workdir <- getwd()
[16:12:51.361]             }
[16:12:51.361]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.361]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.361]         }
[16:12:51.361]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.361]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:51.361]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.361]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.361]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.361]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.361]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.361]             base::names(...future.oldOptions))
[16:12:51.361]     }
[16:12:51.361]     if (FALSE) {
[16:12:51.361]     }
[16:12:51.361]     else {
[16:12:51.361]         if (TRUE) {
[16:12:51.361]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.361]                 open = "w")
[16:12:51.361]         }
[16:12:51.361]         else {
[16:12:51.361]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.361]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.361]         }
[16:12:51.361]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.361]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.361]             base::sink(type = "output", split = FALSE)
[16:12:51.361]             base::close(...future.stdout)
[16:12:51.361]         }, add = TRUE)
[16:12:51.361]     }
[16:12:51.361]     ...future.frame <- base::sys.nframe()
[16:12:51.361]     ...future.conditions <- base::list()
[16:12:51.361]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.361]     if (FALSE) {
[16:12:51.361]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.361]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.361]     }
[16:12:51.361]     ...future.result <- base::tryCatch({
[16:12:51.361]         base::withCallingHandlers({
[16:12:51.361]             ...future.value <- base::withVisible(base::local(value(a) + 
[16:12:51.361]                 1))
[16:12:51.361]             future::FutureResult(value = ...future.value$value, 
[16:12:51.361]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.361]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.361]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.361]                     ...future.globalenv.names))
[16:12:51.361]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.361]         }, condition = base::local({
[16:12:51.361]             c <- base::c
[16:12:51.361]             inherits <- base::inherits
[16:12:51.361]             invokeRestart <- base::invokeRestart
[16:12:51.361]             length <- base::length
[16:12:51.361]             list <- base::list
[16:12:51.361]             seq.int <- base::seq.int
[16:12:51.361]             signalCondition <- base::signalCondition
[16:12:51.361]             sys.calls <- base::sys.calls
[16:12:51.361]             `[[` <- base::`[[`
[16:12:51.361]             `+` <- base::`+`
[16:12:51.361]             `<<-` <- base::`<<-`
[16:12:51.361]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.361]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.361]                   3L)]
[16:12:51.361]             }
[16:12:51.361]             function(cond) {
[16:12:51.361]                 is_error <- inherits(cond, "error")
[16:12:51.361]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.361]                   NULL)
[16:12:51.361]                 if (is_error) {
[16:12:51.361]                   sessionInformation <- function() {
[16:12:51.361]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.361]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.361]                       search = base::search(), system = base::Sys.info())
[16:12:51.361]                   }
[16:12:51.361]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.361]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.361]                     cond$call), session = sessionInformation(), 
[16:12:51.361]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.361]                   signalCondition(cond)
[16:12:51.361]                 }
[16:12:51.361]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.361]                 "immediateCondition"))) {
[16:12:51.361]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.361]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.361]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.361]                   if (TRUE && !signal) {
[16:12:51.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.361]                     {
[16:12:51.361]                       inherits <- base::inherits
[16:12:51.361]                       invokeRestart <- base::invokeRestart
[16:12:51.361]                       is.null <- base::is.null
[16:12:51.361]                       muffled <- FALSE
[16:12:51.361]                       if (inherits(cond, "message")) {
[16:12:51.361]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.361]                         if (muffled) 
[16:12:51.361]                           invokeRestart("muffleMessage")
[16:12:51.361]                       }
[16:12:51.361]                       else if (inherits(cond, "warning")) {
[16:12:51.361]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.361]                         if (muffled) 
[16:12:51.361]                           invokeRestart("muffleWarning")
[16:12:51.361]                       }
[16:12:51.361]                       else if (inherits(cond, "condition")) {
[16:12:51.361]                         if (!is.null(pattern)) {
[16:12:51.361]                           computeRestarts <- base::computeRestarts
[16:12:51.361]                           grepl <- base::grepl
[16:12:51.361]                           restarts <- computeRestarts(cond)
[16:12:51.361]                           for (restart in restarts) {
[16:12:51.361]                             name <- restart$name
[16:12:51.361]                             if (is.null(name)) 
[16:12:51.361]                               next
[16:12:51.361]                             if (!grepl(pattern, name)) 
[16:12:51.361]                               next
[16:12:51.361]                             invokeRestart(restart)
[16:12:51.361]                             muffled <- TRUE
[16:12:51.361]                             break
[16:12:51.361]                           }
[16:12:51.361]                         }
[16:12:51.361]                       }
[16:12:51.361]                       invisible(muffled)
[16:12:51.361]                     }
[16:12:51.361]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.361]                   }
[16:12:51.361]                 }
[16:12:51.361]                 else {
[16:12:51.361]                   if (TRUE) {
[16:12:51.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.361]                     {
[16:12:51.361]                       inherits <- base::inherits
[16:12:51.361]                       invokeRestart <- base::invokeRestart
[16:12:51.361]                       is.null <- base::is.null
[16:12:51.361]                       muffled <- FALSE
[16:12:51.361]                       if (inherits(cond, "message")) {
[16:12:51.361]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.361]                         if (muffled) 
[16:12:51.361]                           invokeRestart("muffleMessage")
[16:12:51.361]                       }
[16:12:51.361]                       else if (inherits(cond, "warning")) {
[16:12:51.361]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.361]                         if (muffled) 
[16:12:51.361]                           invokeRestart("muffleWarning")
[16:12:51.361]                       }
[16:12:51.361]                       else if (inherits(cond, "condition")) {
[16:12:51.361]                         if (!is.null(pattern)) {
[16:12:51.361]                           computeRestarts <- base::computeRestarts
[16:12:51.361]                           grepl <- base::grepl
[16:12:51.361]                           restarts <- computeRestarts(cond)
[16:12:51.361]                           for (restart in restarts) {
[16:12:51.361]                             name <- restart$name
[16:12:51.361]                             if (is.null(name)) 
[16:12:51.361]                               next
[16:12:51.361]                             if (!grepl(pattern, name)) 
[16:12:51.361]                               next
[16:12:51.361]                             invokeRestart(restart)
[16:12:51.361]                             muffled <- TRUE
[16:12:51.361]                             break
[16:12:51.361]                           }
[16:12:51.361]                         }
[16:12:51.361]                       }
[16:12:51.361]                       invisible(muffled)
[16:12:51.361]                     }
[16:12:51.361]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.361]                   }
[16:12:51.361]                 }
[16:12:51.361]             }
[16:12:51.361]         }))
[16:12:51.361]     }, error = function(ex) {
[16:12:51.361]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.361]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.361]                 ...future.rng), started = ...future.startTime, 
[16:12:51.361]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.361]             version = "1.8"), class = "FutureResult")
[16:12:51.361]     }, finally = {
[16:12:51.361]         if (!identical(...future.workdir, getwd())) 
[16:12:51.361]             setwd(...future.workdir)
[16:12:51.361]         {
[16:12:51.361]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.361]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.361]             }
[16:12:51.361]             base::options(...future.oldOptions)
[16:12:51.361]             if (.Platform$OS.type == "windows") {
[16:12:51.361]                 old_names <- names(...future.oldEnvVars)
[16:12:51.361]                 envs <- base::Sys.getenv()
[16:12:51.361]                 names <- names(envs)
[16:12:51.361]                 common <- intersect(names, old_names)
[16:12:51.361]                 added <- setdiff(names, old_names)
[16:12:51.361]                 removed <- setdiff(old_names, names)
[16:12:51.361]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.361]                   envs[common]]
[16:12:51.361]                 NAMES <- toupper(changed)
[16:12:51.361]                 args <- list()
[16:12:51.361]                 for (kk in seq_along(NAMES)) {
[16:12:51.361]                   name <- changed[[kk]]
[16:12:51.361]                   NAME <- NAMES[[kk]]
[16:12:51.361]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.361]                     next
[16:12:51.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.361]                 }
[16:12:51.361]                 NAMES <- toupper(added)
[16:12:51.361]                 for (kk in seq_along(NAMES)) {
[16:12:51.361]                   name <- added[[kk]]
[16:12:51.361]                   NAME <- NAMES[[kk]]
[16:12:51.361]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.361]                     next
[16:12:51.361]                   args[[name]] <- ""
[16:12:51.361]                 }
[16:12:51.361]                 NAMES <- toupper(removed)
[16:12:51.361]                 for (kk in seq_along(NAMES)) {
[16:12:51.361]                   name <- removed[[kk]]
[16:12:51.361]                   NAME <- NAMES[[kk]]
[16:12:51.361]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.361]                     next
[16:12:51.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.361]                 }
[16:12:51.361]                 if (length(args) > 0) 
[16:12:51.361]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.361]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.361]             }
[16:12:51.361]             else {
[16:12:51.361]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.361]             }
[16:12:51.361]             {
[16:12:51.361]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.361]                   0L) {
[16:12:51.361]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.361]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.361]                   base::options(opts)
[16:12:51.361]                 }
[16:12:51.361]                 {
[16:12:51.361]                   {
[16:12:51.361]                     NULL
[16:12:51.361]                     RNGkind("Mersenne-Twister")
[16:12:51.361]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.361]                       inherits = FALSE)
[16:12:51.361]                   }
[16:12:51.361]                   options(future.plan = NULL)
[16:12:51.361]                   if (is.na(NA_character_)) 
[16:12:51.361]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.361]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.361]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.361]                   {
[16:12:51.361]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.361]                     if (!future$lazy) 
[16:12:51.361]                       future <- run(future)
[16:12:51.361]                     invisible(future)
[16:12:51.361]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.361]                 }
[16:12:51.361]             }
[16:12:51.361]         }
[16:12:51.361]     })
[16:12:51.361]     if (TRUE) {
[16:12:51.361]         base::sink(type = "output", split = FALSE)
[16:12:51.361]         if (TRUE) {
[16:12:51.361]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.361]         }
[16:12:51.361]         else {
[16:12:51.361]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.361]         }
[16:12:51.361]         base::close(...future.stdout)
[16:12:51.361]         ...future.stdout <- NULL
[16:12:51.361]     }
[16:12:51.361]     ...future.result$conditions <- ...future.conditions
[16:12:51.361]     ...future.result$finished <- base::Sys.time()
[16:12:51.361]     ...future.result
[16:12:51.361] }
[16:12:51.363] assign_globals() ...
[16:12:51.363] List of 1
[16:12:51.363]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x56233de2d0e0> 
[16:12:51.363]  - attr(*, "where")=List of 1
[16:12:51.363]   ..$ a:<environment: R_EmptyEnv> 
[16:12:51.363]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.363]  - attr(*, "resolved")= logi TRUE
[16:12:51.363]  - attr(*, "total_size")= num 1596216
[16:12:51.363]  - attr(*, "already-done")= logi TRUE
[16:12:51.366] - copied ‘a’ to environment
[16:12:51.366] assign_globals() ... done
[16:12:51.366] plan(): Setting new future strategy stack:
[16:12:51.366] List of future strategies:
[16:12:51.366] 1. sequential:
[16:12:51.366]    - args: function (..., envir = parent.frame())
[16:12:51.366]    - tweaked: FALSE
[16:12:51.366]    - call: NULL
[16:12:51.367] plan(): nbrOfWorkers() = 1
[16:12:51.367] plan(): Setting new future strategy stack:
[16:12:51.368] List of future strategies:
[16:12:51.368] 1. sequential:
[16:12:51.368]    - args: function (..., envir = parent.frame())
[16:12:51.368]    - tweaked: FALSE
[16:12:51.368]    - call: plan(strategy)
[16:12:51.368] plan(): nbrOfWorkers() = 1
[16:12:51.368] SequentialFuture started (and completed)
[16:12:51.368] - Launch lazy future ... done
[16:12:51.368] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.369] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.369] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:51.370] - globals found: [2] ‘{’, ‘pkg’
[16:12:51.370] Searching for globals ... DONE
[16:12:51.370] Resolving globals: TRUE
[16:12:51.370] Resolving any globals that are futures ...
[16:12:51.370] - globals: [2] ‘{’, ‘pkg’
[16:12:51.370] Resolving any globals that are futures ... DONE
[16:12:51.371] Resolving futures part of globals (recursively) ...
[16:12:51.371] resolve() on list ...
[16:12:51.371]  recursive: 99
[16:12:51.371]  length: 1
[16:12:51.371]  elements: ‘pkg’
[16:12:51.371]  length: 0 (resolved future 1)
[16:12:51.373] resolve() on list ... DONE
[16:12:51.373] - globals: [1] ‘pkg’
[16:12:51.373] Resolving futures part of globals (recursively) ... DONE
[16:12:51.373] The total size of the 1 globals is 112 bytes (112 bytes)
[16:12:51.374] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[16:12:51.374] - globals: [1] ‘pkg’
[16:12:51.374] 
[16:12:51.374] getGlobalsAndPackages() ... DONE
[16:12:51.374] Packages needed by the future expression (n = 0): <none>
[16:12:51.374] Packages needed by future strategies (n = 0): <none>
[16:12:51.375] {
[16:12:51.375]     {
[16:12:51.375]         {
[16:12:51.375]             ...future.startTime <- base::Sys.time()
[16:12:51.375]             {
[16:12:51.375]                 {
[16:12:51.375]                   {
[16:12:51.375]                     base::local({
[16:12:51.375]                       has_future <- base::requireNamespace("future", 
[16:12:51.375]                         quietly = TRUE)
[16:12:51.375]                       if (has_future) {
[16:12:51.375]                         ns <- base::getNamespace("future")
[16:12:51.375]                         version <- ns[[".package"]][["version"]]
[16:12:51.375]                         if (is.null(version)) 
[16:12:51.375]                           version <- utils::packageVersion("future")
[16:12:51.375]                       }
[16:12:51.375]                       else {
[16:12:51.375]                         version <- NULL
[16:12:51.375]                       }
[16:12:51.375]                       if (!has_future || version < "1.8.0") {
[16:12:51.375]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.375]                           "", base::R.version$version.string), 
[16:12:51.375]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:51.375]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.375]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.375]                             "release", "version")], collapse = " "), 
[16:12:51.375]                           hostname = base::Sys.info()[["nodename"]])
[16:12:51.375]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.375]                           info)
[16:12:51.375]                         info <- base::paste(info, collapse = "; ")
[16:12:51.375]                         if (!has_future) {
[16:12:51.375]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.375]                             info)
[16:12:51.375]                         }
[16:12:51.375]                         else {
[16:12:51.375]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.375]                             info, version)
[16:12:51.375]                         }
[16:12:51.375]                         base::stop(msg)
[16:12:51.375]                       }
[16:12:51.375]                     })
[16:12:51.375]                   }
[16:12:51.375]                   options(future.plan = NULL)
[16:12:51.375]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.375]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.375]                 }
[16:12:51.375]                 ...future.workdir <- getwd()
[16:12:51.375]             }
[16:12:51.375]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.375]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.375]         }
[16:12:51.375]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.375]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:51.375]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.375]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.375]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.375]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.375]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.375]             base::names(...future.oldOptions))
[16:12:51.375]     }
[16:12:51.375]     if (FALSE) {
[16:12:51.375]     }
[16:12:51.375]     else {
[16:12:51.375]         if (TRUE) {
[16:12:51.375]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.375]                 open = "w")
[16:12:51.375]         }
[16:12:51.375]         else {
[16:12:51.375]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.375]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.375]         }
[16:12:51.375]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.375]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.375]             base::sink(type = "output", split = FALSE)
[16:12:51.375]             base::close(...future.stdout)
[16:12:51.375]         }, add = TRUE)
[16:12:51.375]     }
[16:12:51.375]     ...future.frame <- base::sys.nframe()
[16:12:51.375]     ...future.conditions <- base::list()
[16:12:51.375]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.375]     if (FALSE) {
[16:12:51.375]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.375]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.375]     }
[16:12:51.375]     ...future.result <- base::tryCatch({
[16:12:51.375]         base::withCallingHandlers({
[16:12:51.375]             ...future.value <- base::withVisible(base::local({
[16:12:51.375]                 pkg
[16:12:51.375]             }))
[16:12:51.375]             future::FutureResult(value = ...future.value$value, 
[16:12:51.375]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.375]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.375]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.375]                     ...future.globalenv.names))
[16:12:51.375]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.375]         }, condition = base::local({
[16:12:51.375]             c <- base::c
[16:12:51.375]             inherits <- base::inherits
[16:12:51.375]             invokeRestart <- base::invokeRestart
[16:12:51.375]             length <- base::length
[16:12:51.375]             list <- base::list
[16:12:51.375]             seq.int <- base::seq.int
[16:12:51.375]             signalCondition <- base::signalCondition
[16:12:51.375]             sys.calls <- base::sys.calls
[16:12:51.375]             `[[` <- base::`[[`
[16:12:51.375]             `+` <- base::`+`
[16:12:51.375]             `<<-` <- base::`<<-`
[16:12:51.375]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.375]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.375]                   3L)]
[16:12:51.375]             }
[16:12:51.375]             function(cond) {
[16:12:51.375]                 is_error <- inherits(cond, "error")
[16:12:51.375]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.375]                   NULL)
[16:12:51.375]                 if (is_error) {
[16:12:51.375]                   sessionInformation <- function() {
[16:12:51.375]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.375]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.375]                       search = base::search(), system = base::Sys.info())
[16:12:51.375]                   }
[16:12:51.375]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.375]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.375]                     cond$call), session = sessionInformation(), 
[16:12:51.375]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.375]                   signalCondition(cond)
[16:12:51.375]                 }
[16:12:51.375]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.375]                 "immediateCondition"))) {
[16:12:51.375]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.375]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.375]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.375]                   if (TRUE && !signal) {
[16:12:51.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.375]                     {
[16:12:51.375]                       inherits <- base::inherits
[16:12:51.375]                       invokeRestart <- base::invokeRestart
[16:12:51.375]                       is.null <- base::is.null
[16:12:51.375]                       muffled <- FALSE
[16:12:51.375]                       if (inherits(cond, "message")) {
[16:12:51.375]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.375]                         if (muffled) 
[16:12:51.375]                           invokeRestart("muffleMessage")
[16:12:51.375]                       }
[16:12:51.375]                       else if (inherits(cond, "warning")) {
[16:12:51.375]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.375]                         if (muffled) 
[16:12:51.375]                           invokeRestart("muffleWarning")
[16:12:51.375]                       }
[16:12:51.375]                       else if (inherits(cond, "condition")) {
[16:12:51.375]                         if (!is.null(pattern)) {
[16:12:51.375]                           computeRestarts <- base::computeRestarts
[16:12:51.375]                           grepl <- base::grepl
[16:12:51.375]                           restarts <- computeRestarts(cond)
[16:12:51.375]                           for (restart in restarts) {
[16:12:51.375]                             name <- restart$name
[16:12:51.375]                             if (is.null(name)) 
[16:12:51.375]                               next
[16:12:51.375]                             if (!grepl(pattern, name)) 
[16:12:51.375]                               next
[16:12:51.375]                             invokeRestart(restart)
[16:12:51.375]                             muffled <- TRUE
[16:12:51.375]                             break
[16:12:51.375]                           }
[16:12:51.375]                         }
[16:12:51.375]                       }
[16:12:51.375]                       invisible(muffled)
[16:12:51.375]                     }
[16:12:51.375]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.375]                   }
[16:12:51.375]                 }
[16:12:51.375]                 else {
[16:12:51.375]                   if (TRUE) {
[16:12:51.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.375]                     {
[16:12:51.375]                       inherits <- base::inherits
[16:12:51.375]                       invokeRestart <- base::invokeRestart
[16:12:51.375]                       is.null <- base::is.null
[16:12:51.375]                       muffled <- FALSE
[16:12:51.375]                       if (inherits(cond, "message")) {
[16:12:51.375]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.375]                         if (muffled) 
[16:12:51.375]                           invokeRestart("muffleMessage")
[16:12:51.375]                       }
[16:12:51.375]                       else if (inherits(cond, "warning")) {
[16:12:51.375]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.375]                         if (muffled) 
[16:12:51.375]                           invokeRestart("muffleWarning")
[16:12:51.375]                       }
[16:12:51.375]                       else if (inherits(cond, "condition")) {
[16:12:51.375]                         if (!is.null(pattern)) {
[16:12:51.375]                           computeRestarts <- base::computeRestarts
[16:12:51.375]                           grepl <- base::grepl
[16:12:51.375]                           restarts <- computeRestarts(cond)
[16:12:51.375]                           for (restart in restarts) {
[16:12:51.375]                             name <- restart$name
[16:12:51.375]                             if (is.null(name)) 
[16:12:51.375]                               next
[16:12:51.375]                             if (!grepl(pattern, name)) 
[16:12:51.375]                               next
[16:12:51.375]                             invokeRestart(restart)
[16:12:51.375]                             muffled <- TRUE
[16:12:51.375]                             break
[16:12:51.375]                           }
[16:12:51.375]                         }
[16:12:51.375]                       }
[16:12:51.375]                       invisible(muffled)
[16:12:51.375]                     }
[16:12:51.375]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.375]                   }
[16:12:51.375]                 }
[16:12:51.375]             }
[16:12:51.375]         }))
[16:12:51.375]     }, error = function(ex) {
[16:12:51.375]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.375]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.375]                 ...future.rng), started = ...future.startTime, 
[16:12:51.375]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.375]             version = "1.8"), class = "FutureResult")
[16:12:51.375]     }, finally = {
[16:12:51.375]         if (!identical(...future.workdir, getwd())) 
[16:12:51.375]             setwd(...future.workdir)
[16:12:51.375]         {
[16:12:51.375]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.375]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.375]             }
[16:12:51.375]             base::options(...future.oldOptions)
[16:12:51.375]             if (.Platform$OS.type == "windows") {
[16:12:51.375]                 old_names <- names(...future.oldEnvVars)
[16:12:51.375]                 envs <- base::Sys.getenv()
[16:12:51.375]                 names <- names(envs)
[16:12:51.375]                 common <- intersect(names, old_names)
[16:12:51.375]                 added <- setdiff(names, old_names)
[16:12:51.375]                 removed <- setdiff(old_names, names)
[16:12:51.375]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.375]                   envs[common]]
[16:12:51.375]                 NAMES <- toupper(changed)
[16:12:51.375]                 args <- list()
[16:12:51.375]                 for (kk in seq_along(NAMES)) {
[16:12:51.375]                   name <- changed[[kk]]
[16:12:51.375]                   NAME <- NAMES[[kk]]
[16:12:51.375]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.375]                     next
[16:12:51.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.375]                 }
[16:12:51.375]                 NAMES <- toupper(added)
[16:12:51.375]                 for (kk in seq_along(NAMES)) {
[16:12:51.375]                   name <- added[[kk]]
[16:12:51.375]                   NAME <- NAMES[[kk]]
[16:12:51.375]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.375]                     next
[16:12:51.375]                   args[[name]] <- ""
[16:12:51.375]                 }
[16:12:51.375]                 NAMES <- toupper(removed)
[16:12:51.375]                 for (kk in seq_along(NAMES)) {
[16:12:51.375]                   name <- removed[[kk]]
[16:12:51.375]                   NAME <- NAMES[[kk]]
[16:12:51.375]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.375]                     next
[16:12:51.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.375]                 }
[16:12:51.375]                 if (length(args) > 0) 
[16:12:51.375]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.375]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.375]             }
[16:12:51.375]             else {
[16:12:51.375]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.375]             }
[16:12:51.375]             {
[16:12:51.375]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.375]                   0L) {
[16:12:51.375]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.375]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.375]                   base::options(opts)
[16:12:51.375]                 }
[16:12:51.375]                 {
[16:12:51.375]                   {
[16:12:51.375]                     NULL
[16:12:51.375]                     RNGkind("Mersenne-Twister")
[16:12:51.375]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.375]                       inherits = FALSE)
[16:12:51.375]                   }
[16:12:51.375]                   options(future.plan = NULL)
[16:12:51.375]                   if (is.na(NA_character_)) 
[16:12:51.375]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.375]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.375]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.375]                   {
[16:12:51.375]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.375]                     if (!future$lazy) 
[16:12:51.375]                       future <- run(future)
[16:12:51.375]                     invisible(future)
[16:12:51.375]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.375]                 }
[16:12:51.375]             }
[16:12:51.375]         }
[16:12:51.375]     })
[16:12:51.375]     if (TRUE) {
[16:12:51.375]         base::sink(type = "output", split = FALSE)
[16:12:51.375]         if (TRUE) {
[16:12:51.375]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.375]         }
[16:12:51.375]         else {
[16:12:51.375]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.375]         }
[16:12:51.375]         base::close(...future.stdout)
[16:12:51.375]         ...future.stdout <- NULL
[16:12:51.375]     }
[16:12:51.375]     ...future.result$conditions <- ...future.conditions
[16:12:51.375]     ...future.result$finished <- base::Sys.time()
[16:12:51.375]     ...future.result
[16:12:51.375] }
[16:12:51.376] assign_globals() ...
[16:12:51.377] List of 1
[16:12:51.377]  $ pkg: chr "foo"
[16:12:51.377]  - attr(*, "where")=List of 1
[16:12:51.377]   ..$ pkg:<environment: R_EmptyEnv> 
[16:12:51.377]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.377]  - attr(*, "resolved")= logi TRUE
[16:12:51.377]  - attr(*, "total_size")= num 112
[16:12:51.379] - copied ‘pkg’ to environment
[16:12:51.379] assign_globals() ... done
[16:12:51.379] plan(): Setting new future strategy stack:
[16:12:51.379] List of future strategies:
[16:12:51.379] 1. sequential:
[16:12:51.379]    - args: function (..., envir = parent.frame())
[16:12:51.379]    - tweaked: FALSE
[16:12:51.379]    - call: NULL
[16:12:51.379] plan(): nbrOfWorkers() = 1
[16:12:51.380] plan(): Setting new future strategy stack:
[16:12:51.380] List of future strategies:
[16:12:51.380] 1. sequential:
[16:12:51.380]    - args: function (..., envir = parent.frame())
[16:12:51.380]    - tweaked: FALSE
[16:12:51.380]    - call: plan(strategy)
[16:12:51.381] plan(): nbrOfWorkers() = 1
[16:12:51.381] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.381] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.381] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:51.383] - globals found: [3] ‘{’, ‘<-’, ‘+’
[16:12:51.383] Searching for globals ... DONE
[16:12:51.383] Resolving globals: TRUE
[16:12:51.384] Resolving any globals that are futures ...
[16:12:51.384] - globals: [3] ‘{’, ‘<-’, ‘+’
[16:12:51.384] Resolving any globals that are futures ... DONE
[16:12:51.384] 
[16:12:51.384] 
[16:12:51.384] getGlobalsAndPackages() ... DONE
[16:12:51.384] run() for ‘Future’ ...
[16:12:51.385] - state: ‘created’
[16:12:51.385] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.385] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.385] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.385]   - Field: ‘label’
[16:12:51.385]   - Field: ‘local’
[16:12:51.385]   - Field: ‘owner’
[16:12:51.385]   - Field: ‘envir’
[16:12:51.386]   - Field: ‘packages’
[16:12:51.386]   - Field: ‘gc’
[16:12:51.386]   - Field: ‘conditions’
[16:12:51.386]   - Field: ‘expr’
[16:12:51.386]   - Field: ‘uuid’
[16:12:51.386]   - Field: ‘seed’
[16:12:51.386]   - Field: ‘version’
[16:12:51.386]   - Field: ‘result’
[16:12:51.386]   - Field: ‘asynchronous’
[16:12:51.386]   - Field: ‘calls’
[16:12:51.386]   - Field: ‘globals’
[16:12:51.387]   - Field: ‘stdout’
[16:12:51.387]   - Field: ‘earlySignal’
[16:12:51.387]   - Field: ‘lazy’
[16:12:51.387]   - Field: ‘state’
[16:12:51.387] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.387] - Launch lazy future ...
[16:12:51.387] Packages needed by the future expression (n = 0): <none>
[16:12:51.387] Packages needed by future strategies (n = 0): <none>
[16:12:51.388] {
[16:12:51.388]     {
[16:12:51.388]         {
[16:12:51.388]             ...future.startTime <- base::Sys.time()
[16:12:51.388]             {
[16:12:51.388]                 {
[16:12:51.388]                   {
[16:12:51.388]                     base::local({
[16:12:51.388]                       has_future <- base::requireNamespace("future", 
[16:12:51.388]                         quietly = TRUE)
[16:12:51.388]                       if (has_future) {
[16:12:51.388]                         ns <- base::getNamespace("future")
[16:12:51.388]                         version <- ns[[".package"]][["version"]]
[16:12:51.388]                         if (is.null(version)) 
[16:12:51.388]                           version <- utils::packageVersion("future")
[16:12:51.388]                       }
[16:12:51.388]                       else {
[16:12:51.388]                         version <- NULL
[16:12:51.388]                       }
[16:12:51.388]                       if (!has_future || version < "1.8.0") {
[16:12:51.388]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.388]                           "", base::R.version$version.string), 
[16:12:51.388]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:51.388]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.388]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.388]                             "release", "version")], collapse = " "), 
[16:12:51.388]                           hostname = base::Sys.info()[["nodename"]])
[16:12:51.388]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.388]                           info)
[16:12:51.388]                         info <- base::paste(info, collapse = "; ")
[16:12:51.388]                         if (!has_future) {
[16:12:51.388]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.388]                             info)
[16:12:51.388]                         }
[16:12:51.388]                         else {
[16:12:51.388]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.388]                             info, version)
[16:12:51.388]                         }
[16:12:51.388]                         base::stop(msg)
[16:12:51.388]                       }
[16:12:51.388]                     })
[16:12:51.388]                   }
[16:12:51.388]                   options(future.plan = NULL)
[16:12:51.388]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.388]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.388]                 }
[16:12:51.388]                 ...future.workdir <- getwd()
[16:12:51.388]             }
[16:12:51.388]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.388]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.388]         }
[16:12:51.388]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.388]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:51.388]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.388]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.388]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.388]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.388]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.388]             base::names(...future.oldOptions))
[16:12:51.388]     }
[16:12:51.388]     if (FALSE) {
[16:12:51.388]     }
[16:12:51.388]     else {
[16:12:51.388]         if (TRUE) {
[16:12:51.388]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.388]                 open = "w")
[16:12:51.388]         }
[16:12:51.388]         else {
[16:12:51.388]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.388]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.388]         }
[16:12:51.388]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.388]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.388]             base::sink(type = "output", split = FALSE)
[16:12:51.388]             base::close(...future.stdout)
[16:12:51.388]         }, add = TRUE)
[16:12:51.388]     }
[16:12:51.388]     ...future.frame <- base::sys.nframe()
[16:12:51.388]     ...future.conditions <- base::list()
[16:12:51.388]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.388]     if (FALSE) {
[16:12:51.388]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.388]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.388]     }
[16:12:51.388]     ...future.result <- base::tryCatch({
[16:12:51.388]         base::withCallingHandlers({
[16:12:51.388]             ...future.value <- base::withVisible(base::local({
[16:12:51.388]                 x <- 0
[16:12:51.388]                 x <- x + 1
[16:12:51.388]                 x
[16:12:51.388]             }))
[16:12:51.388]             future::FutureResult(value = ...future.value$value, 
[16:12:51.388]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.388]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.388]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.388]                     ...future.globalenv.names))
[16:12:51.388]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.388]         }, condition = base::local({
[16:12:51.388]             c <- base::c
[16:12:51.388]             inherits <- base::inherits
[16:12:51.388]             invokeRestart <- base::invokeRestart
[16:12:51.388]             length <- base::length
[16:12:51.388]             list <- base::list
[16:12:51.388]             seq.int <- base::seq.int
[16:12:51.388]             signalCondition <- base::signalCondition
[16:12:51.388]             sys.calls <- base::sys.calls
[16:12:51.388]             `[[` <- base::`[[`
[16:12:51.388]             `+` <- base::`+`
[16:12:51.388]             `<<-` <- base::`<<-`
[16:12:51.388]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.388]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.388]                   3L)]
[16:12:51.388]             }
[16:12:51.388]             function(cond) {
[16:12:51.388]                 is_error <- inherits(cond, "error")
[16:12:51.388]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.388]                   NULL)
[16:12:51.388]                 if (is_error) {
[16:12:51.388]                   sessionInformation <- function() {
[16:12:51.388]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.388]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.388]                       search = base::search(), system = base::Sys.info())
[16:12:51.388]                   }
[16:12:51.388]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.388]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.388]                     cond$call), session = sessionInformation(), 
[16:12:51.388]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.388]                   signalCondition(cond)
[16:12:51.388]                 }
[16:12:51.388]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.388]                 "immediateCondition"))) {
[16:12:51.388]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.388]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.388]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.388]                   if (TRUE && !signal) {
[16:12:51.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.388]                     {
[16:12:51.388]                       inherits <- base::inherits
[16:12:51.388]                       invokeRestart <- base::invokeRestart
[16:12:51.388]                       is.null <- base::is.null
[16:12:51.388]                       muffled <- FALSE
[16:12:51.388]                       if (inherits(cond, "message")) {
[16:12:51.388]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.388]                         if (muffled) 
[16:12:51.388]                           invokeRestart("muffleMessage")
[16:12:51.388]                       }
[16:12:51.388]                       else if (inherits(cond, "warning")) {
[16:12:51.388]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.388]                         if (muffled) 
[16:12:51.388]                           invokeRestart("muffleWarning")
[16:12:51.388]                       }
[16:12:51.388]                       else if (inherits(cond, "condition")) {
[16:12:51.388]                         if (!is.null(pattern)) {
[16:12:51.388]                           computeRestarts <- base::computeRestarts
[16:12:51.388]                           grepl <- base::grepl
[16:12:51.388]                           restarts <- computeRestarts(cond)
[16:12:51.388]                           for (restart in restarts) {
[16:12:51.388]                             name <- restart$name
[16:12:51.388]                             if (is.null(name)) 
[16:12:51.388]                               next
[16:12:51.388]                             if (!grepl(pattern, name)) 
[16:12:51.388]                               next
[16:12:51.388]                             invokeRestart(restart)
[16:12:51.388]                             muffled <- TRUE
[16:12:51.388]                             break
[16:12:51.388]                           }
[16:12:51.388]                         }
[16:12:51.388]                       }
[16:12:51.388]                       invisible(muffled)
[16:12:51.388]                     }
[16:12:51.388]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.388]                   }
[16:12:51.388]                 }
[16:12:51.388]                 else {
[16:12:51.388]                   if (TRUE) {
[16:12:51.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.388]                     {
[16:12:51.388]                       inherits <- base::inherits
[16:12:51.388]                       invokeRestart <- base::invokeRestart
[16:12:51.388]                       is.null <- base::is.null
[16:12:51.388]                       muffled <- FALSE
[16:12:51.388]                       if (inherits(cond, "message")) {
[16:12:51.388]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.388]                         if (muffled) 
[16:12:51.388]                           invokeRestart("muffleMessage")
[16:12:51.388]                       }
[16:12:51.388]                       else if (inherits(cond, "warning")) {
[16:12:51.388]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.388]                         if (muffled) 
[16:12:51.388]                           invokeRestart("muffleWarning")
[16:12:51.388]                       }
[16:12:51.388]                       else if (inherits(cond, "condition")) {
[16:12:51.388]                         if (!is.null(pattern)) {
[16:12:51.388]                           computeRestarts <- base::computeRestarts
[16:12:51.388]                           grepl <- base::grepl
[16:12:51.388]                           restarts <- computeRestarts(cond)
[16:12:51.388]                           for (restart in restarts) {
[16:12:51.388]                             name <- restart$name
[16:12:51.388]                             if (is.null(name)) 
[16:12:51.388]                               next
[16:12:51.388]                             if (!grepl(pattern, name)) 
[16:12:51.388]                               next
[16:12:51.388]                             invokeRestart(restart)
[16:12:51.388]                             muffled <- TRUE
[16:12:51.388]                             break
[16:12:51.388]                           }
[16:12:51.388]                         }
[16:12:51.388]                       }
[16:12:51.388]                       invisible(muffled)
[16:12:51.388]                     }
[16:12:51.388]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.388]                   }
[16:12:51.388]                 }
[16:12:51.388]             }
[16:12:51.388]         }))
[16:12:51.388]     }, error = function(ex) {
[16:12:51.388]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.388]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.388]                 ...future.rng), started = ...future.startTime, 
[16:12:51.388]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.388]             version = "1.8"), class = "FutureResult")
[16:12:51.388]     }, finally = {
[16:12:51.388]         if (!identical(...future.workdir, getwd())) 
[16:12:51.388]             setwd(...future.workdir)
[16:12:51.388]         {
[16:12:51.388]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.388]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.388]             }
[16:12:51.388]             base::options(...future.oldOptions)
[16:12:51.388]             if (.Platform$OS.type == "windows") {
[16:12:51.388]                 old_names <- names(...future.oldEnvVars)
[16:12:51.388]                 envs <- base::Sys.getenv()
[16:12:51.388]                 names <- names(envs)
[16:12:51.388]                 common <- intersect(names, old_names)
[16:12:51.388]                 added <- setdiff(names, old_names)
[16:12:51.388]                 removed <- setdiff(old_names, names)
[16:12:51.388]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.388]                   envs[common]]
[16:12:51.388]                 NAMES <- toupper(changed)
[16:12:51.388]                 args <- list()
[16:12:51.388]                 for (kk in seq_along(NAMES)) {
[16:12:51.388]                   name <- changed[[kk]]
[16:12:51.388]                   NAME <- NAMES[[kk]]
[16:12:51.388]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.388]                     next
[16:12:51.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.388]                 }
[16:12:51.388]                 NAMES <- toupper(added)
[16:12:51.388]                 for (kk in seq_along(NAMES)) {
[16:12:51.388]                   name <- added[[kk]]
[16:12:51.388]                   NAME <- NAMES[[kk]]
[16:12:51.388]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.388]                     next
[16:12:51.388]                   args[[name]] <- ""
[16:12:51.388]                 }
[16:12:51.388]                 NAMES <- toupper(removed)
[16:12:51.388]                 for (kk in seq_along(NAMES)) {
[16:12:51.388]                   name <- removed[[kk]]
[16:12:51.388]                   NAME <- NAMES[[kk]]
[16:12:51.388]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.388]                     next
[16:12:51.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.388]                 }
[16:12:51.388]                 if (length(args) > 0) 
[16:12:51.388]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.388]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.388]             }
[16:12:51.388]             else {
[16:12:51.388]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.388]             }
[16:12:51.388]             {
[16:12:51.388]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.388]                   0L) {
[16:12:51.388]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.388]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.388]                   base::options(opts)
[16:12:51.388]                 }
[16:12:51.388]                 {
[16:12:51.388]                   {
[16:12:51.388]                     NULL
[16:12:51.388]                     RNGkind("Mersenne-Twister")
[16:12:51.388]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.388]                       inherits = FALSE)
[16:12:51.388]                   }
[16:12:51.388]                   options(future.plan = NULL)
[16:12:51.388]                   if (is.na(NA_character_)) 
[16:12:51.388]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.388]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.388]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.388]                   {
[16:12:51.388]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.388]                     if (!future$lazy) 
[16:12:51.388]                       future <- run(future)
[16:12:51.388]                     invisible(future)
[16:12:51.388]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.388]                 }
[16:12:51.388]             }
[16:12:51.388]         }
[16:12:51.388]     })
[16:12:51.388]     if (TRUE) {
[16:12:51.388]         base::sink(type = "output", split = FALSE)
[16:12:51.388]         if (TRUE) {
[16:12:51.388]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.388]         }
[16:12:51.388]         else {
[16:12:51.388]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.388]         }
[16:12:51.388]         base::close(...future.stdout)
[16:12:51.388]         ...future.stdout <- NULL
[16:12:51.388]     }
[16:12:51.388]     ...future.result$conditions <- ...future.conditions
[16:12:51.388]     ...future.result$finished <- base::Sys.time()
[16:12:51.388]     ...future.result
[16:12:51.388] }
[16:12:51.389] plan(): Setting new future strategy stack:
[16:12:51.390] List of future strategies:
[16:12:51.390] 1. sequential:
[16:12:51.390]    - args: function (..., envir = parent.frame())
[16:12:51.390]    - tweaked: FALSE
[16:12:51.390]    - call: NULL
[16:12:51.390] plan(): nbrOfWorkers() = 1
[16:12:51.391] plan(): Setting new future strategy stack:
[16:12:51.391] List of future strategies:
[16:12:51.391] 1. sequential:
[16:12:51.391]    - args: function (..., envir = parent.frame())
[16:12:51.391]    - tweaked: FALSE
[16:12:51.391]    - call: plan(strategy)
[16:12:51.391] plan(): nbrOfWorkers() = 1
[16:12:51.391] SequentialFuture started (and completed)
[16:12:51.391] - Launch lazy future ... done
[16:12:51.391] run() for ‘SequentialFuture’ ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.392] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.392] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:51.393] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[16:12:51.393] Searching for globals ... DONE
[16:12:51.394] Resolving globals: TRUE
[16:12:51.394] Resolving any globals that are futures ...
[16:12:51.394] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[16:12:51.394] Resolving any globals that are futures ... DONE
[16:12:51.394] Resolving futures part of globals (recursively) ...
[16:12:51.394] resolve() on list ...
[16:12:51.395]  recursive: 99
[16:12:51.395]  length: 1
[16:12:51.395]  elements: ‘x’
[16:12:51.395]  length: 0 (resolved future 1)
[16:12:51.395] resolve() on list ... DONE
[16:12:51.395] - globals: [1] ‘x’
[16:12:51.395] Resolving futures part of globals (recursively) ... DONE
[16:12:51.395] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:51.396] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[16:12:51.396] - globals: [1] ‘x’
[16:12:51.396] 
[16:12:51.396] getGlobalsAndPackages() ... DONE
[16:12:51.396] run() for ‘Future’ ...
[16:12:51.396] - state: ‘created’
[16:12:51.396] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.397] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.397] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.397]   - Field: ‘label’
[16:12:51.397]   - Field: ‘local’
[16:12:51.397]   - Field: ‘owner’
[16:12:51.397]   - Field: ‘envir’
[16:12:51.397]   - Field: ‘packages’
[16:12:51.397]   - Field: ‘gc’
[16:12:51.397]   - Field: ‘conditions’
[16:12:51.397]   - Field: ‘expr’
[16:12:51.398]   - Field: ‘uuid’
[16:12:51.398]   - Field: ‘seed’
[16:12:51.398]   - Field: ‘version’
[16:12:51.398]   - Field: ‘result’
[16:12:51.398]   - Field: ‘asynchronous’
[16:12:51.398]   - Field: ‘calls’
[16:12:51.398]   - Field: ‘globals’
[16:12:51.398]   - Field: ‘stdout’
[16:12:51.398]   - Field: ‘earlySignal’
[16:12:51.398]   - Field: ‘lazy’
[16:12:51.398]   - Field: ‘state’
[16:12:51.399] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.399] - Launch lazy future ...
[16:12:51.399] Packages needed by the future expression (n = 0): <none>
[16:12:51.399] Packages needed by future strategies (n = 0): <none>
[16:12:51.399] {
[16:12:51.399]     {
[16:12:51.399]         {
[16:12:51.399]             ...future.startTime <- base::Sys.time()
[16:12:51.399]             {
[16:12:51.399]                 {
[16:12:51.399]                   {
[16:12:51.399]                     base::local({
[16:12:51.399]                       has_future <- base::requireNamespace("future", 
[16:12:51.399]                         quietly = TRUE)
[16:12:51.399]                       if (has_future) {
[16:12:51.399]                         ns <- base::getNamespace("future")
[16:12:51.399]                         version <- ns[[".package"]][["version"]]
[16:12:51.399]                         if (is.null(version)) 
[16:12:51.399]                           version <- utils::packageVersion("future")
[16:12:51.399]                       }
[16:12:51.399]                       else {
[16:12:51.399]                         version <- NULL
[16:12:51.399]                       }
[16:12:51.399]                       if (!has_future || version < "1.8.0") {
[16:12:51.399]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.399]                           "", base::R.version$version.string), 
[16:12:51.399]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:51.399]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.399]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.399]                             "release", "version")], collapse = " "), 
[16:12:51.399]                           hostname = base::Sys.info()[["nodename"]])
[16:12:51.399]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.399]                           info)
[16:12:51.399]                         info <- base::paste(info, collapse = "; ")
[16:12:51.399]                         if (!has_future) {
[16:12:51.399]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.399]                             info)
[16:12:51.399]                         }
[16:12:51.399]                         else {
[16:12:51.399]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.399]                             info, version)
[16:12:51.399]                         }
[16:12:51.399]                         base::stop(msg)
[16:12:51.399]                       }
[16:12:51.399]                     })
[16:12:51.399]                   }
[16:12:51.399]                   options(future.plan = NULL)
[16:12:51.399]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.399]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.399]                 }
[16:12:51.399]                 ...future.workdir <- getwd()
[16:12:51.399]             }
[16:12:51.399]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.399]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.399]         }
[16:12:51.399]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.399]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:51.399]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.399]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.399]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.399]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.399]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.399]             base::names(...future.oldOptions))
[16:12:51.399]     }
[16:12:51.399]     if (FALSE) {
[16:12:51.399]     }
[16:12:51.399]     else {
[16:12:51.399]         if (TRUE) {
[16:12:51.399]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.399]                 open = "w")
[16:12:51.399]         }
[16:12:51.399]         else {
[16:12:51.399]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.399]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.399]         }
[16:12:51.399]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.399]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.399]             base::sink(type = "output", split = FALSE)
[16:12:51.399]             base::close(...future.stdout)
[16:12:51.399]         }, add = TRUE)
[16:12:51.399]     }
[16:12:51.399]     ...future.frame <- base::sys.nframe()
[16:12:51.399]     ...future.conditions <- base::list()
[16:12:51.399]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.399]     if (FALSE) {
[16:12:51.399]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.399]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.399]     }
[16:12:51.399]     ...future.result <- base::tryCatch({
[16:12:51.399]         base::withCallingHandlers({
[16:12:51.399]             ...future.value <- base::withVisible(base::local({
[16:12:51.399]                 x <- x + 1
[16:12:51.399]                 x
[16:12:51.399]             }))
[16:12:51.399]             future::FutureResult(value = ...future.value$value, 
[16:12:51.399]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.399]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.399]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.399]                     ...future.globalenv.names))
[16:12:51.399]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.399]         }, condition = base::local({
[16:12:51.399]             c <- base::c
[16:12:51.399]             inherits <- base::inherits
[16:12:51.399]             invokeRestart <- base::invokeRestart
[16:12:51.399]             length <- base::length
[16:12:51.399]             list <- base::list
[16:12:51.399]             seq.int <- base::seq.int
[16:12:51.399]             signalCondition <- base::signalCondition
[16:12:51.399]             sys.calls <- base::sys.calls
[16:12:51.399]             `[[` <- base::`[[`
[16:12:51.399]             `+` <- base::`+`
[16:12:51.399]             `<<-` <- base::`<<-`
[16:12:51.399]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.399]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.399]                   3L)]
[16:12:51.399]             }
[16:12:51.399]             function(cond) {
[16:12:51.399]                 is_error <- inherits(cond, "error")
[16:12:51.399]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.399]                   NULL)
[16:12:51.399]                 if (is_error) {
[16:12:51.399]                   sessionInformation <- function() {
[16:12:51.399]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.399]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.399]                       search = base::search(), system = base::Sys.info())
[16:12:51.399]                   }
[16:12:51.399]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.399]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.399]                     cond$call), session = sessionInformation(), 
[16:12:51.399]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.399]                   signalCondition(cond)
[16:12:51.399]                 }
[16:12:51.399]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.399]                 "immediateCondition"))) {
[16:12:51.399]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.399]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.399]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.399]                   if (TRUE && !signal) {
[16:12:51.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.399]                     {
[16:12:51.399]                       inherits <- base::inherits
[16:12:51.399]                       invokeRestart <- base::invokeRestart
[16:12:51.399]                       is.null <- base::is.null
[16:12:51.399]                       muffled <- FALSE
[16:12:51.399]                       if (inherits(cond, "message")) {
[16:12:51.399]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.399]                         if (muffled) 
[16:12:51.399]                           invokeRestart("muffleMessage")
[16:12:51.399]                       }
[16:12:51.399]                       else if (inherits(cond, "warning")) {
[16:12:51.399]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.399]                         if (muffled) 
[16:12:51.399]                           invokeRestart("muffleWarning")
[16:12:51.399]                       }
[16:12:51.399]                       else if (inherits(cond, "condition")) {
[16:12:51.399]                         if (!is.null(pattern)) {
[16:12:51.399]                           computeRestarts <- base::computeRestarts
[16:12:51.399]                           grepl <- base::grepl
[16:12:51.399]                           restarts <- computeRestarts(cond)
[16:12:51.399]                           for (restart in restarts) {
[16:12:51.399]                             name <- restart$name
[16:12:51.399]                             if (is.null(name)) 
[16:12:51.399]                               next
[16:12:51.399]                             if (!grepl(pattern, name)) 
[16:12:51.399]                               next
[16:12:51.399]                             invokeRestart(restart)
[16:12:51.399]                             muffled <- TRUE
[16:12:51.399]                             break
[16:12:51.399]                           }
[16:12:51.399]                         }
[16:12:51.399]                       }
[16:12:51.399]                       invisible(muffled)
[16:12:51.399]                     }
[16:12:51.399]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.399]                   }
[16:12:51.399]                 }
[16:12:51.399]                 else {
[16:12:51.399]                   if (TRUE) {
[16:12:51.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.399]                     {
[16:12:51.399]                       inherits <- base::inherits
[16:12:51.399]                       invokeRestart <- base::invokeRestart
[16:12:51.399]                       is.null <- base::is.null
[16:12:51.399]                       muffled <- FALSE
[16:12:51.399]                       if (inherits(cond, "message")) {
[16:12:51.399]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.399]                         if (muffled) 
[16:12:51.399]                           invokeRestart("muffleMessage")
[16:12:51.399]                       }
[16:12:51.399]                       else if (inherits(cond, "warning")) {
[16:12:51.399]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.399]                         if (muffled) 
[16:12:51.399]                           invokeRestart("muffleWarning")
[16:12:51.399]                       }
[16:12:51.399]                       else if (inherits(cond, "condition")) {
[16:12:51.399]                         if (!is.null(pattern)) {
[16:12:51.399]                           computeRestarts <- base::computeRestarts
[16:12:51.399]                           grepl <- base::grepl
[16:12:51.399]                           restarts <- computeRestarts(cond)
[16:12:51.399]                           for (restart in restarts) {
[16:12:51.399]                             name <- restart$name
[16:12:51.399]                             if (is.null(name)) 
[16:12:51.399]                               next
[16:12:51.399]                             if (!grepl(pattern, name)) 
[16:12:51.399]                               next
[16:12:51.399]                             invokeRestart(restart)
[16:12:51.399]                             muffled <- TRUE
[16:12:51.399]                             break
[16:12:51.399]                           }
[16:12:51.399]                         }
[16:12:51.399]                       }
[16:12:51.399]                       invisible(muffled)
[16:12:51.399]                     }
[16:12:51.399]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.399]                   }
[16:12:51.399]                 }
[16:12:51.399]             }
[16:12:51.399]         }))
[16:12:51.399]     }, error = function(ex) {
[16:12:51.399]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.399]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.399]                 ...future.rng), started = ...future.startTime, 
[16:12:51.399]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.399]             version = "1.8"), class = "FutureResult")
[16:12:51.399]     }, finally = {
[16:12:51.399]         if (!identical(...future.workdir, getwd())) 
[16:12:51.399]             setwd(...future.workdir)
[16:12:51.399]         {
[16:12:51.399]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.399]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.399]             }
[16:12:51.399]             base::options(...future.oldOptions)
[16:12:51.399]             if (.Platform$OS.type == "windows") {
[16:12:51.399]                 old_names <- names(...future.oldEnvVars)
[16:12:51.399]                 envs <- base::Sys.getenv()
[16:12:51.399]                 names <- names(envs)
[16:12:51.399]                 common <- intersect(names, old_names)
[16:12:51.399]                 added <- setdiff(names, old_names)
[16:12:51.399]                 removed <- setdiff(old_names, names)
[16:12:51.399]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.399]                   envs[common]]
[16:12:51.399]                 NAMES <- toupper(changed)
[16:12:51.399]                 args <- list()
[16:12:51.399]                 for (kk in seq_along(NAMES)) {
[16:12:51.399]                   name <- changed[[kk]]
[16:12:51.399]                   NAME <- NAMES[[kk]]
[16:12:51.399]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.399]                     next
[16:12:51.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.399]                 }
[16:12:51.399]                 NAMES <- toupper(added)
[16:12:51.399]                 for (kk in seq_along(NAMES)) {
[16:12:51.399]                   name <- added[[kk]]
[16:12:51.399]                   NAME <- NAMES[[kk]]
[16:12:51.399]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.399]                     next
[16:12:51.399]                   args[[name]] <- ""
[16:12:51.399]                 }
[16:12:51.399]                 NAMES <- toupper(removed)
[16:12:51.399]                 for (kk in seq_along(NAMES)) {
[16:12:51.399]                   name <- removed[[kk]]
[16:12:51.399]                   NAME <- NAMES[[kk]]
[16:12:51.399]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.399]                     next
[16:12:51.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.399]                 }
[16:12:51.399]                 if (length(args) > 0) 
[16:12:51.399]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.399]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.399]             }
[16:12:51.399]             else {
[16:12:51.399]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.399]             }
[16:12:51.399]             {
[16:12:51.399]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.399]                   0L) {
[16:12:51.399]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.399]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.399]                   base::options(opts)
[16:12:51.399]                 }
[16:12:51.399]                 {
[16:12:51.399]                   {
[16:12:51.399]                     NULL
[16:12:51.399]                     RNGkind("Mersenne-Twister")
[16:12:51.399]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.399]                       inherits = FALSE)
[16:12:51.399]                   }
[16:12:51.399]                   options(future.plan = NULL)
[16:12:51.399]                   if (is.na(NA_character_)) 
[16:12:51.399]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.399]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.399]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.399]                   {
[16:12:51.399]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.399]                     if (!future$lazy) 
[16:12:51.399]                       future <- run(future)
[16:12:51.399]                     invisible(future)
[16:12:51.399]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.399]                 }
[16:12:51.399]             }
[16:12:51.399]         }
[16:12:51.399]     })
[16:12:51.399]     if (TRUE) {
[16:12:51.399]         base::sink(type = "output", split = FALSE)
[16:12:51.399]         if (TRUE) {
[16:12:51.399]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.399]         }
[16:12:51.399]         else {
[16:12:51.399]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.399]         }
[16:12:51.399]         base::close(...future.stdout)
[16:12:51.399]         ...future.stdout <- NULL
[16:12:51.399]     }
[16:12:51.399]     ...future.result$conditions <- ...future.conditions
[16:12:51.399]     ...future.result$finished <- base::Sys.time()
[16:12:51.399]     ...future.result
[16:12:51.399] }
[16:12:51.401] assign_globals() ...
[16:12:51.403] List of 1
[16:12:51.403]  $ x: num 1
[16:12:51.403]  - attr(*, "where")=List of 1
[16:12:51.403]   ..$ x:<environment: R_EmptyEnv> 
[16:12:51.403]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.403]  - attr(*, "resolved")= logi TRUE
[16:12:51.403]  - attr(*, "total_size")= num 56
[16:12:51.403]  - attr(*, "already-done")= logi TRUE
[16:12:51.405] - copied ‘x’ to environment
[16:12:51.405] assign_globals() ... done
[16:12:51.406] plan(): Setting new future strategy stack:
[16:12:51.406] List of future strategies:
[16:12:51.406] 1. sequential:
[16:12:51.406]    - args: function (..., envir = parent.frame())
[16:12:51.406]    - tweaked: FALSE
[16:12:51.406]    - call: NULL
[16:12:51.406] plan(): nbrOfWorkers() = 1
[16:12:51.407] plan(): Setting new future strategy stack:
[16:12:51.407] List of future strategies:
[16:12:51.407] 1. sequential:
[16:12:51.407]    - args: function (..., envir = parent.frame())
[16:12:51.407]    - tweaked: FALSE
[16:12:51.407]    - call: plan(strategy)
[16:12:51.407] plan(): nbrOfWorkers() = 1
[16:12:51.407] SequentialFuture started (and completed)
[16:12:51.408] - Launch lazy future ... done
[16:12:51.408] run() for ‘SequentialFuture’ ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.408] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.408] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:51.410] - globals found: [3] ‘{’, ‘<-’, ‘x’
[16:12:51.410] Searching for globals ... DONE
[16:12:51.411] Resolving globals: TRUE
[16:12:51.411] Resolving any globals that are futures ...
[16:12:51.411] - globals: [3] ‘{’, ‘<-’, ‘x’
[16:12:51.411] Resolving any globals that are futures ... DONE
[16:12:51.411] Resolving futures part of globals (recursively) ...
[16:12:51.411] resolve() on list ...
[16:12:51.412]  recursive: 99
[16:12:51.412]  length: 1
[16:12:51.412]  elements: ‘x’
[16:12:51.412]  length: 0 (resolved future 1)
[16:12:51.412] resolve() on list ... DONE
[16:12:51.412] - globals: [1] ‘x’
[16:12:51.412] Resolving futures part of globals (recursively) ... DONE
[16:12:51.412] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[16:12:51.413] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[16:12:51.413] - globals: [1] ‘x’
[16:12:51.413] 
[16:12:51.413] getGlobalsAndPackages() ... DONE
[16:12:51.413] run() for ‘Future’ ...
[16:12:51.413] - state: ‘created’
[16:12:51.414] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:51.414] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:51.414] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:51.414]   - Field: ‘label’
[16:12:51.414]   - Field: ‘local’
[16:12:51.414]   - Field: ‘owner’
[16:12:51.414]   - Field: ‘envir’
[16:12:51.414]   - Field: ‘packages’
[16:12:51.415]   - Field: ‘gc’
[16:12:51.415]   - Field: ‘conditions’
[16:12:51.415]   - Field: ‘expr’
[16:12:51.415]   - Field: ‘uuid’
[16:12:51.415]   - Field: ‘seed’
[16:12:51.415]   - Field: ‘version’
[16:12:51.415]   - Field: ‘result’
[16:12:51.415]   - Field: ‘asynchronous’
[16:12:51.415]   - Field: ‘calls’
[16:12:51.415]   - Field: ‘globals’
[16:12:51.415]   - Field: ‘stdout’
[16:12:51.416]   - Field: ‘earlySignal’
[16:12:51.416]   - Field: ‘lazy’
[16:12:51.416]   - Field: ‘state’
[16:12:51.416] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:51.416] - Launch lazy future ...
[16:12:51.416] Packages needed by the future expression (n = 0): <none>
[16:12:51.416] Packages needed by future strategies (n = 0): <none>
[16:12:51.417] {
[16:12:51.417]     {
[16:12:51.417]         {
[16:12:51.417]             ...future.startTime <- base::Sys.time()
[16:12:51.417]             {
[16:12:51.417]                 {
[16:12:51.417]                   {
[16:12:51.417]                     base::local({
[16:12:51.417]                       has_future <- base::requireNamespace("future", 
[16:12:51.417]                         quietly = TRUE)
[16:12:51.417]                       if (has_future) {
[16:12:51.417]                         ns <- base::getNamespace("future")
[16:12:51.417]                         version <- ns[[".package"]][["version"]]
[16:12:51.417]                         if (is.null(version)) 
[16:12:51.417]                           version <- utils::packageVersion("future")
[16:12:51.417]                       }
[16:12:51.417]                       else {
[16:12:51.417]                         version <- NULL
[16:12:51.417]                       }
[16:12:51.417]                       if (!has_future || version < "1.8.0") {
[16:12:51.417]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.417]                           "", base::R.version$version.string), 
[16:12:51.417]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:51.417]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.417]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.417]                             "release", "version")], collapse = " "), 
[16:12:51.417]                           hostname = base::Sys.info()[["nodename"]])
[16:12:51.417]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.417]                           info)
[16:12:51.417]                         info <- base::paste(info, collapse = "; ")
[16:12:51.417]                         if (!has_future) {
[16:12:51.417]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.417]                             info)
[16:12:51.417]                         }
[16:12:51.417]                         else {
[16:12:51.417]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.417]                             info, version)
[16:12:51.417]                         }
[16:12:51.417]                         base::stop(msg)
[16:12:51.417]                       }
[16:12:51.417]                     })
[16:12:51.417]                   }
[16:12:51.417]                   options(future.plan = NULL)
[16:12:51.417]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.417]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.417]                 }
[16:12:51.417]                 ...future.workdir <- getwd()
[16:12:51.417]             }
[16:12:51.417]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.417]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.417]         }
[16:12:51.417]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.417]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:51.417]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.417]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.417]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.417]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.417]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.417]             base::names(...future.oldOptions))
[16:12:51.417]     }
[16:12:51.417]     if (FALSE) {
[16:12:51.417]     }
[16:12:51.417]     else {
[16:12:51.417]         if (TRUE) {
[16:12:51.417]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.417]                 open = "w")
[16:12:51.417]         }
[16:12:51.417]         else {
[16:12:51.417]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.417]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.417]         }
[16:12:51.417]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.417]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.417]             base::sink(type = "output", split = FALSE)
[16:12:51.417]             base::close(...future.stdout)
[16:12:51.417]         }, add = TRUE)
[16:12:51.417]     }
[16:12:51.417]     ...future.frame <- base::sys.nframe()
[16:12:51.417]     ...future.conditions <- base::list()
[16:12:51.417]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.417]     if (FALSE) {
[16:12:51.417]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.417]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.417]     }
[16:12:51.417]     ...future.result <- base::tryCatch({
[16:12:51.417]         base::withCallingHandlers({
[16:12:51.417]             ...future.value <- base::withVisible(base::local({
[16:12:51.417]                 x <- x()
[16:12:51.417]                 x
[16:12:51.417]             }))
[16:12:51.417]             future::FutureResult(value = ...future.value$value, 
[16:12:51.417]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.417]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.417]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.417]                     ...future.globalenv.names))
[16:12:51.417]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.417]         }, condition = base::local({
[16:12:51.417]             c <- base::c
[16:12:51.417]             inherits <- base::inherits
[16:12:51.417]             invokeRestart <- base::invokeRestart
[16:12:51.417]             length <- base::length
[16:12:51.417]             list <- base::list
[16:12:51.417]             seq.int <- base::seq.int
[16:12:51.417]             signalCondition <- base::signalCondition
[16:12:51.417]             sys.calls <- base::sys.calls
[16:12:51.417]             `[[` <- base::`[[`
[16:12:51.417]             `+` <- base::`+`
[16:12:51.417]             `<<-` <- base::`<<-`
[16:12:51.417]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.417]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.417]                   3L)]
[16:12:51.417]             }
[16:12:51.417]             function(cond) {
[16:12:51.417]                 is_error <- inherits(cond, "error")
[16:12:51.417]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.417]                   NULL)
[16:12:51.417]                 if (is_error) {
[16:12:51.417]                   sessionInformation <- function() {
[16:12:51.417]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.417]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.417]                       search = base::search(), system = base::Sys.info())
[16:12:51.417]                   }
[16:12:51.417]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.417]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.417]                     cond$call), session = sessionInformation(), 
[16:12:51.417]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.417]                   signalCondition(cond)
[16:12:51.417]                 }
[16:12:51.417]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.417]                 "immediateCondition"))) {
[16:12:51.417]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.417]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.417]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.417]                   if (TRUE && !signal) {
[16:12:51.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.417]                     {
[16:12:51.417]                       inherits <- base::inherits
[16:12:51.417]                       invokeRestart <- base::invokeRestart
[16:12:51.417]                       is.null <- base::is.null
[16:12:51.417]                       muffled <- FALSE
[16:12:51.417]                       if (inherits(cond, "message")) {
[16:12:51.417]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.417]                         if (muffled) 
[16:12:51.417]                           invokeRestart("muffleMessage")
[16:12:51.417]                       }
[16:12:51.417]                       else if (inherits(cond, "warning")) {
[16:12:51.417]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.417]                         if (muffled) 
[16:12:51.417]                           invokeRestart("muffleWarning")
[16:12:51.417]                       }
[16:12:51.417]                       else if (inherits(cond, "condition")) {
[16:12:51.417]                         if (!is.null(pattern)) {
[16:12:51.417]                           computeRestarts <- base::computeRestarts
[16:12:51.417]                           grepl <- base::grepl
[16:12:51.417]                           restarts <- computeRestarts(cond)
[16:12:51.417]                           for (restart in restarts) {
[16:12:51.417]                             name <- restart$name
[16:12:51.417]                             if (is.null(name)) 
[16:12:51.417]                               next
[16:12:51.417]                             if (!grepl(pattern, name)) 
[16:12:51.417]                               next
[16:12:51.417]                             invokeRestart(restart)
[16:12:51.417]                             muffled <- TRUE
[16:12:51.417]                             break
[16:12:51.417]                           }
[16:12:51.417]                         }
[16:12:51.417]                       }
[16:12:51.417]                       invisible(muffled)
[16:12:51.417]                     }
[16:12:51.417]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.417]                   }
[16:12:51.417]                 }
[16:12:51.417]                 else {
[16:12:51.417]                   if (TRUE) {
[16:12:51.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.417]                     {
[16:12:51.417]                       inherits <- base::inherits
[16:12:51.417]                       invokeRestart <- base::invokeRestart
[16:12:51.417]                       is.null <- base::is.null
[16:12:51.417]                       muffled <- FALSE
[16:12:51.417]                       if (inherits(cond, "message")) {
[16:12:51.417]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.417]                         if (muffled) 
[16:12:51.417]                           invokeRestart("muffleMessage")
[16:12:51.417]                       }
[16:12:51.417]                       else if (inherits(cond, "warning")) {
[16:12:51.417]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.417]                         if (muffled) 
[16:12:51.417]                           invokeRestart("muffleWarning")
[16:12:51.417]                       }
[16:12:51.417]                       else if (inherits(cond, "condition")) {
[16:12:51.417]                         if (!is.null(pattern)) {
[16:12:51.417]                           computeRestarts <- base::computeRestarts
[16:12:51.417]                           grepl <- base::grepl
[16:12:51.417]                           restarts <- computeRestarts(cond)
[16:12:51.417]                           for (restart in restarts) {
[16:12:51.417]                             name <- restart$name
[16:12:51.417]                             if (is.null(name)) 
[16:12:51.417]                               next
[16:12:51.417]                             if (!grepl(pattern, name)) 
[16:12:51.417]                               next
[16:12:51.417]                             invokeRestart(restart)
[16:12:51.417]                             muffled <- TRUE
[16:12:51.417]                             break
[16:12:51.417]                           }
[16:12:51.417]                         }
[16:12:51.417]                       }
[16:12:51.417]                       invisible(muffled)
[16:12:51.417]                     }
[16:12:51.417]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.417]                   }
[16:12:51.417]                 }
[16:12:51.417]             }
[16:12:51.417]         }))
[16:12:51.417]     }, error = function(ex) {
[16:12:51.417]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.417]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.417]                 ...future.rng), started = ...future.startTime, 
[16:12:51.417]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.417]             version = "1.8"), class = "FutureResult")
[16:12:51.417]     }, finally = {
[16:12:51.417]         if (!identical(...future.workdir, getwd())) 
[16:12:51.417]             setwd(...future.workdir)
[16:12:51.417]         {
[16:12:51.417]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.417]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.417]             }
[16:12:51.417]             base::options(...future.oldOptions)
[16:12:51.417]             if (.Platform$OS.type == "windows") {
[16:12:51.417]                 old_names <- names(...future.oldEnvVars)
[16:12:51.417]                 envs <- base::Sys.getenv()
[16:12:51.417]                 names <- names(envs)
[16:12:51.417]                 common <- intersect(names, old_names)
[16:12:51.417]                 added <- setdiff(names, old_names)
[16:12:51.417]                 removed <- setdiff(old_names, names)
[16:12:51.417]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.417]                   envs[common]]
[16:12:51.417]                 NAMES <- toupper(changed)
[16:12:51.417]                 args <- list()
[16:12:51.417]                 for (kk in seq_along(NAMES)) {
[16:12:51.417]                   name <- changed[[kk]]
[16:12:51.417]                   NAME <- NAMES[[kk]]
[16:12:51.417]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.417]                     next
[16:12:51.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.417]                 }
[16:12:51.417]                 NAMES <- toupper(added)
[16:12:51.417]                 for (kk in seq_along(NAMES)) {
[16:12:51.417]                   name <- added[[kk]]
[16:12:51.417]                   NAME <- NAMES[[kk]]
[16:12:51.417]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.417]                     next
[16:12:51.417]                   args[[name]] <- ""
[16:12:51.417]                 }
[16:12:51.417]                 NAMES <- toupper(removed)
[16:12:51.417]                 for (kk in seq_along(NAMES)) {
[16:12:51.417]                   name <- removed[[kk]]
[16:12:51.417]                   NAME <- NAMES[[kk]]
[16:12:51.417]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.417]                     next
[16:12:51.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.417]                 }
[16:12:51.417]                 if (length(args) > 0) 
[16:12:51.417]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.417]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.417]             }
[16:12:51.417]             else {
[16:12:51.417]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.417]             }
[16:12:51.417]             {
[16:12:51.417]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.417]                   0L) {
[16:12:51.417]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.417]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.417]                   base::options(opts)
[16:12:51.417]                 }
[16:12:51.417]                 {
[16:12:51.417]                   {
[16:12:51.417]                     NULL
[16:12:51.417]                     RNGkind("Mersenne-Twister")
[16:12:51.417]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:51.417]                       inherits = FALSE)
[16:12:51.417]                   }
[16:12:51.417]                   options(future.plan = NULL)
[16:12:51.417]                   if (is.na(NA_character_)) 
[16:12:51.417]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.417]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.417]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:51.417]                   {
[16:12:51.417]                     future <- SequentialFuture(..., envir = envir)
[16:12:51.417]                     if (!future$lazy) 
[16:12:51.417]                       future <- run(future)
[16:12:51.417]                     invisible(future)
[16:12:51.417]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.417]                 }
[16:12:51.417]             }
[16:12:51.417]         }
[16:12:51.417]     })
[16:12:51.417]     if (TRUE) {
[16:12:51.417]         base::sink(type = "output", split = FALSE)
[16:12:51.417]         if (TRUE) {
[16:12:51.417]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.417]         }
[16:12:51.417]         else {
[16:12:51.417]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.417]         }
[16:12:51.417]         base::close(...future.stdout)
[16:12:51.417]         ...future.stdout <- NULL
[16:12:51.417]     }
[16:12:51.417]     ...future.result$conditions <- ...future.conditions
[16:12:51.417]     ...future.result$finished <- base::Sys.time()
[16:12:51.417]     ...future.result
[16:12:51.417] }
[16:12:51.419] assign_globals() ...
[16:12:51.419] List of 1
[16:12:51.419]  $ x:function ()  
[16:12:51.419]  - attr(*, "where")=List of 1
[16:12:51.419]   ..$ x:<environment: R_EmptyEnv> 
[16:12:51.419]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.419]  - attr(*, "resolved")= logi TRUE
[16:12:51.419]  - attr(*, "total_size")= num 1032
[16:12:51.419]  - attr(*, "already-done")= logi TRUE
[16:12:51.421] - reassign environment for ‘x’
[16:12:51.421] - copied ‘x’ to environment
[16:12:51.421] assign_globals() ... done
[16:12:51.422] plan(): Setting new future strategy stack:
[16:12:51.422] List of future strategies:
[16:12:51.422] 1. sequential:
[16:12:51.422]    - args: function (..., envir = parent.frame())
[16:12:51.422]    - tweaked: FALSE
[16:12:51.422]    - call: NULL
[16:12:51.422] plan(): nbrOfWorkers() = 1
[16:12:51.423] plan(): Setting new future strategy stack:
[16:12:51.423] List of future strategies:
[16:12:51.423] 1. sequential:
[16:12:51.423]    - args: function (..., envir = parent.frame())
[16:12:51.423]    - tweaked: FALSE
[16:12:51.423]    - call: plan(strategy)
[16:12:51.424] plan(): nbrOfWorkers() = 1
[16:12:51.424] SequentialFuture started (and completed)
[16:12:51.424] - Launch lazy future ... done
[16:12:51.424] run() for ‘SequentialFuture’ ... done
value(f) = ‘TRUE’
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- Local variables with the same name as globals ...
- plan('multicore') ...
[16:12:51.437] plan(): Setting new future strategy stack:
[16:12:51.437] List of future strategies:
[16:12:51.437] 1. multicore:
[16:12:51.437]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:51.437]    - tweaked: FALSE
[16:12:51.437]    - call: plan(strategy)
[16:12:51.441] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.441] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.442] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.443] - globals found: [3] ‘{’, ‘<-’, ‘*’
[16:12:51.443] Searching for globals ... DONE
[16:12:51.443] Resolving globals: TRUE
[16:12:51.443] Resolving any globals that are futures ...
[16:12:51.443] - globals: [3] ‘{’, ‘<-’, ‘*’
[16:12:51.444] Resolving any globals that are futures ... DONE
[16:12:51.444] 
[16:12:51.444] 
[16:12:51.444] getGlobalsAndPackages() ... DONE
[16:12:51.444] run() for ‘Future’ ...
[16:12:51.445] - state: ‘created’
[16:12:51.445] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:51.448] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:51.448] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:51.448]   - Field: ‘label’
[16:12:51.448]   - Field: ‘local’
[16:12:51.449]   - Field: ‘owner’
[16:12:51.449]   - Field: ‘envir’
[16:12:51.449]   - Field: ‘workers’
[16:12:51.449]   - Field: ‘packages’
[16:12:51.449]   - Field: ‘gc’
[16:12:51.449]   - Field: ‘job’
[16:12:51.449]   - Field: ‘conditions’
[16:12:51.449]   - Field: ‘expr’
[16:12:51.449]   - Field: ‘uuid’
[16:12:51.449]   - Field: ‘seed’
[16:12:51.449]   - Field: ‘version’
[16:12:51.450]   - Field: ‘result’
[16:12:51.450]   - Field: ‘asynchronous’
[16:12:51.450]   - Field: ‘calls’
[16:12:51.450]   - Field: ‘globals’
[16:12:51.450]   - Field: ‘stdout’
[16:12:51.450]   - Field: ‘earlySignal’
[16:12:51.450]   - Field: ‘lazy’
[16:12:51.450]   - Field: ‘state’
[16:12:51.450] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:51.450] - Launch lazy future ...
[16:12:51.451] Packages needed by the future expression (n = 0): <none>
[16:12:51.452] Packages needed by future strategies (n = 0): <none>
[16:12:51.452] {
[16:12:51.452]     {
[16:12:51.452]         {
[16:12:51.452]             ...future.startTime <- base::Sys.time()
[16:12:51.452]             {
[16:12:51.452]                 {
[16:12:51.452]                   {
[16:12:51.452]                     {
[16:12:51.452]                       base::local({
[16:12:51.452]                         has_future <- base::requireNamespace("future", 
[16:12:51.452]                           quietly = TRUE)
[16:12:51.452]                         if (has_future) {
[16:12:51.452]                           ns <- base::getNamespace("future")
[16:12:51.452]                           version <- ns[[".package"]][["version"]]
[16:12:51.452]                           if (is.null(version)) 
[16:12:51.452]                             version <- utils::packageVersion("future")
[16:12:51.452]                         }
[16:12:51.452]                         else {
[16:12:51.452]                           version <- NULL
[16:12:51.452]                         }
[16:12:51.452]                         if (!has_future || version < "1.8.0") {
[16:12:51.452]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.452]                             "", base::R.version$version.string), 
[16:12:51.452]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:51.452]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.452]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.452]                               "release", "version")], collapse = " "), 
[16:12:51.452]                             hostname = base::Sys.info()[["nodename"]])
[16:12:51.452]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.452]                             info)
[16:12:51.452]                           info <- base::paste(info, collapse = "; ")
[16:12:51.452]                           if (!has_future) {
[16:12:51.452]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.452]                               info)
[16:12:51.452]                           }
[16:12:51.452]                           else {
[16:12:51.452]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.452]                               info, version)
[16:12:51.452]                           }
[16:12:51.452]                           base::stop(msg)
[16:12:51.452]                         }
[16:12:51.452]                       })
[16:12:51.452]                     }
[16:12:51.452]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:51.452]                     base::options(mc.cores = 1L)
[16:12:51.452]                   }
[16:12:51.452]                   options(future.plan = NULL)
[16:12:51.452]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.452]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.452]                 }
[16:12:51.452]                 ...future.workdir <- getwd()
[16:12:51.452]             }
[16:12:51.452]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.452]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.452]         }
[16:12:51.452]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.452]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:51.452]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.452]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.452]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.452]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.452]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.452]             base::names(...future.oldOptions))
[16:12:51.452]     }
[16:12:51.452]     if (FALSE) {
[16:12:51.452]     }
[16:12:51.452]     else {
[16:12:51.452]         if (TRUE) {
[16:12:51.452]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.452]                 open = "w")
[16:12:51.452]         }
[16:12:51.452]         else {
[16:12:51.452]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.452]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.452]         }
[16:12:51.452]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.452]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.452]             base::sink(type = "output", split = FALSE)
[16:12:51.452]             base::close(...future.stdout)
[16:12:51.452]         }, add = TRUE)
[16:12:51.452]     }
[16:12:51.452]     ...future.frame <- base::sys.nframe()
[16:12:51.452]     ...future.conditions <- base::list()
[16:12:51.452]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.452]     if (FALSE) {
[16:12:51.452]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.452]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.452]     }
[16:12:51.452]     ...future.result <- base::tryCatch({
[16:12:51.452]         base::withCallingHandlers({
[16:12:51.452]             ...future.value <- base::withVisible(base::local({
[16:12:51.452]                 withCallingHandlers({
[16:12:51.452]                   {
[16:12:51.452]                     b <- a
[16:12:51.452]                     a <- 2
[16:12:51.452]                     a * b
[16:12:51.452]                   }
[16:12:51.452]                 }, immediateCondition = function(cond) {
[16:12:51.452]                   save_rds <- function (object, pathname, ...) 
[16:12:51.452]                   {
[16:12:51.452]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:51.452]                     if (file_test("-f", pathname_tmp)) {
[16:12:51.452]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.452]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:51.452]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.452]                         fi_tmp[["mtime"]])
[16:12:51.452]                     }
[16:12:51.452]                     tryCatch({
[16:12:51.452]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:51.452]                     }, error = function(ex) {
[16:12:51.452]                       msg <- conditionMessage(ex)
[16:12:51.452]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.452]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:51.452]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.452]                         fi_tmp[["mtime"]], msg)
[16:12:51.452]                       ex$message <- msg
[16:12:51.452]                       stop(ex)
[16:12:51.452]                     })
[16:12:51.452]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:51.452]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:51.452]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:51.452]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.452]                       fi <- file.info(pathname)
[16:12:51.452]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:51.452]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.452]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:51.452]                         fi[["size"]], fi[["mtime"]])
[16:12:51.452]                       stop(msg)
[16:12:51.452]                     }
[16:12:51.452]                     invisible(pathname)
[16:12:51.452]                   }
[16:12:51.452]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:51.452]                     rootPath = tempdir()) 
[16:12:51.452]                   {
[16:12:51.452]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:51.452]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:51.452]                       tmpdir = path, fileext = ".rds")
[16:12:51.452]                     save_rds(obj, file)
[16:12:51.452]                   }
[16:12:51.452]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:51.452]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.452]                   {
[16:12:51.452]                     inherits <- base::inherits
[16:12:51.452]                     invokeRestart <- base::invokeRestart
[16:12:51.452]                     is.null <- base::is.null
[16:12:51.452]                     muffled <- FALSE
[16:12:51.452]                     if (inherits(cond, "message")) {
[16:12:51.452]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:51.452]                       if (muffled) 
[16:12:51.452]                         invokeRestart("muffleMessage")
[16:12:51.452]                     }
[16:12:51.452]                     else if (inherits(cond, "warning")) {
[16:12:51.452]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:51.452]                       if (muffled) 
[16:12:51.452]                         invokeRestart("muffleWarning")
[16:12:51.452]                     }
[16:12:51.452]                     else if (inherits(cond, "condition")) {
[16:12:51.452]                       if (!is.null(pattern)) {
[16:12:51.452]                         computeRestarts <- base::computeRestarts
[16:12:51.452]                         grepl <- base::grepl
[16:12:51.452]                         restarts <- computeRestarts(cond)
[16:12:51.452]                         for (restart in restarts) {
[16:12:51.452]                           name <- restart$name
[16:12:51.452]                           if (is.null(name)) 
[16:12:51.452]                             next
[16:12:51.452]                           if (!grepl(pattern, name)) 
[16:12:51.452]                             next
[16:12:51.452]                           invokeRestart(restart)
[16:12:51.452]                           muffled <- TRUE
[16:12:51.452]                           break
[16:12:51.452]                         }
[16:12:51.452]                       }
[16:12:51.452]                     }
[16:12:51.452]                     invisible(muffled)
[16:12:51.452]                   }
[16:12:51.452]                   muffleCondition(cond)
[16:12:51.452]                 })
[16:12:51.452]             }))
[16:12:51.452]             future::FutureResult(value = ...future.value$value, 
[16:12:51.452]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.452]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.452]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.452]                     ...future.globalenv.names))
[16:12:51.452]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.452]         }, condition = base::local({
[16:12:51.452]             c <- base::c
[16:12:51.452]             inherits <- base::inherits
[16:12:51.452]             invokeRestart <- base::invokeRestart
[16:12:51.452]             length <- base::length
[16:12:51.452]             list <- base::list
[16:12:51.452]             seq.int <- base::seq.int
[16:12:51.452]             signalCondition <- base::signalCondition
[16:12:51.452]             sys.calls <- base::sys.calls
[16:12:51.452]             `[[` <- base::`[[`
[16:12:51.452]             `+` <- base::`+`
[16:12:51.452]             `<<-` <- base::`<<-`
[16:12:51.452]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.452]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.452]                   3L)]
[16:12:51.452]             }
[16:12:51.452]             function(cond) {
[16:12:51.452]                 is_error <- inherits(cond, "error")
[16:12:51.452]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.452]                   NULL)
[16:12:51.452]                 if (is_error) {
[16:12:51.452]                   sessionInformation <- function() {
[16:12:51.452]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.452]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.452]                       search = base::search(), system = base::Sys.info())
[16:12:51.452]                   }
[16:12:51.452]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.452]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.452]                     cond$call), session = sessionInformation(), 
[16:12:51.452]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.452]                   signalCondition(cond)
[16:12:51.452]                 }
[16:12:51.452]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.452]                 "immediateCondition"))) {
[16:12:51.452]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.452]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.452]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.452]                   if (TRUE && !signal) {
[16:12:51.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.452]                     {
[16:12:51.452]                       inherits <- base::inherits
[16:12:51.452]                       invokeRestart <- base::invokeRestart
[16:12:51.452]                       is.null <- base::is.null
[16:12:51.452]                       muffled <- FALSE
[16:12:51.452]                       if (inherits(cond, "message")) {
[16:12:51.452]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.452]                         if (muffled) 
[16:12:51.452]                           invokeRestart("muffleMessage")
[16:12:51.452]                       }
[16:12:51.452]                       else if (inherits(cond, "warning")) {
[16:12:51.452]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.452]                         if (muffled) 
[16:12:51.452]                           invokeRestart("muffleWarning")
[16:12:51.452]                       }
[16:12:51.452]                       else if (inherits(cond, "condition")) {
[16:12:51.452]                         if (!is.null(pattern)) {
[16:12:51.452]                           computeRestarts <- base::computeRestarts
[16:12:51.452]                           grepl <- base::grepl
[16:12:51.452]                           restarts <- computeRestarts(cond)
[16:12:51.452]                           for (restart in restarts) {
[16:12:51.452]                             name <- restart$name
[16:12:51.452]                             if (is.null(name)) 
[16:12:51.452]                               next
[16:12:51.452]                             if (!grepl(pattern, name)) 
[16:12:51.452]                               next
[16:12:51.452]                             invokeRestart(restart)
[16:12:51.452]                             muffled <- TRUE
[16:12:51.452]                             break
[16:12:51.452]                           }
[16:12:51.452]                         }
[16:12:51.452]                       }
[16:12:51.452]                       invisible(muffled)
[16:12:51.452]                     }
[16:12:51.452]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.452]                   }
[16:12:51.452]                 }
[16:12:51.452]                 else {
[16:12:51.452]                   if (TRUE) {
[16:12:51.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.452]                     {
[16:12:51.452]                       inherits <- base::inherits
[16:12:51.452]                       invokeRestart <- base::invokeRestart
[16:12:51.452]                       is.null <- base::is.null
[16:12:51.452]                       muffled <- FALSE
[16:12:51.452]                       if (inherits(cond, "message")) {
[16:12:51.452]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.452]                         if (muffled) 
[16:12:51.452]                           invokeRestart("muffleMessage")
[16:12:51.452]                       }
[16:12:51.452]                       else if (inherits(cond, "warning")) {
[16:12:51.452]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.452]                         if (muffled) 
[16:12:51.452]                           invokeRestart("muffleWarning")
[16:12:51.452]                       }
[16:12:51.452]                       else if (inherits(cond, "condition")) {
[16:12:51.452]                         if (!is.null(pattern)) {
[16:12:51.452]                           computeRestarts <- base::computeRestarts
[16:12:51.452]                           grepl <- base::grepl
[16:12:51.452]                           restarts <- computeRestarts(cond)
[16:12:51.452]                           for (restart in restarts) {
[16:12:51.452]                             name <- restart$name
[16:12:51.452]                             if (is.null(name)) 
[16:12:51.452]                               next
[16:12:51.452]                             if (!grepl(pattern, name)) 
[16:12:51.452]                               next
[16:12:51.452]                             invokeRestart(restart)
[16:12:51.452]                             muffled <- TRUE
[16:12:51.452]                             break
[16:12:51.452]                           }
[16:12:51.452]                         }
[16:12:51.452]                       }
[16:12:51.452]                       invisible(muffled)
[16:12:51.452]                     }
[16:12:51.452]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.452]                   }
[16:12:51.452]                 }
[16:12:51.452]             }
[16:12:51.452]         }))
[16:12:51.452]     }, error = function(ex) {
[16:12:51.452]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.452]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.452]                 ...future.rng), started = ...future.startTime, 
[16:12:51.452]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.452]             version = "1.8"), class = "FutureResult")
[16:12:51.452]     }, finally = {
[16:12:51.452]         if (!identical(...future.workdir, getwd())) 
[16:12:51.452]             setwd(...future.workdir)
[16:12:51.452]         {
[16:12:51.452]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.452]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.452]             }
[16:12:51.452]             base::options(...future.oldOptions)
[16:12:51.452]             if (.Platform$OS.type == "windows") {
[16:12:51.452]                 old_names <- names(...future.oldEnvVars)
[16:12:51.452]                 envs <- base::Sys.getenv()
[16:12:51.452]                 names <- names(envs)
[16:12:51.452]                 common <- intersect(names, old_names)
[16:12:51.452]                 added <- setdiff(names, old_names)
[16:12:51.452]                 removed <- setdiff(old_names, names)
[16:12:51.452]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.452]                   envs[common]]
[16:12:51.452]                 NAMES <- toupper(changed)
[16:12:51.452]                 args <- list()
[16:12:51.452]                 for (kk in seq_along(NAMES)) {
[16:12:51.452]                   name <- changed[[kk]]
[16:12:51.452]                   NAME <- NAMES[[kk]]
[16:12:51.452]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.452]                     next
[16:12:51.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.452]                 }
[16:12:51.452]                 NAMES <- toupper(added)
[16:12:51.452]                 for (kk in seq_along(NAMES)) {
[16:12:51.452]                   name <- added[[kk]]
[16:12:51.452]                   NAME <- NAMES[[kk]]
[16:12:51.452]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.452]                     next
[16:12:51.452]                   args[[name]] <- ""
[16:12:51.452]                 }
[16:12:51.452]                 NAMES <- toupper(removed)
[16:12:51.452]                 for (kk in seq_along(NAMES)) {
[16:12:51.452]                   name <- removed[[kk]]
[16:12:51.452]                   NAME <- NAMES[[kk]]
[16:12:51.452]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.452]                     next
[16:12:51.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.452]                 }
[16:12:51.452]                 if (length(args) > 0) 
[16:12:51.452]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.452]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.452]             }
[16:12:51.452]             else {
[16:12:51.452]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.452]             }
[16:12:51.452]             {
[16:12:51.452]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.452]                   0L) {
[16:12:51.452]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.452]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.452]                   base::options(opts)
[16:12:51.452]                 }
[16:12:51.452]                 {
[16:12:51.452]                   {
[16:12:51.452]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:51.452]                     NULL
[16:12:51.452]                   }
[16:12:51.452]                   options(future.plan = NULL)
[16:12:51.452]                   if (is.na(NA_character_)) 
[16:12:51.452]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.452]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.452]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:51.452]                     envir = parent.frame()) 
[16:12:51.452]                   {
[16:12:51.452]                     default_workers <- missing(workers)
[16:12:51.452]                     if (is.function(workers)) 
[16:12:51.452]                       workers <- workers()
[16:12:51.452]                     workers <- structure(as.integer(workers), 
[16:12:51.452]                       class = class(workers))
[16:12:51.452]                     stop_if_not(is.finite(workers), workers >= 
[16:12:51.452]                       1L)
[16:12:51.452]                     if ((workers == 1L && !inherits(workers, 
[16:12:51.452]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:51.452]                       if (default_workers) 
[16:12:51.452]                         supportsMulticore(warn = TRUE)
[16:12:51.452]                       return(sequential(..., envir = envir))
[16:12:51.452]                     }
[16:12:51.452]                     oopts <- options(mc.cores = workers)
[16:12:51.452]                     on.exit(options(oopts))
[16:12:51.452]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:51.452]                       envir = envir)
[16:12:51.452]                     if (!future$lazy) 
[16:12:51.452]                       future <- run(future)
[16:12:51.452]                     invisible(future)
[16:12:51.452]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.452]                 }
[16:12:51.452]             }
[16:12:51.452]         }
[16:12:51.452]     })
[16:12:51.452]     if (TRUE) {
[16:12:51.452]         base::sink(type = "output", split = FALSE)
[16:12:51.452]         if (TRUE) {
[16:12:51.452]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.452]         }
[16:12:51.452]         else {
[16:12:51.452]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.452]         }
[16:12:51.452]         base::close(...future.stdout)
[16:12:51.452]         ...future.stdout <- NULL
[16:12:51.452]     }
[16:12:51.452]     ...future.result$conditions <- ...future.conditions
[16:12:51.452]     ...future.result$finished <- base::Sys.time()
[16:12:51.452]     ...future.result
[16:12:51.452] }
[16:12:51.455] requestCore(): workers = 2
[16:12:51.457] MulticoreFuture started
[16:12:51.458] - Launch lazy future ... done
[16:12:51.458] run() for ‘MulticoreFuture’ ... done
[16:12:51.458] plan(): Setting new future strategy stack:
[16:12:51.458] List of future strategies:
[16:12:51.458] 1. sequential:
[16:12:51.458]    - args: function (..., envir = parent.frame())
[16:12:51.458]    - tweaked: FALSE
[16:12:51.458]    - call: NULL
[16:12:51.459] plan(): nbrOfWorkers() = 1
[16:12:51.462] plan(): Setting new future strategy stack:
[16:12:51.462] List of future strategies:
[16:12:51.462] 1. multicore:
[16:12:51.462]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:51.462]    - tweaked: FALSE
[16:12:51.462]    - call: plan(strategy)
[16:12:51.467] plan(): nbrOfWorkers() = 2
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.472] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.472] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.474] - globals found: [3] ‘{’, ‘<-’, ‘*’
[16:12:51.474] Searching for globals ... DONE
[16:12:51.474] Resolving globals: TRUE
[16:12:51.475] Resolving any globals that are futures ...
[16:12:51.475] - globals: [3] ‘{’, ‘<-’, ‘*’
[16:12:51.475] Resolving any globals that are futures ... DONE
[16:12:51.475] 
[16:12:51.475] 
[16:12:51.475] getGlobalsAndPackages() ... DONE
[16:12:51.476] run() for ‘Future’ ...
[16:12:51.476] - state: ‘created’
[16:12:51.476] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:51.480] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:51.481] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:51.481]   - Field: ‘label’
[16:12:51.481]   - Field: ‘local’
[16:12:51.481]   - Field: ‘owner’
[16:12:51.481]   - Field: ‘envir’
[16:12:51.481]   - Field: ‘workers’
[16:12:51.481]   - Field: ‘packages’
[16:12:51.482]   - Field: ‘gc’
[16:12:51.482]   - Field: ‘job’
[16:12:51.482]   - Field: ‘conditions’
[16:12:51.482]   - Field: ‘expr’
[16:12:51.485]   - Field: ‘uuid’
[16:12:51.485]   - Field: ‘seed’
[16:12:51.485]   - Field: ‘version’
[16:12:51.485]   - Field: ‘result’
[16:12:51.486]   - Field: ‘asynchronous’
[16:12:51.486]   - Field: ‘calls’
[16:12:51.486]   - Field: ‘globals’
[16:12:51.486]   - Field: ‘stdout’
[16:12:51.486]   - Field: ‘earlySignal’
[16:12:51.486]   - Field: ‘lazy’
[16:12:51.487]   - Field: ‘state’
[16:12:51.487] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:51.487] - Launch lazy future ...
[16:12:51.487] Packages needed by the future expression (n = 0): <none>
[16:12:51.487] Packages needed by future strategies (n = 0): <none>
[16:12:51.488] {
[16:12:51.488]     {
[16:12:51.488]         {
[16:12:51.488]             ...future.startTime <- base::Sys.time()
[16:12:51.488]             {
[16:12:51.488]                 {
[16:12:51.488]                   {
[16:12:51.488]                     {
[16:12:51.488]                       base::local({
[16:12:51.488]                         has_future <- base::requireNamespace("future", 
[16:12:51.488]                           quietly = TRUE)
[16:12:51.488]                         if (has_future) {
[16:12:51.488]                           ns <- base::getNamespace("future")
[16:12:51.488]                           version <- ns[[".package"]][["version"]]
[16:12:51.488]                           if (is.null(version)) 
[16:12:51.488]                             version <- utils::packageVersion("future")
[16:12:51.488]                         }
[16:12:51.488]                         else {
[16:12:51.488]                           version <- NULL
[16:12:51.488]                         }
[16:12:51.488]                         if (!has_future || version < "1.8.0") {
[16:12:51.488]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.488]                             "", base::R.version$version.string), 
[16:12:51.488]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:51.488]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.488]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.488]                               "release", "version")], collapse = " "), 
[16:12:51.488]                             hostname = base::Sys.info()[["nodename"]])
[16:12:51.488]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.488]                             info)
[16:12:51.488]                           info <- base::paste(info, collapse = "; ")
[16:12:51.488]                           if (!has_future) {
[16:12:51.488]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.488]                               info)
[16:12:51.488]                           }
[16:12:51.488]                           else {
[16:12:51.488]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.488]                               info, version)
[16:12:51.488]                           }
[16:12:51.488]                           base::stop(msg)
[16:12:51.488]                         }
[16:12:51.488]                       })
[16:12:51.488]                     }
[16:12:51.488]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:51.488]                     base::options(mc.cores = 1L)
[16:12:51.488]                   }
[16:12:51.488]                   options(future.plan = NULL)
[16:12:51.488]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.488]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.488]                 }
[16:12:51.488]                 ...future.workdir <- getwd()
[16:12:51.488]             }
[16:12:51.488]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.488]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.488]         }
[16:12:51.488]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.488]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:51.488]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.488]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.488]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.488]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.488]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.488]             base::names(...future.oldOptions))
[16:12:51.488]     }
[16:12:51.488]     if (FALSE) {
[16:12:51.488]     }
[16:12:51.488]     else {
[16:12:51.488]         if (TRUE) {
[16:12:51.488]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.488]                 open = "w")
[16:12:51.488]         }
[16:12:51.488]         else {
[16:12:51.488]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.488]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.488]         }
[16:12:51.488]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.488]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.488]             base::sink(type = "output", split = FALSE)
[16:12:51.488]             base::close(...future.stdout)
[16:12:51.488]         }, add = TRUE)
[16:12:51.488]     }
[16:12:51.488]     ...future.frame <- base::sys.nframe()
[16:12:51.488]     ...future.conditions <- base::list()
[16:12:51.488]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.488]     if (FALSE) {
[16:12:51.488]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.488]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.488]     }
[16:12:51.488]     ...future.result <- base::tryCatch({
[16:12:51.488]         base::withCallingHandlers({
[16:12:51.488]             ...future.value <- base::withVisible(base::local({
[16:12:51.488]                 withCallingHandlers({
[16:12:51.488]                   {
[16:12:51.488]                     b <- a
[16:12:51.488]                     a <- 2
[16:12:51.488]                     a * b
[16:12:51.488]                   }
[16:12:51.488]                 }, immediateCondition = function(cond) {
[16:12:51.488]                   save_rds <- function (object, pathname, ...) 
[16:12:51.488]                   {
[16:12:51.488]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:51.488]                     if (file_test("-f", pathname_tmp)) {
[16:12:51.488]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.488]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:51.488]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.488]                         fi_tmp[["mtime"]])
[16:12:51.488]                     }
[16:12:51.488]                     tryCatch({
[16:12:51.488]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:51.488]                     }, error = function(ex) {
[16:12:51.488]                       msg <- conditionMessage(ex)
[16:12:51.488]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.488]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:51.488]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.488]                         fi_tmp[["mtime"]], msg)
[16:12:51.488]                       ex$message <- msg
[16:12:51.488]                       stop(ex)
[16:12:51.488]                     })
[16:12:51.488]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:51.488]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:51.488]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:51.488]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.488]                       fi <- file.info(pathname)
[16:12:51.488]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:51.488]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.488]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:51.488]                         fi[["size"]], fi[["mtime"]])
[16:12:51.488]                       stop(msg)
[16:12:51.488]                     }
[16:12:51.488]                     invisible(pathname)
[16:12:51.488]                   }
[16:12:51.488]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:51.488]                     rootPath = tempdir()) 
[16:12:51.488]                   {
[16:12:51.488]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:51.488]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:51.488]                       tmpdir = path, fileext = ".rds")
[16:12:51.488]                     save_rds(obj, file)
[16:12:51.488]                   }
[16:12:51.488]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:51.488]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.488]                   {
[16:12:51.488]                     inherits <- base::inherits
[16:12:51.488]                     invokeRestart <- base::invokeRestart
[16:12:51.488]                     is.null <- base::is.null
[16:12:51.488]                     muffled <- FALSE
[16:12:51.488]                     if (inherits(cond, "message")) {
[16:12:51.488]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:51.488]                       if (muffled) 
[16:12:51.488]                         invokeRestart("muffleMessage")
[16:12:51.488]                     }
[16:12:51.488]                     else if (inherits(cond, "warning")) {
[16:12:51.488]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:51.488]                       if (muffled) 
[16:12:51.488]                         invokeRestart("muffleWarning")
[16:12:51.488]                     }
[16:12:51.488]                     else if (inherits(cond, "condition")) {
[16:12:51.488]                       if (!is.null(pattern)) {
[16:12:51.488]                         computeRestarts <- base::computeRestarts
[16:12:51.488]                         grepl <- base::grepl
[16:12:51.488]                         restarts <- computeRestarts(cond)
[16:12:51.488]                         for (restart in restarts) {
[16:12:51.488]                           name <- restart$name
[16:12:51.488]                           if (is.null(name)) 
[16:12:51.488]                             next
[16:12:51.488]                           if (!grepl(pattern, name)) 
[16:12:51.488]                             next
[16:12:51.488]                           invokeRestart(restart)
[16:12:51.488]                           muffled <- TRUE
[16:12:51.488]                           break
[16:12:51.488]                         }
[16:12:51.488]                       }
[16:12:51.488]                     }
[16:12:51.488]                     invisible(muffled)
[16:12:51.488]                   }
[16:12:51.488]                   muffleCondition(cond)
[16:12:51.488]                 })
[16:12:51.488]             }))
[16:12:51.488]             future::FutureResult(value = ...future.value$value, 
[16:12:51.488]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.488]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.488]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.488]                     ...future.globalenv.names))
[16:12:51.488]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.488]         }, condition = base::local({
[16:12:51.488]             c <- base::c
[16:12:51.488]             inherits <- base::inherits
[16:12:51.488]             invokeRestart <- base::invokeRestart
[16:12:51.488]             length <- base::length
[16:12:51.488]             list <- base::list
[16:12:51.488]             seq.int <- base::seq.int
[16:12:51.488]             signalCondition <- base::signalCondition
[16:12:51.488]             sys.calls <- base::sys.calls
[16:12:51.488]             `[[` <- base::`[[`
[16:12:51.488]             `+` <- base::`+`
[16:12:51.488]             `<<-` <- base::`<<-`
[16:12:51.488]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.488]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.488]                   3L)]
[16:12:51.488]             }
[16:12:51.488]             function(cond) {
[16:12:51.488]                 is_error <- inherits(cond, "error")
[16:12:51.488]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.488]                   NULL)
[16:12:51.488]                 if (is_error) {
[16:12:51.488]                   sessionInformation <- function() {
[16:12:51.488]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.488]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.488]                       search = base::search(), system = base::Sys.info())
[16:12:51.488]                   }
[16:12:51.488]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.488]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.488]                     cond$call), session = sessionInformation(), 
[16:12:51.488]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.488]                   signalCondition(cond)
[16:12:51.488]                 }
[16:12:51.488]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.488]                 "immediateCondition"))) {
[16:12:51.488]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.488]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.488]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.488]                   if (TRUE && !signal) {
[16:12:51.488]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.488]                     {
[16:12:51.488]                       inherits <- base::inherits
[16:12:51.488]                       invokeRestart <- base::invokeRestart
[16:12:51.488]                       is.null <- base::is.null
[16:12:51.488]                       muffled <- FALSE
[16:12:51.488]                       if (inherits(cond, "message")) {
[16:12:51.488]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.488]                         if (muffled) 
[16:12:51.488]                           invokeRestart("muffleMessage")
[16:12:51.488]                       }
[16:12:51.488]                       else if (inherits(cond, "warning")) {
[16:12:51.488]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.488]                         if (muffled) 
[16:12:51.488]                           invokeRestart("muffleWarning")
[16:12:51.488]                       }
[16:12:51.488]                       else if (inherits(cond, "condition")) {
[16:12:51.488]                         if (!is.null(pattern)) {
[16:12:51.488]                           computeRestarts <- base::computeRestarts
[16:12:51.488]                           grepl <- base::grepl
[16:12:51.488]                           restarts <- computeRestarts(cond)
[16:12:51.488]                           for (restart in restarts) {
[16:12:51.488]                             name <- restart$name
[16:12:51.488]                             if (is.null(name)) 
[16:12:51.488]                               next
[16:12:51.488]                             if (!grepl(pattern, name)) 
[16:12:51.488]                               next
[16:12:51.488]                             invokeRestart(restart)
[16:12:51.488]                             muffled <- TRUE
[16:12:51.488]                             break
[16:12:51.488]                           }
[16:12:51.488]                         }
[16:12:51.488]                       }
[16:12:51.488]                       invisible(muffled)
[16:12:51.488]                     }
[16:12:51.488]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.488]                   }
[16:12:51.488]                 }
[16:12:51.488]                 else {
[16:12:51.488]                   if (TRUE) {
[16:12:51.488]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.488]                     {
[16:12:51.488]                       inherits <- base::inherits
[16:12:51.488]                       invokeRestart <- base::invokeRestart
[16:12:51.488]                       is.null <- base::is.null
[16:12:51.488]                       muffled <- FALSE
[16:12:51.488]                       if (inherits(cond, "message")) {
[16:12:51.488]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.488]                         if (muffled) 
[16:12:51.488]                           invokeRestart("muffleMessage")
[16:12:51.488]                       }
[16:12:51.488]                       else if (inherits(cond, "warning")) {
[16:12:51.488]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.488]                         if (muffled) 
[16:12:51.488]                           invokeRestart("muffleWarning")
[16:12:51.488]                       }
[16:12:51.488]                       else if (inherits(cond, "condition")) {
[16:12:51.488]                         if (!is.null(pattern)) {
[16:12:51.488]                           computeRestarts <- base::computeRestarts
[16:12:51.488]                           grepl <- base::grepl
[16:12:51.488]                           restarts <- computeRestarts(cond)
[16:12:51.488]                           for (restart in restarts) {
[16:12:51.488]                             name <- restart$name
[16:12:51.488]                             if (is.null(name)) 
[16:12:51.488]                               next
[16:12:51.488]                             if (!grepl(pattern, name)) 
[16:12:51.488]                               next
[16:12:51.488]                             invokeRestart(restart)
[16:12:51.488]                             muffled <- TRUE
[16:12:51.488]                             break
[16:12:51.488]                           }
[16:12:51.488]                         }
[16:12:51.488]                       }
[16:12:51.488]                       invisible(muffled)
[16:12:51.488]                     }
[16:12:51.488]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.488]                   }
[16:12:51.488]                 }
[16:12:51.488]             }
[16:12:51.488]         }))
[16:12:51.488]     }, error = function(ex) {
[16:12:51.488]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.488]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.488]                 ...future.rng), started = ...future.startTime, 
[16:12:51.488]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.488]             version = "1.8"), class = "FutureResult")
[16:12:51.488]     }, finally = {
[16:12:51.488]         if (!identical(...future.workdir, getwd())) 
[16:12:51.488]             setwd(...future.workdir)
[16:12:51.488]         {
[16:12:51.488]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.488]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.488]             }
[16:12:51.488]             base::options(...future.oldOptions)
[16:12:51.488]             if (.Platform$OS.type == "windows") {
[16:12:51.488]                 old_names <- names(...future.oldEnvVars)
[16:12:51.488]                 envs <- base::Sys.getenv()
[16:12:51.488]                 names <- names(envs)
[16:12:51.488]                 common <- intersect(names, old_names)
[16:12:51.488]                 added <- setdiff(names, old_names)
[16:12:51.488]                 removed <- setdiff(old_names, names)
[16:12:51.488]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.488]                   envs[common]]
[16:12:51.488]                 NAMES <- toupper(changed)
[16:12:51.488]                 args <- list()
[16:12:51.488]                 for (kk in seq_along(NAMES)) {
[16:12:51.488]                   name <- changed[[kk]]
[16:12:51.488]                   NAME <- NAMES[[kk]]
[16:12:51.488]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.488]                     next
[16:12:51.488]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.488]                 }
[16:12:51.488]                 NAMES <- toupper(added)
[16:12:51.488]                 for (kk in seq_along(NAMES)) {
[16:12:51.488]                   name <- added[[kk]]
[16:12:51.488]                   NAME <- NAMES[[kk]]
[16:12:51.488]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.488]                     next
[16:12:51.488]                   args[[name]] <- ""
[16:12:51.488]                 }
[16:12:51.488]                 NAMES <- toupper(removed)
[16:12:51.488]                 for (kk in seq_along(NAMES)) {
[16:12:51.488]                   name <- removed[[kk]]
[16:12:51.488]                   NAME <- NAMES[[kk]]
[16:12:51.488]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.488]                     next
[16:12:51.488]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.488]                 }
[16:12:51.488]                 if (length(args) > 0) 
[16:12:51.488]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.488]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.488]             }
[16:12:51.488]             else {
[16:12:51.488]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.488]             }
[16:12:51.488]             {
[16:12:51.488]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.488]                   0L) {
[16:12:51.488]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.488]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.488]                   base::options(opts)
[16:12:51.488]                 }
[16:12:51.488]                 {
[16:12:51.488]                   {
[16:12:51.488]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:51.488]                     NULL
[16:12:51.488]                   }
[16:12:51.488]                   options(future.plan = NULL)
[16:12:51.488]                   if (is.na(NA_character_)) 
[16:12:51.488]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.488]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.488]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:51.488]                     envir = parent.frame()) 
[16:12:51.488]                   {
[16:12:51.488]                     default_workers <- missing(workers)
[16:12:51.488]                     if (is.function(workers)) 
[16:12:51.488]                       workers <- workers()
[16:12:51.488]                     workers <- structure(as.integer(workers), 
[16:12:51.488]                       class = class(workers))
[16:12:51.488]                     stop_if_not(is.finite(workers), workers >= 
[16:12:51.488]                       1L)
[16:12:51.488]                     if ((workers == 1L && !inherits(workers, 
[16:12:51.488]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:51.488]                       if (default_workers) 
[16:12:51.488]                         supportsMulticore(warn = TRUE)
[16:12:51.488]                       return(sequential(..., envir = envir))
[16:12:51.488]                     }
[16:12:51.488]                     oopts <- options(mc.cores = workers)
[16:12:51.488]                     on.exit(options(oopts))
[16:12:51.488]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:51.488]                       envir = envir)
[16:12:51.488]                     if (!future$lazy) 
[16:12:51.488]                       future <- run(future)
[16:12:51.488]                     invisible(future)
[16:12:51.488]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.488]                 }
[16:12:51.488]             }
[16:12:51.488]         }
[16:12:51.488]     })
[16:12:51.488]     if (TRUE) {
[16:12:51.488]         base::sink(type = "output", split = FALSE)
[16:12:51.488]         if (TRUE) {
[16:12:51.488]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.488]         }
[16:12:51.488]         else {
[16:12:51.488]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.488]         }
[16:12:51.488]         base::close(...future.stdout)
[16:12:51.488]         ...future.stdout <- NULL
[16:12:51.488]     }
[16:12:51.488]     ...future.result$conditions <- ...future.conditions
[16:12:51.488]     ...future.result$finished <- base::Sys.time()
[16:12:51.488]     ...future.result
[16:12:51.488] }
[16:12:51.491] requestCore(): workers = 2
[16:12:51.493] MulticoreFuture started
[16:12:51.493] - Launch lazy future ... done
[16:12:51.494] run() for ‘MulticoreFuture’ ... done
[16:12:51.494] plan(): Setting new future strategy stack:
[16:12:51.494] List of future strategies:
[16:12:51.494] 1. sequential:
[16:12:51.494]    - args: function (..., envir = parent.frame())
[16:12:51.494]    - tweaked: FALSE
[16:12:51.494]    - call: NULL
[16:12:51.495] plan(): nbrOfWorkers() = 1
[16:12:51.498] plan(): Setting new future strategy stack:
[16:12:51.498] List of future strategies:
[16:12:51.498] 1. multicore:
[16:12:51.498]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:51.498]    - tweaked: FALSE
[16:12:51.498]    - call: plan(strategy)
[16:12:51.504] plan(): nbrOfWorkers() = 2
[16:12:51.511] signalConditions() ...
[16:12:51.511]  - include = ‘immediateCondition’
[16:12:51.512]  - exclude = 
[16:12:51.512]  - resignal = FALSE
[16:12:51.512]  - Number of conditions: 1
[16:12:51.512] signalConditions() ... done
[16:12:51.512] signalConditions() ...
[16:12:51.513]  - include = ‘immediateCondition’
[16:12:51.513]  - exclude = 
[16:12:51.513]  - resignal = FALSE
[16:12:51.513]  - Number of conditions: 1
[16:12:51.513] signalConditions() ... done
[16:12:51.514] Future state: ‘finished’
[16:12:51.514] signalConditions() ...
[16:12:51.514]  - include = ‘condition’
[16:12:51.514]  - exclude = ‘immediateCondition’
[16:12:51.514]  - resignal = TRUE
[16:12:51.514]  - Number of conditions: 1
[16:12:51.515]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:12:51.515] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 39
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2729ef2608da" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:12:51"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.544] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.545] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.546] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:51.546] Searching for globals ... DONE
[16:12:51.546] Resolving globals: TRUE
[16:12:51.546] Resolving any globals that are futures ...
[16:12:51.547] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:51.547] Resolving any globals that are futures ... DONE
[16:12:51.547] Resolving futures part of globals (recursively) ...
[16:12:51.547] resolve() on list ...
[16:12:51.547]  recursive: 99
[16:12:51.547]  length: 1
[16:12:51.548]  elements: ‘ii’
[16:12:51.548]  length: 0 (resolved future 1)
[16:12:51.548] resolve() on list ... DONE
[16:12:51.548] - globals: [1] ‘ii’
[16:12:51.548] Resolving futures part of globals (recursively) ... DONE
[16:12:51.548] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:51.549] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:12:51.549] - globals: [1] ‘ii’
[16:12:51.549] 
[16:12:51.549] getGlobalsAndPackages() ... DONE
[16:12:51.549] run() for ‘Future’ ...
[16:12:51.549] - state: ‘created’
[16:12:51.549] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:51.553] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:51.553] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:51.554]   - Field: ‘label’
[16:12:51.554]   - Field: ‘local’
[16:12:51.554]   - Field: ‘owner’
[16:12:51.554]   - Field: ‘envir’
[16:12:51.554]   - Field: ‘workers’
[16:12:51.554]   - Field: ‘packages’
[16:12:51.554]   - Field: ‘gc’
[16:12:51.554]   - Field: ‘job’
[16:12:51.554]   - Field: ‘conditions’
[16:12:51.555]   - Field: ‘expr’
[16:12:51.555]   - Field: ‘uuid’
[16:12:51.555]   - Field: ‘seed’
[16:12:51.555]   - Field: ‘version’
[16:12:51.555]   - Field: ‘result’
[16:12:51.555]   - Field: ‘asynchronous’
[16:12:51.555]   - Field: ‘calls’
[16:12:51.555]   - Field: ‘globals’
[16:12:51.555]   - Field: ‘stdout’
[16:12:51.555]   - Field: ‘earlySignal’
[16:12:51.555]   - Field: ‘lazy’
[16:12:51.556]   - Field: ‘state’
[16:12:51.556] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:51.556] - Launch lazy future ...
[16:12:51.556] Packages needed by the future expression (n = 0): <none>
[16:12:51.556] Packages needed by future strategies (n = 0): <none>
[16:12:51.557] {
[16:12:51.557]     {
[16:12:51.557]         {
[16:12:51.557]             ...future.startTime <- base::Sys.time()
[16:12:51.557]             {
[16:12:51.557]                 {
[16:12:51.557]                   {
[16:12:51.557]                     {
[16:12:51.557]                       base::local({
[16:12:51.557]                         has_future <- base::requireNamespace("future", 
[16:12:51.557]                           quietly = TRUE)
[16:12:51.557]                         if (has_future) {
[16:12:51.557]                           ns <- base::getNamespace("future")
[16:12:51.557]                           version <- ns[[".package"]][["version"]]
[16:12:51.557]                           if (is.null(version)) 
[16:12:51.557]                             version <- utils::packageVersion("future")
[16:12:51.557]                         }
[16:12:51.557]                         else {
[16:12:51.557]                           version <- NULL
[16:12:51.557]                         }
[16:12:51.557]                         if (!has_future || version < "1.8.0") {
[16:12:51.557]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.557]                             "", base::R.version$version.string), 
[16:12:51.557]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:51.557]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.557]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.557]                               "release", "version")], collapse = " "), 
[16:12:51.557]                             hostname = base::Sys.info()[["nodename"]])
[16:12:51.557]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.557]                             info)
[16:12:51.557]                           info <- base::paste(info, collapse = "; ")
[16:12:51.557]                           if (!has_future) {
[16:12:51.557]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.557]                               info)
[16:12:51.557]                           }
[16:12:51.557]                           else {
[16:12:51.557]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.557]                               info, version)
[16:12:51.557]                           }
[16:12:51.557]                           base::stop(msg)
[16:12:51.557]                         }
[16:12:51.557]                       })
[16:12:51.557]                     }
[16:12:51.557]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:51.557]                     base::options(mc.cores = 1L)
[16:12:51.557]                   }
[16:12:51.557]                   options(future.plan = NULL)
[16:12:51.557]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.557]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.557]                 }
[16:12:51.557]                 ...future.workdir <- getwd()
[16:12:51.557]             }
[16:12:51.557]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.557]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.557]         }
[16:12:51.557]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.557]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:51.557]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.557]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.557]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.557]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.557]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.557]             base::names(...future.oldOptions))
[16:12:51.557]     }
[16:12:51.557]     if (FALSE) {
[16:12:51.557]     }
[16:12:51.557]     else {
[16:12:51.557]         if (TRUE) {
[16:12:51.557]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.557]                 open = "w")
[16:12:51.557]         }
[16:12:51.557]         else {
[16:12:51.557]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.557]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.557]         }
[16:12:51.557]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.557]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.557]             base::sink(type = "output", split = FALSE)
[16:12:51.557]             base::close(...future.stdout)
[16:12:51.557]         }, add = TRUE)
[16:12:51.557]     }
[16:12:51.557]     ...future.frame <- base::sys.nframe()
[16:12:51.557]     ...future.conditions <- base::list()
[16:12:51.557]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.557]     if (FALSE) {
[16:12:51.557]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.557]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.557]     }
[16:12:51.557]     ...future.result <- base::tryCatch({
[16:12:51.557]         base::withCallingHandlers({
[16:12:51.557]             ...future.value <- base::withVisible(base::local({
[16:12:51.557]                 withCallingHandlers({
[16:12:51.557]                   {
[16:12:51.557]                     b <- a * ii
[16:12:51.557]                     a <- 0
[16:12:51.557]                     b
[16:12:51.557]                   }
[16:12:51.557]                 }, immediateCondition = function(cond) {
[16:12:51.557]                   save_rds <- function (object, pathname, ...) 
[16:12:51.557]                   {
[16:12:51.557]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:51.557]                     if (file_test("-f", pathname_tmp)) {
[16:12:51.557]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.557]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:51.557]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.557]                         fi_tmp[["mtime"]])
[16:12:51.557]                     }
[16:12:51.557]                     tryCatch({
[16:12:51.557]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:51.557]                     }, error = function(ex) {
[16:12:51.557]                       msg <- conditionMessage(ex)
[16:12:51.557]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.557]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:51.557]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.557]                         fi_tmp[["mtime"]], msg)
[16:12:51.557]                       ex$message <- msg
[16:12:51.557]                       stop(ex)
[16:12:51.557]                     })
[16:12:51.557]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:51.557]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:51.557]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:51.557]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.557]                       fi <- file.info(pathname)
[16:12:51.557]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:51.557]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.557]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:51.557]                         fi[["size"]], fi[["mtime"]])
[16:12:51.557]                       stop(msg)
[16:12:51.557]                     }
[16:12:51.557]                     invisible(pathname)
[16:12:51.557]                   }
[16:12:51.557]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:51.557]                     rootPath = tempdir()) 
[16:12:51.557]                   {
[16:12:51.557]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:51.557]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:51.557]                       tmpdir = path, fileext = ".rds")
[16:12:51.557]                     save_rds(obj, file)
[16:12:51.557]                   }
[16:12:51.557]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:51.557]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.557]                   {
[16:12:51.557]                     inherits <- base::inherits
[16:12:51.557]                     invokeRestart <- base::invokeRestart
[16:12:51.557]                     is.null <- base::is.null
[16:12:51.557]                     muffled <- FALSE
[16:12:51.557]                     if (inherits(cond, "message")) {
[16:12:51.557]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:51.557]                       if (muffled) 
[16:12:51.557]                         invokeRestart("muffleMessage")
[16:12:51.557]                     }
[16:12:51.557]                     else if (inherits(cond, "warning")) {
[16:12:51.557]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:51.557]                       if (muffled) 
[16:12:51.557]                         invokeRestart("muffleWarning")
[16:12:51.557]                     }
[16:12:51.557]                     else if (inherits(cond, "condition")) {
[16:12:51.557]                       if (!is.null(pattern)) {
[16:12:51.557]                         computeRestarts <- base::computeRestarts
[16:12:51.557]                         grepl <- base::grepl
[16:12:51.557]                         restarts <- computeRestarts(cond)
[16:12:51.557]                         for (restart in restarts) {
[16:12:51.557]                           name <- restart$name
[16:12:51.557]                           if (is.null(name)) 
[16:12:51.557]                             next
[16:12:51.557]                           if (!grepl(pattern, name)) 
[16:12:51.557]                             next
[16:12:51.557]                           invokeRestart(restart)
[16:12:51.557]                           muffled <- TRUE
[16:12:51.557]                           break
[16:12:51.557]                         }
[16:12:51.557]                       }
[16:12:51.557]                     }
[16:12:51.557]                     invisible(muffled)
[16:12:51.557]                   }
[16:12:51.557]                   muffleCondition(cond)
[16:12:51.557]                 })
[16:12:51.557]             }))
[16:12:51.557]             future::FutureResult(value = ...future.value$value, 
[16:12:51.557]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.557]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.557]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.557]                     ...future.globalenv.names))
[16:12:51.557]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.557]         }, condition = base::local({
[16:12:51.557]             c <- base::c
[16:12:51.557]             inherits <- base::inherits
[16:12:51.557]             invokeRestart <- base::invokeRestart
[16:12:51.557]             length <- base::length
[16:12:51.557]             list <- base::list
[16:12:51.557]             seq.int <- base::seq.int
[16:12:51.557]             signalCondition <- base::signalCondition
[16:12:51.557]             sys.calls <- base::sys.calls
[16:12:51.557]             `[[` <- base::`[[`
[16:12:51.557]             `+` <- base::`+`
[16:12:51.557]             `<<-` <- base::`<<-`
[16:12:51.557]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.557]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.557]                   3L)]
[16:12:51.557]             }
[16:12:51.557]             function(cond) {
[16:12:51.557]                 is_error <- inherits(cond, "error")
[16:12:51.557]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.557]                   NULL)
[16:12:51.557]                 if (is_error) {
[16:12:51.557]                   sessionInformation <- function() {
[16:12:51.557]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.557]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.557]                       search = base::search(), system = base::Sys.info())
[16:12:51.557]                   }
[16:12:51.557]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.557]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.557]                     cond$call), session = sessionInformation(), 
[16:12:51.557]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.557]                   signalCondition(cond)
[16:12:51.557]                 }
[16:12:51.557]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.557]                 "immediateCondition"))) {
[16:12:51.557]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.557]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.557]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.557]                   if (TRUE && !signal) {
[16:12:51.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.557]                     {
[16:12:51.557]                       inherits <- base::inherits
[16:12:51.557]                       invokeRestart <- base::invokeRestart
[16:12:51.557]                       is.null <- base::is.null
[16:12:51.557]                       muffled <- FALSE
[16:12:51.557]                       if (inherits(cond, "message")) {
[16:12:51.557]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.557]                         if (muffled) 
[16:12:51.557]                           invokeRestart("muffleMessage")
[16:12:51.557]                       }
[16:12:51.557]                       else if (inherits(cond, "warning")) {
[16:12:51.557]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.557]                         if (muffled) 
[16:12:51.557]                           invokeRestart("muffleWarning")
[16:12:51.557]                       }
[16:12:51.557]                       else if (inherits(cond, "condition")) {
[16:12:51.557]                         if (!is.null(pattern)) {
[16:12:51.557]                           computeRestarts <- base::computeRestarts
[16:12:51.557]                           grepl <- base::grepl
[16:12:51.557]                           restarts <- computeRestarts(cond)
[16:12:51.557]                           for (restart in restarts) {
[16:12:51.557]                             name <- restart$name
[16:12:51.557]                             if (is.null(name)) 
[16:12:51.557]                               next
[16:12:51.557]                             if (!grepl(pattern, name)) 
[16:12:51.557]                               next
[16:12:51.557]                             invokeRestart(restart)
[16:12:51.557]                             muffled <- TRUE
[16:12:51.557]                             break
[16:12:51.557]                           }
[16:12:51.557]                         }
[16:12:51.557]                       }
[16:12:51.557]                       invisible(muffled)
[16:12:51.557]                     }
[16:12:51.557]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.557]                   }
[16:12:51.557]                 }
[16:12:51.557]                 else {
[16:12:51.557]                   if (TRUE) {
[16:12:51.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.557]                     {
[16:12:51.557]                       inherits <- base::inherits
[16:12:51.557]                       invokeRestart <- base::invokeRestart
[16:12:51.557]                       is.null <- base::is.null
[16:12:51.557]                       muffled <- FALSE
[16:12:51.557]                       if (inherits(cond, "message")) {
[16:12:51.557]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.557]                         if (muffled) 
[16:12:51.557]                           invokeRestart("muffleMessage")
[16:12:51.557]                       }
[16:12:51.557]                       else if (inherits(cond, "warning")) {
[16:12:51.557]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.557]                         if (muffled) 
[16:12:51.557]                           invokeRestart("muffleWarning")
[16:12:51.557]                       }
[16:12:51.557]                       else if (inherits(cond, "condition")) {
[16:12:51.557]                         if (!is.null(pattern)) {
[16:12:51.557]                           computeRestarts <- base::computeRestarts
[16:12:51.557]                           grepl <- base::grepl
[16:12:51.557]                           restarts <- computeRestarts(cond)
[16:12:51.557]                           for (restart in restarts) {
[16:12:51.557]                             name <- restart$name
[16:12:51.557]                             if (is.null(name)) 
[16:12:51.557]                               next
[16:12:51.557]                             if (!grepl(pattern, name)) 
[16:12:51.557]                               next
[16:12:51.557]                             invokeRestart(restart)
[16:12:51.557]                             muffled <- TRUE
[16:12:51.557]                             break
[16:12:51.557]                           }
[16:12:51.557]                         }
[16:12:51.557]                       }
[16:12:51.557]                       invisible(muffled)
[16:12:51.557]                     }
[16:12:51.557]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.557]                   }
[16:12:51.557]                 }
[16:12:51.557]             }
[16:12:51.557]         }))
[16:12:51.557]     }, error = function(ex) {
[16:12:51.557]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.557]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.557]                 ...future.rng), started = ...future.startTime, 
[16:12:51.557]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.557]             version = "1.8"), class = "FutureResult")
[16:12:51.557]     }, finally = {
[16:12:51.557]         if (!identical(...future.workdir, getwd())) 
[16:12:51.557]             setwd(...future.workdir)
[16:12:51.557]         {
[16:12:51.557]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.557]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.557]             }
[16:12:51.557]             base::options(...future.oldOptions)
[16:12:51.557]             if (.Platform$OS.type == "windows") {
[16:12:51.557]                 old_names <- names(...future.oldEnvVars)
[16:12:51.557]                 envs <- base::Sys.getenv()
[16:12:51.557]                 names <- names(envs)
[16:12:51.557]                 common <- intersect(names, old_names)
[16:12:51.557]                 added <- setdiff(names, old_names)
[16:12:51.557]                 removed <- setdiff(old_names, names)
[16:12:51.557]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.557]                   envs[common]]
[16:12:51.557]                 NAMES <- toupper(changed)
[16:12:51.557]                 args <- list()
[16:12:51.557]                 for (kk in seq_along(NAMES)) {
[16:12:51.557]                   name <- changed[[kk]]
[16:12:51.557]                   NAME <- NAMES[[kk]]
[16:12:51.557]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.557]                     next
[16:12:51.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.557]                 }
[16:12:51.557]                 NAMES <- toupper(added)
[16:12:51.557]                 for (kk in seq_along(NAMES)) {
[16:12:51.557]                   name <- added[[kk]]
[16:12:51.557]                   NAME <- NAMES[[kk]]
[16:12:51.557]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.557]                     next
[16:12:51.557]                   args[[name]] <- ""
[16:12:51.557]                 }
[16:12:51.557]                 NAMES <- toupper(removed)
[16:12:51.557]                 for (kk in seq_along(NAMES)) {
[16:12:51.557]                   name <- removed[[kk]]
[16:12:51.557]                   NAME <- NAMES[[kk]]
[16:12:51.557]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.557]                     next
[16:12:51.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.557]                 }
[16:12:51.557]                 if (length(args) > 0) 
[16:12:51.557]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.557]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.557]             }
[16:12:51.557]             else {
[16:12:51.557]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.557]             }
[16:12:51.557]             {
[16:12:51.557]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.557]                   0L) {
[16:12:51.557]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.557]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.557]                   base::options(opts)
[16:12:51.557]                 }
[16:12:51.557]                 {
[16:12:51.557]                   {
[16:12:51.557]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:51.557]                     NULL
[16:12:51.557]                   }
[16:12:51.557]                   options(future.plan = NULL)
[16:12:51.557]                   if (is.na(NA_character_)) 
[16:12:51.557]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.557]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.557]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:51.557]                     envir = parent.frame()) 
[16:12:51.557]                   {
[16:12:51.557]                     default_workers <- missing(workers)
[16:12:51.557]                     if (is.function(workers)) 
[16:12:51.557]                       workers <- workers()
[16:12:51.557]                     workers <- structure(as.integer(workers), 
[16:12:51.557]                       class = class(workers))
[16:12:51.557]                     stop_if_not(is.finite(workers), workers >= 
[16:12:51.557]                       1L)
[16:12:51.557]                     if ((workers == 1L && !inherits(workers, 
[16:12:51.557]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:51.557]                       if (default_workers) 
[16:12:51.557]                         supportsMulticore(warn = TRUE)
[16:12:51.557]                       return(sequential(..., envir = envir))
[16:12:51.557]                     }
[16:12:51.557]                     oopts <- options(mc.cores = workers)
[16:12:51.557]                     on.exit(options(oopts))
[16:12:51.557]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:51.557]                       envir = envir)
[16:12:51.557]                     if (!future$lazy) 
[16:12:51.557]                       future <- run(future)
[16:12:51.557]                     invisible(future)
[16:12:51.557]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.557]                 }
[16:12:51.557]             }
[16:12:51.557]         }
[16:12:51.557]     })
[16:12:51.557]     if (TRUE) {
[16:12:51.557]         base::sink(type = "output", split = FALSE)
[16:12:51.557]         if (TRUE) {
[16:12:51.557]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.557]         }
[16:12:51.557]         else {
[16:12:51.557]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.557]         }
[16:12:51.557]         base::close(...future.stdout)
[16:12:51.557]         ...future.stdout <- NULL
[16:12:51.557]     }
[16:12:51.557]     ...future.result$conditions <- ...future.conditions
[16:12:51.557]     ...future.result$finished <- base::Sys.time()
[16:12:51.557]     ...future.result
[16:12:51.557] }
[16:12:51.559] assign_globals() ...
[16:12:51.559] List of 1
[16:12:51.559]  $ ii: int 1
[16:12:51.559]  - attr(*, "where")=List of 1
[16:12:51.559]   ..$ ii:<environment: R_EmptyEnv> 
[16:12:51.559]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.559]  - attr(*, "resolved")= logi TRUE
[16:12:51.559]  - attr(*, "total_size")= num 56
[16:12:51.559]  - attr(*, "already-done")= logi TRUE
[16:12:51.562] - copied ‘ii’ to environment
[16:12:51.562] assign_globals() ... done
[16:12:51.562] requestCore(): workers = 2
[16:12:51.564] MulticoreFuture started
[16:12:51.565] - Launch lazy future ... done
[16:12:51.565] run() for ‘MulticoreFuture’ ... done
[16:12:51.565] plan(): Setting new future strategy stack:
[16:12:51.566] List of future strategies:
[16:12:51.566] 1. sequential:
[16:12:51.566]    - args: function (..., envir = parent.frame())
[16:12:51.566]    - tweaked: FALSE
[16:12:51.566]    - call: NULL
[16:12:51.570] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.570] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.571] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.572] plan(): Setting new future strategy stack:
[16:12:51.573] List of future strategies:
[16:12:51.573] 1. multicore:
[16:12:51.573]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:51.573]    - tweaked: FALSE
[16:12:51.573]    - call: plan(strategy)
[16:12:51.576] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:51.576] Searching for globals ... DONE
[16:12:51.576] Resolving globals: TRUE
[16:12:51.577] Resolving any globals that are futures ...
[16:12:51.577] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:51.577] Resolving any globals that are futures ... DONE
[16:12:51.578] Resolving futures part of globals (recursively) ...
[16:12:51.578] plan(): nbrOfWorkers() = 2
[16:12:51.578] resolve() on list ...
[16:12:51.578]  recursive: 99
[16:12:51.579]  length: 1
[16:12:51.579]  elements: ‘ii’
[16:12:51.579]  length: 0 (resolved future 1)
[16:12:51.579] resolve() on list ... DONE
[16:12:51.579] - globals: [1] ‘ii’
[16:12:51.580] Resolving futures part of globals (recursively) ... DONE
[16:12:51.580] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:51.580] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:12:51.581] - globals: [1] ‘ii’
[16:12:51.581] 
[16:12:51.581] getGlobalsAndPackages() ... DONE
[16:12:51.581] run() for ‘Future’ ...
[16:12:51.582] - state: ‘created’
[16:12:51.582] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:51.586] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:51.586] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:51.586]   - Field: ‘label’
[16:12:51.587]   - Field: ‘local’
[16:12:51.587]   - Field: ‘owner’
[16:12:51.587]   - Field: ‘envir’
[16:12:51.587]   - Field: ‘workers’
[16:12:51.587]   - Field: ‘packages’
[16:12:51.587]   - Field: ‘gc’
[16:12:51.587]   - Field: ‘job’
[16:12:51.587]   - Field: ‘conditions’
[16:12:51.588]   - Field: ‘expr’
[16:12:51.588]   - Field: ‘uuid’
[16:12:51.588]   - Field: ‘seed’
[16:12:51.588]   - Field: ‘version’
[16:12:51.588]   - Field: ‘result’
[16:12:51.588]   - Field: ‘asynchronous’
[16:12:51.588]   - Field: ‘calls’
[16:12:51.589]   - Field: ‘globals’
[16:12:51.589]   - Field: ‘stdout’
[16:12:51.589]   - Field: ‘earlySignal’
[16:12:51.589]   - Field: ‘lazy’
[16:12:51.589]   - Field: ‘state’
[16:12:51.589] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:51.589] - Launch lazy future ...
[16:12:51.590] Packages needed by the future expression (n = 0): <none>
[16:12:51.590] Packages needed by future strategies (n = 0): <none>
[16:12:51.591] {
[16:12:51.591]     {
[16:12:51.591]         {
[16:12:51.591]             ...future.startTime <- base::Sys.time()
[16:12:51.591]             {
[16:12:51.591]                 {
[16:12:51.591]                   {
[16:12:51.591]                     {
[16:12:51.591]                       base::local({
[16:12:51.591]                         has_future <- base::requireNamespace("future", 
[16:12:51.591]                           quietly = TRUE)
[16:12:51.591]                         if (has_future) {
[16:12:51.591]                           ns <- base::getNamespace("future")
[16:12:51.591]                           version <- ns[[".package"]][["version"]]
[16:12:51.591]                           if (is.null(version)) 
[16:12:51.591]                             version <- utils::packageVersion("future")
[16:12:51.591]                         }
[16:12:51.591]                         else {
[16:12:51.591]                           version <- NULL
[16:12:51.591]                         }
[16:12:51.591]                         if (!has_future || version < "1.8.0") {
[16:12:51.591]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.591]                             "", base::R.version$version.string), 
[16:12:51.591]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:51.591]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.591]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.591]                               "release", "version")], collapse = " "), 
[16:12:51.591]                             hostname = base::Sys.info()[["nodename"]])
[16:12:51.591]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.591]                             info)
[16:12:51.591]                           info <- base::paste(info, collapse = "; ")
[16:12:51.591]                           if (!has_future) {
[16:12:51.591]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.591]                               info)
[16:12:51.591]                           }
[16:12:51.591]                           else {
[16:12:51.591]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.591]                               info, version)
[16:12:51.591]                           }
[16:12:51.591]                           base::stop(msg)
[16:12:51.591]                         }
[16:12:51.591]                       })
[16:12:51.591]                     }
[16:12:51.591]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:51.591]                     base::options(mc.cores = 1L)
[16:12:51.591]                   }
[16:12:51.591]                   options(future.plan = NULL)
[16:12:51.591]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.591]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.591]                 }
[16:12:51.591]                 ...future.workdir <- getwd()
[16:12:51.591]             }
[16:12:51.591]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.591]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.591]         }
[16:12:51.591]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.591]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:51.591]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.591]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.591]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.591]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.591]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.591]             base::names(...future.oldOptions))
[16:12:51.591]     }
[16:12:51.591]     if (FALSE) {
[16:12:51.591]     }
[16:12:51.591]     else {
[16:12:51.591]         if (TRUE) {
[16:12:51.591]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.591]                 open = "w")
[16:12:51.591]         }
[16:12:51.591]         else {
[16:12:51.591]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.591]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.591]         }
[16:12:51.591]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.591]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.591]             base::sink(type = "output", split = FALSE)
[16:12:51.591]             base::close(...future.stdout)
[16:12:51.591]         }, add = TRUE)
[16:12:51.591]     }
[16:12:51.591]     ...future.frame <- base::sys.nframe()
[16:12:51.591]     ...future.conditions <- base::list()
[16:12:51.591]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.591]     if (FALSE) {
[16:12:51.591]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.591]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.591]     }
[16:12:51.591]     ...future.result <- base::tryCatch({
[16:12:51.591]         base::withCallingHandlers({
[16:12:51.591]             ...future.value <- base::withVisible(base::local({
[16:12:51.591]                 withCallingHandlers({
[16:12:51.591]                   {
[16:12:51.591]                     b <- a * ii
[16:12:51.591]                     a <- 0
[16:12:51.591]                     b
[16:12:51.591]                   }
[16:12:51.591]                 }, immediateCondition = function(cond) {
[16:12:51.591]                   save_rds <- function (object, pathname, ...) 
[16:12:51.591]                   {
[16:12:51.591]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:51.591]                     if (file_test("-f", pathname_tmp)) {
[16:12:51.591]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.591]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:51.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.591]                         fi_tmp[["mtime"]])
[16:12:51.591]                     }
[16:12:51.591]                     tryCatch({
[16:12:51.591]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:51.591]                     }, error = function(ex) {
[16:12:51.591]                       msg <- conditionMessage(ex)
[16:12:51.591]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.591]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:51.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.591]                         fi_tmp[["mtime"]], msg)
[16:12:51.591]                       ex$message <- msg
[16:12:51.591]                       stop(ex)
[16:12:51.591]                     })
[16:12:51.591]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:51.591]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:51.591]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:51.591]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.591]                       fi <- file.info(pathname)
[16:12:51.591]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:51.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.591]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:51.591]                         fi[["size"]], fi[["mtime"]])
[16:12:51.591]                       stop(msg)
[16:12:51.591]                     }
[16:12:51.591]                     invisible(pathname)
[16:12:51.591]                   }
[16:12:51.591]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:51.591]                     rootPath = tempdir()) 
[16:12:51.591]                   {
[16:12:51.591]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:51.591]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:51.591]                       tmpdir = path, fileext = ".rds")
[16:12:51.591]                     save_rds(obj, file)
[16:12:51.591]                   }
[16:12:51.591]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:51.591]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.591]                   {
[16:12:51.591]                     inherits <- base::inherits
[16:12:51.591]                     invokeRestart <- base::invokeRestart
[16:12:51.591]                     is.null <- base::is.null
[16:12:51.591]                     muffled <- FALSE
[16:12:51.591]                     if (inherits(cond, "message")) {
[16:12:51.591]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:51.591]                       if (muffled) 
[16:12:51.591]                         invokeRestart("muffleMessage")
[16:12:51.591]                     }
[16:12:51.591]                     else if (inherits(cond, "warning")) {
[16:12:51.591]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:51.591]                       if (muffled) 
[16:12:51.591]                         invokeRestart("muffleWarning")
[16:12:51.591]                     }
[16:12:51.591]                     else if (inherits(cond, "condition")) {
[16:12:51.591]                       if (!is.null(pattern)) {
[16:12:51.591]                         computeRestarts <- base::computeRestarts
[16:12:51.591]                         grepl <- base::grepl
[16:12:51.591]                         restarts <- computeRestarts(cond)
[16:12:51.591]                         for (restart in restarts) {
[16:12:51.591]                           name <- restart$name
[16:12:51.591]                           if (is.null(name)) 
[16:12:51.591]                             next
[16:12:51.591]                           if (!grepl(pattern, name)) 
[16:12:51.591]                             next
[16:12:51.591]                           invokeRestart(restart)
[16:12:51.591]                           muffled <- TRUE
[16:12:51.591]                           break
[16:12:51.591]                         }
[16:12:51.591]                       }
[16:12:51.591]                     }
[16:12:51.591]                     invisible(muffled)
[16:12:51.591]                   }
[16:12:51.591]                   muffleCondition(cond)
[16:12:51.591]                 })
[16:12:51.591]             }))
[16:12:51.591]             future::FutureResult(value = ...future.value$value, 
[16:12:51.591]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.591]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.591]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.591]                     ...future.globalenv.names))
[16:12:51.591]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.591]         }, condition = base::local({
[16:12:51.591]             c <- base::c
[16:12:51.591]             inherits <- base::inherits
[16:12:51.591]             invokeRestart <- base::invokeRestart
[16:12:51.591]             length <- base::length
[16:12:51.591]             list <- base::list
[16:12:51.591]             seq.int <- base::seq.int
[16:12:51.591]             signalCondition <- base::signalCondition
[16:12:51.591]             sys.calls <- base::sys.calls
[16:12:51.591]             `[[` <- base::`[[`
[16:12:51.591]             `+` <- base::`+`
[16:12:51.591]             `<<-` <- base::`<<-`
[16:12:51.591]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.591]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.591]                   3L)]
[16:12:51.591]             }
[16:12:51.591]             function(cond) {
[16:12:51.591]                 is_error <- inherits(cond, "error")
[16:12:51.591]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.591]                   NULL)
[16:12:51.591]                 if (is_error) {
[16:12:51.591]                   sessionInformation <- function() {
[16:12:51.591]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.591]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.591]                       search = base::search(), system = base::Sys.info())
[16:12:51.591]                   }
[16:12:51.591]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.591]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.591]                     cond$call), session = sessionInformation(), 
[16:12:51.591]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.591]                   signalCondition(cond)
[16:12:51.591]                 }
[16:12:51.591]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.591]                 "immediateCondition"))) {
[16:12:51.591]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.591]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.591]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.591]                   if (TRUE && !signal) {
[16:12:51.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.591]                     {
[16:12:51.591]                       inherits <- base::inherits
[16:12:51.591]                       invokeRestart <- base::invokeRestart
[16:12:51.591]                       is.null <- base::is.null
[16:12:51.591]                       muffled <- FALSE
[16:12:51.591]                       if (inherits(cond, "message")) {
[16:12:51.591]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.591]                         if (muffled) 
[16:12:51.591]                           invokeRestart("muffleMessage")
[16:12:51.591]                       }
[16:12:51.591]                       else if (inherits(cond, "warning")) {
[16:12:51.591]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.591]                         if (muffled) 
[16:12:51.591]                           invokeRestart("muffleWarning")
[16:12:51.591]                       }
[16:12:51.591]                       else if (inherits(cond, "condition")) {
[16:12:51.591]                         if (!is.null(pattern)) {
[16:12:51.591]                           computeRestarts <- base::computeRestarts
[16:12:51.591]                           grepl <- base::grepl
[16:12:51.591]                           restarts <- computeRestarts(cond)
[16:12:51.591]                           for (restart in restarts) {
[16:12:51.591]                             name <- restart$name
[16:12:51.591]                             if (is.null(name)) 
[16:12:51.591]                               next
[16:12:51.591]                             if (!grepl(pattern, name)) 
[16:12:51.591]                               next
[16:12:51.591]                             invokeRestart(restart)
[16:12:51.591]                             muffled <- TRUE
[16:12:51.591]                             break
[16:12:51.591]                           }
[16:12:51.591]                         }
[16:12:51.591]                       }
[16:12:51.591]                       invisible(muffled)
[16:12:51.591]                     }
[16:12:51.591]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.591]                   }
[16:12:51.591]                 }
[16:12:51.591]                 else {
[16:12:51.591]                   if (TRUE) {
[16:12:51.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.591]                     {
[16:12:51.591]                       inherits <- base::inherits
[16:12:51.591]                       invokeRestart <- base::invokeRestart
[16:12:51.591]                       is.null <- base::is.null
[16:12:51.591]                       muffled <- FALSE
[16:12:51.591]                       if (inherits(cond, "message")) {
[16:12:51.591]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.591]                         if (muffled) 
[16:12:51.591]                           invokeRestart("muffleMessage")
[16:12:51.591]                       }
[16:12:51.591]                       else if (inherits(cond, "warning")) {
[16:12:51.591]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.591]                         if (muffled) 
[16:12:51.591]                           invokeRestart("muffleWarning")
[16:12:51.591]                       }
[16:12:51.591]                       else if (inherits(cond, "condition")) {
[16:12:51.591]                         if (!is.null(pattern)) {
[16:12:51.591]                           computeRestarts <- base::computeRestarts
[16:12:51.591]                           grepl <- base::grepl
[16:12:51.591]                           restarts <- computeRestarts(cond)
[16:12:51.591]                           for (restart in restarts) {
[16:12:51.591]                             name <- restart$name
[16:12:51.591]                             if (is.null(name)) 
[16:12:51.591]                               next
[16:12:51.591]                             if (!grepl(pattern, name)) 
[16:12:51.591]                               next
[16:12:51.591]                             invokeRestart(restart)
[16:12:51.591]                             muffled <- TRUE
[16:12:51.591]                             break
[16:12:51.591]                           }
[16:12:51.591]                         }
[16:12:51.591]                       }
[16:12:51.591]                       invisible(muffled)
[16:12:51.591]                     }
[16:12:51.591]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.591]                   }
[16:12:51.591]                 }
[16:12:51.591]             }
[16:12:51.591]         }))
[16:12:51.591]     }, error = function(ex) {
[16:12:51.591]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.591]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.591]                 ...future.rng), started = ...future.startTime, 
[16:12:51.591]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.591]             version = "1.8"), class = "FutureResult")
[16:12:51.591]     }, finally = {
[16:12:51.591]         if (!identical(...future.workdir, getwd())) 
[16:12:51.591]             setwd(...future.workdir)
[16:12:51.591]         {
[16:12:51.591]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.591]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.591]             }
[16:12:51.591]             base::options(...future.oldOptions)
[16:12:51.591]             if (.Platform$OS.type == "windows") {
[16:12:51.591]                 old_names <- names(...future.oldEnvVars)
[16:12:51.591]                 envs <- base::Sys.getenv()
[16:12:51.591]                 names <- names(envs)
[16:12:51.591]                 common <- intersect(names, old_names)
[16:12:51.591]                 added <- setdiff(names, old_names)
[16:12:51.591]                 removed <- setdiff(old_names, names)
[16:12:51.591]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.591]                   envs[common]]
[16:12:51.591]                 NAMES <- toupper(changed)
[16:12:51.591]                 args <- list()
[16:12:51.591]                 for (kk in seq_along(NAMES)) {
[16:12:51.591]                   name <- changed[[kk]]
[16:12:51.591]                   NAME <- NAMES[[kk]]
[16:12:51.591]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.591]                     next
[16:12:51.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.591]                 }
[16:12:51.591]                 NAMES <- toupper(added)
[16:12:51.591]                 for (kk in seq_along(NAMES)) {
[16:12:51.591]                   name <- added[[kk]]
[16:12:51.591]                   NAME <- NAMES[[kk]]
[16:12:51.591]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.591]                     next
[16:12:51.591]                   args[[name]] <- ""
[16:12:51.591]                 }
[16:12:51.591]                 NAMES <- toupper(removed)
[16:12:51.591]                 for (kk in seq_along(NAMES)) {
[16:12:51.591]                   name <- removed[[kk]]
[16:12:51.591]                   NAME <- NAMES[[kk]]
[16:12:51.591]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.591]                     next
[16:12:51.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.591]                 }
[16:12:51.591]                 if (length(args) > 0) 
[16:12:51.591]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.591]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.591]             }
[16:12:51.591]             else {
[16:12:51.591]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.591]             }
[16:12:51.591]             {
[16:12:51.591]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.591]                   0L) {
[16:12:51.591]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.591]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.591]                   base::options(opts)
[16:12:51.591]                 }
[16:12:51.591]                 {
[16:12:51.591]                   {
[16:12:51.591]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:51.591]                     NULL
[16:12:51.591]                   }
[16:12:51.591]                   options(future.plan = NULL)
[16:12:51.591]                   if (is.na(NA_character_)) 
[16:12:51.591]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.591]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.591]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:51.591]                     envir = parent.frame()) 
[16:12:51.591]                   {
[16:12:51.591]                     default_workers <- missing(workers)
[16:12:51.591]                     if (is.function(workers)) 
[16:12:51.591]                       workers <- workers()
[16:12:51.591]                     workers <- structure(as.integer(workers), 
[16:12:51.591]                       class = class(workers))
[16:12:51.591]                     stop_if_not(is.finite(workers), workers >= 
[16:12:51.591]                       1L)
[16:12:51.591]                     if ((workers == 1L && !inherits(workers, 
[16:12:51.591]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:51.591]                       if (default_workers) 
[16:12:51.591]                         supportsMulticore(warn = TRUE)
[16:12:51.591]                       return(sequential(..., envir = envir))
[16:12:51.591]                     }
[16:12:51.591]                     oopts <- options(mc.cores = workers)
[16:12:51.591]                     on.exit(options(oopts))
[16:12:51.591]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:51.591]                       envir = envir)
[16:12:51.591]                     if (!future$lazy) 
[16:12:51.591]                       future <- run(future)
[16:12:51.591]                     invisible(future)
[16:12:51.591]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.591]                 }
[16:12:51.591]             }
[16:12:51.591]         }
[16:12:51.591]     })
[16:12:51.591]     if (TRUE) {
[16:12:51.591]         base::sink(type = "output", split = FALSE)
[16:12:51.591]         if (TRUE) {
[16:12:51.591]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.591]         }
[16:12:51.591]         else {
[16:12:51.591]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.591]         }
[16:12:51.591]         base::close(...future.stdout)
[16:12:51.591]         ...future.stdout <- NULL
[16:12:51.591]     }
[16:12:51.591]     ...future.result$conditions <- ...future.conditions
[16:12:51.591]     ...future.result$finished <- base::Sys.time()
[16:12:51.591]     ...future.result
[16:12:51.591] }
[16:12:51.593] assign_globals() ...
[16:12:51.593] List of 1
[16:12:51.593]  $ ii: int 2
[16:12:51.593]  - attr(*, "where")=List of 1
[16:12:51.593]   ..$ ii:<environment: R_EmptyEnv> 
[16:12:51.593]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.593]  - attr(*, "resolved")= logi TRUE
[16:12:51.593]  - attr(*, "total_size")= num 56
[16:12:51.593]  - attr(*, "already-done")= logi TRUE
[16:12:51.597] - copied ‘ii’ to environment
[16:12:51.597] assign_globals() ... done
[16:12:51.597] requestCore(): workers = 2
[16:12:51.599] MulticoreFuture started
[16:12:51.600] - Launch lazy future ... done
[16:12:51.600] run() for ‘MulticoreFuture’ ... done
[16:12:51.600] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.601] List of future strategies:
[16:12:51.601] 1. sequential:
[16:12:51.601]    - args: function (..., envir = parent.frame())
[16:12:51.601]    - tweaked: FALSE
[16:12:51.601]    - call: NULL
[16:12:51.601] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.602] plan(): nbrOfWorkers() = 1
[16:12:51.602] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.604] plan(): Setting new future strategy stack:
[16:12:51.604] List of future strategies:
[16:12:51.604] 1. multicore:
[16:12:51.604]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:51.604]    - tweaked: FALSE
[16:12:51.604]    - call: plan(strategy)
[16:12:51.604] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:51.604] Searching for globals ... DONE
[16:12:51.605] Resolving globals: TRUE
[16:12:51.605] Resolving any globals that are futures ...
[16:12:51.605] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:51.605] Resolving any globals that are futures ... DONE
[16:12:51.606] Resolving futures part of globals (recursively) ...
[16:12:51.606] resolve() on list ...
[16:12:51.607]  recursive: 99
[16:12:51.607]  length: 1
[16:12:51.607]  elements: ‘ii’
[16:12:51.607]  length: 0 (resolved future 1)
[16:12:51.607] resolve() on list ... DONE
[16:12:51.607] - globals: [1] ‘ii’
[16:12:51.607] Resolving futures part of globals (recursively) ... DONE
[16:12:51.608] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:51.608] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:12:51.608] - globals: [1] ‘ii’
[16:12:51.609] plan(): nbrOfWorkers() = 2
[16:12:51.609] 
[16:12:51.609] getGlobalsAndPackages() ... DONE
[16:12:51.609] run() for ‘Future’ ...
[16:12:51.609] - state: ‘created’
[16:12:51.610] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:51.614] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:51.614] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:51.614]   - Field: ‘label’
[16:12:51.614]   - Field: ‘local’
[16:12:51.615]   - Field: ‘owner’
[16:12:51.615]   - Field: ‘envir’
[16:12:51.615]   - Field: ‘workers’
[16:12:51.618]   - Field: ‘packages’
[16:12:51.618]   - Field: ‘gc’
[16:12:51.619]   - Field: ‘job’
[16:12:51.619]   - Field: ‘conditions’
[16:12:51.619]   - Field: ‘expr’
[16:12:51.620]   - Field: ‘uuid’
[16:12:51.620]   - Field: ‘seed’
[16:12:51.620]   - Field: ‘version’
[16:12:51.620]   - Field: ‘result’
[16:12:51.621]   - Field: ‘asynchronous’
[16:12:51.621]   - Field: ‘calls’
[16:12:51.621]   - Field: ‘globals’
[16:12:51.621]   - Field: ‘stdout’
[16:12:51.621]   - Field: ‘earlySignal’
[16:12:51.622]   - Field: ‘lazy’
[16:12:51.622]   - Field: ‘state’
[16:12:51.622] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:51.622] - Launch lazy future ...
[16:12:51.623] Packages needed by the future expression (n = 0): <none>
[16:12:51.623] Packages needed by future strategies (n = 0): <none>
[16:12:51.624] {
[16:12:51.624]     {
[16:12:51.624]         {
[16:12:51.624]             ...future.startTime <- base::Sys.time()
[16:12:51.624]             {
[16:12:51.624]                 {
[16:12:51.624]                   {
[16:12:51.624]                     {
[16:12:51.624]                       base::local({
[16:12:51.624]                         has_future <- base::requireNamespace("future", 
[16:12:51.624]                           quietly = TRUE)
[16:12:51.624]                         if (has_future) {
[16:12:51.624]                           ns <- base::getNamespace("future")
[16:12:51.624]                           version <- ns[[".package"]][["version"]]
[16:12:51.624]                           if (is.null(version)) 
[16:12:51.624]                             version <- utils::packageVersion("future")
[16:12:51.624]                         }
[16:12:51.624]                         else {
[16:12:51.624]                           version <- NULL
[16:12:51.624]                         }
[16:12:51.624]                         if (!has_future || version < "1.8.0") {
[16:12:51.624]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.624]                             "", base::R.version$version.string), 
[16:12:51.624]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:51.624]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.624]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.624]                               "release", "version")], collapse = " "), 
[16:12:51.624]                             hostname = base::Sys.info()[["nodename"]])
[16:12:51.624]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.624]                             info)
[16:12:51.624]                           info <- base::paste(info, collapse = "; ")
[16:12:51.624]                           if (!has_future) {
[16:12:51.624]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.624]                               info)
[16:12:51.624]                           }
[16:12:51.624]                           else {
[16:12:51.624]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.624]                               info, version)
[16:12:51.624]                           }
[16:12:51.624]                           base::stop(msg)
[16:12:51.624]                         }
[16:12:51.624]                       })
[16:12:51.624]                     }
[16:12:51.624]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:51.624]                     base::options(mc.cores = 1L)
[16:12:51.624]                   }
[16:12:51.624]                   options(future.plan = NULL)
[16:12:51.624]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.624]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.624]                 }
[16:12:51.624]                 ...future.workdir <- getwd()
[16:12:51.624]             }
[16:12:51.624]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.624]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.624]         }
[16:12:51.624]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.624]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:51.624]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.624]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.624]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.624]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.624]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.624]             base::names(...future.oldOptions))
[16:12:51.624]     }
[16:12:51.624]     if (FALSE) {
[16:12:51.624]     }
[16:12:51.624]     else {
[16:12:51.624]         if (TRUE) {
[16:12:51.624]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.624]                 open = "w")
[16:12:51.624]         }
[16:12:51.624]         else {
[16:12:51.624]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.624]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.624]         }
[16:12:51.624]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.624]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.624]             base::sink(type = "output", split = FALSE)
[16:12:51.624]             base::close(...future.stdout)
[16:12:51.624]         }, add = TRUE)
[16:12:51.624]     }
[16:12:51.624]     ...future.frame <- base::sys.nframe()
[16:12:51.624]     ...future.conditions <- base::list()
[16:12:51.624]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.624]     if (FALSE) {
[16:12:51.624]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.624]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.624]     }
[16:12:51.624]     ...future.result <- base::tryCatch({
[16:12:51.624]         base::withCallingHandlers({
[16:12:51.624]             ...future.value <- base::withVisible(base::local({
[16:12:51.624]                 withCallingHandlers({
[16:12:51.624]                   {
[16:12:51.624]                     b <- a * ii
[16:12:51.624]                     a <- 0
[16:12:51.624]                     b
[16:12:51.624]                   }
[16:12:51.624]                 }, immediateCondition = function(cond) {
[16:12:51.624]                   save_rds <- function (object, pathname, ...) 
[16:12:51.624]                   {
[16:12:51.624]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:51.624]                     if (file_test("-f", pathname_tmp)) {
[16:12:51.624]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.624]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:51.624]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.624]                         fi_tmp[["mtime"]])
[16:12:51.624]                     }
[16:12:51.624]                     tryCatch({
[16:12:51.624]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:51.624]                     }, error = function(ex) {
[16:12:51.624]                       msg <- conditionMessage(ex)
[16:12:51.624]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.624]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:51.624]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.624]                         fi_tmp[["mtime"]], msg)
[16:12:51.624]                       ex$message <- msg
[16:12:51.624]                       stop(ex)
[16:12:51.624]                     })
[16:12:51.624]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:51.624]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:51.624]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:51.624]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.624]                       fi <- file.info(pathname)
[16:12:51.624]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:51.624]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.624]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:51.624]                         fi[["size"]], fi[["mtime"]])
[16:12:51.624]                       stop(msg)
[16:12:51.624]                     }
[16:12:51.624]                     invisible(pathname)
[16:12:51.624]                   }
[16:12:51.624]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:51.624]                     rootPath = tempdir()) 
[16:12:51.624]                   {
[16:12:51.624]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:51.624]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:51.624]                       tmpdir = path, fileext = ".rds")
[16:12:51.624]                     save_rds(obj, file)
[16:12:51.624]                   }
[16:12:51.624]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:51.624]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.624]                   {
[16:12:51.624]                     inherits <- base::inherits
[16:12:51.624]                     invokeRestart <- base::invokeRestart
[16:12:51.624]                     is.null <- base::is.null
[16:12:51.624]                     muffled <- FALSE
[16:12:51.624]                     if (inherits(cond, "message")) {
[16:12:51.624]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:51.624]                       if (muffled) 
[16:12:51.624]                         invokeRestart("muffleMessage")
[16:12:51.624]                     }
[16:12:51.624]                     else if (inherits(cond, "warning")) {
[16:12:51.624]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:51.624]                       if (muffled) 
[16:12:51.624]                         invokeRestart("muffleWarning")
[16:12:51.624]                     }
[16:12:51.624]                     else if (inherits(cond, "condition")) {
[16:12:51.624]                       if (!is.null(pattern)) {
[16:12:51.624]                         computeRestarts <- base::computeRestarts
[16:12:51.624]                         grepl <- base::grepl
[16:12:51.624]                         restarts <- computeRestarts(cond)
[16:12:51.624]                         for (restart in restarts) {
[16:12:51.624]                           name <- restart$name
[16:12:51.624]                           if (is.null(name)) 
[16:12:51.624]                             next
[16:12:51.624]                           if (!grepl(pattern, name)) 
[16:12:51.624]                             next
[16:12:51.624]                           invokeRestart(restart)
[16:12:51.624]                           muffled <- TRUE
[16:12:51.624]                           break
[16:12:51.624]                         }
[16:12:51.624]                       }
[16:12:51.624]                     }
[16:12:51.624]                     invisible(muffled)
[16:12:51.624]                   }
[16:12:51.624]                   muffleCondition(cond)
[16:12:51.624]                 })
[16:12:51.624]             }))
[16:12:51.624]             future::FutureResult(value = ...future.value$value, 
[16:12:51.624]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.624]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.624]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.624]                     ...future.globalenv.names))
[16:12:51.624]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.624]         }, condition = base::local({
[16:12:51.624]             c <- base::c
[16:12:51.624]             inherits <- base::inherits
[16:12:51.624]             invokeRestart <- base::invokeRestart
[16:12:51.624]             length <- base::length
[16:12:51.624]             list <- base::list
[16:12:51.624]             seq.int <- base::seq.int
[16:12:51.624]             signalCondition <- base::signalCondition
[16:12:51.624]             sys.calls <- base::sys.calls
[16:12:51.624]             `[[` <- base::`[[`
[16:12:51.624]             `+` <- base::`+`
[16:12:51.624]             `<<-` <- base::`<<-`
[16:12:51.624]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.624]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.624]                   3L)]
[16:12:51.624]             }
[16:12:51.624]             function(cond) {
[16:12:51.624]                 is_error <- inherits(cond, "error")
[16:12:51.624]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.624]                   NULL)
[16:12:51.624]                 if (is_error) {
[16:12:51.624]                   sessionInformation <- function() {
[16:12:51.624]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.624]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.624]                       search = base::search(), system = base::Sys.info())
[16:12:51.624]                   }
[16:12:51.624]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.624]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.624]                     cond$call), session = sessionInformation(), 
[16:12:51.624]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.624]                   signalCondition(cond)
[16:12:51.624]                 }
[16:12:51.624]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.624]                 "immediateCondition"))) {
[16:12:51.624]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.624]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.624]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.624]                   if (TRUE && !signal) {
[16:12:51.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.624]                     {
[16:12:51.624]                       inherits <- base::inherits
[16:12:51.624]                       invokeRestart <- base::invokeRestart
[16:12:51.624]                       is.null <- base::is.null
[16:12:51.624]                       muffled <- FALSE
[16:12:51.624]                       if (inherits(cond, "message")) {
[16:12:51.624]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.624]                         if (muffled) 
[16:12:51.624]                           invokeRestart("muffleMessage")
[16:12:51.624]                       }
[16:12:51.624]                       else if (inherits(cond, "warning")) {
[16:12:51.624]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.624]                         if (muffled) 
[16:12:51.624]                           invokeRestart("muffleWarning")
[16:12:51.624]                       }
[16:12:51.624]                       else if (inherits(cond, "condition")) {
[16:12:51.624]                         if (!is.null(pattern)) {
[16:12:51.624]                           computeRestarts <- base::computeRestarts
[16:12:51.624]                           grepl <- base::grepl
[16:12:51.624]                           restarts <- computeRestarts(cond)
[16:12:51.624]                           for (restart in restarts) {
[16:12:51.624]                             name <- restart$name
[16:12:51.624]                             if (is.null(name)) 
[16:12:51.624]                               next
[16:12:51.624]                             if (!grepl(pattern, name)) 
[16:12:51.624]                               next
[16:12:51.624]                             invokeRestart(restart)
[16:12:51.624]                             muffled <- TRUE
[16:12:51.624]                             break
[16:12:51.624]                           }
[16:12:51.624]                         }
[16:12:51.624]                       }
[16:12:51.624]                       invisible(muffled)
[16:12:51.624]                     }
[16:12:51.624]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.624]                   }
[16:12:51.624]                 }
[16:12:51.624]                 else {
[16:12:51.624]                   if (TRUE) {
[16:12:51.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.624]                     {
[16:12:51.624]                       inherits <- base::inherits
[16:12:51.624]                       invokeRestart <- base::invokeRestart
[16:12:51.624]                       is.null <- base::is.null
[16:12:51.624]                       muffled <- FALSE
[16:12:51.624]                       if (inherits(cond, "message")) {
[16:12:51.624]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.624]                         if (muffled) 
[16:12:51.624]                           invokeRestart("muffleMessage")
[16:12:51.624]                       }
[16:12:51.624]                       else if (inherits(cond, "warning")) {
[16:12:51.624]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.624]                         if (muffled) 
[16:12:51.624]                           invokeRestart("muffleWarning")
[16:12:51.624]                       }
[16:12:51.624]                       else if (inherits(cond, "condition")) {
[16:12:51.624]                         if (!is.null(pattern)) {
[16:12:51.624]                           computeRestarts <- base::computeRestarts
[16:12:51.624]                           grepl <- base::grepl
[16:12:51.624]                           restarts <- computeRestarts(cond)
[16:12:51.624]                           for (restart in restarts) {
[16:12:51.624]                             name <- restart$name
[16:12:51.624]                             if (is.null(name)) 
[16:12:51.624]                               next
[16:12:51.624]                             if (!grepl(pattern, name)) 
[16:12:51.624]                               next
[16:12:51.624]                             invokeRestart(restart)
[16:12:51.624]                             muffled <- TRUE
[16:12:51.624]                             break
[16:12:51.624]                           }
[16:12:51.624]                         }
[16:12:51.624]                       }
[16:12:51.624]                       invisible(muffled)
[16:12:51.624]                     }
[16:12:51.624]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.624]                   }
[16:12:51.624]                 }
[16:12:51.624]             }
[16:12:51.624]         }))
[16:12:51.624]     }, error = function(ex) {
[16:12:51.624]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.624]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.624]                 ...future.rng), started = ...future.startTime, 
[16:12:51.624]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.624]             version = "1.8"), class = "FutureResult")
[16:12:51.624]     }, finally = {
[16:12:51.624]         if (!identical(...future.workdir, getwd())) 
[16:12:51.624]             setwd(...future.workdir)
[16:12:51.624]         {
[16:12:51.624]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.624]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.624]             }
[16:12:51.624]             base::options(...future.oldOptions)
[16:12:51.624]             if (.Platform$OS.type == "windows") {
[16:12:51.624]                 old_names <- names(...future.oldEnvVars)
[16:12:51.624]                 envs <- base::Sys.getenv()
[16:12:51.624]                 names <- names(envs)
[16:12:51.624]                 common <- intersect(names, old_names)
[16:12:51.624]                 added <- setdiff(names, old_names)
[16:12:51.624]                 removed <- setdiff(old_names, names)
[16:12:51.624]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.624]                   envs[common]]
[16:12:51.624]                 NAMES <- toupper(changed)
[16:12:51.624]                 args <- list()
[16:12:51.624]                 for (kk in seq_along(NAMES)) {
[16:12:51.624]                   name <- changed[[kk]]
[16:12:51.624]                   NAME <- NAMES[[kk]]
[16:12:51.624]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.624]                     next
[16:12:51.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.624]                 }
[16:12:51.624]                 NAMES <- toupper(added)
[16:12:51.624]                 for (kk in seq_along(NAMES)) {
[16:12:51.624]                   name <- added[[kk]]
[16:12:51.624]                   NAME <- NAMES[[kk]]
[16:12:51.624]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.624]                     next
[16:12:51.624]                   args[[name]] <- ""
[16:12:51.624]                 }
[16:12:51.624]                 NAMES <- toupper(removed)
[16:12:51.624]                 for (kk in seq_along(NAMES)) {
[16:12:51.624]                   name <- removed[[kk]]
[16:12:51.624]                   NAME <- NAMES[[kk]]
[16:12:51.624]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.624]                     next
[16:12:51.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.624]                 }
[16:12:51.624]                 if (length(args) > 0) 
[16:12:51.624]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.624]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.624]             }
[16:12:51.624]             else {
[16:12:51.624]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.624]             }
[16:12:51.624]             {
[16:12:51.624]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.624]                   0L) {
[16:12:51.624]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.624]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.624]                   base::options(opts)
[16:12:51.624]                 }
[16:12:51.624]                 {
[16:12:51.624]                   {
[16:12:51.624]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:51.624]                     NULL
[16:12:51.624]                   }
[16:12:51.624]                   options(future.plan = NULL)
[16:12:51.624]                   if (is.na(NA_character_)) 
[16:12:51.624]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.624]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.624]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:51.624]                     envir = parent.frame()) 
[16:12:51.624]                   {
[16:12:51.624]                     default_workers <- missing(workers)
[16:12:51.624]                     if (is.function(workers)) 
[16:12:51.624]                       workers <- workers()
[16:12:51.624]                     workers <- structure(as.integer(workers), 
[16:12:51.624]                       class = class(workers))
[16:12:51.624]                     stop_if_not(is.finite(workers), workers >= 
[16:12:51.624]                       1L)
[16:12:51.624]                     if ((workers == 1L && !inherits(workers, 
[16:12:51.624]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:51.624]                       if (default_workers) 
[16:12:51.624]                         supportsMulticore(warn = TRUE)
[16:12:51.624]                       return(sequential(..., envir = envir))
[16:12:51.624]                     }
[16:12:51.624]                     oopts <- options(mc.cores = workers)
[16:12:51.624]                     on.exit(options(oopts))
[16:12:51.624]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:51.624]                       envir = envir)
[16:12:51.624]                     if (!future$lazy) 
[16:12:51.624]                       future <- run(future)
[16:12:51.624]                     invisible(future)
[16:12:51.624]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.624]                 }
[16:12:51.624]             }
[16:12:51.624]         }
[16:12:51.624]     })
[16:12:51.624]     if (TRUE) {
[16:12:51.624]         base::sink(type = "output", split = FALSE)
[16:12:51.624]         if (TRUE) {
[16:12:51.624]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.624]         }
[16:12:51.624]         else {
[16:12:51.624]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.624]         }
[16:12:51.624]         base::close(...future.stdout)
[16:12:51.624]         ...future.stdout <- NULL
[16:12:51.624]     }
[16:12:51.624]     ...future.result$conditions <- ...future.conditions
[16:12:51.624]     ...future.result$finished <- base::Sys.time()
[16:12:51.624]     ...future.result
[16:12:51.624] }
[16:12:51.627] assign_globals() ...
[16:12:51.627] List of 1
[16:12:51.627]  $ ii: int 3
[16:12:51.627]  - attr(*, "where")=List of 1
[16:12:51.627]   ..$ ii:<environment: R_EmptyEnv> 
[16:12:51.627]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.627]  - attr(*, "resolved")= logi TRUE
[16:12:51.627]  - attr(*, "total_size")= num 56
[16:12:51.627]  - attr(*, "already-done")= logi TRUE
[16:12:51.631] - copied ‘ii’ to environment
[16:12:51.631] assign_globals() ... done
[16:12:51.631] requestCore(): workers = 2
[16:12:51.631] Poll #1 (0): usedCores() = 2, workers = 2
[16:12:51.646] MulticoreFuture started
[16:12:51.647] - Launch lazy future ... done
[16:12:51.647] run() for ‘MulticoreFuture’ ... done
[16:12:51.648] plan(): Setting new future strategy stack:
[16:12:51.648] List of future strategies:
[16:12:51.648] 1. sequential:
[16:12:51.648]    - args: function (..., envir = parent.frame())
[16:12:51.648]    - tweaked: FALSE
[16:12:51.648]    - call: NULL
[16:12:51.649] plan(): nbrOfWorkers() = 1
[16:12:51.652] plan(): Setting new future strategy stack:
[16:12:51.652] List of future strategies:
[16:12:51.652] 1. multicore:
[16:12:51.652]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:51.652]    - tweaked: FALSE
[16:12:51.652]    - call: plan(strategy)
[16:12:51.658] plan(): nbrOfWorkers() = 2
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.660] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.660] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.662] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:51.662] Searching for globals ... DONE
[16:12:51.662] Resolving globals: TRUE
[16:12:51.663] Resolving any globals that are futures ...
[16:12:51.663] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:51.663] Resolving any globals that are futures ... DONE
[16:12:51.663] Resolving futures part of globals (recursively) ...
[16:12:51.664] resolve() on list ...
[16:12:51.664]  recursive: 99
[16:12:51.664]  length: 1
[16:12:51.664]  elements: ‘ii’
[16:12:51.664]  length: 0 (resolved future 1)
[16:12:51.664] resolve() on list ... DONE
[16:12:51.664] - globals: [1] ‘ii’
[16:12:51.664] Resolving futures part of globals (recursively) ... DONE
[16:12:51.665] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:51.665] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:12:51.665] - globals: [1] ‘ii’
[16:12:51.665] 
[16:12:51.665] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.666] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.666] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.668] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:51.668] Searching for globals ... DONE
[16:12:51.668] Resolving globals: TRUE
[16:12:51.668] Resolving any globals that are futures ...
[16:12:51.669] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:51.669] Resolving any globals that are futures ... DONE
[16:12:51.669] Resolving futures part of globals (recursively) ...
[16:12:51.669] resolve() on list ...
[16:12:51.669]  recursive: 99
[16:12:51.670]  length: 1
[16:12:51.670]  elements: ‘ii’
[16:12:51.670]  length: 0 (resolved future 1)
[16:12:51.670] resolve() on list ... DONE
[16:12:51.670] - globals: [1] ‘ii’
[16:12:51.670] Resolving futures part of globals (recursively) ... DONE
[16:12:51.670] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:51.671] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:12:51.671] - globals: [1] ‘ii’
[16:12:51.671] 
[16:12:51.671] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.672] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.672] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.673] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:51.676] Searching for globals ... DONE
[16:12:51.676] Resolving globals: TRUE
[16:12:51.676] Resolving any globals that are futures ...
[16:12:51.676] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:51.677] Resolving any globals that are futures ... DONE
[16:12:51.677] Resolving futures part of globals (recursively) ...
[16:12:51.677] resolve() on list ...
[16:12:51.678]  recursive: 99
[16:12:51.678]  length: 1
[16:12:51.678]  elements: ‘ii’
[16:12:51.678]  length: 0 (resolved future 1)
[16:12:51.678] resolve() on list ... DONE
[16:12:51.678] - globals: [1] ‘ii’
[16:12:51.678] Resolving futures part of globals (recursively) ... DONE
[16:12:51.679] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:51.679] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:12:51.679] - globals: [1] ‘ii’
[16:12:51.679] 
[16:12:51.679] getGlobalsAndPackages() ... DONE
[16:12:51.680] run() for ‘Future’ ...
[16:12:51.680] - state: ‘created’
[16:12:51.680] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:51.684] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:51.684] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:51.684]   - Field: ‘label’
[16:12:51.685]   - Field: ‘local’
[16:12:51.685]   - Field: ‘owner’
[16:12:51.685]   - Field: ‘envir’
[16:12:51.685]   - Field: ‘workers’
[16:12:51.685]   - Field: ‘packages’
[16:12:51.685]   - Field: ‘gc’
[16:12:51.685]   - Field: ‘job’
[16:12:51.685]   - Field: ‘conditions’
[16:12:51.686]   - Field: ‘expr’
[16:12:51.686]   - Field: ‘uuid’
[16:12:51.686]   - Field: ‘seed’
[16:12:51.686]   - Field: ‘version’
[16:12:51.686]   - Field: ‘result’
[16:12:51.686]   - Field: ‘asynchronous’
[16:12:51.686]   - Field: ‘calls’
[16:12:51.686]   - Field: ‘globals’
[16:12:51.686]   - Field: ‘stdout’
[16:12:51.686]   - Field: ‘earlySignal’
[16:12:51.687]   - Field: ‘lazy’
[16:12:51.687]   - Field: ‘state’
[16:12:51.687] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:51.687] - Launch lazy future ...
[16:12:51.687] Packages needed by the future expression (n = 0): <none>
[16:12:51.687] Packages needed by future strategies (n = 0): <none>
[16:12:51.688] {
[16:12:51.688]     {
[16:12:51.688]         {
[16:12:51.688]             ...future.startTime <- base::Sys.time()
[16:12:51.688]             {
[16:12:51.688]                 {
[16:12:51.688]                   {
[16:12:51.688]                     {
[16:12:51.688]                       base::local({
[16:12:51.688]                         has_future <- base::requireNamespace("future", 
[16:12:51.688]                           quietly = TRUE)
[16:12:51.688]                         if (has_future) {
[16:12:51.688]                           ns <- base::getNamespace("future")
[16:12:51.688]                           version <- ns[[".package"]][["version"]]
[16:12:51.688]                           if (is.null(version)) 
[16:12:51.688]                             version <- utils::packageVersion("future")
[16:12:51.688]                         }
[16:12:51.688]                         else {
[16:12:51.688]                           version <- NULL
[16:12:51.688]                         }
[16:12:51.688]                         if (!has_future || version < "1.8.0") {
[16:12:51.688]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.688]                             "", base::R.version$version.string), 
[16:12:51.688]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:51.688]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.688]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.688]                               "release", "version")], collapse = " "), 
[16:12:51.688]                             hostname = base::Sys.info()[["nodename"]])
[16:12:51.688]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.688]                             info)
[16:12:51.688]                           info <- base::paste(info, collapse = "; ")
[16:12:51.688]                           if (!has_future) {
[16:12:51.688]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.688]                               info)
[16:12:51.688]                           }
[16:12:51.688]                           else {
[16:12:51.688]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.688]                               info, version)
[16:12:51.688]                           }
[16:12:51.688]                           base::stop(msg)
[16:12:51.688]                         }
[16:12:51.688]                       })
[16:12:51.688]                     }
[16:12:51.688]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:51.688]                     base::options(mc.cores = 1L)
[16:12:51.688]                   }
[16:12:51.688]                   options(future.plan = NULL)
[16:12:51.688]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.688]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.688]                 }
[16:12:51.688]                 ...future.workdir <- getwd()
[16:12:51.688]             }
[16:12:51.688]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.688]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.688]         }
[16:12:51.688]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.688]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:51.688]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.688]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.688]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.688]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.688]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.688]             base::names(...future.oldOptions))
[16:12:51.688]     }
[16:12:51.688]     if (FALSE) {
[16:12:51.688]     }
[16:12:51.688]     else {
[16:12:51.688]         if (TRUE) {
[16:12:51.688]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.688]                 open = "w")
[16:12:51.688]         }
[16:12:51.688]         else {
[16:12:51.688]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.688]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.688]         }
[16:12:51.688]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.688]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.688]             base::sink(type = "output", split = FALSE)
[16:12:51.688]             base::close(...future.stdout)
[16:12:51.688]         }, add = TRUE)
[16:12:51.688]     }
[16:12:51.688]     ...future.frame <- base::sys.nframe()
[16:12:51.688]     ...future.conditions <- base::list()
[16:12:51.688]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.688]     if (FALSE) {
[16:12:51.688]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.688]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.688]     }
[16:12:51.688]     ...future.result <- base::tryCatch({
[16:12:51.688]         base::withCallingHandlers({
[16:12:51.688]             ...future.value <- base::withVisible(base::local({
[16:12:51.688]                 withCallingHandlers({
[16:12:51.688]                   {
[16:12:51.688]                     b <- a * ii
[16:12:51.688]                     a <- 0
[16:12:51.688]                     b
[16:12:51.688]                   }
[16:12:51.688]                 }, immediateCondition = function(cond) {
[16:12:51.688]                   save_rds <- function (object, pathname, ...) 
[16:12:51.688]                   {
[16:12:51.688]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:51.688]                     if (file_test("-f", pathname_tmp)) {
[16:12:51.688]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.688]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:51.688]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.688]                         fi_tmp[["mtime"]])
[16:12:51.688]                     }
[16:12:51.688]                     tryCatch({
[16:12:51.688]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:51.688]                     }, error = function(ex) {
[16:12:51.688]                       msg <- conditionMessage(ex)
[16:12:51.688]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.688]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:51.688]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.688]                         fi_tmp[["mtime"]], msg)
[16:12:51.688]                       ex$message <- msg
[16:12:51.688]                       stop(ex)
[16:12:51.688]                     })
[16:12:51.688]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:51.688]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:51.688]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:51.688]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.688]                       fi <- file.info(pathname)
[16:12:51.688]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:51.688]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.688]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:51.688]                         fi[["size"]], fi[["mtime"]])
[16:12:51.688]                       stop(msg)
[16:12:51.688]                     }
[16:12:51.688]                     invisible(pathname)
[16:12:51.688]                   }
[16:12:51.688]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:51.688]                     rootPath = tempdir()) 
[16:12:51.688]                   {
[16:12:51.688]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:51.688]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:51.688]                       tmpdir = path, fileext = ".rds")
[16:12:51.688]                     save_rds(obj, file)
[16:12:51.688]                   }
[16:12:51.688]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:51.688]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.688]                   {
[16:12:51.688]                     inherits <- base::inherits
[16:12:51.688]                     invokeRestart <- base::invokeRestart
[16:12:51.688]                     is.null <- base::is.null
[16:12:51.688]                     muffled <- FALSE
[16:12:51.688]                     if (inherits(cond, "message")) {
[16:12:51.688]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:51.688]                       if (muffled) 
[16:12:51.688]                         invokeRestart("muffleMessage")
[16:12:51.688]                     }
[16:12:51.688]                     else if (inherits(cond, "warning")) {
[16:12:51.688]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:51.688]                       if (muffled) 
[16:12:51.688]                         invokeRestart("muffleWarning")
[16:12:51.688]                     }
[16:12:51.688]                     else if (inherits(cond, "condition")) {
[16:12:51.688]                       if (!is.null(pattern)) {
[16:12:51.688]                         computeRestarts <- base::computeRestarts
[16:12:51.688]                         grepl <- base::grepl
[16:12:51.688]                         restarts <- computeRestarts(cond)
[16:12:51.688]                         for (restart in restarts) {
[16:12:51.688]                           name <- restart$name
[16:12:51.688]                           if (is.null(name)) 
[16:12:51.688]                             next
[16:12:51.688]                           if (!grepl(pattern, name)) 
[16:12:51.688]                             next
[16:12:51.688]                           invokeRestart(restart)
[16:12:51.688]                           muffled <- TRUE
[16:12:51.688]                           break
[16:12:51.688]                         }
[16:12:51.688]                       }
[16:12:51.688]                     }
[16:12:51.688]                     invisible(muffled)
[16:12:51.688]                   }
[16:12:51.688]                   muffleCondition(cond)
[16:12:51.688]                 })
[16:12:51.688]             }))
[16:12:51.688]             future::FutureResult(value = ...future.value$value, 
[16:12:51.688]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.688]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.688]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.688]                     ...future.globalenv.names))
[16:12:51.688]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.688]         }, condition = base::local({
[16:12:51.688]             c <- base::c
[16:12:51.688]             inherits <- base::inherits
[16:12:51.688]             invokeRestart <- base::invokeRestart
[16:12:51.688]             length <- base::length
[16:12:51.688]             list <- base::list
[16:12:51.688]             seq.int <- base::seq.int
[16:12:51.688]             signalCondition <- base::signalCondition
[16:12:51.688]             sys.calls <- base::sys.calls
[16:12:51.688]             `[[` <- base::`[[`
[16:12:51.688]             `+` <- base::`+`
[16:12:51.688]             `<<-` <- base::`<<-`
[16:12:51.688]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.688]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.688]                   3L)]
[16:12:51.688]             }
[16:12:51.688]             function(cond) {
[16:12:51.688]                 is_error <- inherits(cond, "error")
[16:12:51.688]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.688]                   NULL)
[16:12:51.688]                 if (is_error) {
[16:12:51.688]                   sessionInformation <- function() {
[16:12:51.688]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.688]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.688]                       search = base::search(), system = base::Sys.info())
[16:12:51.688]                   }
[16:12:51.688]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.688]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.688]                     cond$call), session = sessionInformation(), 
[16:12:51.688]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.688]                   signalCondition(cond)
[16:12:51.688]                 }
[16:12:51.688]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.688]                 "immediateCondition"))) {
[16:12:51.688]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.688]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.688]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.688]                   if (TRUE && !signal) {
[16:12:51.688]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.688]                     {
[16:12:51.688]                       inherits <- base::inherits
[16:12:51.688]                       invokeRestart <- base::invokeRestart
[16:12:51.688]                       is.null <- base::is.null
[16:12:51.688]                       muffled <- FALSE
[16:12:51.688]                       if (inherits(cond, "message")) {
[16:12:51.688]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.688]                         if (muffled) 
[16:12:51.688]                           invokeRestart("muffleMessage")
[16:12:51.688]                       }
[16:12:51.688]                       else if (inherits(cond, "warning")) {
[16:12:51.688]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.688]                         if (muffled) 
[16:12:51.688]                           invokeRestart("muffleWarning")
[16:12:51.688]                       }
[16:12:51.688]                       else if (inherits(cond, "condition")) {
[16:12:51.688]                         if (!is.null(pattern)) {
[16:12:51.688]                           computeRestarts <- base::computeRestarts
[16:12:51.688]                           grepl <- base::grepl
[16:12:51.688]                           restarts <- computeRestarts(cond)
[16:12:51.688]                           for (restart in restarts) {
[16:12:51.688]                             name <- restart$name
[16:12:51.688]                             if (is.null(name)) 
[16:12:51.688]                               next
[16:12:51.688]                             if (!grepl(pattern, name)) 
[16:12:51.688]                               next
[16:12:51.688]                             invokeRestart(restart)
[16:12:51.688]                             muffled <- TRUE
[16:12:51.688]                             break
[16:12:51.688]                           }
[16:12:51.688]                         }
[16:12:51.688]                       }
[16:12:51.688]                       invisible(muffled)
[16:12:51.688]                     }
[16:12:51.688]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.688]                   }
[16:12:51.688]                 }
[16:12:51.688]                 else {
[16:12:51.688]                   if (TRUE) {
[16:12:51.688]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.688]                     {
[16:12:51.688]                       inherits <- base::inherits
[16:12:51.688]                       invokeRestart <- base::invokeRestart
[16:12:51.688]                       is.null <- base::is.null
[16:12:51.688]                       muffled <- FALSE
[16:12:51.688]                       if (inherits(cond, "message")) {
[16:12:51.688]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.688]                         if (muffled) 
[16:12:51.688]                           invokeRestart("muffleMessage")
[16:12:51.688]                       }
[16:12:51.688]                       else if (inherits(cond, "warning")) {
[16:12:51.688]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.688]                         if (muffled) 
[16:12:51.688]                           invokeRestart("muffleWarning")
[16:12:51.688]                       }
[16:12:51.688]                       else if (inherits(cond, "condition")) {
[16:12:51.688]                         if (!is.null(pattern)) {
[16:12:51.688]                           computeRestarts <- base::computeRestarts
[16:12:51.688]                           grepl <- base::grepl
[16:12:51.688]                           restarts <- computeRestarts(cond)
[16:12:51.688]                           for (restart in restarts) {
[16:12:51.688]                             name <- restart$name
[16:12:51.688]                             if (is.null(name)) 
[16:12:51.688]                               next
[16:12:51.688]                             if (!grepl(pattern, name)) 
[16:12:51.688]                               next
[16:12:51.688]                             invokeRestart(restart)
[16:12:51.688]                             muffled <- TRUE
[16:12:51.688]                             break
[16:12:51.688]                           }
[16:12:51.688]                         }
[16:12:51.688]                       }
[16:12:51.688]                       invisible(muffled)
[16:12:51.688]                     }
[16:12:51.688]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.688]                   }
[16:12:51.688]                 }
[16:12:51.688]             }
[16:12:51.688]         }))
[16:12:51.688]     }, error = function(ex) {
[16:12:51.688]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.688]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.688]                 ...future.rng), started = ...future.startTime, 
[16:12:51.688]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.688]             version = "1.8"), class = "FutureResult")
[16:12:51.688]     }, finally = {
[16:12:51.688]         if (!identical(...future.workdir, getwd())) 
[16:12:51.688]             setwd(...future.workdir)
[16:12:51.688]         {
[16:12:51.688]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.688]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.688]             }
[16:12:51.688]             base::options(...future.oldOptions)
[16:12:51.688]             if (.Platform$OS.type == "windows") {
[16:12:51.688]                 old_names <- names(...future.oldEnvVars)
[16:12:51.688]                 envs <- base::Sys.getenv()
[16:12:51.688]                 names <- names(envs)
[16:12:51.688]                 common <- intersect(names, old_names)
[16:12:51.688]                 added <- setdiff(names, old_names)
[16:12:51.688]                 removed <- setdiff(old_names, names)
[16:12:51.688]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.688]                   envs[common]]
[16:12:51.688]                 NAMES <- toupper(changed)
[16:12:51.688]                 args <- list()
[16:12:51.688]                 for (kk in seq_along(NAMES)) {
[16:12:51.688]                   name <- changed[[kk]]
[16:12:51.688]                   NAME <- NAMES[[kk]]
[16:12:51.688]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.688]                     next
[16:12:51.688]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.688]                 }
[16:12:51.688]                 NAMES <- toupper(added)
[16:12:51.688]                 for (kk in seq_along(NAMES)) {
[16:12:51.688]                   name <- added[[kk]]
[16:12:51.688]                   NAME <- NAMES[[kk]]
[16:12:51.688]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.688]                     next
[16:12:51.688]                   args[[name]] <- ""
[16:12:51.688]                 }
[16:12:51.688]                 NAMES <- toupper(removed)
[16:12:51.688]                 for (kk in seq_along(NAMES)) {
[16:12:51.688]                   name <- removed[[kk]]
[16:12:51.688]                   NAME <- NAMES[[kk]]
[16:12:51.688]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.688]                     next
[16:12:51.688]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.688]                 }
[16:12:51.688]                 if (length(args) > 0) 
[16:12:51.688]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.688]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.688]             }
[16:12:51.688]             else {
[16:12:51.688]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.688]             }
[16:12:51.688]             {
[16:12:51.688]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.688]                   0L) {
[16:12:51.688]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.688]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.688]                   base::options(opts)
[16:12:51.688]                 }
[16:12:51.688]                 {
[16:12:51.688]                   {
[16:12:51.688]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:51.688]                     NULL
[16:12:51.688]                   }
[16:12:51.688]                   options(future.plan = NULL)
[16:12:51.688]                   if (is.na(NA_character_)) 
[16:12:51.688]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.688]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.688]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:51.688]                     envir = parent.frame()) 
[16:12:51.688]                   {
[16:12:51.688]                     default_workers <- missing(workers)
[16:12:51.688]                     if (is.function(workers)) 
[16:12:51.688]                       workers <- workers()
[16:12:51.688]                     workers <- structure(as.integer(workers), 
[16:12:51.688]                       class = class(workers))
[16:12:51.688]                     stop_if_not(is.finite(workers), workers >= 
[16:12:51.688]                       1L)
[16:12:51.688]                     if ((workers == 1L && !inherits(workers, 
[16:12:51.688]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:51.688]                       if (default_workers) 
[16:12:51.688]                         supportsMulticore(warn = TRUE)
[16:12:51.688]                       return(sequential(..., envir = envir))
[16:12:51.688]                     }
[16:12:51.688]                     oopts <- options(mc.cores = workers)
[16:12:51.688]                     on.exit(options(oopts))
[16:12:51.688]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:51.688]                       envir = envir)
[16:12:51.688]                     if (!future$lazy) 
[16:12:51.688]                       future <- run(future)
[16:12:51.688]                     invisible(future)
[16:12:51.688]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.688]                 }
[16:12:51.688]             }
[16:12:51.688]         }
[16:12:51.688]     })
[16:12:51.688]     if (TRUE) {
[16:12:51.688]         base::sink(type = "output", split = FALSE)
[16:12:51.688]         if (TRUE) {
[16:12:51.688]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.688]         }
[16:12:51.688]         else {
[16:12:51.688]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.688]         }
[16:12:51.688]         base::close(...future.stdout)
[16:12:51.688]         ...future.stdout <- NULL
[16:12:51.688]     }
[16:12:51.688]     ...future.result$conditions <- ...future.conditions
[16:12:51.688]     ...future.result$finished <- base::Sys.time()
[16:12:51.688]     ...future.result
[16:12:51.688] }
[16:12:51.690] assign_globals() ...
[16:12:51.690] List of 1
[16:12:51.690]  $ ii: int 1
[16:12:51.690]  - attr(*, "where")=List of 1
[16:12:51.690]   ..$ ii:<environment: R_EmptyEnv> 
[16:12:51.690]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.690]  - attr(*, "resolved")= logi TRUE
[16:12:51.690]  - attr(*, "total_size")= num 56
[16:12:51.690]  - attr(*, "already-done")= logi TRUE
[16:12:51.693] - copied ‘ii’ to environment
[16:12:51.693] assign_globals() ... done
[16:12:51.693] requestCore(): workers = 2
[16:12:51.695] MulticoreFuture started
[16:12:51.696] - Launch lazy future ... done
[16:12:51.696] run() for ‘MulticoreFuture’ ... done
[16:12:51.696] plan(): Setting new future strategy stack:
[16:12:51.697] List of future strategies:
[16:12:51.697] 1. sequential:
[16:12:51.697]    - args: function (..., envir = parent.frame())
[16:12:51.697]    - tweaked: FALSE
[16:12:51.697]    - call: NULL
[16:12:51.698] plan(): nbrOfWorkers() = 1
[16:12:51.700] plan(): Setting new future strategy stack:
[16:12:51.700] List of future strategies:
[16:12:51.700] 1. multicore:
[16:12:51.700]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:51.700]    - tweaked: FALSE
[16:12:51.700]    - call: plan(strategy)
[16:12:51.705] plan(): nbrOfWorkers() = 2
[16:12:51.711] signalConditions() ...
[16:12:51.711]  - include = ‘immediateCondition’
[16:12:51.711]  - exclude = 
[16:12:51.712]  - resignal = FALSE
[16:12:51.712]  - Number of conditions: 1
[16:12:51.712] signalConditions() ... done
[16:12:51.712] signalConditions() ...
[16:12:51.712]  - include = ‘immediateCondition’
[16:12:51.712]  - exclude = 
[16:12:51.712]  - resignal = FALSE
[16:12:51.712]  - Number of conditions: 1
[16:12:51.713] signalConditions() ... done
[16:12:51.713] Future state: ‘finished’
[16:12:51.713] signalConditions() ...
[16:12:51.713]  - include = ‘condition’
[16:12:51.713]  - exclude = ‘immediateCondition’
[16:12:51.713]  - resignal = TRUE
[16:12:51.713]  - Number of conditions: 1
[16:12:51.713]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:12:51.714] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 45
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language local({     value <- value(future) ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2729ef2608da" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:12:51"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.746] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.746] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.747] 
[16:12:51.747] Searching for globals ... DONE
[16:12:51.747] - globals: [0] <none>
[16:12:51.747] getGlobalsAndPackages() ... DONE
[16:12:51.748] run() for ‘Future’ ...
[16:12:51.748] - state: ‘created’
[16:12:51.748] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:51.752] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:51.752] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:51.752]   - Field: ‘label’
[16:12:51.752]   - Field: ‘local’
[16:12:51.752]   - Field: ‘owner’
[16:12:51.752]   - Field: ‘envir’
[16:12:51.753]   - Field: ‘workers’
[16:12:51.753]   - Field: ‘packages’
[16:12:51.753]   - Field: ‘gc’
[16:12:51.753]   - Field: ‘job’
[16:12:51.753]   - Field: ‘conditions’
[16:12:51.753]   - Field: ‘expr’
[16:12:51.753]   - Field: ‘uuid’
[16:12:51.753]   - Field: ‘seed’
[16:12:51.753]   - Field: ‘version’
[16:12:51.753]   - Field: ‘result’
[16:12:51.754]   - Field: ‘asynchronous’
[16:12:51.754]   - Field: ‘calls’
[16:12:51.754]   - Field: ‘globals’
[16:12:51.754]   - Field: ‘stdout’
[16:12:51.754]   - Field: ‘earlySignal’
[16:12:51.754]   - Field: ‘lazy’
[16:12:51.754]   - Field: ‘state’
[16:12:51.754] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:51.754] - Launch lazy future ...
[16:12:51.755] Packages needed by the future expression (n = 0): <none>
[16:12:51.755] Packages needed by future strategies (n = 0): <none>
[16:12:51.755] {
[16:12:51.755]     {
[16:12:51.755]         {
[16:12:51.755]             ...future.startTime <- base::Sys.time()
[16:12:51.755]             {
[16:12:51.755]                 {
[16:12:51.755]                   {
[16:12:51.755]                     {
[16:12:51.755]                       base::local({
[16:12:51.755]                         has_future <- base::requireNamespace("future", 
[16:12:51.755]                           quietly = TRUE)
[16:12:51.755]                         if (has_future) {
[16:12:51.755]                           ns <- base::getNamespace("future")
[16:12:51.755]                           version <- ns[[".package"]][["version"]]
[16:12:51.755]                           if (is.null(version)) 
[16:12:51.755]                             version <- utils::packageVersion("future")
[16:12:51.755]                         }
[16:12:51.755]                         else {
[16:12:51.755]                           version <- NULL
[16:12:51.755]                         }
[16:12:51.755]                         if (!has_future || version < "1.8.0") {
[16:12:51.755]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.755]                             "", base::R.version$version.string), 
[16:12:51.755]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:51.755]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.755]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.755]                               "release", "version")], collapse = " "), 
[16:12:51.755]                             hostname = base::Sys.info()[["nodename"]])
[16:12:51.755]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.755]                             info)
[16:12:51.755]                           info <- base::paste(info, collapse = "; ")
[16:12:51.755]                           if (!has_future) {
[16:12:51.755]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.755]                               info)
[16:12:51.755]                           }
[16:12:51.755]                           else {
[16:12:51.755]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.755]                               info, version)
[16:12:51.755]                           }
[16:12:51.755]                           base::stop(msg)
[16:12:51.755]                         }
[16:12:51.755]                       })
[16:12:51.755]                     }
[16:12:51.755]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:51.755]                     base::options(mc.cores = 1L)
[16:12:51.755]                   }
[16:12:51.755]                   options(future.plan = NULL)
[16:12:51.755]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.755]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.755]                 }
[16:12:51.755]                 ...future.workdir <- getwd()
[16:12:51.755]             }
[16:12:51.755]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.755]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.755]         }
[16:12:51.755]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.755]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:51.755]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.755]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.755]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.755]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.755]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.755]             base::names(...future.oldOptions))
[16:12:51.755]     }
[16:12:51.755]     if (FALSE) {
[16:12:51.755]     }
[16:12:51.755]     else {
[16:12:51.755]         if (TRUE) {
[16:12:51.755]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.755]                 open = "w")
[16:12:51.755]         }
[16:12:51.755]         else {
[16:12:51.755]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.755]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.755]         }
[16:12:51.755]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.755]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.755]             base::sink(type = "output", split = FALSE)
[16:12:51.755]             base::close(...future.stdout)
[16:12:51.755]         }, add = TRUE)
[16:12:51.755]     }
[16:12:51.755]     ...future.frame <- base::sys.nframe()
[16:12:51.755]     ...future.conditions <- base::list()
[16:12:51.755]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.755]     if (FALSE) {
[16:12:51.755]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.755]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.755]     }
[16:12:51.755]     ...future.result <- base::tryCatch({
[16:12:51.755]         base::withCallingHandlers({
[16:12:51.755]             ...future.value <- base::withVisible(base::local({
[16:12:51.755]                 withCallingHandlers({
[16:12:51.755]                   1
[16:12:51.755]                 }, immediateCondition = function(cond) {
[16:12:51.755]                   save_rds <- function (object, pathname, ...) 
[16:12:51.755]                   {
[16:12:51.755]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:51.755]                     if (file_test("-f", pathname_tmp)) {
[16:12:51.755]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.755]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:51.755]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.755]                         fi_tmp[["mtime"]])
[16:12:51.755]                     }
[16:12:51.755]                     tryCatch({
[16:12:51.755]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:51.755]                     }, error = function(ex) {
[16:12:51.755]                       msg <- conditionMessage(ex)
[16:12:51.755]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.755]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:51.755]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.755]                         fi_tmp[["mtime"]], msg)
[16:12:51.755]                       ex$message <- msg
[16:12:51.755]                       stop(ex)
[16:12:51.755]                     })
[16:12:51.755]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:51.755]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:51.755]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:51.755]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.755]                       fi <- file.info(pathname)
[16:12:51.755]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:51.755]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.755]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:51.755]                         fi[["size"]], fi[["mtime"]])
[16:12:51.755]                       stop(msg)
[16:12:51.755]                     }
[16:12:51.755]                     invisible(pathname)
[16:12:51.755]                   }
[16:12:51.755]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:51.755]                     rootPath = tempdir()) 
[16:12:51.755]                   {
[16:12:51.755]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:51.755]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:51.755]                       tmpdir = path, fileext = ".rds")
[16:12:51.755]                     save_rds(obj, file)
[16:12:51.755]                   }
[16:12:51.755]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:51.755]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.755]                   {
[16:12:51.755]                     inherits <- base::inherits
[16:12:51.755]                     invokeRestart <- base::invokeRestart
[16:12:51.755]                     is.null <- base::is.null
[16:12:51.755]                     muffled <- FALSE
[16:12:51.755]                     if (inherits(cond, "message")) {
[16:12:51.755]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:51.755]                       if (muffled) 
[16:12:51.755]                         invokeRestart("muffleMessage")
[16:12:51.755]                     }
[16:12:51.755]                     else if (inherits(cond, "warning")) {
[16:12:51.755]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:51.755]                       if (muffled) 
[16:12:51.755]                         invokeRestart("muffleWarning")
[16:12:51.755]                     }
[16:12:51.755]                     else if (inherits(cond, "condition")) {
[16:12:51.755]                       if (!is.null(pattern)) {
[16:12:51.755]                         computeRestarts <- base::computeRestarts
[16:12:51.755]                         grepl <- base::grepl
[16:12:51.755]                         restarts <- computeRestarts(cond)
[16:12:51.755]                         for (restart in restarts) {
[16:12:51.755]                           name <- restart$name
[16:12:51.755]                           if (is.null(name)) 
[16:12:51.755]                             next
[16:12:51.755]                           if (!grepl(pattern, name)) 
[16:12:51.755]                             next
[16:12:51.755]                           invokeRestart(restart)
[16:12:51.755]                           muffled <- TRUE
[16:12:51.755]                           break
[16:12:51.755]                         }
[16:12:51.755]                       }
[16:12:51.755]                     }
[16:12:51.755]                     invisible(muffled)
[16:12:51.755]                   }
[16:12:51.755]                   muffleCondition(cond)
[16:12:51.755]                 })
[16:12:51.755]             }))
[16:12:51.755]             future::FutureResult(value = ...future.value$value, 
[16:12:51.755]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.755]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.755]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.755]                     ...future.globalenv.names))
[16:12:51.755]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.755]         }, condition = base::local({
[16:12:51.755]             c <- base::c
[16:12:51.755]             inherits <- base::inherits
[16:12:51.755]             invokeRestart <- base::invokeRestart
[16:12:51.755]             length <- base::length
[16:12:51.755]             list <- base::list
[16:12:51.755]             seq.int <- base::seq.int
[16:12:51.755]             signalCondition <- base::signalCondition
[16:12:51.755]             sys.calls <- base::sys.calls
[16:12:51.755]             `[[` <- base::`[[`
[16:12:51.755]             `+` <- base::`+`
[16:12:51.755]             `<<-` <- base::`<<-`
[16:12:51.755]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.755]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.755]                   3L)]
[16:12:51.755]             }
[16:12:51.755]             function(cond) {
[16:12:51.755]                 is_error <- inherits(cond, "error")
[16:12:51.755]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.755]                   NULL)
[16:12:51.755]                 if (is_error) {
[16:12:51.755]                   sessionInformation <- function() {
[16:12:51.755]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.755]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.755]                       search = base::search(), system = base::Sys.info())
[16:12:51.755]                   }
[16:12:51.755]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.755]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.755]                     cond$call), session = sessionInformation(), 
[16:12:51.755]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.755]                   signalCondition(cond)
[16:12:51.755]                 }
[16:12:51.755]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.755]                 "immediateCondition"))) {
[16:12:51.755]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.755]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.755]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.755]                   if (TRUE && !signal) {
[16:12:51.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.755]                     {
[16:12:51.755]                       inherits <- base::inherits
[16:12:51.755]                       invokeRestart <- base::invokeRestart
[16:12:51.755]                       is.null <- base::is.null
[16:12:51.755]                       muffled <- FALSE
[16:12:51.755]                       if (inherits(cond, "message")) {
[16:12:51.755]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.755]                         if (muffled) 
[16:12:51.755]                           invokeRestart("muffleMessage")
[16:12:51.755]                       }
[16:12:51.755]                       else if (inherits(cond, "warning")) {
[16:12:51.755]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.755]                         if (muffled) 
[16:12:51.755]                           invokeRestart("muffleWarning")
[16:12:51.755]                       }
[16:12:51.755]                       else if (inherits(cond, "condition")) {
[16:12:51.755]                         if (!is.null(pattern)) {
[16:12:51.755]                           computeRestarts <- base::computeRestarts
[16:12:51.755]                           grepl <- base::grepl
[16:12:51.755]                           restarts <- computeRestarts(cond)
[16:12:51.755]                           for (restart in restarts) {
[16:12:51.755]                             name <- restart$name
[16:12:51.755]                             if (is.null(name)) 
[16:12:51.755]                               next
[16:12:51.755]                             if (!grepl(pattern, name)) 
[16:12:51.755]                               next
[16:12:51.755]                             invokeRestart(restart)
[16:12:51.755]                             muffled <- TRUE
[16:12:51.755]                             break
[16:12:51.755]                           }
[16:12:51.755]                         }
[16:12:51.755]                       }
[16:12:51.755]                       invisible(muffled)
[16:12:51.755]                     }
[16:12:51.755]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.755]                   }
[16:12:51.755]                 }
[16:12:51.755]                 else {
[16:12:51.755]                   if (TRUE) {
[16:12:51.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.755]                     {
[16:12:51.755]                       inherits <- base::inherits
[16:12:51.755]                       invokeRestart <- base::invokeRestart
[16:12:51.755]                       is.null <- base::is.null
[16:12:51.755]                       muffled <- FALSE
[16:12:51.755]                       if (inherits(cond, "message")) {
[16:12:51.755]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.755]                         if (muffled) 
[16:12:51.755]                           invokeRestart("muffleMessage")
[16:12:51.755]                       }
[16:12:51.755]                       else if (inherits(cond, "warning")) {
[16:12:51.755]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.755]                         if (muffled) 
[16:12:51.755]                           invokeRestart("muffleWarning")
[16:12:51.755]                       }
[16:12:51.755]                       else if (inherits(cond, "condition")) {
[16:12:51.755]                         if (!is.null(pattern)) {
[16:12:51.755]                           computeRestarts <- base::computeRestarts
[16:12:51.755]                           grepl <- base::grepl
[16:12:51.755]                           restarts <- computeRestarts(cond)
[16:12:51.755]                           for (restart in restarts) {
[16:12:51.755]                             name <- restart$name
[16:12:51.755]                             if (is.null(name)) 
[16:12:51.755]                               next
[16:12:51.755]                             if (!grepl(pattern, name)) 
[16:12:51.755]                               next
[16:12:51.755]                             invokeRestart(restart)
[16:12:51.755]                             muffled <- TRUE
[16:12:51.755]                             break
[16:12:51.755]                           }
[16:12:51.755]                         }
[16:12:51.755]                       }
[16:12:51.755]                       invisible(muffled)
[16:12:51.755]                     }
[16:12:51.755]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.755]                   }
[16:12:51.755]                 }
[16:12:51.755]             }
[16:12:51.755]         }))
[16:12:51.755]     }, error = function(ex) {
[16:12:51.755]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.755]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.755]                 ...future.rng), started = ...future.startTime, 
[16:12:51.755]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.755]             version = "1.8"), class = "FutureResult")
[16:12:51.755]     }, finally = {
[16:12:51.755]         if (!identical(...future.workdir, getwd())) 
[16:12:51.755]             setwd(...future.workdir)
[16:12:51.755]         {
[16:12:51.755]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.755]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.755]             }
[16:12:51.755]             base::options(...future.oldOptions)
[16:12:51.755]             if (.Platform$OS.type == "windows") {
[16:12:51.755]                 old_names <- names(...future.oldEnvVars)
[16:12:51.755]                 envs <- base::Sys.getenv()
[16:12:51.755]                 names <- names(envs)
[16:12:51.755]                 common <- intersect(names, old_names)
[16:12:51.755]                 added <- setdiff(names, old_names)
[16:12:51.755]                 removed <- setdiff(old_names, names)
[16:12:51.755]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.755]                   envs[common]]
[16:12:51.755]                 NAMES <- toupper(changed)
[16:12:51.755]                 args <- list()
[16:12:51.755]                 for (kk in seq_along(NAMES)) {
[16:12:51.755]                   name <- changed[[kk]]
[16:12:51.755]                   NAME <- NAMES[[kk]]
[16:12:51.755]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.755]                     next
[16:12:51.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.755]                 }
[16:12:51.755]                 NAMES <- toupper(added)
[16:12:51.755]                 for (kk in seq_along(NAMES)) {
[16:12:51.755]                   name <- added[[kk]]
[16:12:51.755]                   NAME <- NAMES[[kk]]
[16:12:51.755]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.755]                     next
[16:12:51.755]                   args[[name]] <- ""
[16:12:51.755]                 }
[16:12:51.755]                 NAMES <- toupper(removed)
[16:12:51.755]                 for (kk in seq_along(NAMES)) {
[16:12:51.755]                   name <- removed[[kk]]
[16:12:51.755]                   NAME <- NAMES[[kk]]
[16:12:51.755]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.755]                     next
[16:12:51.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.755]                 }
[16:12:51.755]                 if (length(args) > 0) 
[16:12:51.755]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.755]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.755]             }
[16:12:51.755]             else {
[16:12:51.755]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.755]             }
[16:12:51.755]             {
[16:12:51.755]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.755]                   0L) {
[16:12:51.755]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.755]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.755]                   base::options(opts)
[16:12:51.755]                 }
[16:12:51.755]                 {
[16:12:51.755]                   {
[16:12:51.755]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:51.755]                     NULL
[16:12:51.755]                   }
[16:12:51.755]                   options(future.plan = NULL)
[16:12:51.755]                   if (is.na(NA_character_)) 
[16:12:51.755]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.755]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.755]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:51.755]                     envir = parent.frame()) 
[16:12:51.755]                   {
[16:12:51.755]                     default_workers <- missing(workers)
[16:12:51.755]                     if (is.function(workers)) 
[16:12:51.755]                       workers <- workers()
[16:12:51.755]                     workers <- structure(as.integer(workers), 
[16:12:51.755]                       class = class(workers))
[16:12:51.755]                     stop_if_not(is.finite(workers), workers >= 
[16:12:51.755]                       1L)
[16:12:51.755]                     if ((workers == 1L && !inherits(workers, 
[16:12:51.755]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:51.755]                       if (default_workers) 
[16:12:51.755]                         supportsMulticore(warn = TRUE)
[16:12:51.755]                       return(sequential(..., envir = envir))
[16:12:51.755]                     }
[16:12:51.755]                     oopts <- options(mc.cores = workers)
[16:12:51.755]                     on.exit(options(oopts))
[16:12:51.755]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:51.755]                       envir = envir)
[16:12:51.755]                     if (!future$lazy) 
[16:12:51.755]                       future <- run(future)
[16:12:51.755]                     invisible(future)
[16:12:51.755]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.755]                 }
[16:12:51.755]             }
[16:12:51.755]         }
[16:12:51.755]     })
[16:12:51.755]     if (TRUE) {
[16:12:51.755]         base::sink(type = "output", split = FALSE)
[16:12:51.755]         if (TRUE) {
[16:12:51.755]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.755]         }
[16:12:51.755]         else {
[16:12:51.755]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.755]         }
[16:12:51.755]         base::close(...future.stdout)
[16:12:51.755]         ...future.stdout <- NULL
[16:12:51.755]     }
[16:12:51.755]     ...future.result$conditions <- ...future.conditions
[16:12:51.755]     ...future.result$finished <- base::Sys.time()
[16:12:51.755]     ...future.result
[16:12:51.755] }
[16:12:51.758] requestCore(): workers = 2
[16:12:51.760] MulticoreFuture started
[16:12:51.761] - Launch lazy future ... done
[16:12:51.761] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.761] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.761] plan(): Setting new future strategy stack:
[16:12:51.762] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.762] List of future strategies:
[16:12:51.762] 1. sequential:
[16:12:51.762]    - args: function (..., envir = parent.frame())
[16:12:51.762]    - tweaked: FALSE
[16:12:51.762]    - call: NULL
[16:12:51.763] plan(): nbrOfWorkers() = 1
[16:12:51.764] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:51.764] Searching for globals ... DONE
[16:12:51.764] Resolving globals: TRUE
[16:12:51.764] Resolving any globals that are futures ...
[16:12:51.765] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:51.765] Resolving any globals that are futures ... DONE
[16:12:51.765] plan(): Setting new future strategy stack:
[16:12:51.765] List of future strategies:
[16:12:51.765] 1. multicore:
[16:12:51.765]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:51.765]    - tweaked: FALSE
[16:12:51.765]    - call: plan(strategy)
[16:12:51.765] Resolving futures part of globals (recursively) ...
[16:12:51.766] resolve() on list ...
[16:12:51.766]  recursive: 99
[16:12:51.766]  length: 1
[16:12:51.766]  elements: ‘a’
[16:12:51.770] plan(): nbrOfWorkers() = 2
[16:12:51.770] Future #1
[16:12:51.771] A MulticoreFuture was resolved
[16:12:51.772]  length: 0 (resolved future 1)
[16:12:51.772] resolve() on list ... DONE
[16:12:51.772] - globals: [1] ‘a’
[16:12:51.772] Resolving futures part of globals (recursively) ... DONE
[16:12:51.773] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[16:12:51.774] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[16:12:51.774] - globals: [1] ‘a’
[16:12:51.774] - packages: [1] ‘future’
[16:12:51.774] getGlobalsAndPackages() ... DONE
[16:12:51.775] run() for ‘Future’ ...
[16:12:51.775] - state: ‘created’
[16:12:51.775] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:51.779] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:51.779] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:51.779]   - Field: ‘label’
[16:12:51.780]   - Field: ‘local’
[16:12:51.780]   - Field: ‘owner’
[16:12:51.780]   - Field: ‘envir’
[16:12:51.780]   - Field: ‘workers’
[16:12:51.780]   - Field: ‘packages’
[16:12:51.780]   - Field: ‘gc’
[16:12:51.780]   - Field: ‘job’
[16:12:51.781]   - Field: ‘conditions’
[16:12:51.783]   - Field: ‘expr’
[16:12:51.783]   - Field: ‘uuid’
[16:12:51.783]   - Field: ‘seed’
[16:12:51.783]   - Field: ‘version’
[16:12:51.784]   - Field: ‘result’
[16:12:51.784]   - Field: ‘asynchronous’
[16:12:51.784]   - Field: ‘calls’
[16:12:51.784]   - Field: ‘globals’
[16:12:51.784]   - Field: ‘stdout’
[16:12:51.784]   - Field: ‘earlySignal’
[16:12:51.785]   - Field: ‘lazy’
[16:12:51.785]   - Field: ‘state’
[16:12:51.785] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:51.785] - Launch lazy future ...
[16:12:51.786] Packages needed by the future expression (n = 1): ‘future’
[16:12:51.786] Packages needed by future strategies (n = 0): <none>
[16:12:51.787] {
[16:12:51.787]     {
[16:12:51.787]         {
[16:12:51.787]             ...future.startTime <- base::Sys.time()
[16:12:51.787]             {
[16:12:51.787]                 {
[16:12:51.787]                   {
[16:12:51.787]                     {
[16:12:51.787]                       {
[16:12:51.787]                         base::local({
[16:12:51.787]                           has_future <- base::requireNamespace("future", 
[16:12:51.787]                             quietly = TRUE)
[16:12:51.787]                           if (has_future) {
[16:12:51.787]                             ns <- base::getNamespace("future")
[16:12:51.787]                             version <- ns[[".package"]][["version"]]
[16:12:51.787]                             if (is.null(version)) 
[16:12:51.787]                               version <- utils::packageVersion("future")
[16:12:51.787]                           }
[16:12:51.787]                           else {
[16:12:51.787]                             version <- NULL
[16:12:51.787]                           }
[16:12:51.787]                           if (!has_future || version < "1.8.0") {
[16:12:51.787]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.787]                               "", base::R.version$version.string), 
[16:12:51.787]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:51.787]                                 base::R.version$platform, 8 * 
[16:12:51.787]                                   base::.Machine$sizeof.pointer), 
[16:12:51.787]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.787]                                 "release", "version")], collapse = " "), 
[16:12:51.787]                               hostname = base::Sys.info()[["nodename"]])
[16:12:51.787]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.787]                               info)
[16:12:51.787]                             info <- base::paste(info, collapse = "; ")
[16:12:51.787]                             if (!has_future) {
[16:12:51.787]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.787]                                 info)
[16:12:51.787]                             }
[16:12:51.787]                             else {
[16:12:51.787]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.787]                                 info, version)
[16:12:51.787]                             }
[16:12:51.787]                             base::stop(msg)
[16:12:51.787]                           }
[16:12:51.787]                         })
[16:12:51.787]                       }
[16:12:51.787]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:51.787]                       base::options(mc.cores = 1L)
[16:12:51.787]                     }
[16:12:51.787]                     base::local({
[16:12:51.787]                       for (pkg in "future") {
[16:12:51.787]                         base::loadNamespace(pkg)
[16:12:51.787]                         base::library(pkg, character.only = TRUE)
[16:12:51.787]                       }
[16:12:51.787]                     })
[16:12:51.787]                   }
[16:12:51.787]                   options(future.plan = NULL)
[16:12:51.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.787]                 }
[16:12:51.787]                 ...future.workdir <- getwd()
[16:12:51.787]             }
[16:12:51.787]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.787]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.787]         }
[16:12:51.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.787]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:51.787]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.787]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.787]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.787]             base::names(...future.oldOptions))
[16:12:51.787]     }
[16:12:51.787]     if (FALSE) {
[16:12:51.787]     }
[16:12:51.787]     else {
[16:12:51.787]         if (TRUE) {
[16:12:51.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.787]                 open = "w")
[16:12:51.787]         }
[16:12:51.787]         else {
[16:12:51.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.787]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.787]         }
[16:12:51.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.787]             base::sink(type = "output", split = FALSE)
[16:12:51.787]             base::close(...future.stdout)
[16:12:51.787]         }, add = TRUE)
[16:12:51.787]     }
[16:12:51.787]     ...future.frame <- base::sys.nframe()
[16:12:51.787]     ...future.conditions <- base::list()
[16:12:51.787]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.787]     if (FALSE) {
[16:12:51.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.787]     }
[16:12:51.787]     ...future.result <- base::tryCatch({
[16:12:51.787]         base::withCallingHandlers({
[16:12:51.787]             ...future.value <- base::withVisible(base::local({
[16:12:51.787]                 withCallingHandlers({
[16:12:51.787]                   value(a) + 1
[16:12:51.787]                 }, immediateCondition = function(cond) {
[16:12:51.787]                   save_rds <- function (object, pathname, ...) 
[16:12:51.787]                   {
[16:12:51.787]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:51.787]                     if (file_test("-f", pathname_tmp)) {
[16:12:51.787]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.787]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:51.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.787]                         fi_tmp[["mtime"]])
[16:12:51.787]                     }
[16:12:51.787]                     tryCatch({
[16:12:51.787]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:51.787]                     }, error = function(ex) {
[16:12:51.787]                       msg <- conditionMessage(ex)
[16:12:51.787]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.787]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:51.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.787]                         fi_tmp[["mtime"]], msg)
[16:12:51.787]                       ex$message <- msg
[16:12:51.787]                       stop(ex)
[16:12:51.787]                     })
[16:12:51.787]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:51.787]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:51.787]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:51.787]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.787]                       fi <- file.info(pathname)
[16:12:51.787]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:51.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.787]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:51.787]                         fi[["size"]], fi[["mtime"]])
[16:12:51.787]                       stop(msg)
[16:12:51.787]                     }
[16:12:51.787]                     invisible(pathname)
[16:12:51.787]                   }
[16:12:51.787]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:51.787]                     rootPath = tempdir()) 
[16:12:51.787]                   {
[16:12:51.787]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:51.787]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:51.787]                       tmpdir = path, fileext = ".rds")
[16:12:51.787]                     save_rds(obj, file)
[16:12:51.787]                   }
[16:12:51.787]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:51.787]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.787]                   {
[16:12:51.787]                     inherits <- base::inherits
[16:12:51.787]                     invokeRestart <- base::invokeRestart
[16:12:51.787]                     is.null <- base::is.null
[16:12:51.787]                     muffled <- FALSE
[16:12:51.787]                     if (inherits(cond, "message")) {
[16:12:51.787]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:51.787]                       if (muffled) 
[16:12:51.787]                         invokeRestart("muffleMessage")
[16:12:51.787]                     }
[16:12:51.787]                     else if (inherits(cond, "warning")) {
[16:12:51.787]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:51.787]                       if (muffled) 
[16:12:51.787]                         invokeRestart("muffleWarning")
[16:12:51.787]                     }
[16:12:51.787]                     else if (inherits(cond, "condition")) {
[16:12:51.787]                       if (!is.null(pattern)) {
[16:12:51.787]                         computeRestarts <- base::computeRestarts
[16:12:51.787]                         grepl <- base::grepl
[16:12:51.787]                         restarts <- computeRestarts(cond)
[16:12:51.787]                         for (restart in restarts) {
[16:12:51.787]                           name <- restart$name
[16:12:51.787]                           if (is.null(name)) 
[16:12:51.787]                             next
[16:12:51.787]                           if (!grepl(pattern, name)) 
[16:12:51.787]                             next
[16:12:51.787]                           invokeRestart(restart)
[16:12:51.787]                           muffled <- TRUE
[16:12:51.787]                           break
[16:12:51.787]                         }
[16:12:51.787]                       }
[16:12:51.787]                     }
[16:12:51.787]                     invisible(muffled)
[16:12:51.787]                   }
[16:12:51.787]                   muffleCondition(cond)
[16:12:51.787]                 })
[16:12:51.787]             }))
[16:12:51.787]             future::FutureResult(value = ...future.value$value, 
[16:12:51.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.787]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.787]                     ...future.globalenv.names))
[16:12:51.787]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.787]         }, condition = base::local({
[16:12:51.787]             c <- base::c
[16:12:51.787]             inherits <- base::inherits
[16:12:51.787]             invokeRestart <- base::invokeRestart
[16:12:51.787]             length <- base::length
[16:12:51.787]             list <- base::list
[16:12:51.787]             seq.int <- base::seq.int
[16:12:51.787]             signalCondition <- base::signalCondition
[16:12:51.787]             sys.calls <- base::sys.calls
[16:12:51.787]             `[[` <- base::`[[`
[16:12:51.787]             `+` <- base::`+`
[16:12:51.787]             `<<-` <- base::`<<-`
[16:12:51.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.787]                   3L)]
[16:12:51.787]             }
[16:12:51.787]             function(cond) {
[16:12:51.787]                 is_error <- inherits(cond, "error")
[16:12:51.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.787]                   NULL)
[16:12:51.787]                 if (is_error) {
[16:12:51.787]                   sessionInformation <- function() {
[16:12:51.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.787]                       search = base::search(), system = base::Sys.info())
[16:12:51.787]                   }
[16:12:51.787]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.787]                     cond$call), session = sessionInformation(), 
[16:12:51.787]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.787]                   signalCondition(cond)
[16:12:51.787]                 }
[16:12:51.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.787]                 "immediateCondition"))) {
[16:12:51.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.787]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.787]                   if (TRUE && !signal) {
[16:12:51.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.787]                     {
[16:12:51.787]                       inherits <- base::inherits
[16:12:51.787]                       invokeRestart <- base::invokeRestart
[16:12:51.787]                       is.null <- base::is.null
[16:12:51.787]                       muffled <- FALSE
[16:12:51.787]                       if (inherits(cond, "message")) {
[16:12:51.787]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.787]                         if (muffled) 
[16:12:51.787]                           invokeRestart("muffleMessage")
[16:12:51.787]                       }
[16:12:51.787]                       else if (inherits(cond, "warning")) {
[16:12:51.787]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.787]                         if (muffled) 
[16:12:51.787]                           invokeRestart("muffleWarning")
[16:12:51.787]                       }
[16:12:51.787]                       else if (inherits(cond, "condition")) {
[16:12:51.787]                         if (!is.null(pattern)) {
[16:12:51.787]                           computeRestarts <- base::computeRestarts
[16:12:51.787]                           grepl <- base::grepl
[16:12:51.787]                           restarts <- computeRestarts(cond)
[16:12:51.787]                           for (restart in restarts) {
[16:12:51.787]                             name <- restart$name
[16:12:51.787]                             if (is.null(name)) 
[16:12:51.787]                               next
[16:12:51.787]                             if (!grepl(pattern, name)) 
[16:12:51.787]                               next
[16:12:51.787]                             invokeRestart(restart)
[16:12:51.787]                             muffled <- TRUE
[16:12:51.787]                             break
[16:12:51.787]                           }
[16:12:51.787]                         }
[16:12:51.787]                       }
[16:12:51.787]                       invisible(muffled)
[16:12:51.787]                     }
[16:12:51.787]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.787]                   }
[16:12:51.787]                 }
[16:12:51.787]                 else {
[16:12:51.787]                   if (TRUE) {
[16:12:51.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.787]                     {
[16:12:51.787]                       inherits <- base::inherits
[16:12:51.787]                       invokeRestart <- base::invokeRestart
[16:12:51.787]                       is.null <- base::is.null
[16:12:51.787]                       muffled <- FALSE
[16:12:51.787]                       if (inherits(cond, "message")) {
[16:12:51.787]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.787]                         if (muffled) 
[16:12:51.787]                           invokeRestart("muffleMessage")
[16:12:51.787]                       }
[16:12:51.787]                       else if (inherits(cond, "warning")) {
[16:12:51.787]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.787]                         if (muffled) 
[16:12:51.787]                           invokeRestart("muffleWarning")
[16:12:51.787]                       }
[16:12:51.787]                       else if (inherits(cond, "condition")) {
[16:12:51.787]                         if (!is.null(pattern)) {
[16:12:51.787]                           computeRestarts <- base::computeRestarts
[16:12:51.787]                           grepl <- base::grepl
[16:12:51.787]                           restarts <- computeRestarts(cond)
[16:12:51.787]                           for (restart in restarts) {
[16:12:51.787]                             name <- restart$name
[16:12:51.787]                             if (is.null(name)) 
[16:12:51.787]                               next
[16:12:51.787]                             if (!grepl(pattern, name)) 
[16:12:51.787]                               next
[16:12:51.787]                             invokeRestart(restart)
[16:12:51.787]                             muffled <- TRUE
[16:12:51.787]                             break
[16:12:51.787]                           }
[16:12:51.787]                         }
[16:12:51.787]                       }
[16:12:51.787]                       invisible(muffled)
[16:12:51.787]                     }
[16:12:51.787]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.787]                   }
[16:12:51.787]                 }
[16:12:51.787]             }
[16:12:51.787]         }))
[16:12:51.787]     }, error = function(ex) {
[16:12:51.787]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.787]                 ...future.rng), started = ...future.startTime, 
[16:12:51.787]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.787]             version = "1.8"), class = "FutureResult")
[16:12:51.787]     }, finally = {
[16:12:51.787]         if (!identical(...future.workdir, getwd())) 
[16:12:51.787]             setwd(...future.workdir)
[16:12:51.787]         {
[16:12:51.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.787]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.787]             }
[16:12:51.787]             base::options(...future.oldOptions)
[16:12:51.787]             if (.Platform$OS.type == "windows") {
[16:12:51.787]                 old_names <- names(...future.oldEnvVars)
[16:12:51.787]                 envs <- base::Sys.getenv()
[16:12:51.787]                 names <- names(envs)
[16:12:51.787]                 common <- intersect(names, old_names)
[16:12:51.787]                 added <- setdiff(names, old_names)
[16:12:51.787]                 removed <- setdiff(old_names, names)
[16:12:51.787]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.787]                   envs[common]]
[16:12:51.787]                 NAMES <- toupper(changed)
[16:12:51.787]                 args <- list()
[16:12:51.787]                 for (kk in seq_along(NAMES)) {
[16:12:51.787]                   name <- changed[[kk]]
[16:12:51.787]                   NAME <- NAMES[[kk]]
[16:12:51.787]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.787]                     next
[16:12:51.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.787]                 }
[16:12:51.787]                 NAMES <- toupper(added)
[16:12:51.787]                 for (kk in seq_along(NAMES)) {
[16:12:51.787]                   name <- added[[kk]]
[16:12:51.787]                   NAME <- NAMES[[kk]]
[16:12:51.787]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.787]                     next
[16:12:51.787]                   args[[name]] <- ""
[16:12:51.787]                 }
[16:12:51.787]                 NAMES <- toupper(removed)
[16:12:51.787]                 for (kk in seq_along(NAMES)) {
[16:12:51.787]                   name <- removed[[kk]]
[16:12:51.787]                   NAME <- NAMES[[kk]]
[16:12:51.787]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.787]                     next
[16:12:51.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.787]                 }
[16:12:51.787]                 if (length(args) > 0) 
[16:12:51.787]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.787]             }
[16:12:51.787]             else {
[16:12:51.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.787]             }
[16:12:51.787]             {
[16:12:51.787]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.787]                   0L) {
[16:12:51.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.787]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.787]                   base::options(opts)
[16:12:51.787]                 }
[16:12:51.787]                 {
[16:12:51.787]                   {
[16:12:51.787]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:51.787]                     NULL
[16:12:51.787]                   }
[16:12:51.787]                   options(future.plan = NULL)
[16:12:51.787]                   if (is.na(NA_character_)) 
[16:12:51.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.787]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:51.787]                     envir = parent.frame()) 
[16:12:51.787]                   {
[16:12:51.787]                     default_workers <- missing(workers)
[16:12:51.787]                     if (is.function(workers)) 
[16:12:51.787]                       workers <- workers()
[16:12:51.787]                     workers <- structure(as.integer(workers), 
[16:12:51.787]                       class = class(workers))
[16:12:51.787]                     stop_if_not(is.finite(workers), workers >= 
[16:12:51.787]                       1L)
[16:12:51.787]                     if ((workers == 1L && !inherits(workers, 
[16:12:51.787]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:51.787]                       if (default_workers) 
[16:12:51.787]                         supportsMulticore(warn = TRUE)
[16:12:51.787]                       return(sequential(..., envir = envir))
[16:12:51.787]                     }
[16:12:51.787]                     oopts <- options(mc.cores = workers)
[16:12:51.787]                     on.exit(options(oopts))
[16:12:51.787]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:51.787]                       envir = envir)
[16:12:51.787]                     if (!future$lazy) 
[16:12:51.787]                       future <- run(future)
[16:12:51.787]                     invisible(future)
[16:12:51.787]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.787]                 }
[16:12:51.787]             }
[16:12:51.787]         }
[16:12:51.787]     })
[16:12:51.787]     if (TRUE) {
[16:12:51.787]         base::sink(type = "output", split = FALSE)
[16:12:51.787]         if (TRUE) {
[16:12:51.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.787]         }
[16:12:51.787]         else {
[16:12:51.787]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.787]         }
[16:12:51.787]         base::close(...future.stdout)
[16:12:51.787]         ...future.stdout <- NULL
[16:12:51.787]     }
[16:12:51.787]     ...future.result$conditions <- ...future.conditions
[16:12:51.787]     ...future.result$finished <- base::Sys.time()
[16:12:51.787]     ...future.result
[16:12:51.787] }
[16:12:51.789] assign_globals() ...
[16:12:51.790] List of 1
[16:12:51.790]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x56233ba64880> 
[16:12:51.790]  - attr(*, "where")=List of 1
[16:12:51.790]   ..$ a:<environment: R_EmptyEnv> 
[16:12:51.790]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.790]  - attr(*, "resolved")= logi TRUE
[16:12:51.790]  - attr(*, "total_size")= num 10816
[16:12:51.790]  - attr(*, "already-done")= logi TRUE
[16:12:51.793] - copied ‘a’ to environment
[16:12:51.793] assign_globals() ... done
[16:12:51.793] requestCore(): workers = 2
[16:12:51.795] MulticoreFuture started
[16:12:51.796] - Launch lazy future ... done
[16:12:51.796] run() for ‘MulticoreFuture’ ... done
[16:12:51.797] plan(): Setting new future strategy stack:
[16:12:51.797] List of future strategies:
[16:12:51.797] 1. sequential:
[16:12:51.797]    - args: function (..., envir = parent.frame())
[16:12:51.797]    - tweaked: FALSE
[16:12:51.797]    - call: NULL
[16:12:51.798] plan(): nbrOfWorkers() = 1
[16:12:51.801] plan(): Setting new future strategy stack:
[16:12:51.801] List of future strategies:
[16:12:51.801] 1. multicore:
[16:12:51.801]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:51.801]    - tweaked: FALSE
[16:12:51.801]    - call: plan(strategy)
[16:12:51.807] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.808] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.808] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.809] 
[16:12:51.809] Searching for globals ... DONE
[16:12:51.810] - globals: [0] <none>
[16:12:51.810] getGlobalsAndPackages() ... DONE
[16:12:51.810] run() for ‘Future’ ...
[16:12:51.810] - state: ‘created’
[16:12:51.810] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:51.815] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:51.815] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:51.815]   - Field: ‘label’
[16:12:51.815]   - Field: ‘local’
[16:12:51.815]   - Field: ‘owner’
[16:12:51.815]   - Field: ‘envir’
[16:12:51.815]   - Field: ‘workers’
[16:12:51.815]   - Field: ‘packages’
[16:12:51.816]   - Field: ‘gc’
[16:12:51.816]   - Field: ‘job’
[16:12:51.816]   - Field: ‘conditions’
[16:12:51.816]   - Field: ‘expr’
[16:12:51.816]   - Field: ‘uuid’
[16:12:51.816]   - Field: ‘seed’
[16:12:51.816]   - Field: ‘version’
[16:12:51.816]   - Field: ‘result’
[16:12:51.817]   - Field: ‘asynchronous’
[16:12:51.817]   - Field: ‘calls’
[16:12:51.817]   - Field: ‘globals’
[16:12:51.817]   - Field: ‘stdout’
[16:12:51.817]   - Field: ‘earlySignal’
[16:12:51.817]   - Field: ‘lazy’
[16:12:51.817]   - Field: ‘state’
[16:12:51.817] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:51.817] - Launch lazy future ...
[16:12:51.818] Packages needed by the future expression (n = 0): <none>
[16:12:51.818] Packages needed by future strategies (n = 0): <none>
[16:12:51.819] {
[16:12:51.819]     {
[16:12:51.819]         {
[16:12:51.819]             ...future.startTime <- base::Sys.time()
[16:12:51.819]             {
[16:12:51.819]                 {
[16:12:51.819]                   {
[16:12:51.819]                     {
[16:12:51.819]                       base::local({
[16:12:51.819]                         has_future <- base::requireNamespace("future", 
[16:12:51.819]                           quietly = TRUE)
[16:12:51.819]                         if (has_future) {
[16:12:51.819]                           ns <- base::getNamespace("future")
[16:12:51.819]                           version <- ns[[".package"]][["version"]]
[16:12:51.819]                           if (is.null(version)) 
[16:12:51.819]                             version <- utils::packageVersion("future")
[16:12:51.819]                         }
[16:12:51.819]                         else {
[16:12:51.819]                           version <- NULL
[16:12:51.819]                         }
[16:12:51.819]                         if (!has_future || version < "1.8.0") {
[16:12:51.819]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.819]                             "", base::R.version$version.string), 
[16:12:51.819]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:51.819]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.819]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.819]                               "release", "version")], collapse = " "), 
[16:12:51.819]                             hostname = base::Sys.info()[["nodename"]])
[16:12:51.819]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.819]                             info)
[16:12:51.819]                           info <- base::paste(info, collapse = "; ")
[16:12:51.819]                           if (!has_future) {
[16:12:51.819]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.819]                               info)
[16:12:51.819]                           }
[16:12:51.819]                           else {
[16:12:51.819]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.819]                               info, version)
[16:12:51.819]                           }
[16:12:51.819]                           base::stop(msg)
[16:12:51.819]                         }
[16:12:51.819]                       })
[16:12:51.819]                     }
[16:12:51.819]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:51.819]                     base::options(mc.cores = 1L)
[16:12:51.819]                   }
[16:12:51.819]                   options(future.plan = NULL)
[16:12:51.819]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.819]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.819]                 }
[16:12:51.819]                 ...future.workdir <- getwd()
[16:12:51.819]             }
[16:12:51.819]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.819]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.819]         }
[16:12:51.819]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.819]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:51.819]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.819]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.819]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.819]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.819]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.819]             base::names(...future.oldOptions))
[16:12:51.819]     }
[16:12:51.819]     if (FALSE) {
[16:12:51.819]     }
[16:12:51.819]     else {
[16:12:51.819]         if (TRUE) {
[16:12:51.819]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.819]                 open = "w")
[16:12:51.819]         }
[16:12:51.819]         else {
[16:12:51.819]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.819]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.819]         }
[16:12:51.819]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.819]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.819]             base::sink(type = "output", split = FALSE)
[16:12:51.819]             base::close(...future.stdout)
[16:12:51.819]         }, add = TRUE)
[16:12:51.819]     }
[16:12:51.819]     ...future.frame <- base::sys.nframe()
[16:12:51.819]     ...future.conditions <- base::list()
[16:12:51.819]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.819]     if (FALSE) {
[16:12:51.819]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.819]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.819]     }
[16:12:51.819]     ...future.result <- base::tryCatch({
[16:12:51.819]         base::withCallingHandlers({
[16:12:51.819]             ...future.value <- base::withVisible(base::local({
[16:12:51.819]                 withCallingHandlers({
[16:12:51.819]                   1
[16:12:51.819]                 }, immediateCondition = function(cond) {
[16:12:51.819]                   save_rds <- function (object, pathname, ...) 
[16:12:51.819]                   {
[16:12:51.819]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:51.819]                     if (file_test("-f", pathname_tmp)) {
[16:12:51.819]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.819]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:51.819]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.819]                         fi_tmp[["mtime"]])
[16:12:51.819]                     }
[16:12:51.819]                     tryCatch({
[16:12:51.819]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:51.819]                     }, error = function(ex) {
[16:12:51.819]                       msg <- conditionMessage(ex)
[16:12:51.819]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.819]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:51.819]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.819]                         fi_tmp[["mtime"]], msg)
[16:12:51.819]                       ex$message <- msg
[16:12:51.819]                       stop(ex)
[16:12:51.819]                     })
[16:12:51.819]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:51.819]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:51.819]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:51.819]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.819]                       fi <- file.info(pathname)
[16:12:51.819]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:51.819]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.819]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:51.819]                         fi[["size"]], fi[["mtime"]])
[16:12:51.819]                       stop(msg)
[16:12:51.819]                     }
[16:12:51.819]                     invisible(pathname)
[16:12:51.819]                   }
[16:12:51.819]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:51.819]                     rootPath = tempdir()) 
[16:12:51.819]                   {
[16:12:51.819]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:51.819]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:51.819]                       tmpdir = path, fileext = ".rds")
[16:12:51.819]                     save_rds(obj, file)
[16:12:51.819]                   }
[16:12:51.819]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:51.819]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.819]                   {
[16:12:51.819]                     inherits <- base::inherits
[16:12:51.819]                     invokeRestart <- base::invokeRestart
[16:12:51.819]                     is.null <- base::is.null
[16:12:51.819]                     muffled <- FALSE
[16:12:51.819]                     if (inherits(cond, "message")) {
[16:12:51.819]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:51.819]                       if (muffled) 
[16:12:51.819]                         invokeRestart("muffleMessage")
[16:12:51.819]                     }
[16:12:51.819]                     else if (inherits(cond, "warning")) {
[16:12:51.819]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:51.819]                       if (muffled) 
[16:12:51.819]                         invokeRestart("muffleWarning")
[16:12:51.819]                     }
[16:12:51.819]                     else if (inherits(cond, "condition")) {
[16:12:51.819]                       if (!is.null(pattern)) {
[16:12:51.819]                         computeRestarts <- base::computeRestarts
[16:12:51.819]                         grepl <- base::grepl
[16:12:51.819]                         restarts <- computeRestarts(cond)
[16:12:51.819]                         for (restart in restarts) {
[16:12:51.819]                           name <- restart$name
[16:12:51.819]                           if (is.null(name)) 
[16:12:51.819]                             next
[16:12:51.819]                           if (!grepl(pattern, name)) 
[16:12:51.819]                             next
[16:12:51.819]                           invokeRestart(restart)
[16:12:51.819]                           muffled <- TRUE
[16:12:51.819]                           break
[16:12:51.819]                         }
[16:12:51.819]                       }
[16:12:51.819]                     }
[16:12:51.819]                     invisible(muffled)
[16:12:51.819]                   }
[16:12:51.819]                   muffleCondition(cond)
[16:12:51.819]                 })
[16:12:51.819]             }))
[16:12:51.819]             future::FutureResult(value = ...future.value$value, 
[16:12:51.819]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.819]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.819]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.819]                     ...future.globalenv.names))
[16:12:51.819]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.819]         }, condition = base::local({
[16:12:51.819]             c <- base::c
[16:12:51.819]             inherits <- base::inherits
[16:12:51.819]             invokeRestart <- base::invokeRestart
[16:12:51.819]             length <- base::length
[16:12:51.819]             list <- base::list
[16:12:51.819]             seq.int <- base::seq.int
[16:12:51.819]             signalCondition <- base::signalCondition
[16:12:51.819]             sys.calls <- base::sys.calls
[16:12:51.819]             `[[` <- base::`[[`
[16:12:51.819]             `+` <- base::`+`
[16:12:51.819]             `<<-` <- base::`<<-`
[16:12:51.819]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.819]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.819]                   3L)]
[16:12:51.819]             }
[16:12:51.819]             function(cond) {
[16:12:51.819]                 is_error <- inherits(cond, "error")
[16:12:51.819]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.819]                   NULL)
[16:12:51.819]                 if (is_error) {
[16:12:51.819]                   sessionInformation <- function() {
[16:12:51.819]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.819]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.819]                       search = base::search(), system = base::Sys.info())
[16:12:51.819]                   }
[16:12:51.819]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.819]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.819]                     cond$call), session = sessionInformation(), 
[16:12:51.819]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.819]                   signalCondition(cond)
[16:12:51.819]                 }
[16:12:51.819]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.819]                 "immediateCondition"))) {
[16:12:51.819]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.819]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.819]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.819]                   if (TRUE && !signal) {
[16:12:51.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.819]                     {
[16:12:51.819]                       inherits <- base::inherits
[16:12:51.819]                       invokeRestart <- base::invokeRestart
[16:12:51.819]                       is.null <- base::is.null
[16:12:51.819]                       muffled <- FALSE
[16:12:51.819]                       if (inherits(cond, "message")) {
[16:12:51.819]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.819]                         if (muffled) 
[16:12:51.819]                           invokeRestart("muffleMessage")
[16:12:51.819]                       }
[16:12:51.819]                       else if (inherits(cond, "warning")) {
[16:12:51.819]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.819]                         if (muffled) 
[16:12:51.819]                           invokeRestart("muffleWarning")
[16:12:51.819]                       }
[16:12:51.819]                       else if (inherits(cond, "condition")) {
[16:12:51.819]                         if (!is.null(pattern)) {
[16:12:51.819]                           computeRestarts <- base::computeRestarts
[16:12:51.819]                           grepl <- base::grepl
[16:12:51.819]                           restarts <- computeRestarts(cond)
[16:12:51.819]                           for (restart in restarts) {
[16:12:51.819]                             name <- restart$name
[16:12:51.819]                             if (is.null(name)) 
[16:12:51.819]                               next
[16:12:51.819]                             if (!grepl(pattern, name)) 
[16:12:51.819]                               next
[16:12:51.819]                             invokeRestart(restart)
[16:12:51.819]                             muffled <- TRUE
[16:12:51.819]                             break
[16:12:51.819]                           }
[16:12:51.819]                         }
[16:12:51.819]                       }
[16:12:51.819]                       invisible(muffled)
[16:12:51.819]                     }
[16:12:51.819]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.819]                   }
[16:12:51.819]                 }
[16:12:51.819]                 else {
[16:12:51.819]                   if (TRUE) {
[16:12:51.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.819]                     {
[16:12:51.819]                       inherits <- base::inherits
[16:12:51.819]                       invokeRestart <- base::invokeRestart
[16:12:51.819]                       is.null <- base::is.null
[16:12:51.819]                       muffled <- FALSE
[16:12:51.819]                       if (inherits(cond, "message")) {
[16:12:51.819]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.819]                         if (muffled) 
[16:12:51.819]                           invokeRestart("muffleMessage")
[16:12:51.819]                       }
[16:12:51.819]                       else if (inherits(cond, "warning")) {
[16:12:51.819]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.819]                         if (muffled) 
[16:12:51.819]                           invokeRestart("muffleWarning")
[16:12:51.819]                       }
[16:12:51.819]                       else if (inherits(cond, "condition")) {
[16:12:51.819]                         if (!is.null(pattern)) {
[16:12:51.819]                           computeRestarts <- base::computeRestarts
[16:12:51.819]                           grepl <- base::grepl
[16:12:51.819]                           restarts <- computeRestarts(cond)
[16:12:51.819]                           for (restart in restarts) {
[16:12:51.819]                             name <- restart$name
[16:12:51.819]                             if (is.null(name)) 
[16:12:51.819]                               next
[16:12:51.819]                             if (!grepl(pattern, name)) 
[16:12:51.819]                               next
[16:12:51.819]                             invokeRestart(restart)
[16:12:51.819]                             muffled <- TRUE
[16:12:51.819]                             break
[16:12:51.819]                           }
[16:12:51.819]                         }
[16:12:51.819]                       }
[16:12:51.819]                       invisible(muffled)
[16:12:51.819]                     }
[16:12:51.819]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.819]                   }
[16:12:51.819]                 }
[16:12:51.819]             }
[16:12:51.819]         }))
[16:12:51.819]     }, error = function(ex) {
[16:12:51.819]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.819]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.819]                 ...future.rng), started = ...future.startTime, 
[16:12:51.819]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.819]             version = "1.8"), class = "FutureResult")
[16:12:51.819]     }, finally = {
[16:12:51.819]         if (!identical(...future.workdir, getwd())) 
[16:12:51.819]             setwd(...future.workdir)
[16:12:51.819]         {
[16:12:51.819]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.819]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.819]             }
[16:12:51.819]             base::options(...future.oldOptions)
[16:12:51.819]             if (.Platform$OS.type == "windows") {
[16:12:51.819]                 old_names <- names(...future.oldEnvVars)
[16:12:51.819]                 envs <- base::Sys.getenv()
[16:12:51.819]                 names <- names(envs)
[16:12:51.819]                 common <- intersect(names, old_names)
[16:12:51.819]                 added <- setdiff(names, old_names)
[16:12:51.819]                 removed <- setdiff(old_names, names)
[16:12:51.819]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.819]                   envs[common]]
[16:12:51.819]                 NAMES <- toupper(changed)
[16:12:51.819]                 args <- list()
[16:12:51.819]                 for (kk in seq_along(NAMES)) {
[16:12:51.819]                   name <- changed[[kk]]
[16:12:51.819]                   NAME <- NAMES[[kk]]
[16:12:51.819]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.819]                     next
[16:12:51.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.819]                 }
[16:12:51.819]                 NAMES <- toupper(added)
[16:12:51.819]                 for (kk in seq_along(NAMES)) {
[16:12:51.819]                   name <- added[[kk]]
[16:12:51.819]                   NAME <- NAMES[[kk]]
[16:12:51.819]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.819]                     next
[16:12:51.819]                   args[[name]] <- ""
[16:12:51.819]                 }
[16:12:51.819]                 NAMES <- toupper(removed)
[16:12:51.819]                 for (kk in seq_along(NAMES)) {
[16:12:51.819]                   name <- removed[[kk]]
[16:12:51.819]                   NAME <- NAMES[[kk]]
[16:12:51.819]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.819]                     next
[16:12:51.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.819]                 }
[16:12:51.819]                 if (length(args) > 0) 
[16:12:51.819]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.819]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.819]             }
[16:12:51.819]             else {
[16:12:51.819]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.819]             }
[16:12:51.819]             {
[16:12:51.819]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.819]                   0L) {
[16:12:51.819]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.819]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.819]                   base::options(opts)
[16:12:51.819]                 }
[16:12:51.819]                 {
[16:12:51.819]                   {
[16:12:51.819]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:51.819]                     NULL
[16:12:51.819]                   }
[16:12:51.819]                   options(future.plan = NULL)
[16:12:51.819]                   if (is.na(NA_character_)) 
[16:12:51.819]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.819]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.819]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:51.819]                     envir = parent.frame()) 
[16:12:51.819]                   {
[16:12:51.819]                     default_workers <- missing(workers)
[16:12:51.819]                     if (is.function(workers)) 
[16:12:51.819]                       workers <- workers()
[16:12:51.819]                     workers <- structure(as.integer(workers), 
[16:12:51.819]                       class = class(workers))
[16:12:51.819]                     stop_if_not(is.finite(workers), workers >= 
[16:12:51.819]                       1L)
[16:12:51.819]                     if ((workers == 1L && !inherits(workers, 
[16:12:51.819]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:51.819]                       if (default_workers) 
[16:12:51.819]                         supportsMulticore(warn = TRUE)
[16:12:51.819]                       return(sequential(..., envir = envir))
[16:12:51.819]                     }
[16:12:51.819]                     oopts <- options(mc.cores = workers)
[16:12:51.819]                     on.exit(options(oopts))
[16:12:51.819]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:51.819]                       envir = envir)
[16:12:51.819]                     if (!future$lazy) 
[16:12:51.819]                       future <- run(future)
[16:12:51.819]                     invisible(future)
[16:12:51.819]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.819]                 }
[16:12:51.819]             }
[16:12:51.819]         }
[16:12:51.819]     })
[16:12:51.819]     if (TRUE) {
[16:12:51.819]         base::sink(type = "output", split = FALSE)
[16:12:51.819]         if (TRUE) {
[16:12:51.819]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.819]         }
[16:12:51.819]         else {
[16:12:51.819]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.819]         }
[16:12:51.819]         base::close(...future.stdout)
[16:12:51.819]         ...future.stdout <- NULL
[16:12:51.819]     }
[16:12:51.819]     ...future.result$conditions <- ...future.conditions
[16:12:51.819]     ...future.result$finished <- base::Sys.time()
[16:12:51.819]     ...future.result
[16:12:51.819] }
[16:12:51.822] requestCore(): workers = 2
[16:12:51.823] MulticoreFuture started
[16:12:51.824] - Launch lazy future ... done
[16:12:51.824] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.824] getGlobalsAndPackages() ...
[16:12:51.824] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.825] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.825] List of future strategies:
[16:12:51.825] 1. sequential:
[16:12:51.825]    - args: function (..., envir = parent.frame())
[16:12:51.825]    - tweaked: FALSE
[16:12:51.825]    - call: NULL
[16:12:51.826] plan(): nbrOfWorkers() = 1
[16:12:51.827] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:51.827] Searching for globals ... DONE
[16:12:51.827] Resolving globals: TRUE
[16:12:51.827] Resolving any globals that are futures ...
[16:12:51.827] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:51.827] plan(): Setting new future strategy stack:
[16:12:51.828] Resolving any globals that are futures ... DONE
[16:12:51.828] List of future strategies:
[16:12:51.828] 1. multicore:
[16:12:51.828]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:51.828]    - tweaked: FALSE
[16:12:51.828]    - call: plan(strategy)
[16:12:51.828] Resolving futures part of globals (recursively) ...
[16:12:51.829] resolve() on list ...
[16:12:51.829]  recursive: 99
[16:12:51.829]  length: 1
[16:12:51.829]  elements: ‘a’
[16:12:51.832] plan(): nbrOfWorkers() = 2
[16:12:51.833] Future #1
[16:12:51.834] A MulticoreFuture was resolved
[16:12:51.834]  length: 0 (resolved future 1)
[16:12:51.835] resolve() on list ... DONE
[16:12:51.835] - globals: [1] ‘a’
[16:12:51.835] Resolving futures part of globals (recursively) ... DONE
[16:12:51.839] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[16:12:51.840] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[16:12:51.840] - globals: [1] ‘a’
[16:12:51.840] - packages: [1] ‘future’
[16:12:51.840] getGlobalsAndPackages() ... DONE
[16:12:51.841] run() for ‘Future’ ...
[16:12:51.841] - state: ‘created’
[16:12:51.841] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:51.846] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:51.846] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:51.846]   - Field: ‘label’
[16:12:51.846]   - Field: ‘local’
[16:12:51.846]   - Field: ‘owner’
[16:12:51.846]   - Field: ‘envir’
[16:12:51.846]   - Field: ‘workers’
[16:12:51.847]   - Field: ‘packages’
[16:12:51.847]   - Field: ‘gc’
[16:12:51.847]   - Field: ‘job’
[16:12:51.847]   - Field: ‘conditions’
[16:12:51.847]   - Field: ‘expr’
[16:12:51.847]   - Field: ‘uuid’
[16:12:51.847]   - Field: ‘seed’
[16:12:51.847]   - Field: ‘version’
[16:12:51.847]   - Field: ‘result’
[16:12:51.848]   - Field: ‘asynchronous’
[16:12:51.848]   - Field: ‘calls’
[16:12:51.848]   - Field: ‘globals’
[16:12:51.848]   - Field: ‘stdout’
[16:12:51.848]   - Field: ‘earlySignal’
[16:12:51.848]   - Field: ‘lazy’
[16:12:51.848]   - Field: ‘state’
[16:12:51.848] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:51.848] - Launch lazy future ...
[16:12:51.849] Packages needed by the future expression (n = 1): ‘future’
[16:12:51.849] Packages needed by future strategies (n = 0): <none>
[16:12:51.850] {
[16:12:51.850]     {
[16:12:51.850]         {
[16:12:51.850]             ...future.startTime <- base::Sys.time()
[16:12:51.850]             {
[16:12:51.850]                 {
[16:12:51.850]                   {
[16:12:51.850]                     {
[16:12:51.850]                       {
[16:12:51.850]                         base::local({
[16:12:51.850]                           has_future <- base::requireNamespace("future", 
[16:12:51.850]                             quietly = TRUE)
[16:12:51.850]                           if (has_future) {
[16:12:51.850]                             ns <- base::getNamespace("future")
[16:12:51.850]                             version <- ns[[".package"]][["version"]]
[16:12:51.850]                             if (is.null(version)) 
[16:12:51.850]                               version <- utils::packageVersion("future")
[16:12:51.850]                           }
[16:12:51.850]                           else {
[16:12:51.850]                             version <- NULL
[16:12:51.850]                           }
[16:12:51.850]                           if (!has_future || version < "1.8.0") {
[16:12:51.850]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.850]                               "", base::R.version$version.string), 
[16:12:51.850]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:51.850]                                 base::R.version$platform, 8 * 
[16:12:51.850]                                   base::.Machine$sizeof.pointer), 
[16:12:51.850]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.850]                                 "release", "version")], collapse = " "), 
[16:12:51.850]                               hostname = base::Sys.info()[["nodename"]])
[16:12:51.850]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.850]                               info)
[16:12:51.850]                             info <- base::paste(info, collapse = "; ")
[16:12:51.850]                             if (!has_future) {
[16:12:51.850]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.850]                                 info)
[16:12:51.850]                             }
[16:12:51.850]                             else {
[16:12:51.850]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.850]                                 info, version)
[16:12:51.850]                             }
[16:12:51.850]                             base::stop(msg)
[16:12:51.850]                           }
[16:12:51.850]                         })
[16:12:51.850]                       }
[16:12:51.850]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:51.850]                       base::options(mc.cores = 1L)
[16:12:51.850]                     }
[16:12:51.850]                     base::local({
[16:12:51.850]                       for (pkg in "future") {
[16:12:51.850]                         base::loadNamespace(pkg)
[16:12:51.850]                         base::library(pkg, character.only = TRUE)
[16:12:51.850]                       }
[16:12:51.850]                     })
[16:12:51.850]                   }
[16:12:51.850]                   options(future.plan = NULL)
[16:12:51.850]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.850]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.850]                 }
[16:12:51.850]                 ...future.workdir <- getwd()
[16:12:51.850]             }
[16:12:51.850]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.850]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.850]         }
[16:12:51.850]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.850]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:51.850]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.850]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.850]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.850]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.850]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.850]             base::names(...future.oldOptions))
[16:12:51.850]     }
[16:12:51.850]     if (FALSE) {
[16:12:51.850]     }
[16:12:51.850]     else {
[16:12:51.850]         if (TRUE) {
[16:12:51.850]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.850]                 open = "w")
[16:12:51.850]         }
[16:12:51.850]         else {
[16:12:51.850]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.850]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.850]         }
[16:12:51.850]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.850]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.850]             base::sink(type = "output", split = FALSE)
[16:12:51.850]             base::close(...future.stdout)
[16:12:51.850]         }, add = TRUE)
[16:12:51.850]     }
[16:12:51.850]     ...future.frame <- base::sys.nframe()
[16:12:51.850]     ...future.conditions <- base::list()
[16:12:51.850]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.850]     if (FALSE) {
[16:12:51.850]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.850]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.850]     }
[16:12:51.850]     ...future.result <- base::tryCatch({
[16:12:51.850]         base::withCallingHandlers({
[16:12:51.850]             ...future.value <- base::withVisible(base::local({
[16:12:51.850]                 withCallingHandlers({
[16:12:51.850]                   value(a) + 1
[16:12:51.850]                 }, immediateCondition = function(cond) {
[16:12:51.850]                   save_rds <- function (object, pathname, ...) 
[16:12:51.850]                   {
[16:12:51.850]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:51.850]                     if (file_test("-f", pathname_tmp)) {
[16:12:51.850]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.850]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:51.850]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.850]                         fi_tmp[["mtime"]])
[16:12:51.850]                     }
[16:12:51.850]                     tryCatch({
[16:12:51.850]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:51.850]                     }, error = function(ex) {
[16:12:51.850]                       msg <- conditionMessage(ex)
[16:12:51.850]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.850]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:51.850]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.850]                         fi_tmp[["mtime"]], msg)
[16:12:51.850]                       ex$message <- msg
[16:12:51.850]                       stop(ex)
[16:12:51.850]                     })
[16:12:51.850]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:51.850]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:51.850]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:51.850]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.850]                       fi <- file.info(pathname)
[16:12:51.850]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:51.850]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.850]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:51.850]                         fi[["size"]], fi[["mtime"]])
[16:12:51.850]                       stop(msg)
[16:12:51.850]                     }
[16:12:51.850]                     invisible(pathname)
[16:12:51.850]                   }
[16:12:51.850]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:51.850]                     rootPath = tempdir()) 
[16:12:51.850]                   {
[16:12:51.850]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:51.850]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:51.850]                       tmpdir = path, fileext = ".rds")
[16:12:51.850]                     save_rds(obj, file)
[16:12:51.850]                   }
[16:12:51.850]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:51.850]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.850]                   {
[16:12:51.850]                     inherits <- base::inherits
[16:12:51.850]                     invokeRestart <- base::invokeRestart
[16:12:51.850]                     is.null <- base::is.null
[16:12:51.850]                     muffled <- FALSE
[16:12:51.850]                     if (inherits(cond, "message")) {
[16:12:51.850]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:51.850]                       if (muffled) 
[16:12:51.850]                         invokeRestart("muffleMessage")
[16:12:51.850]                     }
[16:12:51.850]                     else if (inherits(cond, "warning")) {
[16:12:51.850]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:51.850]                       if (muffled) 
[16:12:51.850]                         invokeRestart("muffleWarning")
[16:12:51.850]                     }
[16:12:51.850]                     else if (inherits(cond, "condition")) {
[16:12:51.850]                       if (!is.null(pattern)) {
[16:12:51.850]                         computeRestarts <- base::computeRestarts
[16:12:51.850]                         grepl <- base::grepl
[16:12:51.850]                         restarts <- computeRestarts(cond)
[16:12:51.850]                         for (restart in restarts) {
[16:12:51.850]                           name <- restart$name
[16:12:51.850]                           if (is.null(name)) 
[16:12:51.850]                             next
[16:12:51.850]                           if (!grepl(pattern, name)) 
[16:12:51.850]                             next
[16:12:51.850]                           invokeRestart(restart)
[16:12:51.850]                           muffled <- TRUE
[16:12:51.850]                           break
[16:12:51.850]                         }
[16:12:51.850]                       }
[16:12:51.850]                     }
[16:12:51.850]                     invisible(muffled)
[16:12:51.850]                   }
[16:12:51.850]                   muffleCondition(cond)
[16:12:51.850]                 })
[16:12:51.850]             }))
[16:12:51.850]             future::FutureResult(value = ...future.value$value, 
[16:12:51.850]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.850]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.850]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.850]                     ...future.globalenv.names))
[16:12:51.850]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.850]         }, condition = base::local({
[16:12:51.850]             c <- base::c
[16:12:51.850]             inherits <- base::inherits
[16:12:51.850]             invokeRestart <- base::invokeRestart
[16:12:51.850]             length <- base::length
[16:12:51.850]             list <- base::list
[16:12:51.850]             seq.int <- base::seq.int
[16:12:51.850]             signalCondition <- base::signalCondition
[16:12:51.850]             sys.calls <- base::sys.calls
[16:12:51.850]             `[[` <- base::`[[`
[16:12:51.850]             `+` <- base::`+`
[16:12:51.850]             `<<-` <- base::`<<-`
[16:12:51.850]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.850]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.850]                   3L)]
[16:12:51.850]             }
[16:12:51.850]             function(cond) {
[16:12:51.850]                 is_error <- inherits(cond, "error")
[16:12:51.850]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.850]                   NULL)
[16:12:51.850]                 if (is_error) {
[16:12:51.850]                   sessionInformation <- function() {
[16:12:51.850]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.850]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.850]                       search = base::search(), system = base::Sys.info())
[16:12:51.850]                   }
[16:12:51.850]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.850]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.850]                     cond$call), session = sessionInformation(), 
[16:12:51.850]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.850]                   signalCondition(cond)
[16:12:51.850]                 }
[16:12:51.850]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.850]                 "immediateCondition"))) {
[16:12:51.850]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.850]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.850]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.850]                   if (TRUE && !signal) {
[16:12:51.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.850]                     {
[16:12:51.850]                       inherits <- base::inherits
[16:12:51.850]                       invokeRestart <- base::invokeRestart
[16:12:51.850]                       is.null <- base::is.null
[16:12:51.850]                       muffled <- FALSE
[16:12:51.850]                       if (inherits(cond, "message")) {
[16:12:51.850]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.850]                         if (muffled) 
[16:12:51.850]                           invokeRestart("muffleMessage")
[16:12:51.850]                       }
[16:12:51.850]                       else if (inherits(cond, "warning")) {
[16:12:51.850]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.850]                         if (muffled) 
[16:12:51.850]                           invokeRestart("muffleWarning")
[16:12:51.850]                       }
[16:12:51.850]                       else if (inherits(cond, "condition")) {
[16:12:51.850]                         if (!is.null(pattern)) {
[16:12:51.850]                           computeRestarts <- base::computeRestarts
[16:12:51.850]                           grepl <- base::grepl
[16:12:51.850]                           restarts <- computeRestarts(cond)
[16:12:51.850]                           for (restart in restarts) {
[16:12:51.850]                             name <- restart$name
[16:12:51.850]                             if (is.null(name)) 
[16:12:51.850]                               next
[16:12:51.850]                             if (!grepl(pattern, name)) 
[16:12:51.850]                               next
[16:12:51.850]                             invokeRestart(restart)
[16:12:51.850]                             muffled <- TRUE
[16:12:51.850]                             break
[16:12:51.850]                           }
[16:12:51.850]                         }
[16:12:51.850]                       }
[16:12:51.850]                       invisible(muffled)
[16:12:51.850]                     }
[16:12:51.850]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.850]                   }
[16:12:51.850]                 }
[16:12:51.850]                 else {
[16:12:51.850]                   if (TRUE) {
[16:12:51.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.850]                     {
[16:12:51.850]                       inherits <- base::inherits
[16:12:51.850]                       invokeRestart <- base::invokeRestart
[16:12:51.850]                       is.null <- base::is.null
[16:12:51.850]                       muffled <- FALSE
[16:12:51.850]                       if (inherits(cond, "message")) {
[16:12:51.850]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.850]                         if (muffled) 
[16:12:51.850]                           invokeRestart("muffleMessage")
[16:12:51.850]                       }
[16:12:51.850]                       else if (inherits(cond, "warning")) {
[16:12:51.850]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.850]                         if (muffled) 
[16:12:51.850]                           invokeRestart("muffleWarning")
[16:12:51.850]                       }
[16:12:51.850]                       else if (inherits(cond, "condition")) {
[16:12:51.850]                         if (!is.null(pattern)) {
[16:12:51.850]                           computeRestarts <- base::computeRestarts
[16:12:51.850]                           grepl <- base::grepl
[16:12:51.850]                           restarts <- computeRestarts(cond)
[16:12:51.850]                           for (restart in restarts) {
[16:12:51.850]                             name <- restart$name
[16:12:51.850]                             if (is.null(name)) 
[16:12:51.850]                               next
[16:12:51.850]                             if (!grepl(pattern, name)) 
[16:12:51.850]                               next
[16:12:51.850]                             invokeRestart(restart)
[16:12:51.850]                             muffled <- TRUE
[16:12:51.850]                             break
[16:12:51.850]                           }
[16:12:51.850]                         }
[16:12:51.850]                       }
[16:12:51.850]                       invisible(muffled)
[16:12:51.850]                     }
[16:12:51.850]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.850]                   }
[16:12:51.850]                 }
[16:12:51.850]             }
[16:12:51.850]         }))
[16:12:51.850]     }, error = function(ex) {
[16:12:51.850]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.850]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.850]                 ...future.rng), started = ...future.startTime, 
[16:12:51.850]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.850]             version = "1.8"), class = "FutureResult")
[16:12:51.850]     }, finally = {
[16:12:51.850]         if (!identical(...future.workdir, getwd())) 
[16:12:51.850]             setwd(...future.workdir)
[16:12:51.850]         {
[16:12:51.850]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.850]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.850]             }
[16:12:51.850]             base::options(...future.oldOptions)
[16:12:51.850]             if (.Platform$OS.type == "windows") {
[16:12:51.850]                 old_names <- names(...future.oldEnvVars)
[16:12:51.850]                 envs <- base::Sys.getenv()
[16:12:51.850]                 names <- names(envs)
[16:12:51.850]                 common <- intersect(names, old_names)
[16:12:51.850]                 added <- setdiff(names, old_names)
[16:12:51.850]                 removed <- setdiff(old_names, names)
[16:12:51.850]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.850]                   envs[common]]
[16:12:51.850]                 NAMES <- toupper(changed)
[16:12:51.850]                 args <- list()
[16:12:51.850]                 for (kk in seq_along(NAMES)) {
[16:12:51.850]                   name <- changed[[kk]]
[16:12:51.850]                   NAME <- NAMES[[kk]]
[16:12:51.850]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.850]                     next
[16:12:51.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.850]                 }
[16:12:51.850]                 NAMES <- toupper(added)
[16:12:51.850]                 for (kk in seq_along(NAMES)) {
[16:12:51.850]                   name <- added[[kk]]
[16:12:51.850]                   NAME <- NAMES[[kk]]
[16:12:51.850]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.850]                     next
[16:12:51.850]                   args[[name]] <- ""
[16:12:51.850]                 }
[16:12:51.850]                 NAMES <- toupper(removed)
[16:12:51.850]                 for (kk in seq_along(NAMES)) {
[16:12:51.850]                   name <- removed[[kk]]
[16:12:51.850]                   NAME <- NAMES[[kk]]
[16:12:51.850]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.850]                     next
[16:12:51.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.850]                 }
[16:12:51.850]                 if (length(args) > 0) 
[16:12:51.850]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.850]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.850]             }
[16:12:51.850]             else {
[16:12:51.850]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.850]             }
[16:12:51.850]             {
[16:12:51.850]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.850]                   0L) {
[16:12:51.850]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.850]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.850]                   base::options(opts)
[16:12:51.850]                 }
[16:12:51.850]                 {
[16:12:51.850]                   {
[16:12:51.850]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:51.850]                     NULL
[16:12:51.850]                   }
[16:12:51.850]                   options(future.plan = NULL)
[16:12:51.850]                   if (is.na(NA_character_)) 
[16:12:51.850]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.850]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.850]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:51.850]                     envir = parent.frame()) 
[16:12:51.850]                   {
[16:12:51.850]                     default_workers <- missing(workers)
[16:12:51.850]                     if (is.function(workers)) 
[16:12:51.850]                       workers <- workers()
[16:12:51.850]                     workers <- structure(as.integer(workers), 
[16:12:51.850]                       class = class(workers))
[16:12:51.850]                     stop_if_not(is.finite(workers), workers >= 
[16:12:51.850]                       1L)
[16:12:51.850]                     if ((workers == 1L && !inherits(workers, 
[16:12:51.850]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:51.850]                       if (default_workers) 
[16:12:51.850]                         supportsMulticore(warn = TRUE)
[16:12:51.850]                       return(sequential(..., envir = envir))
[16:12:51.850]                     }
[16:12:51.850]                     oopts <- options(mc.cores = workers)
[16:12:51.850]                     on.exit(options(oopts))
[16:12:51.850]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:51.850]                       envir = envir)
[16:12:51.850]                     if (!future$lazy) 
[16:12:51.850]                       future <- run(future)
[16:12:51.850]                     invisible(future)
[16:12:51.850]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.850]                 }
[16:12:51.850]             }
[16:12:51.850]         }
[16:12:51.850]     })
[16:12:51.850]     if (TRUE) {
[16:12:51.850]         base::sink(type = "output", split = FALSE)
[16:12:51.850]         if (TRUE) {
[16:12:51.850]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.850]         }
[16:12:51.850]         else {
[16:12:51.850]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.850]         }
[16:12:51.850]         base::close(...future.stdout)
[16:12:51.850]         ...future.stdout <- NULL
[16:12:51.850]     }
[16:12:51.850]     ...future.result$conditions <- ...future.conditions
[16:12:51.850]     ...future.result$finished <- base::Sys.time()
[16:12:51.850]     ...future.result
[16:12:51.850] }
[16:12:51.852] assign_globals() ...
[16:12:51.852] List of 1
[16:12:51.852]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x56233cf53a90> 
[16:12:51.852]  - attr(*, "where")=List of 1
[16:12:51.852]   ..$ a:<environment: R_EmptyEnv> 
[16:12:51.852]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.852]  - attr(*, "resolved")= logi TRUE
[16:12:51.852]  - attr(*, "total_size")= num 10816
[16:12:51.852]  - attr(*, "already-done")= logi TRUE
[16:12:51.855] - copied ‘a’ to environment
[16:12:51.855] assign_globals() ... done
[16:12:51.855] requestCore(): workers = 2
[16:12:51.857] MulticoreFuture started
[16:12:51.858] - Launch lazy future ... done
[16:12:51.858] run() for ‘MulticoreFuture’ ... done
[16:12:51.859] plan(): Setting new future strategy stack:
[16:12:51.859] List of future strategies:
[16:12:51.859] 1. sequential:
[16:12:51.859]    - args: function (..., envir = parent.frame())
[16:12:51.859]    - tweaked: FALSE
[16:12:51.859]    - call: NULL
[16:12:51.860] plan(): nbrOfWorkers() = 1
[16:12:51.862] plan(): Setting new future strategy stack:
[16:12:51.862] List of future strategies:
[16:12:51.862] 1. multicore:
[16:12:51.862]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:51.862]    - tweaked: FALSE
[16:12:51.862]    - call: plan(strategy)
[16:12:51.867] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.869] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.869] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.870] 
[16:12:51.870] Searching for globals ... DONE
[16:12:51.870] - globals: [0] <none>
[16:12:51.871] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.871] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.871] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.872] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:51.873] Searching for globals ... DONE
[16:12:51.873] Resolving globals: TRUE
[16:12:51.873] Resolving any globals that are futures ...
[16:12:51.873] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:51.873] Resolving any globals that are futures ... DONE
[16:12:51.873] Resolving futures part of globals (recursively) ...
[16:12:51.874] resolve() on list ...
[16:12:51.874]  recursive: 99
[16:12:51.874]  length: 1
[16:12:51.874]  elements: ‘a’
[16:12:51.874] run() for ‘Future’ ...
[16:12:51.874] - state: ‘created’
[16:12:51.875] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:51.879] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:51.879] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:51.879]   - Field: ‘label’
[16:12:51.879]   - Field: ‘local’
[16:12:51.879]   - Field: ‘owner’
[16:12:51.879]   - Field: ‘envir’
[16:12:51.880]   - Field: ‘workers’
[16:12:51.880]   - Field: ‘packages’
[16:12:51.880]   - Field: ‘gc’
[16:12:51.880]   - Field: ‘job’
[16:12:51.880]   - Field: ‘conditions’
[16:12:51.880]   - Field: ‘expr’
[16:12:51.880]   - Field: ‘uuid’
[16:12:51.880]   - Field: ‘seed’
[16:12:51.881]   - Field: ‘version’
[16:12:51.881]   - Field: ‘result’
[16:12:51.881]   - Field: ‘asynchronous’
[16:12:51.883]   - Field: ‘calls’
[16:12:51.883]   - Field: ‘globals’
[16:12:51.883]   - Field: ‘stdout’
[16:12:51.884]   - Field: ‘earlySignal’
[16:12:51.884]   - Field: ‘lazy’
[16:12:51.884]   - Field: ‘state’
[16:12:51.884] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:51.884] - Launch lazy future ...
[16:12:51.885] Packages needed by the future expression (n = 0): <none>
[16:12:51.885] Packages needed by future strategies (n = 0): <none>
[16:12:51.886] {
[16:12:51.886]     {
[16:12:51.886]         {
[16:12:51.886]             ...future.startTime <- base::Sys.time()
[16:12:51.886]             {
[16:12:51.886]                 {
[16:12:51.886]                   {
[16:12:51.886]                     {
[16:12:51.886]                       base::local({
[16:12:51.886]                         has_future <- base::requireNamespace("future", 
[16:12:51.886]                           quietly = TRUE)
[16:12:51.886]                         if (has_future) {
[16:12:51.886]                           ns <- base::getNamespace("future")
[16:12:51.886]                           version <- ns[[".package"]][["version"]]
[16:12:51.886]                           if (is.null(version)) 
[16:12:51.886]                             version <- utils::packageVersion("future")
[16:12:51.886]                         }
[16:12:51.886]                         else {
[16:12:51.886]                           version <- NULL
[16:12:51.886]                         }
[16:12:51.886]                         if (!has_future || version < "1.8.0") {
[16:12:51.886]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.886]                             "", base::R.version$version.string), 
[16:12:51.886]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:51.886]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.886]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.886]                               "release", "version")], collapse = " "), 
[16:12:51.886]                             hostname = base::Sys.info()[["nodename"]])
[16:12:51.886]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.886]                             info)
[16:12:51.886]                           info <- base::paste(info, collapse = "; ")
[16:12:51.886]                           if (!has_future) {
[16:12:51.886]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.886]                               info)
[16:12:51.886]                           }
[16:12:51.886]                           else {
[16:12:51.886]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.886]                               info, version)
[16:12:51.886]                           }
[16:12:51.886]                           base::stop(msg)
[16:12:51.886]                         }
[16:12:51.886]                       })
[16:12:51.886]                     }
[16:12:51.886]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:51.886]                     base::options(mc.cores = 1L)
[16:12:51.886]                   }
[16:12:51.886]                   options(future.plan = NULL)
[16:12:51.886]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.886]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.886]                 }
[16:12:51.886]                 ...future.workdir <- getwd()
[16:12:51.886]             }
[16:12:51.886]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.886]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.886]         }
[16:12:51.886]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.886]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:51.886]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.886]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.886]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.886]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.886]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.886]             base::names(...future.oldOptions))
[16:12:51.886]     }
[16:12:51.886]     if (FALSE) {
[16:12:51.886]     }
[16:12:51.886]     else {
[16:12:51.886]         if (TRUE) {
[16:12:51.886]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.886]                 open = "w")
[16:12:51.886]         }
[16:12:51.886]         else {
[16:12:51.886]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.886]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.886]         }
[16:12:51.886]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.886]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.886]             base::sink(type = "output", split = FALSE)
[16:12:51.886]             base::close(...future.stdout)
[16:12:51.886]         }, add = TRUE)
[16:12:51.886]     }
[16:12:51.886]     ...future.frame <- base::sys.nframe()
[16:12:51.886]     ...future.conditions <- base::list()
[16:12:51.886]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.886]     if (FALSE) {
[16:12:51.886]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.886]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.886]     }
[16:12:51.886]     ...future.result <- base::tryCatch({
[16:12:51.886]         base::withCallingHandlers({
[16:12:51.886]             ...future.value <- base::withVisible(base::local({
[16:12:51.886]                 withCallingHandlers({
[16:12:51.886]                   1
[16:12:51.886]                 }, immediateCondition = function(cond) {
[16:12:51.886]                   save_rds <- function (object, pathname, ...) 
[16:12:51.886]                   {
[16:12:51.886]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:51.886]                     if (file_test("-f", pathname_tmp)) {
[16:12:51.886]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.886]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:51.886]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.886]                         fi_tmp[["mtime"]])
[16:12:51.886]                     }
[16:12:51.886]                     tryCatch({
[16:12:51.886]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:51.886]                     }, error = function(ex) {
[16:12:51.886]                       msg <- conditionMessage(ex)
[16:12:51.886]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.886]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:51.886]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.886]                         fi_tmp[["mtime"]], msg)
[16:12:51.886]                       ex$message <- msg
[16:12:51.886]                       stop(ex)
[16:12:51.886]                     })
[16:12:51.886]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:51.886]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:51.886]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:51.886]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.886]                       fi <- file.info(pathname)
[16:12:51.886]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:51.886]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.886]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:51.886]                         fi[["size"]], fi[["mtime"]])
[16:12:51.886]                       stop(msg)
[16:12:51.886]                     }
[16:12:51.886]                     invisible(pathname)
[16:12:51.886]                   }
[16:12:51.886]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:51.886]                     rootPath = tempdir()) 
[16:12:51.886]                   {
[16:12:51.886]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:51.886]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:51.886]                       tmpdir = path, fileext = ".rds")
[16:12:51.886]                     save_rds(obj, file)
[16:12:51.886]                   }
[16:12:51.886]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:51.886]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.886]                   {
[16:12:51.886]                     inherits <- base::inherits
[16:12:51.886]                     invokeRestart <- base::invokeRestart
[16:12:51.886]                     is.null <- base::is.null
[16:12:51.886]                     muffled <- FALSE
[16:12:51.886]                     if (inherits(cond, "message")) {
[16:12:51.886]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:51.886]                       if (muffled) 
[16:12:51.886]                         invokeRestart("muffleMessage")
[16:12:51.886]                     }
[16:12:51.886]                     else if (inherits(cond, "warning")) {
[16:12:51.886]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:51.886]                       if (muffled) 
[16:12:51.886]                         invokeRestart("muffleWarning")
[16:12:51.886]                     }
[16:12:51.886]                     else if (inherits(cond, "condition")) {
[16:12:51.886]                       if (!is.null(pattern)) {
[16:12:51.886]                         computeRestarts <- base::computeRestarts
[16:12:51.886]                         grepl <- base::grepl
[16:12:51.886]                         restarts <- computeRestarts(cond)
[16:12:51.886]                         for (restart in restarts) {
[16:12:51.886]                           name <- restart$name
[16:12:51.886]                           if (is.null(name)) 
[16:12:51.886]                             next
[16:12:51.886]                           if (!grepl(pattern, name)) 
[16:12:51.886]                             next
[16:12:51.886]                           invokeRestart(restart)
[16:12:51.886]                           muffled <- TRUE
[16:12:51.886]                           break
[16:12:51.886]                         }
[16:12:51.886]                       }
[16:12:51.886]                     }
[16:12:51.886]                     invisible(muffled)
[16:12:51.886]                   }
[16:12:51.886]                   muffleCondition(cond)
[16:12:51.886]                 })
[16:12:51.886]             }))
[16:12:51.886]             future::FutureResult(value = ...future.value$value, 
[16:12:51.886]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.886]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.886]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.886]                     ...future.globalenv.names))
[16:12:51.886]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.886]         }, condition = base::local({
[16:12:51.886]             c <- base::c
[16:12:51.886]             inherits <- base::inherits
[16:12:51.886]             invokeRestart <- base::invokeRestart
[16:12:51.886]             length <- base::length
[16:12:51.886]             list <- base::list
[16:12:51.886]             seq.int <- base::seq.int
[16:12:51.886]             signalCondition <- base::signalCondition
[16:12:51.886]             sys.calls <- base::sys.calls
[16:12:51.886]             `[[` <- base::`[[`
[16:12:51.886]             `+` <- base::`+`
[16:12:51.886]             `<<-` <- base::`<<-`
[16:12:51.886]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.886]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.886]                   3L)]
[16:12:51.886]             }
[16:12:51.886]             function(cond) {
[16:12:51.886]                 is_error <- inherits(cond, "error")
[16:12:51.886]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.886]                   NULL)
[16:12:51.886]                 if (is_error) {
[16:12:51.886]                   sessionInformation <- function() {
[16:12:51.886]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.886]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.886]                       search = base::search(), system = base::Sys.info())
[16:12:51.886]                   }
[16:12:51.886]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.886]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.886]                     cond$call), session = sessionInformation(), 
[16:12:51.886]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.886]                   signalCondition(cond)
[16:12:51.886]                 }
[16:12:51.886]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.886]                 "immediateCondition"))) {
[16:12:51.886]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.886]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.886]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.886]                   if (TRUE && !signal) {
[16:12:51.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.886]                     {
[16:12:51.886]                       inherits <- base::inherits
[16:12:51.886]                       invokeRestart <- base::invokeRestart
[16:12:51.886]                       is.null <- base::is.null
[16:12:51.886]                       muffled <- FALSE
[16:12:51.886]                       if (inherits(cond, "message")) {
[16:12:51.886]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.886]                         if (muffled) 
[16:12:51.886]                           invokeRestart("muffleMessage")
[16:12:51.886]                       }
[16:12:51.886]                       else if (inherits(cond, "warning")) {
[16:12:51.886]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.886]                         if (muffled) 
[16:12:51.886]                           invokeRestart("muffleWarning")
[16:12:51.886]                       }
[16:12:51.886]                       else if (inherits(cond, "condition")) {
[16:12:51.886]                         if (!is.null(pattern)) {
[16:12:51.886]                           computeRestarts <- base::computeRestarts
[16:12:51.886]                           grepl <- base::grepl
[16:12:51.886]                           restarts <- computeRestarts(cond)
[16:12:51.886]                           for (restart in restarts) {
[16:12:51.886]                             name <- restart$name
[16:12:51.886]                             if (is.null(name)) 
[16:12:51.886]                               next
[16:12:51.886]                             if (!grepl(pattern, name)) 
[16:12:51.886]                               next
[16:12:51.886]                             invokeRestart(restart)
[16:12:51.886]                             muffled <- TRUE
[16:12:51.886]                             break
[16:12:51.886]                           }
[16:12:51.886]                         }
[16:12:51.886]                       }
[16:12:51.886]                       invisible(muffled)
[16:12:51.886]                     }
[16:12:51.886]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.886]                   }
[16:12:51.886]                 }
[16:12:51.886]                 else {
[16:12:51.886]                   if (TRUE) {
[16:12:51.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.886]                     {
[16:12:51.886]                       inherits <- base::inherits
[16:12:51.886]                       invokeRestart <- base::invokeRestart
[16:12:51.886]                       is.null <- base::is.null
[16:12:51.886]                       muffled <- FALSE
[16:12:51.886]                       if (inherits(cond, "message")) {
[16:12:51.886]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.886]                         if (muffled) 
[16:12:51.886]                           invokeRestart("muffleMessage")
[16:12:51.886]                       }
[16:12:51.886]                       else if (inherits(cond, "warning")) {
[16:12:51.886]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.886]                         if (muffled) 
[16:12:51.886]                           invokeRestart("muffleWarning")
[16:12:51.886]                       }
[16:12:51.886]                       else if (inherits(cond, "condition")) {
[16:12:51.886]                         if (!is.null(pattern)) {
[16:12:51.886]                           computeRestarts <- base::computeRestarts
[16:12:51.886]                           grepl <- base::grepl
[16:12:51.886]                           restarts <- computeRestarts(cond)
[16:12:51.886]                           for (restart in restarts) {
[16:12:51.886]                             name <- restart$name
[16:12:51.886]                             if (is.null(name)) 
[16:12:51.886]                               next
[16:12:51.886]                             if (!grepl(pattern, name)) 
[16:12:51.886]                               next
[16:12:51.886]                             invokeRestart(restart)
[16:12:51.886]                             muffled <- TRUE
[16:12:51.886]                             break
[16:12:51.886]                           }
[16:12:51.886]                         }
[16:12:51.886]                       }
[16:12:51.886]                       invisible(muffled)
[16:12:51.886]                     }
[16:12:51.886]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.886]                   }
[16:12:51.886]                 }
[16:12:51.886]             }
[16:12:51.886]         }))
[16:12:51.886]     }, error = function(ex) {
[16:12:51.886]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.886]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.886]                 ...future.rng), started = ...future.startTime, 
[16:12:51.886]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.886]             version = "1.8"), class = "FutureResult")
[16:12:51.886]     }, finally = {
[16:12:51.886]         if (!identical(...future.workdir, getwd())) 
[16:12:51.886]             setwd(...future.workdir)
[16:12:51.886]         {
[16:12:51.886]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.886]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.886]             }
[16:12:51.886]             base::options(...future.oldOptions)
[16:12:51.886]             if (.Platform$OS.type == "windows") {
[16:12:51.886]                 old_names <- names(...future.oldEnvVars)
[16:12:51.886]                 envs <- base::Sys.getenv()
[16:12:51.886]                 names <- names(envs)
[16:12:51.886]                 common <- intersect(names, old_names)
[16:12:51.886]                 added <- setdiff(names, old_names)
[16:12:51.886]                 removed <- setdiff(old_names, names)
[16:12:51.886]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.886]                   envs[common]]
[16:12:51.886]                 NAMES <- toupper(changed)
[16:12:51.886]                 args <- list()
[16:12:51.886]                 for (kk in seq_along(NAMES)) {
[16:12:51.886]                   name <- changed[[kk]]
[16:12:51.886]                   NAME <- NAMES[[kk]]
[16:12:51.886]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.886]                     next
[16:12:51.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.886]                 }
[16:12:51.886]                 NAMES <- toupper(added)
[16:12:51.886]                 for (kk in seq_along(NAMES)) {
[16:12:51.886]                   name <- added[[kk]]
[16:12:51.886]                   NAME <- NAMES[[kk]]
[16:12:51.886]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.886]                     next
[16:12:51.886]                   args[[name]] <- ""
[16:12:51.886]                 }
[16:12:51.886]                 NAMES <- toupper(removed)
[16:12:51.886]                 for (kk in seq_along(NAMES)) {
[16:12:51.886]                   name <- removed[[kk]]
[16:12:51.886]                   NAME <- NAMES[[kk]]
[16:12:51.886]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.886]                     next
[16:12:51.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.886]                 }
[16:12:51.886]                 if (length(args) > 0) 
[16:12:51.886]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.886]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.886]             }
[16:12:51.886]             else {
[16:12:51.886]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.886]             }
[16:12:51.886]             {
[16:12:51.886]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.886]                   0L) {
[16:12:51.886]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.886]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.886]                   base::options(opts)
[16:12:51.886]                 }
[16:12:51.886]                 {
[16:12:51.886]                   {
[16:12:51.886]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:51.886]                     NULL
[16:12:51.886]                   }
[16:12:51.886]                   options(future.plan = NULL)
[16:12:51.886]                   if (is.na(NA_character_)) 
[16:12:51.886]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.886]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.886]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:51.886]                     envir = parent.frame()) 
[16:12:51.886]                   {
[16:12:51.886]                     default_workers <- missing(workers)
[16:12:51.886]                     if (is.function(workers)) 
[16:12:51.886]                       workers <- workers()
[16:12:51.886]                     workers <- structure(as.integer(workers), 
[16:12:51.886]                       class = class(workers))
[16:12:51.886]                     stop_if_not(is.finite(workers), workers >= 
[16:12:51.886]                       1L)
[16:12:51.886]                     if ((workers == 1L && !inherits(workers, 
[16:12:51.886]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:51.886]                       if (default_workers) 
[16:12:51.886]                         supportsMulticore(warn = TRUE)
[16:12:51.886]                       return(sequential(..., envir = envir))
[16:12:51.886]                     }
[16:12:51.886]                     oopts <- options(mc.cores = workers)
[16:12:51.886]                     on.exit(options(oopts))
[16:12:51.886]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:51.886]                       envir = envir)
[16:12:51.886]                     if (!future$lazy) 
[16:12:51.886]                       future <- run(future)
[16:12:51.886]                     invisible(future)
[16:12:51.886]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.886]                 }
[16:12:51.886]             }
[16:12:51.886]         }
[16:12:51.886]     })
[16:12:51.886]     if (TRUE) {
[16:12:51.886]         base::sink(type = "output", split = FALSE)
[16:12:51.886]         if (TRUE) {
[16:12:51.886]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.886]         }
[16:12:51.886]         else {
[16:12:51.886]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.886]         }
[16:12:51.886]         base::close(...future.stdout)
[16:12:51.886]         ...future.stdout <- NULL
[16:12:51.886]     }
[16:12:51.886]     ...future.result$conditions <- ...future.conditions
[16:12:51.886]     ...future.result$finished <- base::Sys.time()
[16:12:51.886]     ...future.result
[16:12:51.886] }
[16:12:51.888] requestCore(): workers = 2
[16:12:51.890] MulticoreFuture started
[16:12:51.891] - Launch lazy future ... done
[16:12:51.891] plan(): Setting new future strategy stack:
[16:12:51.891] run() for ‘MulticoreFuture’ ... done
[16:12:51.892] List of future strategies:
[16:12:51.892] 1. sequential:
[16:12:51.892]    - args: function (..., envir = parent.frame())
[16:12:51.892]    - tweaked: FALSE
[16:12:51.892]    - call: NULL
[16:12:51.893] plan(): nbrOfWorkers() = 1
[16:12:51.895] plan(): Setting new future strategy stack:
[16:12:51.896] List of future strategies:
[16:12:51.896] 1. multicore:
[16:12:51.896]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:51.896]    - tweaked: FALSE
[16:12:51.896]    - call: plan(strategy)
[16:12:51.901] plan(): nbrOfWorkers() = 2
[16:12:51.902] Future #1
[16:12:51.903] A MulticoreFuture was resolved
[16:12:51.903]  length: 0 (resolved future 1)
[16:12:51.904] resolve() on list ... DONE
[16:12:51.904] - globals: [1] ‘a’
[16:12:51.904] Resolving futures part of globals (recursively) ... DONE
[16:12:51.905] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[16:12:51.906] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[16:12:51.906] - globals: [1] ‘a’
[16:12:51.906] - packages: [1] ‘future’
[16:12:51.907] getGlobalsAndPackages() ... DONE
[16:12:51.907] run() for ‘Future’ ...
[16:12:51.907] - state: ‘created’
[16:12:51.907] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:51.912] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:51.912] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:51.912]   - Field: ‘label’
[16:12:51.912]   - Field: ‘local’
[16:12:51.912]   - Field: ‘owner’
[16:12:51.912]   - Field: ‘envir’
[16:12:51.912]   - Field: ‘workers’
[16:12:51.912]   - Field: ‘packages’
[16:12:51.913]   - Field: ‘gc’
[16:12:51.913]   - Field: ‘job’
[16:12:51.913]   - Field: ‘conditions’
[16:12:51.913]   - Field: ‘expr’
[16:12:51.913]   - Field: ‘uuid’
[16:12:51.913]   - Field: ‘seed’
[16:12:51.913]   - Field: ‘version’
[16:12:51.913]   - Field: ‘result’
[16:12:51.914]   - Field: ‘asynchronous’
[16:12:51.914]   - Field: ‘calls’
[16:12:51.914]   - Field: ‘globals’
[16:12:51.914]   - Field: ‘stdout’
[16:12:51.914]   - Field: ‘earlySignal’
[16:12:51.914]   - Field: ‘lazy’
[16:12:51.914]   - Field: ‘state’
[16:12:51.914] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:51.914] - Launch lazy future ...
[16:12:51.915] Packages needed by the future expression (n = 1): ‘future’
[16:12:51.915] Packages needed by future strategies (n = 0): <none>
[16:12:51.916] {
[16:12:51.916]     {
[16:12:51.916]         {
[16:12:51.916]             ...future.startTime <- base::Sys.time()
[16:12:51.916]             {
[16:12:51.916]                 {
[16:12:51.916]                   {
[16:12:51.916]                     {
[16:12:51.916]                       {
[16:12:51.916]                         base::local({
[16:12:51.916]                           has_future <- base::requireNamespace("future", 
[16:12:51.916]                             quietly = TRUE)
[16:12:51.916]                           if (has_future) {
[16:12:51.916]                             ns <- base::getNamespace("future")
[16:12:51.916]                             version <- ns[[".package"]][["version"]]
[16:12:51.916]                             if (is.null(version)) 
[16:12:51.916]                               version <- utils::packageVersion("future")
[16:12:51.916]                           }
[16:12:51.916]                           else {
[16:12:51.916]                             version <- NULL
[16:12:51.916]                           }
[16:12:51.916]                           if (!has_future || version < "1.8.0") {
[16:12:51.916]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.916]                               "", base::R.version$version.string), 
[16:12:51.916]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:51.916]                                 base::R.version$platform, 8 * 
[16:12:51.916]                                   base::.Machine$sizeof.pointer), 
[16:12:51.916]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.916]                                 "release", "version")], collapse = " "), 
[16:12:51.916]                               hostname = base::Sys.info()[["nodename"]])
[16:12:51.916]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.916]                               info)
[16:12:51.916]                             info <- base::paste(info, collapse = "; ")
[16:12:51.916]                             if (!has_future) {
[16:12:51.916]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.916]                                 info)
[16:12:51.916]                             }
[16:12:51.916]                             else {
[16:12:51.916]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.916]                                 info, version)
[16:12:51.916]                             }
[16:12:51.916]                             base::stop(msg)
[16:12:51.916]                           }
[16:12:51.916]                         })
[16:12:51.916]                       }
[16:12:51.916]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:51.916]                       base::options(mc.cores = 1L)
[16:12:51.916]                     }
[16:12:51.916]                     base::local({
[16:12:51.916]                       for (pkg in "future") {
[16:12:51.916]                         base::loadNamespace(pkg)
[16:12:51.916]                         base::library(pkg, character.only = TRUE)
[16:12:51.916]                       }
[16:12:51.916]                     })
[16:12:51.916]                   }
[16:12:51.916]                   options(future.plan = NULL)
[16:12:51.916]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.916]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.916]                 }
[16:12:51.916]                 ...future.workdir <- getwd()
[16:12:51.916]             }
[16:12:51.916]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.916]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.916]         }
[16:12:51.916]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.916]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:51.916]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.916]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.916]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.916]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.916]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.916]             base::names(...future.oldOptions))
[16:12:51.916]     }
[16:12:51.916]     if (FALSE) {
[16:12:51.916]     }
[16:12:51.916]     else {
[16:12:51.916]         if (TRUE) {
[16:12:51.916]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.916]                 open = "w")
[16:12:51.916]         }
[16:12:51.916]         else {
[16:12:51.916]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.916]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.916]         }
[16:12:51.916]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.916]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.916]             base::sink(type = "output", split = FALSE)
[16:12:51.916]             base::close(...future.stdout)
[16:12:51.916]         }, add = TRUE)
[16:12:51.916]     }
[16:12:51.916]     ...future.frame <- base::sys.nframe()
[16:12:51.916]     ...future.conditions <- base::list()
[16:12:51.916]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.916]     if (FALSE) {
[16:12:51.916]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.916]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.916]     }
[16:12:51.916]     ...future.result <- base::tryCatch({
[16:12:51.916]         base::withCallingHandlers({
[16:12:51.916]             ...future.value <- base::withVisible(base::local({
[16:12:51.916]                 withCallingHandlers({
[16:12:51.916]                   value(a) + 1
[16:12:51.916]                 }, immediateCondition = function(cond) {
[16:12:51.916]                   save_rds <- function (object, pathname, ...) 
[16:12:51.916]                   {
[16:12:51.916]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:51.916]                     if (file_test("-f", pathname_tmp)) {
[16:12:51.916]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.916]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:51.916]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.916]                         fi_tmp[["mtime"]])
[16:12:51.916]                     }
[16:12:51.916]                     tryCatch({
[16:12:51.916]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:51.916]                     }, error = function(ex) {
[16:12:51.916]                       msg <- conditionMessage(ex)
[16:12:51.916]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.916]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:51.916]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.916]                         fi_tmp[["mtime"]], msg)
[16:12:51.916]                       ex$message <- msg
[16:12:51.916]                       stop(ex)
[16:12:51.916]                     })
[16:12:51.916]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:51.916]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:51.916]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:51.916]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.916]                       fi <- file.info(pathname)
[16:12:51.916]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:51.916]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.916]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:51.916]                         fi[["size"]], fi[["mtime"]])
[16:12:51.916]                       stop(msg)
[16:12:51.916]                     }
[16:12:51.916]                     invisible(pathname)
[16:12:51.916]                   }
[16:12:51.916]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:51.916]                     rootPath = tempdir()) 
[16:12:51.916]                   {
[16:12:51.916]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:51.916]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:51.916]                       tmpdir = path, fileext = ".rds")
[16:12:51.916]                     save_rds(obj, file)
[16:12:51.916]                   }
[16:12:51.916]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:51.916]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.916]                   {
[16:12:51.916]                     inherits <- base::inherits
[16:12:51.916]                     invokeRestart <- base::invokeRestart
[16:12:51.916]                     is.null <- base::is.null
[16:12:51.916]                     muffled <- FALSE
[16:12:51.916]                     if (inherits(cond, "message")) {
[16:12:51.916]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:51.916]                       if (muffled) 
[16:12:51.916]                         invokeRestart("muffleMessage")
[16:12:51.916]                     }
[16:12:51.916]                     else if (inherits(cond, "warning")) {
[16:12:51.916]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:51.916]                       if (muffled) 
[16:12:51.916]                         invokeRestart("muffleWarning")
[16:12:51.916]                     }
[16:12:51.916]                     else if (inherits(cond, "condition")) {
[16:12:51.916]                       if (!is.null(pattern)) {
[16:12:51.916]                         computeRestarts <- base::computeRestarts
[16:12:51.916]                         grepl <- base::grepl
[16:12:51.916]                         restarts <- computeRestarts(cond)
[16:12:51.916]                         for (restart in restarts) {
[16:12:51.916]                           name <- restart$name
[16:12:51.916]                           if (is.null(name)) 
[16:12:51.916]                             next
[16:12:51.916]                           if (!grepl(pattern, name)) 
[16:12:51.916]                             next
[16:12:51.916]                           invokeRestart(restart)
[16:12:51.916]                           muffled <- TRUE
[16:12:51.916]                           break
[16:12:51.916]                         }
[16:12:51.916]                       }
[16:12:51.916]                     }
[16:12:51.916]                     invisible(muffled)
[16:12:51.916]                   }
[16:12:51.916]                   muffleCondition(cond)
[16:12:51.916]                 })
[16:12:51.916]             }))
[16:12:51.916]             future::FutureResult(value = ...future.value$value, 
[16:12:51.916]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.916]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.916]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.916]                     ...future.globalenv.names))
[16:12:51.916]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.916]         }, condition = base::local({
[16:12:51.916]             c <- base::c
[16:12:51.916]             inherits <- base::inherits
[16:12:51.916]             invokeRestart <- base::invokeRestart
[16:12:51.916]             length <- base::length
[16:12:51.916]             list <- base::list
[16:12:51.916]             seq.int <- base::seq.int
[16:12:51.916]             signalCondition <- base::signalCondition
[16:12:51.916]             sys.calls <- base::sys.calls
[16:12:51.916]             `[[` <- base::`[[`
[16:12:51.916]             `+` <- base::`+`
[16:12:51.916]             `<<-` <- base::`<<-`
[16:12:51.916]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.916]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.916]                   3L)]
[16:12:51.916]             }
[16:12:51.916]             function(cond) {
[16:12:51.916]                 is_error <- inherits(cond, "error")
[16:12:51.916]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.916]                   NULL)
[16:12:51.916]                 if (is_error) {
[16:12:51.916]                   sessionInformation <- function() {
[16:12:51.916]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.916]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.916]                       search = base::search(), system = base::Sys.info())
[16:12:51.916]                   }
[16:12:51.916]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.916]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.916]                     cond$call), session = sessionInformation(), 
[16:12:51.916]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.916]                   signalCondition(cond)
[16:12:51.916]                 }
[16:12:51.916]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.916]                 "immediateCondition"))) {
[16:12:51.916]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.916]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.916]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.916]                   if (TRUE && !signal) {
[16:12:51.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.916]                     {
[16:12:51.916]                       inherits <- base::inherits
[16:12:51.916]                       invokeRestart <- base::invokeRestart
[16:12:51.916]                       is.null <- base::is.null
[16:12:51.916]                       muffled <- FALSE
[16:12:51.916]                       if (inherits(cond, "message")) {
[16:12:51.916]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.916]                         if (muffled) 
[16:12:51.916]                           invokeRestart("muffleMessage")
[16:12:51.916]                       }
[16:12:51.916]                       else if (inherits(cond, "warning")) {
[16:12:51.916]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.916]                         if (muffled) 
[16:12:51.916]                           invokeRestart("muffleWarning")
[16:12:51.916]                       }
[16:12:51.916]                       else if (inherits(cond, "condition")) {
[16:12:51.916]                         if (!is.null(pattern)) {
[16:12:51.916]                           computeRestarts <- base::computeRestarts
[16:12:51.916]                           grepl <- base::grepl
[16:12:51.916]                           restarts <- computeRestarts(cond)
[16:12:51.916]                           for (restart in restarts) {
[16:12:51.916]                             name <- restart$name
[16:12:51.916]                             if (is.null(name)) 
[16:12:51.916]                               next
[16:12:51.916]                             if (!grepl(pattern, name)) 
[16:12:51.916]                               next
[16:12:51.916]                             invokeRestart(restart)
[16:12:51.916]                             muffled <- TRUE
[16:12:51.916]                             break
[16:12:51.916]                           }
[16:12:51.916]                         }
[16:12:51.916]                       }
[16:12:51.916]                       invisible(muffled)
[16:12:51.916]                     }
[16:12:51.916]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.916]                   }
[16:12:51.916]                 }
[16:12:51.916]                 else {
[16:12:51.916]                   if (TRUE) {
[16:12:51.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.916]                     {
[16:12:51.916]                       inherits <- base::inherits
[16:12:51.916]                       invokeRestart <- base::invokeRestart
[16:12:51.916]                       is.null <- base::is.null
[16:12:51.916]                       muffled <- FALSE
[16:12:51.916]                       if (inherits(cond, "message")) {
[16:12:51.916]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.916]                         if (muffled) 
[16:12:51.916]                           invokeRestart("muffleMessage")
[16:12:51.916]                       }
[16:12:51.916]                       else if (inherits(cond, "warning")) {
[16:12:51.916]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.916]                         if (muffled) 
[16:12:51.916]                           invokeRestart("muffleWarning")
[16:12:51.916]                       }
[16:12:51.916]                       else if (inherits(cond, "condition")) {
[16:12:51.916]                         if (!is.null(pattern)) {
[16:12:51.916]                           computeRestarts <- base::computeRestarts
[16:12:51.916]                           grepl <- base::grepl
[16:12:51.916]                           restarts <- computeRestarts(cond)
[16:12:51.916]                           for (restart in restarts) {
[16:12:51.916]                             name <- restart$name
[16:12:51.916]                             if (is.null(name)) 
[16:12:51.916]                               next
[16:12:51.916]                             if (!grepl(pattern, name)) 
[16:12:51.916]                               next
[16:12:51.916]                             invokeRestart(restart)
[16:12:51.916]                             muffled <- TRUE
[16:12:51.916]                             break
[16:12:51.916]                           }
[16:12:51.916]                         }
[16:12:51.916]                       }
[16:12:51.916]                       invisible(muffled)
[16:12:51.916]                     }
[16:12:51.916]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.916]                   }
[16:12:51.916]                 }
[16:12:51.916]             }
[16:12:51.916]         }))
[16:12:51.916]     }, error = function(ex) {
[16:12:51.916]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.916]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.916]                 ...future.rng), started = ...future.startTime, 
[16:12:51.916]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.916]             version = "1.8"), class = "FutureResult")
[16:12:51.916]     }, finally = {
[16:12:51.916]         if (!identical(...future.workdir, getwd())) 
[16:12:51.916]             setwd(...future.workdir)
[16:12:51.916]         {
[16:12:51.916]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.916]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.916]             }
[16:12:51.916]             base::options(...future.oldOptions)
[16:12:51.916]             if (.Platform$OS.type == "windows") {
[16:12:51.916]                 old_names <- names(...future.oldEnvVars)
[16:12:51.916]                 envs <- base::Sys.getenv()
[16:12:51.916]                 names <- names(envs)
[16:12:51.916]                 common <- intersect(names, old_names)
[16:12:51.916]                 added <- setdiff(names, old_names)
[16:12:51.916]                 removed <- setdiff(old_names, names)
[16:12:51.916]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.916]                   envs[common]]
[16:12:51.916]                 NAMES <- toupper(changed)
[16:12:51.916]                 args <- list()
[16:12:51.916]                 for (kk in seq_along(NAMES)) {
[16:12:51.916]                   name <- changed[[kk]]
[16:12:51.916]                   NAME <- NAMES[[kk]]
[16:12:51.916]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.916]                     next
[16:12:51.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.916]                 }
[16:12:51.916]                 NAMES <- toupper(added)
[16:12:51.916]                 for (kk in seq_along(NAMES)) {
[16:12:51.916]                   name <- added[[kk]]
[16:12:51.916]                   NAME <- NAMES[[kk]]
[16:12:51.916]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.916]                     next
[16:12:51.916]                   args[[name]] <- ""
[16:12:51.916]                 }
[16:12:51.916]                 NAMES <- toupper(removed)
[16:12:51.916]                 for (kk in seq_along(NAMES)) {
[16:12:51.916]                   name <- removed[[kk]]
[16:12:51.916]                   NAME <- NAMES[[kk]]
[16:12:51.916]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.916]                     next
[16:12:51.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.916]                 }
[16:12:51.916]                 if (length(args) > 0) 
[16:12:51.916]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.916]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.916]             }
[16:12:51.916]             else {
[16:12:51.916]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.916]             }
[16:12:51.916]             {
[16:12:51.916]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.916]                   0L) {
[16:12:51.916]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.916]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.916]                   base::options(opts)
[16:12:51.916]                 }
[16:12:51.916]                 {
[16:12:51.916]                   {
[16:12:51.916]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:51.916]                     NULL
[16:12:51.916]                   }
[16:12:51.916]                   options(future.plan = NULL)
[16:12:51.916]                   if (is.na(NA_character_)) 
[16:12:51.916]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.916]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.916]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:51.916]                     envir = parent.frame()) 
[16:12:51.916]                   {
[16:12:51.916]                     default_workers <- missing(workers)
[16:12:51.916]                     if (is.function(workers)) 
[16:12:51.916]                       workers <- workers()
[16:12:51.916]                     workers <- structure(as.integer(workers), 
[16:12:51.916]                       class = class(workers))
[16:12:51.916]                     stop_if_not(is.finite(workers), workers >= 
[16:12:51.916]                       1L)
[16:12:51.916]                     if ((workers == 1L && !inherits(workers, 
[16:12:51.916]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:51.916]                       if (default_workers) 
[16:12:51.916]                         supportsMulticore(warn = TRUE)
[16:12:51.916]                       return(sequential(..., envir = envir))
[16:12:51.916]                     }
[16:12:51.916]                     oopts <- options(mc.cores = workers)
[16:12:51.916]                     on.exit(options(oopts))
[16:12:51.916]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:51.916]                       envir = envir)
[16:12:51.916]                     if (!future$lazy) 
[16:12:51.916]                       future <- run(future)
[16:12:51.916]                     invisible(future)
[16:12:51.916]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.916]                 }
[16:12:51.916]             }
[16:12:51.916]         }
[16:12:51.916]     })
[16:12:51.916]     if (TRUE) {
[16:12:51.916]         base::sink(type = "output", split = FALSE)
[16:12:51.916]         if (TRUE) {
[16:12:51.916]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.916]         }
[16:12:51.916]         else {
[16:12:51.916]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.916]         }
[16:12:51.916]         base::close(...future.stdout)
[16:12:51.916]         ...future.stdout <- NULL
[16:12:51.916]     }
[16:12:51.916]     ...future.result$conditions <- ...future.conditions
[16:12:51.916]     ...future.result$finished <- base::Sys.time()
[16:12:51.916]     ...future.result
[16:12:51.916] }
[16:12:51.919] assign_globals() ...
[16:12:51.919] List of 1
[16:12:51.919]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x56233d494648> 
[16:12:51.919]  - attr(*, "where")=List of 1
[16:12:51.919]   ..$ a:<environment: R_EmptyEnv> 
[16:12:51.919]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.919]  - attr(*, "resolved")= logi TRUE
[16:12:51.919]  - attr(*, "total_size")= num 10984
[16:12:51.919]  - attr(*, "already-done")= logi TRUE
[16:12:51.922] - copied ‘a’ to environment
[16:12:51.922] assign_globals() ... done
[16:12:51.922] requestCore(): workers = 2
[16:12:51.924] MulticoreFuture started
[16:12:51.924] - Launch lazy future ... done
[16:12:51.924] run() for ‘MulticoreFuture’ ... done
[16:12:51.925] plan(): Setting new future strategy stack:
[16:12:51.925] List of future strategies:
[16:12:51.925] 1. sequential:
[16:12:51.925]    - args: function (..., envir = parent.frame())
[16:12:51.925]    - tweaked: FALSE
[16:12:51.925]    - call: NULL
[16:12:51.926] plan(): nbrOfWorkers() = 1
[16:12:51.929] plan(): Setting new future strategy stack:
[16:12:51.929] List of future strategies:
[16:12:51.929] 1. multicore:
[16:12:51.929]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:51.929]    - tweaked: FALSE
[16:12:51.929]    - call: plan(strategy)
[16:12:51.934] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.935] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.936] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.937] 
[16:12:51.937] Searching for globals ... DONE
[16:12:51.937] - globals: [0] <none>
[16:12:51.937] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:51.937] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:51.938] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:51.939] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:51.939] Searching for globals ... DONE
[16:12:51.939] Resolving globals: TRUE
[16:12:51.939] Resolving any globals that are futures ...
[16:12:51.939] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:51.939] Resolving any globals that are futures ... DONE
[16:12:51.943] Resolving futures part of globals (recursively) ...
[16:12:51.943] resolve() on list ...
[16:12:51.944]  recursive: 99
[16:12:51.944]  length: 1
[16:12:51.944]  elements: ‘a’
[16:12:51.944] run() for ‘Future’ ...
[16:12:51.944] - state: ‘created’
[16:12:51.945] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:51.949] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:51.949] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:51.949]   - Field: ‘label’
[16:12:51.949]   - Field: ‘local’
[16:12:51.950]   - Field: ‘owner’
[16:12:51.950]   - Field: ‘envir’
[16:12:51.950]   - Field: ‘workers’
[16:12:51.950]   - Field: ‘packages’
[16:12:51.950]   - Field: ‘gc’
[16:12:51.950]   - Field: ‘job’
[16:12:51.950]   - Field: ‘conditions’
[16:12:51.950]   - Field: ‘expr’
[16:12:51.951]   - Field: ‘uuid’
[16:12:51.951]   - Field: ‘seed’
[16:12:51.951]   - Field: ‘version’
[16:12:51.951]   - Field: ‘result’
[16:12:51.951]   - Field: ‘asynchronous’
[16:12:51.951]   - Field: ‘calls’
[16:12:51.951]   - Field: ‘globals’
[16:12:51.951]   - Field: ‘stdout’
[16:12:51.952]   - Field: ‘earlySignal’
[16:12:51.952]   - Field: ‘lazy’
[16:12:51.952]   - Field: ‘state’
[16:12:51.952] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:51.952] - Launch lazy future ...
[16:12:51.952] Packages needed by the future expression (n = 0): <none>
[16:12:51.953] Packages needed by future strategies (n = 0): <none>
[16:12:51.953] {
[16:12:51.953]     {
[16:12:51.953]         {
[16:12:51.953]             ...future.startTime <- base::Sys.time()
[16:12:51.953]             {
[16:12:51.953]                 {
[16:12:51.953]                   {
[16:12:51.953]                     {
[16:12:51.953]                       base::local({
[16:12:51.953]                         has_future <- base::requireNamespace("future", 
[16:12:51.953]                           quietly = TRUE)
[16:12:51.953]                         if (has_future) {
[16:12:51.953]                           ns <- base::getNamespace("future")
[16:12:51.953]                           version <- ns[[".package"]][["version"]]
[16:12:51.953]                           if (is.null(version)) 
[16:12:51.953]                             version <- utils::packageVersion("future")
[16:12:51.953]                         }
[16:12:51.953]                         else {
[16:12:51.953]                           version <- NULL
[16:12:51.953]                         }
[16:12:51.953]                         if (!has_future || version < "1.8.0") {
[16:12:51.953]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.953]                             "", base::R.version$version.string), 
[16:12:51.953]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:51.953]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:51.953]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.953]                               "release", "version")], collapse = " "), 
[16:12:51.953]                             hostname = base::Sys.info()[["nodename"]])
[16:12:51.953]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.953]                             info)
[16:12:51.953]                           info <- base::paste(info, collapse = "; ")
[16:12:51.953]                           if (!has_future) {
[16:12:51.953]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.953]                               info)
[16:12:51.953]                           }
[16:12:51.953]                           else {
[16:12:51.953]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.953]                               info, version)
[16:12:51.953]                           }
[16:12:51.953]                           base::stop(msg)
[16:12:51.953]                         }
[16:12:51.953]                       })
[16:12:51.953]                     }
[16:12:51.953]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:51.953]                     base::options(mc.cores = 1L)
[16:12:51.953]                   }
[16:12:51.953]                   options(future.plan = NULL)
[16:12:51.953]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.953]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.953]                 }
[16:12:51.953]                 ...future.workdir <- getwd()
[16:12:51.953]             }
[16:12:51.953]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.953]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.953]         }
[16:12:51.953]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.953]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:51.953]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.953]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.953]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.953]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.953]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.953]             base::names(...future.oldOptions))
[16:12:51.953]     }
[16:12:51.953]     if (FALSE) {
[16:12:51.953]     }
[16:12:51.953]     else {
[16:12:51.953]         if (TRUE) {
[16:12:51.953]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.953]                 open = "w")
[16:12:51.953]         }
[16:12:51.953]         else {
[16:12:51.953]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.953]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.953]         }
[16:12:51.953]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.953]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.953]             base::sink(type = "output", split = FALSE)
[16:12:51.953]             base::close(...future.stdout)
[16:12:51.953]         }, add = TRUE)
[16:12:51.953]     }
[16:12:51.953]     ...future.frame <- base::sys.nframe()
[16:12:51.953]     ...future.conditions <- base::list()
[16:12:51.953]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.953]     if (FALSE) {
[16:12:51.953]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.953]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.953]     }
[16:12:51.953]     ...future.result <- base::tryCatch({
[16:12:51.953]         base::withCallingHandlers({
[16:12:51.953]             ...future.value <- base::withVisible(base::local({
[16:12:51.953]                 withCallingHandlers({
[16:12:51.953]                   1
[16:12:51.953]                 }, immediateCondition = function(cond) {
[16:12:51.953]                   save_rds <- function (object, pathname, ...) 
[16:12:51.953]                   {
[16:12:51.953]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:51.953]                     if (file_test("-f", pathname_tmp)) {
[16:12:51.953]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.953]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:51.953]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.953]                         fi_tmp[["mtime"]])
[16:12:51.953]                     }
[16:12:51.953]                     tryCatch({
[16:12:51.953]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:51.953]                     }, error = function(ex) {
[16:12:51.953]                       msg <- conditionMessage(ex)
[16:12:51.953]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.953]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:51.953]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.953]                         fi_tmp[["mtime"]], msg)
[16:12:51.953]                       ex$message <- msg
[16:12:51.953]                       stop(ex)
[16:12:51.953]                     })
[16:12:51.953]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:51.953]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:51.953]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:51.953]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.953]                       fi <- file.info(pathname)
[16:12:51.953]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:51.953]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.953]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:51.953]                         fi[["size"]], fi[["mtime"]])
[16:12:51.953]                       stop(msg)
[16:12:51.953]                     }
[16:12:51.953]                     invisible(pathname)
[16:12:51.953]                   }
[16:12:51.953]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:51.953]                     rootPath = tempdir()) 
[16:12:51.953]                   {
[16:12:51.953]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:51.953]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:51.953]                       tmpdir = path, fileext = ".rds")
[16:12:51.953]                     save_rds(obj, file)
[16:12:51.953]                   }
[16:12:51.953]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:51.953]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.953]                   {
[16:12:51.953]                     inherits <- base::inherits
[16:12:51.953]                     invokeRestart <- base::invokeRestart
[16:12:51.953]                     is.null <- base::is.null
[16:12:51.953]                     muffled <- FALSE
[16:12:51.953]                     if (inherits(cond, "message")) {
[16:12:51.953]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:51.953]                       if (muffled) 
[16:12:51.953]                         invokeRestart("muffleMessage")
[16:12:51.953]                     }
[16:12:51.953]                     else if (inherits(cond, "warning")) {
[16:12:51.953]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:51.953]                       if (muffled) 
[16:12:51.953]                         invokeRestart("muffleWarning")
[16:12:51.953]                     }
[16:12:51.953]                     else if (inherits(cond, "condition")) {
[16:12:51.953]                       if (!is.null(pattern)) {
[16:12:51.953]                         computeRestarts <- base::computeRestarts
[16:12:51.953]                         grepl <- base::grepl
[16:12:51.953]                         restarts <- computeRestarts(cond)
[16:12:51.953]                         for (restart in restarts) {
[16:12:51.953]                           name <- restart$name
[16:12:51.953]                           if (is.null(name)) 
[16:12:51.953]                             next
[16:12:51.953]                           if (!grepl(pattern, name)) 
[16:12:51.953]                             next
[16:12:51.953]                           invokeRestart(restart)
[16:12:51.953]                           muffled <- TRUE
[16:12:51.953]                           break
[16:12:51.953]                         }
[16:12:51.953]                       }
[16:12:51.953]                     }
[16:12:51.953]                     invisible(muffled)
[16:12:51.953]                   }
[16:12:51.953]                   muffleCondition(cond)
[16:12:51.953]                 })
[16:12:51.953]             }))
[16:12:51.953]             future::FutureResult(value = ...future.value$value, 
[16:12:51.953]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.953]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.953]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.953]                     ...future.globalenv.names))
[16:12:51.953]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.953]         }, condition = base::local({
[16:12:51.953]             c <- base::c
[16:12:51.953]             inherits <- base::inherits
[16:12:51.953]             invokeRestart <- base::invokeRestart
[16:12:51.953]             length <- base::length
[16:12:51.953]             list <- base::list
[16:12:51.953]             seq.int <- base::seq.int
[16:12:51.953]             signalCondition <- base::signalCondition
[16:12:51.953]             sys.calls <- base::sys.calls
[16:12:51.953]             `[[` <- base::`[[`
[16:12:51.953]             `+` <- base::`+`
[16:12:51.953]             `<<-` <- base::`<<-`
[16:12:51.953]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.953]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.953]                   3L)]
[16:12:51.953]             }
[16:12:51.953]             function(cond) {
[16:12:51.953]                 is_error <- inherits(cond, "error")
[16:12:51.953]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.953]                   NULL)
[16:12:51.953]                 if (is_error) {
[16:12:51.953]                   sessionInformation <- function() {
[16:12:51.953]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.953]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.953]                       search = base::search(), system = base::Sys.info())
[16:12:51.953]                   }
[16:12:51.953]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.953]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.953]                     cond$call), session = sessionInformation(), 
[16:12:51.953]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.953]                   signalCondition(cond)
[16:12:51.953]                 }
[16:12:51.953]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.953]                 "immediateCondition"))) {
[16:12:51.953]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.953]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.953]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.953]                   if (TRUE && !signal) {
[16:12:51.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.953]                     {
[16:12:51.953]                       inherits <- base::inherits
[16:12:51.953]                       invokeRestart <- base::invokeRestart
[16:12:51.953]                       is.null <- base::is.null
[16:12:51.953]                       muffled <- FALSE
[16:12:51.953]                       if (inherits(cond, "message")) {
[16:12:51.953]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.953]                         if (muffled) 
[16:12:51.953]                           invokeRestart("muffleMessage")
[16:12:51.953]                       }
[16:12:51.953]                       else if (inherits(cond, "warning")) {
[16:12:51.953]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.953]                         if (muffled) 
[16:12:51.953]                           invokeRestart("muffleWarning")
[16:12:51.953]                       }
[16:12:51.953]                       else if (inherits(cond, "condition")) {
[16:12:51.953]                         if (!is.null(pattern)) {
[16:12:51.953]                           computeRestarts <- base::computeRestarts
[16:12:51.953]                           grepl <- base::grepl
[16:12:51.953]                           restarts <- computeRestarts(cond)
[16:12:51.953]                           for (restart in restarts) {
[16:12:51.953]                             name <- restart$name
[16:12:51.953]                             if (is.null(name)) 
[16:12:51.953]                               next
[16:12:51.953]                             if (!grepl(pattern, name)) 
[16:12:51.953]                               next
[16:12:51.953]                             invokeRestart(restart)
[16:12:51.953]                             muffled <- TRUE
[16:12:51.953]                             break
[16:12:51.953]                           }
[16:12:51.953]                         }
[16:12:51.953]                       }
[16:12:51.953]                       invisible(muffled)
[16:12:51.953]                     }
[16:12:51.953]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.953]                   }
[16:12:51.953]                 }
[16:12:51.953]                 else {
[16:12:51.953]                   if (TRUE) {
[16:12:51.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.953]                     {
[16:12:51.953]                       inherits <- base::inherits
[16:12:51.953]                       invokeRestart <- base::invokeRestart
[16:12:51.953]                       is.null <- base::is.null
[16:12:51.953]                       muffled <- FALSE
[16:12:51.953]                       if (inherits(cond, "message")) {
[16:12:51.953]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.953]                         if (muffled) 
[16:12:51.953]                           invokeRestart("muffleMessage")
[16:12:51.953]                       }
[16:12:51.953]                       else if (inherits(cond, "warning")) {
[16:12:51.953]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.953]                         if (muffled) 
[16:12:51.953]                           invokeRestart("muffleWarning")
[16:12:51.953]                       }
[16:12:51.953]                       else if (inherits(cond, "condition")) {
[16:12:51.953]                         if (!is.null(pattern)) {
[16:12:51.953]                           computeRestarts <- base::computeRestarts
[16:12:51.953]                           grepl <- base::grepl
[16:12:51.953]                           restarts <- computeRestarts(cond)
[16:12:51.953]                           for (restart in restarts) {
[16:12:51.953]                             name <- restart$name
[16:12:51.953]                             if (is.null(name)) 
[16:12:51.953]                               next
[16:12:51.953]                             if (!grepl(pattern, name)) 
[16:12:51.953]                               next
[16:12:51.953]                             invokeRestart(restart)
[16:12:51.953]                             muffled <- TRUE
[16:12:51.953]                             break
[16:12:51.953]                           }
[16:12:51.953]                         }
[16:12:51.953]                       }
[16:12:51.953]                       invisible(muffled)
[16:12:51.953]                     }
[16:12:51.953]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.953]                   }
[16:12:51.953]                 }
[16:12:51.953]             }
[16:12:51.953]         }))
[16:12:51.953]     }, error = function(ex) {
[16:12:51.953]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.953]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.953]                 ...future.rng), started = ...future.startTime, 
[16:12:51.953]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.953]             version = "1.8"), class = "FutureResult")
[16:12:51.953]     }, finally = {
[16:12:51.953]         if (!identical(...future.workdir, getwd())) 
[16:12:51.953]             setwd(...future.workdir)
[16:12:51.953]         {
[16:12:51.953]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.953]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.953]             }
[16:12:51.953]             base::options(...future.oldOptions)
[16:12:51.953]             if (.Platform$OS.type == "windows") {
[16:12:51.953]                 old_names <- names(...future.oldEnvVars)
[16:12:51.953]                 envs <- base::Sys.getenv()
[16:12:51.953]                 names <- names(envs)
[16:12:51.953]                 common <- intersect(names, old_names)
[16:12:51.953]                 added <- setdiff(names, old_names)
[16:12:51.953]                 removed <- setdiff(old_names, names)
[16:12:51.953]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.953]                   envs[common]]
[16:12:51.953]                 NAMES <- toupper(changed)
[16:12:51.953]                 args <- list()
[16:12:51.953]                 for (kk in seq_along(NAMES)) {
[16:12:51.953]                   name <- changed[[kk]]
[16:12:51.953]                   NAME <- NAMES[[kk]]
[16:12:51.953]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.953]                     next
[16:12:51.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.953]                 }
[16:12:51.953]                 NAMES <- toupper(added)
[16:12:51.953]                 for (kk in seq_along(NAMES)) {
[16:12:51.953]                   name <- added[[kk]]
[16:12:51.953]                   NAME <- NAMES[[kk]]
[16:12:51.953]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.953]                     next
[16:12:51.953]                   args[[name]] <- ""
[16:12:51.953]                 }
[16:12:51.953]                 NAMES <- toupper(removed)
[16:12:51.953]                 for (kk in seq_along(NAMES)) {
[16:12:51.953]                   name <- removed[[kk]]
[16:12:51.953]                   NAME <- NAMES[[kk]]
[16:12:51.953]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.953]                     next
[16:12:51.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.953]                 }
[16:12:51.953]                 if (length(args) > 0) 
[16:12:51.953]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.953]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.953]             }
[16:12:51.953]             else {
[16:12:51.953]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.953]             }
[16:12:51.953]             {
[16:12:51.953]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.953]                   0L) {
[16:12:51.953]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.953]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.953]                   base::options(opts)
[16:12:51.953]                 }
[16:12:51.953]                 {
[16:12:51.953]                   {
[16:12:51.953]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:51.953]                     NULL
[16:12:51.953]                   }
[16:12:51.953]                   options(future.plan = NULL)
[16:12:51.953]                   if (is.na(NA_character_)) 
[16:12:51.953]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.953]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.953]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:51.953]                     envir = parent.frame()) 
[16:12:51.953]                   {
[16:12:51.953]                     default_workers <- missing(workers)
[16:12:51.953]                     if (is.function(workers)) 
[16:12:51.953]                       workers <- workers()
[16:12:51.953]                     workers <- structure(as.integer(workers), 
[16:12:51.953]                       class = class(workers))
[16:12:51.953]                     stop_if_not(is.finite(workers), workers >= 
[16:12:51.953]                       1L)
[16:12:51.953]                     if ((workers == 1L && !inherits(workers, 
[16:12:51.953]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:51.953]                       if (default_workers) 
[16:12:51.953]                         supportsMulticore(warn = TRUE)
[16:12:51.953]                       return(sequential(..., envir = envir))
[16:12:51.953]                     }
[16:12:51.953]                     oopts <- options(mc.cores = workers)
[16:12:51.953]                     on.exit(options(oopts))
[16:12:51.953]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:51.953]                       envir = envir)
[16:12:51.953]                     if (!future$lazy) 
[16:12:51.953]                       future <- run(future)
[16:12:51.953]                     invisible(future)
[16:12:51.953]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.953]                 }
[16:12:51.953]             }
[16:12:51.953]         }
[16:12:51.953]     })
[16:12:51.953]     if (TRUE) {
[16:12:51.953]         base::sink(type = "output", split = FALSE)
[16:12:51.953]         if (TRUE) {
[16:12:51.953]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.953]         }
[16:12:51.953]         else {
[16:12:51.953]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.953]         }
[16:12:51.953]         base::close(...future.stdout)
[16:12:51.953]         ...future.stdout <- NULL
[16:12:51.953]     }
[16:12:51.953]     ...future.result$conditions <- ...future.conditions
[16:12:51.953]     ...future.result$finished <- base::Sys.time()
[16:12:51.953]     ...future.result
[16:12:51.953] }
[16:12:51.956] requestCore(): workers = 2
[16:12:51.958] MulticoreFuture started
[16:12:51.958] - Launch lazy future ... done
[16:12:51.958] run() for ‘MulticoreFuture’ ... done
[16:12:51.959] plan(): Setting new future strategy stack:
[16:12:51.959] List of future strategies:
[16:12:51.959] 1. sequential:
[16:12:51.959]    - args: function (..., envir = parent.frame())
[16:12:51.959]    - tweaked: FALSE
[16:12:51.959]    - call: NULL
[16:12:51.960] plan(): nbrOfWorkers() = 1
[16:12:51.962] plan(): Setting new future strategy stack:
[16:12:51.962] List of future strategies:
[16:12:51.962] 1. multicore:
[16:12:51.962]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:51.962]    - tweaked: FALSE
[16:12:51.962]    - call: plan(strategy)
[16:12:51.968] plan(): nbrOfWorkers() = 2
[16:12:51.968] Future #1
[16:12:51.969] A MulticoreFuture was resolved
[16:12:51.970]  length: 0 (resolved future 1)
[16:12:51.970] resolve() on list ... DONE
[16:12:51.970] - globals: [1] ‘a’
[16:12:51.970] Resolving futures part of globals (recursively) ... DONE
[16:12:51.972] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[16:12:51.972] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[16:12:51.972] - globals: [1] ‘a’
[16:12:51.972] - packages: [1] ‘future’
[16:12:51.973] getGlobalsAndPackages() ... DONE
[16:12:51.973] run() for ‘Future’ ...
[16:12:51.973] - state: ‘created’
[16:12:51.973] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:51.977] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:51.977] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:51.977]   - Field: ‘label’
[16:12:51.978]   - Field: ‘local’
[16:12:51.978]   - Field: ‘owner’
[16:12:51.978]   - Field: ‘envir’
[16:12:51.978]   - Field: ‘workers’
[16:12:51.978]   - Field: ‘packages’
[16:12:51.978]   - Field: ‘gc’
[16:12:51.978]   - Field: ‘job’
[16:12:51.978]   - Field: ‘conditions’
[16:12:51.979]   - Field: ‘expr’
[16:12:51.979]   - Field: ‘uuid’
[16:12:51.979]   - Field: ‘seed’
[16:12:51.979]   - Field: ‘version’
[16:12:51.979]   - Field: ‘result’
[16:12:51.979]   - Field: ‘asynchronous’
[16:12:51.979]   - Field: ‘calls’
[16:12:51.979]   - Field: ‘globals’
[16:12:51.980]   - Field: ‘stdout’
[16:12:51.980]   - Field: ‘earlySignal’
[16:12:51.980]   - Field: ‘lazy’
[16:12:51.980]   - Field: ‘state’
[16:12:51.980] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:51.980] - Launch lazy future ...
[16:12:51.980] Packages needed by the future expression (n = 1): ‘future’
[16:12:51.981] Packages needed by future strategies (n = 0): <none>
[16:12:51.981] {
[16:12:51.981]     {
[16:12:51.981]         {
[16:12:51.981]             ...future.startTime <- base::Sys.time()
[16:12:51.981]             {
[16:12:51.981]                 {
[16:12:51.981]                   {
[16:12:51.981]                     {
[16:12:51.981]                       {
[16:12:51.981]                         base::local({
[16:12:51.981]                           has_future <- base::requireNamespace("future", 
[16:12:51.981]                             quietly = TRUE)
[16:12:51.981]                           if (has_future) {
[16:12:51.981]                             ns <- base::getNamespace("future")
[16:12:51.981]                             version <- ns[[".package"]][["version"]]
[16:12:51.981]                             if (is.null(version)) 
[16:12:51.981]                               version <- utils::packageVersion("future")
[16:12:51.981]                           }
[16:12:51.981]                           else {
[16:12:51.981]                             version <- NULL
[16:12:51.981]                           }
[16:12:51.981]                           if (!has_future || version < "1.8.0") {
[16:12:51.981]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:51.981]                               "", base::R.version$version.string), 
[16:12:51.981]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:51.981]                                 base::R.version$platform, 8 * 
[16:12:51.981]                                   base::.Machine$sizeof.pointer), 
[16:12:51.981]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:51.981]                                 "release", "version")], collapse = " "), 
[16:12:51.981]                               hostname = base::Sys.info()[["nodename"]])
[16:12:51.981]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:51.981]                               info)
[16:12:51.981]                             info <- base::paste(info, collapse = "; ")
[16:12:51.981]                             if (!has_future) {
[16:12:51.981]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:51.981]                                 info)
[16:12:51.981]                             }
[16:12:51.981]                             else {
[16:12:51.981]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:51.981]                                 info, version)
[16:12:51.981]                             }
[16:12:51.981]                             base::stop(msg)
[16:12:51.981]                           }
[16:12:51.981]                         })
[16:12:51.981]                       }
[16:12:51.981]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:51.981]                       base::options(mc.cores = 1L)
[16:12:51.981]                     }
[16:12:51.981]                     base::local({
[16:12:51.981]                       for (pkg in "future") {
[16:12:51.981]                         base::loadNamespace(pkg)
[16:12:51.981]                         base::library(pkg, character.only = TRUE)
[16:12:51.981]                       }
[16:12:51.981]                     })
[16:12:51.981]                   }
[16:12:51.981]                   options(future.plan = NULL)
[16:12:51.981]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.981]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:51.981]                 }
[16:12:51.981]                 ...future.workdir <- getwd()
[16:12:51.981]             }
[16:12:51.981]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:51.981]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:51.981]         }
[16:12:51.981]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:51.981]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:51.981]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:51.981]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:51.981]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:51.981]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:51.981]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:51.981]             base::names(...future.oldOptions))
[16:12:51.981]     }
[16:12:51.981]     if (FALSE) {
[16:12:51.981]     }
[16:12:51.981]     else {
[16:12:51.981]         if (TRUE) {
[16:12:51.981]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:51.981]                 open = "w")
[16:12:51.981]         }
[16:12:51.981]         else {
[16:12:51.981]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:51.981]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:51.981]         }
[16:12:51.981]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:51.981]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:51.981]             base::sink(type = "output", split = FALSE)
[16:12:51.981]             base::close(...future.stdout)
[16:12:51.981]         }, add = TRUE)
[16:12:51.981]     }
[16:12:51.981]     ...future.frame <- base::sys.nframe()
[16:12:51.981]     ...future.conditions <- base::list()
[16:12:51.981]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:51.981]     if (FALSE) {
[16:12:51.981]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:51.981]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:51.981]     }
[16:12:51.981]     ...future.result <- base::tryCatch({
[16:12:51.981]         base::withCallingHandlers({
[16:12:51.981]             ...future.value <- base::withVisible(base::local({
[16:12:51.981]                 withCallingHandlers({
[16:12:51.981]                   value(a) + 1
[16:12:51.981]                 }, immediateCondition = function(cond) {
[16:12:51.981]                   save_rds <- function (object, pathname, ...) 
[16:12:51.981]                   {
[16:12:51.981]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:51.981]                     if (file_test("-f", pathname_tmp)) {
[16:12:51.981]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.981]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:51.981]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.981]                         fi_tmp[["mtime"]])
[16:12:51.981]                     }
[16:12:51.981]                     tryCatch({
[16:12:51.981]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:51.981]                     }, error = function(ex) {
[16:12:51.981]                       msg <- conditionMessage(ex)
[16:12:51.981]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.981]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:51.981]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.981]                         fi_tmp[["mtime"]], msg)
[16:12:51.981]                       ex$message <- msg
[16:12:51.981]                       stop(ex)
[16:12:51.981]                     })
[16:12:51.981]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:51.981]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:51.981]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:51.981]                       fi_tmp <- file.info(pathname_tmp)
[16:12:51.981]                       fi <- file.info(pathname)
[16:12:51.981]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:51.981]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:51.981]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:51.981]                         fi[["size"]], fi[["mtime"]])
[16:12:51.981]                       stop(msg)
[16:12:51.981]                     }
[16:12:51.981]                     invisible(pathname)
[16:12:51.981]                   }
[16:12:51.981]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:51.981]                     rootPath = tempdir()) 
[16:12:51.981]                   {
[16:12:51.981]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:51.981]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:51.981]                       tmpdir = path, fileext = ".rds")
[16:12:51.981]                     save_rds(obj, file)
[16:12:51.981]                   }
[16:12:51.981]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:51.981]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.981]                   {
[16:12:51.981]                     inherits <- base::inherits
[16:12:51.981]                     invokeRestart <- base::invokeRestart
[16:12:51.981]                     is.null <- base::is.null
[16:12:51.981]                     muffled <- FALSE
[16:12:51.981]                     if (inherits(cond, "message")) {
[16:12:51.981]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:51.981]                       if (muffled) 
[16:12:51.981]                         invokeRestart("muffleMessage")
[16:12:51.981]                     }
[16:12:51.981]                     else if (inherits(cond, "warning")) {
[16:12:51.981]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:51.981]                       if (muffled) 
[16:12:51.981]                         invokeRestart("muffleWarning")
[16:12:51.981]                     }
[16:12:51.981]                     else if (inherits(cond, "condition")) {
[16:12:51.981]                       if (!is.null(pattern)) {
[16:12:51.981]                         computeRestarts <- base::computeRestarts
[16:12:51.981]                         grepl <- base::grepl
[16:12:51.981]                         restarts <- computeRestarts(cond)
[16:12:51.981]                         for (restart in restarts) {
[16:12:51.981]                           name <- restart$name
[16:12:51.981]                           if (is.null(name)) 
[16:12:51.981]                             next
[16:12:51.981]                           if (!grepl(pattern, name)) 
[16:12:51.981]                             next
[16:12:51.981]                           invokeRestart(restart)
[16:12:51.981]                           muffled <- TRUE
[16:12:51.981]                           break
[16:12:51.981]                         }
[16:12:51.981]                       }
[16:12:51.981]                     }
[16:12:51.981]                     invisible(muffled)
[16:12:51.981]                   }
[16:12:51.981]                   muffleCondition(cond)
[16:12:51.981]                 })
[16:12:51.981]             }))
[16:12:51.981]             future::FutureResult(value = ...future.value$value, 
[16:12:51.981]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.981]                   ...future.rng), globalenv = if (FALSE) 
[16:12:51.981]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:51.981]                     ...future.globalenv.names))
[16:12:51.981]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:51.981]         }, condition = base::local({
[16:12:51.981]             c <- base::c
[16:12:51.981]             inherits <- base::inherits
[16:12:51.981]             invokeRestart <- base::invokeRestart
[16:12:51.981]             length <- base::length
[16:12:51.981]             list <- base::list
[16:12:51.981]             seq.int <- base::seq.int
[16:12:51.981]             signalCondition <- base::signalCondition
[16:12:51.981]             sys.calls <- base::sys.calls
[16:12:51.981]             `[[` <- base::`[[`
[16:12:51.981]             `+` <- base::`+`
[16:12:51.981]             `<<-` <- base::`<<-`
[16:12:51.981]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:51.981]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:51.981]                   3L)]
[16:12:51.981]             }
[16:12:51.981]             function(cond) {
[16:12:51.981]                 is_error <- inherits(cond, "error")
[16:12:51.981]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:51.981]                   NULL)
[16:12:51.981]                 if (is_error) {
[16:12:51.981]                   sessionInformation <- function() {
[16:12:51.981]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:51.981]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:51.981]                       search = base::search(), system = base::Sys.info())
[16:12:51.981]                   }
[16:12:51.981]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.981]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:51.981]                     cond$call), session = sessionInformation(), 
[16:12:51.981]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:51.981]                   signalCondition(cond)
[16:12:51.981]                 }
[16:12:51.981]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:51.981]                 "immediateCondition"))) {
[16:12:51.981]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:51.981]                   ...future.conditions[[length(...future.conditions) + 
[16:12:51.981]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:51.981]                   if (TRUE && !signal) {
[16:12:51.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.981]                     {
[16:12:51.981]                       inherits <- base::inherits
[16:12:51.981]                       invokeRestart <- base::invokeRestart
[16:12:51.981]                       is.null <- base::is.null
[16:12:51.981]                       muffled <- FALSE
[16:12:51.981]                       if (inherits(cond, "message")) {
[16:12:51.981]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.981]                         if (muffled) 
[16:12:51.981]                           invokeRestart("muffleMessage")
[16:12:51.981]                       }
[16:12:51.981]                       else if (inherits(cond, "warning")) {
[16:12:51.981]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.981]                         if (muffled) 
[16:12:51.981]                           invokeRestart("muffleWarning")
[16:12:51.981]                       }
[16:12:51.981]                       else if (inherits(cond, "condition")) {
[16:12:51.981]                         if (!is.null(pattern)) {
[16:12:51.981]                           computeRestarts <- base::computeRestarts
[16:12:51.981]                           grepl <- base::grepl
[16:12:51.981]                           restarts <- computeRestarts(cond)
[16:12:51.981]                           for (restart in restarts) {
[16:12:51.981]                             name <- restart$name
[16:12:51.981]                             if (is.null(name)) 
[16:12:51.981]                               next
[16:12:51.981]                             if (!grepl(pattern, name)) 
[16:12:51.981]                               next
[16:12:51.981]                             invokeRestart(restart)
[16:12:51.981]                             muffled <- TRUE
[16:12:51.981]                             break
[16:12:51.981]                           }
[16:12:51.981]                         }
[16:12:51.981]                       }
[16:12:51.981]                       invisible(muffled)
[16:12:51.981]                     }
[16:12:51.981]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.981]                   }
[16:12:51.981]                 }
[16:12:51.981]                 else {
[16:12:51.981]                   if (TRUE) {
[16:12:51.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:51.981]                     {
[16:12:51.981]                       inherits <- base::inherits
[16:12:51.981]                       invokeRestart <- base::invokeRestart
[16:12:51.981]                       is.null <- base::is.null
[16:12:51.981]                       muffled <- FALSE
[16:12:51.981]                       if (inherits(cond, "message")) {
[16:12:51.981]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:51.981]                         if (muffled) 
[16:12:51.981]                           invokeRestart("muffleMessage")
[16:12:51.981]                       }
[16:12:51.981]                       else if (inherits(cond, "warning")) {
[16:12:51.981]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:51.981]                         if (muffled) 
[16:12:51.981]                           invokeRestart("muffleWarning")
[16:12:51.981]                       }
[16:12:51.981]                       else if (inherits(cond, "condition")) {
[16:12:51.981]                         if (!is.null(pattern)) {
[16:12:51.981]                           computeRestarts <- base::computeRestarts
[16:12:51.981]                           grepl <- base::grepl
[16:12:51.981]                           restarts <- computeRestarts(cond)
[16:12:51.981]                           for (restart in restarts) {
[16:12:51.981]                             name <- restart$name
[16:12:51.981]                             if (is.null(name)) 
[16:12:51.981]                               next
[16:12:51.981]                             if (!grepl(pattern, name)) 
[16:12:51.981]                               next
[16:12:51.981]                             invokeRestart(restart)
[16:12:51.981]                             muffled <- TRUE
[16:12:51.981]                             break
[16:12:51.981]                           }
[16:12:51.981]                         }
[16:12:51.981]                       }
[16:12:51.981]                       invisible(muffled)
[16:12:51.981]                     }
[16:12:51.981]                     muffleCondition(cond, pattern = "^muffle")
[16:12:51.981]                   }
[16:12:51.981]                 }
[16:12:51.981]             }
[16:12:51.981]         }))
[16:12:51.981]     }, error = function(ex) {
[16:12:51.981]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:51.981]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:51.981]                 ...future.rng), started = ...future.startTime, 
[16:12:51.981]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:51.981]             version = "1.8"), class = "FutureResult")
[16:12:51.981]     }, finally = {
[16:12:51.981]         if (!identical(...future.workdir, getwd())) 
[16:12:51.981]             setwd(...future.workdir)
[16:12:51.981]         {
[16:12:51.981]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:51.981]                 ...future.oldOptions$nwarnings <- NULL
[16:12:51.981]             }
[16:12:51.981]             base::options(...future.oldOptions)
[16:12:51.981]             if (.Platform$OS.type == "windows") {
[16:12:51.981]                 old_names <- names(...future.oldEnvVars)
[16:12:51.981]                 envs <- base::Sys.getenv()
[16:12:51.981]                 names <- names(envs)
[16:12:51.981]                 common <- intersect(names, old_names)
[16:12:51.981]                 added <- setdiff(names, old_names)
[16:12:51.981]                 removed <- setdiff(old_names, names)
[16:12:51.981]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:51.981]                   envs[common]]
[16:12:51.981]                 NAMES <- toupper(changed)
[16:12:51.981]                 args <- list()
[16:12:51.981]                 for (kk in seq_along(NAMES)) {
[16:12:51.981]                   name <- changed[[kk]]
[16:12:51.981]                   NAME <- NAMES[[kk]]
[16:12:51.981]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.981]                     next
[16:12:51.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.981]                 }
[16:12:51.981]                 NAMES <- toupper(added)
[16:12:51.981]                 for (kk in seq_along(NAMES)) {
[16:12:51.981]                   name <- added[[kk]]
[16:12:51.981]                   NAME <- NAMES[[kk]]
[16:12:51.981]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.981]                     next
[16:12:51.981]                   args[[name]] <- ""
[16:12:51.981]                 }
[16:12:51.981]                 NAMES <- toupper(removed)
[16:12:51.981]                 for (kk in seq_along(NAMES)) {
[16:12:51.981]                   name <- removed[[kk]]
[16:12:51.981]                   NAME <- NAMES[[kk]]
[16:12:51.981]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:51.981]                     next
[16:12:51.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:51.981]                 }
[16:12:51.981]                 if (length(args) > 0) 
[16:12:51.981]                   base::do.call(base::Sys.setenv, args = args)
[16:12:51.981]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:51.981]             }
[16:12:51.981]             else {
[16:12:51.981]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:51.981]             }
[16:12:51.981]             {
[16:12:51.981]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:51.981]                   0L) {
[16:12:51.981]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:51.981]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:51.981]                   base::options(opts)
[16:12:51.981]                 }
[16:12:51.981]                 {
[16:12:51.981]                   {
[16:12:51.981]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:51.981]                     NULL
[16:12:51.981]                   }
[16:12:51.981]                   options(future.plan = NULL)
[16:12:51.981]                   if (is.na(NA_character_)) 
[16:12:51.981]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:51.981]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:51.981]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:51.981]                     envir = parent.frame()) 
[16:12:51.981]                   {
[16:12:51.981]                     default_workers <- missing(workers)
[16:12:51.981]                     if (is.function(workers)) 
[16:12:51.981]                       workers <- workers()
[16:12:51.981]                     workers <- structure(as.integer(workers), 
[16:12:51.981]                       class = class(workers))
[16:12:51.981]                     stop_if_not(is.finite(workers), workers >= 
[16:12:51.981]                       1L)
[16:12:51.981]                     if ((workers == 1L && !inherits(workers, 
[16:12:51.981]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:51.981]                       if (default_workers) 
[16:12:51.981]                         supportsMulticore(warn = TRUE)
[16:12:51.981]                       return(sequential(..., envir = envir))
[16:12:51.981]                     }
[16:12:51.981]                     oopts <- options(mc.cores = workers)
[16:12:51.981]                     on.exit(options(oopts))
[16:12:51.981]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:51.981]                       envir = envir)
[16:12:51.981]                     if (!future$lazy) 
[16:12:51.981]                       future <- run(future)
[16:12:51.981]                     invisible(future)
[16:12:51.981]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:51.981]                 }
[16:12:51.981]             }
[16:12:51.981]         }
[16:12:51.981]     })
[16:12:51.981]     if (TRUE) {
[16:12:51.981]         base::sink(type = "output", split = FALSE)
[16:12:51.981]         if (TRUE) {
[16:12:51.981]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:51.981]         }
[16:12:51.981]         else {
[16:12:51.981]             ...future.result["stdout"] <- base::list(NULL)
[16:12:51.981]         }
[16:12:51.981]         base::close(...future.stdout)
[16:12:51.981]         ...future.stdout <- NULL
[16:12:51.981]     }
[16:12:51.981]     ...future.result$conditions <- ...future.conditions
[16:12:51.981]     ...future.result$finished <- base::Sys.time()
[16:12:51.981]     ...future.result
[16:12:51.981] }
[16:12:51.984] assign_globals() ...
[16:12:51.984] List of 1
[16:12:51.984]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x56233d8bed40> 
[16:12:51.984]  - attr(*, "where")=List of 1
[16:12:51.984]   ..$ a:<environment: R_EmptyEnv> 
[16:12:51.984]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:51.984]  - attr(*, "resolved")= logi TRUE
[16:12:51.984]  - attr(*, "total_size")= num 10984
[16:12:51.984]  - attr(*, "already-done")= logi TRUE
[16:12:51.987] - copied ‘a’ to environment
[16:12:51.988] assign_globals() ... done
[16:12:51.990] requestCore(): workers = 2
[16:12:51.992] MulticoreFuture started
[16:12:51.993] - Launch lazy future ... done
[16:12:51.993] run() for ‘MulticoreFuture’ ... done
[16:12:51.994] plan(): Setting new future strategy stack:
[16:12:51.994] List of future strategies:
[16:12:51.994] 1. sequential:
[16:12:51.994]    - args: function (..., envir = parent.frame())
[16:12:51.994]    - tweaked: FALSE
[16:12:51.994]    - call: NULL
[16:12:51.996] plan(): nbrOfWorkers() = 1
[16:12:51.999] plan(): Setting new future strategy stack:
[16:12:52.000] List of future strategies:
[16:12:52.000] 1. multicore:
[16:12:52.000]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:52.000]    - tweaked: FALSE
[16:12:52.000]    - call: plan(strategy)
[16:12:52.006] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:52.008] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:52.008] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:52.010] - globals found: [2] ‘{’, ‘pkg’
[16:12:52.010] Searching for globals ... DONE
[16:12:52.011] Resolving globals: TRUE
[16:12:52.011] Resolving any globals that are futures ...
[16:12:52.011] - globals: [2] ‘{’, ‘pkg’
[16:12:52.011] Resolving any globals that are futures ... DONE
[16:12:52.012] Resolving futures part of globals (recursively) ...
[16:12:52.012] resolve() on list ...
[16:12:52.012]  recursive: 99
[16:12:52.012]  length: 1
[16:12:52.012]  elements: ‘pkg’
[16:12:52.013]  length: 0 (resolved future 1)
[16:12:52.013] resolve() on list ... DONE
[16:12:52.013] - globals: [1] ‘pkg’
[16:12:52.013] Resolving futures part of globals (recursively) ... DONE
[16:12:52.013] The total size of the 1 globals is 112 bytes (112 bytes)
[16:12:52.014] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[16:12:52.014] - globals: [1] ‘pkg’
[16:12:52.014] 
[16:12:52.014] getGlobalsAndPackages() ... DONE
[16:12:52.015] Packages needed by the future expression (n = 0): <none>
[16:12:52.015] Packages needed by future strategies (n = 0): <none>
[16:12:52.015] {
[16:12:52.015]     {
[16:12:52.015]         {
[16:12:52.015]             ...future.startTime <- base::Sys.time()
[16:12:52.015]             {
[16:12:52.015]                 {
[16:12:52.015]                   {
[16:12:52.015]                     base::local({
[16:12:52.015]                       has_future <- base::requireNamespace("future", 
[16:12:52.015]                         quietly = TRUE)
[16:12:52.015]                       if (has_future) {
[16:12:52.015]                         ns <- base::getNamespace("future")
[16:12:52.015]                         version <- ns[[".package"]][["version"]]
[16:12:52.015]                         if (is.null(version)) 
[16:12:52.015]                           version <- utils::packageVersion("future")
[16:12:52.015]                       }
[16:12:52.015]                       else {
[16:12:52.015]                         version <- NULL
[16:12:52.015]                       }
[16:12:52.015]                       if (!has_future || version < "1.8.0") {
[16:12:52.015]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:52.015]                           "", base::R.version$version.string), 
[16:12:52.015]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:52.015]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:52.015]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:52.015]                             "release", "version")], collapse = " "), 
[16:12:52.015]                           hostname = base::Sys.info()[["nodename"]])
[16:12:52.015]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:52.015]                           info)
[16:12:52.015]                         info <- base::paste(info, collapse = "; ")
[16:12:52.015]                         if (!has_future) {
[16:12:52.015]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:52.015]                             info)
[16:12:52.015]                         }
[16:12:52.015]                         else {
[16:12:52.015]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:52.015]                             info, version)
[16:12:52.015]                         }
[16:12:52.015]                         base::stop(msg)
[16:12:52.015]                       }
[16:12:52.015]                     })
[16:12:52.015]                   }
[16:12:52.015]                   options(future.plan = NULL)
[16:12:52.015]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.015]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:52.015]                 }
[16:12:52.015]                 ...future.workdir <- getwd()
[16:12:52.015]             }
[16:12:52.015]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:52.015]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:52.015]         }
[16:12:52.015]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:52.015]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:52.015]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:52.015]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:52.015]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:52.015]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:52.015]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:52.015]             base::names(...future.oldOptions))
[16:12:52.015]     }
[16:12:52.015]     if (FALSE) {
[16:12:52.015]     }
[16:12:52.015]     else {
[16:12:52.015]         if (TRUE) {
[16:12:52.015]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:52.015]                 open = "w")
[16:12:52.015]         }
[16:12:52.015]         else {
[16:12:52.015]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:52.015]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:52.015]         }
[16:12:52.015]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:52.015]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:52.015]             base::sink(type = "output", split = FALSE)
[16:12:52.015]             base::close(...future.stdout)
[16:12:52.015]         }, add = TRUE)
[16:12:52.015]     }
[16:12:52.015]     ...future.frame <- base::sys.nframe()
[16:12:52.015]     ...future.conditions <- base::list()
[16:12:52.015]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:52.015]     if (FALSE) {
[16:12:52.015]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:52.015]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:52.015]     }
[16:12:52.015]     ...future.result <- base::tryCatch({
[16:12:52.015]         base::withCallingHandlers({
[16:12:52.015]             ...future.value <- base::withVisible(base::local({
[16:12:52.015]                 pkg
[16:12:52.015]             }))
[16:12:52.015]             future::FutureResult(value = ...future.value$value, 
[16:12:52.015]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.015]                   ...future.rng), globalenv = if (FALSE) 
[16:12:52.015]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:52.015]                     ...future.globalenv.names))
[16:12:52.015]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:52.015]         }, condition = base::local({
[16:12:52.015]             c <- base::c
[16:12:52.015]             inherits <- base::inherits
[16:12:52.015]             invokeRestart <- base::invokeRestart
[16:12:52.015]             length <- base::length
[16:12:52.015]             list <- base::list
[16:12:52.015]             seq.int <- base::seq.int
[16:12:52.015]             signalCondition <- base::signalCondition
[16:12:52.015]             sys.calls <- base::sys.calls
[16:12:52.015]             `[[` <- base::`[[`
[16:12:52.015]             `+` <- base::`+`
[16:12:52.015]             `<<-` <- base::`<<-`
[16:12:52.015]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:52.015]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:52.015]                   3L)]
[16:12:52.015]             }
[16:12:52.015]             function(cond) {
[16:12:52.015]                 is_error <- inherits(cond, "error")
[16:12:52.015]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:52.015]                   NULL)
[16:12:52.015]                 if (is_error) {
[16:12:52.015]                   sessionInformation <- function() {
[16:12:52.015]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:52.015]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:52.015]                       search = base::search(), system = base::Sys.info())
[16:12:52.015]                   }
[16:12:52.015]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.015]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:52.015]                     cond$call), session = sessionInformation(), 
[16:12:52.015]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:52.015]                   signalCondition(cond)
[16:12:52.015]                 }
[16:12:52.015]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:52.015]                 "immediateCondition"))) {
[16:12:52.015]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:52.015]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.015]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:52.015]                   if (TRUE && !signal) {
[16:12:52.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.015]                     {
[16:12:52.015]                       inherits <- base::inherits
[16:12:52.015]                       invokeRestart <- base::invokeRestart
[16:12:52.015]                       is.null <- base::is.null
[16:12:52.015]                       muffled <- FALSE
[16:12:52.015]                       if (inherits(cond, "message")) {
[16:12:52.015]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.015]                         if (muffled) 
[16:12:52.015]                           invokeRestart("muffleMessage")
[16:12:52.015]                       }
[16:12:52.015]                       else if (inherits(cond, "warning")) {
[16:12:52.015]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.015]                         if (muffled) 
[16:12:52.015]                           invokeRestart("muffleWarning")
[16:12:52.015]                       }
[16:12:52.015]                       else if (inherits(cond, "condition")) {
[16:12:52.015]                         if (!is.null(pattern)) {
[16:12:52.015]                           computeRestarts <- base::computeRestarts
[16:12:52.015]                           grepl <- base::grepl
[16:12:52.015]                           restarts <- computeRestarts(cond)
[16:12:52.015]                           for (restart in restarts) {
[16:12:52.015]                             name <- restart$name
[16:12:52.015]                             if (is.null(name)) 
[16:12:52.015]                               next
[16:12:52.015]                             if (!grepl(pattern, name)) 
[16:12:52.015]                               next
[16:12:52.015]                             invokeRestart(restart)
[16:12:52.015]                             muffled <- TRUE
[16:12:52.015]                             break
[16:12:52.015]                           }
[16:12:52.015]                         }
[16:12:52.015]                       }
[16:12:52.015]                       invisible(muffled)
[16:12:52.015]                     }
[16:12:52.015]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.015]                   }
[16:12:52.015]                 }
[16:12:52.015]                 else {
[16:12:52.015]                   if (TRUE) {
[16:12:52.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.015]                     {
[16:12:52.015]                       inherits <- base::inherits
[16:12:52.015]                       invokeRestart <- base::invokeRestart
[16:12:52.015]                       is.null <- base::is.null
[16:12:52.015]                       muffled <- FALSE
[16:12:52.015]                       if (inherits(cond, "message")) {
[16:12:52.015]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.015]                         if (muffled) 
[16:12:52.015]                           invokeRestart("muffleMessage")
[16:12:52.015]                       }
[16:12:52.015]                       else if (inherits(cond, "warning")) {
[16:12:52.015]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.015]                         if (muffled) 
[16:12:52.015]                           invokeRestart("muffleWarning")
[16:12:52.015]                       }
[16:12:52.015]                       else if (inherits(cond, "condition")) {
[16:12:52.015]                         if (!is.null(pattern)) {
[16:12:52.015]                           computeRestarts <- base::computeRestarts
[16:12:52.015]                           grepl <- base::grepl
[16:12:52.015]                           restarts <- computeRestarts(cond)
[16:12:52.015]                           for (restart in restarts) {
[16:12:52.015]                             name <- restart$name
[16:12:52.015]                             if (is.null(name)) 
[16:12:52.015]                               next
[16:12:52.015]                             if (!grepl(pattern, name)) 
[16:12:52.015]                               next
[16:12:52.015]                             invokeRestart(restart)
[16:12:52.015]                             muffled <- TRUE
[16:12:52.015]                             break
[16:12:52.015]                           }
[16:12:52.015]                         }
[16:12:52.015]                       }
[16:12:52.015]                       invisible(muffled)
[16:12:52.015]                     }
[16:12:52.015]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.015]                   }
[16:12:52.015]                 }
[16:12:52.015]             }
[16:12:52.015]         }))
[16:12:52.015]     }, error = function(ex) {
[16:12:52.015]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:52.015]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.015]                 ...future.rng), started = ...future.startTime, 
[16:12:52.015]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:52.015]             version = "1.8"), class = "FutureResult")
[16:12:52.015]     }, finally = {
[16:12:52.015]         if (!identical(...future.workdir, getwd())) 
[16:12:52.015]             setwd(...future.workdir)
[16:12:52.015]         {
[16:12:52.015]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:52.015]                 ...future.oldOptions$nwarnings <- NULL
[16:12:52.015]             }
[16:12:52.015]             base::options(...future.oldOptions)
[16:12:52.015]             if (.Platform$OS.type == "windows") {
[16:12:52.015]                 old_names <- names(...future.oldEnvVars)
[16:12:52.015]                 envs <- base::Sys.getenv()
[16:12:52.015]                 names <- names(envs)
[16:12:52.015]                 common <- intersect(names, old_names)
[16:12:52.015]                 added <- setdiff(names, old_names)
[16:12:52.015]                 removed <- setdiff(old_names, names)
[16:12:52.015]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:52.015]                   envs[common]]
[16:12:52.015]                 NAMES <- toupper(changed)
[16:12:52.015]                 args <- list()
[16:12:52.015]                 for (kk in seq_along(NAMES)) {
[16:12:52.015]                   name <- changed[[kk]]
[16:12:52.015]                   NAME <- NAMES[[kk]]
[16:12:52.015]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.015]                     next
[16:12:52.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.015]                 }
[16:12:52.015]                 NAMES <- toupper(added)
[16:12:52.015]                 for (kk in seq_along(NAMES)) {
[16:12:52.015]                   name <- added[[kk]]
[16:12:52.015]                   NAME <- NAMES[[kk]]
[16:12:52.015]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.015]                     next
[16:12:52.015]                   args[[name]] <- ""
[16:12:52.015]                 }
[16:12:52.015]                 NAMES <- toupper(removed)
[16:12:52.015]                 for (kk in seq_along(NAMES)) {
[16:12:52.015]                   name <- removed[[kk]]
[16:12:52.015]                   NAME <- NAMES[[kk]]
[16:12:52.015]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.015]                     next
[16:12:52.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.015]                 }
[16:12:52.015]                 if (length(args) > 0) 
[16:12:52.015]                   base::do.call(base::Sys.setenv, args = args)
[16:12:52.015]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:52.015]             }
[16:12:52.015]             else {
[16:12:52.015]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:52.015]             }
[16:12:52.015]             {
[16:12:52.015]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:52.015]                   0L) {
[16:12:52.015]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:52.015]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:52.015]                   base::options(opts)
[16:12:52.015]                 }
[16:12:52.015]                 {
[16:12:52.015]                   {
[16:12:52.015]                     NULL
[16:12:52.015]                     RNGkind("Mersenne-Twister")
[16:12:52.015]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:52.015]                       inherits = FALSE)
[16:12:52.015]                   }
[16:12:52.015]                   options(future.plan = NULL)
[16:12:52.015]                   if (is.na(NA_character_)) 
[16:12:52.015]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.015]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:52.015]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:52.015]                     envir = parent.frame()) 
[16:12:52.015]                   {
[16:12:52.015]                     default_workers <- missing(workers)
[16:12:52.015]                     if (is.function(workers)) 
[16:12:52.015]                       workers <- workers()
[16:12:52.015]                     workers <- structure(as.integer(workers), 
[16:12:52.015]                       class = class(workers))
[16:12:52.015]                     stop_if_not(is.finite(workers), workers >= 
[16:12:52.015]                       1L)
[16:12:52.015]                     if ((workers == 1L && !inherits(workers, 
[16:12:52.015]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:52.015]                       if (default_workers) 
[16:12:52.015]                         supportsMulticore(warn = TRUE)
[16:12:52.015]                       return(sequential(..., envir = envir))
[16:12:52.015]                     }
[16:12:52.015]                     oopts <- options(mc.cores = workers)
[16:12:52.015]                     on.exit(options(oopts))
[16:12:52.015]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:52.015]                       envir = envir)
[16:12:52.015]                     if (!future$lazy) 
[16:12:52.015]                       future <- run(future)
[16:12:52.015]                     invisible(future)
[16:12:52.015]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:52.015]                 }
[16:12:52.015]             }
[16:12:52.015]         }
[16:12:52.015]     })
[16:12:52.015]     if (TRUE) {
[16:12:52.015]         base::sink(type = "output", split = FALSE)
[16:12:52.015]         if (TRUE) {
[16:12:52.015]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:52.015]         }
[16:12:52.015]         else {
[16:12:52.015]             ...future.result["stdout"] <- base::list(NULL)
[16:12:52.015]         }
[16:12:52.015]         base::close(...future.stdout)
[16:12:52.015]         ...future.stdout <- NULL
[16:12:52.015]     }
[16:12:52.015]     ...future.result$conditions <- ...future.conditions
[16:12:52.015]     ...future.result$finished <- base::Sys.time()
[16:12:52.015]     ...future.result
[16:12:52.015] }
[16:12:52.018] assign_globals() ...
[16:12:52.018] List of 1
[16:12:52.018]  $ pkg: chr "foo"
[16:12:52.018]  - attr(*, "where")=List of 1
[16:12:52.018]   ..$ pkg:<environment: R_EmptyEnv> 
[16:12:52.018]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:52.018]  - attr(*, "resolved")= logi TRUE
[16:12:52.018]  - attr(*, "total_size")= num 112
[16:12:52.021] - copied ‘pkg’ to environment
[16:12:52.021] assign_globals() ... done
[16:12:52.021] plan(): Setting new future strategy stack:
[16:12:52.021] List of future strategies:
[16:12:52.021] 1. sequential:
[16:12:52.021]    - args: function (..., envir = parent.frame())
[16:12:52.021]    - tweaked: FALSE
[16:12:52.021]    - call: NULL
[16:12:52.022] plan(): nbrOfWorkers() = 1
[16:12:52.023] plan(): Setting new future strategy stack:
[16:12:52.023] List of future strategies:
[16:12:52.023] 1. multicore:
[16:12:52.023]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:52.023]    - tweaked: FALSE
[16:12:52.023]    - call: plan(strategy)
[16:12:52.027] plan(): nbrOfWorkers() = 2
[16:12:52.027] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:52.028] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:52.028] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:52.030] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:12:52.031] Searching for globals ... DONE
[16:12:52.031] Resolving globals: TRUE
[16:12:52.031] Resolving any globals that are futures ...
[16:12:52.031] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:12:52.031] Resolving any globals that are futures ... DONE
[16:12:52.031] Resolving futures part of globals (recursively) ...
[16:12:52.032] resolve() on list ...
[16:12:52.032]  recursive: 99
[16:12:52.032]  length: 1
[16:12:52.032]  elements: ‘a’
[16:12:52.032]  length: 0 (resolved future 1)
[16:12:52.032] resolve() on list ... DONE
[16:12:52.032] - globals: [1] ‘a’
[16:12:52.033] Resolving futures part of globals (recursively) ... DONE
[16:12:52.033] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:52.033] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:12:52.033] - globals: [1] ‘a’
[16:12:52.033] 
[16:12:52.033] getGlobalsAndPackages() ... DONE
[16:12:52.034] run() for ‘Future’ ...
[16:12:52.034] - state: ‘created’
[16:12:52.034] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:52.040] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:52.040] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:52.040]   - Field: ‘label’
[16:12:52.040]   - Field: ‘local’
[16:12:52.040]   - Field: ‘owner’
[16:12:52.040]   - Field: ‘envir’
[16:12:52.040]   - Field: ‘workers’
[16:12:52.040]   - Field: ‘packages’
[16:12:52.041]   - Field: ‘gc’
[16:12:52.041]   - Field: ‘job’
[16:12:52.041]   - Field: ‘conditions’
[16:12:52.041]   - Field: ‘expr’
[16:12:52.041]   - Field: ‘uuid’
[16:12:52.041]   - Field: ‘seed’
[16:12:52.041]   - Field: ‘version’
[16:12:52.041]   - Field: ‘result’
[16:12:52.041]   - Field: ‘asynchronous’
[16:12:52.041]   - Field: ‘calls’
[16:12:52.042]   - Field: ‘globals’
[16:12:52.042]   - Field: ‘stdout’
[16:12:52.042]   - Field: ‘earlySignal’
[16:12:52.042]   - Field: ‘lazy’
[16:12:52.042]   - Field: ‘state’
[16:12:52.042] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:52.042] - Launch lazy future ...
[16:12:52.042] Packages needed by the future expression (n = 0): <none>
[16:12:52.043] Packages needed by future strategies (n = 0): <none>
[16:12:52.043] {
[16:12:52.043]     {
[16:12:52.043]         {
[16:12:52.043]             ...future.startTime <- base::Sys.time()
[16:12:52.043]             {
[16:12:52.043]                 {
[16:12:52.043]                   {
[16:12:52.043]                     {
[16:12:52.043]                       base::local({
[16:12:52.043]                         has_future <- base::requireNamespace("future", 
[16:12:52.043]                           quietly = TRUE)
[16:12:52.043]                         if (has_future) {
[16:12:52.043]                           ns <- base::getNamespace("future")
[16:12:52.043]                           version <- ns[[".package"]][["version"]]
[16:12:52.043]                           if (is.null(version)) 
[16:12:52.043]                             version <- utils::packageVersion("future")
[16:12:52.043]                         }
[16:12:52.043]                         else {
[16:12:52.043]                           version <- NULL
[16:12:52.043]                         }
[16:12:52.043]                         if (!has_future || version < "1.8.0") {
[16:12:52.043]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:52.043]                             "", base::R.version$version.string), 
[16:12:52.043]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:52.043]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:52.043]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:52.043]                               "release", "version")], collapse = " "), 
[16:12:52.043]                             hostname = base::Sys.info()[["nodename"]])
[16:12:52.043]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:52.043]                             info)
[16:12:52.043]                           info <- base::paste(info, collapse = "; ")
[16:12:52.043]                           if (!has_future) {
[16:12:52.043]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:52.043]                               info)
[16:12:52.043]                           }
[16:12:52.043]                           else {
[16:12:52.043]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:52.043]                               info, version)
[16:12:52.043]                           }
[16:12:52.043]                           base::stop(msg)
[16:12:52.043]                         }
[16:12:52.043]                       })
[16:12:52.043]                     }
[16:12:52.043]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:52.043]                     base::options(mc.cores = 1L)
[16:12:52.043]                   }
[16:12:52.043]                   options(future.plan = NULL)
[16:12:52.043]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.043]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:52.043]                 }
[16:12:52.043]                 ...future.workdir <- getwd()
[16:12:52.043]             }
[16:12:52.043]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:52.043]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:52.043]         }
[16:12:52.043]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:52.043]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:52.043]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:52.043]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:52.043]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:52.043]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:52.043]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:52.043]             base::names(...future.oldOptions))
[16:12:52.043]     }
[16:12:52.043]     if (FALSE) {
[16:12:52.043]     }
[16:12:52.043]     else {
[16:12:52.043]         if (TRUE) {
[16:12:52.043]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:52.043]                 open = "w")
[16:12:52.043]         }
[16:12:52.043]         else {
[16:12:52.043]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:52.043]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:52.043]         }
[16:12:52.043]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:52.043]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:52.043]             base::sink(type = "output", split = FALSE)
[16:12:52.043]             base::close(...future.stdout)
[16:12:52.043]         }, add = TRUE)
[16:12:52.043]     }
[16:12:52.043]     ...future.frame <- base::sys.nframe()
[16:12:52.043]     ...future.conditions <- base::list()
[16:12:52.043]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:52.043]     if (FALSE) {
[16:12:52.043]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:52.043]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:52.043]     }
[16:12:52.043]     ...future.result <- base::tryCatch({
[16:12:52.043]         base::withCallingHandlers({
[16:12:52.043]             ...future.value <- base::withVisible(base::local({
[16:12:52.043]                 withCallingHandlers({
[16:12:52.043]                   {
[16:12:52.043]                     b <- a
[16:12:52.043]                     a <- 2
[16:12:52.043]                     a * b
[16:12:52.043]                   }
[16:12:52.043]                 }, immediateCondition = function(cond) {
[16:12:52.043]                   save_rds <- function (object, pathname, ...) 
[16:12:52.043]                   {
[16:12:52.043]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:52.043]                     if (file_test("-f", pathname_tmp)) {
[16:12:52.043]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.043]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:52.043]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.043]                         fi_tmp[["mtime"]])
[16:12:52.043]                     }
[16:12:52.043]                     tryCatch({
[16:12:52.043]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:52.043]                     }, error = function(ex) {
[16:12:52.043]                       msg <- conditionMessage(ex)
[16:12:52.043]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.043]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:52.043]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.043]                         fi_tmp[["mtime"]], msg)
[16:12:52.043]                       ex$message <- msg
[16:12:52.043]                       stop(ex)
[16:12:52.043]                     })
[16:12:52.043]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:52.043]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:52.043]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:52.043]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.043]                       fi <- file.info(pathname)
[16:12:52.043]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:52.043]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.043]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:52.043]                         fi[["size"]], fi[["mtime"]])
[16:12:52.043]                       stop(msg)
[16:12:52.043]                     }
[16:12:52.043]                     invisible(pathname)
[16:12:52.043]                   }
[16:12:52.043]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:52.043]                     rootPath = tempdir()) 
[16:12:52.043]                   {
[16:12:52.043]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:52.043]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:52.043]                       tmpdir = path, fileext = ".rds")
[16:12:52.043]                     save_rds(obj, file)
[16:12:52.043]                   }
[16:12:52.043]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:52.043]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.043]                   {
[16:12:52.043]                     inherits <- base::inherits
[16:12:52.043]                     invokeRestart <- base::invokeRestart
[16:12:52.043]                     is.null <- base::is.null
[16:12:52.043]                     muffled <- FALSE
[16:12:52.043]                     if (inherits(cond, "message")) {
[16:12:52.043]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:52.043]                       if (muffled) 
[16:12:52.043]                         invokeRestart("muffleMessage")
[16:12:52.043]                     }
[16:12:52.043]                     else if (inherits(cond, "warning")) {
[16:12:52.043]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:52.043]                       if (muffled) 
[16:12:52.043]                         invokeRestart("muffleWarning")
[16:12:52.043]                     }
[16:12:52.043]                     else if (inherits(cond, "condition")) {
[16:12:52.043]                       if (!is.null(pattern)) {
[16:12:52.043]                         computeRestarts <- base::computeRestarts
[16:12:52.043]                         grepl <- base::grepl
[16:12:52.043]                         restarts <- computeRestarts(cond)
[16:12:52.043]                         for (restart in restarts) {
[16:12:52.043]                           name <- restart$name
[16:12:52.043]                           if (is.null(name)) 
[16:12:52.043]                             next
[16:12:52.043]                           if (!grepl(pattern, name)) 
[16:12:52.043]                             next
[16:12:52.043]                           invokeRestart(restart)
[16:12:52.043]                           muffled <- TRUE
[16:12:52.043]                           break
[16:12:52.043]                         }
[16:12:52.043]                       }
[16:12:52.043]                     }
[16:12:52.043]                     invisible(muffled)
[16:12:52.043]                   }
[16:12:52.043]                   muffleCondition(cond)
[16:12:52.043]                 })
[16:12:52.043]             }))
[16:12:52.043]             future::FutureResult(value = ...future.value$value, 
[16:12:52.043]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.043]                   ...future.rng), globalenv = if (FALSE) 
[16:12:52.043]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:52.043]                     ...future.globalenv.names))
[16:12:52.043]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:52.043]         }, condition = base::local({
[16:12:52.043]             c <- base::c
[16:12:52.043]             inherits <- base::inherits
[16:12:52.043]             invokeRestart <- base::invokeRestart
[16:12:52.043]             length <- base::length
[16:12:52.043]             list <- base::list
[16:12:52.043]             seq.int <- base::seq.int
[16:12:52.043]             signalCondition <- base::signalCondition
[16:12:52.043]             sys.calls <- base::sys.calls
[16:12:52.043]             `[[` <- base::`[[`
[16:12:52.043]             `+` <- base::`+`
[16:12:52.043]             `<<-` <- base::`<<-`
[16:12:52.043]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:52.043]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:52.043]                   3L)]
[16:12:52.043]             }
[16:12:52.043]             function(cond) {
[16:12:52.043]                 is_error <- inherits(cond, "error")
[16:12:52.043]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:52.043]                   NULL)
[16:12:52.043]                 if (is_error) {
[16:12:52.043]                   sessionInformation <- function() {
[16:12:52.043]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:52.043]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:52.043]                       search = base::search(), system = base::Sys.info())
[16:12:52.043]                   }
[16:12:52.043]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.043]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:52.043]                     cond$call), session = sessionInformation(), 
[16:12:52.043]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:52.043]                   signalCondition(cond)
[16:12:52.043]                 }
[16:12:52.043]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:52.043]                 "immediateCondition"))) {
[16:12:52.043]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:52.043]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.043]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:52.043]                   if (TRUE && !signal) {
[16:12:52.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.043]                     {
[16:12:52.043]                       inherits <- base::inherits
[16:12:52.043]                       invokeRestart <- base::invokeRestart
[16:12:52.043]                       is.null <- base::is.null
[16:12:52.043]                       muffled <- FALSE
[16:12:52.043]                       if (inherits(cond, "message")) {
[16:12:52.043]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.043]                         if (muffled) 
[16:12:52.043]                           invokeRestart("muffleMessage")
[16:12:52.043]                       }
[16:12:52.043]                       else if (inherits(cond, "warning")) {
[16:12:52.043]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.043]                         if (muffled) 
[16:12:52.043]                           invokeRestart("muffleWarning")
[16:12:52.043]                       }
[16:12:52.043]                       else if (inherits(cond, "condition")) {
[16:12:52.043]                         if (!is.null(pattern)) {
[16:12:52.043]                           computeRestarts <- base::computeRestarts
[16:12:52.043]                           grepl <- base::grepl
[16:12:52.043]                           restarts <- computeRestarts(cond)
[16:12:52.043]                           for (restart in restarts) {
[16:12:52.043]                             name <- restart$name
[16:12:52.043]                             if (is.null(name)) 
[16:12:52.043]                               next
[16:12:52.043]                             if (!grepl(pattern, name)) 
[16:12:52.043]                               next
[16:12:52.043]                             invokeRestart(restart)
[16:12:52.043]                             muffled <- TRUE
[16:12:52.043]                             break
[16:12:52.043]                           }
[16:12:52.043]                         }
[16:12:52.043]                       }
[16:12:52.043]                       invisible(muffled)
[16:12:52.043]                     }
[16:12:52.043]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.043]                   }
[16:12:52.043]                 }
[16:12:52.043]                 else {
[16:12:52.043]                   if (TRUE) {
[16:12:52.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.043]                     {
[16:12:52.043]                       inherits <- base::inherits
[16:12:52.043]                       invokeRestart <- base::invokeRestart
[16:12:52.043]                       is.null <- base::is.null
[16:12:52.043]                       muffled <- FALSE
[16:12:52.043]                       if (inherits(cond, "message")) {
[16:12:52.043]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.043]                         if (muffled) 
[16:12:52.043]                           invokeRestart("muffleMessage")
[16:12:52.043]                       }
[16:12:52.043]                       else if (inherits(cond, "warning")) {
[16:12:52.043]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.043]                         if (muffled) 
[16:12:52.043]                           invokeRestart("muffleWarning")
[16:12:52.043]                       }
[16:12:52.043]                       else if (inherits(cond, "condition")) {
[16:12:52.043]                         if (!is.null(pattern)) {
[16:12:52.043]                           computeRestarts <- base::computeRestarts
[16:12:52.043]                           grepl <- base::grepl
[16:12:52.043]                           restarts <- computeRestarts(cond)
[16:12:52.043]                           for (restart in restarts) {
[16:12:52.043]                             name <- restart$name
[16:12:52.043]                             if (is.null(name)) 
[16:12:52.043]                               next
[16:12:52.043]                             if (!grepl(pattern, name)) 
[16:12:52.043]                               next
[16:12:52.043]                             invokeRestart(restart)
[16:12:52.043]                             muffled <- TRUE
[16:12:52.043]                             break
[16:12:52.043]                           }
[16:12:52.043]                         }
[16:12:52.043]                       }
[16:12:52.043]                       invisible(muffled)
[16:12:52.043]                     }
[16:12:52.043]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.043]                   }
[16:12:52.043]                 }
[16:12:52.043]             }
[16:12:52.043]         }))
[16:12:52.043]     }, error = function(ex) {
[16:12:52.043]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:52.043]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.043]                 ...future.rng), started = ...future.startTime, 
[16:12:52.043]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:52.043]             version = "1.8"), class = "FutureResult")
[16:12:52.043]     }, finally = {
[16:12:52.043]         if (!identical(...future.workdir, getwd())) 
[16:12:52.043]             setwd(...future.workdir)
[16:12:52.043]         {
[16:12:52.043]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:52.043]                 ...future.oldOptions$nwarnings <- NULL
[16:12:52.043]             }
[16:12:52.043]             base::options(...future.oldOptions)
[16:12:52.043]             if (.Platform$OS.type == "windows") {
[16:12:52.043]                 old_names <- names(...future.oldEnvVars)
[16:12:52.043]                 envs <- base::Sys.getenv()
[16:12:52.043]                 names <- names(envs)
[16:12:52.043]                 common <- intersect(names, old_names)
[16:12:52.043]                 added <- setdiff(names, old_names)
[16:12:52.043]                 removed <- setdiff(old_names, names)
[16:12:52.043]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:52.043]                   envs[common]]
[16:12:52.043]                 NAMES <- toupper(changed)
[16:12:52.043]                 args <- list()
[16:12:52.043]                 for (kk in seq_along(NAMES)) {
[16:12:52.043]                   name <- changed[[kk]]
[16:12:52.043]                   NAME <- NAMES[[kk]]
[16:12:52.043]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.043]                     next
[16:12:52.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.043]                 }
[16:12:52.043]                 NAMES <- toupper(added)
[16:12:52.043]                 for (kk in seq_along(NAMES)) {
[16:12:52.043]                   name <- added[[kk]]
[16:12:52.043]                   NAME <- NAMES[[kk]]
[16:12:52.043]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.043]                     next
[16:12:52.043]                   args[[name]] <- ""
[16:12:52.043]                 }
[16:12:52.043]                 NAMES <- toupper(removed)
[16:12:52.043]                 for (kk in seq_along(NAMES)) {
[16:12:52.043]                   name <- removed[[kk]]
[16:12:52.043]                   NAME <- NAMES[[kk]]
[16:12:52.043]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.043]                     next
[16:12:52.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.043]                 }
[16:12:52.043]                 if (length(args) > 0) 
[16:12:52.043]                   base::do.call(base::Sys.setenv, args = args)
[16:12:52.043]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:52.043]             }
[16:12:52.043]             else {
[16:12:52.043]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:52.043]             }
[16:12:52.043]             {
[16:12:52.043]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:52.043]                   0L) {
[16:12:52.043]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:52.043]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:52.043]                   base::options(opts)
[16:12:52.043]                 }
[16:12:52.043]                 {
[16:12:52.043]                   {
[16:12:52.043]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:52.043]                     NULL
[16:12:52.043]                   }
[16:12:52.043]                   options(future.plan = NULL)
[16:12:52.043]                   if (is.na(NA_character_)) 
[16:12:52.043]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.043]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:52.043]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:52.043]                     envir = parent.frame()) 
[16:12:52.043]                   {
[16:12:52.043]                     default_workers <- missing(workers)
[16:12:52.043]                     if (is.function(workers)) 
[16:12:52.043]                       workers <- workers()
[16:12:52.043]                     workers <- structure(as.integer(workers), 
[16:12:52.043]                       class = class(workers))
[16:12:52.043]                     stop_if_not(is.finite(workers), workers >= 
[16:12:52.043]                       1L)
[16:12:52.043]                     if ((workers == 1L && !inherits(workers, 
[16:12:52.043]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:52.043]                       if (default_workers) 
[16:12:52.043]                         supportsMulticore(warn = TRUE)
[16:12:52.043]                       return(sequential(..., envir = envir))
[16:12:52.043]                     }
[16:12:52.043]                     oopts <- options(mc.cores = workers)
[16:12:52.043]                     on.exit(options(oopts))
[16:12:52.043]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:52.043]                       envir = envir)
[16:12:52.043]                     if (!future$lazy) 
[16:12:52.043]                       future <- run(future)
[16:12:52.043]                     invisible(future)
[16:12:52.043]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:52.043]                 }
[16:12:52.043]             }
[16:12:52.043]         }
[16:12:52.043]     })
[16:12:52.043]     if (TRUE) {
[16:12:52.043]         base::sink(type = "output", split = FALSE)
[16:12:52.043]         if (TRUE) {
[16:12:52.043]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:52.043]         }
[16:12:52.043]         else {
[16:12:52.043]             ...future.result["stdout"] <- base::list(NULL)
[16:12:52.043]         }
[16:12:52.043]         base::close(...future.stdout)
[16:12:52.043]         ...future.stdout <- NULL
[16:12:52.043]     }
[16:12:52.043]     ...future.result$conditions <- ...future.conditions
[16:12:52.043]     ...future.result$finished <- base::Sys.time()
[16:12:52.043]     ...future.result
[16:12:52.043] }
[16:12:52.045] assign_globals() ...
[16:12:52.045] List of 1
[16:12:52.045]  $ a: num 3
[16:12:52.045]  - attr(*, "where")=List of 1
[16:12:52.045]   ..$ a:<environment: R_EmptyEnv> 
[16:12:52.045]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:52.045]  - attr(*, "resolved")= logi TRUE
[16:12:52.045]  - attr(*, "total_size")= num 56
[16:12:52.045]  - attr(*, "already-done")= logi TRUE
[16:12:52.048] - copied ‘a’ to environment
[16:12:52.048] assign_globals() ... done
[16:12:52.048] requestCore(): workers = 2
[16:12:52.050] MulticoreFuture started
[16:12:52.051] - Launch lazy future ... done
[16:12:52.051] run() for ‘MulticoreFuture’ ... done
[16:12:52.052] plan(): Setting new future strategy stack:
[16:12:52.052] List of future strategies:
[16:12:52.052] 1. sequential:
[16:12:52.052]    - args: function (..., envir = parent.frame())
[16:12:52.052]    - tweaked: FALSE
[16:12:52.052]    - call: NULL
[16:12:52.053] plan(): nbrOfWorkers() = 1
[16:12:52.055] plan(): Setting new future strategy stack:
[16:12:52.055] List of future strategies:
[16:12:52.055] 1. multicore:
[16:12:52.055]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:52.055]    - tweaked: FALSE
[16:12:52.055]    - call: plan(strategy)
[16:12:52.060] plan(): nbrOfWorkers() = 2
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:52.062] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:52.062] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:52.065] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:12:52.065] Searching for globals ... DONE
[16:12:52.065] Resolving globals: TRUE
[16:12:52.065] Resolving any globals that are futures ...
[16:12:52.065] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:12:52.065] Resolving any globals that are futures ... DONE
[16:12:52.066] Resolving futures part of globals (recursively) ...
[16:12:52.066] resolve() on list ...
[16:12:52.066]  recursive: 99
[16:12:52.067]  length: 1
[16:12:52.067]  elements: ‘a’
[16:12:52.067]  length: 0 (resolved future 1)
[16:12:52.067] resolve() on list ... DONE
[16:12:52.067] - globals: [1] ‘a’
[16:12:52.067] Resolving futures part of globals (recursively) ... DONE
[16:12:52.067] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:52.068] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:12:52.068] - globals: [1] ‘a’
[16:12:52.068] 
[16:12:52.068] getGlobalsAndPackages() ... DONE
[16:12:52.069] run() for ‘Future’ ...
[16:12:52.069] - state: ‘created’
[16:12:52.069] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:52.073] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:52.073] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:52.073]   - Field: ‘label’
[16:12:52.073]   - Field: ‘local’
[16:12:52.074]   - Field: ‘owner’
[16:12:52.074]   - Field: ‘envir’
[16:12:52.074]   - Field: ‘workers’
[16:12:52.074]   - Field: ‘packages’
[16:12:52.074]   - Field: ‘gc’
[16:12:52.074]   - Field: ‘job’
[16:12:52.074]   - Field: ‘conditions’
[16:12:52.074]   - Field: ‘expr’
[16:12:52.075]   - Field: ‘uuid’
[16:12:52.082]   - Field: ‘seed’
[16:12:52.082]   - Field: ‘version’
[16:12:52.082]   - Field: ‘result’
[16:12:52.082]   - Field: ‘asynchronous’
[16:12:52.083]   - Field: ‘calls’
[16:12:52.083]   - Field: ‘globals’
[16:12:52.083]   - Field: ‘stdout’
[16:12:52.083]   - Field: ‘earlySignal’
[16:12:52.083]   - Field: ‘lazy’
[16:12:52.083]   - Field: ‘state’
[16:12:52.083] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:52.083] - Launch lazy future ...
[16:12:52.084] Packages needed by the future expression (n = 0): <none>
[16:12:52.084] Packages needed by future strategies (n = 0): <none>
[16:12:52.084] {
[16:12:52.084]     {
[16:12:52.084]         {
[16:12:52.084]             ...future.startTime <- base::Sys.time()
[16:12:52.084]             {
[16:12:52.084]                 {
[16:12:52.084]                   {
[16:12:52.084]                     {
[16:12:52.084]                       base::local({
[16:12:52.084]                         has_future <- base::requireNamespace("future", 
[16:12:52.084]                           quietly = TRUE)
[16:12:52.084]                         if (has_future) {
[16:12:52.084]                           ns <- base::getNamespace("future")
[16:12:52.084]                           version <- ns[[".package"]][["version"]]
[16:12:52.084]                           if (is.null(version)) 
[16:12:52.084]                             version <- utils::packageVersion("future")
[16:12:52.084]                         }
[16:12:52.084]                         else {
[16:12:52.084]                           version <- NULL
[16:12:52.084]                         }
[16:12:52.084]                         if (!has_future || version < "1.8.0") {
[16:12:52.084]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:52.084]                             "", base::R.version$version.string), 
[16:12:52.084]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:52.084]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:52.084]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:52.084]                               "release", "version")], collapse = " "), 
[16:12:52.084]                             hostname = base::Sys.info()[["nodename"]])
[16:12:52.084]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:52.084]                             info)
[16:12:52.084]                           info <- base::paste(info, collapse = "; ")
[16:12:52.084]                           if (!has_future) {
[16:12:52.084]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:52.084]                               info)
[16:12:52.084]                           }
[16:12:52.084]                           else {
[16:12:52.084]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:52.084]                               info, version)
[16:12:52.084]                           }
[16:12:52.084]                           base::stop(msg)
[16:12:52.084]                         }
[16:12:52.084]                       })
[16:12:52.084]                     }
[16:12:52.084]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:52.084]                     base::options(mc.cores = 1L)
[16:12:52.084]                   }
[16:12:52.084]                   options(future.plan = NULL)
[16:12:52.084]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.084]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:52.084]                 }
[16:12:52.084]                 ...future.workdir <- getwd()
[16:12:52.084]             }
[16:12:52.084]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:52.084]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:52.084]         }
[16:12:52.084]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:52.084]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:52.084]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:52.084]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:52.084]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:52.084]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:52.084]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:52.084]             base::names(...future.oldOptions))
[16:12:52.084]     }
[16:12:52.084]     if (FALSE) {
[16:12:52.084]     }
[16:12:52.084]     else {
[16:12:52.084]         if (TRUE) {
[16:12:52.084]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:52.084]                 open = "w")
[16:12:52.084]         }
[16:12:52.084]         else {
[16:12:52.084]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:52.084]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:52.084]         }
[16:12:52.084]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:52.084]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:52.084]             base::sink(type = "output", split = FALSE)
[16:12:52.084]             base::close(...future.stdout)
[16:12:52.084]         }, add = TRUE)
[16:12:52.084]     }
[16:12:52.084]     ...future.frame <- base::sys.nframe()
[16:12:52.084]     ...future.conditions <- base::list()
[16:12:52.084]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:52.084]     if (FALSE) {
[16:12:52.084]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:52.084]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:52.084]     }
[16:12:52.084]     ...future.result <- base::tryCatch({
[16:12:52.084]         base::withCallingHandlers({
[16:12:52.084]             ...future.value <- base::withVisible(base::local({
[16:12:52.084]                 withCallingHandlers({
[16:12:52.084]                   {
[16:12:52.084]                     b <- a
[16:12:52.084]                     a <- 2
[16:12:52.084]                     a * b
[16:12:52.084]                   }
[16:12:52.084]                 }, immediateCondition = function(cond) {
[16:12:52.084]                   save_rds <- function (object, pathname, ...) 
[16:12:52.084]                   {
[16:12:52.084]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:52.084]                     if (file_test("-f", pathname_tmp)) {
[16:12:52.084]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.084]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:52.084]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.084]                         fi_tmp[["mtime"]])
[16:12:52.084]                     }
[16:12:52.084]                     tryCatch({
[16:12:52.084]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:52.084]                     }, error = function(ex) {
[16:12:52.084]                       msg <- conditionMessage(ex)
[16:12:52.084]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.084]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:52.084]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.084]                         fi_tmp[["mtime"]], msg)
[16:12:52.084]                       ex$message <- msg
[16:12:52.084]                       stop(ex)
[16:12:52.084]                     })
[16:12:52.084]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:52.084]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:52.084]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:52.084]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.084]                       fi <- file.info(pathname)
[16:12:52.084]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:52.084]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.084]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:52.084]                         fi[["size"]], fi[["mtime"]])
[16:12:52.084]                       stop(msg)
[16:12:52.084]                     }
[16:12:52.084]                     invisible(pathname)
[16:12:52.084]                   }
[16:12:52.084]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:52.084]                     rootPath = tempdir()) 
[16:12:52.084]                   {
[16:12:52.084]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:52.084]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:52.084]                       tmpdir = path, fileext = ".rds")
[16:12:52.084]                     save_rds(obj, file)
[16:12:52.084]                   }
[16:12:52.084]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:52.084]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.084]                   {
[16:12:52.084]                     inherits <- base::inherits
[16:12:52.084]                     invokeRestart <- base::invokeRestart
[16:12:52.084]                     is.null <- base::is.null
[16:12:52.084]                     muffled <- FALSE
[16:12:52.084]                     if (inherits(cond, "message")) {
[16:12:52.084]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:52.084]                       if (muffled) 
[16:12:52.084]                         invokeRestart("muffleMessage")
[16:12:52.084]                     }
[16:12:52.084]                     else if (inherits(cond, "warning")) {
[16:12:52.084]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:52.084]                       if (muffled) 
[16:12:52.084]                         invokeRestart("muffleWarning")
[16:12:52.084]                     }
[16:12:52.084]                     else if (inherits(cond, "condition")) {
[16:12:52.084]                       if (!is.null(pattern)) {
[16:12:52.084]                         computeRestarts <- base::computeRestarts
[16:12:52.084]                         grepl <- base::grepl
[16:12:52.084]                         restarts <- computeRestarts(cond)
[16:12:52.084]                         for (restart in restarts) {
[16:12:52.084]                           name <- restart$name
[16:12:52.084]                           if (is.null(name)) 
[16:12:52.084]                             next
[16:12:52.084]                           if (!grepl(pattern, name)) 
[16:12:52.084]                             next
[16:12:52.084]                           invokeRestart(restart)
[16:12:52.084]                           muffled <- TRUE
[16:12:52.084]                           break
[16:12:52.084]                         }
[16:12:52.084]                       }
[16:12:52.084]                     }
[16:12:52.084]                     invisible(muffled)
[16:12:52.084]                   }
[16:12:52.084]                   muffleCondition(cond)
[16:12:52.084]                 })
[16:12:52.084]             }))
[16:12:52.084]             future::FutureResult(value = ...future.value$value, 
[16:12:52.084]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.084]                   ...future.rng), globalenv = if (FALSE) 
[16:12:52.084]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:52.084]                     ...future.globalenv.names))
[16:12:52.084]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:52.084]         }, condition = base::local({
[16:12:52.084]             c <- base::c
[16:12:52.084]             inherits <- base::inherits
[16:12:52.084]             invokeRestart <- base::invokeRestart
[16:12:52.084]             length <- base::length
[16:12:52.084]             list <- base::list
[16:12:52.084]             seq.int <- base::seq.int
[16:12:52.084]             signalCondition <- base::signalCondition
[16:12:52.084]             sys.calls <- base::sys.calls
[16:12:52.084]             `[[` <- base::`[[`
[16:12:52.084]             `+` <- base::`+`
[16:12:52.084]             `<<-` <- base::`<<-`
[16:12:52.084]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:52.084]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:52.084]                   3L)]
[16:12:52.084]             }
[16:12:52.084]             function(cond) {
[16:12:52.084]                 is_error <- inherits(cond, "error")
[16:12:52.084]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:52.084]                   NULL)
[16:12:52.084]                 if (is_error) {
[16:12:52.084]                   sessionInformation <- function() {
[16:12:52.084]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:52.084]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:52.084]                       search = base::search(), system = base::Sys.info())
[16:12:52.084]                   }
[16:12:52.084]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.084]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:52.084]                     cond$call), session = sessionInformation(), 
[16:12:52.084]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:52.084]                   signalCondition(cond)
[16:12:52.084]                 }
[16:12:52.084]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:52.084]                 "immediateCondition"))) {
[16:12:52.084]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:52.084]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.084]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:52.084]                   if (TRUE && !signal) {
[16:12:52.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.084]                     {
[16:12:52.084]                       inherits <- base::inherits
[16:12:52.084]                       invokeRestart <- base::invokeRestart
[16:12:52.084]                       is.null <- base::is.null
[16:12:52.084]                       muffled <- FALSE
[16:12:52.084]                       if (inherits(cond, "message")) {
[16:12:52.084]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.084]                         if (muffled) 
[16:12:52.084]                           invokeRestart("muffleMessage")
[16:12:52.084]                       }
[16:12:52.084]                       else if (inherits(cond, "warning")) {
[16:12:52.084]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.084]                         if (muffled) 
[16:12:52.084]                           invokeRestart("muffleWarning")
[16:12:52.084]                       }
[16:12:52.084]                       else if (inherits(cond, "condition")) {
[16:12:52.084]                         if (!is.null(pattern)) {
[16:12:52.084]                           computeRestarts <- base::computeRestarts
[16:12:52.084]                           grepl <- base::grepl
[16:12:52.084]                           restarts <- computeRestarts(cond)
[16:12:52.084]                           for (restart in restarts) {
[16:12:52.084]                             name <- restart$name
[16:12:52.084]                             if (is.null(name)) 
[16:12:52.084]                               next
[16:12:52.084]                             if (!grepl(pattern, name)) 
[16:12:52.084]                               next
[16:12:52.084]                             invokeRestart(restart)
[16:12:52.084]                             muffled <- TRUE
[16:12:52.084]                             break
[16:12:52.084]                           }
[16:12:52.084]                         }
[16:12:52.084]                       }
[16:12:52.084]                       invisible(muffled)
[16:12:52.084]                     }
[16:12:52.084]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.084]                   }
[16:12:52.084]                 }
[16:12:52.084]                 else {
[16:12:52.084]                   if (TRUE) {
[16:12:52.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.084]                     {
[16:12:52.084]                       inherits <- base::inherits
[16:12:52.084]                       invokeRestart <- base::invokeRestart
[16:12:52.084]                       is.null <- base::is.null
[16:12:52.084]                       muffled <- FALSE
[16:12:52.084]                       if (inherits(cond, "message")) {
[16:12:52.084]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.084]                         if (muffled) 
[16:12:52.084]                           invokeRestart("muffleMessage")
[16:12:52.084]                       }
[16:12:52.084]                       else if (inherits(cond, "warning")) {
[16:12:52.084]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.084]                         if (muffled) 
[16:12:52.084]                           invokeRestart("muffleWarning")
[16:12:52.084]                       }
[16:12:52.084]                       else if (inherits(cond, "condition")) {
[16:12:52.084]                         if (!is.null(pattern)) {
[16:12:52.084]                           computeRestarts <- base::computeRestarts
[16:12:52.084]                           grepl <- base::grepl
[16:12:52.084]                           restarts <- computeRestarts(cond)
[16:12:52.084]                           for (restart in restarts) {
[16:12:52.084]                             name <- restart$name
[16:12:52.084]                             if (is.null(name)) 
[16:12:52.084]                               next
[16:12:52.084]                             if (!grepl(pattern, name)) 
[16:12:52.084]                               next
[16:12:52.084]                             invokeRestart(restart)
[16:12:52.084]                             muffled <- TRUE
[16:12:52.084]                             break
[16:12:52.084]                           }
[16:12:52.084]                         }
[16:12:52.084]                       }
[16:12:52.084]                       invisible(muffled)
[16:12:52.084]                     }
[16:12:52.084]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.084]                   }
[16:12:52.084]                 }
[16:12:52.084]             }
[16:12:52.084]         }))
[16:12:52.084]     }, error = function(ex) {
[16:12:52.084]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:52.084]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.084]                 ...future.rng), started = ...future.startTime, 
[16:12:52.084]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:52.084]             version = "1.8"), class = "FutureResult")
[16:12:52.084]     }, finally = {
[16:12:52.084]         if (!identical(...future.workdir, getwd())) 
[16:12:52.084]             setwd(...future.workdir)
[16:12:52.084]         {
[16:12:52.084]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:52.084]                 ...future.oldOptions$nwarnings <- NULL
[16:12:52.084]             }
[16:12:52.084]             base::options(...future.oldOptions)
[16:12:52.084]             if (.Platform$OS.type == "windows") {
[16:12:52.084]                 old_names <- names(...future.oldEnvVars)
[16:12:52.084]                 envs <- base::Sys.getenv()
[16:12:52.084]                 names <- names(envs)
[16:12:52.084]                 common <- intersect(names, old_names)
[16:12:52.084]                 added <- setdiff(names, old_names)
[16:12:52.084]                 removed <- setdiff(old_names, names)
[16:12:52.084]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:52.084]                   envs[common]]
[16:12:52.084]                 NAMES <- toupper(changed)
[16:12:52.084]                 args <- list()
[16:12:52.084]                 for (kk in seq_along(NAMES)) {
[16:12:52.084]                   name <- changed[[kk]]
[16:12:52.084]                   NAME <- NAMES[[kk]]
[16:12:52.084]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.084]                     next
[16:12:52.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.084]                 }
[16:12:52.084]                 NAMES <- toupper(added)
[16:12:52.084]                 for (kk in seq_along(NAMES)) {
[16:12:52.084]                   name <- added[[kk]]
[16:12:52.084]                   NAME <- NAMES[[kk]]
[16:12:52.084]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.084]                     next
[16:12:52.084]                   args[[name]] <- ""
[16:12:52.084]                 }
[16:12:52.084]                 NAMES <- toupper(removed)
[16:12:52.084]                 for (kk in seq_along(NAMES)) {
[16:12:52.084]                   name <- removed[[kk]]
[16:12:52.084]                   NAME <- NAMES[[kk]]
[16:12:52.084]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.084]                     next
[16:12:52.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.084]                 }
[16:12:52.084]                 if (length(args) > 0) 
[16:12:52.084]                   base::do.call(base::Sys.setenv, args = args)
[16:12:52.084]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:52.084]             }
[16:12:52.084]             else {
[16:12:52.084]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:52.084]             }
[16:12:52.084]             {
[16:12:52.084]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:52.084]                   0L) {
[16:12:52.084]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:52.084]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:52.084]                   base::options(opts)
[16:12:52.084]                 }
[16:12:52.084]                 {
[16:12:52.084]                   {
[16:12:52.084]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:52.084]                     NULL
[16:12:52.084]                   }
[16:12:52.084]                   options(future.plan = NULL)
[16:12:52.084]                   if (is.na(NA_character_)) 
[16:12:52.084]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.084]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:52.084]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:52.084]                     envir = parent.frame()) 
[16:12:52.084]                   {
[16:12:52.084]                     default_workers <- missing(workers)
[16:12:52.084]                     if (is.function(workers)) 
[16:12:52.084]                       workers <- workers()
[16:12:52.084]                     workers <- structure(as.integer(workers), 
[16:12:52.084]                       class = class(workers))
[16:12:52.084]                     stop_if_not(is.finite(workers), workers >= 
[16:12:52.084]                       1L)
[16:12:52.084]                     if ((workers == 1L && !inherits(workers, 
[16:12:52.084]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:52.084]                       if (default_workers) 
[16:12:52.084]                         supportsMulticore(warn = TRUE)
[16:12:52.084]                       return(sequential(..., envir = envir))
[16:12:52.084]                     }
[16:12:52.084]                     oopts <- options(mc.cores = workers)
[16:12:52.084]                     on.exit(options(oopts))
[16:12:52.084]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:52.084]                       envir = envir)
[16:12:52.084]                     if (!future$lazy) 
[16:12:52.084]                       future <- run(future)
[16:12:52.084]                     invisible(future)
[16:12:52.084]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:52.084]                 }
[16:12:52.084]             }
[16:12:52.084]         }
[16:12:52.084]     })
[16:12:52.084]     if (TRUE) {
[16:12:52.084]         base::sink(type = "output", split = FALSE)
[16:12:52.084]         if (TRUE) {
[16:12:52.084]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:52.084]         }
[16:12:52.084]         else {
[16:12:52.084]             ...future.result["stdout"] <- base::list(NULL)
[16:12:52.084]         }
[16:12:52.084]         base::close(...future.stdout)
[16:12:52.084]         ...future.stdout <- NULL
[16:12:52.084]     }
[16:12:52.084]     ...future.result$conditions <- ...future.conditions
[16:12:52.084]     ...future.result$finished <- base::Sys.time()
[16:12:52.084]     ...future.result
[16:12:52.084] }
[16:12:52.087] assign_globals() ...
[16:12:52.087] List of 1
[16:12:52.087]  $ a: num 3
[16:12:52.087]  - attr(*, "where")=List of 1
[16:12:52.087]   ..$ a:<environment: R_EmptyEnv> 
[16:12:52.087]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:52.087]  - attr(*, "resolved")= logi TRUE
[16:12:52.087]  - attr(*, "total_size")= num 56
[16:12:52.087]  - attr(*, "already-done")= logi TRUE
[16:12:52.089] - copied ‘a’ to environment
[16:12:52.090] assign_globals() ... done
[16:12:52.090] requestCore(): workers = 2
[16:12:52.092] MulticoreFuture started
[16:12:52.093] - Launch lazy future ... done
[16:12:52.093] plan(): Setting new future strategy stack:
[16:12:52.093] run() for ‘MulticoreFuture’ ... done
[16:12:52.093] List of future strategies:
[16:12:52.093] 1. sequential:
[16:12:52.093]    - args: function (..., envir = parent.frame())
[16:12:52.093]    - tweaked: FALSE
[16:12:52.093]    - call: NULL
[16:12:52.095] plan(): nbrOfWorkers() = 1
[16:12:52.098] plan(): Setting new future strategy stack:
[16:12:52.098] List of future strategies:
[16:12:52.098] 1. multicore:
[16:12:52.098]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:52.098]    - tweaked: FALSE
[16:12:52.098]    - call: plan(strategy)
[16:12:52.104] plan(): nbrOfWorkers() = 2
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:52.107] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:52.107] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:52.110] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:52.110] Searching for globals ... DONE
[16:12:52.111] Resolving globals: TRUE
[16:12:52.111] Resolving any globals that are futures ...
[16:12:52.111] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:52.111] Resolving any globals that are futures ... DONE
[16:12:52.112] Resolving futures part of globals (recursively) ...
[16:12:52.112] resolve() on list ...
[16:12:52.112]  recursive: 99
[16:12:52.112]  length: 2
[16:12:52.112]  elements: ‘a’, ‘ii’
[16:12:52.112]  length: 1 (resolved future 1)
[16:12:52.113]  length: 0 (resolved future 2)
[16:12:52.113] resolve() on list ... DONE
[16:12:52.113] - globals: [2] ‘a’, ‘ii’
[16:12:52.113] Resolving futures part of globals (recursively) ... DONE
[16:12:52.113] The total size of the 2 globals is 112 bytes (112 bytes)
[16:12:52.114] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:12:52.114] - globals: [2] ‘a’, ‘ii’
[16:12:52.114] 
[16:12:52.114] getGlobalsAndPackages() ... DONE
[16:12:52.114] run() for ‘Future’ ...
[16:12:52.114] - state: ‘created’
[16:12:52.115] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:52.119] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:52.119] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:52.119]   - Field: ‘label’
[16:12:52.119]   - Field: ‘local’
[16:12:52.120]   - Field: ‘owner’
[16:12:52.120]   - Field: ‘envir’
[16:12:52.120]   - Field: ‘workers’
[16:12:52.120]   - Field: ‘packages’
[16:12:52.120]   - Field: ‘gc’
[16:12:52.120]   - Field: ‘job’
[16:12:52.120]   - Field: ‘conditions’
[16:12:52.121]   - Field: ‘expr’
[16:12:52.121]   - Field: ‘uuid’
[16:12:52.121]   - Field: ‘seed’
[16:12:52.121]   - Field: ‘version’
[16:12:52.121]   - Field: ‘result’
[16:12:52.121]   - Field: ‘asynchronous’
[16:12:52.121]   - Field: ‘calls’
[16:12:52.121]   - Field: ‘globals’
[16:12:52.122]   - Field: ‘stdout’
[16:12:52.122]   - Field: ‘earlySignal’
[16:12:52.122]   - Field: ‘lazy’
[16:12:52.122]   - Field: ‘state’
[16:12:52.122] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:52.122] - Launch lazy future ...
[16:12:52.122] Packages needed by the future expression (n = 0): <none>
[16:12:52.123] Packages needed by future strategies (n = 0): <none>
[16:12:52.123] {
[16:12:52.123]     {
[16:12:52.123]         {
[16:12:52.123]             ...future.startTime <- base::Sys.time()
[16:12:52.123]             {
[16:12:52.123]                 {
[16:12:52.123]                   {
[16:12:52.123]                     {
[16:12:52.123]                       base::local({
[16:12:52.123]                         has_future <- base::requireNamespace("future", 
[16:12:52.123]                           quietly = TRUE)
[16:12:52.123]                         if (has_future) {
[16:12:52.123]                           ns <- base::getNamespace("future")
[16:12:52.123]                           version <- ns[[".package"]][["version"]]
[16:12:52.123]                           if (is.null(version)) 
[16:12:52.123]                             version <- utils::packageVersion("future")
[16:12:52.123]                         }
[16:12:52.123]                         else {
[16:12:52.123]                           version <- NULL
[16:12:52.123]                         }
[16:12:52.123]                         if (!has_future || version < "1.8.0") {
[16:12:52.123]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:52.123]                             "", base::R.version$version.string), 
[16:12:52.123]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:52.123]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:52.123]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:52.123]                               "release", "version")], collapse = " "), 
[16:12:52.123]                             hostname = base::Sys.info()[["nodename"]])
[16:12:52.123]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:52.123]                             info)
[16:12:52.123]                           info <- base::paste(info, collapse = "; ")
[16:12:52.123]                           if (!has_future) {
[16:12:52.123]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:52.123]                               info)
[16:12:52.123]                           }
[16:12:52.123]                           else {
[16:12:52.123]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:52.123]                               info, version)
[16:12:52.123]                           }
[16:12:52.123]                           base::stop(msg)
[16:12:52.123]                         }
[16:12:52.123]                       })
[16:12:52.123]                     }
[16:12:52.123]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:52.123]                     base::options(mc.cores = 1L)
[16:12:52.123]                   }
[16:12:52.123]                   options(future.plan = NULL)
[16:12:52.123]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.123]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:52.123]                 }
[16:12:52.123]                 ...future.workdir <- getwd()
[16:12:52.123]             }
[16:12:52.123]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:52.123]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:52.123]         }
[16:12:52.123]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:52.123]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:52.123]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:52.123]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:52.123]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:52.123]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:52.123]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:52.123]             base::names(...future.oldOptions))
[16:12:52.123]     }
[16:12:52.123]     if (FALSE) {
[16:12:52.123]     }
[16:12:52.123]     else {
[16:12:52.123]         if (TRUE) {
[16:12:52.123]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:52.123]                 open = "w")
[16:12:52.123]         }
[16:12:52.123]         else {
[16:12:52.123]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:52.123]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:52.123]         }
[16:12:52.123]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:52.123]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:52.123]             base::sink(type = "output", split = FALSE)
[16:12:52.123]             base::close(...future.stdout)
[16:12:52.123]         }, add = TRUE)
[16:12:52.123]     }
[16:12:52.123]     ...future.frame <- base::sys.nframe()
[16:12:52.123]     ...future.conditions <- base::list()
[16:12:52.123]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:52.123]     if (FALSE) {
[16:12:52.123]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:52.123]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:52.123]     }
[16:12:52.123]     ...future.result <- base::tryCatch({
[16:12:52.123]         base::withCallingHandlers({
[16:12:52.123]             ...future.value <- base::withVisible(base::local({
[16:12:52.123]                 withCallingHandlers({
[16:12:52.123]                   {
[16:12:52.123]                     b <- a * ii
[16:12:52.123]                     a <- 0
[16:12:52.123]                     b
[16:12:52.123]                   }
[16:12:52.123]                 }, immediateCondition = function(cond) {
[16:12:52.123]                   save_rds <- function (object, pathname, ...) 
[16:12:52.123]                   {
[16:12:52.123]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:52.123]                     if (file_test("-f", pathname_tmp)) {
[16:12:52.123]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.123]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:52.123]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.123]                         fi_tmp[["mtime"]])
[16:12:52.123]                     }
[16:12:52.123]                     tryCatch({
[16:12:52.123]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:52.123]                     }, error = function(ex) {
[16:12:52.123]                       msg <- conditionMessage(ex)
[16:12:52.123]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.123]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:52.123]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.123]                         fi_tmp[["mtime"]], msg)
[16:12:52.123]                       ex$message <- msg
[16:12:52.123]                       stop(ex)
[16:12:52.123]                     })
[16:12:52.123]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:52.123]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:52.123]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:52.123]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.123]                       fi <- file.info(pathname)
[16:12:52.123]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:52.123]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.123]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:52.123]                         fi[["size"]], fi[["mtime"]])
[16:12:52.123]                       stop(msg)
[16:12:52.123]                     }
[16:12:52.123]                     invisible(pathname)
[16:12:52.123]                   }
[16:12:52.123]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:52.123]                     rootPath = tempdir()) 
[16:12:52.123]                   {
[16:12:52.123]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:52.123]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:52.123]                       tmpdir = path, fileext = ".rds")
[16:12:52.123]                     save_rds(obj, file)
[16:12:52.123]                   }
[16:12:52.123]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:52.123]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.123]                   {
[16:12:52.123]                     inherits <- base::inherits
[16:12:52.123]                     invokeRestart <- base::invokeRestart
[16:12:52.123]                     is.null <- base::is.null
[16:12:52.123]                     muffled <- FALSE
[16:12:52.123]                     if (inherits(cond, "message")) {
[16:12:52.123]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:52.123]                       if (muffled) 
[16:12:52.123]                         invokeRestart("muffleMessage")
[16:12:52.123]                     }
[16:12:52.123]                     else if (inherits(cond, "warning")) {
[16:12:52.123]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:52.123]                       if (muffled) 
[16:12:52.123]                         invokeRestart("muffleWarning")
[16:12:52.123]                     }
[16:12:52.123]                     else if (inherits(cond, "condition")) {
[16:12:52.123]                       if (!is.null(pattern)) {
[16:12:52.123]                         computeRestarts <- base::computeRestarts
[16:12:52.123]                         grepl <- base::grepl
[16:12:52.123]                         restarts <- computeRestarts(cond)
[16:12:52.123]                         for (restart in restarts) {
[16:12:52.123]                           name <- restart$name
[16:12:52.123]                           if (is.null(name)) 
[16:12:52.123]                             next
[16:12:52.123]                           if (!grepl(pattern, name)) 
[16:12:52.123]                             next
[16:12:52.123]                           invokeRestart(restart)
[16:12:52.123]                           muffled <- TRUE
[16:12:52.123]                           break
[16:12:52.123]                         }
[16:12:52.123]                       }
[16:12:52.123]                     }
[16:12:52.123]                     invisible(muffled)
[16:12:52.123]                   }
[16:12:52.123]                   muffleCondition(cond)
[16:12:52.123]                 })
[16:12:52.123]             }))
[16:12:52.123]             future::FutureResult(value = ...future.value$value, 
[16:12:52.123]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.123]                   ...future.rng), globalenv = if (FALSE) 
[16:12:52.123]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:52.123]                     ...future.globalenv.names))
[16:12:52.123]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:52.123]         }, condition = base::local({
[16:12:52.123]             c <- base::c
[16:12:52.123]             inherits <- base::inherits
[16:12:52.123]             invokeRestart <- base::invokeRestart
[16:12:52.123]             length <- base::length
[16:12:52.123]             list <- base::list
[16:12:52.123]             seq.int <- base::seq.int
[16:12:52.123]             signalCondition <- base::signalCondition
[16:12:52.123]             sys.calls <- base::sys.calls
[16:12:52.123]             `[[` <- base::`[[`
[16:12:52.123]             `+` <- base::`+`
[16:12:52.123]             `<<-` <- base::`<<-`
[16:12:52.123]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:52.123]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:52.123]                   3L)]
[16:12:52.123]             }
[16:12:52.123]             function(cond) {
[16:12:52.123]                 is_error <- inherits(cond, "error")
[16:12:52.123]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:52.123]                   NULL)
[16:12:52.123]                 if (is_error) {
[16:12:52.123]                   sessionInformation <- function() {
[16:12:52.123]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:52.123]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:52.123]                       search = base::search(), system = base::Sys.info())
[16:12:52.123]                   }
[16:12:52.123]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.123]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:52.123]                     cond$call), session = sessionInformation(), 
[16:12:52.123]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:52.123]                   signalCondition(cond)
[16:12:52.123]                 }
[16:12:52.123]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:52.123]                 "immediateCondition"))) {
[16:12:52.123]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:52.123]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.123]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:52.123]                   if (TRUE && !signal) {
[16:12:52.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.123]                     {
[16:12:52.123]                       inherits <- base::inherits
[16:12:52.123]                       invokeRestart <- base::invokeRestart
[16:12:52.123]                       is.null <- base::is.null
[16:12:52.123]                       muffled <- FALSE
[16:12:52.123]                       if (inherits(cond, "message")) {
[16:12:52.123]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.123]                         if (muffled) 
[16:12:52.123]                           invokeRestart("muffleMessage")
[16:12:52.123]                       }
[16:12:52.123]                       else if (inherits(cond, "warning")) {
[16:12:52.123]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.123]                         if (muffled) 
[16:12:52.123]                           invokeRestart("muffleWarning")
[16:12:52.123]                       }
[16:12:52.123]                       else if (inherits(cond, "condition")) {
[16:12:52.123]                         if (!is.null(pattern)) {
[16:12:52.123]                           computeRestarts <- base::computeRestarts
[16:12:52.123]                           grepl <- base::grepl
[16:12:52.123]                           restarts <- computeRestarts(cond)
[16:12:52.123]                           for (restart in restarts) {
[16:12:52.123]                             name <- restart$name
[16:12:52.123]                             if (is.null(name)) 
[16:12:52.123]                               next
[16:12:52.123]                             if (!grepl(pattern, name)) 
[16:12:52.123]                               next
[16:12:52.123]                             invokeRestart(restart)
[16:12:52.123]                             muffled <- TRUE
[16:12:52.123]                             break
[16:12:52.123]                           }
[16:12:52.123]                         }
[16:12:52.123]                       }
[16:12:52.123]                       invisible(muffled)
[16:12:52.123]                     }
[16:12:52.123]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.123]                   }
[16:12:52.123]                 }
[16:12:52.123]                 else {
[16:12:52.123]                   if (TRUE) {
[16:12:52.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.123]                     {
[16:12:52.123]                       inherits <- base::inherits
[16:12:52.123]                       invokeRestart <- base::invokeRestart
[16:12:52.123]                       is.null <- base::is.null
[16:12:52.123]                       muffled <- FALSE
[16:12:52.123]                       if (inherits(cond, "message")) {
[16:12:52.123]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.123]                         if (muffled) 
[16:12:52.123]                           invokeRestart("muffleMessage")
[16:12:52.123]                       }
[16:12:52.123]                       else if (inherits(cond, "warning")) {
[16:12:52.123]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.123]                         if (muffled) 
[16:12:52.123]                           invokeRestart("muffleWarning")
[16:12:52.123]                       }
[16:12:52.123]                       else if (inherits(cond, "condition")) {
[16:12:52.123]                         if (!is.null(pattern)) {
[16:12:52.123]                           computeRestarts <- base::computeRestarts
[16:12:52.123]                           grepl <- base::grepl
[16:12:52.123]                           restarts <- computeRestarts(cond)
[16:12:52.123]                           for (restart in restarts) {
[16:12:52.123]                             name <- restart$name
[16:12:52.123]                             if (is.null(name)) 
[16:12:52.123]                               next
[16:12:52.123]                             if (!grepl(pattern, name)) 
[16:12:52.123]                               next
[16:12:52.123]                             invokeRestart(restart)
[16:12:52.123]                             muffled <- TRUE
[16:12:52.123]                             break
[16:12:52.123]                           }
[16:12:52.123]                         }
[16:12:52.123]                       }
[16:12:52.123]                       invisible(muffled)
[16:12:52.123]                     }
[16:12:52.123]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.123]                   }
[16:12:52.123]                 }
[16:12:52.123]             }
[16:12:52.123]         }))
[16:12:52.123]     }, error = function(ex) {
[16:12:52.123]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:52.123]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.123]                 ...future.rng), started = ...future.startTime, 
[16:12:52.123]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:52.123]             version = "1.8"), class = "FutureResult")
[16:12:52.123]     }, finally = {
[16:12:52.123]         if (!identical(...future.workdir, getwd())) 
[16:12:52.123]             setwd(...future.workdir)
[16:12:52.123]         {
[16:12:52.123]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:52.123]                 ...future.oldOptions$nwarnings <- NULL
[16:12:52.123]             }
[16:12:52.123]             base::options(...future.oldOptions)
[16:12:52.123]             if (.Platform$OS.type == "windows") {
[16:12:52.123]                 old_names <- names(...future.oldEnvVars)
[16:12:52.123]                 envs <- base::Sys.getenv()
[16:12:52.123]                 names <- names(envs)
[16:12:52.123]                 common <- intersect(names, old_names)
[16:12:52.123]                 added <- setdiff(names, old_names)
[16:12:52.123]                 removed <- setdiff(old_names, names)
[16:12:52.123]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:52.123]                   envs[common]]
[16:12:52.123]                 NAMES <- toupper(changed)
[16:12:52.123]                 args <- list()
[16:12:52.123]                 for (kk in seq_along(NAMES)) {
[16:12:52.123]                   name <- changed[[kk]]
[16:12:52.123]                   NAME <- NAMES[[kk]]
[16:12:52.123]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.123]                     next
[16:12:52.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.123]                 }
[16:12:52.123]                 NAMES <- toupper(added)
[16:12:52.123]                 for (kk in seq_along(NAMES)) {
[16:12:52.123]                   name <- added[[kk]]
[16:12:52.123]                   NAME <- NAMES[[kk]]
[16:12:52.123]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.123]                     next
[16:12:52.123]                   args[[name]] <- ""
[16:12:52.123]                 }
[16:12:52.123]                 NAMES <- toupper(removed)
[16:12:52.123]                 for (kk in seq_along(NAMES)) {
[16:12:52.123]                   name <- removed[[kk]]
[16:12:52.123]                   NAME <- NAMES[[kk]]
[16:12:52.123]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.123]                     next
[16:12:52.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.123]                 }
[16:12:52.123]                 if (length(args) > 0) 
[16:12:52.123]                   base::do.call(base::Sys.setenv, args = args)
[16:12:52.123]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:52.123]             }
[16:12:52.123]             else {
[16:12:52.123]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:52.123]             }
[16:12:52.123]             {
[16:12:52.123]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:52.123]                   0L) {
[16:12:52.123]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:52.123]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:52.123]                   base::options(opts)
[16:12:52.123]                 }
[16:12:52.123]                 {
[16:12:52.123]                   {
[16:12:52.123]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:52.123]                     NULL
[16:12:52.123]                   }
[16:12:52.123]                   options(future.plan = NULL)
[16:12:52.123]                   if (is.na(NA_character_)) 
[16:12:52.123]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.123]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:52.123]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:52.123]                     envir = parent.frame()) 
[16:12:52.123]                   {
[16:12:52.123]                     default_workers <- missing(workers)
[16:12:52.123]                     if (is.function(workers)) 
[16:12:52.123]                       workers <- workers()
[16:12:52.123]                     workers <- structure(as.integer(workers), 
[16:12:52.123]                       class = class(workers))
[16:12:52.123]                     stop_if_not(is.finite(workers), workers >= 
[16:12:52.123]                       1L)
[16:12:52.123]                     if ((workers == 1L && !inherits(workers, 
[16:12:52.123]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:52.123]                       if (default_workers) 
[16:12:52.123]                         supportsMulticore(warn = TRUE)
[16:12:52.123]                       return(sequential(..., envir = envir))
[16:12:52.123]                     }
[16:12:52.123]                     oopts <- options(mc.cores = workers)
[16:12:52.123]                     on.exit(options(oopts))
[16:12:52.123]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:52.123]                       envir = envir)
[16:12:52.123]                     if (!future$lazy) 
[16:12:52.123]                       future <- run(future)
[16:12:52.123]                     invisible(future)
[16:12:52.123]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:52.123]                 }
[16:12:52.123]             }
[16:12:52.123]         }
[16:12:52.123]     })
[16:12:52.123]     if (TRUE) {
[16:12:52.123]         base::sink(type = "output", split = FALSE)
[16:12:52.123]         if (TRUE) {
[16:12:52.123]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:52.123]         }
[16:12:52.123]         else {
[16:12:52.123]             ...future.result["stdout"] <- base::list(NULL)
[16:12:52.123]         }
[16:12:52.123]         base::close(...future.stdout)
[16:12:52.123]         ...future.stdout <- NULL
[16:12:52.123]     }
[16:12:52.123]     ...future.result$conditions <- ...future.conditions
[16:12:52.123]     ...future.result$finished <- base::Sys.time()
[16:12:52.123]     ...future.result
[16:12:52.123] }
[16:12:52.126] assign_globals() ...
[16:12:52.126] List of 2
[16:12:52.126]  $ a : num 1
[16:12:52.126]  $ ii: int 1
[16:12:52.126]  - attr(*, "where")=List of 2
[16:12:52.126]   ..$ a :<environment: R_EmptyEnv> 
[16:12:52.126]   ..$ ii:<environment: R_EmptyEnv> 
[16:12:52.126]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:52.126]  - attr(*, "resolved")= logi TRUE
[16:12:52.126]  - attr(*, "total_size")= num 112
[16:12:52.126]  - attr(*, "already-done")= logi TRUE
[16:12:52.130] - copied ‘a’ to environment
[16:12:52.130] - copied ‘ii’ to environment
[16:12:52.130] assign_globals() ... done
[16:12:52.130] requestCore(): workers = 2
[16:12:52.132] MulticoreFuture started
[16:12:52.132] - Launch lazy future ... done
[16:12:52.132] run() for ‘MulticoreFuture’ ... done
[16:12:52.133] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:52.134] getGlobalsAndPackages() ...
[16:12:52.133] List of future strategies:
[16:12:52.133] 1. sequential:
[16:12:52.133]    - args: function (..., envir = parent.frame())
[16:12:52.133]    - tweaked: FALSE
[16:12:52.133]    - call: NULL
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:52.134] Searching for globals...
[16:12:52.134] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:52.136] plan(): Setting new future strategy stack:
[16:12:52.136] List of future strategies:
[16:12:52.136] 1. multicore:
[16:12:52.136]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:52.136]    - tweaked: FALSE
[16:12:52.136]    - call: plan(strategy)
[16:12:52.145] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:52.146] plan(): nbrOfWorkers() = 2
[16:12:52.146] Searching for globals ... DONE
[16:12:52.146] Resolving globals: TRUE
[16:12:52.147] Resolving any globals that are futures ...
[16:12:52.147] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:52.147] Resolving any globals that are futures ... DONE
[16:12:52.148] Resolving futures part of globals (recursively) ...
[16:12:52.148] resolve() on list ...
[16:12:52.148]  recursive: 99
[16:12:52.149]  length: 2
[16:12:52.149]  elements: ‘a’, ‘ii’
[16:12:52.149]  length: 1 (resolved future 1)
[16:12:52.149]  length: 0 (resolved future 2)
[16:12:52.149] resolve() on list ... DONE
[16:12:52.150] - globals: [2] ‘a’, ‘ii’
[16:12:52.150] Resolving futures part of globals (recursively) ... DONE
[16:12:52.150] The total size of the 2 globals is 112 bytes (112 bytes)
[16:12:52.151] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:12:52.151] - globals: [2] ‘a’, ‘ii’
[16:12:52.151] 
[16:12:52.151] getGlobalsAndPackages() ... DONE
[16:12:52.152] run() for ‘Future’ ...
[16:12:52.152] - state: ‘created’
[16:12:52.152] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:52.157] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:52.157] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:52.158]   - Field: ‘label’
[16:12:52.158]   - Field: ‘local’
[16:12:52.158]   - Field: ‘owner’
[16:12:52.158]   - Field: ‘envir’
[16:12:52.158]   - Field: ‘workers’
[16:12:52.159]   - Field: ‘packages’
[16:12:52.159]   - Field: ‘gc’
[16:12:52.159]   - Field: ‘job’
[16:12:52.159]   - Field: ‘conditions’
[16:12:52.159]   - Field: ‘expr’
[16:12:52.160]   - Field: ‘uuid’
[16:12:52.160]   - Field: ‘seed’
[16:12:52.160]   - Field: ‘version’
[16:12:52.160]   - Field: ‘result’
[16:12:52.160]   - Field: ‘asynchronous’
[16:12:52.160]   - Field: ‘calls’
[16:12:52.160]   - Field: ‘globals’
[16:12:52.160]   - Field: ‘stdout’
[16:12:52.161]   - Field: ‘earlySignal’
[16:12:52.161]   - Field: ‘lazy’
[16:12:52.161]   - Field: ‘state’
[16:12:52.161] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:52.161] - Launch lazy future ...
[16:12:52.162] Packages needed by the future expression (n = 0): <none>
[16:12:52.162] Packages needed by future strategies (n = 0): <none>
[16:12:52.163] {
[16:12:52.163]     {
[16:12:52.163]         {
[16:12:52.163]             ...future.startTime <- base::Sys.time()
[16:12:52.163]             {
[16:12:52.163]                 {
[16:12:52.163]                   {
[16:12:52.163]                     {
[16:12:52.163]                       base::local({
[16:12:52.163]                         has_future <- base::requireNamespace("future", 
[16:12:52.163]                           quietly = TRUE)
[16:12:52.163]                         if (has_future) {
[16:12:52.163]                           ns <- base::getNamespace("future")
[16:12:52.163]                           version <- ns[[".package"]][["version"]]
[16:12:52.163]                           if (is.null(version)) 
[16:12:52.163]                             version <- utils::packageVersion("future")
[16:12:52.163]                         }
[16:12:52.163]                         else {
[16:12:52.163]                           version <- NULL
[16:12:52.163]                         }
[16:12:52.163]                         if (!has_future || version < "1.8.0") {
[16:12:52.163]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:52.163]                             "", base::R.version$version.string), 
[16:12:52.163]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:52.163]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:52.163]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:52.163]                               "release", "version")], collapse = " "), 
[16:12:52.163]                             hostname = base::Sys.info()[["nodename"]])
[16:12:52.163]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:52.163]                             info)
[16:12:52.163]                           info <- base::paste(info, collapse = "; ")
[16:12:52.163]                           if (!has_future) {
[16:12:52.163]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:52.163]                               info)
[16:12:52.163]                           }
[16:12:52.163]                           else {
[16:12:52.163]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:52.163]                               info, version)
[16:12:52.163]                           }
[16:12:52.163]                           base::stop(msg)
[16:12:52.163]                         }
[16:12:52.163]                       })
[16:12:52.163]                     }
[16:12:52.163]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:52.163]                     base::options(mc.cores = 1L)
[16:12:52.163]                   }
[16:12:52.163]                   options(future.plan = NULL)
[16:12:52.163]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.163]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:52.163]                 }
[16:12:52.163]                 ...future.workdir <- getwd()
[16:12:52.163]             }
[16:12:52.163]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:52.163]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:52.163]         }
[16:12:52.163]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:52.163]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:52.163]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:52.163]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:52.163]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:52.163]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:52.163]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:52.163]             base::names(...future.oldOptions))
[16:12:52.163]     }
[16:12:52.163]     if (FALSE) {
[16:12:52.163]     }
[16:12:52.163]     else {
[16:12:52.163]         if (TRUE) {
[16:12:52.163]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:52.163]                 open = "w")
[16:12:52.163]         }
[16:12:52.163]         else {
[16:12:52.163]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:52.163]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:52.163]         }
[16:12:52.163]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:52.163]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:52.163]             base::sink(type = "output", split = FALSE)
[16:12:52.163]             base::close(...future.stdout)
[16:12:52.163]         }, add = TRUE)
[16:12:52.163]     }
[16:12:52.163]     ...future.frame <- base::sys.nframe()
[16:12:52.163]     ...future.conditions <- base::list()
[16:12:52.163]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:52.163]     if (FALSE) {
[16:12:52.163]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:52.163]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:52.163]     }
[16:12:52.163]     ...future.result <- base::tryCatch({
[16:12:52.163]         base::withCallingHandlers({
[16:12:52.163]             ...future.value <- base::withVisible(base::local({
[16:12:52.163]                 withCallingHandlers({
[16:12:52.163]                   {
[16:12:52.163]                     b <- a * ii
[16:12:52.163]                     a <- 0
[16:12:52.163]                     b
[16:12:52.163]                   }
[16:12:52.163]                 }, immediateCondition = function(cond) {
[16:12:52.163]                   save_rds <- function (object, pathname, ...) 
[16:12:52.163]                   {
[16:12:52.163]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:52.163]                     if (file_test("-f", pathname_tmp)) {
[16:12:52.163]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.163]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:52.163]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.163]                         fi_tmp[["mtime"]])
[16:12:52.163]                     }
[16:12:52.163]                     tryCatch({
[16:12:52.163]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:52.163]                     }, error = function(ex) {
[16:12:52.163]                       msg <- conditionMessage(ex)
[16:12:52.163]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.163]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:52.163]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.163]                         fi_tmp[["mtime"]], msg)
[16:12:52.163]                       ex$message <- msg
[16:12:52.163]                       stop(ex)
[16:12:52.163]                     })
[16:12:52.163]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:52.163]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:52.163]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:52.163]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.163]                       fi <- file.info(pathname)
[16:12:52.163]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:52.163]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.163]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:52.163]                         fi[["size"]], fi[["mtime"]])
[16:12:52.163]                       stop(msg)
[16:12:52.163]                     }
[16:12:52.163]                     invisible(pathname)
[16:12:52.163]                   }
[16:12:52.163]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:52.163]                     rootPath = tempdir()) 
[16:12:52.163]                   {
[16:12:52.163]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:52.163]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:52.163]                       tmpdir = path, fileext = ".rds")
[16:12:52.163]                     save_rds(obj, file)
[16:12:52.163]                   }
[16:12:52.163]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:52.163]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.163]                   {
[16:12:52.163]                     inherits <- base::inherits
[16:12:52.163]                     invokeRestart <- base::invokeRestart
[16:12:52.163]                     is.null <- base::is.null
[16:12:52.163]                     muffled <- FALSE
[16:12:52.163]                     if (inherits(cond, "message")) {
[16:12:52.163]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:52.163]                       if (muffled) 
[16:12:52.163]                         invokeRestart("muffleMessage")
[16:12:52.163]                     }
[16:12:52.163]                     else if (inherits(cond, "warning")) {
[16:12:52.163]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:52.163]                       if (muffled) 
[16:12:52.163]                         invokeRestart("muffleWarning")
[16:12:52.163]                     }
[16:12:52.163]                     else if (inherits(cond, "condition")) {
[16:12:52.163]                       if (!is.null(pattern)) {
[16:12:52.163]                         computeRestarts <- base::computeRestarts
[16:12:52.163]                         grepl <- base::grepl
[16:12:52.163]                         restarts <- computeRestarts(cond)
[16:12:52.163]                         for (restart in restarts) {
[16:12:52.163]                           name <- restart$name
[16:12:52.163]                           if (is.null(name)) 
[16:12:52.163]                             next
[16:12:52.163]                           if (!grepl(pattern, name)) 
[16:12:52.163]                             next
[16:12:52.163]                           invokeRestart(restart)
[16:12:52.163]                           muffled <- TRUE
[16:12:52.163]                           break
[16:12:52.163]                         }
[16:12:52.163]                       }
[16:12:52.163]                     }
[16:12:52.163]                     invisible(muffled)
[16:12:52.163]                   }
[16:12:52.163]                   muffleCondition(cond)
[16:12:52.163]                 })
[16:12:52.163]             }))
[16:12:52.163]             future::FutureResult(value = ...future.value$value, 
[16:12:52.163]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.163]                   ...future.rng), globalenv = if (FALSE) 
[16:12:52.163]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:52.163]                     ...future.globalenv.names))
[16:12:52.163]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:52.163]         }, condition = base::local({
[16:12:52.163]             c <- base::c
[16:12:52.163]             inherits <- base::inherits
[16:12:52.163]             invokeRestart <- base::invokeRestart
[16:12:52.163]             length <- base::length
[16:12:52.163]             list <- base::list
[16:12:52.163]             seq.int <- base::seq.int
[16:12:52.163]             signalCondition <- base::signalCondition
[16:12:52.163]             sys.calls <- base::sys.calls
[16:12:52.163]             `[[` <- base::`[[`
[16:12:52.163]             `+` <- base::`+`
[16:12:52.163]             `<<-` <- base::`<<-`
[16:12:52.163]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:52.163]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:52.163]                   3L)]
[16:12:52.163]             }
[16:12:52.163]             function(cond) {
[16:12:52.163]                 is_error <- inherits(cond, "error")
[16:12:52.163]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:52.163]                   NULL)
[16:12:52.163]                 if (is_error) {
[16:12:52.163]                   sessionInformation <- function() {
[16:12:52.163]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:52.163]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:52.163]                       search = base::search(), system = base::Sys.info())
[16:12:52.163]                   }
[16:12:52.163]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.163]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:52.163]                     cond$call), session = sessionInformation(), 
[16:12:52.163]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:52.163]                   signalCondition(cond)
[16:12:52.163]                 }
[16:12:52.163]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:52.163]                 "immediateCondition"))) {
[16:12:52.163]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:52.163]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.163]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:52.163]                   if (TRUE && !signal) {
[16:12:52.163]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.163]                     {
[16:12:52.163]                       inherits <- base::inherits
[16:12:52.163]                       invokeRestart <- base::invokeRestart
[16:12:52.163]                       is.null <- base::is.null
[16:12:52.163]                       muffled <- FALSE
[16:12:52.163]                       if (inherits(cond, "message")) {
[16:12:52.163]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.163]                         if (muffled) 
[16:12:52.163]                           invokeRestart("muffleMessage")
[16:12:52.163]                       }
[16:12:52.163]                       else if (inherits(cond, "warning")) {
[16:12:52.163]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.163]                         if (muffled) 
[16:12:52.163]                           invokeRestart("muffleWarning")
[16:12:52.163]                       }
[16:12:52.163]                       else if (inherits(cond, "condition")) {
[16:12:52.163]                         if (!is.null(pattern)) {
[16:12:52.163]                           computeRestarts <- base::computeRestarts
[16:12:52.163]                           grepl <- base::grepl
[16:12:52.163]                           restarts <- computeRestarts(cond)
[16:12:52.163]                           for (restart in restarts) {
[16:12:52.163]                             name <- restart$name
[16:12:52.163]                             if (is.null(name)) 
[16:12:52.163]                               next
[16:12:52.163]                             if (!grepl(pattern, name)) 
[16:12:52.163]                               next
[16:12:52.163]                             invokeRestart(restart)
[16:12:52.163]                             muffled <- TRUE
[16:12:52.163]                             break
[16:12:52.163]                           }
[16:12:52.163]                         }
[16:12:52.163]                       }
[16:12:52.163]                       invisible(muffled)
[16:12:52.163]                     }
[16:12:52.163]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.163]                   }
[16:12:52.163]                 }
[16:12:52.163]                 else {
[16:12:52.163]                   if (TRUE) {
[16:12:52.163]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.163]                     {
[16:12:52.163]                       inherits <- base::inherits
[16:12:52.163]                       invokeRestart <- base::invokeRestart
[16:12:52.163]                       is.null <- base::is.null
[16:12:52.163]                       muffled <- FALSE
[16:12:52.163]                       if (inherits(cond, "message")) {
[16:12:52.163]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.163]                         if (muffled) 
[16:12:52.163]                           invokeRestart("muffleMessage")
[16:12:52.163]                       }
[16:12:52.163]                       else if (inherits(cond, "warning")) {
[16:12:52.163]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.163]                         if (muffled) 
[16:12:52.163]                           invokeRestart("muffleWarning")
[16:12:52.163]                       }
[16:12:52.163]                       else if (inherits(cond, "condition")) {
[16:12:52.163]                         if (!is.null(pattern)) {
[16:12:52.163]                           computeRestarts <- base::computeRestarts
[16:12:52.163]                           grepl <- base::grepl
[16:12:52.163]                           restarts <- computeRestarts(cond)
[16:12:52.163]                           for (restart in restarts) {
[16:12:52.163]                             name <- restart$name
[16:12:52.163]                             if (is.null(name)) 
[16:12:52.163]                               next
[16:12:52.163]                             if (!grepl(pattern, name)) 
[16:12:52.163]                               next
[16:12:52.163]                             invokeRestart(restart)
[16:12:52.163]                             muffled <- TRUE
[16:12:52.163]                             break
[16:12:52.163]                           }
[16:12:52.163]                         }
[16:12:52.163]                       }
[16:12:52.163]                       invisible(muffled)
[16:12:52.163]                     }
[16:12:52.163]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.163]                   }
[16:12:52.163]                 }
[16:12:52.163]             }
[16:12:52.163]         }))
[16:12:52.163]     }, error = function(ex) {
[16:12:52.163]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:52.163]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.163]                 ...future.rng), started = ...future.startTime, 
[16:12:52.163]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:52.163]             version = "1.8"), class = "FutureResult")
[16:12:52.163]     }, finally = {
[16:12:52.163]         if (!identical(...future.workdir, getwd())) 
[16:12:52.163]             setwd(...future.workdir)
[16:12:52.163]         {
[16:12:52.163]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:52.163]                 ...future.oldOptions$nwarnings <- NULL
[16:12:52.163]             }
[16:12:52.163]             base::options(...future.oldOptions)
[16:12:52.163]             if (.Platform$OS.type == "windows") {
[16:12:52.163]                 old_names <- names(...future.oldEnvVars)
[16:12:52.163]                 envs <- base::Sys.getenv()
[16:12:52.163]                 names <- names(envs)
[16:12:52.163]                 common <- intersect(names, old_names)
[16:12:52.163]                 added <- setdiff(names, old_names)
[16:12:52.163]                 removed <- setdiff(old_names, names)
[16:12:52.163]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:52.163]                   envs[common]]
[16:12:52.163]                 NAMES <- toupper(changed)
[16:12:52.163]                 args <- list()
[16:12:52.163]                 for (kk in seq_along(NAMES)) {
[16:12:52.163]                   name <- changed[[kk]]
[16:12:52.163]                   NAME <- NAMES[[kk]]
[16:12:52.163]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.163]                     next
[16:12:52.163]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.163]                 }
[16:12:52.163]                 NAMES <- toupper(added)
[16:12:52.163]                 for (kk in seq_along(NAMES)) {
[16:12:52.163]                   name <- added[[kk]]
[16:12:52.163]                   NAME <- NAMES[[kk]]
[16:12:52.163]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.163]                     next
[16:12:52.163]                   args[[name]] <- ""
[16:12:52.163]                 }
[16:12:52.163]                 NAMES <- toupper(removed)
[16:12:52.163]                 for (kk in seq_along(NAMES)) {
[16:12:52.163]                   name <- removed[[kk]]
[16:12:52.163]                   NAME <- NAMES[[kk]]
[16:12:52.163]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.163]                     next
[16:12:52.163]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.163]                 }
[16:12:52.163]                 if (length(args) > 0) 
[16:12:52.163]                   base::do.call(base::Sys.setenv, args = args)
[16:12:52.163]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:52.163]             }
[16:12:52.163]             else {
[16:12:52.163]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:52.163]             }
[16:12:52.163]             {
[16:12:52.163]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:52.163]                   0L) {
[16:12:52.163]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:52.163]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:52.163]                   base::options(opts)
[16:12:52.163]                 }
[16:12:52.163]                 {
[16:12:52.163]                   {
[16:12:52.163]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:52.163]                     NULL
[16:12:52.163]                   }
[16:12:52.163]                   options(future.plan = NULL)
[16:12:52.163]                   if (is.na(NA_character_)) 
[16:12:52.163]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.163]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:52.163]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:52.163]                     envir = parent.frame()) 
[16:12:52.163]                   {
[16:12:52.163]                     default_workers <- missing(workers)
[16:12:52.163]                     if (is.function(workers)) 
[16:12:52.163]                       workers <- workers()
[16:12:52.163]                     workers <- structure(as.integer(workers), 
[16:12:52.163]                       class = class(workers))
[16:12:52.163]                     stop_if_not(is.finite(workers), workers >= 
[16:12:52.163]                       1L)
[16:12:52.163]                     if ((workers == 1L && !inherits(workers, 
[16:12:52.163]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:52.163]                       if (default_workers) 
[16:12:52.163]                         supportsMulticore(warn = TRUE)
[16:12:52.163]                       return(sequential(..., envir = envir))
[16:12:52.163]                     }
[16:12:52.163]                     oopts <- options(mc.cores = workers)
[16:12:52.163]                     on.exit(options(oopts))
[16:12:52.163]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:52.163]                       envir = envir)
[16:12:52.163]                     if (!future$lazy) 
[16:12:52.163]                       future <- run(future)
[16:12:52.163]                     invisible(future)
[16:12:52.163]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:52.163]                 }
[16:12:52.163]             }
[16:12:52.163]         }
[16:12:52.163]     })
[16:12:52.163]     if (TRUE) {
[16:12:52.163]         base::sink(type = "output", split = FALSE)
[16:12:52.163]         if (TRUE) {
[16:12:52.163]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:52.163]         }
[16:12:52.163]         else {
[16:12:52.163]             ...future.result["stdout"] <- base::list(NULL)
[16:12:52.163]         }
[16:12:52.163]         base::close(...future.stdout)
[16:12:52.163]         ...future.stdout <- NULL
[16:12:52.163]     }
[16:12:52.163]     ...future.result$conditions <- ...future.conditions
[16:12:52.163]     ...future.result$finished <- base::Sys.time()
[16:12:52.163]     ...future.result
[16:12:52.163] }
[16:12:52.165] assign_globals() ...
[16:12:52.165] List of 2
[16:12:52.165]  $ a : num 1
[16:12:52.165]  $ ii: int 2
[16:12:52.165]  - attr(*, "where")=List of 2
[16:12:52.165]   ..$ a :<environment: R_EmptyEnv> 
[16:12:52.165]   ..$ ii:<environment: R_EmptyEnv> 
[16:12:52.165]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:52.165]  - attr(*, "resolved")= logi TRUE
[16:12:52.165]  - attr(*, "total_size")= num 112
[16:12:52.165]  - attr(*, "already-done")= logi TRUE
[16:12:52.170] - copied ‘a’ to environment
[16:12:52.170] - copied ‘ii’ to environment
[16:12:52.170] assign_globals() ... done
[16:12:52.170] requestCore(): workers = 2
[16:12:52.172] MulticoreFuture started
[16:12:52.173] - Launch lazy future ... done
[16:12:52.173] run() for ‘MulticoreFuture’ ... done
[16:12:52.173] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:52.174] getGlobalsAndPackages() ...
[16:12:52.174] List of future strategies:
[16:12:52.174] 1. sequential:
[16:12:52.174]    - args: function (..., envir = parent.frame())
[16:12:52.174]    - tweaked: FALSE
[16:12:52.174]    - call: NULL
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:52.174] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:52.175] plan(): nbrOfWorkers() = 1
[16:12:52.177] plan(): Setting new future strategy stack:
[16:12:52.177] List of future strategies:
[16:12:52.177] 1. multicore:
[16:12:52.177]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:52.177]    - tweaked: FALSE
[16:12:52.177]    - call: plan(strategy)
[16:12:52.178] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:52.178] Searching for globals ... DONE
[16:12:52.179] Resolving globals: TRUE
[16:12:52.179] Resolving any globals that are futures ...
[16:12:52.179] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:52.179] Resolving any globals that are futures ... DONE
[16:12:52.180] Resolving futures part of globals (recursively) ...
[16:12:52.180] resolve() on list ...
[16:12:52.180]  recursive: 99
[16:12:52.181]  length: 2
[16:12:52.181]  elements: ‘a’, ‘ii’
[16:12:52.181]  length: 1 (resolved future 1)
[16:12:52.181]  length: 0 (resolved future 2)
[16:12:52.181] resolve() on list ... DONE
[16:12:52.181] - globals: [2] ‘a’, ‘ii’
[16:12:52.182] Resolving futures part of globals (recursively) ... DONE
[16:12:52.182] plan(): nbrOfWorkers() = 2
[16:12:52.182] The total size of the 2 globals is 112 bytes (112 bytes)
[16:12:52.183] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:12:52.183] - globals: [2] ‘a’, ‘ii’
[16:12:52.183] 
[16:12:52.183] getGlobalsAndPackages() ... DONE
[16:12:52.183] run() for ‘Future’ ...
[16:12:52.184] - state: ‘created’
[16:12:52.184] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:52.188] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:52.189] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:52.189]   - Field: ‘label’
[16:12:52.189]   - Field: ‘local’
[16:12:52.189]   - Field: ‘owner’
[16:12:52.189]   - Field: ‘envir’
[16:12:52.189]   - Field: ‘workers’
[16:12:52.190]   - Field: ‘packages’
[16:12:52.190]   - Field: ‘gc’
[16:12:52.190]   - Field: ‘job’
[16:12:52.190]   - Field: ‘conditions’
[16:12:52.190]   - Field: ‘expr’
[16:12:52.190]   - Field: ‘uuid’
[16:12:52.191]   - Field: ‘seed’
[16:12:52.191]   - Field: ‘version’
[16:12:52.191]   - Field: ‘result’
[16:12:52.191]   - Field: ‘asynchronous’
[16:12:52.194]   - Field: ‘calls’
[16:12:52.194]   - Field: ‘globals’
[16:12:52.195]   - Field: ‘stdout’
[16:12:52.195]   - Field: ‘earlySignal’
[16:12:52.195]   - Field: ‘lazy’
[16:12:52.195]   - Field: ‘state’
[16:12:52.196] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:52.196] - Launch lazy future ...
[16:12:52.197] Packages needed by the future expression (n = 0): <none>
[16:12:52.197] Packages needed by future strategies (n = 0): <none>
[16:12:52.198] {
[16:12:52.198]     {
[16:12:52.198]         {
[16:12:52.198]             ...future.startTime <- base::Sys.time()
[16:12:52.198]             {
[16:12:52.198]                 {
[16:12:52.198]                   {
[16:12:52.198]                     {
[16:12:52.198]                       base::local({
[16:12:52.198]                         has_future <- base::requireNamespace("future", 
[16:12:52.198]                           quietly = TRUE)
[16:12:52.198]                         if (has_future) {
[16:12:52.198]                           ns <- base::getNamespace("future")
[16:12:52.198]                           version <- ns[[".package"]][["version"]]
[16:12:52.198]                           if (is.null(version)) 
[16:12:52.198]                             version <- utils::packageVersion("future")
[16:12:52.198]                         }
[16:12:52.198]                         else {
[16:12:52.198]                           version <- NULL
[16:12:52.198]                         }
[16:12:52.198]                         if (!has_future || version < "1.8.0") {
[16:12:52.198]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:52.198]                             "", base::R.version$version.string), 
[16:12:52.198]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:52.198]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:52.198]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:52.198]                               "release", "version")], collapse = " "), 
[16:12:52.198]                             hostname = base::Sys.info()[["nodename"]])
[16:12:52.198]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:52.198]                             info)
[16:12:52.198]                           info <- base::paste(info, collapse = "; ")
[16:12:52.198]                           if (!has_future) {
[16:12:52.198]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:52.198]                               info)
[16:12:52.198]                           }
[16:12:52.198]                           else {
[16:12:52.198]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:52.198]                               info, version)
[16:12:52.198]                           }
[16:12:52.198]                           base::stop(msg)
[16:12:52.198]                         }
[16:12:52.198]                       })
[16:12:52.198]                     }
[16:12:52.198]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:52.198]                     base::options(mc.cores = 1L)
[16:12:52.198]                   }
[16:12:52.198]                   options(future.plan = NULL)
[16:12:52.198]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.198]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:52.198]                 }
[16:12:52.198]                 ...future.workdir <- getwd()
[16:12:52.198]             }
[16:12:52.198]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:52.198]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:52.198]         }
[16:12:52.198]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:52.198]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:52.198]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:52.198]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:52.198]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:52.198]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:52.198]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:52.198]             base::names(...future.oldOptions))
[16:12:52.198]     }
[16:12:52.198]     if (FALSE) {
[16:12:52.198]     }
[16:12:52.198]     else {
[16:12:52.198]         if (TRUE) {
[16:12:52.198]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:52.198]                 open = "w")
[16:12:52.198]         }
[16:12:52.198]         else {
[16:12:52.198]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:52.198]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:52.198]         }
[16:12:52.198]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:52.198]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:52.198]             base::sink(type = "output", split = FALSE)
[16:12:52.198]             base::close(...future.stdout)
[16:12:52.198]         }, add = TRUE)
[16:12:52.198]     }
[16:12:52.198]     ...future.frame <- base::sys.nframe()
[16:12:52.198]     ...future.conditions <- base::list()
[16:12:52.198]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:52.198]     if (FALSE) {
[16:12:52.198]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:52.198]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:52.198]     }
[16:12:52.198]     ...future.result <- base::tryCatch({
[16:12:52.198]         base::withCallingHandlers({
[16:12:52.198]             ...future.value <- base::withVisible(base::local({
[16:12:52.198]                 withCallingHandlers({
[16:12:52.198]                   {
[16:12:52.198]                     b <- a * ii
[16:12:52.198]                     a <- 0
[16:12:52.198]                     b
[16:12:52.198]                   }
[16:12:52.198]                 }, immediateCondition = function(cond) {
[16:12:52.198]                   save_rds <- function (object, pathname, ...) 
[16:12:52.198]                   {
[16:12:52.198]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:52.198]                     if (file_test("-f", pathname_tmp)) {
[16:12:52.198]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.198]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:52.198]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.198]                         fi_tmp[["mtime"]])
[16:12:52.198]                     }
[16:12:52.198]                     tryCatch({
[16:12:52.198]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:52.198]                     }, error = function(ex) {
[16:12:52.198]                       msg <- conditionMessage(ex)
[16:12:52.198]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.198]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:52.198]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.198]                         fi_tmp[["mtime"]], msg)
[16:12:52.198]                       ex$message <- msg
[16:12:52.198]                       stop(ex)
[16:12:52.198]                     })
[16:12:52.198]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:52.198]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:52.198]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:52.198]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.198]                       fi <- file.info(pathname)
[16:12:52.198]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:52.198]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.198]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:52.198]                         fi[["size"]], fi[["mtime"]])
[16:12:52.198]                       stop(msg)
[16:12:52.198]                     }
[16:12:52.198]                     invisible(pathname)
[16:12:52.198]                   }
[16:12:52.198]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:52.198]                     rootPath = tempdir()) 
[16:12:52.198]                   {
[16:12:52.198]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:52.198]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:52.198]                       tmpdir = path, fileext = ".rds")
[16:12:52.198]                     save_rds(obj, file)
[16:12:52.198]                   }
[16:12:52.198]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:52.198]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.198]                   {
[16:12:52.198]                     inherits <- base::inherits
[16:12:52.198]                     invokeRestart <- base::invokeRestart
[16:12:52.198]                     is.null <- base::is.null
[16:12:52.198]                     muffled <- FALSE
[16:12:52.198]                     if (inherits(cond, "message")) {
[16:12:52.198]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:52.198]                       if (muffled) 
[16:12:52.198]                         invokeRestart("muffleMessage")
[16:12:52.198]                     }
[16:12:52.198]                     else if (inherits(cond, "warning")) {
[16:12:52.198]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:52.198]                       if (muffled) 
[16:12:52.198]                         invokeRestart("muffleWarning")
[16:12:52.198]                     }
[16:12:52.198]                     else if (inherits(cond, "condition")) {
[16:12:52.198]                       if (!is.null(pattern)) {
[16:12:52.198]                         computeRestarts <- base::computeRestarts
[16:12:52.198]                         grepl <- base::grepl
[16:12:52.198]                         restarts <- computeRestarts(cond)
[16:12:52.198]                         for (restart in restarts) {
[16:12:52.198]                           name <- restart$name
[16:12:52.198]                           if (is.null(name)) 
[16:12:52.198]                             next
[16:12:52.198]                           if (!grepl(pattern, name)) 
[16:12:52.198]                             next
[16:12:52.198]                           invokeRestart(restart)
[16:12:52.198]                           muffled <- TRUE
[16:12:52.198]                           break
[16:12:52.198]                         }
[16:12:52.198]                       }
[16:12:52.198]                     }
[16:12:52.198]                     invisible(muffled)
[16:12:52.198]                   }
[16:12:52.198]                   muffleCondition(cond)
[16:12:52.198]                 })
[16:12:52.198]             }))
[16:12:52.198]             future::FutureResult(value = ...future.value$value, 
[16:12:52.198]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.198]                   ...future.rng), globalenv = if (FALSE) 
[16:12:52.198]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:52.198]                     ...future.globalenv.names))
[16:12:52.198]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:52.198]         }, condition = base::local({
[16:12:52.198]             c <- base::c
[16:12:52.198]             inherits <- base::inherits
[16:12:52.198]             invokeRestart <- base::invokeRestart
[16:12:52.198]             length <- base::length
[16:12:52.198]             list <- base::list
[16:12:52.198]             seq.int <- base::seq.int
[16:12:52.198]             signalCondition <- base::signalCondition
[16:12:52.198]             sys.calls <- base::sys.calls
[16:12:52.198]             `[[` <- base::`[[`
[16:12:52.198]             `+` <- base::`+`
[16:12:52.198]             `<<-` <- base::`<<-`
[16:12:52.198]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:52.198]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:52.198]                   3L)]
[16:12:52.198]             }
[16:12:52.198]             function(cond) {
[16:12:52.198]                 is_error <- inherits(cond, "error")
[16:12:52.198]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:52.198]                   NULL)
[16:12:52.198]                 if (is_error) {
[16:12:52.198]                   sessionInformation <- function() {
[16:12:52.198]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:52.198]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:52.198]                       search = base::search(), system = base::Sys.info())
[16:12:52.198]                   }
[16:12:52.198]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.198]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:52.198]                     cond$call), session = sessionInformation(), 
[16:12:52.198]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:52.198]                   signalCondition(cond)
[16:12:52.198]                 }
[16:12:52.198]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:52.198]                 "immediateCondition"))) {
[16:12:52.198]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:52.198]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.198]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:52.198]                   if (TRUE && !signal) {
[16:12:52.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.198]                     {
[16:12:52.198]                       inherits <- base::inherits
[16:12:52.198]                       invokeRestart <- base::invokeRestart
[16:12:52.198]                       is.null <- base::is.null
[16:12:52.198]                       muffled <- FALSE
[16:12:52.198]                       if (inherits(cond, "message")) {
[16:12:52.198]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.198]                         if (muffled) 
[16:12:52.198]                           invokeRestart("muffleMessage")
[16:12:52.198]                       }
[16:12:52.198]                       else if (inherits(cond, "warning")) {
[16:12:52.198]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.198]                         if (muffled) 
[16:12:52.198]                           invokeRestart("muffleWarning")
[16:12:52.198]                       }
[16:12:52.198]                       else if (inherits(cond, "condition")) {
[16:12:52.198]                         if (!is.null(pattern)) {
[16:12:52.198]                           computeRestarts <- base::computeRestarts
[16:12:52.198]                           grepl <- base::grepl
[16:12:52.198]                           restarts <- computeRestarts(cond)
[16:12:52.198]                           for (restart in restarts) {
[16:12:52.198]                             name <- restart$name
[16:12:52.198]                             if (is.null(name)) 
[16:12:52.198]                               next
[16:12:52.198]                             if (!grepl(pattern, name)) 
[16:12:52.198]                               next
[16:12:52.198]                             invokeRestart(restart)
[16:12:52.198]                             muffled <- TRUE
[16:12:52.198]                             break
[16:12:52.198]                           }
[16:12:52.198]                         }
[16:12:52.198]                       }
[16:12:52.198]                       invisible(muffled)
[16:12:52.198]                     }
[16:12:52.198]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.198]                   }
[16:12:52.198]                 }
[16:12:52.198]                 else {
[16:12:52.198]                   if (TRUE) {
[16:12:52.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.198]                     {
[16:12:52.198]                       inherits <- base::inherits
[16:12:52.198]                       invokeRestart <- base::invokeRestart
[16:12:52.198]                       is.null <- base::is.null
[16:12:52.198]                       muffled <- FALSE
[16:12:52.198]                       if (inherits(cond, "message")) {
[16:12:52.198]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.198]                         if (muffled) 
[16:12:52.198]                           invokeRestart("muffleMessage")
[16:12:52.198]                       }
[16:12:52.198]                       else if (inherits(cond, "warning")) {
[16:12:52.198]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.198]                         if (muffled) 
[16:12:52.198]                           invokeRestart("muffleWarning")
[16:12:52.198]                       }
[16:12:52.198]                       else if (inherits(cond, "condition")) {
[16:12:52.198]                         if (!is.null(pattern)) {
[16:12:52.198]                           computeRestarts <- base::computeRestarts
[16:12:52.198]                           grepl <- base::grepl
[16:12:52.198]                           restarts <- computeRestarts(cond)
[16:12:52.198]                           for (restart in restarts) {
[16:12:52.198]                             name <- restart$name
[16:12:52.198]                             if (is.null(name)) 
[16:12:52.198]                               next
[16:12:52.198]                             if (!grepl(pattern, name)) 
[16:12:52.198]                               next
[16:12:52.198]                             invokeRestart(restart)
[16:12:52.198]                             muffled <- TRUE
[16:12:52.198]                             break
[16:12:52.198]                           }
[16:12:52.198]                         }
[16:12:52.198]                       }
[16:12:52.198]                       invisible(muffled)
[16:12:52.198]                     }
[16:12:52.198]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.198]                   }
[16:12:52.198]                 }
[16:12:52.198]             }
[16:12:52.198]         }))
[16:12:52.198]     }, error = function(ex) {
[16:12:52.198]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:52.198]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.198]                 ...future.rng), started = ...future.startTime, 
[16:12:52.198]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:52.198]             version = "1.8"), class = "FutureResult")
[16:12:52.198]     }, finally = {
[16:12:52.198]         if (!identical(...future.workdir, getwd())) 
[16:12:52.198]             setwd(...future.workdir)
[16:12:52.198]         {
[16:12:52.198]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:52.198]                 ...future.oldOptions$nwarnings <- NULL
[16:12:52.198]             }
[16:12:52.198]             base::options(...future.oldOptions)
[16:12:52.198]             if (.Platform$OS.type == "windows") {
[16:12:52.198]                 old_names <- names(...future.oldEnvVars)
[16:12:52.198]                 envs <- base::Sys.getenv()
[16:12:52.198]                 names <- names(envs)
[16:12:52.198]                 common <- intersect(names, old_names)
[16:12:52.198]                 added <- setdiff(names, old_names)
[16:12:52.198]                 removed <- setdiff(old_names, names)
[16:12:52.198]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:52.198]                   envs[common]]
[16:12:52.198]                 NAMES <- toupper(changed)
[16:12:52.198]                 args <- list()
[16:12:52.198]                 for (kk in seq_along(NAMES)) {
[16:12:52.198]                   name <- changed[[kk]]
[16:12:52.198]                   NAME <- NAMES[[kk]]
[16:12:52.198]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.198]                     next
[16:12:52.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.198]                 }
[16:12:52.198]                 NAMES <- toupper(added)
[16:12:52.198]                 for (kk in seq_along(NAMES)) {
[16:12:52.198]                   name <- added[[kk]]
[16:12:52.198]                   NAME <- NAMES[[kk]]
[16:12:52.198]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.198]                     next
[16:12:52.198]                   args[[name]] <- ""
[16:12:52.198]                 }
[16:12:52.198]                 NAMES <- toupper(removed)
[16:12:52.198]                 for (kk in seq_along(NAMES)) {
[16:12:52.198]                   name <- removed[[kk]]
[16:12:52.198]                   NAME <- NAMES[[kk]]
[16:12:52.198]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.198]                     next
[16:12:52.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.198]                 }
[16:12:52.198]                 if (length(args) > 0) 
[16:12:52.198]                   base::do.call(base::Sys.setenv, args = args)
[16:12:52.198]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:52.198]             }
[16:12:52.198]             else {
[16:12:52.198]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:52.198]             }
[16:12:52.198]             {
[16:12:52.198]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:52.198]                   0L) {
[16:12:52.198]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:52.198]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:52.198]                   base::options(opts)
[16:12:52.198]                 }
[16:12:52.198]                 {
[16:12:52.198]                   {
[16:12:52.198]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:52.198]                     NULL
[16:12:52.198]                   }
[16:12:52.198]                   options(future.plan = NULL)
[16:12:52.198]                   if (is.na(NA_character_)) 
[16:12:52.198]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.198]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:52.198]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:52.198]                     envir = parent.frame()) 
[16:12:52.198]                   {
[16:12:52.198]                     default_workers <- missing(workers)
[16:12:52.198]                     if (is.function(workers)) 
[16:12:52.198]                       workers <- workers()
[16:12:52.198]                     workers <- structure(as.integer(workers), 
[16:12:52.198]                       class = class(workers))
[16:12:52.198]                     stop_if_not(is.finite(workers), workers >= 
[16:12:52.198]                       1L)
[16:12:52.198]                     if ((workers == 1L && !inherits(workers, 
[16:12:52.198]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:52.198]                       if (default_workers) 
[16:12:52.198]                         supportsMulticore(warn = TRUE)
[16:12:52.198]                       return(sequential(..., envir = envir))
[16:12:52.198]                     }
[16:12:52.198]                     oopts <- options(mc.cores = workers)
[16:12:52.198]                     on.exit(options(oopts))
[16:12:52.198]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:52.198]                       envir = envir)
[16:12:52.198]                     if (!future$lazy) 
[16:12:52.198]                       future <- run(future)
[16:12:52.198]                     invisible(future)
[16:12:52.198]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:52.198]                 }
[16:12:52.198]             }
[16:12:52.198]         }
[16:12:52.198]     })
[16:12:52.198]     if (TRUE) {
[16:12:52.198]         base::sink(type = "output", split = FALSE)
[16:12:52.198]         if (TRUE) {
[16:12:52.198]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:52.198]         }
[16:12:52.198]         else {
[16:12:52.198]             ...future.result["stdout"] <- base::list(NULL)
[16:12:52.198]         }
[16:12:52.198]         base::close(...future.stdout)
[16:12:52.198]         ...future.stdout <- NULL
[16:12:52.198]     }
[16:12:52.198]     ...future.result$conditions <- ...future.conditions
[16:12:52.198]     ...future.result$finished <- base::Sys.time()
[16:12:52.198]     ...future.result
[16:12:52.198] }
[16:12:52.200] assign_globals() ...
[16:12:52.201] List of 2
[16:12:52.201]  $ a : num 1
[16:12:52.201]  $ ii: int 3
[16:12:52.201]  - attr(*, "where")=List of 2
[16:12:52.201]   ..$ a :<environment: R_EmptyEnv> 
[16:12:52.201]   ..$ ii:<environment: R_EmptyEnv> 
[16:12:52.201]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:52.201]  - attr(*, "resolved")= logi TRUE
[16:12:52.201]  - attr(*, "total_size")= num 112
[16:12:52.201]  - attr(*, "already-done")= logi TRUE
[16:12:52.205] - copied ‘a’ to environment
[16:12:52.206] - copied ‘ii’ to environment
[16:12:52.206] assign_globals() ... done
[16:12:52.206] requestCore(): workers = 2
[16:12:52.206] Poll #1 (0): usedCores() = 2, workers = 2
[16:12:52.231] MulticoreFuture started
[16:12:52.231] - Launch lazy future ... done
[16:12:52.231] run() for ‘MulticoreFuture’ ... done
[16:12:52.232] plan(): Setting new future strategy stack:
[16:12:52.232] List of future strategies:
[16:12:52.232] 1. sequential:
[16:12:52.232]    - args: function (..., envir = parent.frame())
[16:12:52.232]    - tweaked: FALSE
[16:12:52.232]    - call: NULL
[16:12:52.234] plan(): nbrOfWorkers() = 1
[16:12:52.236] plan(): Setting new future strategy stack:
[16:12:52.236] List of future strategies:
[16:12:52.236] 1. multicore:
[16:12:52.236]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:52.236]    - tweaked: FALSE
[16:12:52.236]    - call: plan(strategy)
[16:12:52.242] plan(): nbrOfWorkers() = 2
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:52.243] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:52.244] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:52.247] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:52.247] Searching for globals ... DONE
[16:12:52.247] Resolving globals: TRUE
[16:12:52.247] Resolving any globals that are futures ...
[16:12:52.247] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:52.247] Resolving any globals that are futures ... DONE
[16:12:52.248] Resolving futures part of globals (recursively) ...
[16:12:52.248] resolve() on list ...
[16:12:52.248]  recursive: 99
[16:12:52.248]  length: 2
[16:12:52.249]  elements: ‘a’, ‘ii’
[16:12:52.249]  length: 1 (resolved future 1)
[16:12:52.252]  length: 0 (resolved future 2)
[16:12:52.252] resolve() on list ... DONE
[16:12:52.252] - globals: [2] ‘a’, ‘ii’
[16:12:52.252] Resolving futures part of globals (recursively) ... DONE
[16:12:52.252] The total size of the 2 globals is 112 bytes (112 bytes)
[16:12:52.253] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:12:52.253] - globals: [2] ‘a’, ‘ii’
[16:12:52.253] 
[16:12:52.254] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:52.255] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:52.255] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:52.257] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:52.257] Searching for globals ... DONE
[16:12:52.258] Resolving globals: TRUE
[16:12:52.258] Resolving any globals that are futures ...
[16:12:52.258] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:52.258] Resolving any globals that are futures ... DONE
[16:12:52.258] Resolving futures part of globals (recursively) ...
[16:12:52.259] resolve() on list ...
[16:12:52.259]  recursive: 99
[16:12:52.259]  length: 2
[16:12:52.259]  elements: ‘a’, ‘ii’
[16:12:52.259]  length: 1 (resolved future 1)
[16:12:52.260]  length: 0 (resolved future 2)
[16:12:52.260] resolve() on list ... DONE
[16:12:52.260] - globals: [2] ‘a’, ‘ii’
[16:12:52.260] Resolving futures part of globals (recursively) ... DONE
[16:12:52.260] The total size of the 2 globals is 112 bytes (112 bytes)
[16:12:52.261] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:12:52.261] - globals: [2] ‘a’, ‘ii’
[16:12:52.261] 
[16:12:52.261] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:52.262] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:52.262] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:52.264] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:52.264] Searching for globals ... DONE
[16:12:52.264] Resolving globals: TRUE
[16:12:52.265] Resolving any globals that are futures ...
[16:12:52.265] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:52.265] Resolving any globals that are futures ... DONE
[16:12:52.265] Resolving futures part of globals (recursively) ...
[16:12:52.265] resolve() on list ...
[16:12:52.265]  recursive: 99
[16:12:52.266]  length: 2
[16:12:52.266]  elements: ‘a’, ‘ii’
[16:12:52.266]  length: 1 (resolved future 1)
[16:12:52.266]  length: 0 (resolved future 2)
[16:12:52.266] resolve() on list ... DONE
[16:12:52.266] - globals: [2] ‘a’, ‘ii’
[16:12:52.266] Resolving futures part of globals (recursively) ... DONE
[16:12:52.266] The total size of the 2 globals is 112 bytes (112 bytes)
[16:12:52.267] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:12:52.267] - globals: [2] ‘a’, ‘ii’
[16:12:52.267] 
[16:12:52.267] getGlobalsAndPackages() ... DONE
[16:12:52.268] run() for ‘Future’ ...
[16:12:52.268] - state: ‘created’
[16:12:52.268] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:52.272] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:52.272] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:52.272]   - Field: ‘label’
[16:12:52.272]   - Field: ‘local’
[16:12:52.272]   - Field: ‘owner’
[16:12:52.272]   - Field: ‘envir’
[16:12:52.272]   - Field: ‘workers’
[16:12:52.272]   - Field: ‘packages’
[16:12:52.273]   - Field: ‘gc’
[16:12:52.273]   - Field: ‘job’
[16:12:52.273]   - Field: ‘conditions’
[16:12:52.273]   - Field: ‘expr’
[16:12:52.273]   - Field: ‘uuid’
[16:12:52.273]   - Field: ‘seed’
[16:12:52.273]   - Field: ‘version’
[16:12:52.273]   - Field: ‘result’
[16:12:52.273]   - Field: ‘asynchronous’
[16:12:52.274]   - Field: ‘calls’
[16:12:52.274]   - Field: ‘globals’
[16:12:52.274]   - Field: ‘stdout’
[16:12:52.274]   - Field: ‘earlySignal’
[16:12:52.274]   - Field: ‘lazy’
[16:12:52.274]   - Field: ‘state’
[16:12:52.274] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:52.274] - Launch lazy future ...
[16:12:52.275] Packages needed by the future expression (n = 0): <none>
[16:12:52.275] Packages needed by future strategies (n = 0): <none>
[16:12:52.275] {
[16:12:52.275]     {
[16:12:52.275]         {
[16:12:52.275]             ...future.startTime <- base::Sys.time()
[16:12:52.275]             {
[16:12:52.275]                 {
[16:12:52.275]                   {
[16:12:52.275]                     {
[16:12:52.275]                       base::local({
[16:12:52.275]                         has_future <- base::requireNamespace("future", 
[16:12:52.275]                           quietly = TRUE)
[16:12:52.275]                         if (has_future) {
[16:12:52.275]                           ns <- base::getNamespace("future")
[16:12:52.275]                           version <- ns[[".package"]][["version"]]
[16:12:52.275]                           if (is.null(version)) 
[16:12:52.275]                             version <- utils::packageVersion("future")
[16:12:52.275]                         }
[16:12:52.275]                         else {
[16:12:52.275]                           version <- NULL
[16:12:52.275]                         }
[16:12:52.275]                         if (!has_future || version < "1.8.0") {
[16:12:52.275]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:52.275]                             "", base::R.version$version.string), 
[16:12:52.275]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:52.275]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:52.275]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:52.275]                               "release", "version")], collapse = " "), 
[16:12:52.275]                             hostname = base::Sys.info()[["nodename"]])
[16:12:52.275]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:52.275]                             info)
[16:12:52.275]                           info <- base::paste(info, collapse = "; ")
[16:12:52.275]                           if (!has_future) {
[16:12:52.275]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:52.275]                               info)
[16:12:52.275]                           }
[16:12:52.275]                           else {
[16:12:52.275]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:52.275]                               info, version)
[16:12:52.275]                           }
[16:12:52.275]                           base::stop(msg)
[16:12:52.275]                         }
[16:12:52.275]                       })
[16:12:52.275]                     }
[16:12:52.275]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:52.275]                     base::options(mc.cores = 1L)
[16:12:52.275]                   }
[16:12:52.275]                   options(future.plan = NULL)
[16:12:52.275]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.275]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:52.275]                 }
[16:12:52.275]                 ...future.workdir <- getwd()
[16:12:52.275]             }
[16:12:52.275]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:52.275]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:52.275]         }
[16:12:52.275]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:52.275]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:52.275]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:52.275]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:52.275]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:52.275]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:52.275]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:52.275]             base::names(...future.oldOptions))
[16:12:52.275]     }
[16:12:52.275]     if (FALSE) {
[16:12:52.275]     }
[16:12:52.275]     else {
[16:12:52.275]         if (TRUE) {
[16:12:52.275]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:52.275]                 open = "w")
[16:12:52.275]         }
[16:12:52.275]         else {
[16:12:52.275]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:52.275]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:52.275]         }
[16:12:52.275]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:52.275]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:52.275]             base::sink(type = "output", split = FALSE)
[16:12:52.275]             base::close(...future.stdout)
[16:12:52.275]         }, add = TRUE)
[16:12:52.275]     }
[16:12:52.275]     ...future.frame <- base::sys.nframe()
[16:12:52.275]     ...future.conditions <- base::list()
[16:12:52.275]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:52.275]     if (FALSE) {
[16:12:52.275]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:52.275]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:52.275]     }
[16:12:52.275]     ...future.result <- base::tryCatch({
[16:12:52.275]         base::withCallingHandlers({
[16:12:52.275]             ...future.value <- base::withVisible(base::local({
[16:12:52.275]                 withCallingHandlers({
[16:12:52.275]                   {
[16:12:52.275]                     b <- a * ii
[16:12:52.275]                     a <- 0
[16:12:52.275]                     b
[16:12:52.275]                   }
[16:12:52.275]                 }, immediateCondition = function(cond) {
[16:12:52.275]                   save_rds <- function (object, pathname, ...) 
[16:12:52.275]                   {
[16:12:52.275]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:52.275]                     if (file_test("-f", pathname_tmp)) {
[16:12:52.275]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.275]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:52.275]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.275]                         fi_tmp[["mtime"]])
[16:12:52.275]                     }
[16:12:52.275]                     tryCatch({
[16:12:52.275]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:52.275]                     }, error = function(ex) {
[16:12:52.275]                       msg <- conditionMessage(ex)
[16:12:52.275]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.275]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:52.275]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.275]                         fi_tmp[["mtime"]], msg)
[16:12:52.275]                       ex$message <- msg
[16:12:52.275]                       stop(ex)
[16:12:52.275]                     })
[16:12:52.275]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:52.275]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:52.275]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:52.275]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.275]                       fi <- file.info(pathname)
[16:12:52.275]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:52.275]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.275]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:52.275]                         fi[["size"]], fi[["mtime"]])
[16:12:52.275]                       stop(msg)
[16:12:52.275]                     }
[16:12:52.275]                     invisible(pathname)
[16:12:52.275]                   }
[16:12:52.275]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:52.275]                     rootPath = tempdir()) 
[16:12:52.275]                   {
[16:12:52.275]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:52.275]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:52.275]                       tmpdir = path, fileext = ".rds")
[16:12:52.275]                     save_rds(obj, file)
[16:12:52.275]                   }
[16:12:52.275]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:52.275]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.275]                   {
[16:12:52.275]                     inherits <- base::inherits
[16:12:52.275]                     invokeRestart <- base::invokeRestart
[16:12:52.275]                     is.null <- base::is.null
[16:12:52.275]                     muffled <- FALSE
[16:12:52.275]                     if (inherits(cond, "message")) {
[16:12:52.275]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:52.275]                       if (muffled) 
[16:12:52.275]                         invokeRestart("muffleMessage")
[16:12:52.275]                     }
[16:12:52.275]                     else if (inherits(cond, "warning")) {
[16:12:52.275]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:52.275]                       if (muffled) 
[16:12:52.275]                         invokeRestart("muffleWarning")
[16:12:52.275]                     }
[16:12:52.275]                     else if (inherits(cond, "condition")) {
[16:12:52.275]                       if (!is.null(pattern)) {
[16:12:52.275]                         computeRestarts <- base::computeRestarts
[16:12:52.275]                         grepl <- base::grepl
[16:12:52.275]                         restarts <- computeRestarts(cond)
[16:12:52.275]                         for (restart in restarts) {
[16:12:52.275]                           name <- restart$name
[16:12:52.275]                           if (is.null(name)) 
[16:12:52.275]                             next
[16:12:52.275]                           if (!grepl(pattern, name)) 
[16:12:52.275]                             next
[16:12:52.275]                           invokeRestart(restart)
[16:12:52.275]                           muffled <- TRUE
[16:12:52.275]                           break
[16:12:52.275]                         }
[16:12:52.275]                       }
[16:12:52.275]                     }
[16:12:52.275]                     invisible(muffled)
[16:12:52.275]                   }
[16:12:52.275]                   muffleCondition(cond)
[16:12:52.275]                 })
[16:12:52.275]             }))
[16:12:52.275]             future::FutureResult(value = ...future.value$value, 
[16:12:52.275]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.275]                   ...future.rng), globalenv = if (FALSE) 
[16:12:52.275]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:52.275]                     ...future.globalenv.names))
[16:12:52.275]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:52.275]         }, condition = base::local({
[16:12:52.275]             c <- base::c
[16:12:52.275]             inherits <- base::inherits
[16:12:52.275]             invokeRestart <- base::invokeRestart
[16:12:52.275]             length <- base::length
[16:12:52.275]             list <- base::list
[16:12:52.275]             seq.int <- base::seq.int
[16:12:52.275]             signalCondition <- base::signalCondition
[16:12:52.275]             sys.calls <- base::sys.calls
[16:12:52.275]             `[[` <- base::`[[`
[16:12:52.275]             `+` <- base::`+`
[16:12:52.275]             `<<-` <- base::`<<-`
[16:12:52.275]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:52.275]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:52.275]                   3L)]
[16:12:52.275]             }
[16:12:52.275]             function(cond) {
[16:12:52.275]                 is_error <- inherits(cond, "error")
[16:12:52.275]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:52.275]                   NULL)
[16:12:52.275]                 if (is_error) {
[16:12:52.275]                   sessionInformation <- function() {
[16:12:52.275]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:52.275]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:52.275]                       search = base::search(), system = base::Sys.info())
[16:12:52.275]                   }
[16:12:52.275]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.275]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:52.275]                     cond$call), session = sessionInformation(), 
[16:12:52.275]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:52.275]                   signalCondition(cond)
[16:12:52.275]                 }
[16:12:52.275]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:52.275]                 "immediateCondition"))) {
[16:12:52.275]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:52.275]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.275]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:52.275]                   if (TRUE && !signal) {
[16:12:52.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.275]                     {
[16:12:52.275]                       inherits <- base::inherits
[16:12:52.275]                       invokeRestart <- base::invokeRestart
[16:12:52.275]                       is.null <- base::is.null
[16:12:52.275]                       muffled <- FALSE
[16:12:52.275]                       if (inherits(cond, "message")) {
[16:12:52.275]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.275]                         if (muffled) 
[16:12:52.275]                           invokeRestart("muffleMessage")
[16:12:52.275]                       }
[16:12:52.275]                       else if (inherits(cond, "warning")) {
[16:12:52.275]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.275]                         if (muffled) 
[16:12:52.275]                           invokeRestart("muffleWarning")
[16:12:52.275]                       }
[16:12:52.275]                       else if (inherits(cond, "condition")) {
[16:12:52.275]                         if (!is.null(pattern)) {
[16:12:52.275]                           computeRestarts <- base::computeRestarts
[16:12:52.275]                           grepl <- base::grepl
[16:12:52.275]                           restarts <- computeRestarts(cond)
[16:12:52.275]                           for (restart in restarts) {
[16:12:52.275]                             name <- restart$name
[16:12:52.275]                             if (is.null(name)) 
[16:12:52.275]                               next
[16:12:52.275]                             if (!grepl(pattern, name)) 
[16:12:52.275]                               next
[16:12:52.275]                             invokeRestart(restart)
[16:12:52.275]                             muffled <- TRUE
[16:12:52.275]                             break
[16:12:52.275]                           }
[16:12:52.275]                         }
[16:12:52.275]                       }
[16:12:52.275]                       invisible(muffled)
[16:12:52.275]                     }
[16:12:52.275]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.275]                   }
[16:12:52.275]                 }
[16:12:52.275]                 else {
[16:12:52.275]                   if (TRUE) {
[16:12:52.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.275]                     {
[16:12:52.275]                       inherits <- base::inherits
[16:12:52.275]                       invokeRestart <- base::invokeRestart
[16:12:52.275]                       is.null <- base::is.null
[16:12:52.275]                       muffled <- FALSE
[16:12:52.275]                       if (inherits(cond, "message")) {
[16:12:52.275]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.275]                         if (muffled) 
[16:12:52.275]                           invokeRestart("muffleMessage")
[16:12:52.275]                       }
[16:12:52.275]                       else if (inherits(cond, "warning")) {
[16:12:52.275]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.275]                         if (muffled) 
[16:12:52.275]                           invokeRestart("muffleWarning")
[16:12:52.275]                       }
[16:12:52.275]                       else if (inherits(cond, "condition")) {
[16:12:52.275]                         if (!is.null(pattern)) {
[16:12:52.275]                           computeRestarts <- base::computeRestarts
[16:12:52.275]                           grepl <- base::grepl
[16:12:52.275]                           restarts <- computeRestarts(cond)
[16:12:52.275]                           for (restart in restarts) {
[16:12:52.275]                             name <- restart$name
[16:12:52.275]                             if (is.null(name)) 
[16:12:52.275]                               next
[16:12:52.275]                             if (!grepl(pattern, name)) 
[16:12:52.275]                               next
[16:12:52.275]                             invokeRestart(restart)
[16:12:52.275]                             muffled <- TRUE
[16:12:52.275]                             break
[16:12:52.275]                           }
[16:12:52.275]                         }
[16:12:52.275]                       }
[16:12:52.275]                       invisible(muffled)
[16:12:52.275]                     }
[16:12:52.275]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.275]                   }
[16:12:52.275]                 }
[16:12:52.275]             }
[16:12:52.275]         }))
[16:12:52.275]     }, error = function(ex) {
[16:12:52.275]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:52.275]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.275]                 ...future.rng), started = ...future.startTime, 
[16:12:52.275]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:52.275]             version = "1.8"), class = "FutureResult")
[16:12:52.275]     }, finally = {
[16:12:52.275]         if (!identical(...future.workdir, getwd())) 
[16:12:52.275]             setwd(...future.workdir)
[16:12:52.275]         {
[16:12:52.275]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:52.275]                 ...future.oldOptions$nwarnings <- NULL
[16:12:52.275]             }
[16:12:52.275]             base::options(...future.oldOptions)
[16:12:52.275]             if (.Platform$OS.type == "windows") {
[16:12:52.275]                 old_names <- names(...future.oldEnvVars)
[16:12:52.275]                 envs <- base::Sys.getenv()
[16:12:52.275]                 names <- names(envs)
[16:12:52.275]                 common <- intersect(names, old_names)
[16:12:52.275]                 added <- setdiff(names, old_names)
[16:12:52.275]                 removed <- setdiff(old_names, names)
[16:12:52.275]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:52.275]                   envs[common]]
[16:12:52.275]                 NAMES <- toupper(changed)
[16:12:52.275]                 args <- list()
[16:12:52.275]                 for (kk in seq_along(NAMES)) {
[16:12:52.275]                   name <- changed[[kk]]
[16:12:52.275]                   NAME <- NAMES[[kk]]
[16:12:52.275]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.275]                     next
[16:12:52.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.275]                 }
[16:12:52.275]                 NAMES <- toupper(added)
[16:12:52.275]                 for (kk in seq_along(NAMES)) {
[16:12:52.275]                   name <- added[[kk]]
[16:12:52.275]                   NAME <- NAMES[[kk]]
[16:12:52.275]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.275]                     next
[16:12:52.275]                   args[[name]] <- ""
[16:12:52.275]                 }
[16:12:52.275]                 NAMES <- toupper(removed)
[16:12:52.275]                 for (kk in seq_along(NAMES)) {
[16:12:52.275]                   name <- removed[[kk]]
[16:12:52.275]                   NAME <- NAMES[[kk]]
[16:12:52.275]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.275]                     next
[16:12:52.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.275]                 }
[16:12:52.275]                 if (length(args) > 0) 
[16:12:52.275]                   base::do.call(base::Sys.setenv, args = args)
[16:12:52.275]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:52.275]             }
[16:12:52.275]             else {
[16:12:52.275]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:52.275]             }
[16:12:52.275]             {
[16:12:52.275]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:52.275]                   0L) {
[16:12:52.275]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:52.275]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:52.275]                   base::options(opts)
[16:12:52.275]                 }
[16:12:52.275]                 {
[16:12:52.275]                   {
[16:12:52.275]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:52.275]                     NULL
[16:12:52.275]                   }
[16:12:52.275]                   options(future.plan = NULL)
[16:12:52.275]                   if (is.na(NA_character_)) 
[16:12:52.275]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.275]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:52.275]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:52.275]                     envir = parent.frame()) 
[16:12:52.275]                   {
[16:12:52.275]                     default_workers <- missing(workers)
[16:12:52.275]                     if (is.function(workers)) 
[16:12:52.275]                       workers <- workers()
[16:12:52.275]                     workers <- structure(as.integer(workers), 
[16:12:52.275]                       class = class(workers))
[16:12:52.275]                     stop_if_not(is.finite(workers), workers >= 
[16:12:52.275]                       1L)
[16:12:52.275]                     if ((workers == 1L && !inherits(workers, 
[16:12:52.275]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:52.275]                       if (default_workers) 
[16:12:52.275]                         supportsMulticore(warn = TRUE)
[16:12:52.275]                       return(sequential(..., envir = envir))
[16:12:52.275]                     }
[16:12:52.275]                     oopts <- options(mc.cores = workers)
[16:12:52.275]                     on.exit(options(oopts))
[16:12:52.275]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:52.275]                       envir = envir)
[16:12:52.275]                     if (!future$lazy) 
[16:12:52.275]                       future <- run(future)
[16:12:52.275]                     invisible(future)
[16:12:52.275]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:52.275]                 }
[16:12:52.275]             }
[16:12:52.275]         }
[16:12:52.275]     })
[16:12:52.275]     if (TRUE) {
[16:12:52.275]         base::sink(type = "output", split = FALSE)
[16:12:52.275]         if (TRUE) {
[16:12:52.275]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:52.275]         }
[16:12:52.275]         else {
[16:12:52.275]             ...future.result["stdout"] <- base::list(NULL)
[16:12:52.275]         }
[16:12:52.275]         base::close(...future.stdout)
[16:12:52.275]         ...future.stdout <- NULL
[16:12:52.275]     }
[16:12:52.275]     ...future.result$conditions <- ...future.conditions
[16:12:52.275]     ...future.result$finished <- base::Sys.time()
[16:12:52.275]     ...future.result
[16:12:52.275] }
[16:12:52.278] assign_globals() ...
[16:12:52.278] List of 2
[16:12:52.278]  $ a : num 1
[16:12:52.278]  $ ii: int 1
[16:12:52.278]  - attr(*, "where")=List of 2
[16:12:52.278]   ..$ a :<environment: R_EmptyEnv> 
[16:12:52.278]   ..$ ii:<environment: R_EmptyEnv> 
[16:12:52.278]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:52.278]  - attr(*, "resolved")= logi TRUE
[16:12:52.278]  - attr(*, "total_size")= num 112
[16:12:52.278]  - attr(*, "already-done")= logi TRUE
[16:12:52.281] - copied ‘a’ to environment
[16:12:52.281] - copied ‘ii’ to environment
[16:12:52.281] assign_globals() ... done
[16:12:52.281] requestCore(): workers = 2
[16:12:52.283] MulticoreFuture started
[16:12:52.284] - Launch lazy future ... done
[16:12:52.284] run() for ‘MulticoreFuture’ ... done
[16:12:52.285] plan(): Setting new future strategy stack:
[16:12:52.285] List of future strategies:
[16:12:52.285] 1. sequential:
[16:12:52.285]    - args: function (..., envir = parent.frame())
[16:12:52.285]    - tweaked: FALSE
[16:12:52.285]    - call: NULL
[16:12:52.291] plan(): nbrOfWorkers() = 1
[16:12:52.294] plan(): Setting new future strategy stack:
[16:12:52.294] List of future strategies:
[16:12:52.294] 1. multicore:
[16:12:52.294]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:52.294]    - tweaked: FALSE
[16:12:52.294]    - call: plan(strategy)
[16:12:52.300] plan(): nbrOfWorkers() = 2
[16:12:52.304] run() for ‘Future’ ...
[16:12:52.304] - state: ‘created’
[16:12:52.304] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:52.309] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:52.309] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:52.309]   - Field: ‘label’
[16:12:52.309]   - Field: ‘local’
[16:12:52.310]   - Field: ‘owner’
[16:12:52.310]   - Field: ‘envir’
[16:12:52.310]   - Field: ‘workers’
[16:12:52.310]   - Field: ‘packages’
[16:12:52.310]   - Field: ‘gc’
[16:12:52.310]   - Field: ‘job’
[16:12:52.310]   - Field: ‘conditions’
[16:12:52.311]   - Field: ‘expr’
[16:12:52.311]   - Field: ‘uuid’
[16:12:52.311]   - Field: ‘seed’
[16:12:52.311]   - Field: ‘version’
[16:12:52.311]   - Field: ‘result’
[16:12:52.311]   - Field: ‘asynchronous’
[16:12:52.312]   - Field: ‘calls’
[16:12:52.312]   - Field: ‘globals’
[16:12:52.312]   - Field: ‘stdout’
[16:12:52.312]   - Field: ‘earlySignal’
[16:12:52.312]   - Field: ‘lazy’
[16:12:52.312]   - Field: ‘state’
[16:12:52.312] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:52.313] - Launch lazy future ...
[16:12:52.313] Packages needed by the future expression (n = 0): <none>
[16:12:52.313] Packages needed by future strategies (n = 0): <none>
[16:12:52.314] {
[16:12:52.314]     {
[16:12:52.314]         {
[16:12:52.314]             ...future.startTime <- base::Sys.time()
[16:12:52.314]             {
[16:12:52.314]                 {
[16:12:52.314]                   {
[16:12:52.314]                     {
[16:12:52.314]                       base::local({
[16:12:52.314]                         has_future <- base::requireNamespace("future", 
[16:12:52.314]                           quietly = TRUE)
[16:12:52.314]                         if (has_future) {
[16:12:52.314]                           ns <- base::getNamespace("future")
[16:12:52.314]                           version <- ns[[".package"]][["version"]]
[16:12:52.314]                           if (is.null(version)) 
[16:12:52.314]                             version <- utils::packageVersion("future")
[16:12:52.314]                         }
[16:12:52.314]                         else {
[16:12:52.314]                           version <- NULL
[16:12:52.314]                         }
[16:12:52.314]                         if (!has_future || version < "1.8.0") {
[16:12:52.314]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:52.314]                             "", base::R.version$version.string), 
[16:12:52.314]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:52.314]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:52.314]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:52.314]                               "release", "version")], collapse = " "), 
[16:12:52.314]                             hostname = base::Sys.info()[["nodename"]])
[16:12:52.314]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:52.314]                             info)
[16:12:52.314]                           info <- base::paste(info, collapse = "; ")
[16:12:52.314]                           if (!has_future) {
[16:12:52.314]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:52.314]                               info)
[16:12:52.314]                           }
[16:12:52.314]                           else {
[16:12:52.314]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:52.314]                               info, version)
[16:12:52.314]                           }
[16:12:52.314]                           base::stop(msg)
[16:12:52.314]                         }
[16:12:52.314]                       })
[16:12:52.314]                     }
[16:12:52.314]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:52.314]                     base::options(mc.cores = 1L)
[16:12:52.314]                   }
[16:12:52.314]                   options(future.plan = NULL)
[16:12:52.314]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.314]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:52.314]                 }
[16:12:52.314]                 ...future.workdir <- getwd()
[16:12:52.314]             }
[16:12:52.314]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:52.314]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:52.314]         }
[16:12:52.314]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:52.314]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:52.314]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:52.314]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:52.314]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:52.314]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:52.314]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:52.314]             base::names(...future.oldOptions))
[16:12:52.314]     }
[16:12:52.314]     if (FALSE) {
[16:12:52.314]     }
[16:12:52.314]     else {
[16:12:52.314]         if (TRUE) {
[16:12:52.314]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:52.314]                 open = "w")
[16:12:52.314]         }
[16:12:52.314]         else {
[16:12:52.314]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:52.314]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:52.314]         }
[16:12:52.314]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:52.314]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:52.314]             base::sink(type = "output", split = FALSE)
[16:12:52.314]             base::close(...future.stdout)
[16:12:52.314]         }, add = TRUE)
[16:12:52.314]     }
[16:12:52.314]     ...future.frame <- base::sys.nframe()
[16:12:52.314]     ...future.conditions <- base::list()
[16:12:52.314]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:52.314]     if (FALSE) {
[16:12:52.314]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:52.314]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:52.314]     }
[16:12:52.314]     ...future.result <- base::tryCatch({
[16:12:52.314]         base::withCallingHandlers({
[16:12:52.314]             ...future.value <- base::withVisible(base::local({
[16:12:52.314]                 withCallingHandlers({
[16:12:52.314]                   {
[16:12:52.314]                     b <- a * ii
[16:12:52.314]                     a <- 0
[16:12:52.314]                     b
[16:12:52.314]                   }
[16:12:52.314]                 }, immediateCondition = function(cond) {
[16:12:52.314]                   save_rds <- function (object, pathname, ...) 
[16:12:52.314]                   {
[16:12:52.314]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:52.314]                     if (file_test("-f", pathname_tmp)) {
[16:12:52.314]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.314]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:52.314]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.314]                         fi_tmp[["mtime"]])
[16:12:52.314]                     }
[16:12:52.314]                     tryCatch({
[16:12:52.314]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:52.314]                     }, error = function(ex) {
[16:12:52.314]                       msg <- conditionMessage(ex)
[16:12:52.314]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.314]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:52.314]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.314]                         fi_tmp[["mtime"]], msg)
[16:12:52.314]                       ex$message <- msg
[16:12:52.314]                       stop(ex)
[16:12:52.314]                     })
[16:12:52.314]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:52.314]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:52.314]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:52.314]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.314]                       fi <- file.info(pathname)
[16:12:52.314]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:52.314]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.314]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:52.314]                         fi[["size"]], fi[["mtime"]])
[16:12:52.314]                       stop(msg)
[16:12:52.314]                     }
[16:12:52.314]                     invisible(pathname)
[16:12:52.314]                   }
[16:12:52.314]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:52.314]                     rootPath = tempdir()) 
[16:12:52.314]                   {
[16:12:52.314]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:52.314]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:52.314]                       tmpdir = path, fileext = ".rds")
[16:12:52.314]                     save_rds(obj, file)
[16:12:52.314]                   }
[16:12:52.314]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:52.314]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.314]                   {
[16:12:52.314]                     inherits <- base::inherits
[16:12:52.314]                     invokeRestart <- base::invokeRestart
[16:12:52.314]                     is.null <- base::is.null
[16:12:52.314]                     muffled <- FALSE
[16:12:52.314]                     if (inherits(cond, "message")) {
[16:12:52.314]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:52.314]                       if (muffled) 
[16:12:52.314]                         invokeRestart("muffleMessage")
[16:12:52.314]                     }
[16:12:52.314]                     else if (inherits(cond, "warning")) {
[16:12:52.314]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:52.314]                       if (muffled) 
[16:12:52.314]                         invokeRestart("muffleWarning")
[16:12:52.314]                     }
[16:12:52.314]                     else if (inherits(cond, "condition")) {
[16:12:52.314]                       if (!is.null(pattern)) {
[16:12:52.314]                         computeRestarts <- base::computeRestarts
[16:12:52.314]                         grepl <- base::grepl
[16:12:52.314]                         restarts <- computeRestarts(cond)
[16:12:52.314]                         for (restart in restarts) {
[16:12:52.314]                           name <- restart$name
[16:12:52.314]                           if (is.null(name)) 
[16:12:52.314]                             next
[16:12:52.314]                           if (!grepl(pattern, name)) 
[16:12:52.314]                             next
[16:12:52.314]                           invokeRestart(restart)
[16:12:52.314]                           muffled <- TRUE
[16:12:52.314]                           break
[16:12:52.314]                         }
[16:12:52.314]                       }
[16:12:52.314]                     }
[16:12:52.314]                     invisible(muffled)
[16:12:52.314]                   }
[16:12:52.314]                   muffleCondition(cond)
[16:12:52.314]                 })
[16:12:52.314]             }))
[16:12:52.314]             future::FutureResult(value = ...future.value$value, 
[16:12:52.314]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.314]                   ...future.rng), globalenv = if (FALSE) 
[16:12:52.314]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:52.314]                     ...future.globalenv.names))
[16:12:52.314]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:52.314]         }, condition = base::local({
[16:12:52.314]             c <- base::c
[16:12:52.314]             inherits <- base::inherits
[16:12:52.314]             invokeRestart <- base::invokeRestart
[16:12:52.314]             length <- base::length
[16:12:52.314]             list <- base::list
[16:12:52.314]             seq.int <- base::seq.int
[16:12:52.314]             signalCondition <- base::signalCondition
[16:12:52.314]             sys.calls <- base::sys.calls
[16:12:52.314]             `[[` <- base::`[[`
[16:12:52.314]             `+` <- base::`+`
[16:12:52.314]             `<<-` <- base::`<<-`
[16:12:52.314]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:52.314]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:52.314]                   3L)]
[16:12:52.314]             }
[16:12:52.314]             function(cond) {
[16:12:52.314]                 is_error <- inherits(cond, "error")
[16:12:52.314]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:52.314]                   NULL)
[16:12:52.314]                 if (is_error) {
[16:12:52.314]                   sessionInformation <- function() {
[16:12:52.314]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:52.314]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:52.314]                       search = base::search(), system = base::Sys.info())
[16:12:52.314]                   }
[16:12:52.314]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.314]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:52.314]                     cond$call), session = sessionInformation(), 
[16:12:52.314]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:52.314]                   signalCondition(cond)
[16:12:52.314]                 }
[16:12:52.314]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:52.314]                 "immediateCondition"))) {
[16:12:52.314]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:52.314]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.314]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:52.314]                   if (TRUE && !signal) {
[16:12:52.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.314]                     {
[16:12:52.314]                       inherits <- base::inherits
[16:12:52.314]                       invokeRestart <- base::invokeRestart
[16:12:52.314]                       is.null <- base::is.null
[16:12:52.314]                       muffled <- FALSE
[16:12:52.314]                       if (inherits(cond, "message")) {
[16:12:52.314]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.314]                         if (muffled) 
[16:12:52.314]                           invokeRestart("muffleMessage")
[16:12:52.314]                       }
[16:12:52.314]                       else if (inherits(cond, "warning")) {
[16:12:52.314]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.314]                         if (muffled) 
[16:12:52.314]                           invokeRestart("muffleWarning")
[16:12:52.314]                       }
[16:12:52.314]                       else if (inherits(cond, "condition")) {
[16:12:52.314]                         if (!is.null(pattern)) {
[16:12:52.314]                           computeRestarts <- base::computeRestarts
[16:12:52.314]                           grepl <- base::grepl
[16:12:52.314]                           restarts <- computeRestarts(cond)
[16:12:52.314]                           for (restart in restarts) {
[16:12:52.314]                             name <- restart$name
[16:12:52.314]                             if (is.null(name)) 
[16:12:52.314]                               next
[16:12:52.314]                             if (!grepl(pattern, name)) 
[16:12:52.314]                               next
[16:12:52.314]                             invokeRestart(restart)
[16:12:52.314]                             muffled <- TRUE
[16:12:52.314]                             break
[16:12:52.314]                           }
[16:12:52.314]                         }
[16:12:52.314]                       }
[16:12:52.314]                       invisible(muffled)
[16:12:52.314]                     }
[16:12:52.314]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.314]                   }
[16:12:52.314]                 }
[16:12:52.314]                 else {
[16:12:52.314]                   if (TRUE) {
[16:12:52.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.314]                     {
[16:12:52.314]                       inherits <- base::inherits
[16:12:52.314]                       invokeRestart <- base::invokeRestart
[16:12:52.314]                       is.null <- base::is.null
[16:12:52.314]                       muffled <- FALSE
[16:12:52.314]                       if (inherits(cond, "message")) {
[16:12:52.314]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.314]                         if (muffled) 
[16:12:52.314]                           invokeRestart("muffleMessage")
[16:12:52.314]                       }
[16:12:52.314]                       else if (inherits(cond, "warning")) {
[16:12:52.314]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.314]                         if (muffled) 
[16:12:52.314]                           invokeRestart("muffleWarning")
[16:12:52.314]                       }
[16:12:52.314]                       else if (inherits(cond, "condition")) {
[16:12:52.314]                         if (!is.null(pattern)) {
[16:12:52.314]                           computeRestarts <- base::computeRestarts
[16:12:52.314]                           grepl <- base::grepl
[16:12:52.314]                           restarts <- computeRestarts(cond)
[16:12:52.314]                           for (restart in restarts) {
[16:12:52.314]                             name <- restart$name
[16:12:52.314]                             if (is.null(name)) 
[16:12:52.314]                               next
[16:12:52.314]                             if (!grepl(pattern, name)) 
[16:12:52.314]                               next
[16:12:52.314]                             invokeRestart(restart)
[16:12:52.314]                             muffled <- TRUE
[16:12:52.314]                             break
[16:12:52.314]                           }
[16:12:52.314]                         }
[16:12:52.314]                       }
[16:12:52.314]                       invisible(muffled)
[16:12:52.314]                     }
[16:12:52.314]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.314]                   }
[16:12:52.314]                 }
[16:12:52.314]             }
[16:12:52.314]         }))
[16:12:52.314]     }, error = function(ex) {
[16:12:52.314]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:52.314]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.314]                 ...future.rng), started = ...future.startTime, 
[16:12:52.314]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:52.314]             version = "1.8"), class = "FutureResult")
[16:12:52.314]     }, finally = {
[16:12:52.314]         if (!identical(...future.workdir, getwd())) 
[16:12:52.314]             setwd(...future.workdir)
[16:12:52.314]         {
[16:12:52.314]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:52.314]                 ...future.oldOptions$nwarnings <- NULL
[16:12:52.314]             }
[16:12:52.314]             base::options(...future.oldOptions)
[16:12:52.314]             if (.Platform$OS.type == "windows") {
[16:12:52.314]                 old_names <- names(...future.oldEnvVars)
[16:12:52.314]                 envs <- base::Sys.getenv()
[16:12:52.314]                 names <- names(envs)
[16:12:52.314]                 common <- intersect(names, old_names)
[16:12:52.314]                 added <- setdiff(names, old_names)
[16:12:52.314]                 removed <- setdiff(old_names, names)
[16:12:52.314]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:52.314]                   envs[common]]
[16:12:52.314]                 NAMES <- toupper(changed)
[16:12:52.314]                 args <- list()
[16:12:52.314]                 for (kk in seq_along(NAMES)) {
[16:12:52.314]                   name <- changed[[kk]]
[16:12:52.314]                   NAME <- NAMES[[kk]]
[16:12:52.314]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.314]                     next
[16:12:52.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.314]                 }
[16:12:52.314]                 NAMES <- toupper(added)
[16:12:52.314]                 for (kk in seq_along(NAMES)) {
[16:12:52.314]                   name <- added[[kk]]
[16:12:52.314]                   NAME <- NAMES[[kk]]
[16:12:52.314]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.314]                     next
[16:12:52.314]                   args[[name]] <- ""
[16:12:52.314]                 }
[16:12:52.314]                 NAMES <- toupper(removed)
[16:12:52.314]                 for (kk in seq_along(NAMES)) {
[16:12:52.314]                   name <- removed[[kk]]
[16:12:52.314]                   NAME <- NAMES[[kk]]
[16:12:52.314]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.314]                     next
[16:12:52.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.314]                 }
[16:12:52.314]                 if (length(args) > 0) 
[16:12:52.314]                   base::do.call(base::Sys.setenv, args = args)
[16:12:52.314]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:52.314]             }
[16:12:52.314]             else {
[16:12:52.314]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:52.314]             }
[16:12:52.314]             {
[16:12:52.314]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:52.314]                   0L) {
[16:12:52.314]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:52.314]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:52.314]                   base::options(opts)
[16:12:52.314]                 }
[16:12:52.314]                 {
[16:12:52.314]                   {
[16:12:52.314]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:52.314]                     NULL
[16:12:52.314]                   }
[16:12:52.314]                   options(future.plan = NULL)
[16:12:52.314]                   if (is.na(NA_character_)) 
[16:12:52.314]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.314]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:52.314]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:52.314]                     envir = parent.frame()) 
[16:12:52.314]                   {
[16:12:52.314]                     default_workers <- missing(workers)
[16:12:52.314]                     if (is.function(workers)) 
[16:12:52.314]                       workers <- workers()
[16:12:52.314]                     workers <- structure(as.integer(workers), 
[16:12:52.314]                       class = class(workers))
[16:12:52.314]                     stop_if_not(is.finite(workers), workers >= 
[16:12:52.314]                       1L)
[16:12:52.314]                     if ((workers == 1L && !inherits(workers, 
[16:12:52.314]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:52.314]                       if (default_workers) 
[16:12:52.314]                         supportsMulticore(warn = TRUE)
[16:12:52.314]                       return(sequential(..., envir = envir))
[16:12:52.314]                     }
[16:12:52.314]                     oopts <- options(mc.cores = workers)
[16:12:52.314]                     on.exit(options(oopts))
[16:12:52.314]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:52.314]                       envir = envir)
[16:12:52.314]                     if (!future$lazy) 
[16:12:52.314]                       future <- run(future)
[16:12:52.314]                     invisible(future)
[16:12:52.314]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:52.314]                 }
[16:12:52.314]             }
[16:12:52.314]         }
[16:12:52.314]     })
[16:12:52.314]     if (TRUE) {
[16:12:52.314]         base::sink(type = "output", split = FALSE)
[16:12:52.314]         if (TRUE) {
[16:12:52.314]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:52.314]         }
[16:12:52.314]         else {
[16:12:52.314]             ...future.result["stdout"] <- base::list(NULL)
[16:12:52.314]         }
[16:12:52.314]         base::close(...future.stdout)
[16:12:52.314]         ...future.stdout <- NULL
[16:12:52.314]     }
[16:12:52.314]     ...future.result$conditions <- ...future.conditions
[16:12:52.314]     ...future.result$finished <- base::Sys.time()
[16:12:52.314]     ...future.result
[16:12:52.314] }
[16:12:52.316] assign_globals() ...
[16:12:52.316] List of 2
[16:12:52.316]  $ a : num 1
[16:12:52.316]  $ ii: int 2
[16:12:52.316]  - attr(*, "where")=List of 2
[16:12:52.316]   ..$ a :<environment: R_EmptyEnv> 
[16:12:52.316]   ..$ ii:<environment: R_EmptyEnv> 
[16:12:52.316]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:52.316]  - attr(*, "resolved")= logi TRUE
[16:12:52.316]  - attr(*, "total_size")= num 112
[16:12:52.316]  - attr(*, "already-done")= logi TRUE
[16:12:52.321] - copied ‘a’ to environment
[16:12:52.321] - copied ‘ii’ to environment
[16:12:52.321] assign_globals() ... done
[16:12:52.322] requestCore(): workers = 2
[16:12:52.323] MulticoreFuture started
[16:12:52.324] - Launch lazy future ... done
[16:12:52.324] run() for ‘MulticoreFuture’ ... done
[16:12:52.325] plan(): Setting new future strategy stack:
[16:12:52.325] List of future strategies:
[16:12:52.325] 1. sequential:
[16:12:52.325]    - args: function (..., envir = parent.frame())
[16:12:52.325]    - tweaked: FALSE
[16:12:52.325]    - call: NULL
[16:12:52.326] plan(): nbrOfWorkers() = 1
[16:12:52.328] plan(): Setting new future strategy stack:
[16:12:52.328] List of future strategies:
[16:12:52.328] 1. multicore:
[16:12:52.328]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:52.328]    - tweaked: FALSE
[16:12:52.328]    - call: plan(strategy)
[16:12:52.334] plan(): nbrOfWorkers() = 2
[16:12:52.335] run() for ‘Future’ ...
[16:12:52.335] - state: ‘created’
[16:12:52.335] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:52.340] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:52.340] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:52.340]   - Field: ‘label’
[16:12:52.340]   - Field: ‘local’
[16:12:52.340]   - Field: ‘owner’
[16:12:52.340]   - Field: ‘envir’
[16:12:52.340]   - Field: ‘workers’
[16:12:52.341]   - Field: ‘packages’
[16:12:52.341]   - Field: ‘gc’
[16:12:52.341]   - Field: ‘job’
[16:12:52.341]   - Field: ‘conditions’
[16:12:52.341]   - Field: ‘expr’
[16:12:52.341]   - Field: ‘uuid’
[16:12:52.341]   - Field: ‘seed’
[16:12:52.341]   - Field: ‘version’
[16:12:52.342]   - Field: ‘result’
[16:12:52.342]   - Field: ‘asynchronous’
[16:12:52.342]   - Field: ‘calls’
[16:12:52.342]   - Field: ‘globals’
[16:12:52.342]   - Field: ‘stdout’
[16:12:52.342]   - Field: ‘earlySignal’
[16:12:52.342]   - Field: ‘lazy’
[16:12:52.342]   - Field: ‘state’
[16:12:52.343] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:52.343] - Launch lazy future ...
[16:12:52.343] Packages needed by the future expression (n = 0): <none>
[16:12:52.343] Packages needed by future strategies (n = 0): <none>
[16:12:52.344] {
[16:12:52.344]     {
[16:12:52.344]         {
[16:12:52.344]             ...future.startTime <- base::Sys.time()
[16:12:52.344]             {
[16:12:52.344]                 {
[16:12:52.344]                   {
[16:12:52.344]                     {
[16:12:52.344]                       base::local({
[16:12:52.344]                         has_future <- base::requireNamespace("future", 
[16:12:52.344]                           quietly = TRUE)
[16:12:52.344]                         if (has_future) {
[16:12:52.344]                           ns <- base::getNamespace("future")
[16:12:52.344]                           version <- ns[[".package"]][["version"]]
[16:12:52.344]                           if (is.null(version)) 
[16:12:52.344]                             version <- utils::packageVersion("future")
[16:12:52.344]                         }
[16:12:52.344]                         else {
[16:12:52.344]                           version <- NULL
[16:12:52.344]                         }
[16:12:52.344]                         if (!has_future || version < "1.8.0") {
[16:12:52.344]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:52.344]                             "", base::R.version$version.string), 
[16:12:52.344]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:52.344]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:52.344]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:52.344]                               "release", "version")], collapse = " "), 
[16:12:52.344]                             hostname = base::Sys.info()[["nodename"]])
[16:12:52.344]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:52.344]                             info)
[16:12:52.344]                           info <- base::paste(info, collapse = "; ")
[16:12:52.344]                           if (!has_future) {
[16:12:52.344]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:52.344]                               info)
[16:12:52.344]                           }
[16:12:52.344]                           else {
[16:12:52.344]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:52.344]                               info, version)
[16:12:52.344]                           }
[16:12:52.344]                           base::stop(msg)
[16:12:52.344]                         }
[16:12:52.344]                       })
[16:12:52.344]                     }
[16:12:52.344]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:52.344]                     base::options(mc.cores = 1L)
[16:12:52.344]                   }
[16:12:52.344]                   options(future.plan = NULL)
[16:12:52.344]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.344]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:52.344]                 }
[16:12:52.344]                 ...future.workdir <- getwd()
[16:12:52.344]             }
[16:12:52.344]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:52.344]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:52.344]         }
[16:12:52.344]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:52.344]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:52.344]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:52.344]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:52.344]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:52.344]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:52.344]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:52.344]             base::names(...future.oldOptions))
[16:12:52.344]     }
[16:12:52.344]     if (FALSE) {
[16:12:52.344]     }
[16:12:52.344]     else {
[16:12:52.344]         if (TRUE) {
[16:12:52.344]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:52.344]                 open = "w")
[16:12:52.344]         }
[16:12:52.344]         else {
[16:12:52.344]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:52.344]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:52.344]         }
[16:12:52.344]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:52.344]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:52.344]             base::sink(type = "output", split = FALSE)
[16:12:52.344]             base::close(...future.stdout)
[16:12:52.344]         }, add = TRUE)
[16:12:52.344]     }
[16:12:52.344]     ...future.frame <- base::sys.nframe()
[16:12:52.344]     ...future.conditions <- base::list()
[16:12:52.344]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:52.344]     if (FALSE) {
[16:12:52.344]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:52.344]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:52.344]     }
[16:12:52.344]     ...future.result <- base::tryCatch({
[16:12:52.344]         base::withCallingHandlers({
[16:12:52.344]             ...future.value <- base::withVisible(base::local({
[16:12:52.344]                 withCallingHandlers({
[16:12:52.344]                   {
[16:12:52.344]                     b <- a * ii
[16:12:52.344]                     a <- 0
[16:12:52.344]                     b
[16:12:52.344]                   }
[16:12:52.344]                 }, immediateCondition = function(cond) {
[16:12:52.344]                   save_rds <- function (object, pathname, ...) 
[16:12:52.344]                   {
[16:12:52.344]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:52.344]                     if (file_test("-f", pathname_tmp)) {
[16:12:52.344]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.344]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:52.344]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.344]                         fi_tmp[["mtime"]])
[16:12:52.344]                     }
[16:12:52.344]                     tryCatch({
[16:12:52.344]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:52.344]                     }, error = function(ex) {
[16:12:52.344]                       msg <- conditionMessage(ex)
[16:12:52.344]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.344]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:52.344]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.344]                         fi_tmp[["mtime"]], msg)
[16:12:52.344]                       ex$message <- msg
[16:12:52.344]                       stop(ex)
[16:12:52.344]                     })
[16:12:52.344]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:52.344]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:52.344]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:52.344]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.344]                       fi <- file.info(pathname)
[16:12:52.344]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:52.344]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.344]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:52.344]                         fi[["size"]], fi[["mtime"]])
[16:12:52.344]                       stop(msg)
[16:12:52.344]                     }
[16:12:52.344]                     invisible(pathname)
[16:12:52.344]                   }
[16:12:52.344]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:52.344]                     rootPath = tempdir()) 
[16:12:52.344]                   {
[16:12:52.344]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:52.344]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:52.344]                       tmpdir = path, fileext = ".rds")
[16:12:52.344]                     save_rds(obj, file)
[16:12:52.344]                   }
[16:12:52.344]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:52.344]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.344]                   {
[16:12:52.344]                     inherits <- base::inherits
[16:12:52.344]                     invokeRestart <- base::invokeRestart
[16:12:52.344]                     is.null <- base::is.null
[16:12:52.344]                     muffled <- FALSE
[16:12:52.344]                     if (inherits(cond, "message")) {
[16:12:52.344]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:52.344]                       if (muffled) 
[16:12:52.344]                         invokeRestart("muffleMessage")
[16:12:52.344]                     }
[16:12:52.344]                     else if (inherits(cond, "warning")) {
[16:12:52.344]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:52.344]                       if (muffled) 
[16:12:52.344]                         invokeRestart("muffleWarning")
[16:12:52.344]                     }
[16:12:52.344]                     else if (inherits(cond, "condition")) {
[16:12:52.344]                       if (!is.null(pattern)) {
[16:12:52.344]                         computeRestarts <- base::computeRestarts
[16:12:52.344]                         grepl <- base::grepl
[16:12:52.344]                         restarts <- computeRestarts(cond)
[16:12:52.344]                         for (restart in restarts) {
[16:12:52.344]                           name <- restart$name
[16:12:52.344]                           if (is.null(name)) 
[16:12:52.344]                             next
[16:12:52.344]                           if (!grepl(pattern, name)) 
[16:12:52.344]                             next
[16:12:52.344]                           invokeRestart(restart)
[16:12:52.344]                           muffled <- TRUE
[16:12:52.344]                           break
[16:12:52.344]                         }
[16:12:52.344]                       }
[16:12:52.344]                     }
[16:12:52.344]                     invisible(muffled)
[16:12:52.344]                   }
[16:12:52.344]                   muffleCondition(cond)
[16:12:52.344]                 })
[16:12:52.344]             }))
[16:12:52.344]             future::FutureResult(value = ...future.value$value, 
[16:12:52.344]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.344]                   ...future.rng), globalenv = if (FALSE) 
[16:12:52.344]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:52.344]                     ...future.globalenv.names))
[16:12:52.344]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:52.344]         }, condition = base::local({
[16:12:52.344]             c <- base::c
[16:12:52.344]             inherits <- base::inherits
[16:12:52.344]             invokeRestart <- base::invokeRestart
[16:12:52.344]             length <- base::length
[16:12:52.344]             list <- base::list
[16:12:52.344]             seq.int <- base::seq.int
[16:12:52.344]             signalCondition <- base::signalCondition
[16:12:52.344]             sys.calls <- base::sys.calls
[16:12:52.344]             `[[` <- base::`[[`
[16:12:52.344]             `+` <- base::`+`
[16:12:52.344]             `<<-` <- base::`<<-`
[16:12:52.344]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:52.344]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:52.344]                   3L)]
[16:12:52.344]             }
[16:12:52.344]             function(cond) {
[16:12:52.344]                 is_error <- inherits(cond, "error")
[16:12:52.344]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:52.344]                   NULL)
[16:12:52.344]                 if (is_error) {
[16:12:52.344]                   sessionInformation <- function() {
[16:12:52.344]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:52.344]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:52.344]                       search = base::search(), system = base::Sys.info())
[16:12:52.344]                   }
[16:12:52.344]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.344]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:52.344]                     cond$call), session = sessionInformation(), 
[16:12:52.344]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:52.344]                   signalCondition(cond)
[16:12:52.344]                 }
[16:12:52.344]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:52.344]                 "immediateCondition"))) {
[16:12:52.344]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:52.344]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.344]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:52.344]                   if (TRUE && !signal) {
[16:12:52.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.344]                     {
[16:12:52.344]                       inherits <- base::inherits
[16:12:52.344]                       invokeRestart <- base::invokeRestart
[16:12:52.344]                       is.null <- base::is.null
[16:12:52.344]                       muffled <- FALSE
[16:12:52.344]                       if (inherits(cond, "message")) {
[16:12:52.344]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.344]                         if (muffled) 
[16:12:52.344]                           invokeRestart("muffleMessage")
[16:12:52.344]                       }
[16:12:52.344]                       else if (inherits(cond, "warning")) {
[16:12:52.344]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.344]                         if (muffled) 
[16:12:52.344]                           invokeRestart("muffleWarning")
[16:12:52.344]                       }
[16:12:52.344]                       else if (inherits(cond, "condition")) {
[16:12:52.344]                         if (!is.null(pattern)) {
[16:12:52.344]                           computeRestarts <- base::computeRestarts
[16:12:52.344]                           grepl <- base::grepl
[16:12:52.344]                           restarts <- computeRestarts(cond)
[16:12:52.344]                           for (restart in restarts) {
[16:12:52.344]                             name <- restart$name
[16:12:52.344]                             if (is.null(name)) 
[16:12:52.344]                               next
[16:12:52.344]                             if (!grepl(pattern, name)) 
[16:12:52.344]                               next
[16:12:52.344]                             invokeRestart(restart)
[16:12:52.344]                             muffled <- TRUE
[16:12:52.344]                             break
[16:12:52.344]                           }
[16:12:52.344]                         }
[16:12:52.344]                       }
[16:12:52.344]                       invisible(muffled)
[16:12:52.344]                     }
[16:12:52.344]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.344]                   }
[16:12:52.344]                 }
[16:12:52.344]                 else {
[16:12:52.344]                   if (TRUE) {
[16:12:52.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.344]                     {
[16:12:52.344]                       inherits <- base::inherits
[16:12:52.344]                       invokeRestart <- base::invokeRestart
[16:12:52.344]                       is.null <- base::is.null
[16:12:52.344]                       muffled <- FALSE
[16:12:52.344]                       if (inherits(cond, "message")) {
[16:12:52.344]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.344]                         if (muffled) 
[16:12:52.344]                           invokeRestart("muffleMessage")
[16:12:52.344]                       }
[16:12:52.344]                       else if (inherits(cond, "warning")) {
[16:12:52.344]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.344]                         if (muffled) 
[16:12:52.344]                           invokeRestart("muffleWarning")
[16:12:52.344]                       }
[16:12:52.344]                       else if (inherits(cond, "condition")) {
[16:12:52.344]                         if (!is.null(pattern)) {
[16:12:52.344]                           computeRestarts <- base::computeRestarts
[16:12:52.344]                           grepl <- base::grepl
[16:12:52.344]                           restarts <- computeRestarts(cond)
[16:12:52.344]                           for (restart in restarts) {
[16:12:52.344]                             name <- restart$name
[16:12:52.344]                             if (is.null(name)) 
[16:12:52.344]                               next
[16:12:52.344]                             if (!grepl(pattern, name)) 
[16:12:52.344]                               next
[16:12:52.344]                             invokeRestart(restart)
[16:12:52.344]                             muffled <- TRUE
[16:12:52.344]                             break
[16:12:52.344]                           }
[16:12:52.344]                         }
[16:12:52.344]                       }
[16:12:52.344]                       invisible(muffled)
[16:12:52.344]                     }
[16:12:52.344]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.344]                   }
[16:12:52.344]                 }
[16:12:52.344]             }
[16:12:52.344]         }))
[16:12:52.344]     }, error = function(ex) {
[16:12:52.344]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:52.344]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.344]                 ...future.rng), started = ...future.startTime, 
[16:12:52.344]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:52.344]             version = "1.8"), class = "FutureResult")
[16:12:52.344]     }, finally = {
[16:12:52.344]         if (!identical(...future.workdir, getwd())) 
[16:12:52.344]             setwd(...future.workdir)
[16:12:52.344]         {
[16:12:52.344]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:52.344]                 ...future.oldOptions$nwarnings <- NULL
[16:12:52.344]             }
[16:12:52.344]             base::options(...future.oldOptions)
[16:12:52.344]             if (.Platform$OS.type == "windows") {
[16:12:52.344]                 old_names <- names(...future.oldEnvVars)
[16:12:52.344]                 envs <- base::Sys.getenv()
[16:12:52.344]                 names <- names(envs)
[16:12:52.344]                 common <- intersect(names, old_names)
[16:12:52.344]                 added <- setdiff(names, old_names)
[16:12:52.344]                 removed <- setdiff(old_names, names)
[16:12:52.344]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:52.344]                   envs[common]]
[16:12:52.344]                 NAMES <- toupper(changed)
[16:12:52.344]                 args <- list()
[16:12:52.344]                 for (kk in seq_along(NAMES)) {
[16:12:52.344]                   name <- changed[[kk]]
[16:12:52.344]                   NAME <- NAMES[[kk]]
[16:12:52.344]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.344]                     next
[16:12:52.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.344]                 }
[16:12:52.344]                 NAMES <- toupper(added)
[16:12:52.344]                 for (kk in seq_along(NAMES)) {
[16:12:52.344]                   name <- added[[kk]]
[16:12:52.344]                   NAME <- NAMES[[kk]]
[16:12:52.344]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.344]                     next
[16:12:52.344]                   args[[name]] <- ""
[16:12:52.344]                 }
[16:12:52.344]                 NAMES <- toupper(removed)
[16:12:52.344]                 for (kk in seq_along(NAMES)) {
[16:12:52.344]                   name <- removed[[kk]]
[16:12:52.344]                   NAME <- NAMES[[kk]]
[16:12:52.344]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.344]                     next
[16:12:52.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.344]                 }
[16:12:52.344]                 if (length(args) > 0) 
[16:12:52.344]                   base::do.call(base::Sys.setenv, args = args)
[16:12:52.344]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:52.344]             }
[16:12:52.344]             else {
[16:12:52.344]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:52.344]             }
[16:12:52.344]             {
[16:12:52.344]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:52.344]                   0L) {
[16:12:52.344]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:52.344]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:52.344]                   base::options(opts)
[16:12:52.344]                 }
[16:12:52.344]                 {
[16:12:52.344]                   {
[16:12:52.344]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:52.344]                     NULL
[16:12:52.344]                   }
[16:12:52.344]                   options(future.plan = NULL)
[16:12:52.344]                   if (is.na(NA_character_)) 
[16:12:52.344]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.344]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:52.344]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:52.344]                     envir = parent.frame()) 
[16:12:52.344]                   {
[16:12:52.344]                     default_workers <- missing(workers)
[16:12:52.344]                     if (is.function(workers)) 
[16:12:52.344]                       workers <- workers()
[16:12:52.344]                     workers <- structure(as.integer(workers), 
[16:12:52.344]                       class = class(workers))
[16:12:52.344]                     stop_if_not(is.finite(workers), workers >= 
[16:12:52.344]                       1L)
[16:12:52.344]                     if ((workers == 1L && !inherits(workers, 
[16:12:52.344]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:52.344]                       if (default_workers) 
[16:12:52.344]                         supportsMulticore(warn = TRUE)
[16:12:52.344]                       return(sequential(..., envir = envir))
[16:12:52.344]                     }
[16:12:52.344]                     oopts <- options(mc.cores = workers)
[16:12:52.344]                     on.exit(options(oopts))
[16:12:52.344]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:52.344]                       envir = envir)
[16:12:52.344]                     if (!future$lazy) 
[16:12:52.344]                       future <- run(future)
[16:12:52.344]                     invisible(future)
[16:12:52.344]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:52.344]                 }
[16:12:52.344]             }
[16:12:52.344]         }
[16:12:52.344]     })
[16:12:52.344]     if (TRUE) {
[16:12:52.344]         base::sink(type = "output", split = FALSE)
[16:12:52.344]         if (TRUE) {
[16:12:52.344]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:52.344]         }
[16:12:52.344]         else {
[16:12:52.344]             ...future.result["stdout"] <- base::list(NULL)
[16:12:52.344]         }
[16:12:52.344]         base::close(...future.stdout)
[16:12:52.344]         ...future.stdout <- NULL
[16:12:52.344]     }
[16:12:52.344]     ...future.result$conditions <- ...future.conditions
[16:12:52.344]     ...future.result$finished <- base::Sys.time()
[16:12:52.344]     ...future.result
[16:12:52.344] }
[16:12:52.347] assign_globals() ...
[16:12:52.347] List of 2
[16:12:52.347]  $ a : num 1
[16:12:52.347]  $ ii: int 3
[16:12:52.347]  - attr(*, "where")=List of 2
[16:12:52.347]   ..$ a :<environment: R_EmptyEnv> 
[16:12:52.347]   ..$ ii:<environment: R_EmptyEnv> 
[16:12:52.347]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:52.347]  - attr(*, "resolved")= logi TRUE
[16:12:52.347]  - attr(*, "total_size")= num 112
[16:12:52.347]  - attr(*, "already-done")= logi TRUE
[16:12:52.351] - copied ‘a’ to environment
[16:12:52.351] - copied ‘ii’ to environment
[16:12:52.351] assign_globals() ... done
[16:12:52.351] requestCore(): workers = 2
[16:12:52.353] MulticoreFuture started
[16:12:52.353] - Launch lazy future ... done
[16:12:52.354] run() for ‘MulticoreFuture’ ... done
[16:12:52.354] plan(): Setting new future strategy stack:
[16:12:52.354] List of future strategies:
[16:12:52.354] 1. sequential:
[16:12:52.354]    - args: function (..., envir = parent.frame())
[16:12:52.354]    - tweaked: FALSE
[16:12:52.354]    - call: NULL
[16:12:52.355] plan(): nbrOfWorkers() = 1
[16:12:52.358] plan(): Setting new future strategy stack:
[16:12:52.358] List of future strategies:
[16:12:52.358] 1. multicore:
[16:12:52.358]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:52.358]    - tweaked: FALSE
[16:12:52.358]    - call: plan(strategy)
[16:12:52.363] plan(): nbrOfWorkers() = 2
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:52.365] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:52.365] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:52.366] 
[16:12:52.366] Searching for globals ... DONE
[16:12:52.366] - globals: [0] <none>
[16:12:52.366] getGlobalsAndPackages() ... DONE
[16:12:52.367] run() for ‘Future’ ...
[16:12:52.367] - state: ‘created’
[16:12:52.367] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:52.371] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:52.371] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:52.372]   - Field: ‘label’
[16:12:52.372]   - Field: ‘local’
[16:12:52.374]   - Field: ‘owner’
[16:12:52.375]   - Field: ‘envir’
[16:12:52.375]   - Field: ‘workers’
[16:12:52.375]   - Field: ‘packages’
[16:12:52.375]   - Field: ‘gc’
[16:12:52.375]   - Field: ‘job’
[16:12:52.376]   - Field: ‘conditions’
[16:12:52.376]   - Field: ‘expr’
[16:12:52.376]   - Field: ‘uuid’
[16:12:52.376]   - Field: ‘seed’
[16:12:52.376]   - Field: ‘version’
[16:12:52.376]   - Field: ‘result’
[16:12:52.377]   - Field: ‘asynchronous’
[16:12:52.377]   - Field: ‘calls’
[16:12:52.377]   - Field: ‘globals’
[16:12:52.377]   - Field: ‘stdout’
[16:12:52.377]   - Field: ‘earlySignal’
[16:12:52.377]   - Field: ‘lazy’
[16:12:52.377]   - Field: ‘state’
[16:12:52.378] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:52.378] - Launch lazy future ...
[16:12:52.378] Packages needed by the future expression (n = 0): <none>
[16:12:52.378] Packages needed by future strategies (n = 0): <none>
[16:12:52.379] {
[16:12:52.379]     {
[16:12:52.379]         {
[16:12:52.379]             ...future.startTime <- base::Sys.time()
[16:12:52.379]             {
[16:12:52.379]                 {
[16:12:52.379]                   {
[16:12:52.379]                     {
[16:12:52.379]                       base::local({
[16:12:52.379]                         has_future <- base::requireNamespace("future", 
[16:12:52.379]                           quietly = TRUE)
[16:12:52.379]                         if (has_future) {
[16:12:52.379]                           ns <- base::getNamespace("future")
[16:12:52.379]                           version <- ns[[".package"]][["version"]]
[16:12:52.379]                           if (is.null(version)) 
[16:12:52.379]                             version <- utils::packageVersion("future")
[16:12:52.379]                         }
[16:12:52.379]                         else {
[16:12:52.379]                           version <- NULL
[16:12:52.379]                         }
[16:12:52.379]                         if (!has_future || version < "1.8.0") {
[16:12:52.379]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:52.379]                             "", base::R.version$version.string), 
[16:12:52.379]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:52.379]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:52.379]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:52.379]                               "release", "version")], collapse = " "), 
[16:12:52.379]                             hostname = base::Sys.info()[["nodename"]])
[16:12:52.379]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:52.379]                             info)
[16:12:52.379]                           info <- base::paste(info, collapse = "; ")
[16:12:52.379]                           if (!has_future) {
[16:12:52.379]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:52.379]                               info)
[16:12:52.379]                           }
[16:12:52.379]                           else {
[16:12:52.379]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:52.379]                               info, version)
[16:12:52.379]                           }
[16:12:52.379]                           base::stop(msg)
[16:12:52.379]                         }
[16:12:52.379]                       })
[16:12:52.379]                     }
[16:12:52.379]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:52.379]                     base::options(mc.cores = 1L)
[16:12:52.379]                   }
[16:12:52.379]                   options(future.plan = NULL)
[16:12:52.379]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.379]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:52.379]                 }
[16:12:52.379]                 ...future.workdir <- getwd()
[16:12:52.379]             }
[16:12:52.379]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:52.379]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:52.379]         }
[16:12:52.379]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:52.379]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:52.379]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:52.379]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:52.379]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:52.379]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:52.379]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:52.379]             base::names(...future.oldOptions))
[16:12:52.379]     }
[16:12:52.379]     if (FALSE) {
[16:12:52.379]     }
[16:12:52.379]     else {
[16:12:52.379]         if (TRUE) {
[16:12:52.379]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:52.379]                 open = "w")
[16:12:52.379]         }
[16:12:52.379]         else {
[16:12:52.379]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:52.379]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:52.379]         }
[16:12:52.379]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:52.379]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:52.379]             base::sink(type = "output", split = FALSE)
[16:12:52.379]             base::close(...future.stdout)
[16:12:52.379]         }, add = TRUE)
[16:12:52.379]     }
[16:12:52.379]     ...future.frame <- base::sys.nframe()
[16:12:52.379]     ...future.conditions <- base::list()
[16:12:52.379]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:52.379]     if (FALSE) {
[16:12:52.379]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:52.379]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:52.379]     }
[16:12:52.379]     ...future.result <- base::tryCatch({
[16:12:52.379]         base::withCallingHandlers({
[16:12:52.379]             ...future.value <- base::withVisible(base::local({
[16:12:52.379]                 withCallingHandlers({
[16:12:52.379]                   1
[16:12:52.379]                 }, immediateCondition = function(cond) {
[16:12:52.379]                   save_rds <- function (object, pathname, ...) 
[16:12:52.379]                   {
[16:12:52.379]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:52.379]                     if (file_test("-f", pathname_tmp)) {
[16:12:52.379]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.379]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:52.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.379]                         fi_tmp[["mtime"]])
[16:12:52.379]                     }
[16:12:52.379]                     tryCatch({
[16:12:52.379]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:52.379]                     }, error = function(ex) {
[16:12:52.379]                       msg <- conditionMessage(ex)
[16:12:52.379]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.379]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:52.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.379]                         fi_tmp[["mtime"]], msg)
[16:12:52.379]                       ex$message <- msg
[16:12:52.379]                       stop(ex)
[16:12:52.379]                     })
[16:12:52.379]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:52.379]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:52.379]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:52.379]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.379]                       fi <- file.info(pathname)
[16:12:52.379]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:52.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.379]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:52.379]                         fi[["size"]], fi[["mtime"]])
[16:12:52.379]                       stop(msg)
[16:12:52.379]                     }
[16:12:52.379]                     invisible(pathname)
[16:12:52.379]                   }
[16:12:52.379]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:52.379]                     rootPath = tempdir()) 
[16:12:52.379]                   {
[16:12:52.379]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:52.379]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:52.379]                       tmpdir = path, fileext = ".rds")
[16:12:52.379]                     save_rds(obj, file)
[16:12:52.379]                   }
[16:12:52.379]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:52.379]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.379]                   {
[16:12:52.379]                     inherits <- base::inherits
[16:12:52.379]                     invokeRestart <- base::invokeRestart
[16:12:52.379]                     is.null <- base::is.null
[16:12:52.379]                     muffled <- FALSE
[16:12:52.379]                     if (inherits(cond, "message")) {
[16:12:52.379]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:52.379]                       if (muffled) 
[16:12:52.379]                         invokeRestart("muffleMessage")
[16:12:52.379]                     }
[16:12:52.379]                     else if (inherits(cond, "warning")) {
[16:12:52.379]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:52.379]                       if (muffled) 
[16:12:52.379]                         invokeRestart("muffleWarning")
[16:12:52.379]                     }
[16:12:52.379]                     else if (inherits(cond, "condition")) {
[16:12:52.379]                       if (!is.null(pattern)) {
[16:12:52.379]                         computeRestarts <- base::computeRestarts
[16:12:52.379]                         grepl <- base::grepl
[16:12:52.379]                         restarts <- computeRestarts(cond)
[16:12:52.379]                         for (restart in restarts) {
[16:12:52.379]                           name <- restart$name
[16:12:52.379]                           if (is.null(name)) 
[16:12:52.379]                             next
[16:12:52.379]                           if (!grepl(pattern, name)) 
[16:12:52.379]                             next
[16:12:52.379]                           invokeRestart(restart)
[16:12:52.379]                           muffled <- TRUE
[16:12:52.379]                           break
[16:12:52.379]                         }
[16:12:52.379]                       }
[16:12:52.379]                     }
[16:12:52.379]                     invisible(muffled)
[16:12:52.379]                   }
[16:12:52.379]                   muffleCondition(cond)
[16:12:52.379]                 })
[16:12:52.379]             }))
[16:12:52.379]             future::FutureResult(value = ...future.value$value, 
[16:12:52.379]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.379]                   ...future.rng), globalenv = if (FALSE) 
[16:12:52.379]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:52.379]                     ...future.globalenv.names))
[16:12:52.379]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:52.379]         }, condition = base::local({
[16:12:52.379]             c <- base::c
[16:12:52.379]             inherits <- base::inherits
[16:12:52.379]             invokeRestart <- base::invokeRestart
[16:12:52.379]             length <- base::length
[16:12:52.379]             list <- base::list
[16:12:52.379]             seq.int <- base::seq.int
[16:12:52.379]             signalCondition <- base::signalCondition
[16:12:52.379]             sys.calls <- base::sys.calls
[16:12:52.379]             `[[` <- base::`[[`
[16:12:52.379]             `+` <- base::`+`
[16:12:52.379]             `<<-` <- base::`<<-`
[16:12:52.379]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:52.379]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:52.379]                   3L)]
[16:12:52.379]             }
[16:12:52.379]             function(cond) {
[16:12:52.379]                 is_error <- inherits(cond, "error")
[16:12:52.379]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:52.379]                   NULL)
[16:12:52.379]                 if (is_error) {
[16:12:52.379]                   sessionInformation <- function() {
[16:12:52.379]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:52.379]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:52.379]                       search = base::search(), system = base::Sys.info())
[16:12:52.379]                   }
[16:12:52.379]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.379]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:52.379]                     cond$call), session = sessionInformation(), 
[16:12:52.379]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:52.379]                   signalCondition(cond)
[16:12:52.379]                 }
[16:12:52.379]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:52.379]                 "immediateCondition"))) {
[16:12:52.379]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:52.379]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.379]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:52.379]                   if (TRUE && !signal) {
[16:12:52.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.379]                     {
[16:12:52.379]                       inherits <- base::inherits
[16:12:52.379]                       invokeRestart <- base::invokeRestart
[16:12:52.379]                       is.null <- base::is.null
[16:12:52.379]                       muffled <- FALSE
[16:12:52.379]                       if (inherits(cond, "message")) {
[16:12:52.379]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.379]                         if (muffled) 
[16:12:52.379]                           invokeRestart("muffleMessage")
[16:12:52.379]                       }
[16:12:52.379]                       else if (inherits(cond, "warning")) {
[16:12:52.379]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.379]                         if (muffled) 
[16:12:52.379]                           invokeRestart("muffleWarning")
[16:12:52.379]                       }
[16:12:52.379]                       else if (inherits(cond, "condition")) {
[16:12:52.379]                         if (!is.null(pattern)) {
[16:12:52.379]                           computeRestarts <- base::computeRestarts
[16:12:52.379]                           grepl <- base::grepl
[16:12:52.379]                           restarts <- computeRestarts(cond)
[16:12:52.379]                           for (restart in restarts) {
[16:12:52.379]                             name <- restart$name
[16:12:52.379]                             if (is.null(name)) 
[16:12:52.379]                               next
[16:12:52.379]                             if (!grepl(pattern, name)) 
[16:12:52.379]                               next
[16:12:52.379]                             invokeRestart(restart)
[16:12:52.379]                             muffled <- TRUE
[16:12:52.379]                             break
[16:12:52.379]                           }
[16:12:52.379]                         }
[16:12:52.379]                       }
[16:12:52.379]                       invisible(muffled)
[16:12:52.379]                     }
[16:12:52.379]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.379]                   }
[16:12:52.379]                 }
[16:12:52.379]                 else {
[16:12:52.379]                   if (TRUE) {
[16:12:52.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.379]                     {
[16:12:52.379]                       inherits <- base::inherits
[16:12:52.379]                       invokeRestart <- base::invokeRestart
[16:12:52.379]                       is.null <- base::is.null
[16:12:52.379]                       muffled <- FALSE
[16:12:52.379]                       if (inherits(cond, "message")) {
[16:12:52.379]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.379]                         if (muffled) 
[16:12:52.379]                           invokeRestart("muffleMessage")
[16:12:52.379]                       }
[16:12:52.379]                       else if (inherits(cond, "warning")) {
[16:12:52.379]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.379]                         if (muffled) 
[16:12:52.379]                           invokeRestart("muffleWarning")
[16:12:52.379]                       }
[16:12:52.379]                       else if (inherits(cond, "condition")) {
[16:12:52.379]                         if (!is.null(pattern)) {
[16:12:52.379]                           computeRestarts <- base::computeRestarts
[16:12:52.379]                           grepl <- base::grepl
[16:12:52.379]                           restarts <- computeRestarts(cond)
[16:12:52.379]                           for (restart in restarts) {
[16:12:52.379]                             name <- restart$name
[16:12:52.379]                             if (is.null(name)) 
[16:12:52.379]                               next
[16:12:52.379]                             if (!grepl(pattern, name)) 
[16:12:52.379]                               next
[16:12:52.379]                             invokeRestart(restart)
[16:12:52.379]                             muffled <- TRUE
[16:12:52.379]                             break
[16:12:52.379]                           }
[16:12:52.379]                         }
[16:12:52.379]                       }
[16:12:52.379]                       invisible(muffled)
[16:12:52.379]                     }
[16:12:52.379]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.379]                   }
[16:12:52.379]                 }
[16:12:52.379]             }
[16:12:52.379]         }))
[16:12:52.379]     }, error = function(ex) {
[16:12:52.379]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:52.379]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.379]                 ...future.rng), started = ...future.startTime, 
[16:12:52.379]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:52.379]             version = "1.8"), class = "FutureResult")
[16:12:52.379]     }, finally = {
[16:12:52.379]         if (!identical(...future.workdir, getwd())) 
[16:12:52.379]             setwd(...future.workdir)
[16:12:52.379]         {
[16:12:52.379]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:52.379]                 ...future.oldOptions$nwarnings <- NULL
[16:12:52.379]             }
[16:12:52.379]             base::options(...future.oldOptions)
[16:12:52.379]             if (.Platform$OS.type == "windows") {
[16:12:52.379]                 old_names <- names(...future.oldEnvVars)
[16:12:52.379]                 envs <- base::Sys.getenv()
[16:12:52.379]                 names <- names(envs)
[16:12:52.379]                 common <- intersect(names, old_names)
[16:12:52.379]                 added <- setdiff(names, old_names)
[16:12:52.379]                 removed <- setdiff(old_names, names)
[16:12:52.379]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:52.379]                   envs[common]]
[16:12:52.379]                 NAMES <- toupper(changed)
[16:12:52.379]                 args <- list()
[16:12:52.379]                 for (kk in seq_along(NAMES)) {
[16:12:52.379]                   name <- changed[[kk]]
[16:12:52.379]                   NAME <- NAMES[[kk]]
[16:12:52.379]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.379]                     next
[16:12:52.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.379]                 }
[16:12:52.379]                 NAMES <- toupper(added)
[16:12:52.379]                 for (kk in seq_along(NAMES)) {
[16:12:52.379]                   name <- added[[kk]]
[16:12:52.379]                   NAME <- NAMES[[kk]]
[16:12:52.379]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.379]                     next
[16:12:52.379]                   args[[name]] <- ""
[16:12:52.379]                 }
[16:12:52.379]                 NAMES <- toupper(removed)
[16:12:52.379]                 for (kk in seq_along(NAMES)) {
[16:12:52.379]                   name <- removed[[kk]]
[16:12:52.379]                   NAME <- NAMES[[kk]]
[16:12:52.379]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.379]                     next
[16:12:52.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.379]                 }
[16:12:52.379]                 if (length(args) > 0) 
[16:12:52.379]                   base::do.call(base::Sys.setenv, args = args)
[16:12:52.379]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:52.379]             }
[16:12:52.379]             else {
[16:12:52.379]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:52.379]             }
[16:12:52.379]             {
[16:12:52.379]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:52.379]                   0L) {
[16:12:52.379]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:52.379]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:52.379]                   base::options(opts)
[16:12:52.379]                 }
[16:12:52.379]                 {
[16:12:52.379]                   {
[16:12:52.379]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:52.379]                     NULL
[16:12:52.379]                   }
[16:12:52.379]                   options(future.plan = NULL)
[16:12:52.379]                   if (is.na(NA_character_)) 
[16:12:52.379]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.379]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:52.379]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:52.379]                     envir = parent.frame()) 
[16:12:52.379]                   {
[16:12:52.379]                     default_workers <- missing(workers)
[16:12:52.379]                     if (is.function(workers)) 
[16:12:52.379]                       workers <- workers()
[16:12:52.379]                     workers <- structure(as.integer(workers), 
[16:12:52.379]                       class = class(workers))
[16:12:52.379]                     stop_if_not(is.finite(workers), workers >= 
[16:12:52.379]                       1L)
[16:12:52.379]                     if ((workers == 1L && !inherits(workers, 
[16:12:52.379]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:52.379]                       if (default_workers) 
[16:12:52.379]                         supportsMulticore(warn = TRUE)
[16:12:52.379]                       return(sequential(..., envir = envir))
[16:12:52.379]                     }
[16:12:52.379]                     oopts <- options(mc.cores = workers)
[16:12:52.379]                     on.exit(options(oopts))
[16:12:52.379]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:52.379]                       envir = envir)
[16:12:52.379]                     if (!future$lazy) 
[16:12:52.379]                       future <- run(future)
[16:12:52.379]                     invisible(future)
[16:12:52.379]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:52.379]                 }
[16:12:52.379]             }
[16:12:52.379]         }
[16:12:52.379]     })
[16:12:52.379]     if (TRUE) {
[16:12:52.379]         base::sink(type = "output", split = FALSE)
[16:12:52.379]         if (TRUE) {
[16:12:52.379]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:52.379]         }
[16:12:52.379]         else {
[16:12:52.379]             ...future.result["stdout"] <- base::list(NULL)
[16:12:52.379]         }
[16:12:52.379]         base::close(...future.stdout)
[16:12:52.379]         ...future.stdout <- NULL
[16:12:52.379]     }
[16:12:52.379]     ...future.result$conditions <- ...future.conditions
[16:12:52.379]     ...future.result$finished <- base::Sys.time()
[16:12:52.379]     ...future.result
[16:12:52.379] }
[16:12:52.382] requestCore(): workers = 2
[16:12:52.383] MulticoreFuture started
[16:12:52.384] - Launch lazy future ... done
[16:12:52.384] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:52.385] getGlobalsAndPackages() ...
[16:12:52.385] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:52.385] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:52.385] List of future strategies:
[16:12:52.385] 1. sequential:
[16:12:52.385]    - args: function (..., envir = parent.frame())
[16:12:52.385]    - tweaked: FALSE
[16:12:52.385]    - call: NULL
[16:12:52.386] plan(): nbrOfWorkers() = 1
[16:12:52.387] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:52.387] Searching for globals ... DONE
[16:12:52.387] Resolving globals: TRUE
[16:12:52.388] Resolving any globals that are futures ...
[16:12:52.388] plan(): Setting new future strategy stack:
[16:12:52.388] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:52.388] List of future strategies:
[16:12:52.388] 1. multicore:
[16:12:52.388]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:52.388]    - tweaked: FALSE
[16:12:52.388]    - call: plan(strategy)
[16:12:52.388] Resolving any globals that are futures ... DONE
[16:12:52.389] Resolving futures part of globals (recursively) ...
[16:12:52.391] resolve() on list ...
[16:12:52.391]  recursive: 99
[16:12:52.391]  length: 1
[16:12:52.391]  elements: ‘a’
[16:12:52.394] plan(): nbrOfWorkers() = 2
[16:12:52.394] Future #1
[16:12:52.396] A MulticoreFuture was resolved
[16:12:52.396]  length: 0 (resolved future 1)
[16:12:52.396] resolve() on list ... DONE
[16:12:52.397] - globals: [1] ‘a’
[16:12:52.397] Resolving futures part of globals (recursively) ... DONE
[16:12:52.400] The total size of the 1 globals is 1.55 MiB (1629776 bytes)
[16:12:52.400] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[16:12:52.400] - globals: [1] ‘a’
[16:12:52.401] - packages: [1] ‘future’
[16:12:52.401] getGlobalsAndPackages() ... DONE
[16:12:52.401] run() for ‘Future’ ...
[16:12:52.401] - state: ‘created’
[16:12:52.401] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:52.405] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:52.406] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:52.406]   - Field: ‘label’
[16:12:52.406]   - Field: ‘local’
[16:12:52.406]   - Field: ‘owner’
[16:12:52.406]   - Field: ‘envir’
[16:12:52.406]   - Field: ‘workers’
[16:12:52.406]   - Field: ‘packages’
[16:12:52.406]   - Field: ‘gc’
[16:12:52.407]   - Field: ‘job’
[16:12:52.407]   - Field: ‘conditions’
[16:12:52.407]   - Field: ‘expr’
[16:12:52.407]   - Field: ‘uuid’
[16:12:52.407]   - Field: ‘seed’
[16:12:52.407]   - Field: ‘version’
[16:12:52.407]   - Field: ‘result’
[16:12:52.407]   - Field: ‘asynchronous’
[16:12:52.407]   - Field: ‘calls’
[16:12:52.408]   - Field: ‘globals’
[16:12:52.408]   - Field: ‘stdout’
[16:12:52.408]   - Field: ‘earlySignal’
[16:12:52.408]   - Field: ‘lazy’
[16:12:52.408]   - Field: ‘state’
[16:12:52.408] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:52.408] - Launch lazy future ...
[16:12:52.409] Packages needed by the future expression (n = 1): ‘future’
[16:12:52.409] Packages needed by future strategies (n = 0): <none>
[16:12:52.409] {
[16:12:52.409]     {
[16:12:52.409]         {
[16:12:52.409]             ...future.startTime <- base::Sys.time()
[16:12:52.409]             {
[16:12:52.409]                 {
[16:12:52.409]                   {
[16:12:52.409]                     {
[16:12:52.409]                       {
[16:12:52.409]                         base::local({
[16:12:52.409]                           has_future <- base::requireNamespace("future", 
[16:12:52.409]                             quietly = TRUE)
[16:12:52.409]                           if (has_future) {
[16:12:52.409]                             ns <- base::getNamespace("future")
[16:12:52.409]                             version <- ns[[".package"]][["version"]]
[16:12:52.409]                             if (is.null(version)) 
[16:12:52.409]                               version <- utils::packageVersion("future")
[16:12:52.409]                           }
[16:12:52.409]                           else {
[16:12:52.409]                             version <- NULL
[16:12:52.409]                           }
[16:12:52.409]                           if (!has_future || version < "1.8.0") {
[16:12:52.409]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:52.409]                               "", base::R.version$version.string), 
[16:12:52.409]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:52.409]                                 base::R.version$platform, 8 * 
[16:12:52.409]                                   base::.Machine$sizeof.pointer), 
[16:12:52.409]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:52.409]                                 "release", "version")], collapse = " "), 
[16:12:52.409]                               hostname = base::Sys.info()[["nodename"]])
[16:12:52.409]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:52.409]                               info)
[16:12:52.409]                             info <- base::paste(info, collapse = "; ")
[16:12:52.409]                             if (!has_future) {
[16:12:52.409]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:52.409]                                 info)
[16:12:52.409]                             }
[16:12:52.409]                             else {
[16:12:52.409]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:52.409]                                 info, version)
[16:12:52.409]                             }
[16:12:52.409]                             base::stop(msg)
[16:12:52.409]                           }
[16:12:52.409]                         })
[16:12:52.409]                       }
[16:12:52.409]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:52.409]                       base::options(mc.cores = 1L)
[16:12:52.409]                     }
[16:12:52.409]                     base::local({
[16:12:52.409]                       for (pkg in "future") {
[16:12:52.409]                         base::loadNamespace(pkg)
[16:12:52.409]                         base::library(pkg, character.only = TRUE)
[16:12:52.409]                       }
[16:12:52.409]                     })
[16:12:52.409]                   }
[16:12:52.409]                   options(future.plan = NULL)
[16:12:52.409]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.409]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:52.409]                 }
[16:12:52.409]                 ...future.workdir <- getwd()
[16:12:52.409]             }
[16:12:52.409]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:52.409]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:52.409]         }
[16:12:52.409]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:52.409]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:52.409]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:52.409]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:52.409]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:52.409]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:52.409]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:52.409]             base::names(...future.oldOptions))
[16:12:52.409]     }
[16:12:52.409]     if (FALSE) {
[16:12:52.409]     }
[16:12:52.409]     else {
[16:12:52.409]         if (TRUE) {
[16:12:52.409]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:52.409]                 open = "w")
[16:12:52.409]         }
[16:12:52.409]         else {
[16:12:52.409]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:52.409]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:52.409]         }
[16:12:52.409]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:52.409]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:52.409]             base::sink(type = "output", split = FALSE)
[16:12:52.409]             base::close(...future.stdout)
[16:12:52.409]         }, add = TRUE)
[16:12:52.409]     }
[16:12:52.409]     ...future.frame <- base::sys.nframe()
[16:12:52.409]     ...future.conditions <- base::list()
[16:12:52.409]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:52.409]     if (FALSE) {
[16:12:52.409]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:52.409]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:52.409]     }
[16:12:52.409]     ...future.result <- base::tryCatch({
[16:12:52.409]         base::withCallingHandlers({
[16:12:52.409]             ...future.value <- base::withVisible(base::local({
[16:12:52.409]                 withCallingHandlers({
[16:12:52.409]                   value(a) + 1
[16:12:52.409]                 }, immediateCondition = function(cond) {
[16:12:52.409]                   save_rds <- function (object, pathname, ...) 
[16:12:52.409]                   {
[16:12:52.409]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:52.409]                     if (file_test("-f", pathname_tmp)) {
[16:12:52.409]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.409]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:52.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.409]                         fi_tmp[["mtime"]])
[16:12:52.409]                     }
[16:12:52.409]                     tryCatch({
[16:12:52.409]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:52.409]                     }, error = function(ex) {
[16:12:52.409]                       msg <- conditionMessage(ex)
[16:12:52.409]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.409]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:52.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.409]                         fi_tmp[["mtime"]], msg)
[16:12:52.409]                       ex$message <- msg
[16:12:52.409]                       stop(ex)
[16:12:52.409]                     })
[16:12:52.409]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:52.409]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:52.409]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:52.409]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.409]                       fi <- file.info(pathname)
[16:12:52.409]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:52.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.409]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:52.409]                         fi[["size"]], fi[["mtime"]])
[16:12:52.409]                       stop(msg)
[16:12:52.409]                     }
[16:12:52.409]                     invisible(pathname)
[16:12:52.409]                   }
[16:12:52.409]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:52.409]                     rootPath = tempdir()) 
[16:12:52.409]                   {
[16:12:52.409]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:52.409]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:52.409]                       tmpdir = path, fileext = ".rds")
[16:12:52.409]                     save_rds(obj, file)
[16:12:52.409]                   }
[16:12:52.409]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:52.409]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.409]                   {
[16:12:52.409]                     inherits <- base::inherits
[16:12:52.409]                     invokeRestart <- base::invokeRestart
[16:12:52.409]                     is.null <- base::is.null
[16:12:52.409]                     muffled <- FALSE
[16:12:52.409]                     if (inherits(cond, "message")) {
[16:12:52.409]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:52.409]                       if (muffled) 
[16:12:52.409]                         invokeRestart("muffleMessage")
[16:12:52.409]                     }
[16:12:52.409]                     else if (inherits(cond, "warning")) {
[16:12:52.409]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:52.409]                       if (muffled) 
[16:12:52.409]                         invokeRestart("muffleWarning")
[16:12:52.409]                     }
[16:12:52.409]                     else if (inherits(cond, "condition")) {
[16:12:52.409]                       if (!is.null(pattern)) {
[16:12:52.409]                         computeRestarts <- base::computeRestarts
[16:12:52.409]                         grepl <- base::grepl
[16:12:52.409]                         restarts <- computeRestarts(cond)
[16:12:52.409]                         for (restart in restarts) {
[16:12:52.409]                           name <- restart$name
[16:12:52.409]                           if (is.null(name)) 
[16:12:52.409]                             next
[16:12:52.409]                           if (!grepl(pattern, name)) 
[16:12:52.409]                             next
[16:12:52.409]                           invokeRestart(restart)
[16:12:52.409]                           muffled <- TRUE
[16:12:52.409]                           break
[16:12:52.409]                         }
[16:12:52.409]                       }
[16:12:52.409]                     }
[16:12:52.409]                     invisible(muffled)
[16:12:52.409]                   }
[16:12:52.409]                   muffleCondition(cond)
[16:12:52.409]                 })
[16:12:52.409]             }))
[16:12:52.409]             future::FutureResult(value = ...future.value$value, 
[16:12:52.409]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.409]                   ...future.rng), globalenv = if (FALSE) 
[16:12:52.409]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:52.409]                     ...future.globalenv.names))
[16:12:52.409]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:52.409]         }, condition = base::local({
[16:12:52.409]             c <- base::c
[16:12:52.409]             inherits <- base::inherits
[16:12:52.409]             invokeRestart <- base::invokeRestart
[16:12:52.409]             length <- base::length
[16:12:52.409]             list <- base::list
[16:12:52.409]             seq.int <- base::seq.int
[16:12:52.409]             signalCondition <- base::signalCondition
[16:12:52.409]             sys.calls <- base::sys.calls
[16:12:52.409]             `[[` <- base::`[[`
[16:12:52.409]             `+` <- base::`+`
[16:12:52.409]             `<<-` <- base::`<<-`
[16:12:52.409]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:52.409]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:52.409]                   3L)]
[16:12:52.409]             }
[16:12:52.409]             function(cond) {
[16:12:52.409]                 is_error <- inherits(cond, "error")
[16:12:52.409]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:52.409]                   NULL)
[16:12:52.409]                 if (is_error) {
[16:12:52.409]                   sessionInformation <- function() {
[16:12:52.409]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:52.409]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:52.409]                       search = base::search(), system = base::Sys.info())
[16:12:52.409]                   }
[16:12:52.409]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.409]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:52.409]                     cond$call), session = sessionInformation(), 
[16:12:52.409]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:52.409]                   signalCondition(cond)
[16:12:52.409]                 }
[16:12:52.409]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:52.409]                 "immediateCondition"))) {
[16:12:52.409]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:52.409]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.409]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:52.409]                   if (TRUE && !signal) {
[16:12:52.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.409]                     {
[16:12:52.409]                       inherits <- base::inherits
[16:12:52.409]                       invokeRestart <- base::invokeRestart
[16:12:52.409]                       is.null <- base::is.null
[16:12:52.409]                       muffled <- FALSE
[16:12:52.409]                       if (inherits(cond, "message")) {
[16:12:52.409]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.409]                         if (muffled) 
[16:12:52.409]                           invokeRestart("muffleMessage")
[16:12:52.409]                       }
[16:12:52.409]                       else if (inherits(cond, "warning")) {
[16:12:52.409]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.409]                         if (muffled) 
[16:12:52.409]                           invokeRestart("muffleWarning")
[16:12:52.409]                       }
[16:12:52.409]                       else if (inherits(cond, "condition")) {
[16:12:52.409]                         if (!is.null(pattern)) {
[16:12:52.409]                           computeRestarts <- base::computeRestarts
[16:12:52.409]                           grepl <- base::grepl
[16:12:52.409]                           restarts <- computeRestarts(cond)
[16:12:52.409]                           for (restart in restarts) {
[16:12:52.409]                             name <- restart$name
[16:12:52.409]                             if (is.null(name)) 
[16:12:52.409]                               next
[16:12:52.409]                             if (!grepl(pattern, name)) 
[16:12:52.409]                               next
[16:12:52.409]                             invokeRestart(restart)
[16:12:52.409]                             muffled <- TRUE
[16:12:52.409]                             break
[16:12:52.409]                           }
[16:12:52.409]                         }
[16:12:52.409]                       }
[16:12:52.409]                       invisible(muffled)
[16:12:52.409]                     }
[16:12:52.409]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.409]                   }
[16:12:52.409]                 }
[16:12:52.409]                 else {
[16:12:52.409]                   if (TRUE) {
[16:12:52.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.409]                     {
[16:12:52.409]                       inherits <- base::inherits
[16:12:52.409]                       invokeRestart <- base::invokeRestart
[16:12:52.409]                       is.null <- base::is.null
[16:12:52.409]                       muffled <- FALSE
[16:12:52.409]                       if (inherits(cond, "message")) {
[16:12:52.409]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.409]                         if (muffled) 
[16:12:52.409]                           invokeRestart("muffleMessage")
[16:12:52.409]                       }
[16:12:52.409]                       else if (inherits(cond, "warning")) {
[16:12:52.409]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.409]                         if (muffled) 
[16:12:52.409]                           invokeRestart("muffleWarning")
[16:12:52.409]                       }
[16:12:52.409]                       else if (inherits(cond, "condition")) {
[16:12:52.409]                         if (!is.null(pattern)) {
[16:12:52.409]                           computeRestarts <- base::computeRestarts
[16:12:52.409]                           grepl <- base::grepl
[16:12:52.409]                           restarts <- computeRestarts(cond)
[16:12:52.409]                           for (restart in restarts) {
[16:12:52.409]                             name <- restart$name
[16:12:52.409]                             if (is.null(name)) 
[16:12:52.409]                               next
[16:12:52.409]                             if (!grepl(pattern, name)) 
[16:12:52.409]                               next
[16:12:52.409]                             invokeRestart(restart)
[16:12:52.409]                             muffled <- TRUE
[16:12:52.409]                             break
[16:12:52.409]                           }
[16:12:52.409]                         }
[16:12:52.409]                       }
[16:12:52.409]                       invisible(muffled)
[16:12:52.409]                     }
[16:12:52.409]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.409]                   }
[16:12:52.409]                 }
[16:12:52.409]             }
[16:12:52.409]         }))
[16:12:52.409]     }, error = function(ex) {
[16:12:52.409]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:52.409]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.409]                 ...future.rng), started = ...future.startTime, 
[16:12:52.409]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:52.409]             version = "1.8"), class = "FutureResult")
[16:12:52.409]     }, finally = {
[16:12:52.409]         if (!identical(...future.workdir, getwd())) 
[16:12:52.409]             setwd(...future.workdir)
[16:12:52.409]         {
[16:12:52.409]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:52.409]                 ...future.oldOptions$nwarnings <- NULL
[16:12:52.409]             }
[16:12:52.409]             base::options(...future.oldOptions)
[16:12:52.409]             if (.Platform$OS.type == "windows") {
[16:12:52.409]                 old_names <- names(...future.oldEnvVars)
[16:12:52.409]                 envs <- base::Sys.getenv()
[16:12:52.409]                 names <- names(envs)
[16:12:52.409]                 common <- intersect(names, old_names)
[16:12:52.409]                 added <- setdiff(names, old_names)
[16:12:52.409]                 removed <- setdiff(old_names, names)
[16:12:52.409]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:52.409]                   envs[common]]
[16:12:52.409]                 NAMES <- toupper(changed)
[16:12:52.409]                 args <- list()
[16:12:52.409]                 for (kk in seq_along(NAMES)) {
[16:12:52.409]                   name <- changed[[kk]]
[16:12:52.409]                   NAME <- NAMES[[kk]]
[16:12:52.409]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.409]                     next
[16:12:52.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.409]                 }
[16:12:52.409]                 NAMES <- toupper(added)
[16:12:52.409]                 for (kk in seq_along(NAMES)) {
[16:12:52.409]                   name <- added[[kk]]
[16:12:52.409]                   NAME <- NAMES[[kk]]
[16:12:52.409]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.409]                     next
[16:12:52.409]                   args[[name]] <- ""
[16:12:52.409]                 }
[16:12:52.409]                 NAMES <- toupper(removed)
[16:12:52.409]                 for (kk in seq_along(NAMES)) {
[16:12:52.409]                   name <- removed[[kk]]
[16:12:52.409]                   NAME <- NAMES[[kk]]
[16:12:52.409]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.409]                     next
[16:12:52.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.409]                 }
[16:12:52.409]                 if (length(args) > 0) 
[16:12:52.409]                   base::do.call(base::Sys.setenv, args = args)
[16:12:52.409]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:52.409]             }
[16:12:52.409]             else {
[16:12:52.409]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:52.409]             }
[16:12:52.409]             {
[16:12:52.409]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:52.409]                   0L) {
[16:12:52.409]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:52.409]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:52.409]                   base::options(opts)
[16:12:52.409]                 }
[16:12:52.409]                 {
[16:12:52.409]                   {
[16:12:52.409]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:52.409]                     NULL
[16:12:52.409]                   }
[16:12:52.409]                   options(future.plan = NULL)
[16:12:52.409]                   if (is.na(NA_character_)) 
[16:12:52.409]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.409]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:52.409]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:52.409]                     envir = parent.frame()) 
[16:12:52.409]                   {
[16:12:52.409]                     default_workers <- missing(workers)
[16:12:52.409]                     if (is.function(workers)) 
[16:12:52.409]                       workers <- workers()
[16:12:52.409]                     workers <- structure(as.integer(workers), 
[16:12:52.409]                       class = class(workers))
[16:12:52.409]                     stop_if_not(is.finite(workers), workers >= 
[16:12:52.409]                       1L)
[16:12:52.409]                     if ((workers == 1L && !inherits(workers, 
[16:12:52.409]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:52.409]                       if (default_workers) 
[16:12:52.409]                         supportsMulticore(warn = TRUE)
[16:12:52.409]                       return(sequential(..., envir = envir))
[16:12:52.409]                     }
[16:12:52.409]                     oopts <- options(mc.cores = workers)
[16:12:52.409]                     on.exit(options(oopts))
[16:12:52.409]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:52.409]                       envir = envir)
[16:12:52.409]                     if (!future$lazy) 
[16:12:52.409]                       future <- run(future)
[16:12:52.409]                     invisible(future)
[16:12:52.409]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:52.409]                 }
[16:12:52.409]             }
[16:12:52.409]         }
[16:12:52.409]     })
[16:12:52.409]     if (TRUE) {
[16:12:52.409]         base::sink(type = "output", split = FALSE)
[16:12:52.409]         if (TRUE) {
[16:12:52.409]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:52.409]         }
[16:12:52.409]         else {
[16:12:52.409]             ...future.result["stdout"] <- base::list(NULL)
[16:12:52.409]         }
[16:12:52.409]         base::close(...future.stdout)
[16:12:52.409]         ...future.stdout <- NULL
[16:12:52.409]     }
[16:12:52.409]     ...future.result$conditions <- ...future.conditions
[16:12:52.409]     ...future.result$finished <- base::Sys.time()
[16:12:52.409]     ...future.result
[16:12:52.409] }
[16:12:52.412] assign_globals() ...
[16:12:52.413] List of 1
[16:12:52.413]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x56233d994cd8> 
[16:12:52.413]  - attr(*, "where")=List of 1
[16:12:52.413]   ..$ a:<environment: R_EmptyEnv> 
[16:12:52.413]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:52.413]  - attr(*, "resolved")= logi TRUE
[16:12:52.413]  - attr(*, "total_size")= num 1629776
[16:12:52.413]  - attr(*, "already-done")= logi TRUE
[16:12:52.415] - copied ‘a’ to environment
[16:12:52.416] assign_globals() ... done
[16:12:52.416] requestCore(): workers = 2
[16:12:52.418] MulticoreFuture started
[16:12:52.418] - Launch lazy future ... done
[16:12:52.418] run() for ‘MulticoreFuture’ ... done
[16:12:52.419] plan(): Setting new future strategy stack:
[16:12:52.419] List of future strategies:
[16:12:52.419] 1. sequential:
[16:12:52.419]    - args: function (..., envir = parent.frame())
[16:12:52.419]    - tweaked: FALSE
[16:12:52.419]    - call: NULL
[16:12:52.420] plan(): nbrOfWorkers() = 1
[16:12:52.423] plan(): Setting new future strategy stack:
[16:12:52.423] List of future strategies:
[16:12:52.423] 1. multicore:
[16:12:52.423]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:52.423]    - tweaked: FALSE
[16:12:52.423]    - call: plan(strategy)
[16:12:52.428] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:52.430] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:52.430] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:52.431] 
[16:12:52.431] Searching for globals ... DONE
[16:12:52.431] - globals: [0] <none>
[16:12:52.431] getGlobalsAndPackages() ... DONE
[16:12:52.432] run() for ‘Future’ ...
[16:12:52.432] - state: ‘created’
[16:12:52.432] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:52.436] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:52.439] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:52.439]   - Field: ‘label’
[16:12:52.440]   - Field: ‘local’
[16:12:52.440]   - Field: ‘owner’
[16:12:52.440]   - Field: ‘envir’
[16:12:52.440]   - Field: ‘workers’
[16:12:52.440]   - Field: ‘packages’
[16:12:52.441]   - Field: ‘gc’
[16:12:52.441]   - Field: ‘job’
[16:12:52.441]   - Field: ‘conditions’
[16:12:52.441]   - Field: ‘expr’
[16:12:52.441]   - Field: ‘uuid’
[16:12:52.441]   - Field: ‘seed’
[16:12:52.442]   - Field: ‘version’
[16:12:52.442]   - Field: ‘result’
[16:12:52.442]   - Field: ‘asynchronous’
[16:12:52.442]   - Field: ‘calls’
[16:12:52.442]   - Field: ‘globals’
[16:12:52.442]   - Field: ‘stdout’
[16:12:52.442]   - Field: ‘earlySignal’
[16:12:52.443]   - Field: ‘lazy’
[16:12:52.443]   - Field: ‘state’
[16:12:52.443] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:52.443] - Launch lazy future ...
[16:12:52.443] Packages needed by the future expression (n = 0): <none>
[16:12:52.444] Packages needed by future strategies (n = 0): <none>
[16:12:52.444] {
[16:12:52.444]     {
[16:12:52.444]         {
[16:12:52.444]             ...future.startTime <- base::Sys.time()
[16:12:52.444]             {
[16:12:52.444]                 {
[16:12:52.444]                   {
[16:12:52.444]                     {
[16:12:52.444]                       base::local({
[16:12:52.444]                         has_future <- base::requireNamespace("future", 
[16:12:52.444]                           quietly = TRUE)
[16:12:52.444]                         if (has_future) {
[16:12:52.444]                           ns <- base::getNamespace("future")
[16:12:52.444]                           version <- ns[[".package"]][["version"]]
[16:12:52.444]                           if (is.null(version)) 
[16:12:52.444]                             version <- utils::packageVersion("future")
[16:12:52.444]                         }
[16:12:52.444]                         else {
[16:12:52.444]                           version <- NULL
[16:12:52.444]                         }
[16:12:52.444]                         if (!has_future || version < "1.8.0") {
[16:12:52.444]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:52.444]                             "", base::R.version$version.string), 
[16:12:52.444]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:52.444]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:52.444]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:52.444]                               "release", "version")], collapse = " "), 
[16:12:52.444]                             hostname = base::Sys.info()[["nodename"]])
[16:12:52.444]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:52.444]                             info)
[16:12:52.444]                           info <- base::paste(info, collapse = "; ")
[16:12:52.444]                           if (!has_future) {
[16:12:52.444]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:52.444]                               info)
[16:12:52.444]                           }
[16:12:52.444]                           else {
[16:12:52.444]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:52.444]                               info, version)
[16:12:52.444]                           }
[16:12:52.444]                           base::stop(msg)
[16:12:52.444]                         }
[16:12:52.444]                       })
[16:12:52.444]                     }
[16:12:52.444]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:52.444]                     base::options(mc.cores = 1L)
[16:12:52.444]                   }
[16:12:52.444]                   options(future.plan = NULL)
[16:12:52.444]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.444]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:52.444]                 }
[16:12:52.444]                 ...future.workdir <- getwd()
[16:12:52.444]             }
[16:12:52.444]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:52.444]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:52.444]         }
[16:12:52.444]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:52.444]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:52.444]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:52.444]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:52.444]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:52.444]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:52.444]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:52.444]             base::names(...future.oldOptions))
[16:12:52.444]     }
[16:12:52.444]     if (FALSE) {
[16:12:52.444]     }
[16:12:52.444]     else {
[16:12:52.444]         if (TRUE) {
[16:12:52.444]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:52.444]                 open = "w")
[16:12:52.444]         }
[16:12:52.444]         else {
[16:12:52.444]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:52.444]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:52.444]         }
[16:12:52.444]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:52.444]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:52.444]             base::sink(type = "output", split = FALSE)
[16:12:52.444]             base::close(...future.stdout)
[16:12:52.444]         }, add = TRUE)
[16:12:52.444]     }
[16:12:52.444]     ...future.frame <- base::sys.nframe()
[16:12:52.444]     ...future.conditions <- base::list()
[16:12:52.444]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:52.444]     if (FALSE) {
[16:12:52.444]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:52.444]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:52.444]     }
[16:12:52.444]     ...future.result <- base::tryCatch({
[16:12:52.444]         base::withCallingHandlers({
[16:12:52.444]             ...future.value <- base::withVisible(base::local({
[16:12:52.444]                 withCallingHandlers({
[16:12:52.444]                   1
[16:12:52.444]                 }, immediateCondition = function(cond) {
[16:12:52.444]                   save_rds <- function (object, pathname, ...) 
[16:12:52.444]                   {
[16:12:52.444]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:52.444]                     if (file_test("-f", pathname_tmp)) {
[16:12:52.444]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.444]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:52.444]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.444]                         fi_tmp[["mtime"]])
[16:12:52.444]                     }
[16:12:52.444]                     tryCatch({
[16:12:52.444]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:52.444]                     }, error = function(ex) {
[16:12:52.444]                       msg <- conditionMessage(ex)
[16:12:52.444]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.444]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:52.444]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.444]                         fi_tmp[["mtime"]], msg)
[16:12:52.444]                       ex$message <- msg
[16:12:52.444]                       stop(ex)
[16:12:52.444]                     })
[16:12:52.444]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:52.444]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:52.444]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:52.444]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.444]                       fi <- file.info(pathname)
[16:12:52.444]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:52.444]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.444]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:52.444]                         fi[["size"]], fi[["mtime"]])
[16:12:52.444]                       stop(msg)
[16:12:52.444]                     }
[16:12:52.444]                     invisible(pathname)
[16:12:52.444]                   }
[16:12:52.444]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:52.444]                     rootPath = tempdir()) 
[16:12:52.444]                   {
[16:12:52.444]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:52.444]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:52.444]                       tmpdir = path, fileext = ".rds")
[16:12:52.444]                     save_rds(obj, file)
[16:12:52.444]                   }
[16:12:52.444]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:52.444]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.444]                   {
[16:12:52.444]                     inherits <- base::inherits
[16:12:52.444]                     invokeRestart <- base::invokeRestart
[16:12:52.444]                     is.null <- base::is.null
[16:12:52.444]                     muffled <- FALSE
[16:12:52.444]                     if (inherits(cond, "message")) {
[16:12:52.444]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:52.444]                       if (muffled) 
[16:12:52.444]                         invokeRestart("muffleMessage")
[16:12:52.444]                     }
[16:12:52.444]                     else if (inherits(cond, "warning")) {
[16:12:52.444]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:52.444]                       if (muffled) 
[16:12:52.444]                         invokeRestart("muffleWarning")
[16:12:52.444]                     }
[16:12:52.444]                     else if (inherits(cond, "condition")) {
[16:12:52.444]                       if (!is.null(pattern)) {
[16:12:52.444]                         computeRestarts <- base::computeRestarts
[16:12:52.444]                         grepl <- base::grepl
[16:12:52.444]                         restarts <- computeRestarts(cond)
[16:12:52.444]                         for (restart in restarts) {
[16:12:52.444]                           name <- restart$name
[16:12:52.444]                           if (is.null(name)) 
[16:12:52.444]                             next
[16:12:52.444]                           if (!grepl(pattern, name)) 
[16:12:52.444]                             next
[16:12:52.444]                           invokeRestart(restart)
[16:12:52.444]                           muffled <- TRUE
[16:12:52.444]                           break
[16:12:52.444]                         }
[16:12:52.444]                       }
[16:12:52.444]                     }
[16:12:52.444]                     invisible(muffled)
[16:12:52.444]                   }
[16:12:52.444]                   muffleCondition(cond)
[16:12:52.444]                 })
[16:12:52.444]             }))
[16:12:52.444]             future::FutureResult(value = ...future.value$value, 
[16:12:52.444]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.444]                   ...future.rng), globalenv = if (FALSE) 
[16:12:52.444]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:52.444]                     ...future.globalenv.names))
[16:12:52.444]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:52.444]         }, condition = base::local({
[16:12:52.444]             c <- base::c
[16:12:52.444]             inherits <- base::inherits
[16:12:52.444]             invokeRestart <- base::invokeRestart
[16:12:52.444]             length <- base::length
[16:12:52.444]             list <- base::list
[16:12:52.444]             seq.int <- base::seq.int
[16:12:52.444]             signalCondition <- base::signalCondition
[16:12:52.444]             sys.calls <- base::sys.calls
[16:12:52.444]             `[[` <- base::`[[`
[16:12:52.444]             `+` <- base::`+`
[16:12:52.444]             `<<-` <- base::`<<-`
[16:12:52.444]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:52.444]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:52.444]                   3L)]
[16:12:52.444]             }
[16:12:52.444]             function(cond) {
[16:12:52.444]                 is_error <- inherits(cond, "error")
[16:12:52.444]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:52.444]                   NULL)
[16:12:52.444]                 if (is_error) {
[16:12:52.444]                   sessionInformation <- function() {
[16:12:52.444]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:52.444]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:52.444]                       search = base::search(), system = base::Sys.info())
[16:12:52.444]                   }
[16:12:52.444]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.444]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:52.444]                     cond$call), session = sessionInformation(), 
[16:12:52.444]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:52.444]                   signalCondition(cond)
[16:12:52.444]                 }
[16:12:52.444]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:52.444]                 "immediateCondition"))) {
[16:12:52.444]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:52.444]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.444]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:52.444]                   if (TRUE && !signal) {
[16:12:52.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.444]                     {
[16:12:52.444]                       inherits <- base::inherits
[16:12:52.444]                       invokeRestart <- base::invokeRestart
[16:12:52.444]                       is.null <- base::is.null
[16:12:52.444]                       muffled <- FALSE
[16:12:52.444]                       if (inherits(cond, "message")) {
[16:12:52.444]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.444]                         if (muffled) 
[16:12:52.444]                           invokeRestart("muffleMessage")
[16:12:52.444]                       }
[16:12:52.444]                       else if (inherits(cond, "warning")) {
[16:12:52.444]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.444]                         if (muffled) 
[16:12:52.444]                           invokeRestart("muffleWarning")
[16:12:52.444]                       }
[16:12:52.444]                       else if (inherits(cond, "condition")) {
[16:12:52.444]                         if (!is.null(pattern)) {
[16:12:52.444]                           computeRestarts <- base::computeRestarts
[16:12:52.444]                           grepl <- base::grepl
[16:12:52.444]                           restarts <- computeRestarts(cond)
[16:12:52.444]                           for (restart in restarts) {
[16:12:52.444]                             name <- restart$name
[16:12:52.444]                             if (is.null(name)) 
[16:12:52.444]                               next
[16:12:52.444]                             if (!grepl(pattern, name)) 
[16:12:52.444]                               next
[16:12:52.444]                             invokeRestart(restart)
[16:12:52.444]                             muffled <- TRUE
[16:12:52.444]                             break
[16:12:52.444]                           }
[16:12:52.444]                         }
[16:12:52.444]                       }
[16:12:52.444]                       invisible(muffled)
[16:12:52.444]                     }
[16:12:52.444]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.444]                   }
[16:12:52.444]                 }
[16:12:52.444]                 else {
[16:12:52.444]                   if (TRUE) {
[16:12:52.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.444]                     {
[16:12:52.444]                       inherits <- base::inherits
[16:12:52.444]                       invokeRestart <- base::invokeRestart
[16:12:52.444]                       is.null <- base::is.null
[16:12:52.444]                       muffled <- FALSE
[16:12:52.444]                       if (inherits(cond, "message")) {
[16:12:52.444]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.444]                         if (muffled) 
[16:12:52.444]                           invokeRestart("muffleMessage")
[16:12:52.444]                       }
[16:12:52.444]                       else if (inherits(cond, "warning")) {
[16:12:52.444]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.444]                         if (muffled) 
[16:12:52.444]                           invokeRestart("muffleWarning")
[16:12:52.444]                       }
[16:12:52.444]                       else if (inherits(cond, "condition")) {
[16:12:52.444]                         if (!is.null(pattern)) {
[16:12:52.444]                           computeRestarts <- base::computeRestarts
[16:12:52.444]                           grepl <- base::grepl
[16:12:52.444]                           restarts <- computeRestarts(cond)
[16:12:52.444]                           for (restart in restarts) {
[16:12:52.444]                             name <- restart$name
[16:12:52.444]                             if (is.null(name)) 
[16:12:52.444]                               next
[16:12:52.444]                             if (!grepl(pattern, name)) 
[16:12:52.444]                               next
[16:12:52.444]                             invokeRestart(restart)
[16:12:52.444]                             muffled <- TRUE
[16:12:52.444]                             break
[16:12:52.444]                           }
[16:12:52.444]                         }
[16:12:52.444]                       }
[16:12:52.444]                       invisible(muffled)
[16:12:52.444]                     }
[16:12:52.444]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.444]                   }
[16:12:52.444]                 }
[16:12:52.444]             }
[16:12:52.444]         }))
[16:12:52.444]     }, error = function(ex) {
[16:12:52.444]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:52.444]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.444]                 ...future.rng), started = ...future.startTime, 
[16:12:52.444]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:52.444]             version = "1.8"), class = "FutureResult")
[16:12:52.444]     }, finally = {
[16:12:52.444]         if (!identical(...future.workdir, getwd())) 
[16:12:52.444]             setwd(...future.workdir)
[16:12:52.444]         {
[16:12:52.444]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:52.444]                 ...future.oldOptions$nwarnings <- NULL
[16:12:52.444]             }
[16:12:52.444]             base::options(...future.oldOptions)
[16:12:52.444]             if (.Platform$OS.type == "windows") {
[16:12:52.444]                 old_names <- names(...future.oldEnvVars)
[16:12:52.444]                 envs <- base::Sys.getenv()
[16:12:52.444]                 names <- names(envs)
[16:12:52.444]                 common <- intersect(names, old_names)
[16:12:52.444]                 added <- setdiff(names, old_names)
[16:12:52.444]                 removed <- setdiff(old_names, names)
[16:12:52.444]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:52.444]                   envs[common]]
[16:12:52.444]                 NAMES <- toupper(changed)
[16:12:52.444]                 args <- list()
[16:12:52.444]                 for (kk in seq_along(NAMES)) {
[16:12:52.444]                   name <- changed[[kk]]
[16:12:52.444]                   NAME <- NAMES[[kk]]
[16:12:52.444]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.444]                     next
[16:12:52.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.444]                 }
[16:12:52.444]                 NAMES <- toupper(added)
[16:12:52.444]                 for (kk in seq_along(NAMES)) {
[16:12:52.444]                   name <- added[[kk]]
[16:12:52.444]                   NAME <- NAMES[[kk]]
[16:12:52.444]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.444]                     next
[16:12:52.444]                   args[[name]] <- ""
[16:12:52.444]                 }
[16:12:52.444]                 NAMES <- toupper(removed)
[16:12:52.444]                 for (kk in seq_along(NAMES)) {
[16:12:52.444]                   name <- removed[[kk]]
[16:12:52.444]                   NAME <- NAMES[[kk]]
[16:12:52.444]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.444]                     next
[16:12:52.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.444]                 }
[16:12:52.444]                 if (length(args) > 0) 
[16:12:52.444]                   base::do.call(base::Sys.setenv, args = args)
[16:12:52.444]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:52.444]             }
[16:12:52.444]             else {
[16:12:52.444]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:52.444]             }
[16:12:52.444]             {
[16:12:52.444]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:52.444]                   0L) {
[16:12:52.444]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:52.444]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:52.444]                   base::options(opts)
[16:12:52.444]                 }
[16:12:52.444]                 {
[16:12:52.444]                   {
[16:12:52.444]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:52.444]                     NULL
[16:12:52.444]                   }
[16:12:52.444]                   options(future.plan = NULL)
[16:12:52.444]                   if (is.na(NA_character_)) 
[16:12:52.444]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.444]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:52.444]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:52.444]                     envir = parent.frame()) 
[16:12:52.444]                   {
[16:12:52.444]                     default_workers <- missing(workers)
[16:12:52.444]                     if (is.function(workers)) 
[16:12:52.444]                       workers <- workers()
[16:12:52.444]                     workers <- structure(as.integer(workers), 
[16:12:52.444]                       class = class(workers))
[16:12:52.444]                     stop_if_not(is.finite(workers), workers >= 
[16:12:52.444]                       1L)
[16:12:52.444]                     if ((workers == 1L && !inherits(workers, 
[16:12:52.444]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:52.444]                       if (default_workers) 
[16:12:52.444]                         supportsMulticore(warn = TRUE)
[16:12:52.444]                       return(sequential(..., envir = envir))
[16:12:52.444]                     }
[16:12:52.444]                     oopts <- options(mc.cores = workers)
[16:12:52.444]                     on.exit(options(oopts))
[16:12:52.444]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:52.444]                       envir = envir)
[16:12:52.444]                     if (!future$lazy) 
[16:12:52.444]                       future <- run(future)
[16:12:52.444]                     invisible(future)
[16:12:52.444]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:52.444]                 }
[16:12:52.444]             }
[16:12:52.444]         }
[16:12:52.444]     })
[16:12:52.444]     if (TRUE) {
[16:12:52.444]         base::sink(type = "output", split = FALSE)
[16:12:52.444]         if (TRUE) {
[16:12:52.444]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:52.444]         }
[16:12:52.444]         else {
[16:12:52.444]             ...future.result["stdout"] <- base::list(NULL)
[16:12:52.444]         }
[16:12:52.444]         base::close(...future.stdout)
[16:12:52.444]         ...future.stdout <- NULL
[16:12:52.444]     }
[16:12:52.444]     ...future.result$conditions <- ...future.conditions
[16:12:52.444]     ...future.result$finished <- base::Sys.time()
[16:12:52.444]     ...future.result
[16:12:52.444] }
[16:12:52.447] requestCore(): workers = 2
[16:12:52.449] MulticoreFuture started
[16:12:52.450] - Launch lazy future ... done
[16:12:52.450] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:52.451] plan(): Setting new future strategy stack:
[16:12:52.451] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:52.451] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:52.451] List of future strategies:
[16:12:52.451] 1. sequential:
[16:12:52.451]    - args: function (..., envir = parent.frame())
[16:12:52.451]    - tweaked: FALSE
[16:12:52.451]    - call: NULL
[16:12:52.452] plan(): nbrOfWorkers() = 1
[16:12:52.453] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:52.454] Searching for globals ... DONE
[16:12:52.454] plan(): Setting new future strategy stack:
[16:12:52.454] Resolving globals: TRUE
[16:12:52.454] List of future strategies:
[16:12:52.454] 1. multicore:
[16:12:52.454]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:52.454]    - tweaked: FALSE
[16:12:52.454]    - call: plan(strategy)
[16:12:52.455] Resolving any globals that are futures ...
[16:12:52.455] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:52.456] Resolving any globals that are futures ... DONE
[16:12:52.457] Resolving futures part of globals (recursively) ...
[16:12:52.458] resolve() on list ...
[16:12:52.458]  recursive: 99
[16:12:52.458]  length: 1
[16:12:52.459]  elements: ‘a’
[16:12:52.461] plan(): nbrOfWorkers() = 2
[16:12:52.461] Future #1
[16:12:52.463] A MulticoreFuture was resolved
[16:12:52.463]  length: 0 (resolved future 1)
[16:12:52.463] resolve() on list ... DONE
[16:12:52.464] - globals: [1] ‘a’
[16:12:52.464] Resolving futures part of globals (recursively) ... DONE
[16:12:52.467] The total size of the 1 globals is 1.55 MiB (1629776 bytes)
[16:12:52.468] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[16:12:52.468] - globals: [1] ‘a’
[16:12:52.468] - packages: [1] ‘future’
[16:12:52.468] getGlobalsAndPackages() ... DONE
[16:12:52.468] run() for ‘Future’ ...
[16:12:52.469] - state: ‘created’
[16:12:52.469] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:52.473] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:52.473] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:52.473]   - Field: ‘label’
[16:12:52.473]   - Field: ‘local’
[16:12:52.474]   - Field: ‘owner’
[16:12:52.474]   - Field: ‘envir’
[16:12:52.474]   - Field: ‘workers’
[16:12:52.474]   - Field: ‘packages’
[16:12:52.474]   - Field: ‘gc’
[16:12:52.474]   - Field: ‘job’
[16:12:52.474]   - Field: ‘conditions’
[16:12:52.474]   - Field: ‘expr’
[16:12:52.474]   - Field: ‘uuid’
[16:12:52.475]   - Field: ‘seed’
[16:12:52.475]   - Field: ‘version’
[16:12:52.475]   - Field: ‘result’
[16:12:52.475]   - Field: ‘asynchronous’
[16:12:52.475]   - Field: ‘calls’
[16:12:52.475]   - Field: ‘globals’
[16:12:52.475]   - Field: ‘stdout’
[16:12:52.475]   - Field: ‘earlySignal’
[16:12:52.475]   - Field: ‘lazy’
[16:12:52.476]   - Field: ‘state’
[16:12:52.476] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:52.476] - Launch lazy future ...
[16:12:52.476] Packages needed by the future expression (n = 1): ‘future’
[16:12:52.476] Packages needed by future strategies (n = 0): <none>
[16:12:52.477] {
[16:12:52.477]     {
[16:12:52.477]         {
[16:12:52.477]             ...future.startTime <- base::Sys.time()
[16:12:52.477]             {
[16:12:52.477]                 {
[16:12:52.477]                   {
[16:12:52.477]                     {
[16:12:52.477]                       {
[16:12:52.477]                         base::local({
[16:12:52.477]                           has_future <- base::requireNamespace("future", 
[16:12:52.477]                             quietly = TRUE)
[16:12:52.477]                           if (has_future) {
[16:12:52.477]                             ns <- base::getNamespace("future")
[16:12:52.477]                             version <- ns[[".package"]][["version"]]
[16:12:52.477]                             if (is.null(version)) 
[16:12:52.477]                               version <- utils::packageVersion("future")
[16:12:52.477]                           }
[16:12:52.477]                           else {
[16:12:52.477]                             version <- NULL
[16:12:52.477]                           }
[16:12:52.477]                           if (!has_future || version < "1.8.0") {
[16:12:52.477]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:52.477]                               "", base::R.version$version.string), 
[16:12:52.477]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:52.477]                                 base::R.version$platform, 8 * 
[16:12:52.477]                                   base::.Machine$sizeof.pointer), 
[16:12:52.477]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:52.477]                                 "release", "version")], collapse = " "), 
[16:12:52.477]                               hostname = base::Sys.info()[["nodename"]])
[16:12:52.477]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:52.477]                               info)
[16:12:52.477]                             info <- base::paste(info, collapse = "; ")
[16:12:52.477]                             if (!has_future) {
[16:12:52.477]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:52.477]                                 info)
[16:12:52.477]                             }
[16:12:52.477]                             else {
[16:12:52.477]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:52.477]                                 info, version)
[16:12:52.477]                             }
[16:12:52.477]                             base::stop(msg)
[16:12:52.477]                           }
[16:12:52.477]                         })
[16:12:52.477]                       }
[16:12:52.477]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:52.477]                       base::options(mc.cores = 1L)
[16:12:52.477]                     }
[16:12:52.477]                     base::local({
[16:12:52.477]                       for (pkg in "future") {
[16:12:52.477]                         base::loadNamespace(pkg)
[16:12:52.477]                         base::library(pkg, character.only = TRUE)
[16:12:52.477]                       }
[16:12:52.477]                     })
[16:12:52.477]                   }
[16:12:52.477]                   options(future.plan = NULL)
[16:12:52.477]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.477]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:52.477]                 }
[16:12:52.477]                 ...future.workdir <- getwd()
[16:12:52.477]             }
[16:12:52.477]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:52.477]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:52.477]         }
[16:12:52.477]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:52.477]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:52.477]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:52.477]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:52.477]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:52.477]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:52.477]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:52.477]             base::names(...future.oldOptions))
[16:12:52.477]     }
[16:12:52.477]     if (FALSE) {
[16:12:52.477]     }
[16:12:52.477]     else {
[16:12:52.477]         if (TRUE) {
[16:12:52.477]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:52.477]                 open = "w")
[16:12:52.477]         }
[16:12:52.477]         else {
[16:12:52.477]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:52.477]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:52.477]         }
[16:12:52.477]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:52.477]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:52.477]             base::sink(type = "output", split = FALSE)
[16:12:52.477]             base::close(...future.stdout)
[16:12:52.477]         }, add = TRUE)
[16:12:52.477]     }
[16:12:52.477]     ...future.frame <- base::sys.nframe()
[16:12:52.477]     ...future.conditions <- base::list()
[16:12:52.477]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:52.477]     if (FALSE) {
[16:12:52.477]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:52.477]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:52.477]     }
[16:12:52.477]     ...future.result <- base::tryCatch({
[16:12:52.477]         base::withCallingHandlers({
[16:12:52.477]             ...future.value <- base::withVisible(base::local({
[16:12:52.477]                 withCallingHandlers({
[16:12:52.477]                   value(a) + 1
[16:12:52.477]                 }, immediateCondition = function(cond) {
[16:12:52.477]                   save_rds <- function (object, pathname, ...) 
[16:12:52.477]                   {
[16:12:52.477]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:52.477]                     if (file_test("-f", pathname_tmp)) {
[16:12:52.477]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.477]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:52.477]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.477]                         fi_tmp[["mtime"]])
[16:12:52.477]                     }
[16:12:52.477]                     tryCatch({
[16:12:52.477]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:52.477]                     }, error = function(ex) {
[16:12:52.477]                       msg <- conditionMessage(ex)
[16:12:52.477]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.477]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:52.477]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.477]                         fi_tmp[["mtime"]], msg)
[16:12:52.477]                       ex$message <- msg
[16:12:52.477]                       stop(ex)
[16:12:52.477]                     })
[16:12:52.477]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:52.477]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:52.477]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:52.477]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.477]                       fi <- file.info(pathname)
[16:12:52.477]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:52.477]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.477]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:52.477]                         fi[["size"]], fi[["mtime"]])
[16:12:52.477]                       stop(msg)
[16:12:52.477]                     }
[16:12:52.477]                     invisible(pathname)
[16:12:52.477]                   }
[16:12:52.477]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:52.477]                     rootPath = tempdir()) 
[16:12:52.477]                   {
[16:12:52.477]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:52.477]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:52.477]                       tmpdir = path, fileext = ".rds")
[16:12:52.477]                     save_rds(obj, file)
[16:12:52.477]                   }
[16:12:52.477]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:52.477]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.477]                   {
[16:12:52.477]                     inherits <- base::inherits
[16:12:52.477]                     invokeRestart <- base::invokeRestart
[16:12:52.477]                     is.null <- base::is.null
[16:12:52.477]                     muffled <- FALSE
[16:12:52.477]                     if (inherits(cond, "message")) {
[16:12:52.477]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:52.477]                       if (muffled) 
[16:12:52.477]                         invokeRestart("muffleMessage")
[16:12:52.477]                     }
[16:12:52.477]                     else if (inherits(cond, "warning")) {
[16:12:52.477]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:52.477]                       if (muffled) 
[16:12:52.477]                         invokeRestart("muffleWarning")
[16:12:52.477]                     }
[16:12:52.477]                     else if (inherits(cond, "condition")) {
[16:12:52.477]                       if (!is.null(pattern)) {
[16:12:52.477]                         computeRestarts <- base::computeRestarts
[16:12:52.477]                         grepl <- base::grepl
[16:12:52.477]                         restarts <- computeRestarts(cond)
[16:12:52.477]                         for (restart in restarts) {
[16:12:52.477]                           name <- restart$name
[16:12:52.477]                           if (is.null(name)) 
[16:12:52.477]                             next
[16:12:52.477]                           if (!grepl(pattern, name)) 
[16:12:52.477]                             next
[16:12:52.477]                           invokeRestart(restart)
[16:12:52.477]                           muffled <- TRUE
[16:12:52.477]                           break
[16:12:52.477]                         }
[16:12:52.477]                       }
[16:12:52.477]                     }
[16:12:52.477]                     invisible(muffled)
[16:12:52.477]                   }
[16:12:52.477]                   muffleCondition(cond)
[16:12:52.477]                 })
[16:12:52.477]             }))
[16:12:52.477]             future::FutureResult(value = ...future.value$value, 
[16:12:52.477]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.477]                   ...future.rng), globalenv = if (FALSE) 
[16:12:52.477]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:52.477]                     ...future.globalenv.names))
[16:12:52.477]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:52.477]         }, condition = base::local({
[16:12:52.477]             c <- base::c
[16:12:52.477]             inherits <- base::inherits
[16:12:52.477]             invokeRestart <- base::invokeRestart
[16:12:52.477]             length <- base::length
[16:12:52.477]             list <- base::list
[16:12:52.477]             seq.int <- base::seq.int
[16:12:52.477]             signalCondition <- base::signalCondition
[16:12:52.477]             sys.calls <- base::sys.calls
[16:12:52.477]             `[[` <- base::`[[`
[16:12:52.477]             `+` <- base::`+`
[16:12:52.477]             `<<-` <- base::`<<-`
[16:12:52.477]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:52.477]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:52.477]                   3L)]
[16:12:52.477]             }
[16:12:52.477]             function(cond) {
[16:12:52.477]                 is_error <- inherits(cond, "error")
[16:12:52.477]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:52.477]                   NULL)
[16:12:52.477]                 if (is_error) {
[16:12:52.477]                   sessionInformation <- function() {
[16:12:52.477]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:52.477]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:52.477]                       search = base::search(), system = base::Sys.info())
[16:12:52.477]                   }
[16:12:52.477]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.477]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:52.477]                     cond$call), session = sessionInformation(), 
[16:12:52.477]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:52.477]                   signalCondition(cond)
[16:12:52.477]                 }
[16:12:52.477]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:52.477]                 "immediateCondition"))) {
[16:12:52.477]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:52.477]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.477]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:52.477]                   if (TRUE && !signal) {
[16:12:52.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.477]                     {
[16:12:52.477]                       inherits <- base::inherits
[16:12:52.477]                       invokeRestart <- base::invokeRestart
[16:12:52.477]                       is.null <- base::is.null
[16:12:52.477]                       muffled <- FALSE
[16:12:52.477]                       if (inherits(cond, "message")) {
[16:12:52.477]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.477]                         if (muffled) 
[16:12:52.477]                           invokeRestart("muffleMessage")
[16:12:52.477]                       }
[16:12:52.477]                       else if (inherits(cond, "warning")) {
[16:12:52.477]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.477]                         if (muffled) 
[16:12:52.477]                           invokeRestart("muffleWarning")
[16:12:52.477]                       }
[16:12:52.477]                       else if (inherits(cond, "condition")) {
[16:12:52.477]                         if (!is.null(pattern)) {
[16:12:52.477]                           computeRestarts <- base::computeRestarts
[16:12:52.477]                           grepl <- base::grepl
[16:12:52.477]                           restarts <- computeRestarts(cond)
[16:12:52.477]                           for (restart in restarts) {
[16:12:52.477]                             name <- restart$name
[16:12:52.477]                             if (is.null(name)) 
[16:12:52.477]                               next
[16:12:52.477]                             if (!grepl(pattern, name)) 
[16:12:52.477]                               next
[16:12:52.477]                             invokeRestart(restart)
[16:12:52.477]                             muffled <- TRUE
[16:12:52.477]                             break
[16:12:52.477]                           }
[16:12:52.477]                         }
[16:12:52.477]                       }
[16:12:52.477]                       invisible(muffled)
[16:12:52.477]                     }
[16:12:52.477]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.477]                   }
[16:12:52.477]                 }
[16:12:52.477]                 else {
[16:12:52.477]                   if (TRUE) {
[16:12:52.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.477]                     {
[16:12:52.477]                       inherits <- base::inherits
[16:12:52.477]                       invokeRestart <- base::invokeRestart
[16:12:52.477]                       is.null <- base::is.null
[16:12:52.477]                       muffled <- FALSE
[16:12:52.477]                       if (inherits(cond, "message")) {
[16:12:52.477]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.477]                         if (muffled) 
[16:12:52.477]                           invokeRestart("muffleMessage")
[16:12:52.477]                       }
[16:12:52.477]                       else if (inherits(cond, "warning")) {
[16:12:52.477]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.477]                         if (muffled) 
[16:12:52.477]                           invokeRestart("muffleWarning")
[16:12:52.477]                       }
[16:12:52.477]                       else if (inherits(cond, "condition")) {
[16:12:52.477]                         if (!is.null(pattern)) {
[16:12:52.477]                           computeRestarts <- base::computeRestarts
[16:12:52.477]                           grepl <- base::grepl
[16:12:52.477]                           restarts <- computeRestarts(cond)
[16:12:52.477]                           for (restart in restarts) {
[16:12:52.477]                             name <- restart$name
[16:12:52.477]                             if (is.null(name)) 
[16:12:52.477]                               next
[16:12:52.477]                             if (!grepl(pattern, name)) 
[16:12:52.477]                               next
[16:12:52.477]                             invokeRestart(restart)
[16:12:52.477]                             muffled <- TRUE
[16:12:52.477]                             break
[16:12:52.477]                           }
[16:12:52.477]                         }
[16:12:52.477]                       }
[16:12:52.477]                       invisible(muffled)
[16:12:52.477]                     }
[16:12:52.477]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.477]                   }
[16:12:52.477]                 }
[16:12:52.477]             }
[16:12:52.477]         }))
[16:12:52.477]     }, error = function(ex) {
[16:12:52.477]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:52.477]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.477]                 ...future.rng), started = ...future.startTime, 
[16:12:52.477]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:52.477]             version = "1.8"), class = "FutureResult")
[16:12:52.477]     }, finally = {
[16:12:52.477]         if (!identical(...future.workdir, getwd())) 
[16:12:52.477]             setwd(...future.workdir)
[16:12:52.477]         {
[16:12:52.477]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:52.477]                 ...future.oldOptions$nwarnings <- NULL
[16:12:52.477]             }
[16:12:52.477]             base::options(...future.oldOptions)
[16:12:52.477]             if (.Platform$OS.type == "windows") {
[16:12:52.477]                 old_names <- names(...future.oldEnvVars)
[16:12:52.477]                 envs <- base::Sys.getenv()
[16:12:52.477]                 names <- names(envs)
[16:12:52.477]                 common <- intersect(names, old_names)
[16:12:52.477]                 added <- setdiff(names, old_names)
[16:12:52.477]                 removed <- setdiff(old_names, names)
[16:12:52.477]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:52.477]                   envs[common]]
[16:12:52.477]                 NAMES <- toupper(changed)
[16:12:52.477]                 args <- list()
[16:12:52.477]                 for (kk in seq_along(NAMES)) {
[16:12:52.477]                   name <- changed[[kk]]
[16:12:52.477]                   NAME <- NAMES[[kk]]
[16:12:52.477]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.477]                     next
[16:12:52.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.477]                 }
[16:12:52.477]                 NAMES <- toupper(added)
[16:12:52.477]                 for (kk in seq_along(NAMES)) {
[16:12:52.477]                   name <- added[[kk]]
[16:12:52.477]                   NAME <- NAMES[[kk]]
[16:12:52.477]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.477]                     next
[16:12:52.477]                   args[[name]] <- ""
[16:12:52.477]                 }
[16:12:52.477]                 NAMES <- toupper(removed)
[16:12:52.477]                 for (kk in seq_along(NAMES)) {
[16:12:52.477]                   name <- removed[[kk]]
[16:12:52.477]                   NAME <- NAMES[[kk]]
[16:12:52.477]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.477]                     next
[16:12:52.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.477]                 }
[16:12:52.477]                 if (length(args) > 0) 
[16:12:52.477]                   base::do.call(base::Sys.setenv, args = args)
[16:12:52.477]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:52.477]             }
[16:12:52.477]             else {
[16:12:52.477]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:52.477]             }
[16:12:52.477]             {
[16:12:52.477]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:52.477]                   0L) {
[16:12:52.477]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:52.477]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:52.477]                   base::options(opts)
[16:12:52.477]                 }
[16:12:52.477]                 {
[16:12:52.477]                   {
[16:12:52.477]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:52.477]                     NULL
[16:12:52.477]                   }
[16:12:52.477]                   options(future.plan = NULL)
[16:12:52.477]                   if (is.na(NA_character_)) 
[16:12:52.477]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.477]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:52.477]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:52.477]                     envir = parent.frame()) 
[16:12:52.477]                   {
[16:12:52.477]                     default_workers <- missing(workers)
[16:12:52.477]                     if (is.function(workers)) 
[16:12:52.477]                       workers <- workers()
[16:12:52.477]                     workers <- structure(as.integer(workers), 
[16:12:52.477]                       class = class(workers))
[16:12:52.477]                     stop_if_not(is.finite(workers), workers >= 
[16:12:52.477]                       1L)
[16:12:52.477]                     if ((workers == 1L && !inherits(workers, 
[16:12:52.477]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:52.477]                       if (default_workers) 
[16:12:52.477]                         supportsMulticore(warn = TRUE)
[16:12:52.477]                       return(sequential(..., envir = envir))
[16:12:52.477]                     }
[16:12:52.477]                     oopts <- options(mc.cores = workers)
[16:12:52.477]                     on.exit(options(oopts))
[16:12:52.477]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:52.477]                       envir = envir)
[16:12:52.477]                     if (!future$lazy) 
[16:12:52.477]                       future <- run(future)
[16:12:52.477]                     invisible(future)
[16:12:52.477]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:52.477]                 }
[16:12:52.477]             }
[16:12:52.477]         }
[16:12:52.477]     })
[16:12:52.477]     if (TRUE) {
[16:12:52.477]         base::sink(type = "output", split = FALSE)
[16:12:52.477]         if (TRUE) {
[16:12:52.477]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:52.477]         }
[16:12:52.477]         else {
[16:12:52.477]             ...future.result["stdout"] <- base::list(NULL)
[16:12:52.477]         }
[16:12:52.477]         base::close(...future.stdout)
[16:12:52.477]         ...future.stdout <- NULL
[16:12:52.477]     }
[16:12:52.477]     ...future.result$conditions <- ...future.conditions
[16:12:52.477]     ...future.result$finished <- base::Sys.time()
[16:12:52.477]     ...future.result
[16:12:52.477] }
[16:12:52.480] assign_globals() ...
[16:12:52.480] List of 1
[16:12:52.480]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x56233d9625d8> 
[16:12:52.480]  - attr(*, "where")=List of 1
[16:12:52.480]   ..$ a:<environment: R_EmptyEnv> 
[16:12:52.480]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:52.480]  - attr(*, "resolved")= logi TRUE
[16:12:52.480]  - attr(*, "total_size")= num 1629776
[16:12:52.480]  - attr(*, "already-done")= logi TRUE
[16:12:52.483] - copied ‘a’ to environment
[16:12:52.483] assign_globals() ... done
[16:12:52.483] requestCore(): workers = 2
[16:12:52.486] MulticoreFuture started
[16:12:52.486] - Launch lazy future ... done
[16:12:52.486] run() for ‘MulticoreFuture’ ... done
[16:12:52.487] plan(): Setting new future strategy stack:
[16:12:52.488] List of future strategies:
[16:12:52.488] 1. sequential:
[16:12:52.488]    - args: function (..., envir = parent.frame())
[16:12:52.488]    - tweaked: FALSE
[16:12:52.488]    - call: NULL
[16:12:52.489] plan(): nbrOfWorkers() = 1
[16:12:52.491] plan(): Setting new future strategy stack:
[16:12:52.491] List of future strategies:
[16:12:52.491] 1. multicore:
[16:12:52.491]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:52.491]    - tweaked: FALSE
[16:12:52.491]    - call: plan(strategy)
[16:12:52.497] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:52.504] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:52.504] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:52.505] 
[16:12:52.505] Searching for globals ... DONE
[16:12:52.505] - globals: [0] <none>
[16:12:52.505] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:52.506] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:52.506] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:52.510] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:52.510] Searching for globals ... DONE
[16:12:52.510] Resolving globals: TRUE
[16:12:52.511] Resolving any globals that are futures ...
[16:12:52.511] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:52.511] Resolving any globals that are futures ... DONE
[16:12:52.512] Resolving futures part of globals (recursively) ...
[16:12:52.512] resolve() on list ...
[16:12:52.512]  recursive: 99
[16:12:52.512]  length: 1
[16:12:52.513]  elements: ‘a’
[16:12:52.513] run() for ‘Future’ ...
[16:12:52.513] - state: ‘created’
[16:12:52.513] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:52.517] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:52.518] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:52.518]   - Field: ‘label’
[16:12:52.518]   - Field: ‘local’
[16:12:52.518]   - Field: ‘owner’
[16:12:52.518]   - Field: ‘envir’
[16:12:52.518]   - Field: ‘workers’
[16:12:52.518]   - Field: ‘packages’
[16:12:52.519]   - Field: ‘gc’
[16:12:52.519]   - Field: ‘job’
[16:12:52.519]   - Field: ‘conditions’
[16:12:52.519]   - Field: ‘expr’
[16:12:52.519]   - Field: ‘uuid’
[16:12:52.519]   - Field: ‘seed’
[16:12:52.519]   - Field: ‘version’
[16:12:52.519]   - Field: ‘result’
[16:12:52.520]   - Field: ‘asynchronous’
[16:12:52.520]   - Field: ‘calls’
[16:12:52.520]   - Field: ‘globals’
[16:12:52.520]   - Field: ‘stdout’
[16:12:52.520]   - Field: ‘earlySignal’
[16:12:52.520]   - Field: ‘lazy’
[16:12:52.520]   - Field: ‘state’
[16:12:52.521] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:52.521] - Launch lazy future ...
[16:12:52.521] Packages needed by the future expression (n = 0): <none>
[16:12:52.521] Packages needed by future strategies (n = 0): <none>
[16:12:52.522] {
[16:12:52.522]     {
[16:12:52.522]         {
[16:12:52.522]             ...future.startTime <- base::Sys.time()
[16:12:52.522]             {
[16:12:52.522]                 {
[16:12:52.522]                   {
[16:12:52.522]                     {
[16:12:52.522]                       base::local({
[16:12:52.522]                         has_future <- base::requireNamespace("future", 
[16:12:52.522]                           quietly = TRUE)
[16:12:52.522]                         if (has_future) {
[16:12:52.522]                           ns <- base::getNamespace("future")
[16:12:52.522]                           version <- ns[[".package"]][["version"]]
[16:12:52.522]                           if (is.null(version)) 
[16:12:52.522]                             version <- utils::packageVersion("future")
[16:12:52.522]                         }
[16:12:52.522]                         else {
[16:12:52.522]                           version <- NULL
[16:12:52.522]                         }
[16:12:52.522]                         if (!has_future || version < "1.8.0") {
[16:12:52.522]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:52.522]                             "", base::R.version$version.string), 
[16:12:52.522]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:52.522]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:52.522]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:52.522]                               "release", "version")], collapse = " "), 
[16:12:52.522]                             hostname = base::Sys.info()[["nodename"]])
[16:12:52.522]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:52.522]                             info)
[16:12:52.522]                           info <- base::paste(info, collapse = "; ")
[16:12:52.522]                           if (!has_future) {
[16:12:52.522]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:52.522]                               info)
[16:12:52.522]                           }
[16:12:52.522]                           else {
[16:12:52.522]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:52.522]                               info, version)
[16:12:52.522]                           }
[16:12:52.522]                           base::stop(msg)
[16:12:52.522]                         }
[16:12:52.522]                       })
[16:12:52.522]                     }
[16:12:52.522]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:52.522]                     base::options(mc.cores = 1L)
[16:12:52.522]                   }
[16:12:52.522]                   options(future.plan = NULL)
[16:12:52.522]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.522]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:52.522]                 }
[16:12:52.522]                 ...future.workdir <- getwd()
[16:12:52.522]             }
[16:12:52.522]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:52.522]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:52.522]         }
[16:12:52.522]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:52.522]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:52.522]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:52.522]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:52.522]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:52.522]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:52.522]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:52.522]             base::names(...future.oldOptions))
[16:12:52.522]     }
[16:12:52.522]     if (FALSE) {
[16:12:52.522]     }
[16:12:52.522]     else {
[16:12:52.522]         if (TRUE) {
[16:12:52.522]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:52.522]                 open = "w")
[16:12:52.522]         }
[16:12:52.522]         else {
[16:12:52.522]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:52.522]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:52.522]         }
[16:12:52.522]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:52.522]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:52.522]             base::sink(type = "output", split = FALSE)
[16:12:52.522]             base::close(...future.stdout)
[16:12:52.522]         }, add = TRUE)
[16:12:52.522]     }
[16:12:52.522]     ...future.frame <- base::sys.nframe()
[16:12:52.522]     ...future.conditions <- base::list()
[16:12:52.522]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:52.522]     if (FALSE) {
[16:12:52.522]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:52.522]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:52.522]     }
[16:12:52.522]     ...future.result <- base::tryCatch({
[16:12:52.522]         base::withCallingHandlers({
[16:12:52.522]             ...future.value <- base::withVisible(base::local({
[16:12:52.522]                 withCallingHandlers({
[16:12:52.522]                   1
[16:12:52.522]                 }, immediateCondition = function(cond) {
[16:12:52.522]                   save_rds <- function (object, pathname, ...) 
[16:12:52.522]                   {
[16:12:52.522]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:52.522]                     if (file_test("-f", pathname_tmp)) {
[16:12:52.522]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.522]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:52.522]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.522]                         fi_tmp[["mtime"]])
[16:12:52.522]                     }
[16:12:52.522]                     tryCatch({
[16:12:52.522]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:52.522]                     }, error = function(ex) {
[16:12:52.522]                       msg <- conditionMessage(ex)
[16:12:52.522]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.522]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:52.522]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.522]                         fi_tmp[["mtime"]], msg)
[16:12:52.522]                       ex$message <- msg
[16:12:52.522]                       stop(ex)
[16:12:52.522]                     })
[16:12:52.522]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:52.522]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:52.522]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:52.522]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.522]                       fi <- file.info(pathname)
[16:12:52.522]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:52.522]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.522]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:52.522]                         fi[["size"]], fi[["mtime"]])
[16:12:52.522]                       stop(msg)
[16:12:52.522]                     }
[16:12:52.522]                     invisible(pathname)
[16:12:52.522]                   }
[16:12:52.522]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:52.522]                     rootPath = tempdir()) 
[16:12:52.522]                   {
[16:12:52.522]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:52.522]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:52.522]                       tmpdir = path, fileext = ".rds")
[16:12:52.522]                     save_rds(obj, file)
[16:12:52.522]                   }
[16:12:52.522]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:52.522]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.522]                   {
[16:12:52.522]                     inherits <- base::inherits
[16:12:52.522]                     invokeRestart <- base::invokeRestart
[16:12:52.522]                     is.null <- base::is.null
[16:12:52.522]                     muffled <- FALSE
[16:12:52.522]                     if (inherits(cond, "message")) {
[16:12:52.522]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:52.522]                       if (muffled) 
[16:12:52.522]                         invokeRestart("muffleMessage")
[16:12:52.522]                     }
[16:12:52.522]                     else if (inherits(cond, "warning")) {
[16:12:52.522]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:52.522]                       if (muffled) 
[16:12:52.522]                         invokeRestart("muffleWarning")
[16:12:52.522]                     }
[16:12:52.522]                     else if (inherits(cond, "condition")) {
[16:12:52.522]                       if (!is.null(pattern)) {
[16:12:52.522]                         computeRestarts <- base::computeRestarts
[16:12:52.522]                         grepl <- base::grepl
[16:12:52.522]                         restarts <- computeRestarts(cond)
[16:12:52.522]                         for (restart in restarts) {
[16:12:52.522]                           name <- restart$name
[16:12:52.522]                           if (is.null(name)) 
[16:12:52.522]                             next
[16:12:52.522]                           if (!grepl(pattern, name)) 
[16:12:52.522]                             next
[16:12:52.522]                           invokeRestart(restart)
[16:12:52.522]                           muffled <- TRUE
[16:12:52.522]                           break
[16:12:52.522]                         }
[16:12:52.522]                       }
[16:12:52.522]                     }
[16:12:52.522]                     invisible(muffled)
[16:12:52.522]                   }
[16:12:52.522]                   muffleCondition(cond)
[16:12:52.522]                 })
[16:12:52.522]             }))
[16:12:52.522]             future::FutureResult(value = ...future.value$value, 
[16:12:52.522]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.522]                   ...future.rng), globalenv = if (FALSE) 
[16:12:52.522]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:52.522]                     ...future.globalenv.names))
[16:12:52.522]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:52.522]         }, condition = base::local({
[16:12:52.522]             c <- base::c
[16:12:52.522]             inherits <- base::inherits
[16:12:52.522]             invokeRestart <- base::invokeRestart
[16:12:52.522]             length <- base::length
[16:12:52.522]             list <- base::list
[16:12:52.522]             seq.int <- base::seq.int
[16:12:52.522]             signalCondition <- base::signalCondition
[16:12:52.522]             sys.calls <- base::sys.calls
[16:12:52.522]             `[[` <- base::`[[`
[16:12:52.522]             `+` <- base::`+`
[16:12:52.522]             `<<-` <- base::`<<-`
[16:12:52.522]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:52.522]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:52.522]                   3L)]
[16:12:52.522]             }
[16:12:52.522]             function(cond) {
[16:12:52.522]                 is_error <- inherits(cond, "error")
[16:12:52.522]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:52.522]                   NULL)
[16:12:52.522]                 if (is_error) {
[16:12:52.522]                   sessionInformation <- function() {
[16:12:52.522]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:52.522]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:52.522]                       search = base::search(), system = base::Sys.info())
[16:12:52.522]                   }
[16:12:52.522]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.522]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:52.522]                     cond$call), session = sessionInformation(), 
[16:12:52.522]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:52.522]                   signalCondition(cond)
[16:12:52.522]                 }
[16:12:52.522]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:52.522]                 "immediateCondition"))) {
[16:12:52.522]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:52.522]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.522]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:52.522]                   if (TRUE && !signal) {
[16:12:52.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.522]                     {
[16:12:52.522]                       inherits <- base::inherits
[16:12:52.522]                       invokeRestart <- base::invokeRestart
[16:12:52.522]                       is.null <- base::is.null
[16:12:52.522]                       muffled <- FALSE
[16:12:52.522]                       if (inherits(cond, "message")) {
[16:12:52.522]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.522]                         if (muffled) 
[16:12:52.522]                           invokeRestart("muffleMessage")
[16:12:52.522]                       }
[16:12:52.522]                       else if (inherits(cond, "warning")) {
[16:12:52.522]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.522]                         if (muffled) 
[16:12:52.522]                           invokeRestart("muffleWarning")
[16:12:52.522]                       }
[16:12:52.522]                       else if (inherits(cond, "condition")) {
[16:12:52.522]                         if (!is.null(pattern)) {
[16:12:52.522]                           computeRestarts <- base::computeRestarts
[16:12:52.522]                           grepl <- base::grepl
[16:12:52.522]                           restarts <- computeRestarts(cond)
[16:12:52.522]                           for (restart in restarts) {
[16:12:52.522]                             name <- restart$name
[16:12:52.522]                             if (is.null(name)) 
[16:12:52.522]                               next
[16:12:52.522]                             if (!grepl(pattern, name)) 
[16:12:52.522]                               next
[16:12:52.522]                             invokeRestart(restart)
[16:12:52.522]                             muffled <- TRUE
[16:12:52.522]                             break
[16:12:52.522]                           }
[16:12:52.522]                         }
[16:12:52.522]                       }
[16:12:52.522]                       invisible(muffled)
[16:12:52.522]                     }
[16:12:52.522]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.522]                   }
[16:12:52.522]                 }
[16:12:52.522]                 else {
[16:12:52.522]                   if (TRUE) {
[16:12:52.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.522]                     {
[16:12:52.522]                       inherits <- base::inherits
[16:12:52.522]                       invokeRestart <- base::invokeRestart
[16:12:52.522]                       is.null <- base::is.null
[16:12:52.522]                       muffled <- FALSE
[16:12:52.522]                       if (inherits(cond, "message")) {
[16:12:52.522]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.522]                         if (muffled) 
[16:12:52.522]                           invokeRestart("muffleMessage")
[16:12:52.522]                       }
[16:12:52.522]                       else if (inherits(cond, "warning")) {
[16:12:52.522]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.522]                         if (muffled) 
[16:12:52.522]                           invokeRestart("muffleWarning")
[16:12:52.522]                       }
[16:12:52.522]                       else if (inherits(cond, "condition")) {
[16:12:52.522]                         if (!is.null(pattern)) {
[16:12:52.522]                           computeRestarts <- base::computeRestarts
[16:12:52.522]                           grepl <- base::grepl
[16:12:52.522]                           restarts <- computeRestarts(cond)
[16:12:52.522]                           for (restart in restarts) {
[16:12:52.522]                             name <- restart$name
[16:12:52.522]                             if (is.null(name)) 
[16:12:52.522]                               next
[16:12:52.522]                             if (!grepl(pattern, name)) 
[16:12:52.522]                               next
[16:12:52.522]                             invokeRestart(restart)
[16:12:52.522]                             muffled <- TRUE
[16:12:52.522]                             break
[16:12:52.522]                           }
[16:12:52.522]                         }
[16:12:52.522]                       }
[16:12:52.522]                       invisible(muffled)
[16:12:52.522]                     }
[16:12:52.522]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.522]                   }
[16:12:52.522]                 }
[16:12:52.522]             }
[16:12:52.522]         }))
[16:12:52.522]     }, error = function(ex) {
[16:12:52.522]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:52.522]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.522]                 ...future.rng), started = ...future.startTime, 
[16:12:52.522]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:52.522]             version = "1.8"), class = "FutureResult")
[16:12:52.522]     }, finally = {
[16:12:52.522]         if (!identical(...future.workdir, getwd())) 
[16:12:52.522]             setwd(...future.workdir)
[16:12:52.522]         {
[16:12:52.522]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:52.522]                 ...future.oldOptions$nwarnings <- NULL
[16:12:52.522]             }
[16:12:52.522]             base::options(...future.oldOptions)
[16:12:52.522]             if (.Platform$OS.type == "windows") {
[16:12:52.522]                 old_names <- names(...future.oldEnvVars)
[16:12:52.522]                 envs <- base::Sys.getenv()
[16:12:52.522]                 names <- names(envs)
[16:12:52.522]                 common <- intersect(names, old_names)
[16:12:52.522]                 added <- setdiff(names, old_names)
[16:12:52.522]                 removed <- setdiff(old_names, names)
[16:12:52.522]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:52.522]                   envs[common]]
[16:12:52.522]                 NAMES <- toupper(changed)
[16:12:52.522]                 args <- list()
[16:12:52.522]                 for (kk in seq_along(NAMES)) {
[16:12:52.522]                   name <- changed[[kk]]
[16:12:52.522]                   NAME <- NAMES[[kk]]
[16:12:52.522]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.522]                     next
[16:12:52.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.522]                 }
[16:12:52.522]                 NAMES <- toupper(added)
[16:12:52.522]                 for (kk in seq_along(NAMES)) {
[16:12:52.522]                   name <- added[[kk]]
[16:12:52.522]                   NAME <- NAMES[[kk]]
[16:12:52.522]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.522]                     next
[16:12:52.522]                   args[[name]] <- ""
[16:12:52.522]                 }
[16:12:52.522]                 NAMES <- toupper(removed)
[16:12:52.522]                 for (kk in seq_along(NAMES)) {
[16:12:52.522]                   name <- removed[[kk]]
[16:12:52.522]                   NAME <- NAMES[[kk]]
[16:12:52.522]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.522]                     next
[16:12:52.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.522]                 }
[16:12:52.522]                 if (length(args) > 0) 
[16:12:52.522]                   base::do.call(base::Sys.setenv, args = args)
[16:12:52.522]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:52.522]             }
[16:12:52.522]             else {
[16:12:52.522]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:52.522]             }
[16:12:52.522]             {
[16:12:52.522]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:52.522]                   0L) {
[16:12:52.522]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:52.522]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:52.522]                   base::options(opts)
[16:12:52.522]                 }
[16:12:52.522]                 {
[16:12:52.522]                   {
[16:12:52.522]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:52.522]                     NULL
[16:12:52.522]                   }
[16:12:52.522]                   options(future.plan = NULL)
[16:12:52.522]                   if (is.na(NA_character_)) 
[16:12:52.522]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.522]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:52.522]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:52.522]                     envir = parent.frame()) 
[16:12:52.522]                   {
[16:12:52.522]                     default_workers <- missing(workers)
[16:12:52.522]                     if (is.function(workers)) 
[16:12:52.522]                       workers <- workers()
[16:12:52.522]                     workers <- structure(as.integer(workers), 
[16:12:52.522]                       class = class(workers))
[16:12:52.522]                     stop_if_not(is.finite(workers), workers >= 
[16:12:52.522]                       1L)
[16:12:52.522]                     if ((workers == 1L && !inherits(workers, 
[16:12:52.522]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:52.522]                       if (default_workers) 
[16:12:52.522]                         supportsMulticore(warn = TRUE)
[16:12:52.522]                       return(sequential(..., envir = envir))
[16:12:52.522]                     }
[16:12:52.522]                     oopts <- options(mc.cores = workers)
[16:12:52.522]                     on.exit(options(oopts))
[16:12:52.522]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:52.522]                       envir = envir)
[16:12:52.522]                     if (!future$lazy) 
[16:12:52.522]                       future <- run(future)
[16:12:52.522]                     invisible(future)
[16:12:52.522]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:52.522]                 }
[16:12:52.522]             }
[16:12:52.522]         }
[16:12:52.522]     })
[16:12:52.522]     if (TRUE) {
[16:12:52.522]         base::sink(type = "output", split = FALSE)
[16:12:52.522]         if (TRUE) {
[16:12:52.522]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:52.522]         }
[16:12:52.522]         else {
[16:12:52.522]             ...future.result["stdout"] <- base::list(NULL)
[16:12:52.522]         }
[16:12:52.522]         base::close(...future.stdout)
[16:12:52.522]         ...future.stdout <- NULL
[16:12:52.522]     }
[16:12:52.522]     ...future.result$conditions <- ...future.conditions
[16:12:52.522]     ...future.result$finished <- base::Sys.time()
[16:12:52.522]     ...future.result
[16:12:52.522] }
[16:12:52.525] requestCore(): workers = 2
[16:12:52.528] MulticoreFuture started
[16:12:52.529] - Launch lazy future ... done
[16:12:52.529] run() for ‘MulticoreFuture’ ... done
[16:12:52.529] plan(): Setting new future strategy stack:
[16:12:52.530] List of future strategies:
[16:12:52.530] 1. sequential:
[16:12:52.530]    - args: function (..., envir = parent.frame())
[16:12:52.530]    - tweaked: FALSE
[16:12:52.530]    - call: NULL
[16:12:52.531] plan(): nbrOfWorkers() = 1
[16:12:52.534] plan(): Setting new future strategy stack:
[16:12:52.534] List of future strategies:
[16:12:52.534] 1. multicore:
[16:12:52.534]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:52.534]    - tweaked: FALSE
[16:12:52.534]    - call: plan(strategy)
[16:12:52.540] plan(): nbrOfWorkers() = 2
[16:12:52.551] Future #1
[16:12:52.552] A MulticoreFuture was resolved
[16:12:52.552]  length: 0 (resolved future 1)
[16:12:52.552] resolve() on list ... DONE
[16:12:52.553] - globals: [1] ‘a’
[16:12:52.553] Resolving futures part of globals (recursively) ... DONE
[16:12:52.556] The total size of the 1 globals is 1.55 MiB (1629944 bytes)
[16:12:52.556] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[16:12:52.557] - globals: [1] ‘a’
[16:12:52.557] - packages: [1] ‘future’
[16:12:52.557] getGlobalsAndPackages() ... DONE
[16:12:52.557] run() for ‘Future’ ...
[16:12:52.557] - state: ‘created’
[16:12:52.558] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:52.561] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:52.562] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:52.562]   - Field: ‘label’
[16:12:52.562]   - Field: ‘local’
[16:12:52.562]   - Field: ‘owner’
[16:12:52.562]   - Field: ‘envir’
[16:12:52.562]   - Field: ‘workers’
[16:12:52.562]   - Field: ‘packages’
[16:12:52.562]   - Field: ‘gc’
[16:12:52.563]   - Field: ‘job’
[16:12:52.563]   - Field: ‘conditions’
[16:12:52.563]   - Field: ‘expr’
[16:12:52.563]   - Field: ‘uuid’
[16:12:52.563]   - Field: ‘seed’
[16:12:52.563]   - Field: ‘version’
[16:12:52.563]   - Field: ‘result’
[16:12:52.563]   - Field: ‘asynchronous’
[16:12:52.563]   - Field: ‘calls’
[16:12:52.564]   - Field: ‘globals’
[16:12:52.564]   - Field: ‘stdout’
[16:12:52.564]   - Field: ‘earlySignal’
[16:12:52.564]   - Field: ‘lazy’
[16:12:52.564]   - Field: ‘state’
[16:12:52.564] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:52.564] - Launch lazy future ...
[16:12:52.565] Packages needed by the future expression (n = 1): ‘future’
[16:12:52.565] Packages needed by future strategies (n = 0): <none>
[16:12:52.565] {
[16:12:52.565]     {
[16:12:52.565]         {
[16:12:52.565]             ...future.startTime <- base::Sys.time()
[16:12:52.565]             {
[16:12:52.565]                 {
[16:12:52.565]                   {
[16:12:52.565]                     {
[16:12:52.565]                       {
[16:12:52.565]                         base::local({
[16:12:52.565]                           has_future <- base::requireNamespace("future", 
[16:12:52.565]                             quietly = TRUE)
[16:12:52.565]                           if (has_future) {
[16:12:52.565]                             ns <- base::getNamespace("future")
[16:12:52.565]                             version <- ns[[".package"]][["version"]]
[16:12:52.565]                             if (is.null(version)) 
[16:12:52.565]                               version <- utils::packageVersion("future")
[16:12:52.565]                           }
[16:12:52.565]                           else {
[16:12:52.565]                             version <- NULL
[16:12:52.565]                           }
[16:12:52.565]                           if (!has_future || version < "1.8.0") {
[16:12:52.565]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:52.565]                               "", base::R.version$version.string), 
[16:12:52.565]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:52.565]                                 base::R.version$platform, 8 * 
[16:12:52.565]                                   base::.Machine$sizeof.pointer), 
[16:12:52.565]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:52.565]                                 "release", "version")], collapse = " "), 
[16:12:52.565]                               hostname = base::Sys.info()[["nodename"]])
[16:12:52.565]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:52.565]                               info)
[16:12:52.565]                             info <- base::paste(info, collapse = "; ")
[16:12:52.565]                             if (!has_future) {
[16:12:52.565]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:52.565]                                 info)
[16:12:52.565]                             }
[16:12:52.565]                             else {
[16:12:52.565]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:52.565]                                 info, version)
[16:12:52.565]                             }
[16:12:52.565]                             base::stop(msg)
[16:12:52.565]                           }
[16:12:52.565]                         })
[16:12:52.565]                       }
[16:12:52.565]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:52.565]                       base::options(mc.cores = 1L)
[16:12:52.565]                     }
[16:12:52.565]                     base::local({
[16:12:52.565]                       for (pkg in "future") {
[16:12:52.565]                         base::loadNamespace(pkg)
[16:12:52.565]                         base::library(pkg, character.only = TRUE)
[16:12:52.565]                       }
[16:12:52.565]                     })
[16:12:52.565]                   }
[16:12:52.565]                   options(future.plan = NULL)
[16:12:52.565]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.565]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:52.565]                 }
[16:12:52.565]                 ...future.workdir <- getwd()
[16:12:52.565]             }
[16:12:52.565]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:52.565]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:52.565]         }
[16:12:52.565]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:52.565]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:52.565]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:52.565]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:52.565]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:52.565]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:52.565]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:52.565]             base::names(...future.oldOptions))
[16:12:52.565]     }
[16:12:52.565]     if (FALSE) {
[16:12:52.565]     }
[16:12:52.565]     else {
[16:12:52.565]         if (TRUE) {
[16:12:52.565]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:52.565]                 open = "w")
[16:12:52.565]         }
[16:12:52.565]         else {
[16:12:52.565]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:52.565]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:52.565]         }
[16:12:52.565]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:52.565]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:52.565]             base::sink(type = "output", split = FALSE)
[16:12:52.565]             base::close(...future.stdout)
[16:12:52.565]         }, add = TRUE)
[16:12:52.565]     }
[16:12:52.565]     ...future.frame <- base::sys.nframe()
[16:12:52.565]     ...future.conditions <- base::list()
[16:12:52.565]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:52.565]     if (FALSE) {
[16:12:52.565]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:52.565]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:52.565]     }
[16:12:52.565]     ...future.result <- base::tryCatch({
[16:12:52.565]         base::withCallingHandlers({
[16:12:52.565]             ...future.value <- base::withVisible(base::local({
[16:12:52.565]                 withCallingHandlers({
[16:12:52.565]                   value(a) + 1
[16:12:52.565]                 }, immediateCondition = function(cond) {
[16:12:52.565]                   save_rds <- function (object, pathname, ...) 
[16:12:52.565]                   {
[16:12:52.565]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:52.565]                     if (file_test("-f", pathname_tmp)) {
[16:12:52.565]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.565]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:52.565]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.565]                         fi_tmp[["mtime"]])
[16:12:52.565]                     }
[16:12:52.565]                     tryCatch({
[16:12:52.565]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:52.565]                     }, error = function(ex) {
[16:12:52.565]                       msg <- conditionMessage(ex)
[16:12:52.565]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.565]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:52.565]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.565]                         fi_tmp[["mtime"]], msg)
[16:12:52.565]                       ex$message <- msg
[16:12:52.565]                       stop(ex)
[16:12:52.565]                     })
[16:12:52.565]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:52.565]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:52.565]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:52.565]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.565]                       fi <- file.info(pathname)
[16:12:52.565]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:52.565]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.565]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:52.565]                         fi[["size"]], fi[["mtime"]])
[16:12:52.565]                       stop(msg)
[16:12:52.565]                     }
[16:12:52.565]                     invisible(pathname)
[16:12:52.565]                   }
[16:12:52.565]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:52.565]                     rootPath = tempdir()) 
[16:12:52.565]                   {
[16:12:52.565]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:52.565]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:52.565]                       tmpdir = path, fileext = ".rds")
[16:12:52.565]                     save_rds(obj, file)
[16:12:52.565]                   }
[16:12:52.565]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:52.565]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.565]                   {
[16:12:52.565]                     inherits <- base::inherits
[16:12:52.565]                     invokeRestart <- base::invokeRestart
[16:12:52.565]                     is.null <- base::is.null
[16:12:52.565]                     muffled <- FALSE
[16:12:52.565]                     if (inherits(cond, "message")) {
[16:12:52.565]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:52.565]                       if (muffled) 
[16:12:52.565]                         invokeRestart("muffleMessage")
[16:12:52.565]                     }
[16:12:52.565]                     else if (inherits(cond, "warning")) {
[16:12:52.565]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:52.565]                       if (muffled) 
[16:12:52.565]                         invokeRestart("muffleWarning")
[16:12:52.565]                     }
[16:12:52.565]                     else if (inherits(cond, "condition")) {
[16:12:52.565]                       if (!is.null(pattern)) {
[16:12:52.565]                         computeRestarts <- base::computeRestarts
[16:12:52.565]                         grepl <- base::grepl
[16:12:52.565]                         restarts <- computeRestarts(cond)
[16:12:52.565]                         for (restart in restarts) {
[16:12:52.565]                           name <- restart$name
[16:12:52.565]                           if (is.null(name)) 
[16:12:52.565]                             next
[16:12:52.565]                           if (!grepl(pattern, name)) 
[16:12:52.565]                             next
[16:12:52.565]                           invokeRestart(restart)
[16:12:52.565]                           muffled <- TRUE
[16:12:52.565]                           break
[16:12:52.565]                         }
[16:12:52.565]                       }
[16:12:52.565]                     }
[16:12:52.565]                     invisible(muffled)
[16:12:52.565]                   }
[16:12:52.565]                   muffleCondition(cond)
[16:12:52.565]                 })
[16:12:52.565]             }))
[16:12:52.565]             future::FutureResult(value = ...future.value$value, 
[16:12:52.565]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.565]                   ...future.rng), globalenv = if (FALSE) 
[16:12:52.565]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:52.565]                     ...future.globalenv.names))
[16:12:52.565]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:52.565]         }, condition = base::local({
[16:12:52.565]             c <- base::c
[16:12:52.565]             inherits <- base::inherits
[16:12:52.565]             invokeRestart <- base::invokeRestart
[16:12:52.565]             length <- base::length
[16:12:52.565]             list <- base::list
[16:12:52.565]             seq.int <- base::seq.int
[16:12:52.565]             signalCondition <- base::signalCondition
[16:12:52.565]             sys.calls <- base::sys.calls
[16:12:52.565]             `[[` <- base::`[[`
[16:12:52.565]             `+` <- base::`+`
[16:12:52.565]             `<<-` <- base::`<<-`
[16:12:52.565]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:52.565]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:52.565]                   3L)]
[16:12:52.565]             }
[16:12:52.565]             function(cond) {
[16:12:52.565]                 is_error <- inherits(cond, "error")
[16:12:52.565]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:52.565]                   NULL)
[16:12:52.565]                 if (is_error) {
[16:12:52.565]                   sessionInformation <- function() {
[16:12:52.565]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:52.565]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:52.565]                       search = base::search(), system = base::Sys.info())
[16:12:52.565]                   }
[16:12:52.565]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.565]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:52.565]                     cond$call), session = sessionInformation(), 
[16:12:52.565]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:52.565]                   signalCondition(cond)
[16:12:52.565]                 }
[16:12:52.565]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:52.565]                 "immediateCondition"))) {
[16:12:52.565]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:52.565]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.565]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:52.565]                   if (TRUE && !signal) {
[16:12:52.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.565]                     {
[16:12:52.565]                       inherits <- base::inherits
[16:12:52.565]                       invokeRestart <- base::invokeRestart
[16:12:52.565]                       is.null <- base::is.null
[16:12:52.565]                       muffled <- FALSE
[16:12:52.565]                       if (inherits(cond, "message")) {
[16:12:52.565]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.565]                         if (muffled) 
[16:12:52.565]                           invokeRestart("muffleMessage")
[16:12:52.565]                       }
[16:12:52.565]                       else if (inherits(cond, "warning")) {
[16:12:52.565]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.565]                         if (muffled) 
[16:12:52.565]                           invokeRestart("muffleWarning")
[16:12:52.565]                       }
[16:12:52.565]                       else if (inherits(cond, "condition")) {
[16:12:52.565]                         if (!is.null(pattern)) {
[16:12:52.565]                           computeRestarts <- base::computeRestarts
[16:12:52.565]                           grepl <- base::grepl
[16:12:52.565]                           restarts <- computeRestarts(cond)
[16:12:52.565]                           for (restart in restarts) {
[16:12:52.565]                             name <- restart$name
[16:12:52.565]                             if (is.null(name)) 
[16:12:52.565]                               next
[16:12:52.565]                             if (!grepl(pattern, name)) 
[16:12:52.565]                               next
[16:12:52.565]                             invokeRestart(restart)
[16:12:52.565]                             muffled <- TRUE
[16:12:52.565]                             break
[16:12:52.565]                           }
[16:12:52.565]                         }
[16:12:52.565]                       }
[16:12:52.565]                       invisible(muffled)
[16:12:52.565]                     }
[16:12:52.565]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.565]                   }
[16:12:52.565]                 }
[16:12:52.565]                 else {
[16:12:52.565]                   if (TRUE) {
[16:12:52.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.565]                     {
[16:12:52.565]                       inherits <- base::inherits
[16:12:52.565]                       invokeRestart <- base::invokeRestart
[16:12:52.565]                       is.null <- base::is.null
[16:12:52.565]                       muffled <- FALSE
[16:12:52.565]                       if (inherits(cond, "message")) {
[16:12:52.565]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.565]                         if (muffled) 
[16:12:52.565]                           invokeRestart("muffleMessage")
[16:12:52.565]                       }
[16:12:52.565]                       else if (inherits(cond, "warning")) {
[16:12:52.565]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.565]                         if (muffled) 
[16:12:52.565]                           invokeRestart("muffleWarning")
[16:12:52.565]                       }
[16:12:52.565]                       else if (inherits(cond, "condition")) {
[16:12:52.565]                         if (!is.null(pattern)) {
[16:12:52.565]                           computeRestarts <- base::computeRestarts
[16:12:52.565]                           grepl <- base::grepl
[16:12:52.565]                           restarts <- computeRestarts(cond)
[16:12:52.565]                           for (restart in restarts) {
[16:12:52.565]                             name <- restart$name
[16:12:52.565]                             if (is.null(name)) 
[16:12:52.565]                               next
[16:12:52.565]                             if (!grepl(pattern, name)) 
[16:12:52.565]                               next
[16:12:52.565]                             invokeRestart(restart)
[16:12:52.565]                             muffled <- TRUE
[16:12:52.565]                             break
[16:12:52.565]                           }
[16:12:52.565]                         }
[16:12:52.565]                       }
[16:12:52.565]                       invisible(muffled)
[16:12:52.565]                     }
[16:12:52.565]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.565]                   }
[16:12:52.565]                 }
[16:12:52.565]             }
[16:12:52.565]         }))
[16:12:52.565]     }, error = function(ex) {
[16:12:52.565]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:52.565]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.565]                 ...future.rng), started = ...future.startTime, 
[16:12:52.565]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:52.565]             version = "1.8"), class = "FutureResult")
[16:12:52.565]     }, finally = {
[16:12:52.565]         if (!identical(...future.workdir, getwd())) 
[16:12:52.565]             setwd(...future.workdir)
[16:12:52.565]         {
[16:12:52.565]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:52.565]                 ...future.oldOptions$nwarnings <- NULL
[16:12:52.565]             }
[16:12:52.565]             base::options(...future.oldOptions)
[16:12:52.565]             if (.Platform$OS.type == "windows") {
[16:12:52.565]                 old_names <- names(...future.oldEnvVars)
[16:12:52.565]                 envs <- base::Sys.getenv()
[16:12:52.565]                 names <- names(envs)
[16:12:52.565]                 common <- intersect(names, old_names)
[16:12:52.565]                 added <- setdiff(names, old_names)
[16:12:52.565]                 removed <- setdiff(old_names, names)
[16:12:52.565]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:52.565]                   envs[common]]
[16:12:52.565]                 NAMES <- toupper(changed)
[16:12:52.565]                 args <- list()
[16:12:52.565]                 for (kk in seq_along(NAMES)) {
[16:12:52.565]                   name <- changed[[kk]]
[16:12:52.565]                   NAME <- NAMES[[kk]]
[16:12:52.565]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.565]                     next
[16:12:52.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.565]                 }
[16:12:52.565]                 NAMES <- toupper(added)
[16:12:52.565]                 for (kk in seq_along(NAMES)) {
[16:12:52.565]                   name <- added[[kk]]
[16:12:52.565]                   NAME <- NAMES[[kk]]
[16:12:52.565]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.565]                     next
[16:12:52.565]                   args[[name]] <- ""
[16:12:52.565]                 }
[16:12:52.565]                 NAMES <- toupper(removed)
[16:12:52.565]                 for (kk in seq_along(NAMES)) {
[16:12:52.565]                   name <- removed[[kk]]
[16:12:52.565]                   NAME <- NAMES[[kk]]
[16:12:52.565]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.565]                     next
[16:12:52.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.565]                 }
[16:12:52.565]                 if (length(args) > 0) 
[16:12:52.565]                   base::do.call(base::Sys.setenv, args = args)
[16:12:52.565]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:52.565]             }
[16:12:52.565]             else {
[16:12:52.565]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:52.565]             }
[16:12:52.565]             {
[16:12:52.565]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:52.565]                   0L) {
[16:12:52.565]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:52.565]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:52.565]                   base::options(opts)
[16:12:52.565]                 }
[16:12:52.565]                 {
[16:12:52.565]                   {
[16:12:52.565]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:52.565]                     NULL
[16:12:52.565]                   }
[16:12:52.565]                   options(future.plan = NULL)
[16:12:52.565]                   if (is.na(NA_character_)) 
[16:12:52.565]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.565]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:52.565]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:52.565]                     envir = parent.frame()) 
[16:12:52.565]                   {
[16:12:52.565]                     default_workers <- missing(workers)
[16:12:52.565]                     if (is.function(workers)) 
[16:12:52.565]                       workers <- workers()
[16:12:52.565]                     workers <- structure(as.integer(workers), 
[16:12:52.565]                       class = class(workers))
[16:12:52.565]                     stop_if_not(is.finite(workers), workers >= 
[16:12:52.565]                       1L)
[16:12:52.565]                     if ((workers == 1L && !inherits(workers, 
[16:12:52.565]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:52.565]                       if (default_workers) 
[16:12:52.565]                         supportsMulticore(warn = TRUE)
[16:12:52.565]                       return(sequential(..., envir = envir))
[16:12:52.565]                     }
[16:12:52.565]                     oopts <- options(mc.cores = workers)
[16:12:52.565]                     on.exit(options(oopts))
[16:12:52.565]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:52.565]                       envir = envir)
[16:12:52.565]                     if (!future$lazy) 
[16:12:52.565]                       future <- run(future)
[16:12:52.565]                     invisible(future)
[16:12:52.565]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:52.565]                 }
[16:12:52.565]             }
[16:12:52.565]         }
[16:12:52.565]     })
[16:12:52.565]     if (TRUE) {
[16:12:52.565]         base::sink(type = "output", split = FALSE)
[16:12:52.565]         if (TRUE) {
[16:12:52.565]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:52.565]         }
[16:12:52.565]         else {
[16:12:52.565]             ...future.result["stdout"] <- base::list(NULL)
[16:12:52.565]         }
[16:12:52.565]         base::close(...future.stdout)
[16:12:52.565]         ...future.stdout <- NULL
[16:12:52.565]     }
[16:12:52.565]     ...future.result$conditions <- ...future.conditions
[16:12:52.565]     ...future.result$finished <- base::Sys.time()
[16:12:52.565]     ...future.result
[16:12:52.565] }
[16:12:52.568] assign_globals() ...
[16:12:52.569] List of 1
[16:12:52.569]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x56233d9dde60> 
[16:12:52.569]  - attr(*, "where")=List of 1
[16:12:52.569]   ..$ a:<environment: R_EmptyEnv> 
[16:12:52.569]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:52.569]  - attr(*, "resolved")= logi TRUE
[16:12:52.569]  - attr(*, "total_size")= num 1629944
[16:12:52.569]  - attr(*, "already-done")= logi TRUE
[16:12:52.572] - copied ‘a’ to environment
[16:12:52.572] assign_globals() ... done
[16:12:52.572] requestCore(): workers = 2
[16:12:52.574] MulticoreFuture started
[16:12:52.574] - Launch lazy future ... done
[16:12:52.575] run() for ‘MulticoreFuture’ ... done
[16:12:52.575] plan(): Setting new future strategy stack:
[16:12:52.576] List of future strategies:
[16:12:52.576] 1. sequential:
[16:12:52.576]    - args: function (..., envir = parent.frame())
[16:12:52.576]    - tweaked: FALSE
[16:12:52.576]    - call: NULL
[16:12:52.577] plan(): nbrOfWorkers() = 1
[16:12:52.579] plan(): Setting new future strategy stack:
[16:12:52.579] List of future strategies:
[16:12:52.579] 1. multicore:
[16:12:52.579]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:52.579]    - tweaked: FALSE
[16:12:52.579]    - call: plan(strategy)
[16:12:52.590] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:52.592] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:52.592] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:52.593] 
[16:12:52.593] Searching for globals ... DONE
[16:12:52.593] - globals: [0] <none>
[16:12:52.593] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:52.594] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:52.597] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:52.598] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:52.599] Searching for globals ... DONE
[16:12:52.599] Resolving globals: TRUE
[16:12:52.599] Resolving any globals that are futures ...
[16:12:52.599] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:52.599] Resolving any globals that are futures ... DONE
[16:12:52.600] Resolving futures part of globals (recursively) ...
[16:12:52.600] resolve() on list ...
[16:12:52.600]  recursive: 99
[16:12:52.600]  length: 1
[16:12:52.600]  elements: ‘a’
[16:12:52.601] run() for ‘Future’ ...
[16:12:52.601] - state: ‘created’
[16:12:52.601] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:52.605] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:52.605] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:52.605]   - Field: ‘label’
[16:12:52.606]   - Field: ‘local’
[16:12:52.606]   - Field: ‘owner’
[16:12:52.606]   - Field: ‘envir’
[16:12:52.606]   - Field: ‘workers’
[16:12:52.606]   - Field: ‘packages’
[16:12:52.606]   - Field: ‘gc’
[16:12:52.606]   - Field: ‘job’
[16:12:52.606]   - Field: ‘conditions’
[16:12:52.607]   - Field: ‘expr’
[16:12:52.607]   - Field: ‘uuid’
[16:12:52.607]   - Field: ‘seed’
[16:12:52.607]   - Field: ‘version’
[16:12:52.607]   - Field: ‘result’
[16:12:52.607]   - Field: ‘asynchronous’
[16:12:52.608]   - Field: ‘calls’
[16:12:52.608]   - Field: ‘globals’
[16:12:52.608]   - Field: ‘stdout’
[16:12:52.608]   - Field: ‘earlySignal’
[16:12:52.608]   - Field: ‘lazy’
[16:12:52.608]   - Field: ‘state’
[16:12:52.608] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:52.609] - Launch lazy future ...
[16:12:52.609] Packages needed by the future expression (n = 0): <none>
[16:12:52.609] Packages needed by future strategies (n = 0): <none>
[16:12:52.610] {
[16:12:52.610]     {
[16:12:52.610]         {
[16:12:52.610]             ...future.startTime <- base::Sys.time()
[16:12:52.610]             {
[16:12:52.610]                 {
[16:12:52.610]                   {
[16:12:52.610]                     {
[16:12:52.610]                       base::local({
[16:12:52.610]                         has_future <- base::requireNamespace("future", 
[16:12:52.610]                           quietly = TRUE)
[16:12:52.610]                         if (has_future) {
[16:12:52.610]                           ns <- base::getNamespace("future")
[16:12:52.610]                           version <- ns[[".package"]][["version"]]
[16:12:52.610]                           if (is.null(version)) 
[16:12:52.610]                             version <- utils::packageVersion("future")
[16:12:52.610]                         }
[16:12:52.610]                         else {
[16:12:52.610]                           version <- NULL
[16:12:52.610]                         }
[16:12:52.610]                         if (!has_future || version < "1.8.0") {
[16:12:52.610]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:52.610]                             "", base::R.version$version.string), 
[16:12:52.610]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:52.610]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:52.610]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:52.610]                               "release", "version")], collapse = " "), 
[16:12:52.610]                             hostname = base::Sys.info()[["nodename"]])
[16:12:52.610]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:52.610]                             info)
[16:12:52.610]                           info <- base::paste(info, collapse = "; ")
[16:12:52.610]                           if (!has_future) {
[16:12:52.610]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:52.610]                               info)
[16:12:52.610]                           }
[16:12:52.610]                           else {
[16:12:52.610]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:52.610]                               info, version)
[16:12:52.610]                           }
[16:12:52.610]                           base::stop(msg)
[16:12:52.610]                         }
[16:12:52.610]                       })
[16:12:52.610]                     }
[16:12:52.610]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:52.610]                     base::options(mc.cores = 1L)
[16:12:52.610]                   }
[16:12:52.610]                   options(future.plan = NULL)
[16:12:52.610]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.610]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:52.610]                 }
[16:12:52.610]                 ...future.workdir <- getwd()
[16:12:52.610]             }
[16:12:52.610]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:52.610]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:52.610]         }
[16:12:52.610]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:52.610]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:52.610]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:52.610]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:52.610]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:52.610]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:52.610]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:52.610]             base::names(...future.oldOptions))
[16:12:52.610]     }
[16:12:52.610]     if (FALSE) {
[16:12:52.610]     }
[16:12:52.610]     else {
[16:12:52.610]         if (TRUE) {
[16:12:52.610]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:52.610]                 open = "w")
[16:12:52.610]         }
[16:12:52.610]         else {
[16:12:52.610]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:52.610]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:52.610]         }
[16:12:52.610]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:52.610]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:52.610]             base::sink(type = "output", split = FALSE)
[16:12:52.610]             base::close(...future.stdout)
[16:12:52.610]         }, add = TRUE)
[16:12:52.610]     }
[16:12:52.610]     ...future.frame <- base::sys.nframe()
[16:12:52.610]     ...future.conditions <- base::list()
[16:12:52.610]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:52.610]     if (FALSE) {
[16:12:52.610]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:52.610]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:52.610]     }
[16:12:52.610]     ...future.result <- base::tryCatch({
[16:12:52.610]         base::withCallingHandlers({
[16:12:52.610]             ...future.value <- base::withVisible(base::local({
[16:12:52.610]                 withCallingHandlers({
[16:12:52.610]                   1
[16:12:52.610]                 }, immediateCondition = function(cond) {
[16:12:52.610]                   save_rds <- function (object, pathname, ...) 
[16:12:52.610]                   {
[16:12:52.610]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:52.610]                     if (file_test("-f", pathname_tmp)) {
[16:12:52.610]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.610]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:52.610]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.610]                         fi_tmp[["mtime"]])
[16:12:52.610]                     }
[16:12:52.610]                     tryCatch({
[16:12:52.610]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:52.610]                     }, error = function(ex) {
[16:12:52.610]                       msg <- conditionMessage(ex)
[16:12:52.610]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.610]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:52.610]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.610]                         fi_tmp[["mtime"]], msg)
[16:12:52.610]                       ex$message <- msg
[16:12:52.610]                       stop(ex)
[16:12:52.610]                     })
[16:12:52.610]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:52.610]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:52.610]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:52.610]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.610]                       fi <- file.info(pathname)
[16:12:52.610]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:52.610]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.610]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:52.610]                         fi[["size"]], fi[["mtime"]])
[16:12:52.610]                       stop(msg)
[16:12:52.610]                     }
[16:12:52.610]                     invisible(pathname)
[16:12:52.610]                   }
[16:12:52.610]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:52.610]                     rootPath = tempdir()) 
[16:12:52.610]                   {
[16:12:52.610]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:52.610]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:52.610]                       tmpdir = path, fileext = ".rds")
[16:12:52.610]                     save_rds(obj, file)
[16:12:52.610]                   }
[16:12:52.610]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:52.610]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.610]                   {
[16:12:52.610]                     inherits <- base::inherits
[16:12:52.610]                     invokeRestart <- base::invokeRestart
[16:12:52.610]                     is.null <- base::is.null
[16:12:52.610]                     muffled <- FALSE
[16:12:52.610]                     if (inherits(cond, "message")) {
[16:12:52.610]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:52.610]                       if (muffled) 
[16:12:52.610]                         invokeRestart("muffleMessage")
[16:12:52.610]                     }
[16:12:52.610]                     else if (inherits(cond, "warning")) {
[16:12:52.610]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:52.610]                       if (muffled) 
[16:12:52.610]                         invokeRestart("muffleWarning")
[16:12:52.610]                     }
[16:12:52.610]                     else if (inherits(cond, "condition")) {
[16:12:52.610]                       if (!is.null(pattern)) {
[16:12:52.610]                         computeRestarts <- base::computeRestarts
[16:12:52.610]                         grepl <- base::grepl
[16:12:52.610]                         restarts <- computeRestarts(cond)
[16:12:52.610]                         for (restart in restarts) {
[16:12:52.610]                           name <- restart$name
[16:12:52.610]                           if (is.null(name)) 
[16:12:52.610]                             next
[16:12:52.610]                           if (!grepl(pattern, name)) 
[16:12:52.610]                             next
[16:12:52.610]                           invokeRestart(restart)
[16:12:52.610]                           muffled <- TRUE
[16:12:52.610]                           break
[16:12:52.610]                         }
[16:12:52.610]                       }
[16:12:52.610]                     }
[16:12:52.610]                     invisible(muffled)
[16:12:52.610]                   }
[16:12:52.610]                   muffleCondition(cond)
[16:12:52.610]                 })
[16:12:52.610]             }))
[16:12:52.610]             future::FutureResult(value = ...future.value$value, 
[16:12:52.610]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.610]                   ...future.rng), globalenv = if (FALSE) 
[16:12:52.610]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:52.610]                     ...future.globalenv.names))
[16:12:52.610]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:52.610]         }, condition = base::local({
[16:12:52.610]             c <- base::c
[16:12:52.610]             inherits <- base::inherits
[16:12:52.610]             invokeRestart <- base::invokeRestart
[16:12:52.610]             length <- base::length
[16:12:52.610]             list <- base::list
[16:12:52.610]             seq.int <- base::seq.int
[16:12:52.610]             signalCondition <- base::signalCondition
[16:12:52.610]             sys.calls <- base::sys.calls
[16:12:52.610]             `[[` <- base::`[[`
[16:12:52.610]             `+` <- base::`+`
[16:12:52.610]             `<<-` <- base::`<<-`
[16:12:52.610]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:52.610]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:52.610]                   3L)]
[16:12:52.610]             }
[16:12:52.610]             function(cond) {
[16:12:52.610]                 is_error <- inherits(cond, "error")
[16:12:52.610]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:52.610]                   NULL)
[16:12:52.610]                 if (is_error) {
[16:12:52.610]                   sessionInformation <- function() {
[16:12:52.610]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:52.610]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:52.610]                       search = base::search(), system = base::Sys.info())
[16:12:52.610]                   }
[16:12:52.610]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.610]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:52.610]                     cond$call), session = sessionInformation(), 
[16:12:52.610]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:52.610]                   signalCondition(cond)
[16:12:52.610]                 }
[16:12:52.610]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:52.610]                 "immediateCondition"))) {
[16:12:52.610]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:52.610]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.610]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:52.610]                   if (TRUE && !signal) {
[16:12:52.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.610]                     {
[16:12:52.610]                       inherits <- base::inherits
[16:12:52.610]                       invokeRestart <- base::invokeRestart
[16:12:52.610]                       is.null <- base::is.null
[16:12:52.610]                       muffled <- FALSE
[16:12:52.610]                       if (inherits(cond, "message")) {
[16:12:52.610]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.610]                         if (muffled) 
[16:12:52.610]                           invokeRestart("muffleMessage")
[16:12:52.610]                       }
[16:12:52.610]                       else if (inherits(cond, "warning")) {
[16:12:52.610]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.610]                         if (muffled) 
[16:12:52.610]                           invokeRestart("muffleWarning")
[16:12:52.610]                       }
[16:12:52.610]                       else if (inherits(cond, "condition")) {
[16:12:52.610]                         if (!is.null(pattern)) {
[16:12:52.610]                           computeRestarts <- base::computeRestarts
[16:12:52.610]                           grepl <- base::grepl
[16:12:52.610]                           restarts <- computeRestarts(cond)
[16:12:52.610]                           for (restart in restarts) {
[16:12:52.610]                             name <- restart$name
[16:12:52.610]                             if (is.null(name)) 
[16:12:52.610]                               next
[16:12:52.610]                             if (!grepl(pattern, name)) 
[16:12:52.610]                               next
[16:12:52.610]                             invokeRestart(restart)
[16:12:52.610]                             muffled <- TRUE
[16:12:52.610]                             break
[16:12:52.610]                           }
[16:12:52.610]                         }
[16:12:52.610]                       }
[16:12:52.610]                       invisible(muffled)
[16:12:52.610]                     }
[16:12:52.610]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.610]                   }
[16:12:52.610]                 }
[16:12:52.610]                 else {
[16:12:52.610]                   if (TRUE) {
[16:12:52.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.610]                     {
[16:12:52.610]                       inherits <- base::inherits
[16:12:52.610]                       invokeRestart <- base::invokeRestart
[16:12:52.610]                       is.null <- base::is.null
[16:12:52.610]                       muffled <- FALSE
[16:12:52.610]                       if (inherits(cond, "message")) {
[16:12:52.610]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.610]                         if (muffled) 
[16:12:52.610]                           invokeRestart("muffleMessage")
[16:12:52.610]                       }
[16:12:52.610]                       else if (inherits(cond, "warning")) {
[16:12:52.610]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.610]                         if (muffled) 
[16:12:52.610]                           invokeRestart("muffleWarning")
[16:12:52.610]                       }
[16:12:52.610]                       else if (inherits(cond, "condition")) {
[16:12:52.610]                         if (!is.null(pattern)) {
[16:12:52.610]                           computeRestarts <- base::computeRestarts
[16:12:52.610]                           grepl <- base::grepl
[16:12:52.610]                           restarts <- computeRestarts(cond)
[16:12:52.610]                           for (restart in restarts) {
[16:12:52.610]                             name <- restart$name
[16:12:52.610]                             if (is.null(name)) 
[16:12:52.610]                               next
[16:12:52.610]                             if (!grepl(pattern, name)) 
[16:12:52.610]                               next
[16:12:52.610]                             invokeRestart(restart)
[16:12:52.610]                             muffled <- TRUE
[16:12:52.610]                             break
[16:12:52.610]                           }
[16:12:52.610]                         }
[16:12:52.610]                       }
[16:12:52.610]                       invisible(muffled)
[16:12:52.610]                     }
[16:12:52.610]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.610]                   }
[16:12:52.610]                 }
[16:12:52.610]             }
[16:12:52.610]         }))
[16:12:52.610]     }, error = function(ex) {
[16:12:52.610]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:52.610]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.610]                 ...future.rng), started = ...future.startTime, 
[16:12:52.610]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:52.610]             version = "1.8"), class = "FutureResult")
[16:12:52.610]     }, finally = {
[16:12:52.610]         if (!identical(...future.workdir, getwd())) 
[16:12:52.610]             setwd(...future.workdir)
[16:12:52.610]         {
[16:12:52.610]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:52.610]                 ...future.oldOptions$nwarnings <- NULL
[16:12:52.610]             }
[16:12:52.610]             base::options(...future.oldOptions)
[16:12:52.610]             if (.Platform$OS.type == "windows") {
[16:12:52.610]                 old_names <- names(...future.oldEnvVars)
[16:12:52.610]                 envs <- base::Sys.getenv()
[16:12:52.610]                 names <- names(envs)
[16:12:52.610]                 common <- intersect(names, old_names)
[16:12:52.610]                 added <- setdiff(names, old_names)
[16:12:52.610]                 removed <- setdiff(old_names, names)
[16:12:52.610]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:52.610]                   envs[common]]
[16:12:52.610]                 NAMES <- toupper(changed)
[16:12:52.610]                 args <- list()
[16:12:52.610]                 for (kk in seq_along(NAMES)) {
[16:12:52.610]                   name <- changed[[kk]]
[16:12:52.610]                   NAME <- NAMES[[kk]]
[16:12:52.610]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.610]                     next
[16:12:52.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.610]                 }
[16:12:52.610]                 NAMES <- toupper(added)
[16:12:52.610]                 for (kk in seq_along(NAMES)) {
[16:12:52.610]                   name <- added[[kk]]
[16:12:52.610]                   NAME <- NAMES[[kk]]
[16:12:52.610]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.610]                     next
[16:12:52.610]                   args[[name]] <- ""
[16:12:52.610]                 }
[16:12:52.610]                 NAMES <- toupper(removed)
[16:12:52.610]                 for (kk in seq_along(NAMES)) {
[16:12:52.610]                   name <- removed[[kk]]
[16:12:52.610]                   NAME <- NAMES[[kk]]
[16:12:52.610]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.610]                     next
[16:12:52.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.610]                 }
[16:12:52.610]                 if (length(args) > 0) 
[16:12:52.610]                   base::do.call(base::Sys.setenv, args = args)
[16:12:52.610]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:52.610]             }
[16:12:52.610]             else {
[16:12:52.610]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:52.610]             }
[16:12:52.610]             {
[16:12:52.610]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:52.610]                   0L) {
[16:12:52.610]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:52.610]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:52.610]                   base::options(opts)
[16:12:52.610]                 }
[16:12:52.610]                 {
[16:12:52.610]                   {
[16:12:52.610]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:52.610]                     NULL
[16:12:52.610]                   }
[16:12:52.610]                   options(future.plan = NULL)
[16:12:52.610]                   if (is.na(NA_character_)) 
[16:12:52.610]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.610]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:52.610]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:52.610]                     envir = parent.frame()) 
[16:12:52.610]                   {
[16:12:52.610]                     default_workers <- missing(workers)
[16:12:52.610]                     if (is.function(workers)) 
[16:12:52.610]                       workers <- workers()
[16:12:52.610]                     workers <- structure(as.integer(workers), 
[16:12:52.610]                       class = class(workers))
[16:12:52.610]                     stop_if_not(is.finite(workers), workers >= 
[16:12:52.610]                       1L)
[16:12:52.610]                     if ((workers == 1L && !inherits(workers, 
[16:12:52.610]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:52.610]                       if (default_workers) 
[16:12:52.610]                         supportsMulticore(warn = TRUE)
[16:12:52.610]                       return(sequential(..., envir = envir))
[16:12:52.610]                     }
[16:12:52.610]                     oopts <- options(mc.cores = workers)
[16:12:52.610]                     on.exit(options(oopts))
[16:12:52.610]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:52.610]                       envir = envir)
[16:12:52.610]                     if (!future$lazy) 
[16:12:52.610]                       future <- run(future)
[16:12:52.610]                     invisible(future)
[16:12:52.610]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:52.610]                 }
[16:12:52.610]             }
[16:12:52.610]         }
[16:12:52.610]     })
[16:12:52.610]     if (TRUE) {
[16:12:52.610]         base::sink(type = "output", split = FALSE)
[16:12:52.610]         if (TRUE) {
[16:12:52.610]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:52.610]         }
[16:12:52.610]         else {
[16:12:52.610]             ...future.result["stdout"] <- base::list(NULL)
[16:12:52.610]         }
[16:12:52.610]         base::close(...future.stdout)
[16:12:52.610]         ...future.stdout <- NULL
[16:12:52.610]     }
[16:12:52.610]     ...future.result$conditions <- ...future.conditions
[16:12:52.610]     ...future.result$finished <- base::Sys.time()
[16:12:52.610]     ...future.result
[16:12:52.610] }
[16:12:52.612] requestCore(): workers = 2
[16:12:52.614] MulticoreFuture started
[16:12:52.615] - Launch lazy future ... done
[16:12:52.615] run() for ‘MulticoreFuture’ ... done
[16:12:52.615] plan(): Setting new future strategy stack:
[16:12:52.616] List of future strategies:
[16:12:52.616] 1. sequential:
[16:12:52.616]    - args: function (..., envir = parent.frame())
[16:12:52.616]    - tweaked: FALSE
[16:12:52.616]    - call: NULL
[16:12:52.617] plan(): nbrOfWorkers() = 1
[16:12:52.619] plan(): Setting new future strategy stack:
[16:12:52.619] List of future strategies:
[16:12:52.619] 1. multicore:
[16:12:52.619]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:52.619]    - tweaked: FALSE
[16:12:52.619]    - call: plan(strategy)
[16:12:52.625] plan(): nbrOfWorkers() = 2
[16:12:52.625] Future #1
[16:12:52.627] A MulticoreFuture was resolved
[16:12:52.627]  length: 0 (resolved future 1)
[16:12:52.627] resolve() on list ... DONE
[16:12:52.627] - globals: [1] ‘a’
[16:12:52.627] Resolving futures part of globals (recursively) ... DONE
[16:12:52.630] The total size of the 1 globals is 1.55 MiB (1629944 bytes)
[16:12:52.631] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[16:12:52.631] - globals: [1] ‘a’
[16:12:52.631] - packages: [1] ‘future’
[16:12:52.631] getGlobalsAndPackages() ... DONE
[16:12:52.632] run() for ‘Future’ ...
[16:12:52.632] - state: ‘created’
[16:12:52.632] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:52.636] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:52.636] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:52.636]   - Field: ‘label’
[16:12:52.637]   - Field: ‘local’
[16:12:52.637]   - Field: ‘owner’
[16:12:52.637]   - Field: ‘envir’
[16:12:52.637]   - Field: ‘workers’
[16:12:52.637]   - Field: ‘packages’
[16:12:52.637]   - Field: ‘gc’
[16:12:52.637]   - Field: ‘job’
[16:12:52.637]   - Field: ‘conditions’
[16:12:52.637]   - Field: ‘expr’
[16:12:52.638]   - Field: ‘uuid’
[16:12:52.638]   - Field: ‘seed’
[16:12:52.638]   - Field: ‘version’
[16:12:52.638]   - Field: ‘result’
[16:12:52.638]   - Field: ‘asynchronous’
[16:12:52.638]   - Field: ‘calls’
[16:12:52.638]   - Field: ‘globals’
[16:12:52.638]   - Field: ‘stdout’
[16:12:52.638]   - Field: ‘earlySignal’
[16:12:52.639]   - Field: ‘lazy’
[16:12:52.639]   - Field: ‘state’
[16:12:52.639] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:52.639] - Launch lazy future ...
[16:12:52.639] Packages needed by the future expression (n = 1): ‘future’
[16:12:52.639] Packages needed by future strategies (n = 0): <none>
[16:12:52.640] {
[16:12:52.640]     {
[16:12:52.640]         {
[16:12:52.640]             ...future.startTime <- base::Sys.time()
[16:12:52.640]             {
[16:12:52.640]                 {
[16:12:52.640]                   {
[16:12:52.640]                     {
[16:12:52.640]                       {
[16:12:52.640]                         base::local({
[16:12:52.640]                           has_future <- base::requireNamespace("future", 
[16:12:52.640]                             quietly = TRUE)
[16:12:52.640]                           if (has_future) {
[16:12:52.640]                             ns <- base::getNamespace("future")
[16:12:52.640]                             version <- ns[[".package"]][["version"]]
[16:12:52.640]                             if (is.null(version)) 
[16:12:52.640]                               version <- utils::packageVersion("future")
[16:12:52.640]                           }
[16:12:52.640]                           else {
[16:12:52.640]                             version <- NULL
[16:12:52.640]                           }
[16:12:52.640]                           if (!has_future || version < "1.8.0") {
[16:12:52.640]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:52.640]                               "", base::R.version$version.string), 
[16:12:52.640]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:52.640]                                 base::R.version$platform, 8 * 
[16:12:52.640]                                   base::.Machine$sizeof.pointer), 
[16:12:52.640]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:52.640]                                 "release", "version")], collapse = " "), 
[16:12:52.640]                               hostname = base::Sys.info()[["nodename"]])
[16:12:52.640]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:52.640]                               info)
[16:12:52.640]                             info <- base::paste(info, collapse = "; ")
[16:12:52.640]                             if (!has_future) {
[16:12:52.640]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:52.640]                                 info)
[16:12:52.640]                             }
[16:12:52.640]                             else {
[16:12:52.640]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:52.640]                                 info, version)
[16:12:52.640]                             }
[16:12:52.640]                             base::stop(msg)
[16:12:52.640]                           }
[16:12:52.640]                         })
[16:12:52.640]                       }
[16:12:52.640]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:52.640]                       base::options(mc.cores = 1L)
[16:12:52.640]                     }
[16:12:52.640]                     base::local({
[16:12:52.640]                       for (pkg in "future") {
[16:12:52.640]                         base::loadNamespace(pkg)
[16:12:52.640]                         base::library(pkg, character.only = TRUE)
[16:12:52.640]                       }
[16:12:52.640]                     })
[16:12:52.640]                   }
[16:12:52.640]                   options(future.plan = NULL)
[16:12:52.640]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.640]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:52.640]                 }
[16:12:52.640]                 ...future.workdir <- getwd()
[16:12:52.640]             }
[16:12:52.640]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:52.640]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:52.640]         }
[16:12:52.640]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:52.640]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:52.640]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:52.640]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:52.640]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:52.640]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:52.640]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:52.640]             base::names(...future.oldOptions))
[16:12:52.640]     }
[16:12:52.640]     if (FALSE) {
[16:12:52.640]     }
[16:12:52.640]     else {
[16:12:52.640]         if (TRUE) {
[16:12:52.640]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:52.640]                 open = "w")
[16:12:52.640]         }
[16:12:52.640]         else {
[16:12:52.640]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:52.640]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:52.640]         }
[16:12:52.640]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:52.640]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:52.640]             base::sink(type = "output", split = FALSE)
[16:12:52.640]             base::close(...future.stdout)
[16:12:52.640]         }, add = TRUE)
[16:12:52.640]     }
[16:12:52.640]     ...future.frame <- base::sys.nframe()
[16:12:52.640]     ...future.conditions <- base::list()
[16:12:52.640]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:52.640]     if (FALSE) {
[16:12:52.640]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:52.640]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:52.640]     }
[16:12:52.640]     ...future.result <- base::tryCatch({
[16:12:52.640]         base::withCallingHandlers({
[16:12:52.640]             ...future.value <- base::withVisible(base::local({
[16:12:52.640]                 withCallingHandlers({
[16:12:52.640]                   value(a) + 1
[16:12:52.640]                 }, immediateCondition = function(cond) {
[16:12:52.640]                   save_rds <- function (object, pathname, ...) 
[16:12:52.640]                   {
[16:12:52.640]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:52.640]                     if (file_test("-f", pathname_tmp)) {
[16:12:52.640]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.640]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:52.640]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.640]                         fi_tmp[["mtime"]])
[16:12:52.640]                     }
[16:12:52.640]                     tryCatch({
[16:12:52.640]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:52.640]                     }, error = function(ex) {
[16:12:52.640]                       msg <- conditionMessage(ex)
[16:12:52.640]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.640]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:52.640]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.640]                         fi_tmp[["mtime"]], msg)
[16:12:52.640]                       ex$message <- msg
[16:12:52.640]                       stop(ex)
[16:12:52.640]                     })
[16:12:52.640]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:52.640]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:52.640]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:52.640]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.640]                       fi <- file.info(pathname)
[16:12:52.640]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:52.640]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.640]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:52.640]                         fi[["size"]], fi[["mtime"]])
[16:12:52.640]                       stop(msg)
[16:12:52.640]                     }
[16:12:52.640]                     invisible(pathname)
[16:12:52.640]                   }
[16:12:52.640]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:52.640]                     rootPath = tempdir()) 
[16:12:52.640]                   {
[16:12:52.640]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:52.640]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:52.640]                       tmpdir = path, fileext = ".rds")
[16:12:52.640]                     save_rds(obj, file)
[16:12:52.640]                   }
[16:12:52.640]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:52.640]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.640]                   {
[16:12:52.640]                     inherits <- base::inherits
[16:12:52.640]                     invokeRestart <- base::invokeRestart
[16:12:52.640]                     is.null <- base::is.null
[16:12:52.640]                     muffled <- FALSE
[16:12:52.640]                     if (inherits(cond, "message")) {
[16:12:52.640]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:52.640]                       if (muffled) 
[16:12:52.640]                         invokeRestart("muffleMessage")
[16:12:52.640]                     }
[16:12:52.640]                     else if (inherits(cond, "warning")) {
[16:12:52.640]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:52.640]                       if (muffled) 
[16:12:52.640]                         invokeRestart("muffleWarning")
[16:12:52.640]                     }
[16:12:52.640]                     else if (inherits(cond, "condition")) {
[16:12:52.640]                       if (!is.null(pattern)) {
[16:12:52.640]                         computeRestarts <- base::computeRestarts
[16:12:52.640]                         grepl <- base::grepl
[16:12:52.640]                         restarts <- computeRestarts(cond)
[16:12:52.640]                         for (restart in restarts) {
[16:12:52.640]                           name <- restart$name
[16:12:52.640]                           if (is.null(name)) 
[16:12:52.640]                             next
[16:12:52.640]                           if (!grepl(pattern, name)) 
[16:12:52.640]                             next
[16:12:52.640]                           invokeRestart(restart)
[16:12:52.640]                           muffled <- TRUE
[16:12:52.640]                           break
[16:12:52.640]                         }
[16:12:52.640]                       }
[16:12:52.640]                     }
[16:12:52.640]                     invisible(muffled)
[16:12:52.640]                   }
[16:12:52.640]                   muffleCondition(cond)
[16:12:52.640]                 })
[16:12:52.640]             }))
[16:12:52.640]             future::FutureResult(value = ...future.value$value, 
[16:12:52.640]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.640]                   ...future.rng), globalenv = if (FALSE) 
[16:12:52.640]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:52.640]                     ...future.globalenv.names))
[16:12:52.640]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:52.640]         }, condition = base::local({
[16:12:52.640]             c <- base::c
[16:12:52.640]             inherits <- base::inherits
[16:12:52.640]             invokeRestart <- base::invokeRestart
[16:12:52.640]             length <- base::length
[16:12:52.640]             list <- base::list
[16:12:52.640]             seq.int <- base::seq.int
[16:12:52.640]             signalCondition <- base::signalCondition
[16:12:52.640]             sys.calls <- base::sys.calls
[16:12:52.640]             `[[` <- base::`[[`
[16:12:52.640]             `+` <- base::`+`
[16:12:52.640]             `<<-` <- base::`<<-`
[16:12:52.640]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:52.640]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:52.640]                   3L)]
[16:12:52.640]             }
[16:12:52.640]             function(cond) {
[16:12:52.640]                 is_error <- inherits(cond, "error")
[16:12:52.640]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:52.640]                   NULL)
[16:12:52.640]                 if (is_error) {
[16:12:52.640]                   sessionInformation <- function() {
[16:12:52.640]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:52.640]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:52.640]                       search = base::search(), system = base::Sys.info())
[16:12:52.640]                   }
[16:12:52.640]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.640]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:52.640]                     cond$call), session = sessionInformation(), 
[16:12:52.640]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:52.640]                   signalCondition(cond)
[16:12:52.640]                 }
[16:12:52.640]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:52.640]                 "immediateCondition"))) {
[16:12:52.640]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:52.640]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.640]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:52.640]                   if (TRUE && !signal) {
[16:12:52.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.640]                     {
[16:12:52.640]                       inherits <- base::inherits
[16:12:52.640]                       invokeRestart <- base::invokeRestart
[16:12:52.640]                       is.null <- base::is.null
[16:12:52.640]                       muffled <- FALSE
[16:12:52.640]                       if (inherits(cond, "message")) {
[16:12:52.640]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.640]                         if (muffled) 
[16:12:52.640]                           invokeRestart("muffleMessage")
[16:12:52.640]                       }
[16:12:52.640]                       else if (inherits(cond, "warning")) {
[16:12:52.640]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.640]                         if (muffled) 
[16:12:52.640]                           invokeRestart("muffleWarning")
[16:12:52.640]                       }
[16:12:52.640]                       else if (inherits(cond, "condition")) {
[16:12:52.640]                         if (!is.null(pattern)) {
[16:12:52.640]                           computeRestarts <- base::computeRestarts
[16:12:52.640]                           grepl <- base::grepl
[16:12:52.640]                           restarts <- computeRestarts(cond)
[16:12:52.640]                           for (restart in restarts) {
[16:12:52.640]                             name <- restart$name
[16:12:52.640]                             if (is.null(name)) 
[16:12:52.640]                               next
[16:12:52.640]                             if (!grepl(pattern, name)) 
[16:12:52.640]                               next
[16:12:52.640]                             invokeRestart(restart)
[16:12:52.640]                             muffled <- TRUE
[16:12:52.640]                             break
[16:12:52.640]                           }
[16:12:52.640]                         }
[16:12:52.640]                       }
[16:12:52.640]                       invisible(muffled)
[16:12:52.640]                     }
[16:12:52.640]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.640]                   }
[16:12:52.640]                 }
[16:12:52.640]                 else {
[16:12:52.640]                   if (TRUE) {
[16:12:52.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.640]                     {
[16:12:52.640]                       inherits <- base::inherits
[16:12:52.640]                       invokeRestart <- base::invokeRestart
[16:12:52.640]                       is.null <- base::is.null
[16:12:52.640]                       muffled <- FALSE
[16:12:52.640]                       if (inherits(cond, "message")) {
[16:12:52.640]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.640]                         if (muffled) 
[16:12:52.640]                           invokeRestart("muffleMessage")
[16:12:52.640]                       }
[16:12:52.640]                       else if (inherits(cond, "warning")) {
[16:12:52.640]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.640]                         if (muffled) 
[16:12:52.640]                           invokeRestart("muffleWarning")
[16:12:52.640]                       }
[16:12:52.640]                       else if (inherits(cond, "condition")) {
[16:12:52.640]                         if (!is.null(pattern)) {
[16:12:52.640]                           computeRestarts <- base::computeRestarts
[16:12:52.640]                           grepl <- base::grepl
[16:12:52.640]                           restarts <- computeRestarts(cond)
[16:12:52.640]                           for (restart in restarts) {
[16:12:52.640]                             name <- restart$name
[16:12:52.640]                             if (is.null(name)) 
[16:12:52.640]                               next
[16:12:52.640]                             if (!grepl(pattern, name)) 
[16:12:52.640]                               next
[16:12:52.640]                             invokeRestart(restart)
[16:12:52.640]                             muffled <- TRUE
[16:12:52.640]                             break
[16:12:52.640]                           }
[16:12:52.640]                         }
[16:12:52.640]                       }
[16:12:52.640]                       invisible(muffled)
[16:12:52.640]                     }
[16:12:52.640]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.640]                   }
[16:12:52.640]                 }
[16:12:52.640]             }
[16:12:52.640]         }))
[16:12:52.640]     }, error = function(ex) {
[16:12:52.640]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:52.640]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.640]                 ...future.rng), started = ...future.startTime, 
[16:12:52.640]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:52.640]             version = "1.8"), class = "FutureResult")
[16:12:52.640]     }, finally = {
[16:12:52.640]         if (!identical(...future.workdir, getwd())) 
[16:12:52.640]             setwd(...future.workdir)
[16:12:52.640]         {
[16:12:52.640]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:52.640]                 ...future.oldOptions$nwarnings <- NULL
[16:12:52.640]             }
[16:12:52.640]             base::options(...future.oldOptions)
[16:12:52.640]             if (.Platform$OS.type == "windows") {
[16:12:52.640]                 old_names <- names(...future.oldEnvVars)
[16:12:52.640]                 envs <- base::Sys.getenv()
[16:12:52.640]                 names <- names(envs)
[16:12:52.640]                 common <- intersect(names, old_names)
[16:12:52.640]                 added <- setdiff(names, old_names)
[16:12:52.640]                 removed <- setdiff(old_names, names)
[16:12:52.640]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:52.640]                   envs[common]]
[16:12:52.640]                 NAMES <- toupper(changed)
[16:12:52.640]                 args <- list()
[16:12:52.640]                 for (kk in seq_along(NAMES)) {
[16:12:52.640]                   name <- changed[[kk]]
[16:12:52.640]                   NAME <- NAMES[[kk]]
[16:12:52.640]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.640]                     next
[16:12:52.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.640]                 }
[16:12:52.640]                 NAMES <- toupper(added)
[16:12:52.640]                 for (kk in seq_along(NAMES)) {
[16:12:52.640]                   name <- added[[kk]]
[16:12:52.640]                   NAME <- NAMES[[kk]]
[16:12:52.640]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.640]                     next
[16:12:52.640]                   args[[name]] <- ""
[16:12:52.640]                 }
[16:12:52.640]                 NAMES <- toupper(removed)
[16:12:52.640]                 for (kk in seq_along(NAMES)) {
[16:12:52.640]                   name <- removed[[kk]]
[16:12:52.640]                   NAME <- NAMES[[kk]]
[16:12:52.640]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.640]                     next
[16:12:52.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.640]                 }
[16:12:52.640]                 if (length(args) > 0) 
[16:12:52.640]                   base::do.call(base::Sys.setenv, args = args)
[16:12:52.640]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:52.640]             }
[16:12:52.640]             else {
[16:12:52.640]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:52.640]             }
[16:12:52.640]             {
[16:12:52.640]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:52.640]                   0L) {
[16:12:52.640]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:52.640]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:52.640]                   base::options(opts)
[16:12:52.640]                 }
[16:12:52.640]                 {
[16:12:52.640]                   {
[16:12:52.640]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:52.640]                     NULL
[16:12:52.640]                   }
[16:12:52.640]                   options(future.plan = NULL)
[16:12:52.640]                   if (is.na(NA_character_)) 
[16:12:52.640]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.640]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:52.640]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:52.640]                     envir = parent.frame()) 
[16:12:52.640]                   {
[16:12:52.640]                     default_workers <- missing(workers)
[16:12:52.640]                     if (is.function(workers)) 
[16:12:52.640]                       workers <- workers()
[16:12:52.640]                     workers <- structure(as.integer(workers), 
[16:12:52.640]                       class = class(workers))
[16:12:52.640]                     stop_if_not(is.finite(workers), workers >= 
[16:12:52.640]                       1L)
[16:12:52.640]                     if ((workers == 1L && !inherits(workers, 
[16:12:52.640]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:52.640]                       if (default_workers) 
[16:12:52.640]                         supportsMulticore(warn = TRUE)
[16:12:52.640]                       return(sequential(..., envir = envir))
[16:12:52.640]                     }
[16:12:52.640]                     oopts <- options(mc.cores = workers)
[16:12:52.640]                     on.exit(options(oopts))
[16:12:52.640]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:52.640]                       envir = envir)
[16:12:52.640]                     if (!future$lazy) 
[16:12:52.640]                       future <- run(future)
[16:12:52.640]                     invisible(future)
[16:12:52.640]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:52.640]                 }
[16:12:52.640]             }
[16:12:52.640]         }
[16:12:52.640]     })
[16:12:52.640]     if (TRUE) {
[16:12:52.640]         base::sink(type = "output", split = FALSE)
[16:12:52.640]         if (TRUE) {
[16:12:52.640]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:52.640]         }
[16:12:52.640]         else {
[16:12:52.640]             ...future.result["stdout"] <- base::list(NULL)
[16:12:52.640]         }
[16:12:52.640]         base::close(...future.stdout)
[16:12:52.640]         ...future.stdout <- NULL
[16:12:52.640]     }
[16:12:52.640]     ...future.result$conditions <- ...future.conditions
[16:12:52.640]     ...future.result$finished <- base::Sys.time()
[16:12:52.640]     ...future.result
[16:12:52.640] }
[16:12:52.643] assign_globals() ...
[16:12:52.643] List of 1
[16:12:52.643]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x56233db47b38> 
[16:12:52.643]  - attr(*, "where")=List of 1
[16:12:52.643]   ..$ a:<environment: R_EmptyEnv> 
[16:12:52.643]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:52.643]  - attr(*, "resolved")= logi TRUE
[16:12:52.643]  - attr(*, "total_size")= num 1629944
[16:12:52.643]  - attr(*, "already-done")= logi TRUE
[16:12:52.648] - copied ‘a’ to environment
[16:12:52.649] assign_globals() ... done
[16:12:52.649] requestCore(): workers = 2
[16:12:52.652] MulticoreFuture started
[16:12:52.652] - Launch lazy future ... done
[16:12:52.652] run() for ‘MulticoreFuture’ ... done
[16:12:52.653] plan(): Setting new future strategy stack:
[16:12:52.653] List of future strategies:
[16:12:52.653] 1. sequential:
[16:12:52.653]    - args: function (..., envir = parent.frame())
[16:12:52.653]    - tweaked: FALSE
[16:12:52.653]    - call: NULL
[16:12:52.655] plan(): nbrOfWorkers() = 1
[16:12:52.664] plan(): Setting new future strategy stack:
[16:12:52.664] List of future strategies:
[16:12:52.664] 1. multicore:
[16:12:52.664]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:52.664]    - tweaked: FALSE
[16:12:52.664]    - call: plan(strategy)
[16:12:52.672] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:52.674] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:52.675] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:52.681] - globals found: [2] ‘{’, ‘pkg’
[16:12:52.682] Searching for globals ... DONE
[16:12:52.682] Resolving globals: TRUE
[16:12:52.682] Resolving any globals that are futures ...
[16:12:52.683] - globals: [2] ‘{’, ‘pkg’
[16:12:52.683] Resolving any globals that are futures ... DONE
[16:12:52.684] Resolving futures part of globals (recursively) ...
[16:12:52.684] resolve() on list ...
[16:12:52.685]  recursive: 99
[16:12:52.685]  length: 1
[16:12:52.685]  elements: ‘pkg’
[16:12:52.685]  length: 0 (resolved future 1)
[16:12:52.686] resolve() on list ... DONE
[16:12:52.686] - globals: [1] ‘pkg’
[16:12:52.686] Resolving futures part of globals (recursively) ... DONE
[16:12:52.687] The total size of the 1 globals is 112 bytes (112 bytes)
[16:12:52.687] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[16:12:52.688] - globals: [1] ‘pkg’
[16:12:52.688] 
[16:12:52.688] getGlobalsAndPackages() ... DONE
[16:12:52.689] Packages needed by the future expression (n = 0): <none>
[16:12:52.689] Packages needed by future strategies (n = 0): <none>
[16:12:52.691] {
[16:12:52.691]     {
[16:12:52.691]         {
[16:12:52.691]             ...future.startTime <- base::Sys.time()
[16:12:52.691]             {
[16:12:52.691]                 {
[16:12:52.691]                   {
[16:12:52.691]                     base::local({
[16:12:52.691]                       has_future <- base::requireNamespace("future", 
[16:12:52.691]                         quietly = TRUE)
[16:12:52.691]                       if (has_future) {
[16:12:52.691]                         ns <- base::getNamespace("future")
[16:12:52.691]                         version <- ns[[".package"]][["version"]]
[16:12:52.691]                         if (is.null(version)) 
[16:12:52.691]                           version <- utils::packageVersion("future")
[16:12:52.691]                       }
[16:12:52.691]                       else {
[16:12:52.691]                         version <- NULL
[16:12:52.691]                       }
[16:12:52.691]                       if (!has_future || version < "1.8.0") {
[16:12:52.691]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:52.691]                           "", base::R.version$version.string), 
[16:12:52.691]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:52.691]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:52.691]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:52.691]                             "release", "version")], collapse = " "), 
[16:12:52.691]                           hostname = base::Sys.info()[["nodename"]])
[16:12:52.691]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:52.691]                           info)
[16:12:52.691]                         info <- base::paste(info, collapse = "; ")
[16:12:52.691]                         if (!has_future) {
[16:12:52.691]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:52.691]                             info)
[16:12:52.691]                         }
[16:12:52.691]                         else {
[16:12:52.691]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:52.691]                             info, version)
[16:12:52.691]                         }
[16:12:52.691]                         base::stop(msg)
[16:12:52.691]                       }
[16:12:52.691]                     })
[16:12:52.691]                   }
[16:12:52.691]                   options(future.plan = NULL)
[16:12:52.691]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.691]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:52.691]                 }
[16:12:52.691]                 ...future.workdir <- getwd()
[16:12:52.691]             }
[16:12:52.691]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:52.691]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:52.691]         }
[16:12:52.691]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:52.691]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:52.691]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:52.691]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:52.691]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:52.691]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:52.691]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:52.691]             base::names(...future.oldOptions))
[16:12:52.691]     }
[16:12:52.691]     if (FALSE) {
[16:12:52.691]     }
[16:12:52.691]     else {
[16:12:52.691]         if (TRUE) {
[16:12:52.691]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:52.691]                 open = "w")
[16:12:52.691]         }
[16:12:52.691]         else {
[16:12:52.691]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:52.691]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:52.691]         }
[16:12:52.691]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:52.691]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:52.691]             base::sink(type = "output", split = FALSE)
[16:12:52.691]             base::close(...future.stdout)
[16:12:52.691]         }, add = TRUE)
[16:12:52.691]     }
[16:12:52.691]     ...future.frame <- base::sys.nframe()
[16:12:52.691]     ...future.conditions <- base::list()
[16:12:52.691]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:52.691]     if (FALSE) {
[16:12:52.691]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:52.691]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:52.691]     }
[16:12:52.691]     ...future.result <- base::tryCatch({
[16:12:52.691]         base::withCallingHandlers({
[16:12:52.691]             ...future.value <- base::withVisible(base::local({
[16:12:52.691]                 pkg
[16:12:52.691]             }))
[16:12:52.691]             future::FutureResult(value = ...future.value$value, 
[16:12:52.691]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.691]                   ...future.rng), globalenv = if (FALSE) 
[16:12:52.691]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:52.691]                     ...future.globalenv.names))
[16:12:52.691]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:52.691]         }, condition = base::local({
[16:12:52.691]             c <- base::c
[16:12:52.691]             inherits <- base::inherits
[16:12:52.691]             invokeRestart <- base::invokeRestart
[16:12:52.691]             length <- base::length
[16:12:52.691]             list <- base::list
[16:12:52.691]             seq.int <- base::seq.int
[16:12:52.691]             signalCondition <- base::signalCondition
[16:12:52.691]             sys.calls <- base::sys.calls
[16:12:52.691]             `[[` <- base::`[[`
[16:12:52.691]             `+` <- base::`+`
[16:12:52.691]             `<<-` <- base::`<<-`
[16:12:52.691]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:52.691]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:52.691]                   3L)]
[16:12:52.691]             }
[16:12:52.691]             function(cond) {
[16:12:52.691]                 is_error <- inherits(cond, "error")
[16:12:52.691]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:52.691]                   NULL)
[16:12:52.691]                 if (is_error) {
[16:12:52.691]                   sessionInformation <- function() {
[16:12:52.691]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:52.691]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:52.691]                       search = base::search(), system = base::Sys.info())
[16:12:52.691]                   }
[16:12:52.691]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.691]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:52.691]                     cond$call), session = sessionInformation(), 
[16:12:52.691]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:52.691]                   signalCondition(cond)
[16:12:52.691]                 }
[16:12:52.691]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:52.691]                 "immediateCondition"))) {
[16:12:52.691]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:52.691]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.691]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:52.691]                   if (TRUE && !signal) {
[16:12:52.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.691]                     {
[16:12:52.691]                       inherits <- base::inherits
[16:12:52.691]                       invokeRestart <- base::invokeRestart
[16:12:52.691]                       is.null <- base::is.null
[16:12:52.691]                       muffled <- FALSE
[16:12:52.691]                       if (inherits(cond, "message")) {
[16:12:52.691]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.691]                         if (muffled) 
[16:12:52.691]                           invokeRestart("muffleMessage")
[16:12:52.691]                       }
[16:12:52.691]                       else if (inherits(cond, "warning")) {
[16:12:52.691]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.691]                         if (muffled) 
[16:12:52.691]                           invokeRestart("muffleWarning")
[16:12:52.691]                       }
[16:12:52.691]                       else if (inherits(cond, "condition")) {
[16:12:52.691]                         if (!is.null(pattern)) {
[16:12:52.691]                           computeRestarts <- base::computeRestarts
[16:12:52.691]                           grepl <- base::grepl
[16:12:52.691]                           restarts <- computeRestarts(cond)
[16:12:52.691]                           for (restart in restarts) {
[16:12:52.691]                             name <- restart$name
[16:12:52.691]                             if (is.null(name)) 
[16:12:52.691]                               next
[16:12:52.691]                             if (!grepl(pattern, name)) 
[16:12:52.691]                               next
[16:12:52.691]                             invokeRestart(restart)
[16:12:52.691]                             muffled <- TRUE
[16:12:52.691]                             break
[16:12:52.691]                           }
[16:12:52.691]                         }
[16:12:52.691]                       }
[16:12:52.691]                       invisible(muffled)
[16:12:52.691]                     }
[16:12:52.691]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.691]                   }
[16:12:52.691]                 }
[16:12:52.691]                 else {
[16:12:52.691]                   if (TRUE) {
[16:12:52.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.691]                     {
[16:12:52.691]                       inherits <- base::inherits
[16:12:52.691]                       invokeRestart <- base::invokeRestart
[16:12:52.691]                       is.null <- base::is.null
[16:12:52.691]                       muffled <- FALSE
[16:12:52.691]                       if (inherits(cond, "message")) {
[16:12:52.691]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.691]                         if (muffled) 
[16:12:52.691]                           invokeRestart("muffleMessage")
[16:12:52.691]                       }
[16:12:52.691]                       else if (inherits(cond, "warning")) {
[16:12:52.691]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.691]                         if (muffled) 
[16:12:52.691]                           invokeRestart("muffleWarning")
[16:12:52.691]                       }
[16:12:52.691]                       else if (inherits(cond, "condition")) {
[16:12:52.691]                         if (!is.null(pattern)) {
[16:12:52.691]                           computeRestarts <- base::computeRestarts
[16:12:52.691]                           grepl <- base::grepl
[16:12:52.691]                           restarts <- computeRestarts(cond)
[16:12:52.691]                           for (restart in restarts) {
[16:12:52.691]                             name <- restart$name
[16:12:52.691]                             if (is.null(name)) 
[16:12:52.691]                               next
[16:12:52.691]                             if (!grepl(pattern, name)) 
[16:12:52.691]                               next
[16:12:52.691]                             invokeRestart(restart)
[16:12:52.691]                             muffled <- TRUE
[16:12:52.691]                             break
[16:12:52.691]                           }
[16:12:52.691]                         }
[16:12:52.691]                       }
[16:12:52.691]                       invisible(muffled)
[16:12:52.691]                     }
[16:12:52.691]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.691]                   }
[16:12:52.691]                 }
[16:12:52.691]             }
[16:12:52.691]         }))
[16:12:52.691]     }, error = function(ex) {
[16:12:52.691]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:52.691]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.691]                 ...future.rng), started = ...future.startTime, 
[16:12:52.691]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:52.691]             version = "1.8"), class = "FutureResult")
[16:12:52.691]     }, finally = {
[16:12:52.691]         if (!identical(...future.workdir, getwd())) 
[16:12:52.691]             setwd(...future.workdir)
[16:12:52.691]         {
[16:12:52.691]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:52.691]                 ...future.oldOptions$nwarnings <- NULL
[16:12:52.691]             }
[16:12:52.691]             base::options(...future.oldOptions)
[16:12:52.691]             if (.Platform$OS.type == "windows") {
[16:12:52.691]                 old_names <- names(...future.oldEnvVars)
[16:12:52.691]                 envs <- base::Sys.getenv()
[16:12:52.691]                 names <- names(envs)
[16:12:52.691]                 common <- intersect(names, old_names)
[16:12:52.691]                 added <- setdiff(names, old_names)
[16:12:52.691]                 removed <- setdiff(old_names, names)
[16:12:52.691]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:52.691]                   envs[common]]
[16:12:52.691]                 NAMES <- toupper(changed)
[16:12:52.691]                 args <- list()
[16:12:52.691]                 for (kk in seq_along(NAMES)) {
[16:12:52.691]                   name <- changed[[kk]]
[16:12:52.691]                   NAME <- NAMES[[kk]]
[16:12:52.691]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.691]                     next
[16:12:52.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.691]                 }
[16:12:52.691]                 NAMES <- toupper(added)
[16:12:52.691]                 for (kk in seq_along(NAMES)) {
[16:12:52.691]                   name <- added[[kk]]
[16:12:52.691]                   NAME <- NAMES[[kk]]
[16:12:52.691]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.691]                     next
[16:12:52.691]                   args[[name]] <- ""
[16:12:52.691]                 }
[16:12:52.691]                 NAMES <- toupper(removed)
[16:12:52.691]                 for (kk in seq_along(NAMES)) {
[16:12:52.691]                   name <- removed[[kk]]
[16:12:52.691]                   NAME <- NAMES[[kk]]
[16:12:52.691]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.691]                     next
[16:12:52.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.691]                 }
[16:12:52.691]                 if (length(args) > 0) 
[16:12:52.691]                   base::do.call(base::Sys.setenv, args = args)
[16:12:52.691]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:52.691]             }
[16:12:52.691]             else {
[16:12:52.691]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:52.691]             }
[16:12:52.691]             {
[16:12:52.691]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:52.691]                   0L) {
[16:12:52.691]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:52.691]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:52.691]                   base::options(opts)
[16:12:52.691]                 }
[16:12:52.691]                 {
[16:12:52.691]                   {
[16:12:52.691]                     NULL
[16:12:52.691]                     RNGkind("Mersenne-Twister")
[16:12:52.691]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:52.691]                       inherits = FALSE)
[16:12:52.691]                   }
[16:12:52.691]                   options(future.plan = NULL)
[16:12:52.691]                   if (is.na(NA_character_)) 
[16:12:52.691]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.691]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:52.691]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:52.691]                     envir = parent.frame()) 
[16:12:52.691]                   {
[16:12:52.691]                     default_workers <- missing(workers)
[16:12:52.691]                     if (is.function(workers)) 
[16:12:52.691]                       workers <- workers()
[16:12:52.691]                     workers <- structure(as.integer(workers), 
[16:12:52.691]                       class = class(workers))
[16:12:52.691]                     stop_if_not(is.finite(workers), workers >= 
[16:12:52.691]                       1L)
[16:12:52.691]                     if ((workers == 1L && !inherits(workers, 
[16:12:52.691]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:52.691]                       if (default_workers) 
[16:12:52.691]                         supportsMulticore(warn = TRUE)
[16:12:52.691]                       return(sequential(..., envir = envir))
[16:12:52.691]                     }
[16:12:52.691]                     oopts <- options(mc.cores = workers)
[16:12:52.691]                     on.exit(options(oopts))
[16:12:52.691]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:52.691]                       envir = envir)
[16:12:52.691]                     if (!future$lazy) 
[16:12:52.691]                       future <- run(future)
[16:12:52.691]                     invisible(future)
[16:12:52.691]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:52.691]                 }
[16:12:52.691]             }
[16:12:52.691]         }
[16:12:52.691]     })
[16:12:52.691]     if (TRUE) {
[16:12:52.691]         base::sink(type = "output", split = FALSE)
[16:12:52.691]         if (TRUE) {
[16:12:52.691]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:52.691]         }
[16:12:52.691]         else {
[16:12:52.691]             ...future.result["stdout"] <- base::list(NULL)
[16:12:52.691]         }
[16:12:52.691]         base::close(...future.stdout)
[16:12:52.691]         ...future.stdout <- NULL
[16:12:52.691]     }
[16:12:52.691]     ...future.result$conditions <- ...future.conditions
[16:12:52.691]     ...future.result$finished <- base::Sys.time()
[16:12:52.691]     ...future.result
[16:12:52.691] }
[16:12:52.694] assign_globals() ...
[16:12:52.694] List of 1
[16:12:52.694]  $ pkg: chr "foo"
[16:12:52.694]  - attr(*, "where")=List of 1
[16:12:52.694]   ..$ pkg:<environment: R_EmptyEnv> 
[16:12:52.694]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:52.694]  - attr(*, "resolved")= logi TRUE
[16:12:52.694]  - attr(*, "total_size")= num 112
[16:12:52.700] - copied ‘pkg’ to environment
[16:12:52.700] assign_globals() ... done
[16:12:52.701] plan(): Setting new future strategy stack:
[16:12:52.701] List of future strategies:
[16:12:52.701] 1. sequential:
[16:12:52.701]    - args: function (..., envir = parent.frame())
[16:12:52.701]    - tweaked: FALSE
[16:12:52.701]    - call: NULL
[16:12:52.702] plan(): nbrOfWorkers() = 1
[16:12:52.704] plan(): Setting new future strategy stack:
[16:12:52.704] List of future strategies:
[16:12:52.704] 1. multicore:
[16:12:52.704]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:52.704]    - tweaked: FALSE
[16:12:52.704]    - call: plan(strategy)
[16:12:52.709] plan(): nbrOfWorkers() = 2
[16:12:52.709] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:52.710] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:52.710] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:52.713] - globals found: [3] ‘{’, ‘<-’, ‘+’
[16:12:52.713] Searching for globals ... DONE
[16:12:52.713] Resolving globals: TRUE
[16:12:52.713] Resolving any globals that are futures ...
[16:12:52.714] - globals: [3] ‘{’, ‘<-’, ‘+’
[16:12:52.714] Resolving any globals that are futures ... DONE
[16:12:52.714] 
[16:12:52.714] 
[16:12:52.715] getGlobalsAndPackages() ... DONE
[16:12:52.715] run() for ‘Future’ ...
[16:12:52.715] - state: ‘created’
[16:12:52.715] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:52.720] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:52.721] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:52.721]   - Field: ‘label’
[16:12:52.721]   - Field: ‘local’
[16:12:52.721]   - Field: ‘owner’
[16:12:52.721]   - Field: ‘envir’
[16:12:52.722]   - Field: ‘workers’
[16:12:52.722]   - Field: ‘packages’
[16:12:52.722]   - Field: ‘gc’
[16:12:52.722]   - Field: ‘job’
[16:12:52.722]   - Field: ‘conditions’
[16:12:52.723]   - Field: ‘expr’
[16:12:52.723]   - Field: ‘uuid’
[16:12:52.723]   - Field: ‘seed’
[16:12:52.723]   - Field: ‘version’
[16:12:52.723]   - Field: ‘result’
[16:12:52.724]   - Field: ‘asynchronous’
[16:12:52.724]   - Field: ‘calls’
[16:12:52.724]   - Field: ‘globals’
[16:12:52.724]   - Field: ‘stdout’
[16:12:52.724]   - Field: ‘earlySignal’
[16:12:52.725]   - Field: ‘lazy’
[16:12:52.725]   - Field: ‘state’
[16:12:52.725] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:52.725] - Launch lazy future ...
[16:12:52.726] Packages needed by the future expression (n = 0): <none>
[16:12:52.726] Packages needed by future strategies (n = 0): <none>
[16:12:52.727] {
[16:12:52.727]     {
[16:12:52.727]         {
[16:12:52.727]             ...future.startTime <- base::Sys.time()
[16:12:52.727]             {
[16:12:52.727]                 {
[16:12:52.727]                   {
[16:12:52.727]                     {
[16:12:52.727]                       base::local({
[16:12:52.727]                         has_future <- base::requireNamespace("future", 
[16:12:52.727]                           quietly = TRUE)
[16:12:52.727]                         if (has_future) {
[16:12:52.727]                           ns <- base::getNamespace("future")
[16:12:52.727]                           version <- ns[[".package"]][["version"]]
[16:12:52.727]                           if (is.null(version)) 
[16:12:52.727]                             version <- utils::packageVersion("future")
[16:12:52.727]                         }
[16:12:52.727]                         else {
[16:12:52.727]                           version <- NULL
[16:12:52.727]                         }
[16:12:52.727]                         if (!has_future || version < "1.8.0") {
[16:12:52.727]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:52.727]                             "", base::R.version$version.string), 
[16:12:52.727]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:52.727]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:52.727]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:52.727]                               "release", "version")], collapse = " "), 
[16:12:52.727]                             hostname = base::Sys.info()[["nodename"]])
[16:12:52.727]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:52.727]                             info)
[16:12:52.727]                           info <- base::paste(info, collapse = "; ")
[16:12:52.727]                           if (!has_future) {
[16:12:52.727]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:52.727]                               info)
[16:12:52.727]                           }
[16:12:52.727]                           else {
[16:12:52.727]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:52.727]                               info, version)
[16:12:52.727]                           }
[16:12:52.727]                           base::stop(msg)
[16:12:52.727]                         }
[16:12:52.727]                       })
[16:12:52.727]                     }
[16:12:52.727]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:52.727]                     base::options(mc.cores = 1L)
[16:12:52.727]                   }
[16:12:52.727]                   options(future.plan = NULL)
[16:12:52.727]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.727]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:52.727]                 }
[16:12:52.727]                 ...future.workdir <- getwd()
[16:12:52.727]             }
[16:12:52.727]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:52.727]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:52.727]         }
[16:12:52.727]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:52.727]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:52.727]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:52.727]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:52.727]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:52.727]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:52.727]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:52.727]             base::names(...future.oldOptions))
[16:12:52.727]     }
[16:12:52.727]     if (FALSE) {
[16:12:52.727]     }
[16:12:52.727]     else {
[16:12:52.727]         if (TRUE) {
[16:12:52.727]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:52.727]                 open = "w")
[16:12:52.727]         }
[16:12:52.727]         else {
[16:12:52.727]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:52.727]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:52.727]         }
[16:12:52.727]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:52.727]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:52.727]             base::sink(type = "output", split = FALSE)
[16:12:52.727]             base::close(...future.stdout)
[16:12:52.727]         }, add = TRUE)
[16:12:52.727]     }
[16:12:52.727]     ...future.frame <- base::sys.nframe()
[16:12:52.727]     ...future.conditions <- base::list()
[16:12:52.727]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:52.727]     if (FALSE) {
[16:12:52.727]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:52.727]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:52.727]     }
[16:12:52.727]     ...future.result <- base::tryCatch({
[16:12:52.727]         base::withCallingHandlers({
[16:12:52.727]             ...future.value <- base::withVisible(base::local({
[16:12:52.727]                 withCallingHandlers({
[16:12:52.727]                   {
[16:12:52.727]                     x <- 0
[16:12:52.727]                     x <- x + 1
[16:12:52.727]                     x
[16:12:52.727]                   }
[16:12:52.727]                 }, immediateCondition = function(cond) {
[16:12:52.727]                   save_rds <- function (object, pathname, ...) 
[16:12:52.727]                   {
[16:12:52.727]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:52.727]                     if (file_test("-f", pathname_tmp)) {
[16:12:52.727]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.727]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:52.727]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.727]                         fi_tmp[["mtime"]])
[16:12:52.727]                     }
[16:12:52.727]                     tryCatch({
[16:12:52.727]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:52.727]                     }, error = function(ex) {
[16:12:52.727]                       msg <- conditionMessage(ex)
[16:12:52.727]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.727]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:52.727]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.727]                         fi_tmp[["mtime"]], msg)
[16:12:52.727]                       ex$message <- msg
[16:12:52.727]                       stop(ex)
[16:12:52.727]                     })
[16:12:52.727]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:52.727]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:52.727]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:52.727]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.727]                       fi <- file.info(pathname)
[16:12:52.727]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:52.727]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.727]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:52.727]                         fi[["size"]], fi[["mtime"]])
[16:12:52.727]                       stop(msg)
[16:12:52.727]                     }
[16:12:52.727]                     invisible(pathname)
[16:12:52.727]                   }
[16:12:52.727]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:52.727]                     rootPath = tempdir()) 
[16:12:52.727]                   {
[16:12:52.727]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:52.727]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:52.727]                       tmpdir = path, fileext = ".rds")
[16:12:52.727]                     save_rds(obj, file)
[16:12:52.727]                   }
[16:12:52.727]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:52.727]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.727]                   {
[16:12:52.727]                     inherits <- base::inherits
[16:12:52.727]                     invokeRestart <- base::invokeRestart
[16:12:52.727]                     is.null <- base::is.null
[16:12:52.727]                     muffled <- FALSE
[16:12:52.727]                     if (inherits(cond, "message")) {
[16:12:52.727]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:52.727]                       if (muffled) 
[16:12:52.727]                         invokeRestart("muffleMessage")
[16:12:52.727]                     }
[16:12:52.727]                     else if (inherits(cond, "warning")) {
[16:12:52.727]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:52.727]                       if (muffled) 
[16:12:52.727]                         invokeRestart("muffleWarning")
[16:12:52.727]                     }
[16:12:52.727]                     else if (inherits(cond, "condition")) {
[16:12:52.727]                       if (!is.null(pattern)) {
[16:12:52.727]                         computeRestarts <- base::computeRestarts
[16:12:52.727]                         grepl <- base::grepl
[16:12:52.727]                         restarts <- computeRestarts(cond)
[16:12:52.727]                         for (restart in restarts) {
[16:12:52.727]                           name <- restart$name
[16:12:52.727]                           if (is.null(name)) 
[16:12:52.727]                             next
[16:12:52.727]                           if (!grepl(pattern, name)) 
[16:12:52.727]                             next
[16:12:52.727]                           invokeRestart(restart)
[16:12:52.727]                           muffled <- TRUE
[16:12:52.727]                           break
[16:12:52.727]                         }
[16:12:52.727]                       }
[16:12:52.727]                     }
[16:12:52.727]                     invisible(muffled)
[16:12:52.727]                   }
[16:12:52.727]                   muffleCondition(cond)
[16:12:52.727]                 })
[16:12:52.727]             }))
[16:12:52.727]             future::FutureResult(value = ...future.value$value, 
[16:12:52.727]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.727]                   ...future.rng), globalenv = if (FALSE) 
[16:12:52.727]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:52.727]                     ...future.globalenv.names))
[16:12:52.727]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:52.727]         }, condition = base::local({
[16:12:52.727]             c <- base::c
[16:12:52.727]             inherits <- base::inherits
[16:12:52.727]             invokeRestart <- base::invokeRestart
[16:12:52.727]             length <- base::length
[16:12:52.727]             list <- base::list
[16:12:52.727]             seq.int <- base::seq.int
[16:12:52.727]             signalCondition <- base::signalCondition
[16:12:52.727]             sys.calls <- base::sys.calls
[16:12:52.727]             `[[` <- base::`[[`
[16:12:52.727]             `+` <- base::`+`
[16:12:52.727]             `<<-` <- base::`<<-`
[16:12:52.727]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:52.727]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:52.727]                   3L)]
[16:12:52.727]             }
[16:12:52.727]             function(cond) {
[16:12:52.727]                 is_error <- inherits(cond, "error")
[16:12:52.727]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:52.727]                   NULL)
[16:12:52.727]                 if (is_error) {
[16:12:52.727]                   sessionInformation <- function() {
[16:12:52.727]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:52.727]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:52.727]                       search = base::search(), system = base::Sys.info())
[16:12:52.727]                   }
[16:12:52.727]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.727]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:52.727]                     cond$call), session = sessionInformation(), 
[16:12:52.727]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:52.727]                   signalCondition(cond)
[16:12:52.727]                 }
[16:12:52.727]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:52.727]                 "immediateCondition"))) {
[16:12:52.727]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:52.727]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.727]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:52.727]                   if (TRUE && !signal) {
[16:12:52.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.727]                     {
[16:12:52.727]                       inherits <- base::inherits
[16:12:52.727]                       invokeRestart <- base::invokeRestart
[16:12:52.727]                       is.null <- base::is.null
[16:12:52.727]                       muffled <- FALSE
[16:12:52.727]                       if (inherits(cond, "message")) {
[16:12:52.727]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.727]                         if (muffled) 
[16:12:52.727]                           invokeRestart("muffleMessage")
[16:12:52.727]                       }
[16:12:52.727]                       else if (inherits(cond, "warning")) {
[16:12:52.727]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.727]                         if (muffled) 
[16:12:52.727]                           invokeRestart("muffleWarning")
[16:12:52.727]                       }
[16:12:52.727]                       else if (inherits(cond, "condition")) {
[16:12:52.727]                         if (!is.null(pattern)) {
[16:12:52.727]                           computeRestarts <- base::computeRestarts
[16:12:52.727]                           grepl <- base::grepl
[16:12:52.727]                           restarts <- computeRestarts(cond)
[16:12:52.727]                           for (restart in restarts) {
[16:12:52.727]                             name <- restart$name
[16:12:52.727]                             if (is.null(name)) 
[16:12:52.727]                               next
[16:12:52.727]                             if (!grepl(pattern, name)) 
[16:12:52.727]                               next
[16:12:52.727]                             invokeRestart(restart)
[16:12:52.727]                             muffled <- TRUE
[16:12:52.727]                             break
[16:12:52.727]                           }
[16:12:52.727]                         }
[16:12:52.727]                       }
[16:12:52.727]                       invisible(muffled)
[16:12:52.727]                     }
[16:12:52.727]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.727]                   }
[16:12:52.727]                 }
[16:12:52.727]                 else {
[16:12:52.727]                   if (TRUE) {
[16:12:52.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.727]                     {
[16:12:52.727]                       inherits <- base::inherits
[16:12:52.727]                       invokeRestart <- base::invokeRestart
[16:12:52.727]                       is.null <- base::is.null
[16:12:52.727]                       muffled <- FALSE
[16:12:52.727]                       if (inherits(cond, "message")) {
[16:12:52.727]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.727]                         if (muffled) 
[16:12:52.727]                           invokeRestart("muffleMessage")
[16:12:52.727]                       }
[16:12:52.727]                       else if (inherits(cond, "warning")) {
[16:12:52.727]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.727]                         if (muffled) 
[16:12:52.727]                           invokeRestart("muffleWarning")
[16:12:52.727]                       }
[16:12:52.727]                       else if (inherits(cond, "condition")) {
[16:12:52.727]                         if (!is.null(pattern)) {
[16:12:52.727]                           computeRestarts <- base::computeRestarts
[16:12:52.727]                           grepl <- base::grepl
[16:12:52.727]                           restarts <- computeRestarts(cond)
[16:12:52.727]                           for (restart in restarts) {
[16:12:52.727]                             name <- restart$name
[16:12:52.727]                             if (is.null(name)) 
[16:12:52.727]                               next
[16:12:52.727]                             if (!grepl(pattern, name)) 
[16:12:52.727]                               next
[16:12:52.727]                             invokeRestart(restart)
[16:12:52.727]                             muffled <- TRUE
[16:12:52.727]                             break
[16:12:52.727]                           }
[16:12:52.727]                         }
[16:12:52.727]                       }
[16:12:52.727]                       invisible(muffled)
[16:12:52.727]                     }
[16:12:52.727]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.727]                   }
[16:12:52.727]                 }
[16:12:52.727]             }
[16:12:52.727]         }))
[16:12:52.727]     }, error = function(ex) {
[16:12:52.727]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:52.727]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.727]                 ...future.rng), started = ...future.startTime, 
[16:12:52.727]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:52.727]             version = "1.8"), class = "FutureResult")
[16:12:52.727]     }, finally = {
[16:12:52.727]         if (!identical(...future.workdir, getwd())) 
[16:12:52.727]             setwd(...future.workdir)
[16:12:52.727]         {
[16:12:52.727]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:52.727]                 ...future.oldOptions$nwarnings <- NULL
[16:12:52.727]             }
[16:12:52.727]             base::options(...future.oldOptions)
[16:12:52.727]             if (.Platform$OS.type == "windows") {
[16:12:52.727]                 old_names <- names(...future.oldEnvVars)
[16:12:52.727]                 envs <- base::Sys.getenv()
[16:12:52.727]                 names <- names(envs)
[16:12:52.727]                 common <- intersect(names, old_names)
[16:12:52.727]                 added <- setdiff(names, old_names)
[16:12:52.727]                 removed <- setdiff(old_names, names)
[16:12:52.727]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:52.727]                   envs[common]]
[16:12:52.727]                 NAMES <- toupper(changed)
[16:12:52.727]                 args <- list()
[16:12:52.727]                 for (kk in seq_along(NAMES)) {
[16:12:52.727]                   name <- changed[[kk]]
[16:12:52.727]                   NAME <- NAMES[[kk]]
[16:12:52.727]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.727]                     next
[16:12:52.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.727]                 }
[16:12:52.727]                 NAMES <- toupper(added)
[16:12:52.727]                 for (kk in seq_along(NAMES)) {
[16:12:52.727]                   name <- added[[kk]]
[16:12:52.727]                   NAME <- NAMES[[kk]]
[16:12:52.727]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.727]                     next
[16:12:52.727]                   args[[name]] <- ""
[16:12:52.727]                 }
[16:12:52.727]                 NAMES <- toupper(removed)
[16:12:52.727]                 for (kk in seq_along(NAMES)) {
[16:12:52.727]                   name <- removed[[kk]]
[16:12:52.727]                   NAME <- NAMES[[kk]]
[16:12:52.727]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.727]                     next
[16:12:52.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.727]                 }
[16:12:52.727]                 if (length(args) > 0) 
[16:12:52.727]                   base::do.call(base::Sys.setenv, args = args)
[16:12:52.727]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:52.727]             }
[16:12:52.727]             else {
[16:12:52.727]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:52.727]             }
[16:12:52.727]             {
[16:12:52.727]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:52.727]                   0L) {
[16:12:52.727]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:52.727]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:52.727]                   base::options(opts)
[16:12:52.727]                 }
[16:12:52.727]                 {
[16:12:52.727]                   {
[16:12:52.727]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:52.727]                     NULL
[16:12:52.727]                   }
[16:12:52.727]                   options(future.plan = NULL)
[16:12:52.727]                   if (is.na(NA_character_)) 
[16:12:52.727]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.727]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:52.727]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:52.727]                     envir = parent.frame()) 
[16:12:52.727]                   {
[16:12:52.727]                     default_workers <- missing(workers)
[16:12:52.727]                     if (is.function(workers)) 
[16:12:52.727]                       workers <- workers()
[16:12:52.727]                     workers <- structure(as.integer(workers), 
[16:12:52.727]                       class = class(workers))
[16:12:52.727]                     stop_if_not(is.finite(workers), workers >= 
[16:12:52.727]                       1L)
[16:12:52.727]                     if ((workers == 1L && !inherits(workers, 
[16:12:52.727]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:52.727]                       if (default_workers) 
[16:12:52.727]                         supportsMulticore(warn = TRUE)
[16:12:52.727]                       return(sequential(..., envir = envir))
[16:12:52.727]                     }
[16:12:52.727]                     oopts <- options(mc.cores = workers)
[16:12:52.727]                     on.exit(options(oopts))
[16:12:52.727]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:52.727]                       envir = envir)
[16:12:52.727]                     if (!future$lazy) 
[16:12:52.727]                       future <- run(future)
[16:12:52.727]                     invisible(future)
[16:12:52.727]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:52.727]                 }
[16:12:52.727]             }
[16:12:52.727]         }
[16:12:52.727]     })
[16:12:52.727]     if (TRUE) {
[16:12:52.727]         base::sink(type = "output", split = FALSE)
[16:12:52.727]         if (TRUE) {
[16:12:52.727]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:52.727]         }
[16:12:52.727]         else {
[16:12:52.727]             ...future.result["stdout"] <- base::list(NULL)
[16:12:52.727]         }
[16:12:52.727]         base::close(...future.stdout)
[16:12:52.727]         ...future.stdout <- NULL
[16:12:52.727]     }
[16:12:52.727]     ...future.result$conditions <- ...future.conditions
[16:12:52.727]     ...future.result$finished <- base::Sys.time()
[16:12:52.727]     ...future.result
[16:12:52.727] }
[16:12:52.731] requestCore(): workers = 2
[16:12:52.735] MulticoreFuture started
[16:12:52.735] - Launch lazy future ... done
[16:12:52.736] run() for ‘MulticoreFuture’ ... done
[16:12:52.736] plan(): Setting new future strategy stack:
[16:12:52.736] List of future strategies:
[16:12:52.736] 1. sequential:
[16:12:52.736]    - args: function (..., envir = parent.frame())
[16:12:52.736]    - tweaked: FALSE
[16:12:52.736]    - call: NULL
[16:12:52.737] plan(): nbrOfWorkers() = 1
[16:12:52.740] plan(): Setting new future strategy stack:
[16:12:52.740] List of future strategies:
[16:12:52.740] 1. multicore:
[16:12:52.740]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:52.740]    - tweaked: FALSE
[16:12:52.740]    - call: plan(strategy)
[16:12:52.745] plan(): nbrOfWorkers() = 2
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:52.747] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:52.747] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:52.749] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[16:12:52.749] Searching for globals ... DONE
[16:12:52.753] Resolving globals: TRUE
[16:12:52.753] Resolving any globals that are futures ...
[16:12:52.753] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[16:12:52.753] Resolving any globals that are futures ... DONE
[16:12:52.754] Resolving futures part of globals (recursively) ...
[16:12:52.754] resolve() on list ...
[16:12:52.755]  recursive: 99
[16:12:52.755]  length: 1
[16:12:52.755]  elements: ‘x’
[16:12:52.755]  length: 0 (resolved future 1)
[16:12:52.755] resolve() on list ... DONE
[16:12:52.755] - globals: [1] ‘x’
[16:12:52.756] Resolving futures part of globals (recursively) ... DONE
[16:12:52.756] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:52.756] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[16:12:52.756] - globals: [1] ‘x’
[16:12:52.757] 
[16:12:52.757] getGlobalsAndPackages() ... DONE
[16:12:52.757] run() for ‘Future’ ...
[16:12:52.757] - state: ‘created’
[16:12:52.757] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:52.762] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:52.762] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:52.762]   - Field: ‘label’
[16:12:52.762]   - Field: ‘local’
[16:12:52.762]   - Field: ‘owner’
[16:12:52.763]   - Field: ‘envir’
[16:12:52.763]   - Field: ‘workers’
[16:12:52.763]   - Field: ‘packages’
[16:12:52.763]   - Field: ‘gc’
[16:12:52.763]   - Field: ‘job’
[16:12:52.763]   - Field: ‘conditions’
[16:12:52.763]   - Field: ‘expr’
[16:12:52.763]   - Field: ‘uuid’
[16:12:52.764]   - Field: ‘seed’
[16:12:52.764]   - Field: ‘version’
[16:12:52.764]   - Field: ‘result’
[16:12:52.764]   - Field: ‘asynchronous’
[16:12:52.764]   - Field: ‘calls’
[16:12:52.764]   - Field: ‘globals’
[16:12:52.765]   - Field: ‘stdout’
[16:12:52.765]   - Field: ‘earlySignal’
[16:12:52.765]   - Field: ‘lazy’
[16:12:52.765]   - Field: ‘state’
[16:12:52.765] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:52.765] - Launch lazy future ...
[16:12:52.766] Packages needed by the future expression (n = 0): <none>
[16:12:52.766] Packages needed by future strategies (n = 0): <none>
[16:12:52.767] {
[16:12:52.767]     {
[16:12:52.767]         {
[16:12:52.767]             ...future.startTime <- base::Sys.time()
[16:12:52.767]             {
[16:12:52.767]                 {
[16:12:52.767]                   {
[16:12:52.767]                     {
[16:12:52.767]                       base::local({
[16:12:52.767]                         has_future <- base::requireNamespace("future", 
[16:12:52.767]                           quietly = TRUE)
[16:12:52.767]                         if (has_future) {
[16:12:52.767]                           ns <- base::getNamespace("future")
[16:12:52.767]                           version <- ns[[".package"]][["version"]]
[16:12:52.767]                           if (is.null(version)) 
[16:12:52.767]                             version <- utils::packageVersion("future")
[16:12:52.767]                         }
[16:12:52.767]                         else {
[16:12:52.767]                           version <- NULL
[16:12:52.767]                         }
[16:12:52.767]                         if (!has_future || version < "1.8.0") {
[16:12:52.767]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:52.767]                             "", base::R.version$version.string), 
[16:12:52.767]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:52.767]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:52.767]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:52.767]                               "release", "version")], collapse = " "), 
[16:12:52.767]                             hostname = base::Sys.info()[["nodename"]])
[16:12:52.767]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:52.767]                             info)
[16:12:52.767]                           info <- base::paste(info, collapse = "; ")
[16:12:52.767]                           if (!has_future) {
[16:12:52.767]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:52.767]                               info)
[16:12:52.767]                           }
[16:12:52.767]                           else {
[16:12:52.767]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:52.767]                               info, version)
[16:12:52.767]                           }
[16:12:52.767]                           base::stop(msg)
[16:12:52.767]                         }
[16:12:52.767]                       })
[16:12:52.767]                     }
[16:12:52.767]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:52.767]                     base::options(mc.cores = 1L)
[16:12:52.767]                   }
[16:12:52.767]                   options(future.plan = NULL)
[16:12:52.767]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.767]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:52.767]                 }
[16:12:52.767]                 ...future.workdir <- getwd()
[16:12:52.767]             }
[16:12:52.767]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:52.767]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:52.767]         }
[16:12:52.767]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:52.767]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:52.767]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:52.767]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:52.767]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:52.767]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:52.767]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:52.767]             base::names(...future.oldOptions))
[16:12:52.767]     }
[16:12:52.767]     if (FALSE) {
[16:12:52.767]     }
[16:12:52.767]     else {
[16:12:52.767]         if (TRUE) {
[16:12:52.767]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:52.767]                 open = "w")
[16:12:52.767]         }
[16:12:52.767]         else {
[16:12:52.767]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:52.767]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:52.767]         }
[16:12:52.767]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:52.767]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:52.767]             base::sink(type = "output", split = FALSE)
[16:12:52.767]             base::close(...future.stdout)
[16:12:52.767]         }, add = TRUE)
[16:12:52.767]     }
[16:12:52.767]     ...future.frame <- base::sys.nframe()
[16:12:52.767]     ...future.conditions <- base::list()
[16:12:52.767]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:52.767]     if (FALSE) {
[16:12:52.767]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:52.767]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:52.767]     }
[16:12:52.767]     ...future.result <- base::tryCatch({
[16:12:52.767]         base::withCallingHandlers({
[16:12:52.767]             ...future.value <- base::withVisible(base::local({
[16:12:52.767]                 withCallingHandlers({
[16:12:52.767]                   {
[16:12:52.767]                     x <- x + 1
[16:12:52.767]                     x
[16:12:52.767]                   }
[16:12:52.767]                 }, immediateCondition = function(cond) {
[16:12:52.767]                   save_rds <- function (object, pathname, ...) 
[16:12:52.767]                   {
[16:12:52.767]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:52.767]                     if (file_test("-f", pathname_tmp)) {
[16:12:52.767]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.767]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:52.767]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.767]                         fi_tmp[["mtime"]])
[16:12:52.767]                     }
[16:12:52.767]                     tryCatch({
[16:12:52.767]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:52.767]                     }, error = function(ex) {
[16:12:52.767]                       msg <- conditionMessage(ex)
[16:12:52.767]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.767]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:52.767]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.767]                         fi_tmp[["mtime"]], msg)
[16:12:52.767]                       ex$message <- msg
[16:12:52.767]                       stop(ex)
[16:12:52.767]                     })
[16:12:52.767]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:52.767]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:52.767]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:52.767]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.767]                       fi <- file.info(pathname)
[16:12:52.767]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:52.767]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.767]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:52.767]                         fi[["size"]], fi[["mtime"]])
[16:12:52.767]                       stop(msg)
[16:12:52.767]                     }
[16:12:52.767]                     invisible(pathname)
[16:12:52.767]                   }
[16:12:52.767]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:52.767]                     rootPath = tempdir()) 
[16:12:52.767]                   {
[16:12:52.767]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:52.767]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:52.767]                       tmpdir = path, fileext = ".rds")
[16:12:52.767]                     save_rds(obj, file)
[16:12:52.767]                   }
[16:12:52.767]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:52.767]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.767]                   {
[16:12:52.767]                     inherits <- base::inherits
[16:12:52.767]                     invokeRestart <- base::invokeRestart
[16:12:52.767]                     is.null <- base::is.null
[16:12:52.767]                     muffled <- FALSE
[16:12:52.767]                     if (inherits(cond, "message")) {
[16:12:52.767]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:52.767]                       if (muffled) 
[16:12:52.767]                         invokeRestart("muffleMessage")
[16:12:52.767]                     }
[16:12:52.767]                     else if (inherits(cond, "warning")) {
[16:12:52.767]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:52.767]                       if (muffled) 
[16:12:52.767]                         invokeRestart("muffleWarning")
[16:12:52.767]                     }
[16:12:52.767]                     else if (inherits(cond, "condition")) {
[16:12:52.767]                       if (!is.null(pattern)) {
[16:12:52.767]                         computeRestarts <- base::computeRestarts
[16:12:52.767]                         grepl <- base::grepl
[16:12:52.767]                         restarts <- computeRestarts(cond)
[16:12:52.767]                         for (restart in restarts) {
[16:12:52.767]                           name <- restart$name
[16:12:52.767]                           if (is.null(name)) 
[16:12:52.767]                             next
[16:12:52.767]                           if (!grepl(pattern, name)) 
[16:12:52.767]                             next
[16:12:52.767]                           invokeRestart(restart)
[16:12:52.767]                           muffled <- TRUE
[16:12:52.767]                           break
[16:12:52.767]                         }
[16:12:52.767]                       }
[16:12:52.767]                     }
[16:12:52.767]                     invisible(muffled)
[16:12:52.767]                   }
[16:12:52.767]                   muffleCondition(cond)
[16:12:52.767]                 })
[16:12:52.767]             }))
[16:12:52.767]             future::FutureResult(value = ...future.value$value, 
[16:12:52.767]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.767]                   ...future.rng), globalenv = if (FALSE) 
[16:12:52.767]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:52.767]                     ...future.globalenv.names))
[16:12:52.767]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:52.767]         }, condition = base::local({
[16:12:52.767]             c <- base::c
[16:12:52.767]             inherits <- base::inherits
[16:12:52.767]             invokeRestart <- base::invokeRestart
[16:12:52.767]             length <- base::length
[16:12:52.767]             list <- base::list
[16:12:52.767]             seq.int <- base::seq.int
[16:12:52.767]             signalCondition <- base::signalCondition
[16:12:52.767]             sys.calls <- base::sys.calls
[16:12:52.767]             `[[` <- base::`[[`
[16:12:52.767]             `+` <- base::`+`
[16:12:52.767]             `<<-` <- base::`<<-`
[16:12:52.767]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:52.767]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:52.767]                   3L)]
[16:12:52.767]             }
[16:12:52.767]             function(cond) {
[16:12:52.767]                 is_error <- inherits(cond, "error")
[16:12:52.767]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:52.767]                   NULL)
[16:12:52.767]                 if (is_error) {
[16:12:52.767]                   sessionInformation <- function() {
[16:12:52.767]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:52.767]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:52.767]                       search = base::search(), system = base::Sys.info())
[16:12:52.767]                   }
[16:12:52.767]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.767]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:52.767]                     cond$call), session = sessionInformation(), 
[16:12:52.767]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:52.767]                   signalCondition(cond)
[16:12:52.767]                 }
[16:12:52.767]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:52.767]                 "immediateCondition"))) {
[16:12:52.767]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:52.767]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.767]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:52.767]                   if (TRUE && !signal) {
[16:12:52.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.767]                     {
[16:12:52.767]                       inherits <- base::inherits
[16:12:52.767]                       invokeRestart <- base::invokeRestart
[16:12:52.767]                       is.null <- base::is.null
[16:12:52.767]                       muffled <- FALSE
[16:12:52.767]                       if (inherits(cond, "message")) {
[16:12:52.767]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.767]                         if (muffled) 
[16:12:52.767]                           invokeRestart("muffleMessage")
[16:12:52.767]                       }
[16:12:52.767]                       else if (inherits(cond, "warning")) {
[16:12:52.767]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.767]                         if (muffled) 
[16:12:52.767]                           invokeRestart("muffleWarning")
[16:12:52.767]                       }
[16:12:52.767]                       else if (inherits(cond, "condition")) {
[16:12:52.767]                         if (!is.null(pattern)) {
[16:12:52.767]                           computeRestarts <- base::computeRestarts
[16:12:52.767]                           grepl <- base::grepl
[16:12:52.767]                           restarts <- computeRestarts(cond)
[16:12:52.767]                           for (restart in restarts) {
[16:12:52.767]                             name <- restart$name
[16:12:52.767]                             if (is.null(name)) 
[16:12:52.767]                               next
[16:12:52.767]                             if (!grepl(pattern, name)) 
[16:12:52.767]                               next
[16:12:52.767]                             invokeRestart(restart)
[16:12:52.767]                             muffled <- TRUE
[16:12:52.767]                             break
[16:12:52.767]                           }
[16:12:52.767]                         }
[16:12:52.767]                       }
[16:12:52.767]                       invisible(muffled)
[16:12:52.767]                     }
[16:12:52.767]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.767]                   }
[16:12:52.767]                 }
[16:12:52.767]                 else {
[16:12:52.767]                   if (TRUE) {
[16:12:52.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.767]                     {
[16:12:52.767]                       inherits <- base::inherits
[16:12:52.767]                       invokeRestart <- base::invokeRestart
[16:12:52.767]                       is.null <- base::is.null
[16:12:52.767]                       muffled <- FALSE
[16:12:52.767]                       if (inherits(cond, "message")) {
[16:12:52.767]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.767]                         if (muffled) 
[16:12:52.767]                           invokeRestart("muffleMessage")
[16:12:52.767]                       }
[16:12:52.767]                       else if (inherits(cond, "warning")) {
[16:12:52.767]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.767]                         if (muffled) 
[16:12:52.767]                           invokeRestart("muffleWarning")
[16:12:52.767]                       }
[16:12:52.767]                       else if (inherits(cond, "condition")) {
[16:12:52.767]                         if (!is.null(pattern)) {
[16:12:52.767]                           computeRestarts <- base::computeRestarts
[16:12:52.767]                           grepl <- base::grepl
[16:12:52.767]                           restarts <- computeRestarts(cond)
[16:12:52.767]                           for (restart in restarts) {
[16:12:52.767]                             name <- restart$name
[16:12:52.767]                             if (is.null(name)) 
[16:12:52.767]                               next
[16:12:52.767]                             if (!grepl(pattern, name)) 
[16:12:52.767]                               next
[16:12:52.767]                             invokeRestart(restart)
[16:12:52.767]                             muffled <- TRUE
[16:12:52.767]                             break
[16:12:52.767]                           }
[16:12:52.767]                         }
[16:12:52.767]                       }
[16:12:52.767]                       invisible(muffled)
[16:12:52.767]                     }
[16:12:52.767]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.767]                   }
[16:12:52.767]                 }
[16:12:52.767]             }
[16:12:52.767]         }))
[16:12:52.767]     }, error = function(ex) {
[16:12:52.767]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:52.767]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.767]                 ...future.rng), started = ...future.startTime, 
[16:12:52.767]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:52.767]             version = "1.8"), class = "FutureResult")
[16:12:52.767]     }, finally = {
[16:12:52.767]         if (!identical(...future.workdir, getwd())) 
[16:12:52.767]             setwd(...future.workdir)
[16:12:52.767]         {
[16:12:52.767]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:52.767]                 ...future.oldOptions$nwarnings <- NULL
[16:12:52.767]             }
[16:12:52.767]             base::options(...future.oldOptions)
[16:12:52.767]             if (.Platform$OS.type == "windows") {
[16:12:52.767]                 old_names <- names(...future.oldEnvVars)
[16:12:52.767]                 envs <- base::Sys.getenv()
[16:12:52.767]                 names <- names(envs)
[16:12:52.767]                 common <- intersect(names, old_names)
[16:12:52.767]                 added <- setdiff(names, old_names)
[16:12:52.767]                 removed <- setdiff(old_names, names)
[16:12:52.767]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:52.767]                   envs[common]]
[16:12:52.767]                 NAMES <- toupper(changed)
[16:12:52.767]                 args <- list()
[16:12:52.767]                 for (kk in seq_along(NAMES)) {
[16:12:52.767]                   name <- changed[[kk]]
[16:12:52.767]                   NAME <- NAMES[[kk]]
[16:12:52.767]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.767]                     next
[16:12:52.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.767]                 }
[16:12:52.767]                 NAMES <- toupper(added)
[16:12:52.767]                 for (kk in seq_along(NAMES)) {
[16:12:52.767]                   name <- added[[kk]]
[16:12:52.767]                   NAME <- NAMES[[kk]]
[16:12:52.767]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.767]                     next
[16:12:52.767]                   args[[name]] <- ""
[16:12:52.767]                 }
[16:12:52.767]                 NAMES <- toupper(removed)
[16:12:52.767]                 for (kk in seq_along(NAMES)) {
[16:12:52.767]                   name <- removed[[kk]]
[16:12:52.767]                   NAME <- NAMES[[kk]]
[16:12:52.767]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.767]                     next
[16:12:52.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.767]                 }
[16:12:52.767]                 if (length(args) > 0) 
[16:12:52.767]                   base::do.call(base::Sys.setenv, args = args)
[16:12:52.767]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:52.767]             }
[16:12:52.767]             else {
[16:12:52.767]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:52.767]             }
[16:12:52.767]             {
[16:12:52.767]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:52.767]                   0L) {
[16:12:52.767]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:52.767]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:52.767]                   base::options(opts)
[16:12:52.767]                 }
[16:12:52.767]                 {
[16:12:52.767]                   {
[16:12:52.767]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:52.767]                     NULL
[16:12:52.767]                   }
[16:12:52.767]                   options(future.plan = NULL)
[16:12:52.767]                   if (is.na(NA_character_)) 
[16:12:52.767]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.767]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:52.767]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:52.767]                     envir = parent.frame()) 
[16:12:52.767]                   {
[16:12:52.767]                     default_workers <- missing(workers)
[16:12:52.767]                     if (is.function(workers)) 
[16:12:52.767]                       workers <- workers()
[16:12:52.767]                     workers <- structure(as.integer(workers), 
[16:12:52.767]                       class = class(workers))
[16:12:52.767]                     stop_if_not(is.finite(workers), workers >= 
[16:12:52.767]                       1L)
[16:12:52.767]                     if ((workers == 1L && !inherits(workers, 
[16:12:52.767]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:52.767]                       if (default_workers) 
[16:12:52.767]                         supportsMulticore(warn = TRUE)
[16:12:52.767]                       return(sequential(..., envir = envir))
[16:12:52.767]                     }
[16:12:52.767]                     oopts <- options(mc.cores = workers)
[16:12:52.767]                     on.exit(options(oopts))
[16:12:52.767]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:52.767]                       envir = envir)
[16:12:52.767]                     if (!future$lazy) 
[16:12:52.767]                       future <- run(future)
[16:12:52.767]                     invisible(future)
[16:12:52.767]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:52.767]                 }
[16:12:52.767]             }
[16:12:52.767]         }
[16:12:52.767]     })
[16:12:52.767]     if (TRUE) {
[16:12:52.767]         base::sink(type = "output", split = FALSE)
[16:12:52.767]         if (TRUE) {
[16:12:52.767]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:52.767]         }
[16:12:52.767]         else {
[16:12:52.767]             ...future.result["stdout"] <- base::list(NULL)
[16:12:52.767]         }
[16:12:52.767]         base::close(...future.stdout)
[16:12:52.767]         ...future.stdout <- NULL
[16:12:52.767]     }
[16:12:52.767]     ...future.result$conditions <- ...future.conditions
[16:12:52.767]     ...future.result$finished <- base::Sys.time()
[16:12:52.767]     ...future.result
[16:12:52.767] }
[16:12:52.769] assign_globals() ...
[16:12:52.769] List of 1
[16:12:52.769]  $ x: num 1
[16:12:52.769]  - attr(*, "where")=List of 1
[16:12:52.769]   ..$ x:<environment: R_EmptyEnv> 
[16:12:52.769]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:52.769]  - attr(*, "resolved")= logi TRUE
[16:12:52.769]  - attr(*, "total_size")= num 56
[16:12:52.769]  - attr(*, "already-done")= logi TRUE
[16:12:52.772] - copied ‘x’ to environment
[16:12:52.772] assign_globals() ... done
[16:12:52.773] requestCore(): workers = 2
[16:12:52.774] MulticoreFuture started
[16:12:52.775] - Launch lazy future ... done
[16:12:52.775] run() for ‘MulticoreFuture’ ... done
[16:12:52.776] plan(): Setting new future strategy stack:
[16:12:52.776] List of future strategies:
[16:12:52.776] 1. sequential:
[16:12:52.776]    - args: function (..., envir = parent.frame())
[16:12:52.776]    - tweaked: FALSE
[16:12:52.776]    - call: NULL
[16:12:52.777] plan(): nbrOfWorkers() = 1
[16:12:52.779] plan(): Setting new future strategy stack:
[16:12:52.779] List of future strategies:
[16:12:52.779] 1. multicore:
[16:12:52.779]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:52.779]    - tweaked: FALSE
[16:12:52.779]    - call: plan(strategy)
[16:12:52.784] plan(): nbrOfWorkers() = 2
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:52.786] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:52.786] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:52.788] - globals found: [3] ‘{’, ‘<-’, ‘x’
[16:12:52.789] Searching for globals ... DONE
[16:12:52.789] Resolving globals: TRUE
[16:12:52.789] Resolving any globals that are futures ...
[16:12:52.789] - globals: [3] ‘{’, ‘<-’, ‘x’
[16:12:52.789] Resolving any globals that are futures ... DONE
[16:12:52.790] Resolving futures part of globals (recursively) ...
[16:12:52.790] resolve() on list ...
[16:12:52.790]  recursive: 99
[16:12:52.790]  length: 1
[16:12:52.790]  elements: ‘x’
[16:12:52.790]  length: 0 (resolved future 1)
[16:12:52.791] resolve() on list ... DONE
[16:12:52.791] - globals: [1] ‘x’
[16:12:52.791] Resolving futures part of globals (recursively) ... DONE
[16:12:52.791] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[16:12:52.791] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[16:12:52.792] - globals: [1] ‘x’
[16:12:52.792] 
[16:12:52.792] getGlobalsAndPackages() ... DONE
[16:12:52.792] run() for ‘Future’ ...
[16:12:52.792] - state: ‘created’
[16:12:52.792] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:52.797] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:52.797] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:52.797]   - Field: ‘label’
[16:12:52.797]   - Field: ‘local’
[16:12:52.797]   - Field: ‘owner’
[16:12:52.797]   - Field: ‘envir’
[16:12:52.797]   - Field: ‘workers’
[16:12:52.798]   - Field: ‘packages’
[16:12:52.798]   - Field: ‘gc’
[16:12:52.798]   - Field: ‘job’
[16:12:52.798]   - Field: ‘conditions’
[16:12:52.798]   - Field: ‘expr’
[16:12:52.798]   - Field: ‘uuid’
[16:12:52.798]   - Field: ‘seed’
[16:12:52.798]   - Field: ‘version’
[16:12:52.798]   - Field: ‘result’
[16:12:52.799]   - Field: ‘asynchronous’
[16:12:52.799]   - Field: ‘calls’
[16:12:52.799]   - Field: ‘globals’
[16:12:52.799]   - Field: ‘stdout’
[16:12:52.799]   - Field: ‘earlySignal’
[16:12:52.799]   - Field: ‘lazy’
[16:12:52.799]   - Field: ‘state’
[16:12:52.799] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:52.800] - Launch lazy future ...
[16:12:52.800] Packages needed by the future expression (n = 0): <none>
[16:12:52.800] Packages needed by future strategies (n = 0): <none>
[16:12:52.801] {
[16:12:52.801]     {
[16:12:52.801]         {
[16:12:52.801]             ...future.startTime <- base::Sys.time()
[16:12:52.801]             {
[16:12:52.801]                 {
[16:12:52.801]                   {
[16:12:52.801]                     {
[16:12:52.801]                       base::local({
[16:12:52.801]                         has_future <- base::requireNamespace("future", 
[16:12:52.801]                           quietly = TRUE)
[16:12:52.801]                         if (has_future) {
[16:12:52.801]                           ns <- base::getNamespace("future")
[16:12:52.801]                           version <- ns[[".package"]][["version"]]
[16:12:52.801]                           if (is.null(version)) 
[16:12:52.801]                             version <- utils::packageVersion("future")
[16:12:52.801]                         }
[16:12:52.801]                         else {
[16:12:52.801]                           version <- NULL
[16:12:52.801]                         }
[16:12:52.801]                         if (!has_future || version < "1.8.0") {
[16:12:52.801]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:52.801]                             "", base::R.version$version.string), 
[16:12:52.801]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:52.801]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:52.801]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:52.801]                               "release", "version")], collapse = " "), 
[16:12:52.801]                             hostname = base::Sys.info()[["nodename"]])
[16:12:52.801]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:52.801]                             info)
[16:12:52.801]                           info <- base::paste(info, collapse = "; ")
[16:12:52.801]                           if (!has_future) {
[16:12:52.801]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:52.801]                               info)
[16:12:52.801]                           }
[16:12:52.801]                           else {
[16:12:52.801]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:52.801]                               info, version)
[16:12:52.801]                           }
[16:12:52.801]                           base::stop(msg)
[16:12:52.801]                         }
[16:12:52.801]                       })
[16:12:52.801]                     }
[16:12:52.801]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:52.801]                     base::options(mc.cores = 1L)
[16:12:52.801]                   }
[16:12:52.801]                   options(future.plan = NULL)
[16:12:52.801]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.801]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:52.801]                 }
[16:12:52.801]                 ...future.workdir <- getwd()
[16:12:52.801]             }
[16:12:52.801]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:52.801]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:52.801]         }
[16:12:52.801]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:52.801]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:52.801]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:52.801]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:52.801]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:52.801]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:52.801]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:52.801]             base::names(...future.oldOptions))
[16:12:52.801]     }
[16:12:52.801]     if (FALSE) {
[16:12:52.801]     }
[16:12:52.801]     else {
[16:12:52.801]         if (TRUE) {
[16:12:52.801]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:52.801]                 open = "w")
[16:12:52.801]         }
[16:12:52.801]         else {
[16:12:52.801]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:52.801]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:52.801]         }
[16:12:52.801]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:52.801]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:52.801]             base::sink(type = "output", split = FALSE)
[16:12:52.801]             base::close(...future.stdout)
[16:12:52.801]         }, add = TRUE)
[16:12:52.801]     }
[16:12:52.801]     ...future.frame <- base::sys.nframe()
[16:12:52.801]     ...future.conditions <- base::list()
[16:12:52.801]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:52.801]     if (FALSE) {
[16:12:52.801]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:52.801]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:52.801]     }
[16:12:52.801]     ...future.result <- base::tryCatch({
[16:12:52.801]         base::withCallingHandlers({
[16:12:52.801]             ...future.value <- base::withVisible(base::local({
[16:12:52.801]                 withCallingHandlers({
[16:12:52.801]                   {
[16:12:52.801]                     x <- x()
[16:12:52.801]                     x
[16:12:52.801]                   }
[16:12:52.801]                 }, immediateCondition = function(cond) {
[16:12:52.801]                   save_rds <- function (object, pathname, ...) 
[16:12:52.801]                   {
[16:12:52.801]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:52.801]                     if (file_test("-f", pathname_tmp)) {
[16:12:52.801]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.801]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:52.801]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.801]                         fi_tmp[["mtime"]])
[16:12:52.801]                     }
[16:12:52.801]                     tryCatch({
[16:12:52.801]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:52.801]                     }, error = function(ex) {
[16:12:52.801]                       msg <- conditionMessage(ex)
[16:12:52.801]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.801]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:52.801]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.801]                         fi_tmp[["mtime"]], msg)
[16:12:52.801]                       ex$message <- msg
[16:12:52.801]                       stop(ex)
[16:12:52.801]                     })
[16:12:52.801]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:52.801]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:52.801]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:52.801]                       fi_tmp <- file.info(pathname_tmp)
[16:12:52.801]                       fi <- file.info(pathname)
[16:12:52.801]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:52.801]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:52.801]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:52.801]                         fi[["size"]], fi[["mtime"]])
[16:12:52.801]                       stop(msg)
[16:12:52.801]                     }
[16:12:52.801]                     invisible(pathname)
[16:12:52.801]                   }
[16:12:52.801]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:52.801]                     rootPath = tempdir()) 
[16:12:52.801]                   {
[16:12:52.801]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:52.801]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:52.801]                       tmpdir = path, fileext = ".rds")
[16:12:52.801]                     save_rds(obj, file)
[16:12:52.801]                   }
[16:12:52.801]                   saveImmediateCondition(cond, path = "/tmp/RtmpwnSrTh/.future/immediateConditions")
[16:12:52.801]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.801]                   {
[16:12:52.801]                     inherits <- base::inherits
[16:12:52.801]                     invokeRestart <- base::invokeRestart
[16:12:52.801]                     is.null <- base::is.null
[16:12:52.801]                     muffled <- FALSE
[16:12:52.801]                     if (inherits(cond, "message")) {
[16:12:52.801]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:52.801]                       if (muffled) 
[16:12:52.801]                         invokeRestart("muffleMessage")
[16:12:52.801]                     }
[16:12:52.801]                     else if (inherits(cond, "warning")) {
[16:12:52.801]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:52.801]                       if (muffled) 
[16:12:52.801]                         invokeRestart("muffleWarning")
[16:12:52.801]                     }
[16:12:52.801]                     else if (inherits(cond, "condition")) {
[16:12:52.801]                       if (!is.null(pattern)) {
[16:12:52.801]                         computeRestarts <- base::computeRestarts
[16:12:52.801]                         grepl <- base::grepl
[16:12:52.801]                         restarts <- computeRestarts(cond)
[16:12:52.801]                         for (restart in restarts) {
[16:12:52.801]                           name <- restart$name
[16:12:52.801]                           if (is.null(name)) 
[16:12:52.801]                             next
[16:12:52.801]                           if (!grepl(pattern, name)) 
[16:12:52.801]                             next
[16:12:52.801]                           invokeRestart(restart)
[16:12:52.801]                           muffled <- TRUE
[16:12:52.801]                           break
[16:12:52.801]                         }
[16:12:52.801]                       }
[16:12:52.801]                     }
[16:12:52.801]                     invisible(muffled)
[16:12:52.801]                   }
[16:12:52.801]                   muffleCondition(cond)
[16:12:52.801]                 })
[16:12:52.801]             }))
[16:12:52.801]             future::FutureResult(value = ...future.value$value, 
[16:12:52.801]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.801]                   ...future.rng), globalenv = if (FALSE) 
[16:12:52.801]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:52.801]                     ...future.globalenv.names))
[16:12:52.801]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:52.801]         }, condition = base::local({
[16:12:52.801]             c <- base::c
[16:12:52.801]             inherits <- base::inherits
[16:12:52.801]             invokeRestart <- base::invokeRestart
[16:12:52.801]             length <- base::length
[16:12:52.801]             list <- base::list
[16:12:52.801]             seq.int <- base::seq.int
[16:12:52.801]             signalCondition <- base::signalCondition
[16:12:52.801]             sys.calls <- base::sys.calls
[16:12:52.801]             `[[` <- base::`[[`
[16:12:52.801]             `+` <- base::`+`
[16:12:52.801]             `<<-` <- base::`<<-`
[16:12:52.801]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:52.801]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:52.801]                   3L)]
[16:12:52.801]             }
[16:12:52.801]             function(cond) {
[16:12:52.801]                 is_error <- inherits(cond, "error")
[16:12:52.801]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:52.801]                   NULL)
[16:12:52.801]                 if (is_error) {
[16:12:52.801]                   sessionInformation <- function() {
[16:12:52.801]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:52.801]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:52.801]                       search = base::search(), system = base::Sys.info())
[16:12:52.801]                   }
[16:12:52.801]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.801]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:52.801]                     cond$call), session = sessionInformation(), 
[16:12:52.801]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:52.801]                   signalCondition(cond)
[16:12:52.801]                 }
[16:12:52.801]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:52.801]                 "immediateCondition"))) {
[16:12:52.801]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:52.801]                   ...future.conditions[[length(...future.conditions) + 
[16:12:52.801]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:52.801]                   if (TRUE && !signal) {
[16:12:52.801]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.801]                     {
[16:12:52.801]                       inherits <- base::inherits
[16:12:52.801]                       invokeRestart <- base::invokeRestart
[16:12:52.801]                       is.null <- base::is.null
[16:12:52.801]                       muffled <- FALSE
[16:12:52.801]                       if (inherits(cond, "message")) {
[16:12:52.801]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.801]                         if (muffled) 
[16:12:52.801]                           invokeRestart("muffleMessage")
[16:12:52.801]                       }
[16:12:52.801]                       else if (inherits(cond, "warning")) {
[16:12:52.801]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.801]                         if (muffled) 
[16:12:52.801]                           invokeRestart("muffleWarning")
[16:12:52.801]                       }
[16:12:52.801]                       else if (inherits(cond, "condition")) {
[16:12:52.801]                         if (!is.null(pattern)) {
[16:12:52.801]                           computeRestarts <- base::computeRestarts
[16:12:52.801]                           grepl <- base::grepl
[16:12:52.801]                           restarts <- computeRestarts(cond)
[16:12:52.801]                           for (restart in restarts) {
[16:12:52.801]                             name <- restart$name
[16:12:52.801]                             if (is.null(name)) 
[16:12:52.801]                               next
[16:12:52.801]                             if (!grepl(pattern, name)) 
[16:12:52.801]                               next
[16:12:52.801]                             invokeRestart(restart)
[16:12:52.801]                             muffled <- TRUE
[16:12:52.801]                             break
[16:12:52.801]                           }
[16:12:52.801]                         }
[16:12:52.801]                       }
[16:12:52.801]                       invisible(muffled)
[16:12:52.801]                     }
[16:12:52.801]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.801]                   }
[16:12:52.801]                 }
[16:12:52.801]                 else {
[16:12:52.801]                   if (TRUE) {
[16:12:52.801]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:52.801]                     {
[16:12:52.801]                       inherits <- base::inherits
[16:12:52.801]                       invokeRestart <- base::invokeRestart
[16:12:52.801]                       is.null <- base::is.null
[16:12:52.801]                       muffled <- FALSE
[16:12:52.801]                       if (inherits(cond, "message")) {
[16:12:52.801]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:52.801]                         if (muffled) 
[16:12:52.801]                           invokeRestart("muffleMessage")
[16:12:52.801]                       }
[16:12:52.801]                       else if (inherits(cond, "warning")) {
[16:12:52.801]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:52.801]                         if (muffled) 
[16:12:52.801]                           invokeRestart("muffleWarning")
[16:12:52.801]                       }
[16:12:52.801]                       else if (inherits(cond, "condition")) {
[16:12:52.801]                         if (!is.null(pattern)) {
[16:12:52.801]                           computeRestarts <- base::computeRestarts
[16:12:52.801]                           grepl <- base::grepl
[16:12:52.801]                           restarts <- computeRestarts(cond)
[16:12:52.801]                           for (restart in restarts) {
[16:12:52.801]                             name <- restart$name
[16:12:52.801]                             if (is.null(name)) 
[16:12:52.801]                               next
[16:12:52.801]                             if (!grepl(pattern, name)) 
[16:12:52.801]                               next
[16:12:52.801]                             invokeRestart(restart)
[16:12:52.801]                             muffled <- TRUE
[16:12:52.801]                             break
[16:12:52.801]                           }
[16:12:52.801]                         }
[16:12:52.801]                       }
[16:12:52.801]                       invisible(muffled)
[16:12:52.801]                     }
[16:12:52.801]                     muffleCondition(cond, pattern = "^muffle")
[16:12:52.801]                   }
[16:12:52.801]                 }
[16:12:52.801]             }
[16:12:52.801]         }))
[16:12:52.801]     }, error = function(ex) {
[16:12:52.801]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:52.801]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:52.801]                 ...future.rng), started = ...future.startTime, 
[16:12:52.801]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:52.801]             version = "1.8"), class = "FutureResult")
[16:12:52.801]     }, finally = {
[16:12:52.801]         if (!identical(...future.workdir, getwd())) 
[16:12:52.801]             setwd(...future.workdir)
[16:12:52.801]         {
[16:12:52.801]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:52.801]                 ...future.oldOptions$nwarnings <- NULL
[16:12:52.801]             }
[16:12:52.801]             base::options(...future.oldOptions)
[16:12:52.801]             if (.Platform$OS.type == "windows") {
[16:12:52.801]                 old_names <- names(...future.oldEnvVars)
[16:12:52.801]                 envs <- base::Sys.getenv()
[16:12:52.801]                 names <- names(envs)
[16:12:52.801]                 common <- intersect(names, old_names)
[16:12:52.801]                 added <- setdiff(names, old_names)
[16:12:52.801]                 removed <- setdiff(old_names, names)
[16:12:52.801]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:52.801]                   envs[common]]
[16:12:52.801]                 NAMES <- toupper(changed)
[16:12:52.801]                 args <- list()
[16:12:52.801]                 for (kk in seq_along(NAMES)) {
[16:12:52.801]                   name <- changed[[kk]]
[16:12:52.801]                   NAME <- NAMES[[kk]]
[16:12:52.801]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.801]                     next
[16:12:52.801]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.801]                 }
[16:12:52.801]                 NAMES <- toupper(added)
[16:12:52.801]                 for (kk in seq_along(NAMES)) {
[16:12:52.801]                   name <- added[[kk]]
[16:12:52.801]                   NAME <- NAMES[[kk]]
[16:12:52.801]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.801]                     next
[16:12:52.801]                   args[[name]] <- ""
[16:12:52.801]                 }
[16:12:52.801]                 NAMES <- toupper(removed)
[16:12:52.801]                 for (kk in seq_along(NAMES)) {
[16:12:52.801]                   name <- removed[[kk]]
[16:12:52.801]                   NAME <- NAMES[[kk]]
[16:12:52.801]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:52.801]                     next
[16:12:52.801]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:52.801]                 }
[16:12:52.801]                 if (length(args) > 0) 
[16:12:52.801]                   base::do.call(base::Sys.setenv, args = args)
[16:12:52.801]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:52.801]             }
[16:12:52.801]             else {
[16:12:52.801]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:52.801]             }
[16:12:52.801]             {
[16:12:52.801]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:52.801]                   0L) {
[16:12:52.801]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:52.801]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:52.801]                   base::options(opts)
[16:12:52.801]                 }
[16:12:52.801]                 {
[16:12:52.801]                   {
[16:12:52.801]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:52.801]                     NULL
[16:12:52.801]                   }
[16:12:52.801]                   options(future.plan = NULL)
[16:12:52.801]                   if (is.na(NA_character_)) 
[16:12:52.801]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:52.801]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:52.801]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:52.801]                     envir = parent.frame()) 
[16:12:52.801]                   {
[16:12:52.801]                     default_workers <- missing(workers)
[16:12:52.801]                     if (is.function(workers)) 
[16:12:52.801]                       workers <- workers()
[16:12:52.801]                     workers <- structure(as.integer(workers), 
[16:12:52.801]                       class = class(workers))
[16:12:52.801]                     stop_if_not(is.finite(workers), workers >= 
[16:12:52.801]                       1L)
[16:12:52.801]                     if ((workers == 1L && !inherits(workers, 
[16:12:52.801]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:52.801]                       if (default_workers) 
[16:12:52.801]                         supportsMulticore(warn = TRUE)
[16:12:52.801]                       return(sequential(..., envir = envir))
[16:12:52.801]                     }
[16:12:52.801]                     oopts <- options(mc.cores = workers)
[16:12:52.801]                     on.exit(options(oopts))
[16:12:52.801]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:52.801]                       envir = envir)
[16:12:52.801]                     if (!future$lazy) 
[16:12:52.801]                       future <- run(future)
[16:12:52.801]                     invisible(future)
[16:12:52.801]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:52.801]                 }
[16:12:52.801]             }
[16:12:52.801]         }
[16:12:52.801]     })
[16:12:52.801]     if (TRUE) {
[16:12:52.801]         base::sink(type = "output", split = FALSE)
[16:12:52.801]         if (TRUE) {
[16:12:52.801]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:52.801]         }
[16:12:52.801]         else {
[16:12:52.801]             ...future.result["stdout"] <- base::list(NULL)
[16:12:52.801]         }
[16:12:52.801]         base::close(...future.stdout)
[16:12:52.801]         ...future.stdout <- NULL
[16:12:52.801]     }
[16:12:52.801]     ...future.result$conditions <- ...future.conditions
[16:12:52.801]     ...future.result$finished <- base::Sys.time()
[16:12:52.801]     ...future.result
[16:12:52.801] }
[16:12:52.806] assign_globals() ...
[16:12:52.806] List of 1
[16:12:52.806]  $ x:function ()  
[16:12:52.806]  - attr(*, "where")=List of 1
[16:12:52.806]   ..$ x:<environment: R_EmptyEnv> 
[16:12:52.806]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:52.806]  - attr(*, "resolved")= logi TRUE
[16:12:52.806]  - attr(*, "total_size")= num 1032
[16:12:52.806]  - attr(*, "already-done")= logi TRUE
[16:12:52.810] - reassign environment for ‘x’
[16:12:52.810] - copied ‘x’ to environment
[16:12:52.810] assign_globals() ... done
[16:12:52.810] requestCore(): workers = 2
[16:12:52.813] MulticoreFuture started
[16:12:52.813] - Launch lazy future ... done
[16:12:52.813] run() for ‘MulticoreFuture’ ... done
[16:12:52.814] plan(): Setting new future strategy stack:
[16:12:52.814] List of future strategies:
[16:12:52.814] 1. sequential:
[16:12:52.814]    - args: function (..., envir = parent.frame())
[16:12:52.814]    - tweaked: FALSE
[16:12:52.814]    - call: NULL
[16:12:52.815] plan(): nbrOfWorkers() = 1
[16:12:52.817] plan(): Setting new future strategy stack:
[16:12:52.818] List of future strategies:
[16:12:52.818] 1. multicore:
[16:12:52.818]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:52.818]    - tweaked: FALSE
[16:12:52.818]    - call: plan(strategy)
[16:12:52.824] plan(): nbrOfWorkers() = 2
value(f) = ‘TRUE’
- plan('multisession') ...
[16:12:52.826] plan(): Setting new future strategy stack:
[16:12:52.826] List of future strategies:
[16:12:52.826] 1. multisession:
[16:12:52.826]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:12:52.826]    - tweaked: FALSE
[16:12:52.826]    - call: plan(strategy)
[16:12:52.827] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:12:52.827] multisession:
[16:12:52.827] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:12:52.827] - tweaked: FALSE
[16:12:52.827] - call: plan(strategy)
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:52.836] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:52.837] Not searching for globals
[16:12:52.837] - globals: [0] <none>
[16:12:52.837] getGlobalsAndPackages() ... DONE
[16:12:52.838] [local output] makeClusterPSOCK() ...
[16:12:52.883] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:12:52.888] [local output] Base port: 11424
[16:12:52.889] [local output] Getting setup options for 2 cluster nodes ...
[16:12:52.889] [local output]  - Node 1 of 2 ...
[16:12:52.889] [local output] localMachine=TRUE => revtunnel=FALSE

[16:12:52.890] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpwnSrTh/worker.rank=1.parallelly.parent=86187.150ab3b8c0b4d.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpwnSrTh/worker.rank=1.parallelly.parent=86187.150ab3b8c0b4d.pid")'’
[16:12:53.081] - Possible to infer worker's PID: TRUE
[16:12:53.081] [local output] Rscript port: 11424

[16:12:53.082] [local output]  - Node 2 of 2 ...
[16:12:53.082] [local output] localMachine=TRUE => revtunnel=FALSE

[16:12:53.083] [local output] Rscript port: 11424

[16:12:53.083] [local output] Getting setup options for 2 cluster nodes ... done
[16:12:53.083] [local output]  - Parallel setup requested for some PSOCK nodes
[16:12:53.084] [local output] Setting up PSOCK nodes in parallel
[16:12:53.084] List of 36
[16:12:53.084]  $ worker          : chr "localhost"
[16:12:53.084]   ..- attr(*, "localhost")= logi TRUE
[16:12:53.084]  $ master          : chr "localhost"
[16:12:53.084]  $ port            : int 11424
[16:12:53.084]  $ connectTimeout  : num 120
[16:12:53.084]  $ timeout         : num 2592000
[16:12:53.084]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:12:53.084]  $ homogeneous     : logi TRUE
[16:12:53.084]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:12:53.084]  $ rscript_envs    : NULL
[16:12:53.084]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:12:53.084]  $ rscript_startup : NULL
[16:12:53.084]  $ rscript_sh      : chr "sh"
[16:12:53.084]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:12:53.084]  $ methods         : logi TRUE
[16:12:53.084]  $ socketOptions   : chr "no-delay"
[16:12:53.084]  $ useXDR          : logi FALSE
[16:12:53.084]  $ outfile         : chr "/dev/null"
[16:12:53.084]  $ renice          : int NA
[16:12:53.084]  $ rshcmd          : NULL
[16:12:53.084]  $ user            : chr(0) 
[16:12:53.084]  $ revtunnel       : logi FALSE
[16:12:53.084]  $ rshlogfile      : NULL
[16:12:53.084]  $ rshopts         : chr(0) 
[16:12:53.084]  $ rank            : int 1
[16:12:53.084]  $ manual          : logi FALSE
[16:12:53.084]  $ dryrun          : logi FALSE
[16:12:53.084]  $ quiet           : logi FALSE
[16:12:53.084]  $ setup_strategy  : chr "parallel"
[16:12:53.084]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:12:53.084]  $ pidfile         : chr "/tmp/RtmpwnSrTh/worker.rank=1.parallelly.parent=86187.150ab3b8c0b4d.pid"
[16:12:53.084]  $ rshcmd_label    : NULL
[16:12:53.084]  $ rsh_call        : NULL
[16:12:53.084]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:12:53.084]  $ localMachine    : logi TRUE
[16:12:53.084]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:12:53.084]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:12:53.084]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:12:53.084]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:12:53.084]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:12:53.084]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:12:53.084]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:12:53.084]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:12:53.084]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:12:53.084]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:12:53.084]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:12:53.084]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:12:53.084]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:12:53.084]  $ arguments       :List of 28
[16:12:53.084]   ..$ worker          : chr "localhost"
[16:12:53.084]   ..$ master          : NULL
[16:12:53.084]   ..$ port            : int 11424
[16:12:53.084]   ..$ connectTimeout  : num 120
[16:12:53.084]   ..$ timeout         : num 2592000
[16:12:53.084]   ..$ rscript         : NULL
[16:12:53.084]   ..$ homogeneous     : NULL
[16:12:53.084]   ..$ rscript_args    : NULL
[16:12:53.084]   ..$ rscript_envs    : NULL
[16:12:53.084]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:12:53.084]   ..$ rscript_startup : NULL
[16:12:53.084]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:12:53.084]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:12:53.084]   ..$ methods         : logi TRUE
[16:12:53.084]   ..$ socketOptions   : chr "no-delay"
[16:12:53.084]   ..$ useXDR          : logi FALSE
[16:12:53.084]   ..$ outfile         : chr "/dev/null"
[16:12:53.084]   ..$ renice          : int NA
[16:12:53.084]   ..$ rshcmd          : NULL
[16:12:53.084]   ..$ user            : NULL
[16:12:53.084]   ..$ revtunnel       : logi NA
[16:12:53.084]   ..$ rshlogfile      : NULL
[16:12:53.084]   ..$ rshopts         : NULL
[16:12:53.084]   ..$ rank            : int 1
[16:12:53.084]   ..$ manual          : logi FALSE
[16:12:53.084]   ..$ dryrun          : logi FALSE
[16:12:53.084]   ..$ quiet           : logi FALSE
[16:12:53.084]   ..$ setup_strategy  : chr "parallel"
[16:12:53.084]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:12:53.102] [local output] System call to launch all workers:
[16:12:53.102] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpwnSrTh/worker.rank=1.parallelly.parent=86187.150ab3b8c0b4d.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11424 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:12:53.102] [local output] Starting PSOCK main server
[16:12:53.103] [local output] Workers launched
[16:12:53.103] [local output] Waiting for workers to connect back
[16:12:53.104]  - [local output] 0 workers out of 2 ready
[16:12:53.350]  - [local output] 0 workers out of 2 ready
[16:12:53.351]  - [local output] 1 workers out of 2 ready
[16:12:53.351]  - [local output] 2 workers out of 2 ready
[16:12:53.351] [local output] Launching of workers completed
[16:12:53.351] [local output] Collecting session information from workers
[16:12:53.352] [local output]  - Worker #1 of 2
[16:12:53.353] [local output]  - Worker #2 of 2
[16:12:53.353] [local output] makeClusterPSOCK() ... done
[16:12:53.365] Packages needed by the future expression (n = 0): <none>
[16:12:53.365] Packages needed by future strategies (n = 0): <none>
[16:12:53.366] {
[16:12:53.366]     {
[16:12:53.366]         {
[16:12:53.366]             ...future.startTime <- base::Sys.time()
[16:12:53.366]             {
[16:12:53.366]                 {
[16:12:53.366]                   {
[16:12:53.366]                     {
[16:12:53.366]                       base::local({
[16:12:53.366]                         has_future <- base::requireNamespace("future", 
[16:12:53.366]                           quietly = TRUE)
[16:12:53.366]                         if (has_future) {
[16:12:53.366]                           ns <- base::getNamespace("future")
[16:12:53.366]                           version <- ns[[".package"]][["version"]]
[16:12:53.366]                           if (is.null(version)) 
[16:12:53.366]                             version <- utils::packageVersion("future")
[16:12:53.366]                         }
[16:12:53.366]                         else {
[16:12:53.366]                           version <- NULL
[16:12:53.366]                         }
[16:12:53.366]                         if (!has_future || version < "1.8.0") {
[16:12:53.366]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:53.366]                             "", base::R.version$version.string), 
[16:12:53.366]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:53.366]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:53.366]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:53.366]                               "release", "version")], collapse = " "), 
[16:12:53.366]                             hostname = base::Sys.info()[["nodename"]])
[16:12:53.366]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:53.366]                             info)
[16:12:53.366]                           info <- base::paste(info, collapse = "; ")
[16:12:53.366]                           if (!has_future) {
[16:12:53.366]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:53.366]                               info)
[16:12:53.366]                           }
[16:12:53.366]                           else {
[16:12:53.366]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:53.366]                               info, version)
[16:12:53.366]                           }
[16:12:53.366]                           base::stop(msg)
[16:12:53.366]                         }
[16:12:53.366]                       })
[16:12:53.366]                     }
[16:12:53.366]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:53.366]                     base::options(mc.cores = 1L)
[16:12:53.366]                   }
[16:12:53.366]                   options(future.plan = NULL)
[16:12:53.366]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:53.366]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:53.366]                 }
[16:12:53.366]                 ...future.workdir <- getwd()
[16:12:53.366]             }
[16:12:53.366]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:53.366]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:53.366]         }
[16:12:53.366]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:53.366]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:53.366]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:53.366]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:53.366]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:53.366]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:53.366]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:53.366]             base::names(...future.oldOptions))
[16:12:53.366]     }
[16:12:53.366]     if (FALSE) {
[16:12:53.366]     }
[16:12:53.366]     else {
[16:12:53.366]         if (TRUE) {
[16:12:53.366]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:53.366]                 open = "w")
[16:12:53.366]         }
[16:12:53.366]         else {
[16:12:53.366]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:53.366]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:53.366]         }
[16:12:53.366]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:53.366]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:53.366]             base::sink(type = "output", split = FALSE)
[16:12:53.366]             base::close(...future.stdout)
[16:12:53.366]         }, add = TRUE)
[16:12:53.366]     }
[16:12:53.366]     ...future.frame <- base::sys.nframe()
[16:12:53.366]     ...future.conditions <- base::list()
[16:12:53.366]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:53.366]     if (FALSE) {
[16:12:53.366]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:53.366]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:53.366]     }
[16:12:53.366]     ...future.result <- base::tryCatch({
[16:12:53.366]         base::withCallingHandlers({
[16:12:53.366]             ...future.value <- base::withVisible(base::local({
[16:12:53.366]                 ...future.makeSendCondition <- local({
[16:12:53.366]                   sendCondition <- NULL
[16:12:53.366]                   function(frame = 1L) {
[16:12:53.366]                     if (is.function(sendCondition)) 
[16:12:53.366]                       return(sendCondition)
[16:12:53.366]                     ns <- getNamespace("parallel")
[16:12:53.366]                     if (exists("sendData", mode = "function", 
[16:12:53.366]                       envir = ns)) {
[16:12:53.366]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:53.366]                         envir = ns)
[16:12:53.366]                       envir <- sys.frame(frame)
[16:12:53.366]                       master <- NULL
[16:12:53.366]                       while (!identical(envir, .GlobalEnv) && 
[16:12:53.366]                         !identical(envir, emptyenv())) {
[16:12:53.366]                         if (exists("master", mode = "list", envir = envir, 
[16:12:53.366]                           inherits = FALSE)) {
[16:12:53.366]                           master <- get("master", mode = "list", 
[16:12:53.366]                             envir = envir, inherits = FALSE)
[16:12:53.366]                           if (inherits(master, c("SOCKnode", 
[16:12:53.366]                             "SOCK0node"))) {
[16:12:53.366]                             sendCondition <<- function(cond) {
[16:12:53.366]                               data <- list(type = "VALUE", value = cond, 
[16:12:53.366]                                 success = TRUE)
[16:12:53.366]                               parallel_sendData(master, data)
[16:12:53.366]                             }
[16:12:53.366]                             return(sendCondition)
[16:12:53.366]                           }
[16:12:53.366]                         }
[16:12:53.366]                         frame <- frame + 1L
[16:12:53.366]                         envir <- sys.frame(frame)
[16:12:53.366]                       }
[16:12:53.366]                     }
[16:12:53.366]                     sendCondition <<- function(cond) NULL
[16:12:53.366]                   }
[16:12:53.366]                 })
[16:12:53.366]                 withCallingHandlers({
[16:12:53.366]                   NA
[16:12:53.366]                 }, immediateCondition = function(cond) {
[16:12:53.366]                   sendCondition <- ...future.makeSendCondition()
[16:12:53.366]                   sendCondition(cond)
[16:12:53.366]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.366]                   {
[16:12:53.366]                     inherits <- base::inherits
[16:12:53.366]                     invokeRestart <- base::invokeRestart
[16:12:53.366]                     is.null <- base::is.null
[16:12:53.366]                     muffled <- FALSE
[16:12:53.366]                     if (inherits(cond, "message")) {
[16:12:53.366]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:53.366]                       if (muffled) 
[16:12:53.366]                         invokeRestart("muffleMessage")
[16:12:53.366]                     }
[16:12:53.366]                     else if (inherits(cond, "warning")) {
[16:12:53.366]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:53.366]                       if (muffled) 
[16:12:53.366]                         invokeRestart("muffleWarning")
[16:12:53.366]                     }
[16:12:53.366]                     else if (inherits(cond, "condition")) {
[16:12:53.366]                       if (!is.null(pattern)) {
[16:12:53.366]                         computeRestarts <- base::computeRestarts
[16:12:53.366]                         grepl <- base::grepl
[16:12:53.366]                         restarts <- computeRestarts(cond)
[16:12:53.366]                         for (restart in restarts) {
[16:12:53.366]                           name <- restart$name
[16:12:53.366]                           if (is.null(name)) 
[16:12:53.366]                             next
[16:12:53.366]                           if (!grepl(pattern, name)) 
[16:12:53.366]                             next
[16:12:53.366]                           invokeRestart(restart)
[16:12:53.366]                           muffled <- TRUE
[16:12:53.366]                           break
[16:12:53.366]                         }
[16:12:53.366]                       }
[16:12:53.366]                     }
[16:12:53.366]                     invisible(muffled)
[16:12:53.366]                   }
[16:12:53.366]                   muffleCondition(cond)
[16:12:53.366]                 })
[16:12:53.366]             }))
[16:12:53.366]             future::FutureResult(value = ...future.value$value, 
[16:12:53.366]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:53.366]                   ...future.rng), globalenv = if (FALSE) 
[16:12:53.366]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:53.366]                     ...future.globalenv.names))
[16:12:53.366]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:53.366]         }, condition = base::local({
[16:12:53.366]             c <- base::c
[16:12:53.366]             inherits <- base::inherits
[16:12:53.366]             invokeRestart <- base::invokeRestart
[16:12:53.366]             length <- base::length
[16:12:53.366]             list <- base::list
[16:12:53.366]             seq.int <- base::seq.int
[16:12:53.366]             signalCondition <- base::signalCondition
[16:12:53.366]             sys.calls <- base::sys.calls
[16:12:53.366]             `[[` <- base::`[[`
[16:12:53.366]             `+` <- base::`+`
[16:12:53.366]             `<<-` <- base::`<<-`
[16:12:53.366]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:53.366]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:53.366]                   3L)]
[16:12:53.366]             }
[16:12:53.366]             function(cond) {
[16:12:53.366]                 is_error <- inherits(cond, "error")
[16:12:53.366]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:53.366]                   NULL)
[16:12:53.366]                 if (is_error) {
[16:12:53.366]                   sessionInformation <- function() {
[16:12:53.366]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:53.366]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:53.366]                       search = base::search(), system = base::Sys.info())
[16:12:53.366]                   }
[16:12:53.366]                   ...future.conditions[[length(...future.conditions) + 
[16:12:53.366]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:53.366]                     cond$call), session = sessionInformation(), 
[16:12:53.366]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:53.366]                   signalCondition(cond)
[16:12:53.366]                 }
[16:12:53.366]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:53.366]                 "immediateCondition"))) {
[16:12:53.366]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:53.366]                   ...future.conditions[[length(...future.conditions) + 
[16:12:53.366]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:53.366]                   if (TRUE && !signal) {
[16:12:53.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.366]                     {
[16:12:53.366]                       inherits <- base::inherits
[16:12:53.366]                       invokeRestart <- base::invokeRestart
[16:12:53.366]                       is.null <- base::is.null
[16:12:53.366]                       muffled <- FALSE
[16:12:53.366]                       if (inherits(cond, "message")) {
[16:12:53.366]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:53.366]                         if (muffled) 
[16:12:53.366]                           invokeRestart("muffleMessage")
[16:12:53.366]                       }
[16:12:53.366]                       else if (inherits(cond, "warning")) {
[16:12:53.366]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:53.366]                         if (muffled) 
[16:12:53.366]                           invokeRestart("muffleWarning")
[16:12:53.366]                       }
[16:12:53.366]                       else if (inherits(cond, "condition")) {
[16:12:53.366]                         if (!is.null(pattern)) {
[16:12:53.366]                           computeRestarts <- base::computeRestarts
[16:12:53.366]                           grepl <- base::grepl
[16:12:53.366]                           restarts <- computeRestarts(cond)
[16:12:53.366]                           for (restart in restarts) {
[16:12:53.366]                             name <- restart$name
[16:12:53.366]                             if (is.null(name)) 
[16:12:53.366]                               next
[16:12:53.366]                             if (!grepl(pattern, name)) 
[16:12:53.366]                               next
[16:12:53.366]                             invokeRestart(restart)
[16:12:53.366]                             muffled <- TRUE
[16:12:53.366]                             break
[16:12:53.366]                           }
[16:12:53.366]                         }
[16:12:53.366]                       }
[16:12:53.366]                       invisible(muffled)
[16:12:53.366]                     }
[16:12:53.366]                     muffleCondition(cond, pattern = "^muffle")
[16:12:53.366]                   }
[16:12:53.366]                 }
[16:12:53.366]                 else {
[16:12:53.366]                   if (TRUE) {
[16:12:53.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.366]                     {
[16:12:53.366]                       inherits <- base::inherits
[16:12:53.366]                       invokeRestart <- base::invokeRestart
[16:12:53.366]                       is.null <- base::is.null
[16:12:53.366]                       muffled <- FALSE
[16:12:53.366]                       if (inherits(cond, "message")) {
[16:12:53.366]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:53.366]                         if (muffled) 
[16:12:53.366]                           invokeRestart("muffleMessage")
[16:12:53.366]                       }
[16:12:53.366]                       else if (inherits(cond, "warning")) {
[16:12:53.366]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:53.366]                         if (muffled) 
[16:12:53.366]                           invokeRestart("muffleWarning")
[16:12:53.366]                       }
[16:12:53.366]                       else if (inherits(cond, "condition")) {
[16:12:53.366]                         if (!is.null(pattern)) {
[16:12:53.366]                           computeRestarts <- base::computeRestarts
[16:12:53.366]                           grepl <- base::grepl
[16:12:53.366]                           restarts <- computeRestarts(cond)
[16:12:53.366]                           for (restart in restarts) {
[16:12:53.366]                             name <- restart$name
[16:12:53.366]                             if (is.null(name)) 
[16:12:53.366]                               next
[16:12:53.366]                             if (!grepl(pattern, name)) 
[16:12:53.366]                               next
[16:12:53.366]                             invokeRestart(restart)
[16:12:53.366]                             muffled <- TRUE
[16:12:53.366]                             break
[16:12:53.366]                           }
[16:12:53.366]                         }
[16:12:53.366]                       }
[16:12:53.366]                       invisible(muffled)
[16:12:53.366]                     }
[16:12:53.366]                     muffleCondition(cond, pattern = "^muffle")
[16:12:53.366]                   }
[16:12:53.366]                 }
[16:12:53.366]             }
[16:12:53.366]         }))
[16:12:53.366]     }, error = function(ex) {
[16:12:53.366]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:53.366]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:53.366]                 ...future.rng), started = ...future.startTime, 
[16:12:53.366]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:53.366]             version = "1.8"), class = "FutureResult")
[16:12:53.366]     }, finally = {
[16:12:53.366]         if (!identical(...future.workdir, getwd())) 
[16:12:53.366]             setwd(...future.workdir)
[16:12:53.366]         {
[16:12:53.366]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:53.366]                 ...future.oldOptions$nwarnings <- NULL
[16:12:53.366]             }
[16:12:53.366]             base::options(...future.oldOptions)
[16:12:53.366]             if (.Platform$OS.type == "windows") {
[16:12:53.366]                 old_names <- names(...future.oldEnvVars)
[16:12:53.366]                 envs <- base::Sys.getenv()
[16:12:53.366]                 names <- names(envs)
[16:12:53.366]                 common <- intersect(names, old_names)
[16:12:53.366]                 added <- setdiff(names, old_names)
[16:12:53.366]                 removed <- setdiff(old_names, names)
[16:12:53.366]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:53.366]                   envs[common]]
[16:12:53.366]                 NAMES <- toupper(changed)
[16:12:53.366]                 args <- list()
[16:12:53.366]                 for (kk in seq_along(NAMES)) {
[16:12:53.366]                   name <- changed[[kk]]
[16:12:53.366]                   NAME <- NAMES[[kk]]
[16:12:53.366]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.366]                     next
[16:12:53.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:53.366]                 }
[16:12:53.366]                 NAMES <- toupper(added)
[16:12:53.366]                 for (kk in seq_along(NAMES)) {
[16:12:53.366]                   name <- added[[kk]]
[16:12:53.366]                   NAME <- NAMES[[kk]]
[16:12:53.366]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.366]                     next
[16:12:53.366]                   args[[name]] <- ""
[16:12:53.366]                 }
[16:12:53.366]                 NAMES <- toupper(removed)
[16:12:53.366]                 for (kk in seq_along(NAMES)) {
[16:12:53.366]                   name <- removed[[kk]]
[16:12:53.366]                   NAME <- NAMES[[kk]]
[16:12:53.366]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.366]                     next
[16:12:53.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:53.366]                 }
[16:12:53.366]                 if (length(args) > 0) 
[16:12:53.366]                   base::do.call(base::Sys.setenv, args = args)
[16:12:53.366]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:53.366]             }
[16:12:53.366]             else {
[16:12:53.366]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:53.366]             }
[16:12:53.366]             {
[16:12:53.366]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:53.366]                   0L) {
[16:12:53.366]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:53.366]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:53.366]                   base::options(opts)
[16:12:53.366]                 }
[16:12:53.366]                 {
[16:12:53.366]                   {
[16:12:53.366]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:53.366]                     NULL
[16:12:53.366]                   }
[16:12:53.366]                   options(future.plan = NULL)
[16:12:53.366]                   if (is.na(NA_character_)) 
[16:12:53.366]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:53.366]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:53.366]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:53.366]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:53.366]                     envir = parent.frame()) 
[16:12:53.366]                   {
[16:12:53.366]                     if (is.function(workers)) 
[16:12:53.366]                       workers <- workers()
[16:12:53.366]                     workers <- structure(as.integer(workers), 
[16:12:53.366]                       class = class(workers))
[16:12:53.366]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:53.366]                       workers >= 1)
[16:12:53.366]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:53.366]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:53.366]                     }
[16:12:53.366]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:53.366]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:53.366]                       envir = envir)
[16:12:53.366]                     if (!future$lazy) 
[16:12:53.366]                       future <- run(future)
[16:12:53.366]                     invisible(future)
[16:12:53.366]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:53.366]                 }
[16:12:53.366]             }
[16:12:53.366]         }
[16:12:53.366]     })
[16:12:53.366]     if (TRUE) {
[16:12:53.366]         base::sink(type = "output", split = FALSE)
[16:12:53.366]         if (TRUE) {
[16:12:53.366]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:53.366]         }
[16:12:53.366]         else {
[16:12:53.366]             ...future.result["stdout"] <- base::list(NULL)
[16:12:53.366]         }
[16:12:53.366]         base::close(...future.stdout)
[16:12:53.366]         ...future.stdout <- NULL
[16:12:53.366]     }
[16:12:53.366]     ...future.result$conditions <- ...future.conditions
[16:12:53.366]     ...future.result$finished <- base::Sys.time()
[16:12:53.366]     ...future.result
[16:12:53.366] }
[16:12:53.436] MultisessionFuture started
[16:12:53.437] result() for ClusterFuture ...
[16:12:53.437] receiveMessageFromWorker() for ClusterFuture ...
[16:12:53.437] - Validating connection of MultisessionFuture
[16:12:53.470] - received message: FutureResult
[16:12:53.470] - Received FutureResult
[16:12:53.470] - Erased future from FutureRegistry
[16:12:53.470] result() for ClusterFuture ...
[16:12:53.470] - result already collected: FutureResult
[16:12:53.470] result() for ClusterFuture ... done
[16:12:53.470] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:53.471] result() for ClusterFuture ... done
[16:12:53.471] result() for ClusterFuture ...
[16:12:53.471] - result already collected: FutureResult
[16:12:53.471] result() for ClusterFuture ... done
[16:12:53.471] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:12:53.475] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:53.475] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:53.476] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:53.477] - globals found: [3] ‘{’, ‘<-’, ‘*’
[16:12:53.478] Searching for globals ... DONE
[16:12:53.478] Resolving globals: TRUE
[16:12:53.478] Resolving any globals that are futures ...
[16:12:53.478] - globals: [3] ‘{’, ‘<-’, ‘*’
[16:12:53.478] Resolving any globals that are futures ... DONE
[16:12:53.478] 
[16:12:53.479] 
[16:12:53.479] getGlobalsAndPackages() ... DONE
[16:12:53.479] run() for ‘Future’ ...
[16:12:53.479] - state: ‘created’
[16:12:53.479] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:53.495] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:53.495] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:53.495]   - Field: ‘node’
[16:12:53.495]   - Field: ‘label’
[16:12:53.495]   - Field: ‘local’
[16:12:53.495]   - Field: ‘owner’
[16:12:53.495]   - Field: ‘envir’
[16:12:53.496]   - Field: ‘workers’
[16:12:53.496]   - Field: ‘packages’
[16:12:53.496]   - Field: ‘gc’
[16:12:53.496]   - Field: ‘conditions’
[16:12:53.496]   - Field: ‘persistent’
[16:12:53.496]   - Field: ‘expr’
[16:12:53.496]   - Field: ‘uuid’
[16:12:53.496]   - Field: ‘seed’
[16:12:53.496]   - Field: ‘version’
[16:12:53.497]   - Field: ‘result’
[16:12:53.497]   - Field: ‘asynchronous’
[16:12:53.497]   - Field: ‘calls’
[16:12:53.497]   - Field: ‘globals’
[16:12:53.497]   - Field: ‘stdout’
[16:12:53.497]   - Field: ‘earlySignal’
[16:12:53.497]   - Field: ‘lazy’
[16:12:53.497]   - Field: ‘state’
[16:12:53.497] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:53.498] - Launch lazy future ...
[16:12:53.498] Packages needed by the future expression (n = 0): <none>
[16:12:53.498] Packages needed by future strategies (n = 0): <none>
[16:12:53.499] {
[16:12:53.499]     {
[16:12:53.499]         {
[16:12:53.499]             ...future.startTime <- base::Sys.time()
[16:12:53.499]             {
[16:12:53.499]                 {
[16:12:53.499]                   {
[16:12:53.499]                     {
[16:12:53.499]                       base::local({
[16:12:53.499]                         has_future <- base::requireNamespace("future", 
[16:12:53.499]                           quietly = TRUE)
[16:12:53.499]                         if (has_future) {
[16:12:53.499]                           ns <- base::getNamespace("future")
[16:12:53.499]                           version <- ns[[".package"]][["version"]]
[16:12:53.499]                           if (is.null(version)) 
[16:12:53.499]                             version <- utils::packageVersion("future")
[16:12:53.499]                         }
[16:12:53.499]                         else {
[16:12:53.499]                           version <- NULL
[16:12:53.499]                         }
[16:12:53.499]                         if (!has_future || version < "1.8.0") {
[16:12:53.499]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:53.499]                             "", base::R.version$version.string), 
[16:12:53.499]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:53.499]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:53.499]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:53.499]                               "release", "version")], collapse = " "), 
[16:12:53.499]                             hostname = base::Sys.info()[["nodename"]])
[16:12:53.499]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:53.499]                             info)
[16:12:53.499]                           info <- base::paste(info, collapse = "; ")
[16:12:53.499]                           if (!has_future) {
[16:12:53.499]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:53.499]                               info)
[16:12:53.499]                           }
[16:12:53.499]                           else {
[16:12:53.499]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:53.499]                               info, version)
[16:12:53.499]                           }
[16:12:53.499]                           base::stop(msg)
[16:12:53.499]                         }
[16:12:53.499]                       })
[16:12:53.499]                     }
[16:12:53.499]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:53.499]                     base::options(mc.cores = 1L)
[16:12:53.499]                   }
[16:12:53.499]                   options(future.plan = NULL)
[16:12:53.499]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:53.499]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:53.499]                 }
[16:12:53.499]                 ...future.workdir <- getwd()
[16:12:53.499]             }
[16:12:53.499]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:53.499]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:53.499]         }
[16:12:53.499]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:53.499]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:53.499]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:53.499]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:53.499]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:53.499]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:53.499]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:53.499]             base::names(...future.oldOptions))
[16:12:53.499]     }
[16:12:53.499]     if (FALSE) {
[16:12:53.499]     }
[16:12:53.499]     else {
[16:12:53.499]         if (TRUE) {
[16:12:53.499]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:53.499]                 open = "w")
[16:12:53.499]         }
[16:12:53.499]         else {
[16:12:53.499]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:53.499]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:53.499]         }
[16:12:53.499]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:53.499]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:53.499]             base::sink(type = "output", split = FALSE)
[16:12:53.499]             base::close(...future.stdout)
[16:12:53.499]         }, add = TRUE)
[16:12:53.499]     }
[16:12:53.499]     ...future.frame <- base::sys.nframe()
[16:12:53.499]     ...future.conditions <- base::list()
[16:12:53.499]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:53.499]     if (FALSE) {
[16:12:53.499]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:53.499]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:53.499]     }
[16:12:53.499]     ...future.result <- base::tryCatch({
[16:12:53.499]         base::withCallingHandlers({
[16:12:53.499]             ...future.value <- base::withVisible(base::local({
[16:12:53.499]                 ...future.makeSendCondition <- local({
[16:12:53.499]                   sendCondition <- NULL
[16:12:53.499]                   function(frame = 1L) {
[16:12:53.499]                     if (is.function(sendCondition)) 
[16:12:53.499]                       return(sendCondition)
[16:12:53.499]                     ns <- getNamespace("parallel")
[16:12:53.499]                     if (exists("sendData", mode = "function", 
[16:12:53.499]                       envir = ns)) {
[16:12:53.499]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:53.499]                         envir = ns)
[16:12:53.499]                       envir <- sys.frame(frame)
[16:12:53.499]                       master <- NULL
[16:12:53.499]                       while (!identical(envir, .GlobalEnv) && 
[16:12:53.499]                         !identical(envir, emptyenv())) {
[16:12:53.499]                         if (exists("master", mode = "list", envir = envir, 
[16:12:53.499]                           inherits = FALSE)) {
[16:12:53.499]                           master <- get("master", mode = "list", 
[16:12:53.499]                             envir = envir, inherits = FALSE)
[16:12:53.499]                           if (inherits(master, c("SOCKnode", 
[16:12:53.499]                             "SOCK0node"))) {
[16:12:53.499]                             sendCondition <<- function(cond) {
[16:12:53.499]                               data <- list(type = "VALUE", value = cond, 
[16:12:53.499]                                 success = TRUE)
[16:12:53.499]                               parallel_sendData(master, data)
[16:12:53.499]                             }
[16:12:53.499]                             return(sendCondition)
[16:12:53.499]                           }
[16:12:53.499]                         }
[16:12:53.499]                         frame <- frame + 1L
[16:12:53.499]                         envir <- sys.frame(frame)
[16:12:53.499]                       }
[16:12:53.499]                     }
[16:12:53.499]                     sendCondition <<- function(cond) NULL
[16:12:53.499]                   }
[16:12:53.499]                 })
[16:12:53.499]                 withCallingHandlers({
[16:12:53.499]                   {
[16:12:53.499]                     b <- a
[16:12:53.499]                     a <- 2
[16:12:53.499]                     a * b
[16:12:53.499]                   }
[16:12:53.499]                 }, immediateCondition = function(cond) {
[16:12:53.499]                   sendCondition <- ...future.makeSendCondition()
[16:12:53.499]                   sendCondition(cond)
[16:12:53.499]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.499]                   {
[16:12:53.499]                     inherits <- base::inherits
[16:12:53.499]                     invokeRestart <- base::invokeRestart
[16:12:53.499]                     is.null <- base::is.null
[16:12:53.499]                     muffled <- FALSE
[16:12:53.499]                     if (inherits(cond, "message")) {
[16:12:53.499]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:53.499]                       if (muffled) 
[16:12:53.499]                         invokeRestart("muffleMessage")
[16:12:53.499]                     }
[16:12:53.499]                     else if (inherits(cond, "warning")) {
[16:12:53.499]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:53.499]                       if (muffled) 
[16:12:53.499]                         invokeRestart("muffleWarning")
[16:12:53.499]                     }
[16:12:53.499]                     else if (inherits(cond, "condition")) {
[16:12:53.499]                       if (!is.null(pattern)) {
[16:12:53.499]                         computeRestarts <- base::computeRestarts
[16:12:53.499]                         grepl <- base::grepl
[16:12:53.499]                         restarts <- computeRestarts(cond)
[16:12:53.499]                         for (restart in restarts) {
[16:12:53.499]                           name <- restart$name
[16:12:53.499]                           if (is.null(name)) 
[16:12:53.499]                             next
[16:12:53.499]                           if (!grepl(pattern, name)) 
[16:12:53.499]                             next
[16:12:53.499]                           invokeRestart(restart)
[16:12:53.499]                           muffled <- TRUE
[16:12:53.499]                           break
[16:12:53.499]                         }
[16:12:53.499]                       }
[16:12:53.499]                     }
[16:12:53.499]                     invisible(muffled)
[16:12:53.499]                   }
[16:12:53.499]                   muffleCondition(cond)
[16:12:53.499]                 })
[16:12:53.499]             }))
[16:12:53.499]             future::FutureResult(value = ...future.value$value, 
[16:12:53.499]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:53.499]                   ...future.rng), globalenv = if (FALSE) 
[16:12:53.499]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:53.499]                     ...future.globalenv.names))
[16:12:53.499]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:53.499]         }, condition = base::local({
[16:12:53.499]             c <- base::c
[16:12:53.499]             inherits <- base::inherits
[16:12:53.499]             invokeRestart <- base::invokeRestart
[16:12:53.499]             length <- base::length
[16:12:53.499]             list <- base::list
[16:12:53.499]             seq.int <- base::seq.int
[16:12:53.499]             signalCondition <- base::signalCondition
[16:12:53.499]             sys.calls <- base::sys.calls
[16:12:53.499]             `[[` <- base::`[[`
[16:12:53.499]             `+` <- base::`+`
[16:12:53.499]             `<<-` <- base::`<<-`
[16:12:53.499]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:53.499]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:53.499]                   3L)]
[16:12:53.499]             }
[16:12:53.499]             function(cond) {
[16:12:53.499]                 is_error <- inherits(cond, "error")
[16:12:53.499]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:53.499]                   NULL)
[16:12:53.499]                 if (is_error) {
[16:12:53.499]                   sessionInformation <- function() {
[16:12:53.499]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:53.499]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:53.499]                       search = base::search(), system = base::Sys.info())
[16:12:53.499]                   }
[16:12:53.499]                   ...future.conditions[[length(...future.conditions) + 
[16:12:53.499]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:53.499]                     cond$call), session = sessionInformation(), 
[16:12:53.499]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:53.499]                   signalCondition(cond)
[16:12:53.499]                 }
[16:12:53.499]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:53.499]                 "immediateCondition"))) {
[16:12:53.499]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:53.499]                   ...future.conditions[[length(...future.conditions) + 
[16:12:53.499]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:53.499]                   if (TRUE && !signal) {
[16:12:53.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.499]                     {
[16:12:53.499]                       inherits <- base::inherits
[16:12:53.499]                       invokeRestart <- base::invokeRestart
[16:12:53.499]                       is.null <- base::is.null
[16:12:53.499]                       muffled <- FALSE
[16:12:53.499]                       if (inherits(cond, "message")) {
[16:12:53.499]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:53.499]                         if (muffled) 
[16:12:53.499]                           invokeRestart("muffleMessage")
[16:12:53.499]                       }
[16:12:53.499]                       else if (inherits(cond, "warning")) {
[16:12:53.499]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:53.499]                         if (muffled) 
[16:12:53.499]                           invokeRestart("muffleWarning")
[16:12:53.499]                       }
[16:12:53.499]                       else if (inherits(cond, "condition")) {
[16:12:53.499]                         if (!is.null(pattern)) {
[16:12:53.499]                           computeRestarts <- base::computeRestarts
[16:12:53.499]                           grepl <- base::grepl
[16:12:53.499]                           restarts <- computeRestarts(cond)
[16:12:53.499]                           for (restart in restarts) {
[16:12:53.499]                             name <- restart$name
[16:12:53.499]                             if (is.null(name)) 
[16:12:53.499]                               next
[16:12:53.499]                             if (!grepl(pattern, name)) 
[16:12:53.499]                               next
[16:12:53.499]                             invokeRestart(restart)
[16:12:53.499]                             muffled <- TRUE
[16:12:53.499]                             break
[16:12:53.499]                           }
[16:12:53.499]                         }
[16:12:53.499]                       }
[16:12:53.499]                       invisible(muffled)
[16:12:53.499]                     }
[16:12:53.499]                     muffleCondition(cond, pattern = "^muffle")
[16:12:53.499]                   }
[16:12:53.499]                 }
[16:12:53.499]                 else {
[16:12:53.499]                   if (TRUE) {
[16:12:53.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.499]                     {
[16:12:53.499]                       inherits <- base::inherits
[16:12:53.499]                       invokeRestart <- base::invokeRestart
[16:12:53.499]                       is.null <- base::is.null
[16:12:53.499]                       muffled <- FALSE
[16:12:53.499]                       if (inherits(cond, "message")) {
[16:12:53.499]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:53.499]                         if (muffled) 
[16:12:53.499]                           invokeRestart("muffleMessage")
[16:12:53.499]                       }
[16:12:53.499]                       else if (inherits(cond, "warning")) {
[16:12:53.499]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:53.499]                         if (muffled) 
[16:12:53.499]                           invokeRestart("muffleWarning")
[16:12:53.499]                       }
[16:12:53.499]                       else if (inherits(cond, "condition")) {
[16:12:53.499]                         if (!is.null(pattern)) {
[16:12:53.499]                           computeRestarts <- base::computeRestarts
[16:12:53.499]                           grepl <- base::grepl
[16:12:53.499]                           restarts <- computeRestarts(cond)
[16:12:53.499]                           for (restart in restarts) {
[16:12:53.499]                             name <- restart$name
[16:12:53.499]                             if (is.null(name)) 
[16:12:53.499]                               next
[16:12:53.499]                             if (!grepl(pattern, name)) 
[16:12:53.499]                               next
[16:12:53.499]                             invokeRestart(restart)
[16:12:53.499]                             muffled <- TRUE
[16:12:53.499]                             break
[16:12:53.499]                           }
[16:12:53.499]                         }
[16:12:53.499]                       }
[16:12:53.499]                       invisible(muffled)
[16:12:53.499]                     }
[16:12:53.499]                     muffleCondition(cond, pattern = "^muffle")
[16:12:53.499]                   }
[16:12:53.499]                 }
[16:12:53.499]             }
[16:12:53.499]         }))
[16:12:53.499]     }, error = function(ex) {
[16:12:53.499]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:53.499]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:53.499]                 ...future.rng), started = ...future.startTime, 
[16:12:53.499]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:53.499]             version = "1.8"), class = "FutureResult")
[16:12:53.499]     }, finally = {
[16:12:53.499]         if (!identical(...future.workdir, getwd())) 
[16:12:53.499]             setwd(...future.workdir)
[16:12:53.499]         {
[16:12:53.499]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:53.499]                 ...future.oldOptions$nwarnings <- NULL
[16:12:53.499]             }
[16:12:53.499]             base::options(...future.oldOptions)
[16:12:53.499]             if (.Platform$OS.type == "windows") {
[16:12:53.499]                 old_names <- names(...future.oldEnvVars)
[16:12:53.499]                 envs <- base::Sys.getenv()
[16:12:53.499]                 names <- names(envs)
[16:12:53.499]                 common <- intersect(names, old_names)
[16:12:53.499]                 added <- setdiff(names, old_names)
[16:12:53.499]                 removed <- setdiff(old_names, names)
[16:12:53.499]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:53.499]                   envs[common]]
[16:12:53.499]                 NAMES <- toupper(changed)
[16:12:53.499]                 args <- list()
[16:12:53.499]                 for (kk in seq_along(NAMES)) {
[16:12:53.499]                   name <- changed[[kk]]
[16:12:53.499]                   NAME <- NAMES[[kk]]
[16:12:53.499]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.499]                     next
[16:12:53.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:53.499]                 }
[16:12:53.499]                 NAMES <- toupper(added)
[16:12:53.499]                 for (kk in seq_along(NAMES)) {
[16:12:53.499]                   name <- added[[kk]]
[16:12:53.499]                   NAME <- NAMES[[kk]]
[16:12:53.499]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.499]                     next
[16:12:53.499]                   args[[name]] <- ""
[16:12:53.499]                 }
[16:12:53.499]                 NAMES <- toupper(removed)
[16:12:53.499]                 for (kk in seq_along(NAMES)) {
[16:12:53.499]                   name <- removed[[kk]]
[16:12:53.499]                   NAME <- NAMES[[kk]]
[16:12:53.499]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.499]                     next
[16:12:53.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:53.499]                 }
[16:12:53.499]                 if (length(args) > 0) 
[16:12:53.499]                   base::do.call(base::Sys.setenv, args = args)
[16:12:53.499]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:53.499]             }
[16:12:53.499]             else {
[16:12:53.499]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:53.499]             }
[16:12:53.499]             {
[16:12:53.499]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:53.499]                   0L) {
[16:12:53.499]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:53.499]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:53.499]                   base::options(opts)
[16:12:53.499]                 }
[16:12:53.499]                 {
[16:12:53.499]                   {
[16:12:53.499]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:53.499]                     NULL
[16:12:53.499]                   }
[16:12:53.499]                   options(future.plan = NULL)
[16:12:53.499]                   if (is.na(NA_character_)) 
[16:12:53.499]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:53.499]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:53.499]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:53.499]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:53.499]                     envir = parent.frame()) 
[16:12:53.499]                   {
[16:12:53.499]                     if (is.function(workers)) 
[16:12:53.499]                       workers <- workers()
[16:12:53.499]                     workers <- structure(as.integer(workers), 
[16:12:53.499]                       class = class(workers))
[16:12:53.499]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:53.499]                       workers >= 1)
[16:12:53.499]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:53.499]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:53.499]                     }
[16:12:53.499]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:53.499]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:53.499]                       envir = envir)
[16:12:53.499]                     if (!future$lazy) 
[16:12:53.499]                       future <- run(future)
[16:12:53.499]                     invisible(future)
[16:12:53.499]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:53.499]                 }
[16:12:53.499]             }
[16:12:53.499]         }
[16:12:53.499]     })
[16:12:53.499]     if (TRUE) {
[16:12:53.499]         base::sink(type = "output", split = FALSE)
[16:12:53.499]         if (TRUE) {
[16:12:53.499]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:53.499]         }
[16:12:53.499]         else {
[16:12:53.499]             ...future.result["stdout"] <- base::list(NULL)
[16:12:53.499]         }
[16:12:53.499]         base::close(...future.stdout)
[16:12:53.499]         ...future.stdout <- NULL
[16:12:53.499]     }
[16:12:53.499]     ...future.result$conditions <- ...future.conditions
[16:12:53.499]     ...future.result$finished <- base::Sys.time()
[16:12:53.499]     ...future.result
[16:12:53.499] }
[16:12:53.502] MultisessionFuture started
[16:12:53.502] - Launch lazy future ... done
[16:12:53.503] run() for ‘MultisessionFuture’ ... done
[16:12:53.503] result() for ClusterFuture ...
[16:12:53.503] receiveMessageFromWorker() for ClusterFuture ...
[16:12:53.503] - Validating connection of MultisessionFuture
[16:12:53.550] - received message: FutureResult
[16:12:53.551] - Received FutureResult
[16:12:53.551] - Erased future from FutureRegistry
[16:12:53.551] result() for ClusterFuture ...
[16:12:53.551] - result already collected: FutureResult
[16:12:53.551] result() for ClusterFuture ... done
[16:12:53.551] signalConditions() ...
[16:12:53.551]  - include = ‘immediateCondition’
[16:12:53.552]  - exclude = 
[16:12:53.552]  - resignal = FALSE
[16:12:53.552]  - Number of conditions: 1
[16:12:53.552] signalConditions() ... done
[16:12:53.552] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:53.552] result() for ClusterFuture ... done
[16:12:53.552] result() for ClusterFuture ...
[16:12:53.552] - result already collected: FutureResult
[16:12:53.553] result() for ClusterFuture ... done
[16:12:53.553] signalConditions() ...
[16:12:53.553]  - include = ‘immediateCondition’
[16:12:53.553]  - exclude = 
[16:12:53.553]  - resignal = FALSE
[16:12:53.553]  - Number of conditions: 1
[16:12:53.553] signalConditions() ... done
[16:12:53.553] Future state: ‘finished’
[16:12:53.553] result() for ClusterFuture ...
[16:12:53.554] - result already collected: FutureResult
[16:12:53.554] result() for ClusterFuture ... done
[16:12:53.554] signalConditions() ...
[16:12:53.554]  - include = ‘condition’
[16:12:53.554]  - exclude = ‘immediateCondition’
[16:12:53.554]  - resignal = TRUE
[16:12:53.554]  - Number of conditions: 1
[16:12:53.554]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:12:53.555] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2729ef2608da" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:12:53"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:53.571] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:53.572] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:53.574] - globals found: [3] ‘{’, ‘<-’, ‘*’
[16:12:53.574] Searching for globals ... DONE
[16:12:53.574] Resolving globals: TRUE
[16:12:53.574] Resolving any globals that are futures ...
[16:12:53.574] - globals: [3] ‘{’, ‘<-’, ‘*’
[16:12:53.574] Resolving any globals that are futures ... DONE
[16:12:53.575] 
[16:12:53.575] 
[16:12:53.575] getGlobalsAndPackages() ... DONE
[16:12:53.575] run() for ‘Future’ ...
[16:12:53.575] - state: ‘created’
[16:12:53.576] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:53.592] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:53.593] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:53.593]   - Field: ‘node’
[16:12:53.593]   - Field: ‘label’
[16:12:53.593]   - Field: ‘local’
[16:12:53.593]   - Field: ‘owner’
[16:12:53.593]   - Field: ‘envir’
[16:12:53.593]   - Field: ‘workers’
[16:12:53.593]   - Field: ‘packages’
[16:12:53.594]   - Field: ‘gc’
[16:12:53.594]   - Field: ‘conditions’
[16:12:53.594]   - Field: ‘persistent’
[16:12:53.594]   - Field: ‘expr’
[16:12:53.594]   - Field: ‘uuid’
[16:12:53.594]   - Field: ‘seed’
[16:12:53.594]   - Field: ‘version’
[16:12:53.594]   - Field: ‘result’
[16:12:53.595]   - Field: ‘asynchronous’
[16:12:53.595]   - Field: ‘calls’
[16:12:53.595]   - Field: ‘globals’
[16:12:53.595]   - Field: ‘stdout’
[16:12:53.595]   - Field: ‘earlySignal’
[16:12:53.595]   - Field: ‘lazy’
[16:12:53.595]   - Field: ‘state’
[16:12:53.595] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:53.595] - Launch lazy future ...
[16:12:53.596] Packages needed by the future expression (n = 0): <none>
[16:12:53.596] Packages needed by future strategies (n = 0): <none>
[16:12:53.597] {
[16:12:53.597]     {
[16:12:53.597]         {
[16:12:53.597]             ...future.startTime <- base::Sys.time()
[16:12:53.597]             {
[16:12:53.597]                 {
[16:12:53.597]                   {
[16:12:53.597]                     {
[16:12:53.597]                       base::local({
[16:12:53.597]                         has_future <- base::requireNamespace("future", 
[16:12:53.597]                           quietly = TRUE)
[16:12:53.597]                         if (has_future) {
[16:12:53.597]                           ns <- base::getNamespace("future")
[16:12:53.597]                           version <- ns[[".package"]][["version"]]
[16:12:53.597]                           if (is.null(version)) 
[16:12:53.597]                             version <- utils::packageVersion("future")
[16:12:53.597]                         }
[16:12:53.597]                         else {
[16:12:53.597]                           version <- NULL
[16:12:53.597]                         }
[16:12:53.597]                         if (!has_future || version < "1.8.0") {
[16:12:53.597]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:53.597]                             "", base::R.version$version.string), 
[16:12:53.597]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:53.597]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:53.597]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:53.597]                               "release", "version")], collapse = " "), 
[16:12:53.597]                             hostname = base::Sys.info()[["nodename"]])
[16:12:53.597]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:53.597]                             info)
[16:12:53.597]                           info <- base::paste(info, collapse = "; ")
[16:12:53.597]                           if (!has_future) {
[16:12:53.597]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:53.597]                               info)
[16:12:53.597]                           }
[16:12:53.597]                           else {
[16:12:53.597]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:53.597]                               info, version)
[16:12:53.597]                           }
[16:12:53.597]                           base::stop(msg)
[16:12:53.597]                         }
[16:12:53.597]                       })
[16:12:53.597]                     }
[16:12:53.597]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:53.597]                     base::options(mc.cores = 1L)
[16:12:53.597]                   }
[16:12:53.597]                   options(future.plan = NULL)
[16:12:53.597]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:53.597]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:53.597]                 }
[16:12:53.597]                 ...future.workdir <- getwd()
[16:12:53.597]             }
[16:12:53.597]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:53.597]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:53.597]         }
[16:12:53.597]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:53.597]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:53.597]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:53.597]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:53.597]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:53.597]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:53.597]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:53.597]             base::names(...future.oldOptions))
[16:12:53.597]     }
[16:12:53.597]     if (FALSE) {
[16:12:53.597]     }
[16:12:53.597]     else {
[16:12:53.597]         if (TRUE) {
[16:12:53.597]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:53.597]                 open = "w")
[16:12:53.597]         }
[16:12:53.597]         else {
[16:12:53.597]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:53.597]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:53.597]         }
[16:12:53.597]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:53.597]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:53.597]             base::sink(type = "output", split = FALSE)
[16:12:53.597]             base::close(...future.stdout)
[16:12:53.597]         }, add = TRUE)
[16:12:53.597]     }
[16:12:53.597]     ...future.frame <- base::sys.nframe()
[16:12:53.597]     ...future.conditions <- base::list()
[16:12:53.597]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:53.597]     if (FALSE) {
[16:12:53.597]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:53.597]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:53.597]     }
[16:12:53.597]     ...future.result <- base::tryCatch({
[16:12:53.597]         base::withCallingHandlers({
[16:12:53.597]             ...future.value <- base::withVisible(base::local({
[16:12:53.597]                 ...future.makeSendCondition <- local({
[16:12:53.597]                   sendCondition <- NULL
[16:12:53.597]                   function(frame = 1L) {
[16:12:53.597]                     if (is.function(sendCondition)) 
[16:12:53.597]                       return(sendCondition)
[16:12:53.597]                     ns <- getNamespace("parallel")
[16:12:53.597]                     if (exists("sendData", mode = "function", 
[16:12:53.597]                       envir = ns)) {
[16:12:53.597]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:53.597]                         envir = ns)
[16:12:53.597]                       envir <- sys.frame(frame)
[16:12:53.597]                       master <- NULL
[16:12:53.597]                       while (!identical(envir, .GlobalEnv) && 
[16:12:53.597]                         !identical(envir, emptyenv())) {
[16:12:53.597]                         if (exists("master", mode = "list", envir = envir, 
[16:12:53.597]                           inherits = FALSE)) {
[16:12:53.597]                           master <- get("master", mode = "list", 
[16:12:53.597]                             envir = envir, inherits = FALSE)
[16:12:53.597]                           if (inherits(master, c("SOCKnode", 
[16:12:53.597]                             "SOCK0node"))) {
[16:12:53.597]                             sendCondition <<- function(cond) {
[16:12:53.597]                               data <- list(type = "VALUE", value = cond, 
[16:12:53.597]                                 success = TRUE)
[16:12:53.597]                               parallel_sendData(master, data)
[16:12:53.597]                             }
[16:12:53.597]                             return(sendCondition)
[16:12:53.597]                           }
[16:12:53.597]                         }
[16:12:53.597]                         frame <- frame + 1L
[16:12:53.597]                         envir <- sys.frame(frame)
[16:12:53.597]                       }
[16:12:53.597]                     }
[16:12:53.597]                     sendCondition <<- function(cond) NULL
[16:12:53.597]                   }
[16:12:53.597]                 })
[16:12:53.597]                 withCallingHandlers({
[16:12:53.597]                   {
[16:12:53.597]                     b <- a
[16:12:53.597]                     a <- 2
[16:12:53.597]                     a * b
[16:12:53.597]                   }
[16:12:53.597]                 }, immediateCondition = function(cond) {
[16:12:53.597]                   sendCondition <- ...future.makeSendCondition()
[16:12:53.597]                   sendCondition(cond)
[16:12:53.597]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.597]                   {
[16:12:53.597]                     inherits <- base::inherits
[16:12:53.597]                     invokeRestart <- base::invokeRestart
[16:12:53.597]                     is.null <- base::is.null
[16:12:53.597]                     muffled <- FALSE
[16:12:53.597]                     if (inherits(cond, "message")) {
[16:12:53.597]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:53.597]                       if (muffled) 
[16:12:53.597]                         invokeRestart("muffleMessage")
[16:12:53.597]                     }
[16:12:53.597]                     else if (inherits(cond, "warning")) {
[16:12:53.597]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:53.597]                       if (muffled) 
[16:12:53.597]                         invokeRestart("muffleWarning")
[16:12:53.597]                     }
[16:12:53.597]                     else if (inherits(cond, "condition")) {
[16:12:53.597]                       if (!is.null(pattern)) {
[16:12:53.597]                         computeRestarts <- base::computeRestarts
[16:12:53.597]                         grepl <- base::grepl
[16:12:53.597]                         restarts <- computeRestarts(cond)
[16:12:53.597]                         for (restart in restarts) {
[16:12:53.597]                           name <- restart$name
[16:12:53.597]                           if (is.null(name)) 
[16:12:53.597]                             next
[16:12:53.597]                           if (!grepl(pattern, name)) 
[16:12:53.597]                             next
[16:12:53.597]                           invokeRestart(restart)
[16:12:53.597]                           muffled <- TRUE
[16:12:53.597]                           break
[16:12:53.597]                         }
[16:12:53.597]                       }
[16:12:53.597]                     }
[16:12:53.597]                     invisible(muffled)
[16:12:53.597]                   }
[16:12:53.597]                   muffleCondition(cond)
[16:12:53.597]                 })
[16:12:53.597]             }))
[16:12:53.597]             future::FutureResult(value = ...future.value$value, 
[16:12:53.597]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:53.597]                   ...future.rng), globalenv = if (FALSE) 
[16:12:53.597]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:53.597]                     ...future.globalenv.names))
[16:12:53.597]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:53.597]         }, condition = base::local({
[16:12:53.597]             c <- base::c
[16:12:53.597]             inherits <- base::inherits
[16:12:53.597]             invokeRestart <- base::invokeRestart
[16:12:53.597]             length <- base::length
[16:12:53.597]             list <- base::list
[16:12:53.597]             seq.int <- base::seq.int
[16:12:53.597]             signalCondition <- base::signalCondition
[16:12:53.597]             sys.calls <- base::sys.calls
[16:12:53.597]             `[[` <- base::`[[`
[16:12:53.597]             `+` <- base::`+`
[16:12:53.597]             `<<-` <- base::`<<-`
[16:12:53.597]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:53.597]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:53.597]                   3L)]
[16:12:53.597]             }
[16:12:53.597]             function(cond) {
[16:12:53.597]                 is_error <- inherits(cond, "error")
[16:12:53.597]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:53.597]                   NULL)
[16:12:53.597]                 if (is_error) {
[16:12:53.597]                   sessionInformation <- function() {
[16:12:53.597]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:53.597]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:53.597]                       search = base::search(), system = base::Sys.info())
[16:12:53.597]                   }
[16:12:53.597]                   ...future.conditions[[length(...future.conditions) + 
[16:12:53.597]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:53.597]                     cond$call), session = sessionInformation(), 
[16:12:53.597]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:53.597]                   signalCondition(cond)
[16:12:53.597]                 }
[16:12:53.597]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:53.597]                 "immediateCondition"))) {
[16:12:53.597]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:53.597]                   ...future.conditions[[length(...future.conditions) + 
[16:12:53.597]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:53.597]                   if (TRUE && !signal) {
[16:12:53.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.597]                     {
[16:12:53.597]                       inherits <- base::inherits
[16:12:53.597]                       invokeRestart <- base::invokeRestart
[16:12:53.597]                       is.null <- base::is.null
[16:12:53.597]                       muffled <- FALSE
[16:12:53.597]                       if (inherits(cond, "message")) {
[16:12:53.597]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:53.597]                         if (muffled) 
[16:12:53.597]                           invokeRestart("muffleMessage")
[16:12:53.597]                       }
[16:12:53.597]                       else if (inherits(cond, "warning")) {
[16:12:53.597]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:53.597]                         if (muffled) 
[16:12:53.597]                           invokeRestart("muffleWarning")
[16:12:53.597]                       }
[16:12:53.597]                       else if (inherits(cond, "condition")) {
[16:12:53.597]                         if (!is.null(pattern)) {
[16:12:53.597]                           computeRestarts <- base::computeRestarts
[16:12:53.597]                           grepl <- base::grepl
[16:12:53.597]                           restarts <- computeRestarts(cond)
[16:12:53.597]                           for (restart in restarts) {
[16:12:53.597]                             name <- restart$name
[16:12:53.597]                             if (is.null(name)) 
[16:12:53.597]                               next
[16:12:53.597]                             if (!grepl(pattern, name)) 
[16:12:53.597]                               next
[16:12:53.597]                             invokeRestart(restart)
[16:12:53.597]                             muffled <- TRUE
[16:12:53.597]                             break
[16:12:53.597]                           }
[16:12:53.597]                         }
[16:12:53.597]                       }
[16:12:53.597]                       invisible(muffled)
[16:12:53.597]                     }
[16:12:53.597]                     muffleCondition(cond, pattern = "^muffle")
[16:12:53.597]                   }
[16:12:53.597]                 }
[16:12:53.597]                 else {
[16:12:53.597]                   if (TRUE) {
[16:12:53.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.597]                     {
[16:12:53.597]                       inherits <- base::inherits
[16:12:53.597]                       invokeRestart <- base::invokeRestart
[16:12:53.597]                       is.null <- base::is.null
[16:12:53.597]                       muffled <- FALSE
[16:12:53.597]                       if (inherits(cond, "message")) {
[16:12:53.597]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:53.597]                         if (muffled) 
[16:12:53.597]                           invokeRestart("muffleMessage")
[16:12:53.597]                       }
[16:12:53.597]                       else if (inherits(cond, "warning")) {
[16:12:53.597]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:53.597]                         if (muffled) 
[16:12:53.597]                           invokeRestart("muffleWarning")
[16:12:53.597]                       }
[16:12:53.597]                       else if (inherits(cond, "condition")) {
[16:12:53.597]                         if (!is.null(pattern)) {
[16:12:53.597]                           computeRestarts <- base::computeRestarts
[16:12:53.597]                           grepl <- base::grepl
[16:12:53.597]                           restarts <- computeRestarts(cond)
[16:12:53.597]                           for (restart in restarts) {
[16:12:53.597]                             name <- restart$name
[16:12:53.597]                             if (is.null(name)) 
[16:12:53.597]                               next
[16:12:53.597]                             if (!grepl(pattern, name)) 
[16:12:53.597]                               next
[16:12:53.597]                             invokeRestart(restart)
[16:12:53.597]                             muffled <- TRUE
[16:12:53.597]                             break
[16:12:53.597]                           }
[16:12:53.597]                         }
[16:12:53.597]                       }
[16:12:53.597]                       invisible(muffled)
[16:12:53.597]                     }
[16:12:53.597]                     muffleCondition(cond, pattern = "^muffle")
[16:12:53.597]                   }
[16:12:53.597]                 }
[16:12:53.597]             }
[16:12:53.597]         }))
[16:12:53.597]     }, error = function(ex) {
[16:12:53.597]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:53.597]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:53.597]                 ...future.rng), started = ...future.startTime, 
[16:12:53.597]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:53.597]             version = "1.8"), class = "FutureResult")
[16:12:53.597]     }, finally = {
[16:12:53.597]         if (!identical(...future.workdir, getwd())) 
[16:12:53.597]             setwd(...future.workdir)
[16:12:53.597]         {
[16:12:53.597]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:53.597]                 ...future.oldOptions$nwarnings <- NULL
[16:12:53.597]             }
[16:12:53.597]             base::options(...future.oldOptions)
[16:12:53.597]             if (.Platform$OS.type == "windows") {
[16:12:53.597]                 old_names <- names(...future.oldEnvVars)
[16:12:53.597]                 envs <- base::Sys.getenv()
[16:12:53.597]                 names <- names(envs)
[16:12:53.597]                 common <- intersect(names, old_names)
[16:12:53.597]                 added <- setdiff(names, old_names)
[16:12:53.597]                 removed <- setdiff(old_names, names)
[16:12:53.597]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:53.597]                   envs[common]]
[16:12:53.597]                 NAMES <- toupper(changed)
[16:12:53.597]                 args <- list()
[16:12:53.597]                 for (kk in seq_along(NAMES)) {
[16:12:53.597]                   name <- changed[[kk]]
[16:12:53.597]                   NAME <- NAMES[[kk]]
[16:12:53.597]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.597]                     next
[16:12:53.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:53.597]                 }
[16:12:53.597]                 NAMES <- toupper(added)
[16:12:53.597]                 for (kk in seq_along(NAMES)) {
[16:12:53.597]                   name <- added[[kk]]
[16:12:53.597]                   NAME <- NAMES[[kk]]
[16:12:53.597]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.597]                     next
[16:12:53.597]                   args[[name]] <- ""
[16:12:53.597]                 }
[16:12:53.597]                 NAMES <- toupper(removed)
[16:12:53.597]                 for (kk in seq_along(NAMES)) {
[16:12:53.597]                   name <- removed[[kk]]
[16:12:53.597]                   NAME <- NAMES[[kk]]
[16:12:53.597]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.597]                     next
[16:12:53.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:53.597]                 }
[16:12:53.597]                 if (length(args) > 0) 
[16:12:53.597]                   base::do.call(base::Sys.setenv, args = args)
[16:12:53.597]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:53.597]             }
[16:12:53.597]             else {
[16:12:53.597]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:53.597]             }
[16:12:53.597]             {
[16:12:53.597]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:53.597]                   0L) {
[16:12:53.597]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:53.597]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:53.597]                   base::options(opts)
[16:12:53.597]                 }
[16:12:53.597]                 {
[16:12:53.597]                   {
[16:12:53.597]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:53.597]                     NULL
[16:12:53.597]                   }
[16:12:53.597]                   options(future.plan = NULL)
[16:12:53.597]                   if (is.na(NA_character_)) 
[16:12:53.597]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:53.597]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:53.597]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:53.597]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:53.597]                     envir = parent.frame()) 
[16:12:53.597]                   {
[16:12:53.597]                     if (is.function(workers)) 
[16:12:53.597]                       workers <- workers()
[16:12:53.597]                     workers <- structure(as.integer(workers), 
[16:12:53.597]                       class = class(workers))
[16:12:53.597]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:53.597]                       workers >= 1)
[16:12:53.597]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:53.597]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:53.597]                     }
[16:12:53.597]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:53.597]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:53.597]                       envir = envir)
[16:12:53.597]                     if (!future$lazy) 
[16:12:53.597]                       future <- run(future)
[16:12:53.597]                     invisible(future)
[16:12:53.597]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:53.597]                 }
[16:12:53.597]             }
[16:12:53.597]         }
[16:12:53.597]     })
[16:12:53.597]     if (TRUE) {
[16:12:53.597]         base::sink(type = "output", split = FALSE)
[16:12:53.597]         if (TRUE) {
[16:12:53.597]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:53.597]         }
[16:12:53.597]         else {
[16:12:53.597]             ...future.result["stdout"] <- base::list(NULL)
[16:12:53.597]         }
[16:12:53.597]         base::close(...future.stdout)
[16:12:53.597]         ...future.stdout <- NULL
[16:12:53.597]     }
[16:12:53.597]     ...future.result$conditions <- ...future.conditions
[16:12:53.597]     ...future.result$finished <- base::Sys.time()
[16:12:53.597]     ...future.result
[16:12:53.597] }
[16:12:53.603] MultisessionFuture started
[16:12:53.603] - Launch lazy future ... done
[16:12:53.603] run() for ‘MultisessionFuture’ ... done
[16:12:53.603] result() for ClusterFuture ...
[16:12:53.603] receiveMessageFromWorker() for ClusterFuture ...
[16:12:53.603] - Validating connection of MultisessionFuture
[16:12:53.650] - received message: FutureResult
[16:12:53.650] - Received FutureResult
[16:12:53.650] - Erased future from FutureRegistry
[16:12:53.650] result() for ClusterFuture ...
[16:12:53.651] - result already collected: FutureResult
[16:12:53.651] result() for ClusterFuture ... done
[16:12:53.651] signalConditions() ...
[16:12:53.651]  - include = ‘immediateCondition’
[16:12:53.651]  - exclude = 
[16:12:53.651]  - resignal = FALSE
[16:12:53.651]  - Number of conditions: 1
[16:12:53.651] signalConditions() ... done
[16:12:53.651] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:53.651] result() for ClusterFuture ... done
[16:12:53.652] result() for ClusterFuture ...
[16:12:53.652] - result already collected: FutureResult
[16:12:53.652] result() for ClusterFuture ... done
[16:12:53.652] signalConditions() ...
[16:12:53.652]  - include = ‘immediateCondition’
[16:12:53.652]  - exclude = 
[16:12:53.652]  - resignal = FALSE
[16:12:53.652]  - Number of conditions: 1
[16:12:53.652] signalConditions() ... done
[16:12:53.652] Future state: ‘finished’
[16:12:53.653] result() for ClusterFuture ...
[16:12:53.653] - result already collected: FutureResult
[16:12:53.653] result() for ClusterFuture ... done
[16:12:53.653] signalConditions() ...
[16:12:53.653]  - include = ‘condition’
[16:12:53.653]  - exclude = ‘immediateCondition’
[16:12:53.653]  - resignal = TRUE
[16:12:53.653]  - Number of conditions: 1
[16:12:53.653]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:12:53.653] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2729ef2608da" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:12:53"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:53.668] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:53.669] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:53.670] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:53.670] Searching for globals ... DONE
[16:12:53.670] Resolving globals: TRUE
[16:12:53.670] Resolving any globals that are futures ...
[16:12:53.670] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:53.670] Resolving any globals that are futures ... DONE
[16:12:53.671] Resolving futures part of globals (recursively) ...
[16:12:53.671] resolve() on list ...
[16:12:53.671]  recursive: 99
[16:12:53.671]  length: 1
[16:12:53.671]  elements: ‘ii’
[16:12:53.671]  length: 0 (resolved future 1)
[16:12:53.672] resolve() on list ... DONE
[16:12:53.672] - globals: [1] ‘ii’
[16:12:53.672] Resolving futures part of globals (recursively) ... DONE
[16:12:53.672] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:53.672] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:12:53.672] - globals: [1] ‘ii’
[16:12:53.673] 
[16:12:53.673] getGlobalsAndPackages() ... DONE
[16:12:53.673] run() for ‘Future’ ...
[16:12:53.673] - state: ‘created’
[16:12:53.673] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:53.688] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:53.688] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:53.688]   - Field: ‘node’
[16:12:53.689]   - Field: ‘label’
[16:12:53.689]   - Field: ‘local’
[16:12:53.689]   - Field: ‘owner’
[16:12:53.689]   - Field: ‘envir’
[16:12:53.689]   - Field: ‘workers’
[16:12:53.689]   - Field: ‘packages’
[16:12:53.689]   - Field: ‘gc’
[16:12:53.689]   - Field: ‘conditions’
[16:12:53.689]   - Field: ‘persistent’
[16:12:53.689]   - Field: ‘expr’
[16:12:53.689]   - Field: ‘uuid’
[16:12:53.690]   - Field: ‘seed’
[16:12:53.690]   - Field: ‘version’
[16:12:53.690]   - Field: ‘result’
[16:12:53.690]   - Field: ‘asynchronous’
[16:12:53.690]   - Field: ‘calls’
[16:12:53.690]   - Field: ‘globals’
[16:12:53.690]   - Field: ‘stdout’
[16:12:53.690]   - Field: ‘earlySignal’
[16:12:53.690]   - Field: ‘lazy’
[16:12:53.690]   - Field: ‘state’
[16:12:53.690] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:53.691] - Launch lazy future ...
[16:12:53.691] Packages needed by the future expression (n = 0): <none>
[16:12:53.691] Packages needed by future strategies (n = 0): <none>
[16:12:53.691] {
[16:12:53.691]     {
[16:12:53.691]         {
[16:12:53.691]             ...future.startTime <- base::Sys.time()
[16:12:53.691]             {
[16:12:53.691]                 {
[16:12:53.691]                   {
[16:12:53.691]                     {
[16:12:53.691]                       base::local({
[16:12:53.691]                         has_future <- base::requireNamespace("future", 
[16:12:53.691]                           quietly = TRUE)
[16:12:53.691]                         if (has_future) {
[16:12:53.691]                           ns <- base::getNamespace("future")
[16:12:53.691]                           version <- ns[[".package"]][["version"]]
[16:12:53.691]                           if (is.null(version)) 
[16:12:53.691]                             version <- utils::packageVersion("future")
[16:12:53.691]                         }
[16:12:53.691]                         else {
[16:12:53.691]                           version <- NULL
[16:12:53.691]                         }
[16:12:53.691]                         if (!has_future || version < "1.8.0") {
[16:12:53.691]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:53.691]                             "", base::R.version$version.string), 
[16:12:53.691]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:53.691]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:53.691]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:53.691]                               "release", "version")], collapse = " "), 
[16:12:53.691]                             hostname = base::Sys.info()[["nodename"]])
[16:12:53.691]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:53.691]                             info)
[16:12:53.691]                           info <- base::paste(info, collapse = "; ")
[16:12:53.691]                           if (!has_future) {
[16:12:53.691]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:53.691]                               info)
[16:12:53.691]                           }
[16:12:53.691]                           else {
[16:12:53.691]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:53.691]                               info, version)
[16:12:53.691]                           }
[16:12:53.691]                           base::stop(msg)
[16:12:53.691]                         }
[16:12:53.691]                       })
[16:12:53.691]                     }
[16:12:53.691]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:53.691]                     base::options(mc.cores = 1L)
[16:12:53.691]                   }
[16:12:53.691]                   options(future.plan = NULL)
[16:12:53.691]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:53.691]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:53.691]                 }
[16:12:53.691]                 ...future.workdir <- getwd()
[16:12:53.691]             }
[16:12:53.691]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:53.691]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:53.691]         }
[16:12:53.691]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:53.691]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:53.691]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:53.691]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:53.691]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:53.691]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:53.691]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:53.691]             base::names(...future.oldOptions))
[16:12:53.691]     }
[16:12:53.691]     if (FALSE) {
[16:12:53.691]     }
[16:12:53.691]     else {
[16:12:53.691]         if (TRUE) {
[16:12:53.691]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:53.691]                 open = "w")
[16:12:53.691]         }
[16:12:53.691]         else {
[16:12:53.691]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:53.691]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:53.691]         }
[16:12:53.691]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:53.691]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:53.691]             base::sink(type = "output", split = FALSE)
[16:12:53.691]             base::close(...future.stdout)
[16:12:53.691]         }, add = TRUE)
[16:12:53.691]     }
[16:12:53.691]     ...future.frame <- base::sys.nframe()
[16:12:53.691]     ...future.conditions <- base::list()
[16:12:53.691]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:53.691]     if (FALSE) {
[16:12:53.691]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:53.691]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:53.691]     }
[16:12:53.691]     ...future.result <- base::tryCatch({
[16:12:53.691]         base::withCallingHandlers({
[16:12:53.691]             ...future.value <- base::withVisible(base::local({
[16:12:53.691]                 ...future.makeSendCondition <- local({
[16:12:53.691]                   sendCondition <- NULL
[16:12:53.691]                   function(frame = 1L) {
[16:12:53.691]                     if (is.function(sendCondition)) 
[16:12:53.691]                       return(sendCondition)
[16:12:53.691]                     ns <- getNamespace("parallel")
[16:12:53.691]                     if (exists("sendData", mode = "function", 
[16:12:53.691]                       envir = ns)) {
[16:12:53.691]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:53.691]                         envir = ns)
[16:12:53.691]                       envir <- sys.frame(frame)
[16:12:53.691]                       master <- NULL
[16:12:53.691]                       while (!identical(envir, .GlobalEnv) && 
[16:12:53.691]                         !identical(envir, emptyenv())) {
[16:12:53.691]                         if (exists("master", mode = "list", envir = envir, 
[16:12:53.691]                           inherits = FALSE)) {
[16:12:53.691]                           master <- get("master", mode = "list", 
[16:12:53.691]                             envir = envir, inherits = FALSE)
[16:12:53.691]                           if (inherits(master, c("SOCKnode", 
[16:12:53.691]                             "SOCK0node"))) {
[16:12:53.691]                             sendCondition <<- function(cond) {
[16:12:53.691]                               data <- list(type = "VALUE", value = cond, 
[16:12:53.691]                                 success = TRUE)
[16:12:53.691]                               parallel_sendData(master, data)
[16:12:53.691]                             }
[16:12:53.691]                             return(sendCondition)
[16:12:53.691]                           }
[16:12:53.691]                         }
[16:12:53.691]                         frame <- frame + 1L
[16:12:53.691]                         envir <- sys.frame(frame)
[16:12:53.691]                       }
[16:12:53.691]                     }
[16:12:53.691]                     sendCondition <<- function(cond) NULL
[16:12:53.691]                   }
[16:12:53.691]                 })
[16:12:53.691]                 withCallingHandlers({
[16:12:53.691]                   {
[16:12:53.691]                     b <- a * ii
[16:12:53.691]                     a <- 0
[16:12:53.691]                     b
[16:12:53.691]                   }
[16:12:53.691]                 }, immediateCondition = function(cond) {
[16:12:53.691]                   sendCondition <- ...future.makeSendCondition()
[16:12:53.691]                   sendCondition(cond)
[16:12:53.691]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.691]                   {
[16:12:53.691]                     inherits <- base::inherits
[16:12:53.691]                     invokeRestart <- base::invokeRestart
[16:12:53.691]                     is.null <- base::is.null
[16:12:53.691]                     muffled <- FALSE
[16:12:53.691]                     if (inherits(cond, "message")) {
[16:12:53.691]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:53.691]                       if (muffled) 
[16:12:53.691]                         invokeRestart("muffleMessage")
[16:12:53.691]                     }
[16:12:53.691]                     else if (inherits(cond, "warning")) {
[16:12:53.691]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:53.691]                       if (muffled) 
[16:12:53.691]                         invokeRestart("muffleWarning")
[16:12:53.691]                     }
[16:12:53.691]                     else if (inherits(cond, "condition")) {
[16:12:53.691]                       if (!is.null(pattern)) {
[16:12:53.691]                         computeRestarts <- base::computeRestarts
[16:12:53.691]                         grepl <- base::grepl
[16:12:53.691]                         restarts <- computeRestarts(cond)
[16:12:53.691]                         for (restart in restarts) {
[16:12:53.691]                           name <- restart$name
[16:12:53.691]                           if (is.null(name)) 
[16:12:53.691]                             next
[16:12:53.691]                           if (!grepl(pattern, name)) 
[16:12:53.691]                             next
[16:12:53.691]                           invokeRestart(restart)
[16:12:53.691]                           muffled <- TRUE
[16:12:53.691]                           break
[16:12:53.691]                         }
[16:12:53.691]                       }
[16:12:53.691]                     }
[16:12:53.691]                     invisible(muffled)
[16:12:53.691]                   }
[16:12:53.691]                   muffleCondition(cond)
[16:12:53.691]                 })
[16:12:53.691]             }))
[16:12:53.691]             future::FutureResult(value = ...future.value$value, 
[16:12:53.691]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:53.691]                   ...future.rng), globalenv = if (FALSE) 
[16:12:53.691]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:53.691]                     ...future.globalenv.names))
[16:12:53.691]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:53.691]         }, condition = base::local({
[16:12:53.691]             c <- base::c
[16:12:53.691]             inherits <- base::inherits
[16:12:53.691]             invokeRestart <- base::invokeRestart
[16:12:53.691]             length <- base::length
[16:12:53.691]             list <- base::list
[16:12:53.691]             seq.int <- base::seq.int
[16:12:53.691]             signalCondition <- base::signalCondition
[16:12:53.691]             sys.calls <- base::sys.calls
[16:12:53.691]             `[[` <- base::`[[`
[16:12:53.691]             `+` <- base::`+`
[16:12:53.691]             `<<-` <- base::`<<-`
[16:12:53.691]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:53.691]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:53.691]                   3L)]
[16:12:53.691]             }
[16:12:53.691]             function(cond) {
[16:12:53.691]                 is_error <- inherits(cond, "error")
[16:12:53.691]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:53.691]                   NULL)
[16:12:53.691]                 if (is_error) {
[16:12:53.691]                   sessionInformation <- function() {
[16:12:53.691]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:53.691]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:53.691]                       search = base::search(), system = base::Sys.info())
[16:12:53.691]                   }
[16:12:53.691]                   ...future.conditions[[length(...future.conditions) + 
[16:12:53.691]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:53.691]                     cond$call), session = sessionInformation(), 
[16:12:53.691]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:53.691]                   signalCondition(cond)
[16:12:53.691]                 }
[16:12:53.691]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:53.691]                 "immediateCondition"))) {
[16:12:53.691]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:53.691]                   ...future.conditions[[length(...future.conditions) + 
[16:12:53.691]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:53.691]                   if (TRUE && !signal) {
[16:12:53.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.691]                     {
[16:12:53.691]                       inherits <- base::inherits
[16:12:53.691]                       invokeRestart <- base::invokeRestart
[16:12:53.691]                       is.null <- base::is.null
[16:12:53.691]                       muffled <- FALSE
[16:12:53.691]                       if (inherits(cond, "message")) {
[16:12:53.691]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:53.691]                         if (muffled) 
[16:12:53.691]                           invokeRestart("muffleMessage")
[16:12:53.691]                       }
[16:12:53.691]                       else if (inherits(cond, "warning")) {
[16:12:53.691]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:53.691]                         if (muffled) 
[16:12:53.691]                           invokeRestart("muffleWarning")
[16:12:53.691]                       }
[16:12:53.691]                       else if (inherits(cond, "condition")) {
[16:12:53.691]                         if (!is.null(pattern)) {
[16:12:53.691]                           computeRestarts <- base::computeRestarts
[16:12:53.691]                           grepl <- base::grepl
[16:12:53.691]                           restarts <- computeRestarts(cond)
[16:12:53.691]                           for (restart in restarts) {
[16:12:53.691]                             name <- restart$name
[16:12:53.691]                             if (is.null(name)) 
[16:12:53.691]                               next
[16:12:53.691]                             if (!grepl(pattern, name)) 
[16:12:53.691]                               next
[16:12:53.691]                             invokeRestart(restart)
[16:12:53.691]                             muffled <- TRUE
[16:12:53.691]                             break
[16:12:53.691]                           }
[16:12:53.691]                         }
[16:12:53.691]                       }
[16:12:53.691]                       invisible(muffled)
[16:12:53.691]                     }
[16:12:53.691]                     muffleCondition(cond, pattern = "^muffle")
[16:12:53.691]                   }
[16:12:53.691]                 }
[16:12:53.691]                 else {
[16:12:53.691]                   if (TRUE) {
[16:12:53.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.691]                     {
[16:12:53.691]                       inherits <- base::inherits
[16:12:53.691]                       invokeRestart <- base::invokeRestart
[16:12:53.691]                       is.null <- base::is.null
[16:12:53.691]                       muffled <- FALSE
[16:12:53.691]                       if (inherits(cond, "message")) {
[16:12:53.691]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:53.691]                         if (muffled) 
[16:12:53.691]                           invokeRestart("muffleMessage")
[16:12:53.691]                       }
[16:12:53.691]                       else if (inherits(cond, "warning")) {
[16:12:53.691]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:53.691]                         if (muffled) 
[16:12:53.691]                           invokeRestart("muffleWarning")
[16:12:53.691]                       }
[16:12:53.691]                       else if (inherits(cond, "condition")) {
[16:12:53.691]                         if (!is.null(pattern)) {
[16:12:53.691]                           computeRestarts <- base::computeRestarts
[16:12:53.691]                           grepl <- base::grepl
[16:12:53.691]                           restarts <- computeRestarts(cond)
[16:12:53.691]                           for (restart in restarts) {
[16:12:53.691]                             name <- restart$name
[16:12:53.691]                             if (is.null(name)) 
[16:12:53.691]                               next
[16:12:53.691]                             if (!grepl(pattern, name)) 
[16:12:53.691]                               next
[16:12:53.691]                             invokeRestart(restart)
[16:12:53.691]                             muffled <- TRUE
[16:12:53.691]                             break
[16:12:53.691]                           }
[16:12:53.691]                         }
[16:12:53.691]                       }
[16:12:53.691]                       invisible(muffled)
[16:12:53.691]                     }
[16:12:53.691]                     muffleCondition(cond, pattern = "^muffle")
[16:12:53.691]                   }
[16:12:53.691]                 }
[16:12:53.691]             }
[16:12:53.691]         }))
[16:12:53.691]     }, error = function(ex) {
[16:12:53.691]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:53.691]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:53.691]                 ...future.rng), started = ...future.startTime, 
[16:12:53.691]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:53.691]             version = "1.8"), class = "FutureResult")
[16:12:53.691]     }, finally = {
[16:12:53.691]         if (!identical(...future.workdir, getwd())) 
[16:12:53.691]             setwd(...future.workdir)
[16:12:53.691]         {
[16:12:53.691]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:53.691]                 ...future.oldOptions$nwarnings <- NULL
[16:12:53.691]             }
[16:12:53.691]             base::options(...future.oldOptions)
[16:12:53.691]             if (.Platform$OS.type == "windows") {
[16:12:53.691]                 old_names <- names(...future.oldEnvVars)
[16:12:53.691]                 envs <- base::Sys.getenv()
[16:12:53.691]                 names <- names(envs)
[16:12:53.691]                 common <- intersect(names, old_names)
[16:12:53.691]                 added <- setdiff(names, old_names)
[16:12:53.691]                 removed <- setdiff(old_names, names)
[16:12:53.691]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:53.691]                   envs[common]]
[16:12:53.691]                 NAMES <- toupper(changed)
[16:12:53.691]                 args <- list()
[16:12:53.691]                 for (kk in seq_along(NAMES)) {
[16:12:53.691]                   name <- changed[[kk]]
[16:12:53.691]                   NAME <- NAMES[[kk]]
[16:12:53.691]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.691]                     next
[16:12:53.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:53.691]                 }
[16:12:53.691]                 NAMES <- toupper(added)
[16:12:53.691]                 for (kk in seq_along(NAMES)) {
[16:12:53.691]                   name <- added[[kk]]
[16:12:53.691]                   NAME <- NAMES[[kk]]
[16:12:53.691]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.691]                     next
[16:12:53.691]                   args[[name]] <- ""
[16:12:53.691]                 }
[16:12:53.691]                 NAMES <- toupper(removed)
[16:12:53.691]                 for (kk in seq_along(NAMES)) {
[16:12:53.691]                   name <- removed[[kk]]
[16:12:53.691]                   NAME <- NAMES[[kk]]
[16:12:53.691]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.691]                     next
[16:12:53.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:53.691]                 }
[16:12:53.691]                 if (length(args) > 0) 
[16:12:53.691]                   base::do.call(base::Sys.setenv, args = args)
[16:12:53.691]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:53.691]             }
[16:12:53.691]             else {
[16:12:53.691]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:53.691]             }
[16:12:53.691]             {
[16:12:53.691]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:53.691]                   0L) {
[16:12:53.691]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:53.691]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:53.691]                   base::options(opts)
[16:12:53.691]                 }
[16:12:53.691]                 {
[16:12:53.691]                   {
[16:12:53.691]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:53.691]                     NULL
[16:12:53.691]                   }
[16:12:53.691]                   options(future.plan = NULL)
[16:12:53.691]                   if (is.na(NA_character_)) 
[16:12:53.691]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:53.691]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:53.691]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:53.691]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:53.691]                     envir = parent.frame()) 
[16:12:53.691]                   {
[16:12:53.691]                     if (is.function(workers)) 
[16:12:53.691]                       workers <- workers()
[16:12:53.691]                     workers <- structure(as.integer(workers), 
[16:12:53.691]                       class = class(workers))
[16:12:53.691]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:53.691]                       workers >= 1)
[16:12:53.691]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:53.691]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:53.691]                     }
[16:12:53.691]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:53.691]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:53.691]                       envir = envir)
[16:12:53.691]                     if (!future$lazy) 
[16:12:53.691]                       future <- run(future)
[16:12:53.691]                     invisible(future)
[16:12:53.691]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:53.691]                 }
[16:12:53.691]             }
[16:12:53.691]         }
[16:12:53.691]     })
[16:12:53.691]     if (TRUE) {
[16:12:53.691]         base::sink(type = "output", split = FALSE)
[16:12:53.691]         if (TRUE) {
[16:12:53.691]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:53.691]         }
[16:12:53.691]         else {
[16:12:53.691]             ...future.result["stdout"] <- base::list(NULL)
[16:12:53.691]         }
[16:12:53.691]         base::close(...future.stdout)
[16:12:53.691]         ...future.stdout <- NULL
[16:12:53.691]     }
[16:12:53.691]     ...future.result$conditions <- ...future.conditions
[16:12:53.691]     ...future.result$finished <- base::Sys.time()
[16:12:53.691]     ...future.result
[16:12:53.691] }
[16:12:53.694] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:12:53.694] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:12:53.695] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:12:53.695] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:12:53.696] MultisessionFuture started
[16:12:53.696] - Launch lazy future ... done
[16:12:53.696] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:53.696] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:53.697] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:53.698] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:53.698] Searching for globals ... DONE
[16:12:53.698] Resolving globals: TRUE
[16:12:53.698] Resolving any globals that are futures ...
[16:12:53.698] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:53.698] Resolving any globals that are futures ... DONE
[16:12:53.699] Resolving futures part of globals (recursively) ...
[16:12:53.699] resolve() on list ...
[16:12:53.699]  recursive: 99
[16:12:53.699]  length: 1
[16:12:53.699]  elements: ‘ii’
[16:12:53.699]  length: 0 (resolved future 1)
[16:12:53.699] resolve() on list ... DONE
[16:12:53.700] - globals: [1] ‘ii’
[16:12:53.700] Resolving futures part of globals (recursively) ... DONE
[16:12:53.700] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:53.700] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:12:53.700] - globals: [1] ‘ii’
[16:12:53.700] 
[16:12:53.701] getGlobalsAndPackages() ... DONE
[16:12:53.701] run() for ‘Future’ ...
[16:12:53.701] - state: ‘created’
[16:12:53.701] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:53.715] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:53.716] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:53.716]   - Field: ‘node’
[16:12:53.716]   - Field: ‘label’
[16:12:53.716]   - Field: ‘local’
[16:12:53.716]   - Field: ‘owner’
[16:12:53.716]   - Field: ‘envir’
[16:12:53.716]   - Field: ‘workers’
[16:12:53.716]   - Field: ‘packages’
[16:12:53.716]   - Field: ‘gc’
[16:12:53.716]   - Field: ‘conditions’
[16:12:53.717]   - Field: ‘persistent’
[16:12:53.717]   - Field: ‘expr’
[16:12:53.717]   - Field: ‘uuid’
[16:12:53.717]   - Field: ‘seed’
[16:12:53.717]   - Field: ‘version’
[16:12:53.717]   - Field: ‘result’
[16:12:53.717]   - Field: ‘asynchronous’
[16:12:53.717]   - Field: ‘calls’
[16:12:53.717]   - Field: ‘globals’
[16:12:53.717]   - Field: ‘stdout’
[16:12:53.717]   - Field: ‘earlySignal’
[16:12:53.718]   - Field: ‘lazy’
[16:12:53.718]   - Field: ‘state’
[16:12:53.718] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:53.718] - Launch lazy future ...
[16:12:53.718] Packages needed by the future expression (n = 0): <none>
[16:12:53.718] Packages needed by future strategies (n = 0): <none>
[16:12:53.719] {
[16:12:53.719]     {
[16:12:53.719]         {
[16:12:53.719]             ...future.startTime <- base::Sys.time()
[16:12:53.719]             {
[16:12:53.719]                 {
[16:12:53.719]                   {
[16:12:53.719]                     {
[16:12:53.719]                       base::local({
[16:12:53.719]                         has_future <- base::requireNamespace("future", 
[16:12:53.719]                           quietly = TRUE)
[16:12:53.719]                         if (has_future) {
[16:12:53.719]                           ns <- base::getNamespace("future")
[16:12:53.719]                           version <- ns[[".package"]][["version"]]
[16:12:53.719]                           if (is.null(version)) 
[16:12:53.719]                             version <- utils::packageVersion("future")
[16:12:53.719]                         }
[16:12:53.719]                         else {
[16:12:53.719]                           version <- NULL
[16:12:53.719]                         }
[16:12:53.719]                         if (!has_future || version < "1.8.0") {
[16:12:53.719]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:53.719]                             "", base::R.version$version.string), 
[16:12:53.719]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:53.719]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:53.719]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:53.719]                               "release", "version")], collapse = " "), 
[16:12:53.719]                             hostname = base::Sys.info()[["nodename"]])
[16:12:53.719]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:53.719]                             info)
[16:12:53.719]                           info <- base::paste(info, collapse = "; ")
[16:12:53.719]                           if (!has_future) {
[16:12:53.719]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:53.719]                               info)
[16:12:53.719]                           }
[16:12:53.719]                           else {
[16:12:53.719]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:53.719]                               info, version)
[16:12:53.719]                           }
[16:12:53.719]                           base::stop(msg)
[16:12:53.719]                         }
[16:12:53.719]                       })
[16:12:53.719]                     }
[16:12:53.719]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:53.719]                     base::options(mc.cores = 1L)
[16:12:53.719]                   }
[16:12:53.719]                   options(future.plan = NULL)
[16:12:53.719]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:53.719]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:53.719]                 }
[16:12:53.719]                 ...future.workdir <- getwd()
[16:12:53.719]             }
[16:12:53.719]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:53.719]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:53.719]         }
[16:12:53.719]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:53.719]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:53.719]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:53.719]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:53.719]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:53.719]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:53.719]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:53.719]             base::names(...future.oldOptions))
[16:12:53.719]     }
[16:12:53.719]     if (FALSE) {
[16:12:53.719]     }
[16:12:53.719]     else {
[16:12:53.719]         if (TRUE) {
[16:12:53.719]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:53.719]                 open = "w")
[16:12:53.719]         }
[16:12:53.719]         else {
[16:12:53.719]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:53.719]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:53.719]         }
[16:12:53.719]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:53.719]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:53.719]             base::sink(type = "output", split = FALSE)
[16:12:53.719]             base::close(...future.stdout)
[16:12:53.719]         }, add = TRUE)
[16:12:53.719]     }
[16:12:53.719]     ...future.frame <- base::sys.nframe()
[16:12:53.719]     ...future.conditions <- base::list()
[16:12:53.719]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:53.719]     if (FALSE) {
[16:12:53.719]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:53.719]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:53.719]     }
[16:12:53.719]     ...future.result <- base::tryCatch({
[16:12:53.719]         base::withCallingHandlers({
[16:12:53.719]             ...future.value <- base::withVisible(base::local({
[16:12:53.719]                 ...future.makeSendCondition <- local({
[16:12:53.719]                   sendCondition <- NULL
[16:12:53.719]                   function(frame = 1L) {
[16:12:53.719]                     if (is.function(sendCondition)) 
[16:12:53.719]                       return(sendCondition)
[16:12:53.719]                     ns <- getNamespace("parallel")
[16:12:53.719]                     if (exists("sendData", mode = "function", 
[16:12:53.719]                       envir = ns)) {
[16:12:53.719]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:53.719]                         envir = ns)
[16:12:53.719]                       envir <- sys.frame(frame)
[16:12:53.719]                       master <- NULL
[16:12:53.719]                       while (!identical(envir, .GlobalEnv) && 
[16:12:53.719]                         !identical(envir, emptyenv())) {
[16:12:53.719]                         if (exists("master", mode = "list", envir = envir, 
[16:12:53.719]                           inherits = FALSE)) {
[16:12:53.719]                           master <- get("master", mode = "list", 
[16:12:53.719]                             envir = envir, inherits = FALSE)
[16:12:53.719]                           if (inherits(master, c("SOCKnode", 
[16:12:53.719]                             "SOCK0node"))) {
[16:12:53.719]                             sendCondition <<- function(cond) {
[16:12:53.719]                               data <- list(type = "VALUE", value = cond, 
[16:12:53.719]                                 success = TRUE)
[16:12:53.719]                               parallel_sendData(master, data)
[16:12:53.719]                             }
[16:12:53.719]                             return(sendCondition)
[16:12:53.719]                           }
[16:12:53.719]                         }
[16:12:53.719]                         frame <- frame + 1L
[16:12:53.719]                         envir <- sys.frame(frame)
[16:12:53.719]                       }
[16:12:53.719]                     }
[16:12:53.719]                     sendCondition <<- function(cond) NULL
[16:12:53.719]                   }
[16:12:53.719]                 })
[16:12:53.719]                 withCallingHandlers({
[16:12:53.719]                   {
[16:12:53.719]                     b <- a * ii
[16:12:53.719]                     a <- 0
[16:12:53.719]                     b
[16:12:53.719]                   }
[16:12:53.719]                 }, immediateCondition = function(cond) {
[16:12:53.719]                   sendCondition <- ...future.makeSendCondition()
[16:12:53.719]                   sendCondition(cond)
[16:12:53.719]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.719]                   {
[16:12:53.719]                     inherits <- base::inherits
[16:12:53.719]                     invokeRestart <- base::invokeRestart
[16:12:53.719]                     is.null <- base::is.null
[16:12:53.719]                     muffled <- FALSE
[16:12:53.719]                     if (inherits(cond, "message")) {
[16:12:53.719]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:53.719]                       if (muffled) 
[16:12:53.719]                         invokeRestart("muffleMessage")
[16:12:53.719]                     }
[16:12:53.719]                     else if (inherits(cond, "warning")) {
[16:12:53.719]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:53.719]                       if (muffled) 
[16:12:53.719]                         invokeRestart("muffleWarning")
[16:12:53.719]                     }
[16:12:53.719]                     else if (inherits(cond, "condition")) {
[16:12:53.719]                       if (!is.null(pattern)) {
[16:12:53.719]                         computeRestarts <- base::computeRestarts
[16:12:53.719]                         grepl <- base::grepl
[16:12:53.719]                         restarts <- computeRestarts(cond)
[16:12:53.719]                         for (restart in restarts) {
[16:12:53.719]                           name <- restart$name
[16:12:53.719]                           if (is.null(name)) 
[16:12:53.719]                             next
[16:12:53.719]                           if (!grepl(pattern, name)) 
[16:12:53.719]                             next
[16:12:53.719]                           invokeRestart(restart)
[16:12:53.719]                           muffled <- TRUE
[16:12:53.719]                           break
[16:12:53.719]                         }
[16:12:53.719]                       }
[16:12:53.719]                     }
[16:12:53.719]                     invisible(muffled)
[16:12:53.719]                   }
[16:12:53.719]                   muffleCondition(cond)
[16:12:53.719]                 })
[16:12:53.719]             }))
[16:12:53.719]             future::FutureResult(value = ...future.value$value, 
[16:12:53.719]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:53.719]                   ...future.rng), globalenv = if (FALSE) 
[16:12:53.719]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:53.719]                     ...future.globalenv.names))
[16:12:53.719]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:53.719]         }, condition = base::local({
[16:12:53.719]             c <- base::c
[16:12:53.719]             inherits <- base::inherits
[16:12:53.719]             invokeRestart <- base::invokeRestart
[16:12:53.719]             length <- base::length
[16:12:53.719]             list <- base::list
[16:12:53.719]             seq.int <- base::seq.int
[16:12:53.719]             signalCondition <- base::signalCondition
[16:12:53.719]             sys.calls <- base::sys.calls
[16:12:53.719]             `[[` <- base::`[[`
[16:12:53.719]             `+` <- base::`+`
[16:12:53.719]             `<<-` <- base::`<<-`
[16:12:53.719]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:53.719]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:53.719]                   3L)]
[16:12:53.719]             }
[16:12:53.719]             function(cond) {
[16:12:53.719]                 is_error <- inherits(cond, "error")
[16:12:53.719]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:53.719]                   NULL)
[16:12:53.719]                 if (is_error) {
[16:12:53.719]                   sessionInformation <- function() {
[16:12:53.719]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:53.719]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:53.719]                       search = base::search(), system = base::Sys.info())
[16:12:53.719]                   }
[16:12:53.719]                   ...future.conditions[[length(...future.conditions) + 
[16:12:53.719]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:53.719]                     cond$call), session = sessionInformation(), 
[16:12:53.719]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:53.719]                   signalCondition(cond)
[16:12:53.719]                 }
[16:12:53.719]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:53.719]                 "immediateCondition"))) {
[16:12:53.719]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:53.719]                   ...future.conditions[[length(...future.conditions) + 
[16:12:53.719]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:53.719]                   if (TRUE && !signal) {
[16:12:53.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.719]                     {
[16:12:53.719]                       inherits <- base::inherits
[16:12:53.719]                       invokeRestart <- base::invokeRestart
[16:12:53.719]                       is.null <- base::is.null
[16:12:53.719]                       muffled <- FALSE
[16:12:53.719]                       if (inherits(cond, "message")) {
[16:12:53.719]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:53.719]                         if (muffled) 
[16:12:53.719]                           invokeRestart("muffleMessage")
[16:12:53.719]                       }
[16:12:53.719]                       else if (inherits(cond, "warning")) {
[16:12:53.719]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:53.719]                         if (muffled) 
[16:12:53.719]                           invokeRestart("muffleWarning")
[16:12:53.719]                       }
[16:12:53.719]                       else if (inherits(cond, "condition")) {
[16:12:53.719]                         if (!is.null(pattern)) {
[16:12:53.719]                           computeRestarts <- base::computeRestarts
[16:12:53.719]                           grepl <- base::grepl
[16:12:53.719]                           restarts <- computeRestarts(cond)
[16:12:53.719]                           for (restart in restarts) {
[16:12:53.719]                             name <- restart$name
[16:12:53.719]                             if (is.null(name)) 
[16:12:53.719]                               next
[16:12:53.719]                             if (!grepl(pattern, name)) 
[16:12:53.719]                               next
[16:12:53.719]                             invokeRestart(restart)
[16:12:53.719]                             muffled <- TRUE
[16:12:53.719]                             break
[16:12:53.719]                           }
[16:12:53.719]                         }
[16:12:53.719]                       }
[16:12:53.719]                       invisible(muffled)
[16:12:53.719]                     }
[16:12:53.719]                     muffleCondition(cond, pattern = "^muffle")
[16:12:53.719]                   }
[16:12:53.719]                 }
[16:12:53.719]                 else {
[16:12:53.719]                   if (TRUE) {
[16:12:53.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.719]                     {
[16:12:53.719]                       inherits <- base::inherits
[16:12:53.719]                       invokeRestart <- base::invokeRestart
[16:12:53.719]                       is.null <- base::is.null
[16:12:53.719]                       muffled <- FALSE
[16:12:53.719]                       if (inherits(cond, "message")) {
[16:12:53.719]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:53.719]                         if (muffled) 
[16:12:53.719]                           invokeRestart("muffleMessage")
[16:12:53.719]                       }
[16:12:53.719]                       else if (inherits(cond, "warning")) {
[16:12:53.719]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:53.719]                         if (muffled) 
[16:12:53.719]                           invokeRestart("muffleWarning")
[16:12:53.719]                       }
[16:12:53.719]                       else if (inherits(cond, "condition")) {
[16:12:53.719]                         if (!is.null(pattern)) {
[16:12:53.719]                           computeRestarts <- base::computeRestarts
[16:12:53.719]                           grepl <- base::grepl
[16:12:53.719]                           restarts <- computeRestarts(cond)
[16:12:53.719]                           for (restart in restarts) {
[16:12:53.719]                             name <- restart$name
[16:12:53.719]                             if (is.null(name)) 
[16:12:53.719]                               next
[16:12:53.719]                             if (!grepl(pattern, name)) 
[16:12:53.719]                               next
[16:12:53.719]                             invokeRestart(restart)
[16:12:53.719]                             muffled <- TRUE
[16:12:53.719]                             break
[16:12:53.719]                           }
[16:12:53.719]                         }
[16:12:53.719]                       }
[16:12:53.719]                       invisible(muffled)
[16:12:53.719]                     }
[16:12:53.719]                     muffleCondition(cond, pattern = "^muffle")
[16:12:53.719]                   }
[16:12:53.719]                 }
[16:12:53.719]             }
[16:12:53.719]         }))
[16:12:53.719]     }, error = function(ex) {
[16:12:53.719]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:53.719]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:53.719]                 ...future.rng), started = ...future.startTime, 
[16:12:53.719]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:53.719]             version = "1.8"), class = "FutureResult")
[16:12:53.719]     }, finally = {
[16:12:53.719]         if (!identical(...future.workdir, getwd())) 
[16:12:53.719]             setwd(...future.workdir)
[16:12:53.719]         {
[16:12:53.719]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:53.719]                 ...future.oldOptions$nwarnings <- NULL
[16:12:53.719]             }
[16:12:53.719]             base::options(...future.oldOptions)
[16:12:53.719]             if (.Platform$OS.type == "windows") {
[16:12:53.719]                 old_names <- names(...future.oldEnvVars)
[16:12:53.719]                 envs <- base::Sys.getenv()
[16:12:53.719]                 names <- names(envs)
[16:12:53.719]                 common <- intersect(names, old_names)
[16:12:53.719]                 added <- setdiff(names, old_names)
[16:12:53.719]                 removed <- setdiff(old_names, names)
[16:12:53.719]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:53.719]                   envs[common]]
[16:12:53.719]                 NAMES <- toupper(changed)
[16:12:53.719]                 args <- list()
[16:12:53.719]                 for (kk in seq_along(NAMES)) {
[16:12:53.719]                   name <- changed[[kk]]
[16:12:53.719]                   NAME <- NAMES[[kk]]
[16:12:53.719]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.719]                     next
[16:12:53.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:53.719]                 }
[16:12:53.719]                 NAMES <- toupper(added)
[16:12:53.719]                 for (kk in seq_along(NAMES)) {
[16:12:53.719]                   name <- added[[kk]]
[16:12:53.719]                   NAME <- NAMES[[kk]]
[16:12:53.719]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.719]                     next
[16:12:53.719]                   args[[name]] <- ""
[16:12:53.719]                 }
[16:12:53.719]                 NAMES <- toupper(removed)
[16:12:53.719]                 for (kk in seq_along(NAMES)) {
[16:12:53.719]                   name <- removed[[kk]]
[16:12:53.719]                   NAME <- NAMES[[kk]]
[16:12:53.719]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.719]                     next
[16:12:53.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:53.719]                 }
[16:12:53.719]                 if (length(args) > 0) 
[16:12:53.719]                   base::do.call(base::Sys.setenv, args = args)
[16:12:53.719]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:53.719]             }
[16:12:53.719]             else {
[16:12:53.719]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:53.719]             }
[16:12:53.719]             {
[16:12:53.719]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:53.719]                   0L) {
[16:12:53.719]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:53.719]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:53.719]                   base::options(opts)
[16:12:53.719]                 }
[16:12:53.719]                 {
[16:12:53.719]                   {
[16:12:53.719]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:53.719]                     NULL
[16:12:53.719]                   }
[16:12:53.719]                   options(future.plan = NULL)
[16:12:53.719]                   if (is.na(NA_character_)) 
[16:12:53.719]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:53.719]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:53.719]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:53.719]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:53.719]                     envir = parent.frame()) 
[16:12:53.719]                   {
[16:12:53.719]                     if (is.function(workers)) 
[16:12:53.719]                       workers <- workers()
[16:12:53.719]                     workers <- structure(as.integer(workers), 
[16:12:53.719]                       class = class(workers))
[16:12:53.719]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:53.719]                       workers >= 1)
[16:12:53.719]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:53.719]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:53.719]                     }
[16:12:53.719]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:53.719]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:53.719]                       envir = envir)
[16:12:53.719]                     if (!future$lazy) 
[16:12:53.719]                       future <- run(future)
[16:12:53.719]                     invisible(future)
[16:12:53.719]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:53.719]                 }
[16:12:53.719]             }
[16:12:53.719]         }
[16:12:53.719]     })
[16:12:53.719]     if (TRUE) {
[16:12:53.719]         base::sink(type = "output", split = FALSE)
[16:12:53.719]         if (TRUE) {
[16:12:53.719]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:53.719]         }
[16:12:53.719]         else {
[16:12:53.719]             ...future.result["stdout"] <- base::list(NULL)
[16:12:53.719]         }
[16:12:53.719]         base::close(...future.stdout)
[16:12:53.719]         ...future.stdout <- NULL
[16:12:53.719]     }
[16:12:53.719]     ...future.result$conditions <- ...future.conditions
[16:12:53.719]     ...future.result$finished <- base::Sys.time()
[16:12:53.719]     ...future.result
[16:12:53.719] }
[16:12:53.791] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[16:12:53.791] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[16:12:53.792] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[16:12:53.792] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[16:12:53.793] MultisessionFuture started
[16:12:53.793] - Launch lazy future ... done
[16:12:53.793] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:53.794] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:53.794] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:53.795] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:53.795] Searching for globals ... DONE
[16:12:53.795] Resolving globals: TRUE
[16:12:53.795] Resolving any globals that are futures ...
[16:12:53.796] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:53.796] Resolving any globals that are futures ... DONE
[16:12:53.796] Resolving futures part of globals (recursively) ...
[16:12:53.796] resolve() on list ...
[16:12:53.796]  recursive: 99
[16:12:53.796]  length: 1
[16:12:53.797]  elements: ‘ii’
[16:12:53.797]  length: 0 (resolved future 1)
[16:12:53.797] resolve() on list ... DONE
[16:12:53.797] - globals: [1] ‘ii’
[16:12:53.797] Resolving futures part of globals (recursively) ... DONE
[16:12:53.797] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:53.797] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:12:53.798] - globals: [1] ‘ii’
[16:12:53.798] 
[16:12:53.798] getGlobalsAndPackages() ... DONE
[16:12:53.798] run() for ‘Future’ ...
[16:12:53.798] - state: ‘created’
[16:12:53.798] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:53.813] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:53.813] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:53.813]   - Field: ‘node’
[16:12:53.814]   - Field: ‘label’
[16:12:53.814]   - Field: ‘local’
[16:12:53.814]   - Field: ‘owner’
[16:12:53.814]   - Field: ‘envir’
[16:12:53.814]   - Field: ‘workers’
[16:12:53.814]   - Field: ‘packages’
[16:12:53.814]   - Field: ‘gc’
[16:12:53.814]   - Field: ‘conditions’
[16:12:53.814]   - Field: ‘persistent’
[16:12:53.814]   - Field: ‘expr’
[16:12:53.815]   - Field: ‘uuid’
[16:12:53.815]   - Field: ‘seed’
[16:12:53.815]   - Field: ‘version’
[16:12:53.815]   - Field: ‘result’
[16:12:53.815]   - Field: ‘asynchronous’
[16:12:53.815]   - Field: ‘calls’
[16:12:53.815]   - Field: ‘globals’
[16:12:53.815]   - Field: ‘stdout’
[16:12:53.815]   - Field: ‘earlySignal’
[16:12:53.815]   - Field: ‘lazy’
[16:12:53.815]   - Field: ‘state’
[16:12:53.816] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:53.816] - Launch lazy future ...
[16:12:53.816] Packages needed by the future expression (n = 0): <none>
[16:12:53.816] Packages needed by future strategies (n = 0): <none>
[16:12:53.817] {
[16:12:53.817]     {
[16:12:53.817]         {
[16:12:53.817]             ...future.startTime <- base::Sys.time()
[16:12:53.817]             {
[16:12:53.817]                 {
[16:12:53.817]                   {
[16:12:53.817]                     {
[16:12:53.817]                       base::local({
[16:12:53.817]                         has_future <- base::requireNamespace("future", 
[16:12:53.817]                           quietly = TRUE)
[16:12:53.817]                         if (has_future) {
[16:12:53.817]                           ns <- base::getNamespace("future")
[16:12:53.817]                           version <- ns[[".package"]][["version"]]
[16:12:53.817]                           if (is.null(version)) 
[16:12:53.817]                             version <- utils::packageVersion("future")
[16:12:53.817]                         }
[16:12:53.817]                         else {
[16:12:53.817]                           version <- NULL
[16:12:53.817]                         }
[16:12:53.817]                         if (!has_future || version < "1.8.0") {
[16:12:53.817]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:53.817]                             "", base::R.version$version.string), 
[16:12:53.817]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:53.817]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:53.817]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:53.817]                               "release", "version")], collapse = " "), 
[16:12:53.817]                             hostname = base::Sys.info()[["nodename"]])
[16:12:53.817]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:53.817]                             info)
[16:12:53.817]                           info <- base::paste(info, collapse = "; ")
[16:12:53.817]                           if (!has_future) {
[16:12:53.817]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:53.817]                               info)
[16:12:53.817]                           }
[16:12:53.817]                           else {
[16:12:53.817]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:53.817]                               info, version)
[16:12:53.817]                           }
[16:12:53.817]                           base::stop(msg)
[16:12:53.817]                         }
[16:12:53.817]                       })
[16:12:53.817]                     }
[16:12:53.817]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:53.817]                     base::options(mc.cores = 1L)
[16:12:53.817]                   }
[16:12:53.817]                   options(future.plan = NULL)
[16:12:53.817]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:53.817]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:53.817]                 }
[16:12:53.817]                 ...future.workdir <- getwd()
[16:12:53.817]             }
[16:12:53.817]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:53.817]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:53.817]         }
[16:12:53.817]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:53.817]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:53.817]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:53.817]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:53.817]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:53.817]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:53.817]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:53.817]             base::names(...future.oldOptions))
[16:12:53.817]     }
[16:12:53.817]     if (FALSE) {
[16:12:53.817]     }
[16:12:53.817]     else {
[16:12:53.817]         if (TRUE) {
[16:12:53.817]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:53.817]                 open = "w")
[16:12:53.817]         }
[16:12:53.817]         else {
[16:12:53.817]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:53.817]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:53.817]         }
[16:12:53.817]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:53.817]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:53.817]             base::sink(type = "output", split = FALSE)
[16:12:53.817]             base::close(...future.stdout)
[16:12:53.817]         }, add = TRUE)
[16:12:53.817]     }
[16:12:53.817]     ...future.frame <- base::sys.nframe()
[16:12:53.817]     ...future.conditions <- base::list()
[16:12:53.817]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:53.817]     if (FALSE) {
[16:12:53.817]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:53.817]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:53.817]     }
[16:12:53.817]     ...future.result <- base::tryCatch({
[16:12:53.817]         base::withCallingHandlers({
[16:12:53.817]             ...future.value <- base::withVisible(base::local({
[16:12:53.817]                 ...future.makeSendCondition <- local({
[16:12:53.817]                   sendCondition <- NULL
[16:12:53.817]                   function(frame = 1L) {
[16:12:53.817]                     if (is.function(sendCondition)) 
[16:12:53.817]                       return(sendCondition)
[16:12:53.817]                     ns <- getNamespace("parallel")
[16:12:53.817]                     if (exists("sendData", mode = "function", 
[16:12:53.817]                       envir = ns)) {
[16:12:53.817]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:53.817]                         envir = ns)
[16:12:53.817]                       envir <- sys.frame(frame)
[16:12:53.817]                       master <- NULL
[16:12:53.817]                       while (!identical(envir, .GlobalEnv) && 
[16:12:53.817]                         !identical(envir, emptyenv())) {
[16:12:53.817]                         if (exists("master", mode = "list", envir = envir, 
[16:12:53.817]                           inherits = FALSE)) {
[16:12:53.817]                           master <- get("master", mode = "list", 
[16:12:53.817]                             envir = envir, inherits = FALSE)
[16:12:53.817]                           if (inherits(master, c("SOCKnode", 
[16:12:53.817]                             "SOCK0node"))) {
[16:12:53.817]                             sendCondition <<- function(cond) {
[16:12:53.817]                               data <- list(type = "VALUE", value = cond, 
[16:12:53.817]                                 success = TRUE)
[16:12:53.817]                               parallel_sendData(master, data)
[16:12:53.817]                             }
[16:12:53.817]                             return(sendCondition)
[16:12:53.817]                           }
[16:12:53.817]                         }
[16:12:53.817]                         frame <- frame + 1L
[16:12:53.817]                         envir <- sys.frame(frame)
[16:12:53.817]                       }
[16:12:53.817]                     }
[16:12:53.817]                     sendCondition <<- function(cond) NULL
[16:12:53.817]                   }
[16:12:53.817]                 })
[16:12:53.817]                 withCallingHandlers({
[16:12:53.817]                   {
[16:12:53.817]                     b <- a * ii
[16:12:53.817]                     a <- 0
[16:12:53.817]                     b
[16:12:53.817]                   }
[16:12:53.817]                 }, immediateCondition = function(cond) {
[16:12:53.817]                   sendCondition <- ...future.makeSendCondition()
[16:12:53.817]                   sendCondition(cond)
[16:12:53.817]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.817]                   {
[16:12:53.817]                     inherits <- base::inherits
[16:12:53.817]                     invokeRestart <- base::invokeRestart
[16:12:53.817]                     is.null <- base::is.null
[16:12:53.817]                     muffled <- FALSE
[16:12:53.817]                     if (inherits(cond, "message")) {
[16:12:53.817]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:53.817]                       if (muffled) 
[16:12:53.817]                         invokeRestart("muffleMessage")
[16:12:53.817]                     }
[16:12:53.817]                     else if (inherits(cond, "warning")) {
[16:12:53.817]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:53.817]                       if (muffled) 
[16:12:53.817]                         invokeRestart("muffleWarning")
[16:12:53.817]                     }
[16:12:53.817]                     else if (inherits(cond, "condition")) {
[16:12:53.817]                       if (!is.null(pattern)) {
[16:12:53.817]                         computeRestarts <- base::computeRestarts
[16:12:53.817]                         grepl <- base::grepl
[16:12:53.817]                         restarts <- computeRestarts(cond)
[16:12:53.817]                         for (restart in restarts) {
[16:12:53.817]                           name <- restart$name
[16:12:53.817]                           if (is.null(name)) 
[16:12:53.817]                             next
[16:12:53.817]                           if (!grepl(pattern, name)) 
[16:12:53.817]                             next
[16:12:53.817]                           invokeRestart(restart)
[16:12:53.817]                           muffled <- TRUE
[16:12:53.817]                           break
[16:12:53.817]                         }
[16:12:53.817]                       }
[16:12:53.817]                     }
[16:12:53.817]                     invisible(muffled)
[16:12:53.817]                   }
[16:12:53.817]                   muffleCondition(cond)
[16:12:53.817]                 })
[16:12:53.817]             }))
[16:12:53.817]             future::FutureResult(value = ...future.value$value, 
[16:12:53.817]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:53.817]                   ...future.rng), globalenv = if (FALSE) 
[16:12:53.817]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:53.817]                     ...future.globalenv.names))
[16:12:53.817]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:53.817]         }, condition = base::local({
[16:12:53.817]             c <- base::c
[16:12:53.817]             inherits <- base::inherits
[16:12:53.817]             invokeRestart <- base::invokeRestart
[16:12:53.817]             length <- base::length
[16:12:53.817]             list <- base::list
[16:12:53.817]             seq.int <- base::seq.int
[16:12:53.817]             signalCondition <- base::signalCondition
[16:12:53.817]             sys.calls <- base::sys.calls
[16:12:53.817]             `[[` <- base::`[[`
[16:12:53.817]             `+` <- base::`+`
[16:12:53.817]             `<<-` <- base::`<<-`
[16:12:53.817]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:53.817]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:53.817]                   3L)]
[16:12:53.817]             }
[16:12:53.817]             function(cond) {
[16:12:53.817]                 is_error <- inherits(cond, "error")
[16:12:53.817]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:53.817]                   NULL)
[16:12:53.817]                 if (is_error) {
[16:12:53.817]                   sessionInformation <- function() {
[16:12:53.817]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:53.817]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:53.817]                       search = base::search(), system = base::Sys.info())
[16:12:53.817]                   }
[16:12:53.817]                   ...future.conditions[[length(...future.conditions) + 
[16:12:53.817]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:53.817]                     cond$call), session = sessionInformation(), 
[16:12:53.817]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:53.817]                   signalCondition(cond)
[16:12:53.817]                 }
[16:12:53.817]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:53.817]                 "immediateCondition"))) {
[16:12:53.817]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:53.817]                   ...future.conditions[[length(...future.conditions) + 
[16:12:53.817]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:53.817]                   if (TRUE && !signal) {
[16:12:53.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.817]                     {
[16:12:53.817]                       inherits <- base::inherits
[16:12:53.817]                       invokeRestart <- base::invokeRestart
[16:12:53.817]                       is.null <- base::is.null
[16:12:53.817]                       muffled <- FALSE
[16:12:53.817]                       if (inherits(cond, "message")) {
[16:12:53.817]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:53.817]                         if (muffled) 
[16:12:53.817]                           invokeRestart("muffleMessage")
[16:12:53.817]                       }
[16:12:53.817]                       else if (inherits(cond, "warning")) {
[16:12:53.817]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:53.817]                         if (muffled) 
[16:12:53.817]                           invokeRestart("muffleWarning")
[16:12:53.817]                       }
[16:12:53.817]                       else if (inherits(cond, "condition")) {
[16:12:53.817]                         if (!is.null(pattern)) {
[16:12:53.817]                           computeRestarts <- base::computeRestarts
[16:12:53.817]                           grepl <- base::grepl
[16:12:53.817]                           restarts <- computeRestarts(cond)
[16:12:53.817]                           for (restart in restarts) {
[16:12:53.817]                             name <- restart$name
[16:12:53.817]                             if (is.null(name)) 
[16:12:53.817]                               next
[16:12:53.817]                             if (!grepl(pattern, name)) 
[16:12:53.817]                               next
[16:12:53.817]                             invokeRestart(restart)
[16:12:53.817]                             muffled <- TRUE
[16:12:53.817]                             break
[16:12:53.817]                           }
[16:12:53.817]                         }
[16:12:53.817]                       }
[16:12:53.817]                       invisible(muffled)
[16:12:53.817]                     }
[16:12:53.817]                     muffleCondition(cond, pattern = "^muffle")
[16:12:53.817]                   }
[16:12:53.817]                 }
[16:12:53.817]                 else {
[16:12:53.817]                   if (TRUE) {
[16:12:53.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.817]                     {
[16:12:53.817]                       inherits <- base::inherits
[16:12:53.817]                       invokeRestart <- base::invokeRestart
[16:12:53.817]                       is.null <- base::is.null
[16:12:53.817]                       muffled <- FALSE
[16:12:53.817]                       if (inherits(cond, "message")) {
[16:12:53.817]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:53.817]                         if (muffled) 
[16:12:53.817]                           invokeRestart("muffleMessage")
[16:12:53.817]                       }
[16:12:53.817]                       else if (inherits(cond, "warning")) {
[16:12:53.817]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:53.817]                         if (muffled) 
[16:12:53.817]                           invokeRestart("muffleWarning")
[16:12:53.817]                       }
[16:12:53.817]                       else if (inherits(cond, "condition")) {
[16:12:53.817]                         if (!is.null(pattern)) {
[16:12:53.817]                           computeRestarts <- base::computeRestarts
[16:12:53.817]                           grepl <- base::grepl
[16:12:53.817]                           restarts <- computeRestarts(cond)
[16:12:53.817]                           for (restart in restarts) {
[16:12:53.817]                             name <- restart$name
[16:12:53.817]                             if (is.null(name)) 
[16:12:53.817]                               next
[16:12:53.817]                             if (!grepl(pattern, name)) 
[16:12:53.817]                               next
[16:12:53.817]                             invokeRestart(restart)
[16:12:53.817]                             muffled <- TRUE
[16:12:53.817]                             break
[16:12:53.817]                           }
[16:12:53.817]                         }
[16:12:53.817]                       }
[16:12:53.817]                       invisible(muffled)
[16:12:53.817]                     }
[16:12:53.817]                     muffleCondition(cond, pattern = "^muffle")
[16:12:53.817]                   }
[16:12:53.817]                 }
[16:12:53.817]             }
[16:12:53.817]         }))
[16:12:53.817]     }, error = function(ex) {
[16:12:53.817]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:53.817]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:53.817]                 ...future.rng), started = ...future.startTime, 
[16:12:53.817]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:53.817]             version = "1.8"), class = "FutureResult")
[16:12:53.817]     }, finally = {
[16:12:53.817]         if (!identical(...future.workdir, getwd())) 
[16:12:53.817]             setwd(...future.workdir)
[16:12:53.817]         {
[16:12:53.817]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:53.817]                 ...future.oldOptions$nwarnings <- NULL
[16:12:53.817]             }
[16:12:53.817]             base::options(...future.oldOptions)
[16:12:53.817]             if (.Platform$OS.type == "windows") {
[16:12:53.817]                 old_names <- names(...future.oldEnvVars)
[16:12:53.817]                 envs <- base::Sys.getenv()
[16:12:53.817]                 names <- names(envs)
[16:12:53.817]                 common <- intersect(names, old_names)
[16:12:53.817]                 added <- setdiff(names, old_names)
[16:12:53.817]                 removed <- setdiff(old_names, names)
[16:12:53.817]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:53.817]                   envs[common]]
[16:12:53.817]                 NAMES <- toupper(changed)
[16:12:53.817]                 args <- list()
[16:12:53.817]                 for (kk in seq_along(NAMES)) {
[16:12:53.817]                   name <- changed[[kk]]
[16:12:53.817]                   NAME <- NAMES[[kk]]
[16:12:53.817]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.817]                     next
[16:12:53.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:53.817]                 }
[16:12:53.817]                 NAMES <- toupper(added)
[16:12:53.817]                 for (kk in seq_along(NAMES)) {
[16:12:53.817]                   name <- added[[kk]]
[16:12:53.817]                   NAME <- NAMES[[kk]]
[16:12:53.817]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.817]                     next
[16:12:53.817]                   args[[name]] <- ""
[16:12:53.817]                 }
[16:12:53.817]                 NAMES <- toupper(removed)
[16:12:53.817]                 for (kk in seq_along(NAMES)) {
[16:12:53.817]                   name <- removed[[kk]]
[16:12:53.817]                   NAME <- NAMES[[kk]]
[16:12:53.817]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.817]                     next
[16:12:53.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:53.817]                 }
[16:12:53.817]                 if (length(args) > 0) 
[16:12:53.817]                   base::do.call(base::Sys.setenv, args = args)
[16:12:53.817]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:53.817]             }
[16:12:53.817]             else {
[16:12:53.817]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:53.817]             }
[16:12:53.817]             {
[16:12:53.817]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:53.817]                   0L) {
[16:12:53.817]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:53.817]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:53.817]                   base::options(opts)
[16:12:53.817]                 }
[16:12:53.817]                 {
[16:12:53.817]                   {
[16:12:53.817]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:53.817]                     NULL
[16:12:53.817]                   }
[16:12:53.817]                   options(future.plan = NULL)
[16:12:53.817]                   if (is.na(NA_character_)) 
[16:12:53.817]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:53.817]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:53.817]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:53.817]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:53.817]                     envir = parent.frame()) 
[16:12:53.817]                   {
[16:12:53.817]                     if (is.function(workers)) 
[16:12:53.817]                       workers <- workers()
[16:12:53.817]                     workers <- structure(as.integer(workers), 
[16:12:53.817]                       class = class(workers))
[16:12:53.817]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:53.817]                       workers >= 1)
[16:12:53.817]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:53.817]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:53.817]                     }
[16:12:53.817]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:53.817]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:53.817]                       envir = envir)
[16:12:53.817]                     if (!future$lazy) 
[16:12:53.817]                       future <- run(future)
[16:12:53.817]                     invisible(future)
[16:12:53.817]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:53.817]                 }
[16:12:53.817]             }
[16:12:53.817]         }
[16:12:53.817]     })
[16:12:53.817]     if (TRUE) {
[16:12:53.817]         base::sink(type = "output", split = FALSE)
[16:12:53.817]         if (TRUE) {
[16:12:53.817]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:53.817]         }
[16:12:53.817]         else {
[16:12:53.817]             ...future.result["stdout"] <- base::list(NULL)
[16:12:53.817]         }
[16:12:53.817]         base::close(...future.stdout)
[16:12:53.817]         ...future.stdout <- NULL
[16:12:53.817]     }
[16:12:53.817]     ...future.result$conditions <- ...future.conditions
[16:12:53.817]     ...future.result$finished <- base::Sys.time()
[16:12:53.817]     ...future.result
[16:12:53.817] }
[16:12:53.819] Poll #1 (0): usedNodes() = 2, workers = 2
[16:12:53.830] receiveMessageFromWorker() for ClusterFuture ...
[16:12:53.830] - Validating connection of MultisessionFuture
[16:12:53.830] - received message: FutureResult
[16:12:53.830] - Received FutureResult
[16:12:53.830] - Erased future from FutureRegistry
[16:12:53.831] result() for ClusterFuture ...
[16:12:53.831] - result already collected: FutureResult
[16:12:53.831] result() for ClusterFuture ... done
[16:12:53.831] signalConditions() ...
[16:12:53.831]  - include = ‘immediateCondition’
[16:12:53.831]  - exclude = 
[16:12:53.831]  - resignal = FALSE
[16:12:53.831]  - Number of conditions: 1
[16:12:53.831] signalConditions() ... done
[16:12:53.831] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:53.831] result() for ClusterFuture ...
[16:12:53.832] - result already collected: FutureResult
[16:12:53.832] result() for ClusterFuture ... done
[16:12:53.832] result() for ClusterFuture ...
[16:12:53.832] - result already collected: FutureResult
[16:12:53.832] result() for ClusterFuture ... done
[16:12:53.832] signalConditions() ...
[16:12:53.832]  - include = ‘immediateCondition’
[16:12:53.832]  - exclude = 
[16:12:53.832]  - resignal = FALSE
[16:12:53.832]  - Number of conditions: 1
[16:12:53.832] signalConditions() ... done
[16:12:53.833] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:12:53.833] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:12:53.834] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:12:53.834] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:12:53.834] MultisessionFuture started
[16:12:53.834] - Launch lazy future ... done
[16:12:53.834] run() for ‘MultisessionFuture’ ... done
[16:12:53.835] result() for ClusterFuture ...
[16:12:53.835] - result already collected: FutureResult
[16:12:53.835] result() for ClusterFuture ... done
[16:12:53.835] result() for ClusterFuture ...
[16:12:53.835] - result already collected: FutureResult
[16:12:53.835] result() for ClusterFuture ... done
[16:12:53.835] signalConditions() ...
[16:12:53.835]  - include = ‘immediateCondition’
[16:12:53.835]  - exclude = 
[16:12:53.835]  - resignal = FALSE
[16:12:53.836]  - Number of conditions: 1
[16:12:53.836] signalConditions() ... done
[16:12:53.836] Future state: ‘finished’
[16:12:53.836] result() for ClusterFuture ...
[16:12:53.836] - result already collected: FutureResult
[16:12:53.836] result() for ClusterFuture ... done
[16:12:53.837] signalConditions() ...
[16:12:53.837]  - include = ‘condition’
[16:12:53.837]  - exclude = ‘immediateCondition’
[16:12:53.837]  - resignal = TRUE
[16:12:53.837]  - Number of conditions: 1
[16:12:53.837]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:12:53.838] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2729ef2608da" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:12:53"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:53.859] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:53.859] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:53.860] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:53.860] Searching for globals ... DONE
[16:12:53.861] Resolving globals: TRUE
[16:12:53.861] Resolving any globals that are futures ...
[16:12:53.861] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:53.861] Resolving any globals that are futures ... DONE
[16:12:53.861] Resolving futures part of globals (recursively) ...
[16:12:53.861] resolve() on list ...
[16:12:53.862]  recursive: 99
[16:12:53.862]  length: 1
[16:12:53.862]  elements: ‘ii’
[16:12:53.862]  length: 0 (resolved future 1)
[16:12:53.862] resolve() on list ... DONE
[16:12:53.862] - globals: [1] ‘ii’
[16:12:53.862] Resolving futures part of globals (recursively) ... DONE
[16:12:53.862] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:53.863] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:12:53.863] - globals: [1] ‘ii’
[16:12:53.863] 
[16:12:53.863] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:53.864] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:53.864] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:53.865] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:53.865] Searching for globals ... DONE
[16:12:53.865] Resolving globals: TRUE
[16:12:53.865] Resolving any globals that are futures ...
[16:12:53.865] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:53.865] Resolving any globals that are futures ... DONE
[16:12:53.866] Resolving futures part of globals (recursively) ...
[16:12:53.866] resolve() on list ...
[16:12:53.866]  recursive: 99
[16:12:53.866]  length: 1
[16:12:53.866]  elements: ‘ii’
[16:12:53.866]  length: 0 (resolved future 1)
[16:12:53.867] resolve() on list ... DONE
[16:12:53.867] - globals: [1] ‘ii’
[16:12:53.867] Resolving futures part of globals (recursively) ... DONE
[16:12:53.867] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:53.867] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:12:53.867] - globals: [1] ‘ii’
[16:12:53.867] 
[16:12:53.867] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:53.868] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:53.868] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:53.870] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:53.870] Searching for globals ... DONE
[16:12:53.870] Resolving globals: TRUE
[16:12:53.870] Resolving any globals that are futures ...
[16:12:53.870] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[16:12:53.870] Resolving any globals that are futures ... DONE
[16:12:53.871] Resolving futures part of globals (recursively) ...
[16:12:53.871] resolve() on list ...
[16:12:53.871]  recursive: 99
[16:12:53.871]  length: 1
[16:12:53.871]  elements: ‘ii’
[16:12:53.871]  length: 0 (resolved future 1)
[16:12:53.872] resolve() on list ... DONE
[16:12:53.872] - globals: [1] ‘ii’
[16:12:53.872] Resolving futures part of globals (recursively) ... DONE
[16:12:53.872] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:53.872] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:12:53.873] - globals: [1] ‘ii’
[16:12:53.873] 
[16:12:53.873] getGlobalsAndPackages() ... DONE
[16:12:53.873] run() for ‘Future’ ...
[16:12:53.873] - state: ‘created’
[16:12:53.873] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:53.889] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:53.889] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:53.890]   - Field: ‘node’
[16:12:53.890]   - Field: ‘label’
[16:12:53.890]   - Field: ‘local’
[16:12:53.890]   - Field: ‘owner’
[16:12:53.890]   - Field: ‘envir’
[16:12:53.890]   - Field: ‘workers’
[16:12:53.890]   - Field: ‘packages’
[16:12:53.890]   - Field: ‘gc’
[16:12:53.890]   - Field: ‘conditions’
[16:12:53.890]   - Field: ‘persistent’
[16:12:53.891]   - Field: ‘expr’
[16:12:53.891]   - Field: ‘uuid’
[16:12:53.891]   - Field: ‘seed’
[16:12:53.891]   - Field: ‘version’
[16:12:53.891]   - Field: ‘result’
[16:12:53.891]   - Field: ‘asynchronous’
[16:12:53.891]   - Field: ‘calls’
[16:12:53.891]   - Field: ‘globals’
[16:12:53.891]   - Field: ‘stdout’
[16:12:53.891]   - Field: ‘earlySignal’
[16:12:53.891]   - Field: ‘lazy’
[16:12:53.892]   - Field: ‘state’
[16:12:53.892] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:53.892] - Launch lazy future ...
[16:12:53.892] Packages needed by the future expression (n = 0): <none>
[16:12:53.892] Packages needed by future strategies (n = 0): <none>
[16:12:53.893] {
[16:12:53.893]     {
[16:12:53.893]         {
[16:12:53.893]             ...future.startTime <- base::Sys.time()
[16:12:53.893]             {
[16:12:53.893]                 {
[16:12:53.893]                   {
[16:12:53.893]                     {
[16:12:53.893]                       base::local({
[16:12:53.893]                         has_future <- base::requireNamespace("future", 
[16:12:53.893]                           quietly = TRUE)
[16:12:53.893]                         if (has_future) {
[16:12:53.893]                           ns <- base::getNamespace("future")
[16:12:53.893]                           version <- ns[[".package"]][["version"]]
[16:12:53.893]                           if (is.null(version)) 
[16:12:53.893]                             version <- utils::packageVersion("future")
[16:12:53.893]                         }
[16:12:53.893]                         else {
[16:12:53.893]                           version <- NULL
[16:12:53.893]                         }
[16:12:53.893]                         if (!has_future || version < "1.8.0") {
[16:12:53.893]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:53.893]                             "", base::R.version$version.string), 
[16:12:53.893]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:53.893]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:53.893]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:53.893]                               "release", "version")], collapse = " "), 
[16:12:53.893]                             hostname = base::Sys.info()[["nodename"]])
[16:12:53.893]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:53.893]                             info)
[16:12:53.893]                           info <- base::paste(info, collapse = "; ")
[16:12:53.893]                           if (!has_future) {
[16:12:53.893]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:53.893]                               info)
[16:12:53.893]                           }
[16:12:53.893]                           else {
[16:12:53.893]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:53.893]                               info, version)
[16:12:53.893]                           }
[16:12:53.893]                           base::stop(msg)
[16:12:53.893]                         }
[16:12:53.893]                       })
[16:12:53.893]                     }
[16:12:53.893]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:53.893]                     base::options(mc.cores = 1L)
[16:12:53.893]                   }
[16:12:53.893]                   options(future.plan = NULL)
[16:12:53.893]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:53.893]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:53.893]                 }
[16:12:53.893]                 ...future.workdir <- getwd()
[16:12:53.893]             }
[16:12:53.893]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:53.893]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:53.893]         }
[16:12:53.893]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:53.893]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:53.893]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:53.893]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:53.893]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:53.893]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:53.893]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:53.893]             base::names(...future.oldOptions))
[16:12:53.893]     }
[16:12:53.893]     if (FALSE) {
[16:12:53.893]     }
[16:12:53.893]     else {
[16:12:53.893]         if (TRUE) {
[16:12:53.893]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:53.893]                 open = "w")
[16:12:53.893]         }
[16:12:53.893]         else {
[16:12:53.893]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:53.893]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:53.893]         }
[16:12:53.893]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:53.893]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:53.893]             base::sink(type = "output", split = FALSE)
[16:12:53.893]             base::close(...future.stdout)
[16:12:53.893]         }, add = TRUE)
[16:12:53.893]     }
[16:12:53.893]     ...future.frame <- base::sys.nframe()
[16:12:53.893]     ...future.conditions <- base::list()
[16:12:53.893]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:53.893]     if (FALSE) {
[16:12:53.893]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:53.893]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:53.893]     }
[16:12:53.893]     ...future.result <- base::tryCatch({
[16:12:53.893]         base::withCallingHandlers({
[16:12:53.893]             ...future.value <- base::withVisible(base::local({
[16:12:53.893]                 ...future.makeSendCondition <- local({
[16:12:53.893]                   sendCondition <- NULL
[16:12:53.893]                   function(frame = 1L) {
[16:12:53.893]                     if (is.function(sendCondition)) 
[16:12:53.893]                       return(sendCondition)
[16:12:53.893]                     ns <- getNamespace("parallel")
[16:12:53.893]                     if (exists("sendData", mode = "function", 
[16:12:53.893]                       envir = ns)) {
[16:12:53.893]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:53.893]                         envir = ns)
[16:12:53.893]                       envir <- sys.frame(frame)
[16:12:53.893]                       master <- NULL
[16:12:53.893]                       while (!identical(envir, .GlobalEnv) && 
[16:12:53.893]                         !identical(envir, emptyenv())) {
[16:12:53.893]                         if (exists("master", mode = "list", envir = envir, 
[16:12:53.893]                           inherits = FALSE)) {
[16:12:53.893]                           master <- get("master", mode = "list", 
[16:12:53.893]                             envir = envir, inherits = FALSE)
[16:12:53.893]                           if (inherits(master, c("SOCKnode", 
[16:12:53.893]                             "SOCK0node"))) {
[16:12:53.893]                             sendCondition <<- function(cond) {
[16:12:53.893]                               data <- list(type = "VALUE", value = cond, 
[16:12:53.893]                                 success = TRUE)
[16:12:53.893]                               parallel_sendData(master, data)
[16:12:53.893]                             }
[16:12:53.893]                             return(sendCondition)
[16:12:53.893]                           }
[16:12:53.893]                         }
[16:12:53.893]                         frame <- frame + 1L
[16:12:53.893]                         envir <- sys.frame(frame)
[16:12:53.893]                       }
[16:12:53.893]                     }
[16:12:53.893]                     sendCondition <<- function(cond) NULL
[16:12:53.893]                   }
[16:12:53.893]                 })
[16:12:53.893]                 withCallingHandlers({
[16:12:53.893]                   {
[16:12:53.893]                     b <- a * ii
[16:12:53.893]                     a <- 0
[16:12:53.893]                     b
[16:12:53.893]                   }
[16:12:53.893]                 }, immediateCondition = function(cond) {
[16:12:53.893]                   sendCondition <- ...future.makeSendCondition()
[16:12:53.893]                   sendCondition(cond)
[16:12:53.893]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.893]                   {
[16:12:53.893]                     inherits <- base::inherits
[16:12:53.893]                     invokeRestart <- base::invokeRestart
[16:12:53.893]                     is.null <- base::is.null
[16:12:53.893]                     muffled <- FALSE
[16:12:53.893]                     if (inherits(cond, "message")) {
[16:12:53.893]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:53.893]                       if (muffled) 
[16:12:53.893]                         invokeRestart("muffleMessage")
[16:12:53.893]                     }
[16:12:53.893]                     else if (inherits(cond, "warning")) {
[16:12:53.893]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:53.893]                       if (muffled) 
[16:12:53.893]                         invokeRestart("muffleWarning")
[16:12:53.893]                     }
[16:12:53.893]                     else if (inherits(cond, "condition")) {
[16:12:53.893]                       if (!is.null(pattern)) {
[16:12:53.893]                         computeRestarts <- base::computeRestarts
[16:12:53.893]                         grepl <- base::grepl
[16:12:53.893]                         restarts <- computeRestarts(cond)
[16:12:53.893]                         for (restart in restarts) {
[16:12:53.893]                           name <- restart$name
[16:12:53.893]                           if (is.null(name)) 
[16:12:53.893]                             next
[16:12:53.893]                           if (!grepl(pattern, name)) 
[16:12:53.893]                             next
[16:12:53.893]                           invokeRestart(restart)
[16:12:53.893]                           muffled <- TRUE
[16:12:53.893]                           break
[16:12:53.893]                         }
[16:12:53.893]                       }
[16:12:53.893]                     }
[16:12:53.893]                     invisible(muffled)
[16:12:53.893]                   }
[16:12:53.893]                   muffleCondition(cond)
[16:12:53.893]                 })
[16:12:53.893]             }))
[16:12:53.893]             future::FutureResult(value = ...future.value$value, 
[16:12:53.893]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:53.893]                   ...future.rng), globalenv = if (FALSE) 
[16:12:53.893]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:53.893]                     ...future.globalenv.names))
[16:12:53.893]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:53.893]         }, condition = base::local({
[16:12:53.893]             c <- base::c
[16:12:53.893]             inherits <- base::inherits
[16:12:53.893]             invokeRestart <- base::invokeRestart
[16:12:53.893]             length <- base::length
[16:12:53.893]             list <- base::list
[16:12:53.893]             seq.int <- base::seq.int
[16:12:53.893]             signalCondition <- base::signalCondition
[16:12:53.893]             sys.calls <- base::sys.calls
[16:12:53.893]             `[[` <- base::`[[`
[16:12:53.893]             `+` <- base::`+`
[16:12:53.893]             `<<-` <- base::`<<-`
[16:12:53.893]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:53.893]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:53.893]                   3L)]
[16:12:53.893]             }
[16:12:53.893]             function(cond) {
[16:12:53.893]                 is_error <- inherits(cond, "error")
[16:12:53.893]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:53.893]                   NULL)
[16:12:53.893]                 if (is_error) {
[16:12:53.893]                   sessionInformation <- function() {
[16:12:53.893]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:53.893]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:53.893]                       search = base::search(), system = base::Sys.info())
[16:12:53.893]                   }
[16:12:53.893]                   ...future.conditions[[length(...future.conditions) + 
[16:12:53.893]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:53.893]                     cond$call), session = sessionInformation(), 
[16:12:53.893]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:53.893]                   signalCondition(cond)
[16:12:53.893]                 }
[16:12:53.893]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:53.893]                 "immediateCondition"))) {
[16:12:53.893]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:53.893]                   ...future.conditions[[length(...future.conditions) + 
[16:12:53.893]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:53.893]                   if (TRUE && !signal) {
[16:12:53.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.893]                     {
[16:12:53.893]                       inherits <- base::inherits
[16:12:53.893]                       invokeRestart <- base::invokeRestart
[16:12:53.893]                       is.null <- base::is.null
[16:12:53.893]                       muffled <- FALSE
[16:12:53.893]                       if (inherits(cond, "message")) {
[16:12:53.893]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:53.893]                         if (muffled) 
[16:12:53.893]                           invokeRestart("muffleMessage")
[16:12:53.893]                       }
[16:12:53.893]                       else if (inherits(cond, "warning")) {
[16:12:53.893]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:53.893]                         if (muffled) 
[16:12:53.893]                           invokeRestart("muffleWarning")
[16:12:53.893]                       }
[16:12:53.893]                       else if (inherits(cond, "condition")) {
[16:12:53.893]                         if (!is.null(pattern)) {
[16:12:53.893]                           computeRestarts <- base::computeRestarts
[16:12:53.893]                           grepl <- base::grepl
[16:12:53.893]                           restarts <- computeRestarts(cond)
[16:12:53.893]                           for (restart in restarts) {
[16:12:53.893]                             name <- restart$name
[16:12:53.893]                             if (is.null(name)) 
[16:12:53.893]                               next
[16:12:53.893]                             if (!grepl(pattern, name)) 
[16:12:53.893]                               next
[16:12:53.893]                             invokeRestart(restart)
[16:12:53.893]                             muffled <- TRUE
[16:12:53.893]                             break
[16:12:53.893]                           }
[16:12:53.893]                         }
[16:12:53.893]                       }
[16:12:53.893]                       invisible(muffled)
[16:12:53.893]                     }
[16:12:53.893]                     muffleCondition(cond, pattern = "^muffle")
[16:12:53.893]                   }
[16:12:53.893]                 }
[16:12:53.893]                 else {
[16:12:53.893]                   if (TRUE) {
[16:12:53.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.893]                     {
[16:12:53.893]                       inherits <- base::inherits
[16:12:53.893]                       invokeRestart <- base::invokeRestart
[16:12:53.893]                       is.null <- base::is.null
[16:12:53.893]                       muffled <- FALSE
[16:12:53.893]                       if (inherits(cond, "message")) {
[16:12:53.893]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:53.893]                         if (muffled) 
[16:12:53.893]                           invokeRestart("muffleMessage")
[16:12:53.893]                       }
[16:12:53.893]                       else if (inherits(cond, "warning")) {
[16:12:53.893]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:53.893]                         if (muffled) 
[16:12:53.893]                           invokeRestart("muffleWarning")
[16:12:53.893]                       }
[16:12:53.893]                       else if (inherits(cond, "condition")) {
[16:12:53.893]                         if (!is.null(pattern)) {
[16:12:53.893]                           computeRestarts <- base::computeRestarts
[16:12:53.893]                           grepl <- base::grepl
[16:12:53.893]                           restarts <- computeRestarts(cond)
[16:12:53.893]                           for (restart in restarts) {
[16:12:53.893]                             name <- restart$name
[16:12:53.893]                             if (is.null(name)) 
[16:12:53.893]                               next
[16:12:53.893]                             if (!grepl(pattern, name)) 
[16:12:53.893]                               next
[16:12:53.893]                             invokeRestart(restart)
[16:12:53.893]                             muffled <- TRUE
[16:12:53.893]                             break
[16:12:53.893]                           }
[16:12:53.893]                         }
[16:12:53.893]                       }
[16:12:53.893]                       invisible(muffled)
[16:12:53.893]                     }
[16:12:53.893]                     muffleCondition(cond, pattern = "^muffle")
[16:12:53.893]                   }
[16:12:53.893]                 }
[16:12:53.893]             }
[16:12:53.893]         }))
[16:12:53.893]     }, error = function(ex) {
[16:12:53.893]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:53.893]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:53.893]                 ...future.rng), started = ...future.startTime, 
[16:12:53.893]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:53.893]             version = "1.8"), class = "FutureResult")
[16:12:53.893]     }, finally = {
[16:12:53.893]         if (!identical(...future.workdir, getwd())) 
[16:12:53.893]             setwd(...future.workdir)
[16:12:53.893]         {
[16:12:53.893]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:53.893]                 ...future.oldOptions$nwarnings <- NULL
[16:12:53.893]             }
[16:12:53.893]             base::options(...future.oldOptions)
[16:12:53.893]             if (.Platform$OS.type == "windows") {
[16:12:53.893]                 old_names <- names(...future.oldEnvVars)
[16:12:53.893]                 envs <- base::Sys.getenv()
[16:12:53.893]                 names <- names(envs)
[16:12:53.893]                 common <- intersect(names, old_names)
[16:12:53.893]                 added <- setdiff(names, old_names)
[16:12:53.893]                 removed <- setdiff(old_names, names)
[16:12:53.893]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:53.893]                   envs[common]]
[16:12:53.893]                 NAMES <- toupper(changed)
[16:12:53.893]                 args <- list()
[16:12:53.893]                 for (kk in seq_along(NAMES)) {
[16:12:53.893]                   name <- changed[[kk]]
[16:12:53.893]                   NAME <- NAMES[[kk]]
[16:12:53.893]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.893]                     next
[16:12:53.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:53.893]                 }
[16:12:53.893]                 NAMES <- toupper(added)
[16:12:53.893]                 for (kk in seq_along(NAMES)) {
[16:12:53.893]                   name <- added[[kk]]
[16:12:53.893]                   NAME <- NAMES[[kk]]
[16:12:53.893]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.893]                     next
[16:12:53.893]                   args[[name]] <- ""
[16:12:53.893]                 }
[16:12:53.893]                 NAMES <- toupper(removed)
[16:12:53.893]                 for (kk in seq_along(NAMES)) {
[16:12:53.893]                   name <- removed[[kk]]
[16:12:53.893]                   NAME <- NAMES[[kk]]
[16:12:53.893]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.893]                     next
[16:12:53.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:53.893]                 }
[16:12:53.893]                 if (length(args) > 0) 
[16:12:53.893]                   base::do.call(base::Sys.setenv, args = args)
[16:12:53.893]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:53.893]             }
[16:12:53.893]             else {
[16:12:53.893]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:53.893]             }
[16:12:53.893]             {
[16:12:53.893]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:53.893]                   0L) {
[16:12:53.893]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:53.893]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:53.893]                   base::options(opts)
[16:12:53.893]                 }
[16:12:53.893]                 {
[16:12:53.893]                   {
[16:12:53.893]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:53.893]                     NULL
[16:12:53.893]                   }
[16:12:53.893]                   options(future.plan = NULL)
[16:12:53.893]                   if (is.na(NA_character_)) 
[16:12:53.893]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:53.893]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:53.893]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:53.893]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:53.893]                     envir = parent.frame()) 
[16:12:53.893]                   {
[16:12:53.893]                     if (is.function(workers)) 
[16:12:53.893]                       workers <- workers()
[16:12:53.893]                     workers <- structure(as.integer(workers), 
[16:12:53.893]                       class = class(workers))
[16:12:53.893]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:53.893]                       workers >= 1)
[16:12:53.893]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:53.893]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:53.893]                     }
[16:12:53.893]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:53.893]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:53.893]                       envir = envir)
[16:12:53.893]                     if (!future$lazy) 
[16:12:53.893]                       future <- run(future)
[16:12:53.893]                     invisible(future)
[16:12:53.893]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:53.893]                 }
[16:12:53.893]             }
[16:12:53.893]         }
[16:12:53.893]     })
[16:12:53.893]     if (TRUE) {
[16:12:53.893]         base::sink(type = "output", split = FALSE)
[16:12:53.893]         if (TRUE) {
[16:12:53.893]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:53.893]         }
[16:12:53.893]         else {
[16:12:53.893]             ...future.result["stdout"] <- base::list(NULL)
[16:12:53.893]         }
[16:12:53.893]         base::close(...future.stdout)
[16:12:53.893]         ...future.stdout <- NULL
[16:12:53.893]     }
[16:12:53.893]     ...future.result$conditions <- ...future.conditions
[16:12:53.893]     ...future.result$finished <- base::Sys.time()
[16:12:53.893]     ...future.result
[16:12:53.893] }
[16:12:53.895] Poll #1 (0): usedNodes() = 2, workers = 2
[16:12:53.906] receiveMessageFromWorker() for ClusterFuture ...
[16:12:53.906] - Validating connection of MultisessionFuture
[16:12:53.906] - received message: FutureResult
[16:12:53.906] - Received FutureResult
[16:12:53.906] - Erased future from FutureRegistry
[16:12:53.906] result() for ClusterFuture ...
[16:12:53.907] - result already collected: FutureResult
[16:12:53.907] result() for ClusterFuture ... done
[16:12:53.907] signalConditions() ...
[16:12:53.907]  - include = ‘immediateCondition’
[16:12:53.907]  - exclude = 
[16:12:53.907]  - resignal = FALSE
[16:12:53.907]  - Number of conditions: 1
[16:12:53.907] signalConditions() ... done
[16:12:53.907] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:53.907] result() for ClusterFuture ...
[16:12:53.907] - result already collected: FutureResult
[16:12:53.908] result() for ClusterFuture ... done
[16:12:53.908] result() for ClusterFuture ...
[16:12:53.908] - result already collected: FutureResult
[16:12:53.908] result() for ClusterFuture ... done
[16:12:53.908] signalConditions() ...
[16:12:53.908]  - include = ‘immediateCondition’
[16:12:53.908]  - exclude = 
[16:12:53.908]  - resignal = FALSE
[16:12:53.908]  - Number of conditions: 1
[16:12:53.908] signalConditions() ... done
[16:12:53.909] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[16:12:53.909] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[16:12:53.910] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[16:12:53.910] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[16:12:53.910] MultisessionFuture started
[16:12:53.910] - Launch lazy future ... done
[16:12:53.911] run() for ‘MultisessionFuture’ ... done
[16:12:53.911] result() for ClusterFuture ...
[16:12:53.911] receiveMessageFromWorker() for ClusterFuture ...
[16:12:53.911] - Validating connection of MultisessionFuture
[16:12:53.957] - received message: FutureResult
[16:12:53.957] - Received FutureResult
[16:12:53.957] - Erased future from FutureRegistry
[16:12:53.957] result() for ClusterFuture ...
[16:12:53.957] - result already collected: FutureResult
[16:12:53.958] result() for ClusterFuture ... done
[16:12:53.958] signalConditions() ...
[16:12:53.958]  - include = ‘immediateCondition’
[16:12:53.958]  - exclude = 
[16:12:53.958]  - resignal = FALSE
[16:12:53.958]  - Number of conditions: 1
[16:12:53.958] signalConditions() ... done
[16:12:53.958] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:53.958] result() for ClusterFuture ... done
[16:12:53.958] result() for ClusterFuture ...
[16:12:53.958] - result already collected: FutureResult
[16:12:53.959] result() for ClusterFuture ... done
[16:12:53.959] signalConditions() ...
[16:12:53.959]  - include = ‘immediateCondition’
[16:12:53.959]  - exclude = 
[16:12:53.959]  - resignal = FALSE
[16:12:53.959]  - Number of conditions: 1
[16:12:53.959] signalConditions() ... done
[16:12:53.959] Future state: ‘finished’
[16:12:53.959] result() for ClusterFuture ...
[16:12:53.959] - result already collected: FutureResult
[16:12:53.959] result() for ClusterFuture ... done
[16:12:53.960] signalConditions() ...
[16:12:53.960]  - include = ‘condition’
[16:12:53.960]  - exclude = ‘immediateCondition’
[16:12:53.960]  - resignal = TRUE
[16:12:53.960]  - Number of conditions: 1
[16:12:53.960]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:12:53.960] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2729ef2608da" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-06 16:12:53"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:53.974] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:53.974] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:53.975] 
[16:12:53.975] Searching for globals ... DONE
[16:12:53.975] - globals: [0] <none>
[16:12:53.975] getGlobalsAndPackages() ... DONE
[16:12:53.975] run() for ‘Future’ ...
[16:12:53.975] - state: ‘created’
[16:12:53.975] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:53.990] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:53.990] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:53.990]   - Field: ‘node’
[16:12:53.990]   - Field: ‘label’
[16:12:53.991]   - Field: ‘local’
[16:12:53.991]   - Field: ‘owner’
[16:12:53.991]   - Field: ‘envir’
[16:12:53.991]   - Field: ‘workers’
[16:12:53.991]   - Field: ‘packages’
[16:12:53.991]   - Field: ‘gc’
[16:12:53.991]   - Field: ‘conditions’
[16:12:53.991]   - Field: ‘persistent’
[16:12:53.991]   - Field: ‘expr’
[16:12:53.991]   - Field: ‘uuid’
[16:12:53.991]   - Field: ‘seed’
[16:12:53.992]   - Field: ‘version’
[16:12:53.992]   - Field: ‘result’
[16:12:53.992]   - Field: ‘asynchronous’
[16:12:53.992]   - Field: ‘calls’
[16:12:53.992]   - Field: ‘globals’
[16:12:53.992]   - Field: ‘stdout’
[16:12:53.992]   - Field: ‘earlySignal’
[16:12:53.992]   - Field: ‘lazy’
[16:12:53.992]   - Field: ‘state’
[16:12:53.992] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:53.993] - Launch lazy future ...
[16:12:53.993] Packages needed by the future expression (n = 0): <none>
[16:12:53.993] Packages needed by future strategies (n = 0): <none>
[16:12:53.993] {
[16:12:53.993]     {
[16:12:53.993]         {
[16:12:53.993]             ...future.startTime <- base::Sys.time()
[16:12:53.993]             {
[16:12:53.993]                 {
[16:12:53.993]                   {
[16:12:53.993]                     {
[16:12:53.993]                       base::local({
[16:12:53.993]                         has_future <- base::requireNamespace("future", 
[16:12:53.993]                           quietly = TRUE)
[16:12:53.993]                         if (has_future) {
[16:12:53.993]                           ns <- base::getNamespace("future")
[16:12:53.993]                           version <- ns[[".package"]][["version"]]
[16:12:53.993]                           if (is.null(version)) 
[16:12:53.993]                             version <- utils::packageVersion("future")
[16:12:53.993]                         }
[16:12:53.993]                         else {
[16:12:53.993]                           version <- NULL
[16:12:53.993]                         }
[16:12:53.993]                         if (!has_future || version < "1.8.0") {
[16:12:53.993]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:53.993]                             "", base::R.version$version.string), 
[16:12:53.993]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:53.993]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:53.993]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:53.993]                               "release", "version")], collapse = " "), 
[16:12:53.993]                             hostname = base::Sys.info()[["nodename"]])
[16:12:53.993]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:53.993]                             info)
[16:12:53.993]                           info <- base::paste(info, collapse = "; ")
[16:12:53.993]                           if (!has_future) {
[16:12:53.993]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:53.993]                               info)
[16:12:53.993]                           }
[16:12:53.993]                           else {
[16:12:53.993]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:53.993]                               info, version)
[16:12:53.993]                           }
[16:12:53.993]                           base::stop(msg)
[16:12:53.993]                         }
[16:12:53.993]                       })
[16:12:53.993]                     }
[16:12:53.993]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:53.993]                     base::options(mc.cores = 1L)
[16:12:53.993]                   }
[16:12:53.993]                   options(future.plan = NULL)
[16:12:53.993]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:53.993]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:53.993]                 }
[16:12:53.993]                 ...future.workdir <- getwd()
[16:12:53.993]             }
[16:12:53.993]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:53.993]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:53.993]         }
[16:12:53.993]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:53.993]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:53.993]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:53.993]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:53.993]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:53.993]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:53.993]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:53.993]             base::names(...future.oldOptions))
[16:12:53.993]     }
[16:12:53.993]     if (FALSE) {
[16:12:53.993]     }
[16:12:53.993]     else {
[16:12:53.993]         if (TRUE) {
[16:12:53.993]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:53.993]                 open = "w")
[16:12:53.993]         }
[16:12:53.993]         else {
[16:12:53.993]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:53.993]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:53.993]         }
[16:12:53.993]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:53.993]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:53.993]             base::sink(type = "output", split = FALSE)
[16:12:53.993]             base::close(...future.stdout)
[16:12:53.993]         }, add = TRUE)
[16:12:53.993]     }
[16:12:53.993]     ...future.frame <- base::sys.nframe()
[16:12:53.993]     ...future.conditions <- base::list()
[16:12:53.993]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:53.993]     if (FALSE) {
[16:12:53.993]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:53.993]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:53.993]     }
[16:12:53.993]     ...future.result <- base::tryCatch({
[16:12:53.993]         base::withCallingHandlers({
[16:12:53.993]             ...future.value <- base::withVisible(base::local({
[16:12:53.993]                 ...future.makeSendCondition <- local({
[16:12:53.993]                   sendCondition <- NULL
[16:12:53.993]                   function(frame = 1L) {
[16:12:53.993]                     if (is.function(sendCondition)) 
[16:12:53.993]                       return(sendCondition)
[16:12:53.993]                     ns <- getNamespace("parallel")
[16:12:53.993]                     if (exists("sendData", mode = "function", 
[16:12:53.993]                       envir = ns)) {
[16:12:53.993]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:53.993]                         envir = ns)
[16:12:53.993]                       envir <- sys.frame(frame)
[16:12:53.993]                       master <- NULL
[16:12:53.993]                       while (!identical(envir, .GlobalEnv) && 
[16:12:53.993]                         !identical(envir, emptyenv())) {
[16:12:53.993]                         if (exists("master", mode = "list", envir = envir, 
[16:12:53.993]                           inherits = FALSE)) {
[16:12:53.993]                           master <- get("master", mode = "list", 
[16:12:53.993]                             envir = envir, inherits = FALSE)
[16:12:53.993]                           if (inherits(master, c("SOCKnode", 
[16:12:53.993]                             "SOCK0node"))) {
[16:12:53.993]                             sendCondition <<- function(cond) {
[16:12:53.993]                               data <- list(type = "VALUE", value = cond, 
[16:12:53.993]                                 success = TRUE)
[16:12:53.993]                               parallel_sendData(master, data)
[16:12:53.993]                             }
[16:12:53.993]                             return(sendCondition)
[16:12:53.993]                           }
[16:12:53.993]                         }
[16:12:53.993]                         frame <- frame + 1L
[16:12:53.993]                         envir <- sys.frame(frame)
[16:12:53.993]                       }
[16:12:53.993]                     }
[16:12:53.993]                     sendCondition <<- function(cond) NULL
[16:12:53.993]                   }
[16:12:53.993]                 })
[16:12:53.993]                 withCallingHandlers({
[16:12:53.993]                   1
[16:12:53.993]                 }, immediateCondition = function(cond) {
[16:12:53.993]                   sendCondition <- ...future.makeSendCondition()
[16:12:53.993]                   sendCondition(cond)
[16:12:53.993]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.993]                   {
[16:12:53.993]                     inherits <- base::inherits
[16:12:53.993]                     invokeRestart <- base::invokeRestart
[16:12:53.993]                     is.null <- base::is.null
[16:12:53.993]                     muffled <- FALSE
[16:12:53.993]                     if (inherits(cond, "message")) {
[16:12:53.993]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:53.993]                       if (muffled) 
[16:12:53.993]                         invokeRestart("muffleMessage")
[16:12:53.993]                     }
[16:12:53.993]                     else if (inherits(cond, "warning")) {
[16:12:53.993]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:53.993]                       if (muffled) 
[16:12:53.993]                         invokeRestart("muffleWarning")
[16:12:53.993]                     }
[16:12:53.993]                     else if (inherits(cond, "condition")) {
[16:12:53.993]                       if (!is.null(pattern)) {
[16:12:53.993]                         computeRestarts <- base::computeRestarts
[16:12:53.993]                         grepl <- base::grepl
[16:12:53.993]                         restarts <- computeRestarts(cond)
[16:12:53.993]                         for (restart in restarts) {
[16:12:53.993]                           name <- restart$name
[16:12:53.993]                           if (is.null(name)) 
[16:12:53.993]                             next
[16:12:53.993]                           if (!grepl(pattern, name)) 
[16:12:53.993]                             next
[16:12:53.993]                           invokeRestart(restart)
[16:12:53.993]                           muffled <- TRUE
[16:12:53.993]                           break
[16:12:53.993]                         }
[16:12:53.993]                       }
[16:12:53.993]                     }
[16:12:53.993]                     invisible(muffled)
[16:12:53.993]                   }
[16:12:53.993]                   muffleCondition(cond)
[16:12:53.993]                 })
[16:12:53.993]             }))
[16:12:53.993]             future::FutureResult(value = ...future.value$value, 
[16:12:53.993]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:53.993]                   ...future.rng), globalenv = if (FALSE) 
[16:12:53.993]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:53.993]                     ...future.globalenv.names))
[16:12:53.993]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:53.993]         }, condition = base::local({
[16:12:53.993]             c <- base::c
[16:12:53.993]             inherits <- base::inherits
[16:12:53.993]             invokeRestart <- base::invokeRestart
[16:12:53.993]             length <- base::length
[16:12:53.993]             list <- base::list
[16:12:53.993]             seq.int <- base::seq.int
[16:12:53.993]             signalCondition <- base::signalCondition
[16:12:53.993]             sys.calls <- base::sys.calls
[16:12:53.993]             `[[` <- base::`[[`
[16:12:53.993]             `+` <- base::`+`
[16:12:53.993]             `<<-` <- base::`<<-`
[16:12:53.993]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:53.993]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:53.993]                   3L)]
[16:12:53.993]             }
[16:12:53.993]             function(cond) {
[16:12:53.993]                 is_error <- inherits(cond, "error")
[16:12:53.993]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:53.993]                   NULL)
[16:12:53.993]                 if (is_error) {
[16:12:53.993]                   sessionInformation <- function() {
[16:12:53.993]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:53.993]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:53.993]                       search = base::search(), system = base::Sys.info())
[16:12:53.993]                   }
[16:12:53.993]                   ...future.conditions[[length(...future.conditions) + 
[16:12:53.993]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:53.993]                     cond$call), session = sessionInformation(), 
[16:12:53.993]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:53.993]                   signalCondition(cond)
[16:12:53.993]                 }
[16:12:53.993]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:53.993]                 "immediateCondition"))) {
[16:12:53.993]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:53.993]                   ...future.conditions[[length(...future.conditions) + 
[16:12:53.993]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:53.993]                   if (TRUE && !signal) {
[16:12:53.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.993]                     {
[16:12:53.993]                       inherits <- base::inherits
[16:12:53.993]                       invokeRestart <- base::invokeRestart
[16:12:53.993]                       is.null <- base::is.null
[16:12:53.993]                       muffled <- FALSE
[16:12:53.993]                       if (inherits(cond, "message")) {
[16:12:53.993]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:53.993]                         if (muffled) 
[16:12:53.993]                           invokeRestart("muffleMessage")
[16:12:53.993]                       }
[16:12:53.993]                       else if (inherits(cond, "warning")) {
[16:12:53.993]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:53.993]                         if (muffled) 
[16:12:53.993]                           invokeRestart("muffleWarning")
[16:12:53.993]                       }
[16:12:53.993]                       else if (inherits(cond, "condition")) {
[16:12:53.993]                         if (!is.null(pattern)) {
[16:12:53.993]                           computeRestarts <- base::computeRestarts
[16:12:53.993]                           grepl <- base::grepl
[16:12:53.993]                           restarts <- computeRestarts(cond)
[16:12:53.993]                           for (restart in restarts) {
[16:12:53.993]                             name <- restart$name
[16:12:53.993]                             if (is.null(name)) 
[16:12:53.993]                               next
[16:12:53.993]                             if (!grepl(pattern, name)) 
[16:12:53.993]                               next
[16:12:53.993]                             invokeRestart(restart)
[16:12:53.993]                             muffled <- TRUE
[16:12:53.993]                             break
[16:12:53.993]                           }
[16:12:53.993]                         }
[16:12:53.993]                       }
[16:12:53.993]                       invisible(muffled)
[16:12:53.993]                     }
[16:12:53.993]                     muffleCondition(cond, pattern = "^muffle")
[16:12:53.993]                   }
[16:12:53.993]                 }
[16:12:53.993]                 else {
[16:12:53.993]                   if (TRUE) {
[16:12:53.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:53.993]                     {
[16:12:53.993]                       inherits <- base::inherits
[16:12:53.993]                       invokeRestart <- base::invokeRestart
[16:12:53.993]                       is.null <- base::is.null
[16:12:53.993]                       muffled <- FALSE
[16:12:53.993]                       if (inherits(cond, "message")) {
[16:12:53.993]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:53.993]                         if (muffled) 
[16:12:53.993]                           invokeRestart("muffleMessage")
[16:12:53.993]                       }
[16:12:53.993]                       else if (inherits(cond, "warning")) {
[16:12:53.993]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:53.993]                         if (muffled) 
[16:12:53.993]                           invokeRestart("muffleWarning")
[16:12:53.993]                       }
[16:12:53.993]                       else if (inherits(cond, "condition")) {
[16:12:53.993]                         if (!is.null(pattern)) {
[16:12:53.993]                           computeRestarts <- base::computeRestarts
[16:12:53.993]                           grepl <- base::grepl
[16:12:53.993]                           restarts <- computeRestarts(cond)
[16:12:53.993]                           for (restart in restarts) {
[16:12:53.993]                             name <- restart$name
[16:12:53.993]                             if (is.null(name)) 
[16:12:53.993]                               next
[16:12:53.993]                             if (!grepl(pattern, name)) 
[16:12:53.993]                               next
[16:12:53.993]                             invokeRestart(restart)
[16:12:53.993]                             muffled <- TRUE
[16:12:53.993]                             break
[16:12:53.993]                           }
[16:12:53.993]                         }
[16:12:53.993]                       }
[16:12:53.993]                       invisible(muffled)
[16:12:53.993]                     }
[16:12:53.993]                     muffleCondition(cond, pattern = "^muffle")
[16:12:53.993]                   }
[16:12:53.993]                 }
[16:12:53.993]             }
[16:12:53.993]         }))
[16:12:53.993]     }, error = function(ex) {
[16:12:53.993]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:53.993]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:53.993]                 ...future.rng), started = ...future.startTime, 
[16:12:53.993]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:53.993]             version = "1.8"), class = "FutureResult")
[16:12:53.993]     }, finally = {
[16:12:53.993]         if (!identical(...future.workdir, getwd())) 
[16:12:53.993]             setwd(...future.workdir)
[16:12:53.993]         {
[16:12:53.993]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:53.993]                 ...future.oldOptions$nwarnings <- NULL
[16:12:53.993]             }
[16:12:53.993]             base::options(...future.oldOptions)
[16:12:53.993]             if (.Platform$OS.type == "windows") {
[16:12:53.993]                 old_names <- names(...future.oldEnvVars)
[16:12:53.993]                 envs <- base::Sys.getenv()
[16:12:53.993]                 names <- names(envs)
[16:12:53.993]                 common <- intersect(names, old_names)
[16:12:53.993]                 added <- setdiff(names, old_names)
[16:12:53.993]                 removed <- setdiff(old_names, names)
[16:12:53.993]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:53.993]                   envs[common]]
[16:12:53.993]                 NAMES <- toupper(changed)
[16:12:53.993]                 args <- list()
[16:12:53.993]                 for (kk in seq_along(NAMES)) {
[16:12:53.993]                   name <- changed[[kk]]
[16:12:53.993]                   NAME <- NAMES[[kk]]
[16:12:53.993]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.993]                     next
[16:12:53.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:53.993]                 }
[16:12:53.993]                 NAMES <- toupper(added)
[16:12:53.993]                 for (kk in seq_along(NAMES)) {
[16:12:53.993]                   name <- added[[kk]]
[16:12:53.993]                   NAME <- NAMES[[kk]]
[16:12:53.993]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.993]                     next
[16:12:53.993]                   args[[name]] <- ""
[16:12:53.993]                 }
[16:12:53.993]                 NAMES <- toupper(removed)
[16:12:53.993]                 for (kk in seq_along(NAMES)) {
[16:12:53.993]                   name <- removed[[kk]]
[16:12:53.993]                   NAME <- NAMES[[kk]]
[16:12:53.993]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:53.993]                     next
[16:12:53.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:53.993]                 }
[16:12:53.993]                 if (length(args) > 0) 
[16:12:53.993]                   base::do.call(base::Sys.setenv, args = args)
[16:12:53.993]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:53.993]             }
[16:12:53.993]             else {
[16:12:53.993]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:53.993]             }
[16:12:53.993]             {
[16:12:53.993]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:53.993]                   0L) {
[16:12:53.993]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:53.993]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:53.993]                   base::options(opts)
[16:12:53.993]                 }
[16:12:53.993]                 {
[16:12:53.993]                   {
[16:12:53.993]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:53.993]                     NULL
[16:12:53.993]                   }
[16:12:53.993]                   options(future.plan = NULL)
[16:12:53.993]                   if (is.na(NA_character_)) 
[16:12:53.993]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:53.993]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:53.993]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:53.993]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:53.993]                     envir = parent.frame()) 
[16:12:53.993]                   {
[16:12:53.993]                     if (is.function(workers)) 
[16:12:53.993]                       workers <- workers()
[16:12:53.993]                     workers <- structure(as.integer(workers), 
[16:12:53.993]                       class = class(workers))
[16:12:53.993]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:53.993]                       workers >= 1)
[16:12:53.993]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:53.993]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:53.993]                     }
[16:12:53.993]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:53.993]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:53.993]                       envir = envir)
[16:12:53.993]                     if (!future$lazy) 
[16:12:53.993]                       future <- run(future)
[16:12:53.993]                     invisible(future)
[16:12:53.993]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:53.993]                 }
[16:12:53.993]             }
[16:12:53.993]         }
[16:12:53.993]     })
[16:12:53.993]     if (TRUE) {
[16:12:53.993]         base::sink(type = "output", split = FALSE)
[16:12:53.993]         if (TRUE) {
[16:12:53.993]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:53.993]         }
[16:12:53.993]         else {
[16:12:53.993]             ...future.result["stdout"] <- base::list(NULL)
[16:12:53.993]         }
[16:12:53.993]         base::close(...future.stdout)
[16:12:53.993]         ...future.stdout <- NULL
[16:12:53.993]     }
[16:12:53.993]     ...future.result$conditions <- ...future.conditions
[16:12:53.993]     ...future.result$finished <- base::Sys.time()
[16:12:53.993]     ...future.result
[16:12:53.993] }
[16:12:53.996] MultisessionFuture started
[16:12:53.997] - Launch lazy future ... done
[16:12:53.997] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:53.997] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:53.997] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:53.998] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:53.998] Searching for globals ... DONE
[16:12:53.998] Resolving globals: TRUE
[16:12:53.998] Resolving any globals that are futures ...
[16:12:53.998] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:53.999] Resolving any globals that are futures ... DONE
[16:12:53.999] Resolving futures part of globals (recursively) ...
[16:12:53.999] resolve() on list ...
[16:12:53.999]  recursive: 99
[16:12:53.999]  length: 1
[16:12:53.999]  elements: ‘a’
[16:12:54.045] receiveMessageFromWorker() for ClusterFuture ...
[16:12:54.045] - Validating connection of MultisessionFuture
[16:12:54.045] - received message: FutureResult
[16:12:54.045] - Received FutureResult
[16:12:54.046] - Erased future from FutureRegistry
[16:12:54.046] result() for ClusterFuture ...
[16:12:54.046] - result already collected: FutureResult
[16:12:54.046] result() for ClusterFuture ... done
[16:12:54.046] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:54.046] Future #1
[16:12:54.046] result() for ClusterFuture ...
[16:12:54.046] - result already collected: FutureResult
[16:12:54.047] result() for ClusterFuture ... done
[16:12:54.047] result() for ClusterFuture ...
[16:12:54.047] - result already collected: FutureResult
[16:12:54.047] result() for ClusterFuture ... done
[16:12:54.047] A MultisessionFuture was resolved
[16:12:54.047]  length: 0 (resolved future 1)
[16:12:54.047] resolve() on list ... DONE
[16:12:54.047] - globals: [1] ‘a’
[16:12:54.047] Resolving futures part of globals (recursively) ... DONE
[16:12:54.048] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[16:12:54.049] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[16:12:54.049] - globals: [1] ‘a’
[16:12:54.049] - packages: [1] ‘future’
[16:12:54.049] getGlobalsAndPackages() ... DONE
[16:12:54.049] run() for ‘Future’ ...
[16:12:54.050] - state: ‘created’
[16:12:54.050] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:54.065] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:54.065] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:54.065]   - Field: ‘node’
[16:12:54.065]   - Field: ‘label’
[16:12:54.065]   - Field: ‘local’
[16:12:54.067]   - Field: ‘owner’
[16:12:54.067]   - Field: ‘envir’
[16:12:54.067]   - Field: ‘workers’
[16:12:54.067]   - Field: ‘packages’
[16:12:54.067]   - Field: ‘gc’
[16:12:54.067]   - Field: ‘conditions’
[16:12:54.068]   - Field: ‘persistent’
[16:12:54.068]   - Field: ‘expr’
[16:12:54.068]   - Field: ‘uuid’
[16:12:54.068]   - Field: ‘seed’
[16:12:54.068]   - Field: ‘version’
[16:12:54.068]   - Field: ‘result’
[16:12:54.068]   - Field: ‘asynchronous’
[16:12:54.068]   - Field: ‘calls’
[16:12:54.068]   - Field: ‘globals’
[16:12:54.068]   - Field: ‘stdout’
[16:12:54.068]   - Field: ‘earlySignal’
[16:12:54.069]   - Field: ‘lazy’
[16:12:54.069]   - Field: ‘state’
[16:12:54.069] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:54.069] - Launch lazy future ...
[16:12:54.069] Packages needed by the future expression (n = 1): ‘future’
[16:12:54.069] Packages needed by future strategies (n = 0): <none>
[16:12:54.070] {
[16:12:54.070]     {
[16:12:54.070]         {
[16:12:54.070]             ...future.startTime <- base::Sys.time()
[16:12:54.070]             {
[16:12:54.070]                 {
[16:12:54.070]                   {
[16:12:54.070]                     {
[16:12:54.070]                       {
[16:12:54.070]                         base::local({
[16:12:54.070]                           has_future <- base::requireNamespace("future", 
[16:12:54.070]                             quietly = TRUE)
[16:12:54.070]                           if (has_future) {
[16:12:54.070]                             ns <- base::getNamespace("future")
[16:12:54.070]                             version <- ns[[".package"]][["version"]]
[16:12:54.070]                             if (is.null(version)) 
[16:12:54.070]                               version <- utils::packageVersion("future")
[16:12:54.070]                           }
[16:12:54.070]                           else {
[16:12:54.070]                             version <- NULL
[16:12:54.070]                           }
[16:12:54.070]                           if (!has_future || version < "1.8.0") {
[16:12:54.070]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:54.070]                               "", base::R.version$version.string), 
[16:12:54.070]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:54.070]                                 base::R.version$platform, 8 * 
[16:12:54.070]                                   base::.Machine$sizeof.pointer), 
[16:12:54.070]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:54.070]                                 "release", "version")], collapse = " "), 
[16:12:54.070]                               hostname = base::Sys.info()[["nodename"]])
[16:12:54.070]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:54.070]                               info)
[16:12:54.070]                             info <- base::paste(info, collapse = "; ")
[16:12:54.070]                             if (!has_future) {
[16:12:54.070]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:54.070]                                 info)
[16:12:54.070]                             }
[16:12:54.070]                             else {
[16:12:54.070]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:54.070]                                 info, version)
[16:12:54.070]                             }
[16:12:54.070]                             base::stop(msg)
[16:12:54.070]                           }
[16:12:54.070]                         })
[16:12:54.070]                       }
[16:12:54.070]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:54.070]                       base::options(mc.cores = 1L)
[16:12:54.070]                     }
[16:12:54.070]                     base::local({
[16:12:54.070]                       for (pkg in "future") {
[16:12:54.070]                         base::loadNamespace(pkg)
[16:12:54.070]                         base::library(pkg, character.only = TRUE)
[16:12:54.070]                       }
[16:12:54.070]                     })
[16:12:54.070]                   }
[16:12:54.070]                   options(future.plan = NULL)
[16:12:54.070]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:54.070]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:54.070]                 }
[16:12:54.070]                 ...future.workdir <- getwd()
[16:12:54.070]             }
[16:12:54.070]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:54.070]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:54.070]         }
[16:12:54.070]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:54.070]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:54.070]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:54.070]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:54.070]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:54.070]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:54.070]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:54.070]             base::names(...future.oldOptions))
[16:12:54.070]     }
[16:12:54.070]     if (FALSE) {
[16:12:54.070]     }
[16:12:54.070]     else {
[16:12:54.070]         if (TRUE) {
[16:12:54.070]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:54.070]                 open = "w")
[16:12:54.070]         }
[16:12:54.070]         else {
[16:12:54.070]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:54.070]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:54.070]         }
[16:12:54.070]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:54.070]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:54.070]             base::sink(type = "output", split = FALSE)
[16:12:54.070]             base::close(...future.stdout)
[16:12:54.070]         }, add = TRUE)
[16:12:54.070]     }
[16:12:54.070]     ...future.frame <- base::sys.nframe()
[16:12:54.070]     ...future.conditions <- base::list()
[16:12:54.070]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:54.070]     if (FALSE) {
[16:12:54.070]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:54.070]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:54.070]     }
[16:12:54.070]     ...future.result <- base::tryCatch({
[16:12:54.070]         base::withCallingHandlers({
[16:12:54.070]             ...future.value <- base::withVisible(base::local({
[16:12:54.070]                 ...future.makeSendCondition <- local({
[16:12:54.070]                   sendCondition <- NULL
[16:12:54.070]                   function(frame = 1L) {
[16:12:54.070]                     if (is.function(sendCondition)) 
[16:12:54.070]                       return(sendCondition)
[16:12:54.070]                     ns <- getNamespace("parallel")
[16:12:54.070]                     if (exists("sendData", mode = "function", 
[16:12:54.070]                       envir = ns)) {
[16:12:54.070]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:54.070]                         envir = ns)
[16:12:54.070]                       envir <- sys.frame(frame)
[16:12:54.070]                       master <- NULL
[16:12:54.070]                       while (!identical(envir, .GlobalEnv) && 
[16:12:54.070]                         !identical(envir, emptyenv())) {
[16:12:54.070]                         if (exists("master", mode = "list", envir = envir, 
[16:12:54.070]                           inherits = FALSE)) {
[16:12:54.070]                           master <- get("master", mode = "list", 
[16:12:54.070]                             envir = envir, inherits = FALSE)
[16:12:54.070]                           if (inherits(master, c("SOCKnode", 
[16:12:54.070]                             "SOCK0node"))) {
[16:12:54.070]                             sendCondition <<- function(cond) {
[16:12:54.070]                               data <- list(type = "VALUE", value = cond, 
[16:12:54.070]                                 success = TRUE)
[16:12:54.070]                               parallel_sendData(master, data)
[16:12:54.070]                             }
[16:12:54.070]                             return(sendCondition)
[16:12:54.070]                           }
[16:12:54.070]                         }
[16:12:54.070]                         frame <- frame + 1L
[16:12:54.070]                         envir <- sys.frame(frame)
[16:12:54.070]                       }
[16:12:54.070]                     }
[16:12:54.070]                     sendCondition <<- function(cond) NULL
[16:12:54.070]                   }
[16:12:54.070]                 })
[16:12:54.070]                 withCallingHandlers({
[16:12:54.070]                   value(a) + 1
[16:12:54.070]                 }, immediateCondition = function(cond) {
[16:12:54.070]                   sendCondition <- ...future.makeSendCondition()
[16:12:54.070]                   sendCondition(cond)
[16:12:54.070]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.070]                   {
[16:12:54.070]                     inherits <- base::inherits
[16:12:54.070]                     invokeRestart <- base::invokeRestart
[16:12:54.070]                     is.null <- base::is.null
[16:12:54.070]                     muffled <- FALSE
[16:12:54.070]                     if (inherits(cond, "message")) {
[16:12:54.070]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:54.070]                       if (muffled) 
[16:12:54.070]                         invokeRestart("muffleMessage")
[16:12:54.070]                     }
[16:12:54.070]                     else if (inherits(cond, "warning")) {
[16:12:54.070]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:54.070]                       if (muffled) 
[16:12:54.070]                         invokeRestart("muffleWarning")
[16:12:54.070]                     }
[16:12:54.070]                     else if (inherits(cond, "condition")) {
[16:12:54.070]                       if (!is.null(pattern)) {
[16:12:54.070]                         computeRestarts <- base::computeRestarts
[16:12:54.070]                         grepl <- base::grepl
[16:12:54.070]                         restarts <- computeRestarts(cond)
[16:12:54.070]                         for (restart in restarts) {
[16:12:54.070]                           name <- restart$name
[16:12:54.070]                           if (is.null(name)) 
[16:12:54.070]                             next
[16:12:54.070]                           if (!grepl(pattern, name)) 
[16:12:54.070]                             next
[16:12:54.070]                           invokeRestart(restart)
[16:12:54.070]                           muffled <- TRUE
[16:12:54.070]                           break
[16:12:54.070]                         }
[16:12:54.070]                       }
[16:12:54.070]                     }
[16:12:54.070]                     invisible(muffled)
[16:12:54.070]                   }
[16:12:54.070]                   muffleCondition(cond)
[16:12:54.070]                 })
[16:12:54.070]             }))
[16:12:54.070]             future::FutureResult(value = ...future.value$value, 
[16:12:54.070]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:54.070]                   ...future.rng), globalenv = if (FALSE) 
[16:12:54.070]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:54.070]                     ...future.globalenv.names))
[16:12:54.070]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:54.070]         }, condition = base::local({
[16:12:54.070]             c <- base::c
[16:12:54.070]             inherits <- base::inherits
[16:12:54.070]             invokeRestart <- base::invokeRestart
[16:12:54.070]             length <- base::length
[16:12:54.070]             list <- base::list
[16:12:54.070]             seq.int <- base::seq.int
[16:12:54.070]             signalCondition <- base::signalCondition
[16:12:54.070]             sys.calls <- base::sys.calls
[16:12:54.070]             `[[` <- base::`[[`
[16:12:54.070]             `+` <- base::`+`
[16:12:54.070]             `<<-` <- base::`<<-`
[16:12:54.070]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:54.070]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:54.070]                   3L)]
[16:12:54.070]             }
[16:12:54.070]             function(cond) {
[16:12:54.070]                 is_error <- inherits(cond, "error")
[16:12:54.070]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:54.070]                   NULL)
[16:12:54.070]                 if (is_error) {
[16:12:54.070]                   sessionInformation <- function() {
[16:12:54.070]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:54.070]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:54.070]                       search = base::search(), system = base::Sys.info())
[16:12:54.070]                   }
[16:12:54.070]                   ...future.conditions[[length(...future.conditions) + 
[16:12:54.070]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:54.070]                     cond$call), session = sessionInformation(), 
[16:12:54.070]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:54.070]                   signalCondition(cond)
[16:12:54.070]                 }
[16:12:54.070]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:54.070]                 "immediateCondition"))) {
[16:12:54.070]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:54.070]                   ...future.conditions[[length(...future.conditions) + 
[16:12:54.070]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:54.070]                   if (TRUE && !signal) {
[16:12:54.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.070]                     {
[16:12:54.070]                       inherits <- base::inherits
[16:12:54.070]                       invokeRestart <- base::invokeRestart
[16:12:54.070]                       is.null <- base::is.null
[16:12:54.070]                       muffled <- FALSE
[16:12:54.070]                       if (inherits(cond, "message")) {
[16:12:54.070]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:54.070]                         if (muffled) 
[16:12:54.070]                           invokeRestart("muffleMessage")
[16:12:54.070]                       }
[16:12:54.070]                       else if (inherits(cond, "warning")) {
[16:12:54.070]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:54.070]                         if (muffled) 
[16:12:54.070]                           invokeRestart("muffleWarning")
[16:12:54.070]                       }
[16:12:54.070]                       else if (inherits(cond, "condition")) {
[16:12:54.070]                         if (!is.null(pattern)) {
[16:12:54.070]                           computeRestarts <- base::computeRestarts
[16:12:54.070]                           grepl <- base::grepl
[16:12:54.070]                           restarts <- computeRestarts(cond)
[16:12:54.070]                           for (restart in restarts) {
[16:12:54.070]                             name <- restart$name
[16:12:54.070]                             if (is.null(name)) 
[16:12:54.070]                               next
[16:12:54.070]                             if (!grepl(pattern, name)) 
[16:12:54.070]                               next
[16:12:54.070]                             invokeRestart(restart)
[16:12:54.070]                             muffled <- TRUE
[16:12:54.070]                             break
[16:12:54.070]                           }
[16:12:54.070]                         }
[16:12:54.070]                       }
[16:12:54.070]                       invisible(muffled)
[16:12:54.070]                     }
[16:12:54.070]                     muffleCondition(cond, pattern = "^muffle")
[16:12:54.070]                   }
[16:12:54.070]                 }
[16:12:54.070]                 else {
[16:12:54.070]                   if (TRUE) {
[16:12:54.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.070]                     {
[16:12:54.070]                       inherits <- base::inherits
[16:12:54.070]                       invokeRestart <- base::invokeRestart
[16:12:54.070]                       is.null <- base::is.null
[16:12:54.070]                       muffled <- FALSE
[16:12:54.070]                       if (inherits(cond, "message")) {
[16:12:54.070]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:54.070]                         if (muffled) 
[16:12:54.070]                           invokeRestart("muffleMessage")
[16:12:54.070]                       }
[16:12:54.070]                       else if (inherits(cond, "warning")) {
[16:12:54.070]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:54.070]                         if (muffled) 
[16:12:54.070]                           invokeRestart("muffleWarning")
[16:12:54.070]                       }
[16:12:54.070]                       else if (inherits(cond, "condition")) {
[16:12:54.070]                         if (!is.null(pattern)) {
[16:12:54.070]                           computeRestarts <- base::computeRestarts
[16:12:54.070]                           grepl <- base::grepl
[16:12:54.070]                           restarts <- computeRestarts(cond)
[16:12:54.070]                           for (restart in restarts) {
[16:12:54.070]                             name <- restart$name
[16:12:54.070]                             if (is.null(name)) 
[16:12:54.070]                               next
[16:12:54.070]                             if (!grepl(pattern, name)) 
[16:12:54.070]                               next
[16:12:54.070]                             invokeRestart(restart)
[16:12:54.070]                             muffled <- TRUE
[16:12:54.070]                             break
[16:12:54.070]                           }
[16:12:54.070]                         }
[16:12:54.070]                       }
[16:12:54.070]                       invisible(muffled)
[16:12:54.070]                     }
[16:12:54.070]                     muffleCondition(cond, pattern = "^muffle")
[16:12:54.070]                   }
[16:12:54.070]                 }
[16:12:54.070]             }
[16:12:54.070]         }))
[16:12:54.070]     }, error = function(ex) {
[16:12:54.070]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:54.070]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:54.070]                 ...future.rng), started = ...future.startTime, 
[16:12:54.070]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:54.070]             version = "1.8"), class = "FutureResult")
[16:12:54.070]     }, finally = {
[16:12:54.070]         if (!identical(...future.workdir, getwd())) 
[16:12:54.070]             setwd(...future.workdir)
[16:12:54.070]         {
[16:12:54.070]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:54.070]                 ...future.oldOptions$nwarnings <- NULL
[16:12:54.070]             }
[16:12:54.070]             base::options(...future.oldOptions)
[16:12:54.070]             if (.Platform$OS.type == "windows") {
[16:12:54.070]                 old_names <- names(...future.oldEnvVars)
[16:12:54.070]                 envs <- base::Sys.getenv()
[16:12:54.070]                 names <- names(envs)
[16:12:54.070]                 common <- intersect(names, old_names)
[16:12:54.070]                 added <- setdiff(names, old_names)
[16:12:54.070]                 removed <- setdiff(old_names, names)
[16:12:54.070]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:54.070]                   envs[common]]
[16:12:54.070]                 NAMES <- toupper(changed)
[16:12:54.070]                 args <- list()
[16:12:54.070]                 for (kk in seq_along(NAMES)) {
[16:12:54.070]                   name <- changed[[kk]]
[16:12:54.070]                   NAME <- NAMES[[kk]]
[16:12:54.070]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.070]                     next
[16:12:54.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:54.070]                 }
[16:12:54.070]                 NAMES <- toupper(added)
[16:12:54.070]                 for (kk in seq_along(NAMES)) {
[16:12:54.070]                   name <- added[[kk]]
[16:12:54.070]                   NAME <- NAMES[[kk]]
[16:12:54.070]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.070]                     next
[16:12:54.070]                   args[[name]] <- ""
[16:12:54.070]                 }
[16:12:54.070]                 NAMES <- toupper(removed)
[16:12:54.070]                 for (kk in seq_along(NAMES)) {
[16:12:54.070]                   name <- removed[[kk]]
[16:12:54.070]                   NAME <- NAMES[[kk]]
[16:12:54.070]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.070]                     next
[16:12:54.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:54.070]                 }
[16:12:54.070]                 if (length(args) > 0) 
[16:12:54.070]                   base::do.call(base::Sys.setenv, args = args)
[16:12:54.070]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:54.070]             }
[16:12:54.070]             else {
[16:12:54.070]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:54.070]             }
[16:12:54.070]             {
[16:12:54.070]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:54.070]                   0L) {
[16:12:54.070]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:54.070]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:54.070]                   base::options(opts)
[16:12:54.070]                 }
[16:12:54.070]                 {
[16:12:54.070]                   {
[16:12:54.070]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:54.070]                     NULL
[16:12:54.070]                   }
[16:12:54.070]                   options(future.plan = NULL)
[16:12:54.070]                   if (is.na(NA_character_)) 
[16:12:54.070]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:54.070]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:54.070]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:54.070]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:54.070]                     envir = parent.frame()) 
[16:12:54.070]                   {
[16:12:54.070]                     if (is.function(workers)) 
[16:12:54.070]                       workers <- workers()
[16:12:54.070]                     workers <- structure(as.integer(workers), 
[16:12:54.070]                       class = class(workers))
[16:12:54.070]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:54.070]                       workers >= 1)
[16:12:54.070]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:54.070]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:54.070]                     }
[16:12:54.070]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:54.070]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:54.070]                       envir = envir)
[16:12:54.070]                     if (!future$lazy) 
[16:12:54.070]                       future <- run(future)
[16:12:54.070]                     invisible(future)
[16:12:54.070]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:54.070]                 }
[16:12:54.070]             }
[16:12:54.070]         }
[16:12:54.070]     })
[16:12:54.070]     if (TRUE) {
[16:12:54.070]         base::sink(type = "output", split = FALSE)
[16:12:54.070]         if (TRUE) {
[16:12:54.070]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:54.070]         }
[16:12:54.070]         else {
[16:12:54.070]             ...future.result["stdout"] <- base::list(NULL)
[16:12:54.070]         }
[16:12:54.070]         base::close(...future.stdout)
[16:12:54.070]         ...future.stdout <- NULL
[16:12:54.070]     }
[16:12:54.070]     ...future.result$conditions <- ...future.conditions
[16:12:54.070]     ...future.result$finished <- base::Sys.time()
[16:12:54.070]     ...future.result
[16:12:54.070] }
[16:12:54.072] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[16:12:54.073] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[16:12:54.124] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[16:12:54.124] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[16:12:54.125] MultisessionFuture started
[16:12:54.125] - Launch lazy future ... done
[16:12:54.125] run() for ‘MultisessionFuture’ ... done
[16:12:54.125] result() for ClusterFuture ...
[16:12:54.126] receiveMessageFromWorker() for ClusterFuture ...
[16:12:54.126] - Validating connection of MultisessionFuture
[16:12:54.177] - received message: FutureResult
[16:12:54.177] - Received FutureResult
[16:12:54.177] - Erased future from FutureRegistry
[16:12:54.177] result() for ClusterFuture ...
[16:12:54.178] - result already collected: FutureResult
[16:12:54.178] result() for ClusterFuture ... done
[16:12:54.178] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:54.178] result() for ClusterFuture ... done
[16:12:54.178] result() for ClusterFuture ...
[16:12:54.178] - result already collected: FutureResult
[16:12:54.178] result() for ClusterFuture ... done
value(b) = 2
[16:12:54.178] result() for ClusterFuture ...
[16:12:54.178] - result already collected: FutureResult
[16:12:54.179] result() for ClusterFuture ... done
[16:12:54.179] result() for ClusterFuture ...
[16:12:54.179] - result already collected: FutureResult
[16:12:54.179] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:54.179] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:54.179] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:54.180] 
[16:12:54.180] Searching for globals ... DONE
[16:12:54.180] - globals: [0] <none>
[16:12:54.180] getGlobalsAndPackages() ... DONE
[16:12:54.180] run() for ‘Future’ ...
[16:12:54.180] - state: ‘created’
[16:12:54.181] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:54.196] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:54.196] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:54.196]   - Field: ‘node’
[16:12:54.196]   - Field: ‘label’
[16:12:54.196]   - Field: ‘local’
[16:12:54.196]   - Field: ‘owner’
[16:12:54.196]   - Field: ‘envir’
[16:12:54.196]   - Field: ‘workers’
[16:12:54.196]   - Field: ‘packages’
[16:12:54.197]   - Field: ‘gc’
[16:12:54.197]   - Field: ‘conditions’
[16:12:54.197]   - Field: ‘persistent’
[16:12:54.197]   - Field: ‘expr’
[16:12:54.197]   - Field: ‘uuid’
[16:12:54.197]   - Field: ‘seed’
[16:12:54.197]   - Field: ‘version’
[16:12:54.197]   - Field: ‘result’
[16:12:54.197]   - Field: ‘asynchronous’
[16:12:54.197]   - Field: ‘calls’
[16:12:54.197]   - Field: ‘globals’
[16:12:54.198]   - Field: ‘stdout’
[16:12:54.198]   - Field: ‘earlySignal’
[16:12:54.198]   - Field: ‘lazy’
[16:12:54.198]   - Field: ‘state’
[16:12:54.198] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:54.198] - Launch lazy future ...
[16:12:54.198] Packages needed by the future expression (n = 0): <none>
[16:12:54.198] Packages needed by future strategies (n = 0): <none>
[16:12:54.199] {
[16:12:54.199]     {
[16:12:54.199]         {
[16:12:54.199]             ...future.startTime <- base::Sys.time()
[16:12:54.199]             {
[16:12:54.199]                 {
[16:12:54.199]                   {
[16:12:54.199]                     {
[16:12:54.199]                       base::local({
[16:12:54.199]                         has_future <- base::requireNamespace("future", 
[16:12:54.199]                           quietly = TRUE)
[16:12:54.199]                         if (has_future) {
[16:12:54.199]                           ns <- base::getNamespace("future")
[16:12:54.199]                           version <- ns[[".package"]][["version"]]
[16:12:54.199]                           if (is.null(version)) 
[16:12:54.199]                             version <- utils::packageVersion("future")
[16:12:54.199]                         }
[16:12:54.199]                         else {
[16:12:54.199]                           version <- NULL
[16:12:54.199]                         }
[16:12:54.199]                         if (!has_future || version < "1.8.0") {
[16:12:54.199]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:54.199]                             "", base::R.version$version.string), 
[16:12:54.199]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:54.199]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:54.199]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:54.199]                               "release", "version")], collapse = " "), 
[16:12:54.199]                             hostname = base::Sys.info()[["nodename"]])
[16:12:54.199]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:54.199]                             info)
[16:12:54.199]                           info <- base::paste(info, collapse = "; ")
[16:12:54.199]                           if (!has_future) {
[16:12:54.199]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:54.199]                               info)
[16:12:54.199]                           }
[16:12:54.199]                           else {
[16:12:54.199]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:54.199]                               info, version)
[16:12:54.199]                           }
[16:12:54.199]                           base::stop(msg)
[16:12:54.199]                         }
[16:12:54.199]                       })
[16:12:54.199]                     }
[16:12:54.199]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:54.199]                     base::options(mc.cores = 1L)
[16:12:54.199]                   }
[16:12:54.199]                   options(future.plan = NULL)
[16:12:54.199]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:54.199]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:54.199]                 }
[16:12:54.199]                 ...future.workdir <- getwd()
[16:12:54.199]             }
[16:12:54.199]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:54.199]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:54.199]         }
[16:12:54.199]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:54.199]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:54.199]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:54.199]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:54.199]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:54.199]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:54.199]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:54.199]             base::names(...future.oldOptions))
[16:12:54.199]     }
[16:12:54.199]     if (FALSE) {
[16:12:54.199]     }
[16:12:54.199]     else {
[16:12:54.199]         if (TRUE) {
[16:12:54.199]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:54.199]                 open = "w")
[16:12:54.199]         }
[16:12:54.199]         else {
[16:12:54.199]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:54.199]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:54.199]         }
[16:12:54.199]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:54.199]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:54.199]             base::sink(type = "output", split = FALSE)
[16:12:54.199]             base::close(...future.stdout)
[16:12:54.199]         }, add = TRUE)
[16:12:54.199]     }
[16:12:54.199]     ...future.frame <- base::sys.nframe()
[16:12:54.199]     ...future.conditions <- base::list()
[16:12:54.199]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:54.199]     if (FALSE) {
[16:12:54.199]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:54.199]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:54.199]     }
[16:12:54.199]     ...future.result <- base::tryCatch({
[16:12:54.199]         base::withCallingHandlers({
[16:12:54.199]             ...future.value <- base::withVisible(base::local({
[16:12:54.199]                 ...future.makeSendCondition <- local({
[16:12:54.199]                   sendCondition <- NULL
[16:12:54.199]                   function(frame = 1L) {
[16:12:54.199]                     if (is.function(sendCondition)) 
[16:12:54.199]                       return(sendCondition)
[16:12:54.199]                     ns <- getNamespace("parallel")
[16:12:54.199]                     if (exists("sendData", mode = "function", 
[16:12:54.199]                       envir = ns)) {
[16:12:54.199]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:54.199]                         envir = ns)
[16:12:54.199]                       envir <- sys.frame(frame)
[16:12:54.199]                       master <- NULL
[16:12:54.199]                       while (!identical(envir, .GlobalEnv) && 
[16:12:54.199]                         !identical(envir, emptyenv())) {
[16:12:54.199]                         if (exists("master", mode = "list", envir = envir, 
[16:12:54.199]                           inherits = FALSE)) {
[16:12:54.199]                           master <- get("master", mode = "list", 
[16:12:54.199]                             envir = envir, inherits = FALSE)
[16:12:54.199]                           if (inherits(master, c("SOCKnode", 
[16:12:54.199]                             "SOCK0node"))) {
[16:12:54.199]                             sendCondition <<- function(cond) {
[16:12:54.199]                               data <- list(type = "VALUE", value = cond, 
[16:12:54.199]                                 success = TRUE)
[16:12:54.199]                               parallel_sendData(master, data)
[16:12:54.199]                             }
[16:12:54.199]                             return(sendCondition)
[16:12:54.199]                           }
[16:12:54.199]                         }
[16:12:54.199]                         frame <- frame + 1L
[16:12:54.199]                         envir <- sys.frame(frame)
[16:12:54.199]                       }
[16:12:54.199]                     }
[16:12:54.199]                     sendCondition <<- function(cond) NULL
[16:12:54.199]                   }
[16:12:54.199]                 })
[16:12:54.199]                 withCallingHandlers({
[16:12:54.199]                   1
[16:12:54.199]                 }, immediateCondition = function(cond) {
[16:12:54.199]                   sendCondition <- ...future.makeSendCondition()
[16:12:54.199]                   sendCondition(cond)
[16:12:54.199]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.199]                   {
[16:12:54.199]                     inherits <- base::inherits
[16:12:54.199]                     invokeRestart <- base::invokeRestart
[16:12:54.199]                     is.null <- base::is.null
[16:12:54.199]                     muffled <- FALSE
[16:12:54.199]                     if (inherits(cond, "message")) {
[16:12:54.199]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:54.199]                       if (muffled) 
[16:12:54.199]                         invokeRestart("muffleMessage")
[16:12:54.199]                     }
[16:12:54.199]                     else if (inherits(cond, "warning")) {
[16:12:54.199]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:54.199]                       if (muffled) 
[16:12:54.199]                         invokeRestart("muffleWarning")
[16:12:54.199]                     }
[16:12:54.199]                     else if (inherits(cond, "condition")) {
[16:12:54.199]                       if (!is.null(pattern)) {
[16:12:54.199]                         computeRestarts <- base::computeRestarts
[16:12:54.199]                         grepl <- base::grepl
[16:12:54.199]                         restarts <- computeRestarts(cond)
[16:12:54.199]                         for (restart in restarts) {
[16:12:54.199]                           name <- restart$name
[16:12:54.199]                           if (is.null(name)) 
[16:12:54.199]                             next
[16:12:54.199]                           if (!grepl(pattern, name)) 
[16:12:54.199]                             next
[16:12:54.199]                           invokeRestart(restart)
[16:12:54.199]                           muffled <- TRUE
[16:12:54.199]                           break
[16:12:54.199]                         }
[16:12:54.199]                       }
[16:12:54.199]                     }
[16:12:54.199]                     invisible(muffled)
[16:12:54.199]                   }
[16:12:54.199]                   muffleCondition(cond)
[16:12:54.199]                 })
[16:12:54.199]             }))
[16:12:54.199]             future::FutureResult(value = ...future.value$value, 
[16:12:54.199]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:54.199]                   ...future.rng), globalenv = if (FALSE) 
[16:12:54.199]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:54.199]                     ...future.globalenv.names))
[16:12:54.199]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:54.199]         }, condition = base::local({
[16:12:54.199]             c <- base::c
[16:12:54.199]             inherits <- base::inherits
[16:12:54.199]             invokeRestart <- base::invokeRestart
[16:12:54.199]             length <- base::length
[16:12:54.199]             list <- base::list
[16:12:54.199]             seq.int <- base::seq.int
[16:12:54.199]             signalCondition <- base::signalCondition
[16:12:54.199]             sys.calls <- base::sys.calls
[16:12:54.199]             `[[` <- base::`[[`
[16:12:54.199]             `+` <- base::`+`
[16:12:54.199]             `<<-` <- base::`<<-`
[16:12:54.199]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:54.199]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:54.199]                   3L)]
[16:12:54.199]             }
[16:12:54.199]             function(cond) {
[16:12:54.199]                 is_error <- inherits(cond, "error")
[16:12:54.199]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:54.199]                   NULL)
[16:12:54.199]                 if (is_error) {
[16:12:54.199]                   sessionInformation <- function() {
[16:12:54.199]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:54.199]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:54.199]                       search = base::search(), system = base::Sys.info())
[16:12:54.199]                   }
[16:12:54.199]                   ...future.conditions[[length(...future.conditions) + 
[16:12:54.199]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:54.199]                     cond$call), session = sessionInformation(), 
[16:12:54.199]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:54.199]                   signalCondition(cond)
[16:12:54.199]                 }
[16:12:54.199]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:54.199]                 "immediateCondition"))) {
[16:12:54.199]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:54.199]                   ...future.conditions[[length(...future.conditions) + 
[16:12:54.199]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:54.199]                   if (TRUE && !signal) {
[16:12:54.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.199]                     {
[16:12:54.199]                       inherits <- base::inherits
[16:12:54.199]                       invokeRestart <- base::invokeRestart
[16:12:54.199]                       is.null <- base::is.null
[16:12:54.199]                       muffled <- FALSE
[16:12:54.199]                       if (inherits(cond, "message")) {
[16:12:54.199]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:54.199]                         if (muffled) 
[16:12:54.199]                           invokeRestart("muffleMessage")
[16:12:54.199]                       }
[16:12:54.199]                       else if (inherits(cond, "warning")) {
[16:12:54.199]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:54.199]                         if (muffled) 
[16:12:54.199]                           invokeRestart("muffleWarning")
[16:12:54.199]                       }
[16:12:54.199]                       else if (inherits(cond, "condition")) {
[16:12:54.199]                         if (!is.null(pattern)) {
[16:12:54.199]                           computeRestarts <- base::computeRestarts
[16:12:54.199]                           grepl <- base::grepl
[16:12:54.199]                           restarts <- computeRestarts(cond)
[16:12:54.199]                           for (restart in restarts) {
[16:12:54.199]                             name <- restart$name
[16:12:54.199]                             if (is.null(name)) 
[16:12:54.199]                               next
[16:12:54.199]                             if (!grepl(pattern, name)) 
[16:12:54.199]                               next
[16:12:54.199]                             invokeRestart(restart)
[16:12:54.199]                             muffled <- TRUE
[16:12:54.199]                             break
[16:12:54.199]                           }
[16:12:54.199]                         }
[16:12:54.199]                       }
[16:12:54.199]                       invisible(muffled)
[16:12:54.199]                     }
[16:12:54.199]                     muffleCondition(cond, pattern = "^muffle")
[16:12:54.199]                   }
[16:12:54.199]                 }
[16:12:54.199]                 else {
[16:12:54.199]                   if (TRUE) {
[16:12:54.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.199]                     {
[16:12:54.199]                       inherits <- base::inherits
[16:12:54.199]                       invokeRestart <- base::invokeRestart
[16:12:54.199]                       is.null <- base::is.null
[16:12:54.199]                       muffled <- FALSE
[16:12:54.199]                       if (inherits(cond, "message")) {
[16:12:54.199]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:54.199]                         if (muffled) 
[16:12:54.199]                           invokeRestart("muffleMessage")
[16:12:54.199]                       }
[16:12:54.199]                       else if (inherits(cond, "warning")) {
[16:12:54.199]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:54.199]                         if (muffled) 
[16:12:54.199]                           invokeRestart("muffleWarning")
[16:12:54.199]                       }
[16:12:54.199]                       else if (inherits(cond, "condition")) {
[16:12:54.199]                         if (!is.null(pattern)) {
[16:12:54.199]                           computeRestarts <- base::computeRestarts
[16:12:54.199]                           grepl <- base::grepl
[16:12:54.199]                           restarts <- computeRestarts(cond)
[16:12:54.199]                           for (restart in restarts) {
[16:12:54.199]                             name <- restart$name
[16:12:54.199]                             if (is.null(name)) 
[16:12:54.199]                               next
[16:12:54.199]                             if (!grepl(pattern, name)) 
[16:12:54.199]                               next
[16:12:54.199]                             invokeRestart(restart)
[16:12:54.199]                             muffled <- TRUE
[16:12:54.199]                             break
[16:12:54.199]                           }
[16:12:54.199]                         }
[16:12:54.199]                       }
[16:12:54.199]                       invisible(muffled)
[16:12:54.199]                     }
[16:12:54.199]                     muffleCondition(cond, pattern = "^muffle")
[16:12:54.199]                   }
[16:12:54.199]                 }
[16:12:54.199]             }
[16:12:54.199]         }))
[16:12:54.199]     }, error = function(ex) {
[16:12:54.199]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:54.199]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:54.199]                 ...future.rng), started = ...future.startTime, 
[16:12:54.199]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:54.199]             version = "1.8"), class = "FutureResult")
[16:12:54.199]     }, finally = {
[16:12:54.199]         if (!identical(...future.workdir, getwd())) 
[16:12:54.199]             setwd(...future.workdir)
[16:12:54.199]         {
[16:12:54.199]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:54.199]                 ...future.oldOptions$nwarnings <- NULL
[16:12:54.199]             }
[16:12:54.199]             base::options(...future.oldOptions)
[16:12:54.199]             if (.Platform$OS.type == "windows") {
[16:12:54.199]                 old_names <- names(...future.oldEnvVars)
[16:12:54.199]                 envs <- base::Sys.getenv()
[16:12:54.199]                 names <- names(envs)
[16:12:54.199]                 common <- intersect(names, old_names)
[16:12:54.199]                 added <- setdiff(names, old_names)
[16:12:54.199]                 removed <- setdiff(old_names, names)
[16:12:54.199]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:54.199]                   envs[common]]
[16:12:54.199]                 NAMES <- toupper(changed)
[16:12:54.199]                 args <- list()
[16:12:54.199]                 for (kk in seq_along(NAMES)) {
[16:12:54.199]                   name <- changed[[kk]]
[16:12:54.199]                   NAME <- NAMES[[kk]]
[16:12:54.199]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.199]                     next
[16:12:54.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:54.199]                 }
[16:12:54.199]                 NAMES <- toupper(added)
[16:12:54.199]                 for (kk in seq_along(NAMES)) {
[16:12:54.199]                   name <- added[[kk]]
[16:12:54.199]                   NAME <- NAMES[[kk]]
[16:12:54.199]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.199]                     next
[16:12:54.199]                   args[[name]] <- ""
[16:12:54.199]                 }
[16:12:54.199]                 NAMES <- toupper(removed)
[16:12:54.199]                 for (kk in seq_along(NAMES)) {
[16:12:54.199]                   name <- removed[[kk]]
[16:12:54.199]                   NAME <- NAMES[[kk]]
[16:12:54.199]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.199]                     next
[16:12:54.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:54.199]                 }
[16:12:54.199]                 if (length(args) > 0) 
[16:12:54.199]                   base::do.call(base::Sys.setenv, args = args)
[16:12:54.199]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:54.199]             }
[16:12:54.199]             else {
[16:12:54.199]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:54.199]             }
[16:12:54.199]             {
[16:12:54.199]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:54.199]                   0L) {
[16:12:54.199]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:54.199]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:54.199]                   base::options(opts)
[16:12:54.199]                 }
[16:12:54.199]                 {
[16:12:54.199]                   {
[16:12:54.199]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:54.199]                     NULL
[16:12:54.199]                   }
[16:12:54.199]                   options(future.plan = NULL)
[16:12:54.199]                   if (is.na(NA_character_)) 
[16:12:54.199]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:54.199]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:54.199]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:54.199]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:54.199]                     envir = parent.frame()) 
[16:12:54.199]                   {
[16:12:54.199]                     if (is.function(workers)) 
[16:12:54.199]                       workers <- workers()
[16:12:54.199]                     workers <- structure(as.integer(workers), 
[16:12:54.199]                       class = class(workers))
[16:12:54.199]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:54.199]                       workers >= 1)
[16:12:54.199]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:54.199]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:54.199]                     }
[16:12:54.199]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:54.199]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:54.199]                       envir = envir)
[16:12:54.199]                     if (!future$lazy) 
[16:12:54.199]                       future <- run(future)
[16:12:54.199]                     invisible(future)
[16:12:54.199]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:54.199]                 }
[16:12:54.199]             }
[16:12:54.199]         }
[16:12:54.199]     })
[16:12:54.199]     if (TRUE) {
[16:12:54.199]         base::sink(type = "output", split = FALSE)
[16:12:54.199]         if (TRUE) {
[16:12:54.199]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:54.199]         }
[16:12:54.199]         else {
[16:12:54.199]             ...future.result["stdout"] <- base::list(NULL)
[16:12:54.199]         }
[16:12:54.199]         base::close(...future.stdout)
[16:12:54.199]         ...future.stdout <- NULL
[16:12:54.199]     }
[16:12:54.199]     ...future.result$conditions <- ...future.conditions
[16:12:54.199]     ...future.result$finished <- base::Sys.time()
[16:12:54.199]     ...future.result
[16:12:54.199] }
[16:12:54.202] MultisessionFuture started
[16:12:54.202] - Launch lazy future ... done
[16:12:54.202] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:54.203] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:54.203] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:54.204] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:54.204] Searching for globals ... DONE
[16:12:54.204] Resolving globals: TRUE
[16:12:54.204] Resolving any globals that are futures ...
[16:12:54.204] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:54.204] Resolving any globals that are futures ... DONE
[16:12:54.205] Resolving futures part of globals (recursively) ...
[16:12:54.205] resolve() on list ...
[16:12:54.205]  recursive: 99
[16:12:54.205]  length: 1
[16:12:54.205]  elements: ‘a’
[16:12:54.249] receiveMessageFromWorker() for ClusterFuture ...
[16:12:54.249] - Validating connection of MultisessionFuture
[16:12:54.250] - received message: FutureResult
[16:12:54.250] - Received FutureResult
[16:12:54.250] - Erased future from FutureRegistry
[16:12:54.250] result() for ClusterFuture ...
[16:12:54.250] - result already collected: FutureResult
[16:12:54.250] result() for ClusterFuture ... done
[16:12:54.250] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:54.250] Future #1
[16:12:54.250] result() for ClusterFuture ...
[16:12:54.251] - result already collected: FutureResult
[16:12:54.251] result() for ClusterFuture ... done
[16:12:54.251] result() for ClusterFuture ...
[16:12:54.251] - result already collected: FutureResult
[16:12:54.251] result() for ClusterFuture ... done
[16:12:54.251] A MultisessionFuture was resolved
[16:12:54.251]  length: 0 (resolved future 1)
[16:12:54.251] resolve() on list ... DONE
[16:12:54.251] - globals: [1] ‘a’
[16:12:54.252] Resolving futures part of globals (recursively) ... DONE
[16:12:54.253] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[16:12:54.253] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[16:12:54.253] - globals: [1] ‘a’
[16:12:54.253] - packages: [1] ‘future’
[16:12:54.253] getGlobalsAndPackages() ... DONE
[16:12:54.254] run() for ‘Future’ ...
[16:12:54.254] - state: ‘created’
[16:12:54.254] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:54.268] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:54.269] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:54.269]   - Field: ‘node’
[16:12:54.269]   - Field: ‘label’
[16:12:54.269]   - Field: ‘local’
[16:12:54.269]   - Field: ‘owner’
[16:12:54.269]   - Field: ‘envir’
[16:12:54.269]   - Field: ‘workers’
[16:12:54.269]   - Field: ‘packages’
[16:12:54.269]   - Field: ‘gc’
[16:12:54.269]   - Field: ‘conditions’
[16:12:54.270]   - Field: ‘persistent’
[16:12:54.270]   - Field: ‘expr’
[16:12:54.270]   - Field: ‘uuid’
[16:12:54.270]   - Field: ‘seed’
[16:12:54.270]   - Field: ‘version’
[16:12:54.270]   - Field: ‘result’
[16:12:54.270]   - Field: ‘asynchronous’
[16:12:54.270]   - Field: ‘calls’
[16:12:54.270]   - Field: ‘globals’
[16:12:54.270]   - Field: ‘stdout’
[16:12:54.270]   - Field: ‘earlySignal’
[16:12:54.271]   - Field: ‘lazy’
[16:12:54.271]   - Field: ‘state’
[16:12:54.271] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:54.271] - Launch lazy future ...
[16:12:54.271] Packages needed by the future expression (n = 1): ‘future’
[16:12:54.271] Packages needed by future strategies (n = 0): <none>
[16:12:54.272] {
[16:12:54.272]     {
[16:12:54.272]         {
[16:12:54.272]             ...future.startTime <- base::Sys.time()
[16:12:54.272]             {
[16:12:54.272]                 {
[16:12:54.272]                   {
[16:12:54.272]                     {
[16:12:54.272]                       {
[16:12:54.272]                         base::local({
[16:12:54.272]                           has_future <- base::requireNamespace("future", 
[16:12:54.272]                             quietly = TRUE)
[16:12:54.272]                           if (has_future) {
[16:12:54.272]                             ns <- base::getNamespace("future")
[16:12:54.272]                             version <- ns[[".package"]][["version"]]
[16:12:54.272]                             if (is.null(version)) 
[16:12:54.272]                               version <- utils::packageVersion("future")
[16:12:54.272]                           }
[16:12:54.272]                           else {
[16:12:54.272]                             version <- NULL
[16:12:54.272]                           }
[16:12:54.272]                           if (!has_future || version < "1.8.0") {
[16:12:54.272]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:54.272]                               "", base::R.version$version.string), 
[16:12:54.272]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:54.272]                                 base::R.version$platform, 8 * 
[16:12:54.272]                                   base::.Machine$sizeof.pointer), 
[16:12:54.272]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:54.272]                                 "release", "version")], collapse = " "), 
[16:12:54.272]                               hostname = base::Sys.info()[["nodename"]])
[16:12:54.272]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:54.272]                               info)
[16:12:54.272]                             info <- base::paste(info, collapse = "; ")
[16:12:54.272]                             if (!has_future) {
[16:12:54.272]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:54.272]                                 info)
[16:12:54.272]                             }
[16:12:54.272]                             else {
[16:12:54.272]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:54.272]                                 info, version)
[16:12:54.272]                             }
[16:12:54.272]                             base::stop(msg)
[16:12:54.272]                           }
[16:12:54.272]                         })
[16:12:54.272]                       }
[16:12:54.272]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:54.272]                       base::options(mc.cores = 1L)
[16:12:54.272]                     }
[16:12:54.272]                     base::local({
[16:12:54.272]                       for (pkg in "future") {
[16:12:54.272]                         base::loadNamespace(pkg)
[16:12:54.272]                         base::library(pkg, character.only = TRUE)
[16:12:54.272]                       }
[16:12:54.272]                     })
[16:12:54.272]                   }
[16:12:54.272]                   options(future.plan = NULL)
[16:12:54.272]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:54.272]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:54.272]                 }
[16:12:54.272]                 ...future.workdir <- getwd()
[16:12:54.272]             }
[16:12:54.272]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:54.272]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:54.272]         }
[16:12:54.272]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:54.272]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:54.272]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:54.272]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:54.272]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:54.272]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:54.272]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:54.272]             base::names(...future.oldOptions))
[16:12:54.272]     }
[16:12:54.272]     if (FALSE) {
[16:12:54.272]     }
[16:12:54.272]     else {
[16:12:54.272]         if (TRUE) {
[16:12:54.272]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:54.272]                 open = "w")
[16:12:54.272]         }
[16:12:54.272]         else {
[16:12:54.272]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:54.272]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:54.272]         }
[16:12:54.272]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:54.272]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:54.272]             base::sink(type = "output", split = FALSE)
[16:12:54.272]             base::close(...future.stdout)
[16:12:54.272]         }, add = TRUE)
[16:12:54.272]     }
[16:12:54.272]     ...future.frame <- base::sys.nframe()
[16:12:54.272]     ...future.conditions <- base::list()
[16:12:54.272]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:54.272]     if (FALSE) {
[16:12:54.272]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:54.272]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:54.272]     }
[16:12:54.272]     ...future.result <- base::tryCatch({
[16:12:54.272]         base::withCallingHandlers({
[16:12:54.272]             ...future.value <- base::withVisible(base::local({
[16:12:54.272]                 ...future.makeSendCondition <- local({
[16:12:54.272]                   sendCondition <- NULL
[16:12:54.272]                   function(frame = 1L) {
[16:12:54.272]                     if (is.function(sendCondition)) 
[16:12:54.272]                       return(sendCondition)
[16:12:54.272]                     ns <- getNamespace("parallel")
[16:12:54.272]                     if (exists("sendData", mode = "function", 
[16:12:54.272]                       envir = ns)) {
[16:12:54.272]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:54.272]                         envir = ns)
[16:12:54.272]                       envir <- sys.frame(frame)
[16:12:54.272]                       master <- NULL
[16:12:54.272]                       while (!identical(envir, .GlobalEnv) && 
[16:12:54.272]                         !identical(envir, emptyenv())) {
[16:12:54.272]                         if (exists("master", mode = "list", envir = envir, 
[16:12:54.272]                           inherits = FALSE)) {
[16:12:54.272]                           master <- get("master", mode = "list", 
[16:12:54.272]                             envir = envir, inherits = FALSE)
[16:12:54.272]                           if (inherits(master, c("SOCKnode", 
[16:12:54.272]                             "SOCK0node"))) {
[16:12:54.272]                             sendCondition <<- function(cond) {
[16:12:54.272]                               data <- list(type = "VALUE", value = cond, 
[16:12:54.272]                                 success = TRUE)
[16:12:54.272]                               parallel_sendData(master, data)
[16:12:54.272]                             }
[16:12:54.272]                             return(sendCondition)
[16:12:54.272]                           }
[16:12:54.272]                         }
[16:12:54.272]                         frame <- frame + 1L
[16:12:54.272]                         envir <- sys.frame(frame)
[16:12:54.272]                       }
[16:12:54.272]                     }
[16:12:54.272]                     sendCondition <<- function(cond) NULL
[16:12:54.272]                   }
[16:12:54.272]                 })
[16:12:54.272]                 withCallingHandlers({
[16:12:54.272]                   value(a) + 1
[16:12:54.272]                 }, immediateCondition = function(cond) {
[16:12:54.272]                   sendCondition <- ...future.makeSendCondition()
[16:12:54.272]                   sendCondition(cond)
[16:12:54.272]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.272]                   {
[16:12:54.272]                     inherits <- base::inherits
[16:12:54.272]                     invokeRestart <- base::invokeRestart
[16:12:54.272]                     is.null <- base::is.null
[16:12:54.272]                     muffled <- FALSE
[16:12:54.272]                     if (inherits(cond, "message")) {
[16:12:54.272]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:54.272]                       if (muffled) 
[16:12:54.272]                         invokeRestart("muffleMessage")
[16:12:54.272]                     }
[16:12:54.272]                     else if (inherits(cond, "warning")) {
[16:12:54.272]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:54.272]                       if (muffled) 
[16:12:54.272]                         invokeRestart("muffleWarning")
[16:12:54.272]                     }
[16:12:54.272]                     else if (inherits(cond, "condition")) {
[16:12:54.272]                       if (!is.null(pattern)) {
[16:12:54.272]                         computeRestarts <- base::computeRestarts
[16:12:54.272]                         grepl <- base::grepl
[16:12:54.272]                         restarts <- computeRestarts(cond)
[16:12:54.272]                         for (restart in restarts) {
[16:12:54.272]                           name <- restart$name
[16:12:54.272]                           if (is.null(name)) 
[16:12:54.272]                             next
[16:12:54.272]                           if (!grepl(pattern, name)) 
[16:12:54.272]                             next
[16:12:54.272]                           invokeRestart(restart)
[16:12:54.272]                           muffled <- TRUE
[16:12:54.272]                           break
[16:12:54.272]                         }
[16:12:54.272]                       }
[16:12:54.272]                     }
[16:12:54.272]                     invisible(muffled)
[16:12:54.272]                   }
[16:12:54.272]                   muffleCondition(cond)
[16:12:54.272]                 })
[16:12:54.272]             }))
[16:12:54.272]             future::FutureResult(value = ...future.value$value, 
[16:12:54.272]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:54.272]                   ...future.rng), globalenv = if (FALSE) 
[16:12:54.272]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:54.272]                     ...future.globalenv.names))
[16:12:54.272]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:54.272]         }, condition = base::local({
[16:12:54.272]             c <- base::c
[16:12:54.272]             inherits <- base::inherits
[16:12:54.272]             invokeRestart <- base::invokeRestart
[16:12:54.272]             length <- base::length
[16:12:54.272]             list <- base::list
[16:12:54.272]             seq.int <- base::seq.int
[16:12:54.272]             signalCondition <- base::signalCondition
[16:12:54.272]             sys.calls <- base::sys.calls
[16:12:54.272]             `[[` <- base::`[[`
[16:12:54.272]             `+` <- base::`+`
[16:12:54.272]             `<<-` <- base::`<<-`
[16:12:54.272]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:54.272]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:54.272]                   3L)]
[16:12:54.272]             }
[16:12:54.272]             function(cond) {
[16:12:54.272]                 is_error <- inherits(cond, "error")
[16:12:54.272]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:54.272]                   NULL)
[16:12:54.272]                 if (is_error) {
[16:12:54.272]                   sessionInformation <- function() {
[16:12:54.272]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:54.272]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:54.272]                       search = base::search(), system = base::Sys.info())
[16:12:54.272]                   }
[16:12:54.272]                   ...future.conditions[[length(...future.conditions) + 
[16:12:54.272]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:54.272]                     cond$call), session = sessionInformation(), 
[16:12:54.272]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:54.272]                   signalCondition(cond)
[16:12:54.272]                 }
[16:12:54.272]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:54.272]                 "immediateCondition"))) {
[16:12:54.272]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:54.272]                   ...future.conditions[[length(...future.conditions) + 
[16:12:54.272]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:54.272]                   if (TRUE && !signal) {
[16:12:54.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.272]                     {
[16:12:54.272]                       inherits <- base::inherits
[16:12:54.272]                       invokeRestart <- base::invokeRestart
[16:12:54.272]                       is.null <- base::is.null
[16:12:54.272]                       muffled <- FALSE
[16:12:54.272]                       if (inherits(cond, "message")) {
[16:12:54.272]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:54.272]                         if (muffled) 
[16:12:54.272]                           invokeRestart("muffleMessage")
[16:12:54.272]                       }
[16:12:54.272]                       else if (inherits(cond, "warning")) {
[16:12:54.272]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:54.272]                         if (muffled) 
[16:12:54.272]                           invokeRestart("muffleWarning")
[16:12:54.272]                       }
[16:12:54.272]                       else if (inherits(cond, "condition")) {
[16:12:54.272]                         if (!is.null(pattern)) {
[16:12:54.272]                           computeRestarts <- base::computeRestarts
[16:12:54.272]                           grepl <- base::grepl
[16:12:54.272]                           restarts <- computeRestarts(cond)
[16:12:54.272]                           for (restart in restarts) {
[16:12:54.272]                             name <- restart$name
[16:12:54.272]                             if (is.null(name)) 
[16:12:54.272]                               next
[16:12:54.272]                             if (!grepl(pattern, name)) 
[16:12:54.272]                               next
[16:12:54.272]                             invokeRestart(restart)
[16:12:54.272]                             muffled <- TRUE
[16:12:54.272]                             break
[16:12:54.272]                           }
[16:12:54.272]                         }
[16:12:54.272]                       }
[16:12:54.272]                       invisible(muffled)
[16:12:54.272]                     }
[16:12:54.272]                     muffleCondition(cond, pattern = "^muffle")
[16:12:54.272]                   }
[16:12:54.272]                 }
[16:12:54.272]                 else {
[16:12:54.272]                   if (TRUE) {
[16:12:54.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.272]                     {
[16:12:54.272]                       inherits <- base::inherits
[16:12:54.272]                       invokeRestart <- base::invokeRestart
[16:12:54.272]                       is.null <- base::is.null
[16:12:54.272]                       muffled <- FALSE
[16:12:54.272]                       if (inherits(cond, "message")) {
[16:12:54.272]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:54.272]                         if (muffled) 
[16:12:54.272]                           invokeRestart("muffleMessage")
[16:12:54.272]                       }
[16:12:54.272]                       else if (inherits(cond, "warning")) {
[16:12:54.272]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:54.272]                         if (muffled) 
[16:12:54.272]                           invokeRestart("muffleWarning")
[16:12:54.272]                       }
[16:12:54.272]                       else if (inherits(cond, "condition")) {
[16:12:54.272]                         if (!is.null(pattern)) {
[16:12:54.272]                           computeRestarts <- base::computeRestarts
[16:12:54.272]                           grepl <- base::grepl
[16:12:54.272]                           restarts <- computeRestarts(cond)
[16:12:54.272]                           for (restart in restarts) {
[16:12:54.272]                             name <- restart$name
[16:12:54.272]                             if (is.null(name)) 
[16:12:54.272]                               next
[16:12:54.272]                             if (!grepl(pattern, name)) 
[16:12:54.272]                               next
[16:12:54.272]                             invokeRestart(restart)
[16:12:54.272]                             muffled <- TRUE
[16:12:54.272]                             break
[16:12:54.272]                           }
[16:12:54.272]                         }
[16:12:54.272]                       }
[16:12:54.272]                       invisible(muffled)
[16:12:54.272]                     }
[16:12:54.272]                     muffleCondition(cond, pattern = "^muffle")
[16:12:54.272]                   }
[16:12:54.272]                 }
[16:12:54.272]             }
[16:12:54.272]         }))
[16:12:54.272]     }, error = function(ex) {
[16:12:54.272]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:54.272]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:54.272]                 ...future.rng), started = ...future.startTime, 
[16:12:54.272]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:54.272]             version = "1.8"), class = "FutureResult")
[16:12:54.272]     }, finally = {
[16:12:54.272]         if (!identical(...future.workdir, getwd())) 
[16:12:54.272]             setwd(...future.workdir)
[16:12:54.272]         {
[16:12:54.272]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:54.272]                 ...future.oldOptions$nwarnings <- NULL
[16:12:54.272]             }
[16:12:54.272]             base::options(...future.oldOptions)
[16:12:54.272]             if (.Platform$OS.type == "windows") {
[16:12:54.272]                 old_names <- names(...future.oldEnvVars)
[16:12:54.272]                 envs <- base::Sys.getenv()
[16:12:54.272]                 names <- names(envs)
[16:12:54.272]                 common <- intersect(names, old_names)
[16:12:54.272]                 added <- setdiff(names, old_names)
[16:12:54.272]                 removed <- setdiff(old_names, names)
[16:12:54.272]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:54.272]                   envs[common]]
[16:12:54.272]                 NAMES <- toupper(changed)
[16:12:54.272]                 args <- list()
[16:12:54.272]                 for (kk in seq_along(NAMES)) {
[16:12:54.272]                   name <- changed[[kk]]
[16:12:54.272]                   NAME <- NAMES[[kk]]
[16:12:54.272]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.272]                     next
[16:12:54.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:54.272]                 }
[16:12:54.272]                 NAMES <- toupper(added)
[16:12:54.272]                 for (kk in seq_along(NAMES)) {
[16:12:54.272]                   name <- added[[kk]]
[16:12:54.272]                   NAME <- NAMES[[kk]]
[16:12:54.272]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.272]                     next
[16:12:54.272]                   args[[name]] <- ""
[16:12:54.272]                 }
[16:12:54.272]                 NAMES <- toupper(removed)
[16:12:54.272]                 for (kk in seq_along(NAMES)) {
[16:12:54.272]                   name <- removed[[kk]]
[16:12:54.272]                   NAME <- NAMES[[kk]]
[16:12:54.272]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.272]                     next
[16:12:54.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:54.272]                 }
[16:12:54.272]                 if (length(args) > 0) 
[16:12:54.272]                   base::do.call(base::Sys.setenv, args = args)
[16:12:54.272]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:54.272]             }
[16:12:54.272]             else {
[16:12:54.272]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:54.272]             }
[16:12:54.272]             {
[16:12:54.272]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:54.272]                   0L) {
[16:12:54.272]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:54.272]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:54.272]                   base::options(opts)
[16:12:54.272]                 }
[16:12:54.272]                 {
[16:12:54.272]                   {
[16:12:54.272]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:54.272]                     NULL
[16:12:54.272]                   }
[16:12:54.272]                   options(future.plan = NULL)
[16:12:54.272]                   if (is.na(NA_character_)) 
[16:12:54.272]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:54.272]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:54.272]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:54.272]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:54.272]                     envir = parent.frame()) 
[16:12:54.272]                   {
[16:12:54.272]                     if (is.function(workers)) 
[16:12:54.272]                       workers <- workers()
[16:12:54.272]                     workers <- structure(as.integer(workers), 
[16:12:54.272]                       class = class(workers))
[16:12:54.272]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:54.272]                       workers >= 1)
[16:12:54.272]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:54.272]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:54.272]                     }
[16:12:54.272]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:54.272]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:54.272]                       envir = envir)
[16:12:54.272]                     if (!future$lazy) 
[16:12:54.272]                       future <- run(future)
[16:12:54.272]                     invisible(future)
[16:12:54.272]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:54.272]                 }
[16:12:54.272]             }
[16:12:54.272]         }
[16:12:54.272]     })
[16:12:54.272]     if (TRUE) {
[16:12:54.272]         base::sink(type = "output", split = FALSE)
[16:12:54.272]         if (TRUE) {
[16:12:54.272]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:54.272]         }
[16:12:54.272]         else {
[16:12:54.272]             ...future.result["stdout"] <- base::list(NULL)
[16:12:54.272]         }
[16:12:54.272]         base::close(...future.stdout)
[16:12:54.272]         ...future.stdout <- NULL
[16:12:54.272]     }
[16:12:54.272]     ...future.result$conditions <- ...future.conditions
[16:12:54.272]     ...future.result$finished <- base::Sys.time()
[16:12:54.272]     ...future.result
[16:12:54.272] }
[16:12:54.275] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[16:12:54.276] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[16:12:54.328] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[16:12:54.328] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[16:12:54.329] MultisessionFuture started
[16:12:54.329] - Launch lazy future ... done
[16:12:54.329] run() for ‘MultisessionFuture’ ... done
[16:12:54.329] result() for ClusterFuture ...
[16:12:54.329] receiveMessageFromWorker() for ClusterFuture ...
[16:12:54.329] - Validating connection of MultisessionFuture
[16:12:54.377] - received message: FutureResult
[16:12:54.378] - Received FutureResult
[16:12:54.378] - Erased future from FutureRegistry
[16:12:54.378] result() for ClusterFuture ...
[16:12:54.378] - result already collected: FutureResult
[16:12:54.378] result() for ClusterFuture ... done
[16:12:54.378] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:54.378] result() for ClusterFuture ... done
[16:12:54.378] result() for ClusterFuture ...
[16:12:54.379] - result already collected: FutureResult
[16:12:54.379] result() for ClusterFuture ... done
value(b) = 2
[16:12:54.379] result() for ClusterFuture ...
[16:12:54.379] - result already collected: FutureResult
[16:12:54.379] result() for ClusterFuture ... done
[16:12:54.379] result() for ClusterFuture ...
[16:12:54.379] - result already collected: FutureResult
[16:12:54.379] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:54.380] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:54.380] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:54.380] 
[16:12:54.380] Searching for globals ... DONE
[16:12:54.381] - globals: [0] <none>
[16:12:54.381] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:54.381] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:54.381] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:54.382] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:54.382] Searching for globals ... DONE
[16:12:54.382] Resolving globals: TRUE
[16:12:54.382] Resolving any globals that are futures ...
[16:12:54.382] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:54.383] Resolving any globals that are futures ... DONE
[16:12:54.383] Resolving futures part of globals (recursively) ...
[16:12:54.383] resolve() on list ...
[16:12:54.383]  recursive: 99
[16:12:54.383]  length: 1
[16:12:54.383]  elements: ‘a’
[16:12:54.383] run() for ‘Future’ ...
[16:12:54.384] - state: ‘created’
[16:12:54.384] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:54.399] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:54.399] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:54.399]   - Field: ‘node’
[16:12:54.399]   - Field: ‘label’
[16:12:54.399]   - Field: ‘local’
[16:12:54.399]   - Field: ‘owner’
[16:12:54.399]   - Field: ‘envir’
[16:12:54.399]   - Field: ‘workers’
[16:12:54.399]   - Field: ‘packages’
[16:12:54.400]   - Field: ‘gc’
[16:12:54.400]   - Field: ‘conditions’
[16:12:54.400]   - Field: ‘persistent’
[16:12:54.400]   - Field: ‘expr’
[16:12:54.400]   - Field: ‘uuid’
[16:12:54.400]   - Field: ‘seed’
[16:12:54.400]   - Field: ‘version’
[16:12:54.400]   - Field: ‘result’
[16:12:54.400]   - Field: ‘asynchronous’
[16:12:54.400]   - Field: ‘calls’
[16:12:54.401]   - Field: ‘globals’
[16:12:54.401]   - Field: ‘stdout’
[16:12:54.401]   - Field: ‘earlySignal’
[16:12:54.401]   - Field: ‘lazy’
[16:12:54.401]   - Field: ‘state’
[16:12:54.401] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:54.401] - Launch lazy future ...
[16:12:54.401] Packages needed by the future expression (n = 0): <none>
[16:12:54.402] Packages needed by future strategies (n = 0): <none>
[16:12:54.402] {
[16:12:54.402]     {
[16:12:54.402]         {
[16:12:54.402]             ...future.startTime <- base::Sys.time()
[16:12:54.402]             {
[16:12:54.402]                 {
[16:12:54.402]                   {
[16:12:54.402]                     {
[16:12:54.402]                       base::local({
[16:12:54.402]                         has_future <- base::requireNamespace("future", 
[16:12:54.402]                           quietly = TRUE)
[16:12:54.402]                         if (has_future) {
[16:12:54.402]                           ns <- base::getNamespace("future")
[16:12:54.402]                           version <- ns[[".package"]][["version"]]
[16:12:54.402]                           if (is.null(version)) 
[16:12:54.402]                             version <- utils::packageVersion("future")
[16:12:54.402]                         }
[16:12:54.402]                         else {
[16:12:54.402]                           version <- NULL
[16:12:54.402]                         }
[16:12:54.402]                         if (!has_future || version < "1.8.0") {
[16:12:54.402]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:54.402]                             "", base::R.version$version.string), 
[16:12:54.402]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:54.402]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:54.402]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:54.402]                               "release", "version")], collapse = " "), 
[16:12:54.402]                             hostname = base::Sys.info()[["nodename"]])
[16:12:54.402]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:54.402]                             info)
[16:12:54.402]                           info <- base::paste(info, collapse = "; ")
[16:12:54.402]                           if (!has_future) {
[16:12:54.402]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:54.402]                               info)
[16:12:54.402]                           }
[16:12:54.402]                           else {
[16:12:54.402]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:54.402]                               info, version)
[16:12:54.402]                           }
[16:12:54.402]                           base::stop(msg)
[16:12:54.402]                         }
[16:12:54.402]                       })
[16:12:54.402]                     }
[16:12:54.402]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:54.402]                     base::options(mc.cores = 1L)
[16:12:54.402]                   }
[16:12:54.402]                   options(future.plan = NULL)
[16:12:54.402]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:54.402]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:54.402]                 }
[16:12:54.402]                 ...future.workdir <- getwd()
[16:12:54.402]             }
[16:12:54.402]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:54.402]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:54.402]         }
[16:12:54.402]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:54.402]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:54.402]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:54.402]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:54.402]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:54.402]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:54.402]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:54.402]             base::names(...future.oldOptions))
[16:12:54.402]     }
[16:12:54.402]     if (FALSE) {
[16:12:54.402]     }
[16:12:54.402]     else {
[16:12:54.402]         if (TRUE) {
[16:12:54.402]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:54.402]                 open = "w")
[16:12:54.402]         }
[16:12:54.402]         else {
[16:12:54.402]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:54.402]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:54.402]         }
[16:12:54.402]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:54.402]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:54.402]             base::sink(type = "output", split = FALSE)
[16:12:54.402]             base::close(...future.stdout)
[16:12:54.402]         }, add = TRUE)
[16:12:54.402]     }
[16:12:54.402]     ...future.frame <- base::sys.nframe()
[16:12:54.402]     ...future.conditions <- base::list()
[16:12:54.402]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:54.402]     if (FALSE) {
[16:12:54.402]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:54.402]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:54.402]     }
[16:12:54.402]     ...future.result <- base::tryCatch({
[16:12:54.402]         base::withCallingHandlers({
[16:12:54.402]             ...future.value <- base::withVisible(base::local({
[16:12:54.402]                 ...future.makeSendCondition <- local({
[16:12:54.402]                   sendCondition <- NULL
[16:12:54.402]                   function(frame = 1L) {
[16:12:54.402]                     if (is.function(sendCondition)) 
[16:12:54.402]                       return(sendCondition)
[16:12:54.402]                     ns <- getNamespace("parallel")
[16:12:54.402]                     if (exists("sendData", mode = "function", 
[16:12:54.402]                       envir = ns)) {
[16:12:54.402]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:54.402]                         envir = ns)
[16:12:54.402]                       envir <- sys.frame(frame)
[16:12:54.402]                       master <- NULL
[16:12:54.402]                       while (!identical(envir, .GlobalEnv) && 
[16:12:54.402]                         !identical(envir, emptyenv())) {
[16:12:54.402]                         if (exists("master", mode = "list", envir = envir, 
[16:12:54.402]                           inherits = FALSE)) {
[16:12:54.402]                           master <- get("master", mode = "list", 
[16:12:54.402]                             envir = envir, inherits = FALSE)
[16:12:54.402]                           if (inherits(master, c("SOCKnode", 
[16:12:54.402]                             "SOCK0node"))) {
[16:12:54.402]                             sendCondition <<- function(cond) {
[16:12:54.402]                               data <- list(type = "VALUE", value = cond, 
[16:12:54.402]                                 success = TRUE)
[16:12:54.402]                               parallel_sendData(master, data)
[16:12:54.402]                             }
[16:12:54.402]                             return(sendCondition)
[16:12:54.402]                           }
[16:12:54.402]                         }
[16:12:54.402]                         frame <- frame + 1L
[16:12:54.402]                         envir <- sys.frame(frame)
[16:12:54.402]                       }
[16:12:54.402]                     }
[16:12:54.402]                     sendCondition <<- function(cond) NULL
[16:12:54.402]                   }
[16:12:54.402]                 })
[16:12:54.402]                 withCallingHandlers({
[16:12:54.402]                   1
[16:12:54.402]                 }, immediateCondition = function(cond) {
[16:12:54.402]                   sendCondition <- ...future.makeSendCondition()
[16:12:54.402]                   sendCondition(cond)
[16:12:54.402]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.402]                   {
[16:12:54.402]                     inherits <- base::inherits
[16:12:54.402]                     invokeRestart <- base::invokeRestart
[16:12:54.402]                     is.null <- base::is.null
[16:12:54.402]                     muffled <- FALSE
[16:12:54.402]                     if (inherits(cond, "message")) {
[16:12:54.402]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:54.402]                       if (muffled) 
[16:12:54.402]                         invokeRestart("muffleMessage")
[16:12:54.402]                     }
[16:12:54.402]                     else if (inherits(cond, "warning")) {
[16:12:54.402]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:54.402]                       if (muffled) 
[16:12:54.402]                         invokeRestart("muffleWarning")
[16:12:54.402]                     }
[16:12:54.402]                     else if (inherits(cond, "condition")) {
[16:12:54.402]                       if (!is.null(pattern)) {
[16:12:54.402]                         computeRestarts <- base::computeRestarts
[16:12:54.402]                         grepl <- base::grepl
[16:12:54.402]                         restarts <- computeRestarts(cond)
[16:12:54.402]                         for (restart in restarts) {
[16:12:54.402]                           name <- restart$name
[16:12:54.402]                           if (is.null(name)) 
[16:12:54.402]                             next
[16:12:54.402]                           if (!grepl(pattern, name)) 
[16:12:54.402]                             next
[16:12:54.402]                           invokeRestart(restart)
[16:12:54.402]                           muffled <- TRUE
[16:12:54.402]                           break
[16:12:54.402]                         }
[16:12:54.402]                       }
[16:12:54.402]                     }
[16:12:54.402]                     invisible(muffled)
[16:12:54.402]                   }
[16:12:54.402]                   muffleCondition(cond)
[16:12:54.402]                 })
[16:12:54.402]             }))
[16:12:54.402]             future::FutureResult(value = ...future.value$value, 
[16:12:54.402]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:54.402]                   ...future.rng), globalenv = if (FALSE) 
[16:12:54.402]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:54.402]                     ...future.globalenv.names))
[16:12:54.402]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:54.402]         }, condition = base::local({
[16:12:54.402]             c <- base::c
[16:12:54.402]             inherits <- base::inherits
[16:12:54.402]             invokeRestart <- base::invokeRestart
[16:12:54.402]             length <- base::length
[16:12:54.402]             list <- base::list
[16:12:54.402]             seq.int <- base::seq.int
[16:12:54.402]             signalCondition <- base::signalCondition
[16:12:54.402]             sys.calls <- base::sys.calls
[16:12:54.402]             `[[` <- base::`[[`
[16:12:54.402]             `+` <- base::`+`
[16:12:54.402]             `<<-` <- base::`<<-`
[16:12:54.402]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:54.402]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:54.402]                   3L)]
[16:12:54.402]             }
[16:12:54.402]             function(cond) {
[16:12:54.402]                 is_error <- inherits(cond, "error")
[16:12:54.402]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:54.402]                   NULL)
[16:12:54.402]                 if (is_error) {
[16:12:54.402]                   sessionInformation <- function() {
[16:12:54.402]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:54.402]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:54.402]                       search = base::search(), system = base::Sys.info())
[16:12:54.402]                   }
[16:12:54.402]                   ...future.conditions[[length(...future.conditions) + 
[16:12:54.402]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:54.402]                     cond$call), session = sessionInformation(), 
[16:12:54.402]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:54.402]                   signalCondition(cond)
[16:12:54.402]                 }
[16:12:54.402]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:54.402]                 "immediateCondition"))) {
[16:12:54.402]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:54.402]                   ...future.conditions[[length(...future.conditions) + 
[16:12:54.402]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:54.402]                   if (TRUE && !signal) {
[16:12:54.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.402]                     {
[16:12:54.402]                       inherits <- base::inherits
[16:12:54.402]                       invokeRestart <- base::invokeRestart
[16:12:54.402]                       is.null <- base::is.null
[16:12:54.402]                       muffled <- FALSE
[16:12:54.402]                       if (inherits(cond, "message")) {
[16:12:54.402]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:54.402]                         if (muffled) 
[16:12:54.402]                           invokeRestart("muffleMessage")
[16:12:54.402]                       }
[16:12:54.402]                       else if (inherits(cond, "warning")) {
[16:12:54.402]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:54.402]                         if (muffled) 
[16:12:54.402]                           invokeRestart("muffleWarning")
[16:12:54.402]                       }
[16:12:54.402]                       else if (inherits(cond, "condition")) {
[16:12:54.402]                         if (!is.null(pattern)) {
[16:12:54.402]                           computeRestarts <- base::computeRestarts
[16:12:54.402]                           grepl <- base::grepl
[16:12:54.402]                           restarts <- computeRestarts(cond)
[16:12:54.402]                           for (restart in restarts) {
[16:12:54.402]                             name <- restart$name
[16:12:54.402]                             if (is.null(name)) 
[16:12:54.402]                               next
[16:12:54.402]                             if (!grepl(pattern, name)) 
[16:12:54.402]                               next
[16:12:54.402]                             invokeRestart(restart)
[16:12:54.402]                             muffled <- TRUE
[16:12:54.402]                             break
[16:12:54.402]                           }
[16:12:54.402]                         }
[16:12:54.402]                       }
[16:12:54.402]                       invisible(muffled)
[16:12:54.402]                     }
[16:12:54.402]                     muffleCondition(cond, pattern = "^muffle")
[16:12:54.402]                   }
[16:12:54.402]                 }
[16:12:54.402]                 else {
[16:12:54.402]                   if (TRUE) {
[16:12:54.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.402]                     {
[16:12:54.402]                       inherits <- base::inherits
[16:12:54.402]                       invokeRestart <- base::invokeRestart
[16:12:54.402]                       is.null <- base::is.null
[16:12:54.402]                       muffled <- FALSE
[16:12:54.402]                       if (inherits(cond, "message")) {
[16:12:54.402]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:54.402]                         if (muffled) 
[16:12:54.402]                           invokeRestart("muffleMessage")
[16:12:54.402]                       }
[16:12:54.402]                       else if (inherits(cond, "warning")) {
[16:12:54.402]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:54.402]                         if (muffled) 
[16:12:54.402]                           invokeRestart("muffleWarning")
[16:12:54.402]                       }
[16:12:54.402]                       else if (inherits(cond, "condition")) {
[16:12:54.402]                         if (!is.null(pattern)) {
[16:12:54.402]                           computeRestarts <- base::computeRestarts
[16:12:54.402]                           grepl <- base::grepl
[16:12:54.402]                           restarts <- computeRestarts(cond)
[16:12:54.402]                           for (restart in restarts) {
[16:12:54.402]                             name <- restart$name
[16:12:54.402]                             if (is.null(name)) 
[16:12:54.402]                               next
[16:12:54.402]                             if (!grepl(pattern, name)) 
[16:12:54.402]                               next
[16:12:54.402]                             invokeRestart(restart)
[16:12:54.402]                             muffled <- TRUE
[16:12:54.402]                             break
[16:12:54.402]                           }
[16:12:54.402]                         }
[16:12:54.402]                       }
[16:12:54.402]                       invisible(muffled)
[16:12:54.402]                     }
[16:12:54.402]                     muffleCondition(cond, pattern = "^muffle")
[16:12:54.402]                   }
[16:12:54.402]                 }
[16:12:54.402]             }
[16:12:54.402]         }))
[16:12:54.402]     }, error = function(ex) {
[16:12:54.402]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:54.402]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:54.402]                 ...future.rng), started = ...future.startTime, 
[16:12:54.402]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:54.402]             version = "1.8"), class = "FutureResult")
[16:12:54.402]     }, finally = {
[16:12:54.402]         if (!identical(...future.workdir, getwd())) 
[16:12:54.402]             setwd(...future.workdir)
[16:12:54.402]         {
[16:12:54.402]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:54.402]                 ...future.oldOptions$nwarnings <- NULL
[16:12:54.402]             }
[16:12:54.402]             base::options(...future.oldOptions)
[16:12:54.402]             if (.Platform$OS.type == "windows") {
[16:12:54.402]                 old_names <- names(...future.oldEnvVars)
[16:12:54.402]                 envs <- base::Sys.getenv()
[16:12:54.402]                 names <- names(envs)
[16:12:54.402]                 common <- intersect(names, old_names)
[16:12:54.402]                 added <- setdiff(names, old_names)
[16:12:54.402]                 removed <- setdiff(old_names, names)
[16:12:54.402]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:54.402]                   envs[common]]
[16:12:54.402]                 NAMES <- toupper(changed)
[16:12:54.402]                 args <- list()
[16:12:54.402]                 for (kk in seq_along(NAMES)) {
[16:12:54.402]                   name <- changed[[kk]]
[16:12:54.402]                   NAME <- NAMES[[kk]]
[16:12:54.402]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.402]                     next
[16:12:54.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:54.402]                 }
[16:12:54.402]                 NAMES <- toupper(added)
[16:12:54.402]                 for (kk in seq_along(NAMES)) {
[16:12:54.402]                   name <- added[[kk]]
[16:12:54.402]                   NAME <- NAMES[[kk]]
[16:12:54.402]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.402]                     next
[16:12:54.402]                   args[[name]] <- ""
[16:12:54.402]                 }
[16:12:54.402]                 NAMES <- toupper(removed)
[16:12:54.402]                 for (kk in seq_along(NAMES)) {
[16:12:54.402]                   name <- removed[[kk]]
[16:12:54.402]                   NAME <- NAMES[[kk]]
[16:12:54.402]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.402]                     next
[16:12:54.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:54.402]                 }
[16:12:54.402]                 if (length(args) > 0) 
[16:12:54.402]                   base::do.call(base::Sys.setenv, args = args)
[16:12:54.402]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:54.402]             }
[16:12:54.402]             else {
[16:12:54.402]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:54.402]             }
[16:12:54.402]             {
[16:12:54.402]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:54.402]                   0L) {
[16:12:54.402]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:54.402]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:54.402]                   base::options(opts)
[16:12:54.402]                 }
[16:12:54.402]                 {
[16:12:54.402]                   {
[16:12:54.402]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:54.402]                     NULL
[16:12:54.402]                   }
[16:12:54.402]                   options(future.plan = NULL)
[16:12:54.402]                   if (is.na(NA_character_)) 
[16:12:54.402]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:54.402]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:54.402]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:54.402]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:54.402]                     envir = parent.frame()) 
[16:12:54.402]                   {
[16:12:54.402]                     if (is.function(workers)) 
[16:12:54.402]                       workers <- workers()
[16:12:54.402]                     workers <- structure(as.integer(workers), 
[16:12:54.402]                       class = class(workers))
[16:12:54.402]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:54.402]                       workers >= 1)
[16:12:54.402]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:54.402]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:54.402]                     }
[16:12:54.402]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:54.402]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:54.402]                       envir = envir)
[16:12:54.402]                     if (!future$lazy) 
[16:12:54.402]                       future <- run(future)
[16:12:54.402]                     invisible(future)
[16:12:54.402]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:54.402]                 }
[16:12:54.402]             }
[16:12:54.402]         }
[16:12:54.402]     })
[16:12:54.402]     if (TRUE) {
[16:12:54.402]         base::sink(type = "output", split = FALSE)
[16:12:54.402]         if (TRUE) {
[16:12:54.402]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:54.402]         }
[16:12:54.402]         else {
[16:12:54.402]             ...future.result["stdout"] <- base::list(NULL)
[16:12:54.402]         }
[16:12:54.402]         base::close(...future.stdout)
[16:12:54.402]         ...future.stdout <- NULL
[16:12:54.402]     }
[16:12:54.402]     ...future.result$conditions <- ...future.conditions
[16:12:54.402]     ...future.result$finished <- base::Sys.time()
[16:12:54.402]     ...future.result
[16:12:54.402] }
[16:12:54.405] MultisessionFuture started
[16:12:54.405] - Launch lazy future ... done
[16:12:54.405] run() for ‘MultisessionFuture’ ... done
[16:12:54.453] receiveMessageFromWorker() for ClusterFuture ...
[16:12:54.453] - Validating connection of MultisessionFuture
[16:12:54.453] - received message: FutureResult
[16:12:54.454] - Received FutureResult
[16:12:54.454] - Erased future from FutureRegistry
[16:12:54.454] result() for ClusterFuture ...
[16:12:54.454] - result already collected: FutureResult
[16:12:54.454] result() for ClusterFuture ... done
[16:12:54.454] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:54.454] Future #1
[16:12:54.454] result() for ClusterFuture ...
[16:12:54.454] - result already collected: FutureResult
[16:12:54.454] result() for ClusterFuture ... done
[16:12:54.454] result() for ClusterFuture ...
[16:12:54.455] - result already collected: FutureResult
[16:12:54.455] result() for ClusterFuture ... done
[16:12:54.455] A MultisessionFuture was resolved
[16:12:54.455]  length: 0 (resolved future 1)
[16:12:54.455] resolve() on list ... DONE
[16:12:54.455] - globals: [1] ‘a’
[16:12:54.455] Resolving futures part of globals (recursively) ... DONE
[16:12:54.456] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[16:12:54.457] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[16:12:54.457] - globals: [1] ‘a’
[16:12:54.457] - packages: [1] ‘future’
[16:12:54.457] getGlobalsAndPackages() ... DONE
[16:12:54.457] run() for ‘Future’ ...
[16:12:54.457] - state: ‘created’
[16:12:54.458] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:54.473] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:54.473] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:54.473]   - Field: ‘node’
[16:12:54.473]   - Field: ‘label’
[16:12:54.473]   - Field: ‘local’
[16:12:54.473]   - Field: ‘owner’
[16:12:54.473]   - Field: ‘envir’
[16:12:54.473]   - Field: ‘workers’
[16:12:54.473]   - Field: ‘packages’
[16:12:54.474]   - Field: ‘gc’
[16:12:54.474]   - Field: ‘conditions’
[16:12:54.474]   - Field: ‘persistent’
[16:12:54.474]   - Field: ‘expr’
[16:12:54.474]   - Field: ‘uuid’
[16:12:54.474]   - Field: ‘seed’
[16:12:54.474]   - Field: ‘version’
[16:12:54.474]   - Field: ‘result’
[16:12:54.474]   - Field: ‘asynchronous’
[16:12:54.474]   - Field: ‘calls’
[16:12:54.474]   - Field: ‘globals’
[16:12:54.475]   - Field: ‘stdout’
[16:12:54.475]   - Field: ‘earlySignal’
[16:12:54.475]   - Field: ‘lazy’
[16:12:54.475]   - Field: ‘state’
[16:12:54.475] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:54.475] - Launch lazy future ...
[16:12:54.475] Packages needed by the future expression (n = 1): ‘future’
[16:12:54.475] Packages needed by future strategies (n = 0): <none>
[16:12:54.476] {
[16:12:54.476]     {
[16:12:54.476]         {
[16:12:54.476]             ...future.startTime <- base::Sys.time()
[16:12:54.476]             {
[16:12:54.476]                 {
[16:12:54.476]                   {
[16:12:54.476]                     {
[16:12:54.476]                       {
[16:12:54.476]                         base::local({
[16:12:54.476]                           has_future <- base::requireNamespace("future", 
[16:12:54.476]                             quietly = TRUE)
[16:12:54.476]                           if (has_future) {
[16:12:54.476]                             ns <- base::getNamespace("future")
[16:12:54.476]                             version <- ns[[".package"]][["version"]]
[16:12:54.476]                             if (is.null(version)) 
[16:12:54.476]                               version <- utils::packageVersion("future")
[16:12:54.476]                           }
[16:12:54.476]                           else {
[16:12:54.476]                             version <- NULL
[16:12:54.476]                           }
[16:12:54.476]                           if (!has_future || version < "1.8.0") {
[16:12:54.476]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:54.476]                               "", base::R.version$version.string), 
[16:12:54.476]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:54.476]                                 base::R.version$platform, 8 * 
[16:12:54.476]                                   base::.Machine$sizeof.pointer), 
[16:12:54.476]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:54.476]                                 "release", "version")], collapse = " "), 
[16:12:54.476]                               hostname = base::Sys.info()[["nodename"]])
[16:12:54.476]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:54.476]                               info)
[16:12:54.476]                             info <- base::paste(info, collapse = "; ")
[16:12:54.476]                             if (!has_future) {
[16:12:54.476]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:54.476]                                 info)
[16:12:54.476]                             }
[16:12:54.476]                             else {
[16:12:54.476]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:54.476]                                 info, version)
[16:12:54.476]                             }
[16:12:54.476]                             base::stop(msg)
[16:12:54.476]                           }
[16:12:54.476]                         })
[16:12:54.476]                       }
[16:12:54.476]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:54.476]                       base::options(mc.cores = 1L)
[16:12:54.476]                     }
[16:12:54.476]                     base::local({
[16:12:54.476]                       for (pkg in "future") {
[16:12:54.476]                         base::loadNamespace(pkg)
[16:12:54.476]                         base::library(pkg, character.only = TRUE)
[16:12:54.476]                       }
[16:12:54.476]                     })
[16:12:54.476]                   }
[16:12:54.476]                   options(future.plan = NULL)
[16:12:54.476]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:54.476]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:54.476]                 }
[16:12:54.476]                 ...future.workdir <- getwd()
[16:12:54.476]             }
[16:12:54.476]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:54.476]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:54.476]         }
[16:12:54.476]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:54.476]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:54.476]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:54.476]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:54.476]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:54.476]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:54.476]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:54.476]             base::names(...future.oldOptions))
[16:12:54.476]     }
[16:12:54.476]     if (FALSE) {
[16:12:54.476]     }
[16:12:54.476]     else {
[16:12:54.476]         if (TRUE) {
[16:12:54.476]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:54.476]                 open = "w")
[16:12:54.476]         }
[16:12:54.476]         else {
[16:12:54.476]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:54.476]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:54.476]         }
[16:12:54.476]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:54.476]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:54.476]             base::sink(type = "output", split = FALSE)
[16:12:54.476]             base::close(...future.stdout)
[16:12:54.476]         }, add = TRUE)
[16:12:54.476]     }
[16:12:54.476]     ...future.frame <- base::sys.nframe()
[16:12:54.476]     ...future.conditions <- base::list()
[16:12:54.476]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:54.476]     if (FALSE) {
[16:12:54.476]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:54.476]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:54.476]     }
[16:12:54.476]     ...future.result <- base::tryCatch({
[16:12:54.476]         base::withCallingHandlers({
[16:12:54.476]             ...future.value <- base::withVisible(base::local({
[16:12:54.476]                 ...future.makeSendCondition <- local({
[16:12:54.476]                   sendCondition <- NULL
[16:12:54.476]                   function(frame = 1L) {
[16:12:54.476]                     if (is.function(sendCondition)) 
[16:12:54.476]                       return(sendCondition)
[16:12:54.476]                     ns <- getNamespace("parallel")
[16:12:54.476]                     if (exists("sendData", mode = "function", 
[16:12:54.476]                       envir = ns)) {
[16:12:54.476]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:54.476]                         envir = ns)
[16:12:54.476]                       envir <- sys.frame(frame)
[16:12:54.476]                       master <- NULL
[16:12:54.476]                       while (!identical(envir, .GlobalEnv) && 
[16:12:54.476]                         !identical(envir, emptyenv())) {
[16:12:54.476]                         if (exists("master", mode = "list", envir = envir, 
[16:12:54.476]                           inherits = FALSE)) {
[16:12:54.476]                           master <- get("master", mode = "list", 
[16:12:54.476]                             envir = envir, inherits = FALSE)
[16:12:54.476]                           if (inherits(master, c("SOCKnode", 
[16:12:54.476]                             "SOCK0node"))) {
[16:12:54.476]                             sendCondition <<- function(cond) {
[16:12:54.476]                               data <- list(type = "VALUE", value = cond, 
[16:12:54.476]                                 success = TRUE)
[16:12:54.476]                               parallel_sendData(master, data)
[16:12:54.476]                             }
[16:12:54.476]                             return(sendCondition)
[16:12:54.476]                           }
[16:12:54.476]                         }
[16:12:54.476]                         frame <- frame + 1L
[16:12:54.476]                         envir <- sys.frame(frame)
[16:12:54.476]                       }
[16:12:54.476]                     }
[16:12:54.476]                     sendCondition <<- function(cond) NULL
[16:12:54.476]                   }
[16:12:54.476]                 })
[16:12:54.476]                 withCallingHandlers({
[16:12:54.476]                   value(a) + 1
[16:12:54.476]                 }, immediateCondition = function(cond) {
[16:12:54.476]                   sendCondition <- ...future.makeSendCondition()
[16:12:54.476]                   sendCondition(cond)
[16:12:54.476]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.476]                   {
[16:12:54.476]                     inherits <- base::inherits
[16:12:54.476]                     invokeRestart <- base::invokeRestart
[16:12:54.476]                     is.null <- base::is.null
[16:12:54.476]                     muffled <- FALSE
[16:12:54.476]                     if (inherits(cond, "message")) {
[16:12:54.476]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:54.476]                       if (muffled) 
[16:12:54.476]                         invokeRestart("muffleMessage")
[16:12:54.476]                     }
[16:12:54.476]                     else if (inherits(cond, "warning")) {
[16:12:54.476]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:54.476]                       if (muffled) 
[16:12:54.476]                         invokeRestart("muffleWarning")
[16:12:54.476]                     }
[16:12:54.476]                     else if (inherits(cond, "condition")) {
[16:12:54.476]                       if (!is.null(pattern)) {
[16:12:54.476]                         computeRestarts <- base::computeRestarts
[16:12:54.476]                         grepl <- base::grepl
[16:12:54.476]                         restarts <- computeRestarts(cond)
[16:12:54.476]                         for (restart in restarts) {
[16:12:54.476]                           name <- restart$name
[16:12:54.476]                           if (is.null(name)) 
[16:12:54.476]                             next
[16:12:54.476]                           if (!grepl(pattern, name)) 
[16:12:54.476]                             next
[16:12:54.476]                           invokeRestart(restart)
[16:12:54.476]                           muffled <- TRUE
[16:12:54.476]                           break
[16:12:54.476]                         }
[16:12:54.476]                       }
[16:12:54.476]                     }
[16:12:54.476]                     invisible(muffled)
[16:12:54.476]                   }
[16:12:54.476]                   muffleCondition(cond)
[16:12:54.476]                 })
[16:12:54.476]             }))
[16:12:54.476]             future::FutureResult(value = ...future.value$value, 
[16:12:54.476]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:54.476]                   ...future.rng), globalenv = if (FALSE) 
[16:12:54.476]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:54.476]                     ...future.globalenv.names))
[16:12:54.476]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:54.476]         }, condition = base::local({
[16:12:54.476]             c <- base::c
[16:12:54.476]             inherits <- base::inherits
[16:12:54.476]             invokeRestart <- base::invokeRestart
[16:12:54.476]             length <- base::length
[16:12:54.476]             list <- base::list
[16:12:54.476]             seq.int <- base::seq.int
[16:12:54.476]             signalCondition <- base::signalCondition
[16:12:54.476]             sys.calls <- base::sys.calls
[16:12:54.476]             `[[` <- base::`[[`
[16:12:54.476]             `+` <- base::`+`
[16:12:54.476]             `<<-` <- base::`<<-`
[16:12:54.476]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:54.476]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:54.476]                   3L)]
[16:12:54.476]             }
[16:12:54.476]             function(cond) {
[16:12:54.476]                 is_error <- inherits(cond, "error")
[16:12:54.476]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:54.476]                   NULL)
[16:12:54.476]                 if (is_error) {
[16:12:54.476]                   sessionInformation <- function() {
[16:12:54.476]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:54.476]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:54.476]                       search = base::search(), system = base::Sys.info())
[16:12:54.476]                   }
[16:12:54.476]                   ...future.conditions[[length(...future.conditions) + 
[16:12:54.476]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:54.476]                     cond$call), session = sessionInformation(), 
[16:12:54.476]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:54.476]                   signalCondition(cond)
[16:12:54.476]                 }
[16:12:54.476]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:54.476]                 "immediateCondition"))) {
[16:12:54.476]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:54.476]                   ...future.conditions[[length(...future.conditions) + 
[16:12:54.476]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:54.476]                   if (TRUE && !signal) {
[16:12:54.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.476]                     {
[16:12:54.476]                       inherits <- base::inherits
[16:12:54.476]                       invokeRestart <- base::invokeRestart
[16:12:54.476]                       is.null <- base::is.null
[16:12:54.476]                       muffled <- FALSE
[16:12:54.476]                       if (inherits(cond, "message")) {
[16:12:54.476]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:54.476]                         if (muffled) 
[16:12:54.476]                           invokeRestart("muffleMessage")
[16:12:54.476]                       }
[16:12:54.476]                       else if (inherits(cond, "warning")) {
[16:12:54.476]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:54.476]                         if (muffled) 
[16:12:54.476]                           invokeRestart("muffleWarning")
[16:12:54.476]                       }
[16:12:54.476]                       else if (inherits(cond, "condition")) {
[16:12:54.476]                         if (!is.null(pattern)) {
[16:12:54.476]                           computeRestarts <- base::computeRestarts
[16:12:54.476]                           grepl <- base::grepl
[16:12:54.476]                           restarts <- computeRestarts(cond)
[16:12:54.476]                           for (restart in restarts) {
[16:12:54.476]                             name <- restart$name
[16:12:54.476]                             if (is.null(name)) 
[16:12:54.476]                               next
[16:12:54.476]                             if (!grepl(pattern, name)) 
[16:12:54.476]                               next
[16:12:54.476]                             invokeRestart(restart)
[16:12:54.476]                             muffled <- TRUE
[16:12:54.476]                             break
[16:12:54.476]                           }
[16:12:54.476]                         }
[16:12:54.476]                       }
[16:12:54.476]                       invisible(muffled)
[16:12:54.476]                     }
[16:12:54.476]                     muffleCondition(cond, pattern = "^muffle")
[16:12:54.476]                   }
[16:12:54.476]                 }
[16:12:54.476]                 else {
[16:12:54.476]                   if (TRUE) {
[16:12:54.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.476]                     {
[16:12:54.476]                       inherits <- base::inherits
[16:12:54.476]                       invokeRestart <- base::invokeRestart
[16:12:54.476]                       is.null <- base::is.null
[16:12:54.476]                       muffled <- FALSE
[16:12:54.476]                       if (inherits(cond, "message")) {
[16:12:54.476]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:54.476]                         if (muffled) 
[16:12:54.476]                           invokeRestart("muffleMessage")
[16:12:54.476]                       }
[16:12:54.476]                       else if (inherits(cond, "warning")) {
[16:12:54.476]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:54.476]                         if (muffled) 
[16:12:54.476]                           invokeRestart("muffleWarning")
[16:12:54.476]                       }
[16:12:54.476]                       else if (inherits(cond, "condition")) {
[16:12:54.476]                         if (!is.null(pattern)) {
[16:12:54.476]                           computeRestarts <- base::computeRestarts
[16:12:54.476]                           grepl <- base::grepl
[16:12:54.476]                           restarts <- computeRestarts(cond)
[16:12:54.476]                           for (restart in restarts) {
[16:12:54.476]                             name <- restart$name
[16:12:54.476]                             if (is.null(name)) 
[16:12:54.476]                               next
[16:12:54.476]                             if (!grepl(pattern, name)) 
[16:12:54.476]                               next
[16:12:54.476]                             invokeRestart(restart)
[16:12:54.476]                             muffled <- TRUE
[16:12:54.476]                             break
[16:12:54.476]                           }
[16:12:54.476]                         }
[16:12:54.476]                       }
[16:12:54.476]                       invisible(muffled)
[16:12:54.476]                     }
[16:12:54.476]                     muffleCondition(cond, pattern = "^muffle")
[16:12:54.476]                   }
[16:12:54.476]                 }
[16:12:54.476]             }
[16:12:54.476]         }))
[16:12:54.476]     }, error = function(ex) {
[16:12:54.476]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:54.476]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:54.476]                 ...future.rng), started = ...future.startTime, 
[16:12:54.476]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:54.476]             version = "1.8"), class = "FutureResult")
[16:12:54.476]     }, finally = {
[16:12:54.476]         if (!identical(...future.workdir, getwd())) 
[16:12:54.476]             setwd(...future.workdir)
[16:12:54.476]         {
[16:12:54.476]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:54.476]                 ...future.oldOptions$nwarnings <- NULL
[16:12:54.476]             }
[16:12:54.476]             base::options(...future.oldOptions)
[16:12:54.476]             if (.Platform$OS.type == "windows") {
[16:12:54.476]                 old_names <- names(...future.oldEnvVars)
[16:12:54.476]                 envs <- base::Sys.getenv()
[16:12:54.476]                 names <- names(envs)
[16:12:54.476]                 common <- intersect(names, old_names)
[16:12:54.476]                 added <- setdiff(names, old_names)
[16:12:54.476]                 removed <- setdiff(old_names, names)
[16:12:54.476]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:54.476]                   envs[common]]
[16:12:54.476]                 NAMES <- toupper(changed)
[16:12:54.476]                 args <- list()
[16:12:54.476]                 for (kk in seq_along(NAMES)) {
[16:12:54.476]                   name <- changed[[kk]]
[16:12:54.476]                   NAME <- NAMES[[kk]]
[16:12:54.476]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.476]                     next
[16:12:54.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:54.476]                 }
[16:12:54.476]                 NAMES <- toupper(added)
[16:12:54.476]                 for (kk in seq_along(NAMES)) {
[16:12:54.476]                   name <- added[[kk]]
[16:12:54.476]                   NAME <- NAMES[[kk]]
[16:12:54.476]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.476]                     next
[16:12:54.476]                   args[[name]] <- ""
[16:12:54.476]                 }
[16:12:54.476]                 NAMES <- toupper(removed)
[16:12:54.476]                 for (kk in seq_along(NAMES)) {
[16:12:54.476]                   name <- removed[[kk]]
[16:12:54.476]                   NAME <- NAMES[[kk]]
[16:12:54.476]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.476]                     next
[16:12:54.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:54.476]                 }
[16:12:54.476]                 if (length(args) > 0) 
[16:12:54.476]                   base::do.call(base::Sys.setenv, args = args)
[16:12:54.476]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:54.476]             }
[16:12:54.476]             else {
[16:12:54.476]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:54.476]             }
[16:12:54.476]             {
[16:12:54.476]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:54.476]                   0L) {
[16:12:54.476]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:54.476]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:54.476]                   base::options(opts)
[16:12:54.476]                 }
[16:12:54.476]                 {
[16:12:54.476]                   {
[16:12:54.476]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:54.476]                     NULL
[16:12:54.476]                   }
[16:12:54.476]                   options(future.plan = NULL)
[16:12:54.476]                   if (is.na(NA_character_)) 
[16:12:54.476]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:54.476]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:54.476]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:54.476]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:54.476]                     envir = parent.frame()) 
[16:12:54.476]                   {
[16:12:54.476]                     if (is.function(workers)) 
[16:12:54.476]                       workers <- workers()
[16:12:54.476]                     workers <- structure(as.integer(workers), 
[16:12:54.476]                       class = class(workers))
[16:12:54.476]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:54.476]                       workers >= 1)
[16:12:54.476]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:54.476]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:54.476]                     }
[16:12:54.476]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:54.476]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:54.476]                       envir = envir)
[16:12:54.476]                     if (!future$lazy) 
[16:12:54.476]                       future <- run(future)
[16:12:54.476]                     invisible(future)
[16:12:54.476]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:54.476]                 }
[16:12:54.476]             }
[16:12:54.476]         }
[16:12:54.476]     })
[16:12:54.476]     if (TRUE) {
[16:12:54.476]         base::sink(type = "output", split = FALSE)
[16:12:54.476]         if (TRUE) {
[16:12:54.476]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:54.476]         }
[16:12:54.476]         else {
[16:12:54.476]             ...future.result["stdout"] <- base::list(NULL)
[16:12:54.476]         }
[16:12:54.476]         base::close(...future.stdout)
[16:12:54.476]         ...future.stdout <- NULL
[16:12:54.476]     }
[16:12:54.476]     ...future.result$conditions <- ...future.conditions
[16:12:54.476]     ...future.result$finished <- base::Sys.time()
[16:12:54.476]     ...future.result
[16:12:54.476] }
[16:12:54.479] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[16:12:54.480] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[16:12:54.532] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[16:12:54.532] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[16:12:54.533] MultisessionFuture started
[16:12:54.533] - Launch lazy future ... done
[16:12:54.533] run() for ‘MultisessionFuture’ ... done
[16:12:54.534] result() for ClusterFuture ...
[16:12:54.534] receiveMessageFromWorker() for ClusterFuture ...
[16:12:54.534] - Validating connection of MultisessionFuture
[16:12:54.582] - received message: FutureResult
[16:12:54.582] - Received FutureResult
[16:12:54.582] - Erased future from FutureRegistry
[16:12:54.582] result() for ClusterFuture ...
[16:12:54.582] - result already collected: FutureResult
[16:12:54.582] result() for ClusterFuture ... done
[16:12:54.583] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:54.583] result() for ClusterFuture ... done
[16:12:54.583] result() for ClusterFuture ...
[16:12:54.583] - result already collected: FutureResult
[16:12:54.583] result() for ClusterFuture ... done
value(b) = 2
[16:12:54.583] result() for ClusterFuture ...
[16:12:54.583] - result already collected: FutureResult
[16:12:54.584] result() for ClusterFuture ... done
[16:12:54.584] result() for ClusterFuture ...
[16:12:54.584] - result already collected: FutureResult
[16:12:54.584] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:54.584] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:54.584] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:54.585] 
[16:12:54.585] Searching for globals ... DONE
[16:12:54.585] - globals: [0] <none>
[16:12:54.585] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:54.586] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:54.586] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:54.587] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:54.587] Searching for globals ... DONE
[16:12:54.587] Resolving globals: TRUE
[16:12:54.587] Resolving any globals that are futures ...
[16:12:54.587] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:54.587] Resolving any globals that are futures ... DONE
[16:12:54.588] Resolving futures part of globals (recursively) ...
[16:12:54.588] resolve() on list ...
[16:12:54.588]  recursive: 99
[16:12:54.588]  length: 1
[16:12:54.588]  elements: ‘a’
[16:12:54.591] run() for ‘Future’ ...
[16:12:54.591] - state: ‘created’
[16:12:54.591] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:54.606] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:54.606] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:54.606]   - Field: ‘node’
[16:12:54.606]   - Field: ‘label’
[16:12:54.606]   - Field: ‘local’
[16:12:54.606]   - Field: ‘owner’
[16:12:54.606]   - Field: ‘envir’
[16:12:54.607]   - Field: ‘workers’
[16:12:54.607]   - Field: ‘packages’
[16:12:54.607]   - Field: ‘gc’
[16:12:54.607]   - Field: ‘conditions’
[16:12:54.607]   - Field: ‘persistent’
[16:12:54.607]   - Field: ‘expr’
[16:12:54.607]   - Field: ‘uuid’
[16:12:54.607]   - Field: ‘seed’
[16:12:54.607]   - Field: ‘version’
[16:12:54.607]   - Field: ‘result’
[16:12:54.607]   - Field: ‘asynchronous’
[16:12:54.608]   - Field: ‘calls’
[16:12:54.608]   - Field: ‘globals’
[16:12:54.608]   - Field: ‘stdout’
[16:12:54.608]   - Field: ‘earlySignal’
[16:12:54.608]   - Field: ‘lazy’
[16:12:54.608]   - Field: ‘state’
[16:12:54.608] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:54.608] - Launch lazy future ...
[16:12:54.609] Packages needed by the future expression (n = 0): <none>
[16:12:54.609] Packages needed by future strategies (n = 0): <none>
[16:12:54.609] {
[16:12:54.609]     {
[16:12:54.609]         {
[16:12:54.609]             ...future.startTime <- base::Sys.time()
[16:12:54.609]             {
[16:12:54.609]                 {
[16:12:54.609]                   {
[16:12:54.609]                     {
[16:12:54.609]                       base::local({
[16:12:54.609]                         has_future <- base::requireNamespace("future", 
[16:12:54.609]                           quietly = TRUE)
[16:12:54.609]                         if (has_future) {
[16:12:54.609]                           ns <- base::getNamespace("future")
[16:12:54.609]                           version <- ns[[".package"]][["version"]]
[16:12:54.609]                           if (is.null(version)) 
[16:12:54.609]                             version <- utils::packageVersion("future")
[16:12:54.609]                         }
[16:12:54.609]                         else {
[16:12:54.609]                           version <- NULL
[16:12:54.609]                         }
[16:12:54.609]                         if (!has_future || version < "1.8.0") {
[16:12:54.609]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:54.609]                             "", base::R.version$version.string), 
[16:12:54.609]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:54.609]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:54.609]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:54.609]                               "release", "version")], collapse = " "), 
[16:12:54.609]                             hostname = base::Sys.info()[["nodename"]])
[16:12:54.609]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:54.609]                             info)
[16:12:54.609]                           info <- base::paste(info, collapse = "; ")
[16:12:54.609]                           if (!has_future) {
[16:12:54.609]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:54.609]                               info)
[16:12:54.609]                           }
[16:12:54.609]                           else {
[16:12:54.609]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:54.609]                               info, version)
[16:12:54.609]                           }
[16:12:54.609]                           base::stop(msg)
[16:12:54.609]                         }
[16:12:54.609]                       })
[16:12:54.609]                     }
[16:12:54.609]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:54.609]                     base::options(mc.cores = 1L)
[16:12:54.609]                   }
[16:12:54.609]                   options(future.plan = NULL)
[16:12:54.609]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:54.609]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:54.609]                 }
[16:12:54.609]                 ...future.workdir <- getwd()
[16:12:54.609]             }
[16:12:54.609]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:54.609]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:54.609]         }
[16:12:54.609]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:54.609]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:54.609]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:54.609]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:54.609]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:54.609]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:54.609]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:54.609]             base::names(...future.oldOptions))
[16:12:54.609]     }
[16:12:54.609]     if (FALSE) {
[16:12:54.609]     }
[16:12:54.609]     else {
[16:12:54.609]         if (TRUE) {
[16:12:54.609]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:54.609]                 open = "w")
[16:12:54.609]         }
[16:12:54.609]         else {
[16:12:54.609]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:54.609]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:54.609]         }
[16:12:54.609]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:54.609]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:54.609]             base::sink(type = "output", split = FALSE)
[16:12:54.609]             base::close(...future.stdout)
[16:12:54.609]         }, add = TRUE)
[16:12:54.609]     }
[16:12:54.609]     ...future.frame <- base::sys.nframe()
[16:12:54.609]     ...future.conditions <- base::list()
[16:12:54.609]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:54.609]     if (FALSE) {
[16:12:54.609]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:54.609]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:54.609]     }
[16:12:54.609]     ...future.result <- base::tryCatch({
[16:12:54.609]         base::withCallingHandlers({
[16:12:54.609]             ...future.value <- base::withVisible(base::local({
[16:12:54.609]                 ...future.makeSendCondition <- local({
[16:12:54.609]                   sendCondition <- NULL
[16:12:54.609]                   function(frame = 1L) {
[16:12:54.609]                     if (is.function(sendCondition)) 
[16:12:54.609]                       return(sendCondition)
[16:12:54.609]                     ns <- getNamespace("parallel")
[16:12:54.609]                     if (exists("sendData", mode = "function", 
[16:12:54.609]                       envir = ns)) {
[16:12:54.609]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:54.609]                         envir = ns)
[16:12:54.609]                       envir <- sys.frame(frame)
[16:12:54.609]                       master <- NULL
[16:12:54.609]                       while (!identical(envir, .GlobalEnv) && 
[16:12:54.609]                         !identical(envir, emptyenv())) {
[16:12:54.609]                         if (exists("master", mode = "list", envir = envir, 
[16:12:54.609]                           inherits = FALSE)) {
[16:12:54.609]                           master <- get("master", mode = "list", 
[16:12:54.609]                             envir = envir, inherits = FALSE)
[16:12:54.609]                           if (inherits(master, c("SOCKnode", 
[16:12:54.609]                             "SOCK0node"))) {
[16:12:54.609]                             sendCondition <<- function(cond) {
[16:12:54.609]                               data <- list(type = "VALUE", value = cond, 
[16:12:54.609]                                 success = TRUE)
[16:12:54.609]                               parallel_sendData(master, data)
[16:12:54.609]                             }
[16:12:54.609]                             return(sendCondition)
[16:12:54.609]                           }
[16:12:54.609]                         }
[16:12:54.609]                         frame <- frame + 1L
[16:12:54.609]                         envir <- sys.frame(frame)
[16:12:54.609]                       }
[16:12:54.609]                     }
[16:12:54.609]                     sendCondition <<- function(cond) NULL
[16:12:54.609]                   }
[16:12:54.609]                 })
[16:12:54.609]                 withCallingHandlers({
[16:12:54.609]                   1
[16:12:54.609]                 }, immediateCondition = function(cond) {
[16:12:54.609]                   sendCondition <- ...future.makeSendCondition()
[16:12:54.609]                   sendCondition(cond)
[16:12:54.609]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.609]                   {
[16:12:54.609]                     inherits <- base::inherits
[16:12:54.609]                     invokeRestart <- base::invokeRestart
[16:12:54.609]                     is.null <- base::is.null
[16:12:54.609]                     muffled <- FALSE
[16:12:54.609]                     if (inherits(cond, "message")) {
[16:12:54.609]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:54.609]                       if (muffled) 
[16:12:54.609]                         invokeRestart("muffleMessage")
[16:12:54.609]                     }
[16:12:54.609]                     else if (inherits(cond, "warning")) {
[16:12:54.609]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:54.609]                       if (muffled) 
[16:12:54.609]                         invokeRestart("muffleWarning")
[16:12:54.609]                     }
[16:12:54.609]                     else if (inherits(cond, "condition")) {
[16:12:54.609]                       if (!is.null(pattern)) {
[16:12:54.609]                         computeRestarts <- base::computeRestarts
[16:12:54.609]                         grepl <- base::grepl
[16:12:54.609]                         restarts <- computeRestarts(cond)
[16:12:54.609]                         for (restart in restarts) {
[16:12:54.609]                           name <- restart$name
[16:12:54.609]                           if (is.null(name)) 
[16:12:54.609]                             next
[16:12:54.609]                           if (!grepl(pattern, name)) 
[16:12:54.609]                             next
[16:12:54.609]                           invokeRestart(restart)
[16:12:54.609]                           muffled <- TRUE
[16:12:54.609]                           break
[16:12:54.609]                         }
[16:12:54.609]                       }
[16:12:54.609]                     }
[16:12:54.609]                     invisible(muffled)
[16:12:54.609]                   }
[16:12:54.609]                   muffleCondition(cond)
[16:12:54.609]                 })
[16:12:54.609]             }))
[16:12:54.609]             future::FutureResult(value = ...future.value$value, 
[16:12:54.609]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:54.609]                   ...future.rng), globalenv = if (FALSE) 
[16:12:54.609]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:54.609]                     ...future.globalenv.names))
[16:12:54.609]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:54.609]         }, condition = base::local({
[16:12:54.609]             c <- base::c
[16:12:54.609]             inherits <- base::inherits
[16:12:54.609]             invokeRestart <- base::invokeRestart
[16:12:54.609]             length <- base::length
[16:12:54.609]             list <- base::list
[16:12:54.609]             seq.int <- base::seq.int
[16:12:54.609]             signalCondition <- base::signalCondition
[16:12:54.609]             sys.calls <- base::sys.calls
[16:12:54.609]             `[[` <- base::`[[`
[16:12:54.609]             `+` <- base::`+`
[16:12:54.609]             `<<-` <- base::`<<-`
[16:12:54.609]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:54.609]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:54.609]                   3L)]
[16:12:54.609]             }
[16:12:54.609]             function(cond) {
[16:12:54.609]                 is_error <- inherits(cond, "error")
[16:12:54.609]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:54.609]                   NULL)
[16:12:54.609]                 if (is_error) {
[16:12:54.609]                   sessionInformation <- function() {
[16:12:54.609]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:54.609]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:54.609]                       search = base::search(), system = base::Sys.info())
[16:12:54.609]                   }
[16:12:54.609]                   ...future.conditions[[length(...future.conditions) + 
[16:12:54.609]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:54.609]                     cond$call), session = sessionInformation(), 
[16:12:54.609]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:54.609]                   signalCondition(cond)
[16:12:54.609]                 }
[16:12:54.609]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:54.609]                 "immediateCondition"))) {
[16:12:54.609]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:54.609]                   ...future.conditions[[length(...future.conditions) + 
[16:12:54.609]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:54.609]                   if (TRUE && !signal) {
[16:12:54.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.609]                     {
[16:12:54.609]                       inherits <- base::inherits
[16:12:54.609]                       invokeRestart <- base::invokeRestart
[16:12:54.609]                       is.null <- base::is.null
[16:12:54.609]                       muffled <- FALSE
[16:12:54.609]                       if (inherits(cond, "message")) {
[16:12:54.609]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:54.609]                         if (muffled) 
[16:12:54.609]                           invokeRestart("muffleMessage")
[16:12:54.609]                       }
[16:12:54.609]                       else if (inherits(cond, "warning")) {
[16:12:54.609]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:54.609]                         if (muffled) 
[16:12:54.609]                           invokeRestart("muffleWarning")
[16:12:54.609]                       }
[16:12:54.609]                       else if (inherits(cond, "condition")) {
[16:12:54.609]                         if (!is.null(pattern)) {
[16:12:54.609]                           computeRestarts <- base::computeRestarts
[16:12:54.609]                           grepl <- base::grepl
[16:12:54.609]                           restarts <- computeRestarts(cond)
[16:12:54.609]                           for (restart in restarts) {
[16:12:54.609]                             name <- restart$name
[16:12:54.609]                             if (is.null(name)) 
[16:12:54.609]                               next
[16:12:54.609]                             if (!grepl(pattern, name)) 
[16:12:54.609]                               next
[16:12:54.609]                             invokeRestart(restart)
[16:12:54.609]                             muffled <- TRUE
[16:12:54.609]                             break
[16:12:54.609]                           }
[16:12:54.609]                         }
[16:12:54.609]                       }
[16:12:54.609]                       invisible(muffled)
[16:12:54.609]                     }
[16:12:54.609]                     muffleCondition(cond, pattern = "^muffle")
[16:12:54.609]                   }
[16:12:54.609]                 }
[16:12:54.609]                 else {
[16:12:54.609]                   if (TRUE) {
[16:12:54.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.609]                     {
[16:12:54.609]                       inherits <- base::inherits
[16:12:54.609]                       invokeRestart <- base::invokeRestart
[16:12:54.609]                       is.null <- base::is.null
[16:12:54.609]                       muffled <- FALSE
[16:12:54.609]                       if (inherits(cond, "message")) {
[16:12:54.609]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:54.609]                         if (muffled) 
[16:12:54.609]                           invokeRestart("muffleMessage")
[16:12:54.609]                       }
[16:12:54.609]                       else if (inherits(cond, "warning")) {
[16:12:54.609]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:54.609]                         if (muffled) 
[16:12:54.609]                           invokeRestart("muffleWarning")
[16:12:54.609]                       }
[16:12:54.609]                       else if (inherits(cond, "condition")) {
[16:12:54.609]                         if (!is.null(pattern)) {
[16:12:54.609]                           computeRestarts <- base::computeRestarts
[16:12:54.609]                           grepl <- base::grepl
[16:12:54.609]                           restarts <- computeRestarts(cond)
[16:12:54.609]                           for (restart in restarts) {
[16:12:54.609]                             name <- restart$name
[16:12:54.609]                             if (is.null(name)) 
[16:12:54.609]                               next
[16:12:54.609]                             if (!grepl(pattern, name)) 
[16:12:54.609]                               next
[16:12:54.609]                             invokeRestart(restart)
[16:12:54.609]                             muffled <- TRUE
[16:12:54.609]                             break
[16:12:54.609]                           }
[16:12:54.609]                         }
[16:12:54.609]                       }
[16:12:54.609]                       invisible(muffled)
[16:12:54.609]                     }
[16:12:54.609]                     muffleCondition(cond, pattern = "^muffle")
[16:12:54.609]                   }
[16:12:54.609]                 }
[16:12:54.609]             }
[16:12:54.609]         }))
[16:12:54.609]     }, error = function(ex) {
[16:12:54.609]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:54.609]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:54.609]                 ...future.rng), started = ...future.startTime, 
[16:12:54.609]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:54.609]             version = "1.8"), class = "FutureResult")
[16:12:54.609]     }, finally = {
[16:12:54.609]         if (!identical(...future.workdir, getwd())) 
[16:12:54.609]             setwd(...future.workdir)
[16:12:54.609]         {
[16:12:54.609]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:54.609]                 ...future.oldOptions$nwarnings <- NULL
[16:12:54.609]             }
[16:12:54.609]             base::options(...future.oldOptions)
[16:12:54.609]             if (.Platform$OS.type == "windows") {
[16:12:54.609]                 old_names <- names(...future.oldEnvVars)
[16:12:54.609]                 envs <- base::Sys.getenv()
[16:12:54.609]                 names <- names(envs)
[16:12:54.609]                 common <- intersect(names, old_names)
[16:12:54.609]                 added <- setdiff(names, old_names)
[16:12:54.609]                 removed <- setdiff(old_names, names)
[16:12:54.609]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:54.609]                   envs[common]]
[16:12:54.609]                 NAMES <- toupper(changed)
[16:12:54.609]                 args <- list()
[16:12:54.609]                 for (kk in seq_along(NAMES)) {
[16:12:54.609]                   name <- changed[[kk]]
[16:12:54.609]                   NAME <- NAMES[[kk]]
[16:12:54.609]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.609]                     next
[16:12:54.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:54.609]                 }
[16:12:54.609]                 NAMES <- toupper(added)
[16:12:54.609]                 for (kk in seq_along(NAMES)) {
[16:12:54.609]                   name <- added[[kk]]
[16:12:54.609]                   NAME <- NAMES[[kk]]
[16:12:54.609]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.609]                     next
[16:12:54.609]                   args[[name]] <- ""
[16:12:54.609]                 }
[16:12:54.609]                 NAMES <- toupper(removed)
[16:12:54.609]                 for (kk in seq_along(NAMES)) {
[16:12:54.609]                   name <- removed[[kk]]
[16:12:54.609]                   NAME <- NAMES[[kk]]
[16:12:54.609]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.609]                     next
[16:12:54.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:54.609]                 }
[16:12:54.609]                 if (length(args) > 0) 
[16:12:54.609]                   base::do.call(base::Sys.setenv, args = args)
[16:12:54.609]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:54.609]             }
[16:12:54.609]             else {
[16:12:54.609]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:54.609]             }
[16:12:54.609]             {
[16:12:54.609]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:54.609]                   0L) {
[16:12:54.609]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:54.609]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:54.609]                   base::options(opts)
[16:12:54.609]                 }
[16:12:54.609]                 {
[16:12:54.609]                   {
[16:12:54.609]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:54.609]                     NULL
[16:12:54.609]                   }
[16:12:54.609]                   options(future.plan = NULL)
[16:12:54.609]                   if (is.na(NA_character_)) 
[16:12:54.609]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:54.609]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:54.609]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:54.609]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:54.609]                     envir = parent.frame()) 
[16:12:54.609]                   {
[16:12:54.609]                     if (is.function(workers)) 
[16:12:54.609]                       workers <- workers()
[16:12:54.609]                     workers <- structure(as.integer(workers), 
[16:12:54.609]                       class = class(workers))
[16:12:54.609]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:54.609]                       workers >= 1)
[16:12:54.609]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:54.609]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:54.609]                     }
[16:12:54.609]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:54.609]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:54.609]                       envir = envir)
[16:12:54.609]                     if (!future$lazy) 
[16:12:54.609]                       future <- run(future)
[16:12:54.609]                     invisible(future)
[16:12:54.609]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:54.609]                 }
[16:12:54.609]             }
[16:12:54.609]         }
[16:12:54.609]     })
[16:12:54.609]     if (TRUE) {
[16:12:54.609]         base::sink(type = "output", split = FALSE)
[16:12:54.609]         if (TRUE) {
[16:12:54.609]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:54.609]         }
[16:12:54.609]         else {
[16:12:54.609]             ...future.result["stdout"] <- base::list(NULL)
[16:12:54.609]         }
[16:12:54.609]         base::close(...future.stdout)
[16:12:54.609]         ...future.stdout <- NULL
[16:12:54.609]     }
[16:12:54.609]     ...future.result$conditions <- ...future.conditions
[16:12:54.609]     ...future.result$finished <- base::Sys.time()
[16:12:54.609]     ...future.result
[16:12:54.609] }
[16:12:54.612] MultisessionFuture started
[16:12:54.612] - Launch lazy future ... done
[16:12:54.613] run() for ‘MultisessionFuture’ ... done
[16:12:54.661] receiveMessageFromWorker() for ClusterFuture ...
[16:12:54.661] - Validating connection of MultisessionFuture
[16:12:54.661] - received message: FutureResult
[16:12:54.662] - Received FutureResult
[16:12:54.662] - Erased future from FutureRegistry
[16:12:54.662] result() for ClusterFuture ...
[16:12:54.662] - result already collected: FutureResult
[16:12:54.662] result() for ClusterFuture ... done
[16:12:54.662] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:54.662] Future #1
[16:12:54.662] result() for ClusterFuture ...
[16:12:54.662] - result already collected: FutureResult
[16:12:54.662] result() for ClusterFuture ... done
[16:12:54.663] result() for ClusterFuture ...
[16:12:54.663] - result already collected: FutureResult
[16:12:54.663] result() for ClusterFuture ... done
[16:12:54.663] A MultisessionFuture was resolved
[16:12:54.663]  length: 0 (resolved future 1)
[16:12:54.663] resolve() on list ... DONE
[16:12:54.663] - globals: [1] ‘a’
[16:12:54.663] Resolving futures part of globals (recursively) ... DONE
[16:12:54.664] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[16:12:54.665] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[16:12:54.665] - globals: [1] ‘a’
[16:12:54.665] - packages: [1] ‘future’
[16:12:54.665] getGlobalsAndPackages() ... DONE
[16:12:54.665] run() for ‘Future’ ...
[16:12:54.665] - state: ‘created’
[16:12:54.666] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:54.680] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:54.680] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:54.680]   - Field: ‘node’
[16:12:54.680]   - Field: ‘label’
[16:12:54.680]   - Field: ‘local’
[16:12:54.681]   - Field: ‘owner’
[16:12:54.681]   - Field: ‘envir’
[16:12:54.681]   - Field: ‘workers’
[16:12:54.681]   - Field: ‘packages’
[16:12:54.681]   - Field: ‘gc’
[16:12:54.681]   - Field: ‘conditions’
[16:12:54.681]   - Field: ‘persistent’
[16:12:54.681]   - Field: ‘expr’
[16:12:54.681]   - Field: ‘uuid’
[16:12:54.681]   - Field: ‘seed’
[16:12:54.681]   - Field: ‘version’
[16:12:54.682]   - Field: ‘result’
[16:12:54.682]   - Field: ‘asynchronous’
[16:12:54.682]   - Field: ‘calls’
[16:12:54.682]   - Field: ‘globals’
[16:12:54.682]   - Field: ‘stdout’
[16:12:54.682]   - Field: ‘earlySignal’
[16:12:54.682]   - Field: ‘lazy’
[16:12:54.682]   - Field: ‘state’
[16:12:54.682] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:54.682] - Launch lazy future ...
[16:12:54.683] Packages needed by the future expression (n = 1): ‘future’
[16:12:54.683] Packages needed by future strategies (n = 0): <none>
[16:12:54.683] {
[16:12:54.683]     {
[16:12:54.683]         {
[16:12:54.683]             ...future.startTime <- base::Sys.time()
[16:12:54.683]             {
[16:12:54.683]                 {
[16:12:54.683]                   {
[16:12:54.683]                     {
[16:12:54.683]                       {
[16:12:54.683]                         base::local({
[16:12:54.683]                           has_future <- base::requireNamespace("future", 
[16:12:54.683]                             quietly = TRUE)
[16:12:54.683]                           if (has_future) {
[16:12:54.683]                             ns <- base::getNamespace("future")
[16:12:54.683]                             version <- ns[[".package"]][["version"]]
[16:12:54.683]                             if (is.null(version)) 
[16:12:54.683]                               version <- utils::packageVersion("future")
[16:12:54.683]                           }
[16:12:54.683]                           else {
[16:12:54.683]                             version <- NULL
[16:12:54.683]                           }
[16:12:54.683]                           if (!has_future || version < "1.8.0") {
[16:12:54.683]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:54.683]                               "", base::R.version$version.string), 
[16:12:54.683]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:54.683]                                 base::R.version$platform, 8 * 
[16:12:54.683]                                   base::.Machine$sizeof.pointer), 
[16:12:54.683]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:54.683]                                 "release", "version")], collapse = " "), 
[16:12:54.683]                               hostname = base::Sys.info()[["nodename"]])
[16:12:54.683]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:54.683]                               info)
[16:12:54.683]                             info <- base::paste(info, collapse = "; ")
[16:12:54.683]                             if (!has_future) {
[16:12:54.683]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:54.683]                                 info)
[16:12:54.683]                             }
[16:12:54.683]                             else {
[16:12:54.683]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:54.683]                                 info, version)
[16:12:54.683]                             }
[16:12:54.683]                             base::stop(msg)
[16:12:54.683]                           }
[16:12:54.683]                         })
[16:12:54.683]                       }
[16:12:54.683]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:54.683]                       base::options(mc.cores = 1L)
[16:12:54.683]                     }
[16:12:54.683]                     base::local({
[16:12:54.683]                       for (pkg in "future") {
[16:12:54.683]                         base::loadNamespace(pkg)
[16:12:54.683]                         base::library(pkg, character.only = TRUE)
[16:12:54.683]                       }
[16:12:54.683]                     })
[16:12:54.683]                   }
[16:12:54.683]                   options(future.plan = NULL)
[16:12:54.683]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:54.683]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:54.683]                 }
[16:12:54.683]                 ...future.workdir <- getwd()
[16:12:54.683]             }
[16:12:54.683]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:54.683]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:54.683]         }
[16:12:54.683]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:54.683]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:54.683]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:54.683]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:54.683]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:54.683]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:54.683]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:54.683]             base::names(...future.oldOptions))
[16:12:54.683]     }
[16:12:54.683]     if (FALSE) {
[16:12:54.683]     }
[16:12:54.683]     else {
[16:12:54.683]         if (TRUE) {
[16:12:54.683]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:54.683]                 open = "w")
[16:12:54.683]         }
[16:12:54.683]         else {
[16:12:54.683]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:54.683]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:54.683]         }
[16:12:54.683]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:54.683]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:54.683]             base::sink(type = "output", split = FALSE)
[16:12:54.683]             base::close(...future.stdout)
[16:12:54.683]         }, add = TRUE)
[16:12:54.683]     }
[16:12:54.683]     ...future.frame <- base::sys.nframe()
[16:12:54.683]     ...future.conditions <- base::list()
[16:12:54.683]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:54.683]     if (FALSE) {
[16:12:54.683]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:54.683]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:54.683]     }
[16:12:54.683]     ...future.result <- base::tryCatch({
[16:12:54.683]         base::withCallingHandlers({
[16:12:54.683]             ...future.value <- base::withVisible(base::local({
[16:12:54.683]                 ...future.makeSendCondition <- local({
[16:12:54.683]                   sendCondition <- NULL
[16:12:54.683]                   function(frame = 1L) {
[16:12:54.683]                     if (is.function(sendCondition)) 
[16:12:54.683]                       return(sendCondition)
[16:12:54.683]                     ns <- getNamespace("parallel")
[16:12:54.683]                     if (exists("sendData", mode = "function", 
[16:12:54.683]                       envir = ns)) {
[16:12:54.683]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:54.683]                         envir = ns)
[16:12:54.683]                       envir <- sys.frame(frame)
[16:12:54.683]                       master <- NULL
[16:12:54.683]                       while (!identical(envir, .GlobalEnv) && 
[16:12:54.683]                         !identical(envir, emptyenv())) {
[16:12:54.683]                         if (exists("master", mode = "list", envir = envir, 
[16:12:54.683]                           inherits = FALSE)) {
[16:12:54.683]                           master <- get("master", mode = "list", 
[16:12:54.683]                             envir = envir, inherits = FALSE)
[16:12:54.683]                           if (inherits(master, c("SOCKnode", 
[16:12:54.683]                             "SOCK0node"))) {
[16:12:54.683]                             sendCondition <<- function(cond) {
[16:12:54.683]                               data <- list(type = "VALUE", value = cond, 
[16:12:54.683]                                 success = TRUE)
[16:12:54.683]                               parallel_sendData(master, data)
[16:12:54.683]                             }
[16:12:54.683]                             return(sendCondition)
[16:12:54.683]                           }
[16:12:54.683]                         }
[16:12:54.683]                         frame <- frame + 1L
[16:12:54.683]                         envir <- sys.frame(frame)
[16:12:54.683]                       }
[16:12:54.683]                     }
[16:12:54.683]                     sendCondition <<- function(cond) NULL
[16:12:54.683]                   }
[16:12:54.683]                 })
[16:12:54.683]                 withCallingHandlers({
[16:12:54.683]                   value(a) + 1
[16:12:54.683]                 }, immediateCondition = function(cond) {
[16:12:54.683]                   sendCondition <- ...future.makeSendCondition()
[16:12:54.683]                   sendCondition(cond)
[16:12:54.683]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.683]                   {
[16:12:54.683]                     inherits <- base::inherits
[16:12:54.683]                     invokeRestart <- base::invokeRestart
[16:12:54.683]                     is.null <- base::is.null
[16:12:54.683]                     muffled <- FALSE
[16:12:54.683]                     if (inherits(cond, "message")) {
[16:12:54.683]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:54.683]                       if (muffled) 
[16:12:54.683]                         invokeRestart("muffleMessage")
[16:12:54.683]                     }
[16:12:54.683]                     else if (inherits(cond, "warning")) {
[16:12:54.683]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:54.683]                       if (muffled) 
[16:12:54.683]                         invokeRestart("muffleWarning")
[16:12:54.683]                     }
[16:12:54.683]                     else if (inherits(cond, "condition")) {
[16:12:54.683]                       if (!is.null(pattern)) {
[16:12:54.683]                         computeRestarts <- base::computeRestarts
[16:12:54.683]                         grepl <- base::grepl
[16:12:54.683]                         restarts <- computeRestarts(cond)
[16:12:54.683]                         for (restart in restarts) {
[16:12:54.683]                           name <- restart$name
[16:12:54.683]                           if (is.null(name)) 
[16:12:54.683]                             next
[16:12:54.683]                           if (!grepl(pattern, name)) 
[16:12:54.683]                             next
[16:12:54.683]                           invokeRestart(restart)
[16:12:54.683]                           muffled <- TRUE
[16:12:54.683]                           break
[16:12:54.683]                         }
[16:12:54.683]                       }
[16:12:54.683]                     }
[16:12:54.683]                     invisible(muffled)
[16:12:54.683]                   }
[16:12:54.683]                   muffleCondition(cond)
[16:12:54.683]                 })
[16:12:54.683]             }))
[16:12:54.683]             future::FutureResult(value = ...future.value$value, 
[16:12:54.683]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:54.683]                   ...future.rng), globalenv = if (FALSE) 
[16:12:54.683]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:54.683]                     ...future.globalenv.names))
[16:12:54.683]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:54.683]         }, condition = base::local({
[16:12:54.683]             c <- base::c
[16:12:54.683]             inherits <- base::inherits
[16:12:54.683]             invokeRestart <- base::invokeRestart
[16:12:54.683]             length <- base::length
[16:12:54.683]             list <- base::list
[16:12:54.683]             seq.int <- base::seq.int
[16:12:54.683]             signalCondition <- base::signalCondition
[16:12:54.683]             sys.calls <- base::sys.calls
[16:12:54.683]             `[[` <- base::`[[`
[16:12:54.683]             `+` <- base::`+`
[16:12:54.683]             `<<-` <- base::`<<-`
[16:12:54.683]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:54.683]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:54.683]                   3L)]
[16:12:54.683]             }
[16:12:54.683]             function(cond) {
[16:12:54.683]                 is_error <- inherits(cond, "error")
[16:12:54.683]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:54.683]                   NULL)
[16:12:54.683]                 if (is_error) {
[16:12:54.683]                   sessionInformation <- function() {
[16:12:54.683]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:54.683]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:54.683]                       search = base::search(), system = base::Sys.info())
[16:12:54.683]                   }
[16:12:54.683]                   ...future.conditions[[length(...future.conditions) + 
[16:12:54.683]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:54.683]                     cond$call), session = sessionInformation(), 
[16:12:54.683]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:54.683]                   signalCondition(cond)
[16:12:54.683]                 }
[16:12:54.683]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:54.683]                 "immediateCondition"))) {
[16:12:54.683]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:54.683]                   ...future.conditions[[length(...future.conditions) + 
[16:12:54.683]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:54.683]                   if (TRUE && !signal) {
[16:12:54.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.683]                     {
[16:12:54.683]                       inherits <- base::inherits
[16:12:54.683]                       invokeRestart <- base::invokeRestart
[16:12:54.683]                       is.null <- base::is.null
[16:12:54.683]                       muffled <- FALSE
[16:12:54.683]                       if (inherits(cond, "message")) {
[16:12:54.683]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:54.683]                         if (muffled) 
[16:12:54.683]                           invokeRestart("muffleMessage")
[16:12:54.683]                       }
[16:12:54.683]                       else if (inherits(cond, "warning")) {
[16:12:54.683]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:54.683]                         if (muffled) 
[16:12:54.683]                           invokeRestart("muffleWarning")
[16:12:54.683]                       }
[16:12:54.683]                       else if (inherits(cond, "condition")) {
[16:12:54.683]                         if (!is.null(pattern)) {
[16:12:54.683]                           computeRestarts <- base::computeRestarts
[16:12:54.683]                           grepl <- base::grepl
[16:12:54.683]                           restarts <- computeRestarts(cond)
[16:12:54.683]                           for (restart in restarts) {
[16:12:54.683]                             name <- restart$name
[16:12:54.683]                             if (is.null(name)) 
[16:12:54.683]                               next
[16:12:54.683]                             if (!grepl(pattern, name)) 
[16:12:54.683]                               next
[16:12:54.683]                             invokeRestart(restart)
[16:12:54.683]                             muffled <- TRUE
[16:12:54.683]                             break
[16:12:54.683]                           }
[16:12:54.683]                         }
[16:12:54.683]                       }
[16:12:54.683]                       invisible(muffled)
[16:12:54.683]                     }
[16:12:54.683]                     muffleCondition(cond, pattern = "^muffle")
[16:12:54.683]                   }
[16:12:54.683]                 }
[16:12:54.683]                 else {
[16:12:54.683]                   if (TRUE) {
[16:12:54.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.683]                     {
[16:12:54.683]                       inherits <- base::inherits
[16:12:54.683]                       invokeRestart <- base::invokeRestart
[16:12:54.683]                       is.null <- base::is.null
[16:12:54.683]                       muffled <- FALSE
[16:12:54.683]                       if (inherits(cond, "message")) {
[16:12:54.683]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:54.683]                         if (muffled) 
[16:12:54.683]                           invokeRestart("muffleMessage")
[16:12:54.683]                       }
[16:12:54.683]                       else if (inherits(cond, "warning")) {
[16:12:54.683]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:54.683]                         if (muffled) 
[16:12:54.683]                           invokeRestart("muffleWarning")
[16:12:54.683]                       }
[16:12:54.683]                       else if (inherits(cond, "condition")) {
[16:12:54.683]                         if (!is.null(pattern)) {
[16:12:54.683]                           computeRestarts <- base::computeRestarts
[16:12:54.683]                           grepl <- base::grepl
[16:12:54.683]                           restarts <- computeRestarts(cond)
[16:12:54.683]                           for (restart in restarts) {
[16:12:54.683]                             name <- restart$name
[16:12:54.683]                             if (is.null(name)) 
[16:12:54.683]                               next
[16:12:54.683]                             if (!grepl(pattern, name)) 
[16:12:54.683]                               next
[16:12:54.683]                             invokeRestart(restart)
[16:12:54.683]                             muffled <- TRUE
[16:12:54.683]                             break
[16:12:54.683]                           }
[16:12:54.683]                         }
[16:12:54.683]                       }
[16:12:54.683]                       invisible(muffled)
[16:12:54.683]                     }
[16:12:54.683]                     muffleCondition(cond, pattern = "^muffle")
[16:12:54.683]                   }
[16:12:54.683]                 }
[16:12:54.683]             }
[16:12:54.683]         }))
[16:12:54.683]     }, error = function(ex) {
[16:12:54.683]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:54.683]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:54.683]                 ...future.rng), started = ...future.startTime, 
[16:12:54.683]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:54.683]             version = "1.8"), class = "FutureResult")
[16:12:54.683]     }, finally = {
[16:12:54.683]         if (!identical(...future.workdir, getwd())) 
[16:12:54.683]             setwd(...future.workdir)
[16:12:54.683]         {
[16:12:54.683]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:54.683]                 ...future.oldOptions$nwarnings <- NULL
[16:12:54.683]             }
[16:12:54.683]             base::options(...future.oldOptions)
[16:12:54.683]             if (.Platform$OS.type == "windows") {
[16:12:54.683]                 old_names <- names(...future.oldEnvVars)
[16:12:54.683]                 envs <- base::Sys.getenv()
[16:12:54.683]                 names <- names(envs)
[16:12:54.683]                 common <- intersect(names, old_names)
[16:12:54.683]                 added <- setdiff(names, old_names)
[16:12:54.683]                 removed <- setdiff(old_names, names)
[16:12:54.683]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:54.683]                   envs[common]]
[16:12:54.683]                 NAMES <- toupper(changed)
[16:12:54.683]                 args <- list()
[16:12:54.683]                 for (kk in seq_along(NAMES)) {
[16:12:54.683]                   name <- changed[[kk]]
[16:12:54.683]                   NAME <- NAMES[[kk]]
[16:12:54.683]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.683]                     next
[16:12:54.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:54.683]                 }
[16:12:54.683]                 NAMES <- toupper(added)
[16:12:54.683]                 for (kk in seq_along(NAMES)) {
[16:12:54.683]                   name <- added[[kk]]
[16:12:54.683]                   NAME <- NAMES[[kk]]
[16:12:54.683]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.683]                     next
[16:12:54.683]                   args[[name]] <- ""
[16:12:54.683]                 }
[16:12:54.683]                 NAMES <- toupper(removed)
[16:12:54.683]                 for (kk in seq_along(NAMES)) {
[16:12:54.683]                   name <- removed[[kk]]
[16:12:54.683]                   NAME <- NAMES[[kk]]
[16:12:54.683]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.683]                     next
[16:12:54.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:54.683]                 }
[16:12:54.683]                 if (length(args) > 0) 
[16:12:54.683]                   base::do.call(base::Sys.setenv, args = args)
[16:12:54.683]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:54.683]             }
[16:12:54.683]             else {
[16:12:54.683]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:54.683]             }
[16:12:54.683]             {
[16:12:54.683]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:54.683]                   0L) {
[16:12:54.683]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:54.683]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:54.683]                   base::options(opts)
[16:12:54.683]                 }
[16:12:54.683]                 {
[16:12:54.683]                   {
[16:12:54.683]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:54.683]                     NULL
[16:12:54.683]                   }
[16:12:54.683]                   options(future.plan = NULL)
[16:12:54.683]                   if (is.na(NA_character_)) 
[16:12:54.683]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:54.683]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:54.683]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:54.683]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:54.683]                     envir = parent.frame()) 
[16:12:54.683]                   {
[16:12:54.683]                     if (is.function(workers)) 
[16:12:54.683]                       workers <- workers()
[16:12:54.683]                     workers <- structure(as.integer(workers), 
[16:12:54.683]                       class = class(workers))
[16:12:54.683]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:54.683]                       workers >= 1)
[16:12:54.683]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:54.683]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:54.683]                     }
[16:12:54.683]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:54.683]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:54.683]                       envir = envir)
[16:12:54.683]                     if (!future$lazy) 
[16:12:54.683]                       future <- run(future)
[16:12:54.683]                     invisible(future)
[16:12:54.683]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:54.683]                 }
[16:12:54.683]             }
[16:12:54.683]         }
[16:12:54.683]     })
[16:12:54.683]     if (TRUE) {
[16:12:54.683]         base::sink(type = "output", split = FALSE)
[16:12:54.683]         if (TRUE) {
[16:12:54.683]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:54.683]         }
[16:12:54.683]         else {
[16:12:54.683]             ...future.result["stdout"] <- base::list(NULL)
[16:12:54.683]         }
[16:12:54.683]         base::close(...future.stdout)
[16:12:54.683]         ...future.stdout <- NULL
[16:12:54.683]     }
[16:12:54.683]     ...future.result$conditions <- ...future.conditions
[16:12:54.683]     ...future.result$finished <- base::Sys.time()
[16:12:54.683]     ...future.result
[16:12:54.683] }
[16:12:54.686] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[16:12:54.687] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[16:12:54.740] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[16:12:54.741] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[16:12:54.741] MultisessionFuture started
[16:12:54.742] - Launch lazy future ... done
[16:12:54.742] run() for ‘MultisessionFuture’ ... done
[16:12:54.742] result() for ClusterFuture ...
[16:12:54.742] receiveMessageFromWorker() for ClusterFuture ...
[16:12:54.742] - Validating connection of MultisessionFuture
[16:12:54.789] - received message: FutureResult
[16:12:54.790] - Received FutureResult
[16:12:54.790] - Erased future from FutureRegistry
[16:12:54.790] result() for ClusterFuture ...
[16:12:54.790] - result already collected: FutureResult
[16:12:54.790] result() for ClusterFuture ... done
[16:12:54.790] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:54.790] result() for ClusterFuture ... done
[16:12:54.790] result() for ClusterFuture ...
[16:12:54.790] - result already collected: FutureResult
[16:12:54.791] result() for ClusterFuture ... done
value(b) = 2
[16:12:54.791] result() for ClusterFuture ...
[16:12:54.791] - result already collected: FutureResult
[16:12:54.791] result() for ClusterFuture ... done
[16:12:54.791] result() for ClusterFuture ...
[16:12:54.791] - result already collected: FutureResult
[16:12:54.791] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:54.791] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:54.792] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[16:12:54.793] - globals found: [2] ‘{’, ‘pkg’
[16:12:54.793] Searching for globals ... DONE
[16:12:54.793] Resolving globals: TRUE
[16:12:54.793] Resolving any globals that are futures ...
[16:12:54.793] - globals: [2] ‘{’, ‘pkg’
[16:12:54.793] Resolving any globals that are futures ... DONE
[16:12:54.793] Resolving futures part of globals (recursively) ...
[16:12:54.794] resolve() on list ...
[16:12:54.794]  recursive: 99
[16:12:54.794]  length: 1
[16:12:54.794]  elements: ‘pkg’
[16:12:54.794]  length: 0 (resolved future 1)
[16:12:54.794] resolve() on list ... DONE
[16:12:54.794] - globals: [1] ‘pkg’
[16:12:54.794] Resolving futures part of globals (recursively) ... DONE
[16:12:54.794] The total size of the 1 globals is 112 bytes (112 bytes)
[16:12:54.795] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[16:12:54.795] - globals: [1] ‘pkg’
[16:12:54.795] 
[16:12:54.795] getGlobalsAndPackages() ... DONE
[16:12:54.795] Packages needed by the future expression (n = 0): <none>
[16:12:54.796] Packages needed by future strategies (n = 0): <none>
[16:12:54.796] {
[16:12:54.796]     {
[16:12:54.796]         {
[16:12:54.796]             ...future.startTime <- base::Sys.time()
[16:12:54.796]             {
[16:12:54.796]                 {
[16:12:54.796]                   {
[16:12:54.796]                     base::local({
[16:12:54.796]                       has_future <- base::requireNamespace("future", 
[16:12:54.796]                         quietly = TRUE)
[16:12:54.796]                       if (has_future) {
[16:12:54.796]                         ns <- base::getNamespace("future")
[16:12:54.796]                         version <- ns[[".package"]][["version"]]
[16:12:54.796]                         if (is.null(version)) 
[16:12:54.796]                           version <- utils::packageVersion("future")
[16:12:54.796]                       }
[16:12:54.796]                       else {
[16:12:54.796]                         version <- NULL
[16:12:54.796]                       }
[16:12:54.796]                       if (!has_future || version < "1.8.0") {
[16:12:54.796]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:54.796]                           "", base::R.version$version.string), 
[16:12:54.796]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:54.796]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:54.796]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:54.796]                             "release", "version")], collapse = " "), 
[16:12:54.796]                           hostname = base::Sys.info()[["nodename"]])
[16:12:54.796]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:54.796]                           info)
[16:12:54.796]                         info <- base::paste(info, collapse = "; ")
[16:12:54.796]                         if (!has_future) {
[16:12:54.796]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:54.796]                             info)
[16:12:54.796]                         }
[16:12:54.796]                         else {
[16:12:54.796]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:54.796]                             info, version)
[16:12:54.796]                         }
[16:12:54.796]                         base::stop(msg)
[16:12:54.796]                       }
[16:12:54.796]                     })
[16:12:54.796]                   }
[16:12:54.796]                   options(future.plan = NULL)
[16:12:54.796]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:54.796]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:54.796]                 }
[16:12:54.796]                 ...future.workdir <- getwd()
[16:12:54.796]             }
[16:12:54.796]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:54.796]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:54.796]         }
[16:12:54.796]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:54.796]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[16:12:54.796]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:54.796]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:54.796]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:54.796]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:54.796]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:54.796]             base::names(...future.oldOptions))
[16:12:54.796]     }
[16:12:54.796]     if (FALSE) {
[16:12:54.796]     }
[16:12:54.796]     else {
[16:12:54.796]         if (TRUE) {
[16:12:54.796]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:54.796]                 open = "w")
[16:12:54.796]         }
[16:12:54.796]         else {
[16:12:54.796]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:54.796]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:54.796]         }
[16:12:54.796]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:54.796]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:54.796]             base::sink(type = "output", split = FALSE)
[16:12:54.796]             base::close(...future.stdout)
[16:12:54.796]         }, add = TRUE)
[16:12:54.796]     }
[16:12:54.796]     ...future.frame <- base::sys.nframe()
[16:12:54.796]     ...future.conditions <- base::list()
[16:12:54.796]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:54.796]     if (FALSE) {
[16:12:54.796]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:54.796]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:54.796]     }
[16:12:54.796]     ...future.result <- base::tryCatch({
[16:12:54.796]         base::withCallingHandlers({
[16:12:54.796]             ...future.value <- base::withVisible(base::local({
[16:12:54.796]                 pkg
[16:12:54.796]             }))
[16:12:54.796]             future::FutureResult(value = ...future.value$value, 
[16:12:54.796]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:54.796]                   ...future.rng), globalenv = if (FALSE) 
[16:12:54.796]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:54.796]                     ...future.globalenv.names))
[16:12:54.796]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:54.796]         }, condition = base::local({
[16:12:54.796]             c <- base::c
[16:12:54.796]             inherits <- base::inherits
[16:12:54.796]             invokeRestart <- base::invokeRestart
[16:12:54.796]             length <- base::length
[16:12:54.796]             list <- base::list
[16:12:54.796]             seq.int <- base::seq.int
[16:12:54.796]             signalCondition <- base::signalCondition
[16:12:54.796]             sys.calls <- base::sys.calls
[16:12:54.796]             `[[` <- base::`[[`
[16:12:54.796]             `+` <- base::`+`
[16:12:54.796]             `<<-` <- base::`<<-`
[16:12:54.796]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:54.796]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:54.796]                   3L)]
[16:12:54.796]             }
[16:12:54.796]             function(cond) {
[16:12:54.796]                 is_error <- inherits(cond, "error")
[16:12:54.796]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:54.796]                   NULL)
[16:12:54.796]                 if (is_error) {
[16:12:54.796]                   sessionInformation <- function() {
[16:12:54.796]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:54.796]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:54.796]                       search = base::search(), system = base::Sys.info())
[16:12:54.796]                   }
[16:12:54.796]                   ...future.conditions[[length(...future.conditions) + 
[16:12:54.796]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:54.796]                     cond$call), session = sessionInformation(), 
[16:12:54.796]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:54.796]                   signalCondition(cond)
[16:12:54.796]                 }
[16:12:54.796]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:54.796]                 "immediateCondition"))) {
[16:12:54.796]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:54.796]                   ...future.conditions[[length(...future.conditions) + 
[16:12:54.796]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:54.796]                   if (TRUE && !signal) {
[16:12:54.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.796]                     {
[16:12:54.796]                       inherits <- base::inherits
[16:12:54.796]                       invokeRestart <- base::invokeRestart
[16:12:54.796]                       is.null <- base::is.null
[16:12:54.796]                       muffled <- FALSE
[16:12:54.796]                       if (inherits(cond, "message")) {
[16:12:54.796]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:54.796]                         if (muffled) 
[16:12:54.796]                           invokeRestart("muffleMessage")
[16:12:54.796]                       }
[16:12:54.796]                       else if (inherits(cond, "warning")) {
[16:12:54.796]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:54.796]                         if (muffled) 
[16:12:54.796]                           invokeRestart("muffleWarning")
[16:12:54.796]                       }
[16:12:54.796]                       else if (inherits(cond, "condition")) {
[16:12:54.796]                         if (!is.null(pattern)) {
[16:12:54.796]                           computeRestarts <- base::computeRestarts
[16:12:54.796]                           grepl <- base::grepl
[16:12:54.796]                           restarts <- computeRestarts(cond)
[16:12:54.796]                           for (restart in restarts) {
[16:12:54.796]                             name <- restart$name
[16:12:54.796]                             if (is.null(name)) 
[16:12:54.796]                               next
[16:12:54.796]                             if (!grepl(pattern, name)) 
[16:12:54.796]                               next
[16:12:54.796]                             invokeRestart(restart)
[16:12:54.796]                             muffled <- TRUE
[16:12:54.796]                             break
[16:12:54.796]                           }
[16:12:54.796]                         }
[16:12:54.796]                       }
[16:12:54.796]                       invisible(muffled)
[16:12:54.796]                     }
[16:12:54.796]                     muffleCondition(cond, pattern = "^muffle")
[16:12:54.796]                   }
[16:12:54.796]                 }
[16:12:54.796]                 else {
[16:12:54.796]                   if (TRUE) {
[16:12:54.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.796]                     {
[16:12:54.796]                       inherits <- base::inherits
[16:12:54.796]                       invokeRestart <- base::invokeRestart
[16:12:54.796]                       is.null <- base::is.null
[16:12:54.796]                       muffled <- FALSE
[16:12:54.796]                       if (inherits(cond, "message")) {
[16:12:54.796]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:54.796]                         if (muffled) 
[16:12:54.796]                           invokeRestart("muffleMessage")
[16:12:54.796]                       }
[16:12:54.796]                       else if (inherits(cond, "warning")) {
[16:12:54.796]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:54.796]                         if (muffled) 
[16:12:54.796]                           invokeRestart("muffleWarning")
[16:12:54.796]                       }
[16:12:54.796]                       else if (inherits(cond, "condition")) {
[16:12:54.796]                         if (!is.null(pattern)) {
[16:12:54.796]                           computeRestarts <- base::computeRestarts
[16:12:54.796]                           grepl <- base::grepl
[16:12:54.796]                           restarts <- computeRestarts(cond)
[16:12:54.796]                           for (restart in restarts) {
[16:12:54.796]                             name <- restart$name
[16:12:54.796]                             if (is.null(name)) 
[16:12:54.796]                               next
[16:12:54.796]                             if (!grepl(pattern, name)) 
[16:12:54.796]                               next
[16:12:54.796]                             invokeRestart(restart)
[16:12:54.796]                             muffled <- TRUE
[16:12:54.796]                             break
[16:12:54.796]                           }
[16:12:54.796]                         }
[16:12:54.796]                       }
[16:12:54.796]                       invisible(muffled)
[16:12:54.796]                     }
[16:12:54.796]                     muffleCondition(cond, pattern = "^muffle")
[16:12:54.796]                   }
[16:12:54.796]                 }
[16:12:54.796]             }
[16:12:54.796]         }))
[16:12:54.796]     }, error = function(ex) {
[16:12:54.796]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:54.796]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:54.796]                 ...future.rng), started = ...future.startTime, 
[16:12:54.796]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:54.796]             version = "1.8"), class = "FutureResult")
[16:12:54.796]     }, finally = {
[16:12:54.796]         if (!identical(...future.workdir, getwd())) 
[16:12:54.796]             setwd(...future.workdir)
[16:12:54.796]         {
[16:12:54.796]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:54.796]                 ...future.oldOptions$nwarnings <- NULL
[16:12:54.796]             }
[16:12:54.796]             base::options(...future.oldOptions)
[16:12:54.796]             if (.Platform$OS.type == "windows") {
[16:12:54.796]                 old_names <- names(...future.oldEnvVars)
[16:12:54.796]                 envs <- base::Sys.getenv()
[16:12:54.796]                 names <- names(envs)
[16:12:54.796]                 common <- intersect(names, old_names)
[16:12:54.796]                 added <- setdiff(names, old_names)
[16:12:54.796]                 removed <- setdiff(old_names, names)
[16:12:54.796]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:54.796]                   envs[common]]
[16:12:54.796]                 NAMES <- toupper(changed)
[16:12:54.796]                 args <- list()
[16:12:54.796]                 for (kk in seq_along(NAMES)) {
[16:12:54.796]                   name <- changed[[kk]]
[16:12:54.796]                   NAME <- NAMES[[kk]]
[16:12:54.796]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.796]                     next
[16:12:54.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:54.796]                 }
[16:12:54.796]                 NAMES <- toupper(added)
[16:12:54.796]                 for (kk in seq_along(NAMES)) {
[16:12:54.796]                   name <- added[[kk]]
[16:12:54.796]                   NAME <- NAMES[[kk]]
[16:12:54.796]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.796]                     next
[16:12:54.796]                   args[[name]] <- ""
[16:12:54.796]                 }
[16:12:54.796]                 NAMES <- toupper(removed)
[16:12:54.796]                 for (kk in seq_along(NAMES)) {
[16:12:54.796]                   name <- removed[[kk]]
[16:12:54.796]                   NAME <- NAMES[[kk]]
[16:12:54.796]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.796]                     next
[16:12:54.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:54.796]                 }
[16:12:54.796]                 if (length(args) > 0) 
[16:12:54.796]                   base::do.call(base::Sys.setenv, args = args)
[16:12:54.796]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:54.796]             }
[16:12:54.796]             else {
[16:12:54.796]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:54.796]             }
[16:12:54.796]             {
[16:12:54.796]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:54.796]                   0L) {
[16:12:54.796]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:54.796]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:54.796]                   base::options(opts)
[16:12:54.796]                 }
[16:12:54.796]                 {
[16:12:54.796]                   {
[16:12:54.796]                     NULL
[16:12:54.796]                     RNGkind("Mersenne-Twister")
[16:12:54.796]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:54.796]                       inherits = FALSE)
[16:12:54.796]                   }
[16:12:54.796]                   options(future.plan = NULL)
[16:12:54.796]                   if (is.na(NA_character_)) 
[16:12:54.796]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:54.796]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:54.796]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:54.796]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:54.796]                     envir = parent.frame()) 
[16:12:54.796]                   {
[16:12:54.796]                     if (is.function(workers)) 
[16:12:54.796]                       workers <- workers()
[16:12:54.796]                     workers <- structure(as.integer(workers), 
[16:12:54.796]                       class = class(workers))
[16:12:54.796]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:54.796]                       workers >= 1)
[16:12:54.796]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:54.796]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:54.796]                     }
[16:12:54.796]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:54.796]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:54.796]                       envir = envir)
[16:12:54.796]                     if (!future$lazy) 
[16:12:54.796]                       future <- run(future)
[16:12:54.796]                     invisible(future)
[16:12:54.796]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:54.796]                 }
[16:12:54.796]             }
[16:12:54.796]         }
[16:12:54.796]     })
[16:12:54.796]     if (TRUE) {
[16:12:54.796]         base::sink(type = "output", split = FALSE)
[16:12:54.796]         if (TRUE) {
[16:12:54.796]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:54.796]         }
[16:12:54.796]         else {
[16:12:54.796]             ...future.result["stdout"] <- base::list(NULL)
[16:12:54.796]         }
[16:12:54.796]         base::close(...future.stdout)
[16:12:54.796]         ...future.stdout <- NULL
[16:12:54.796]     }
[16:12:54.796]     ...future.result$conditions <- ...future.conditions
[16:12:54.796]     ...future.result$finished <- base::Sys.time()
[16:12:54.796]     ...future.result
[16:12:54.796] }
[16:12:54.798] assign_globals() ...
[16:12:54.798] List of 1
[16:12:54.798]  $ pkg: chr "foo"
[16:12:54.798]  - attr(*, "where")=List of 1
[16:12:54.798]   ..$ pkg:<environment: R_EmptyEnv> 
[16:12:54.798]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:54.798]  - attr(*, "resolved")= logi TRUE
[16:12:54.798]  - attr(*, "total_size")= num 112
[16:12:54.800] - copied ‘pkg’ to environment
[16:12:54.800] assign_globals() ... done
[16:12:54.801] plan(): Setting new future strategy stack:
[16:12:54.801] List of future strategies:
[16:12:54.801] 1. sequential:
[16:12:54.801]    - args: function (..., envir = parent.frame())
[16:12:54.801]    - tweaked: FALSE
[16:12:54.801]    - call: NULL
[16:12:54.801] plan(): nbrOfWorkers() = 1
[16:12:54.802] plan(): Setting new future strategy stack:
[16:12:54.802] List of future strategies:
[16:12:54.802] 1. multisession:
[16:12:54.802]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:12:54.802]    - tweaked: FALSE
[16:12:54.802]    - call: plan(strategy)
[16:12:54.806] plan(): nbrOfWorkers() = 2
[16:12:54.806] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:54.806] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:54.807] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:54.808] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:12:54.809] Searching for globals ... DONE
[16:12:54.809] Resolving globals: TRUE
[16:12:54.809] Resolving any globals that are futures ...
[16:12:54.809] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:12:54.809] Resolving any globals that are futures ... DONE
[16:12:54.809] Resolving futures part of globals (recursively) ...
[16:12:54.810] resolve() on list ...
[16:12:54.810]  recursive: 99
[16:12:54.810]  length: 1
[16:12:54.810]  elements: ‘a’
[16:12:54.810]  length: 0 (resolved future 1)
[16:12:54.810] resolve() on list ... DONE
[16:12:54.810] - globals: [1] ‘a’
[16:12:54.810] Resolving futures part of globals (recursively) ... DONE
[16:12:54.810] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:54.811] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:12:54.811] - globals: [1] ‘a’
[16:12:54.811] 
[16:12:54.811] getGlobalsAndPackages() ... DONE
[16:12:54.811] run() for ‘Future’ ...
[16:12:54.811] - state: ‘created’
[16:12:54.811] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:54.826] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:54.826] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:54.826]   - Field: ‘node’
[16:12:54.826]   - Field: ‘label’
[16:12:54.826]   - Field: ‘local’
[16:12:54.826]   - Field: ‘owner’
[16:12:54.826]   - Field: ‘envir’
[16:12:54.827]   - Field: ‘workers’
[16:12:54.827]   - Field: ‘packages’
[16:12:54.827]   - Field: ‘gc’
[16:12:54.827]   - Field: ‘conditions’
[16:12:54.827]   - Field: ‘persistent’
[16:12:54.827]   - Field: ‘expr’
[16:12:54.827]   - Field: ‘uuid’
[16:12:54.827]   - Field: ‘seed’
[16:12:54.827]   - Field: ‘version’
[16:12:54.827]   - Field: ‘result’
[16:12:54.827]   - Field: ‘asynchronous’
[16:12:54.828]   - Field: ‘calls’
[16:12:54.828]   - Field: ‘globals’
[16:12:54.828]   - Field: ‘stdout’
[16:12:54.828]   - Field: ‘earlySignal’
[16:12:54.828]   - Field: ‘lazy’
[16:12:54.828]   - Field: ‘state’
[16:12:54.828] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:54.828] - Launch lazy future ...
[16:12:54.829] Packages needed by the future expression (n = 0): <none>
[16:12:54.829] Packages needed by future strategies (n = 0): <none>
[16:12:54.829] {
[16:12:54.829]     {
[16:12:54.829]         {
[16:12:54.829]             ...future.startTime <- base::Sys.time()
[16:12:54.829]             {
[16:12:54.829]                 {
[16:12:54.829]                   {
[16:12:54.829]                     {
[16:12:54.829]                       base::local({
[16:12:54.829]                         has_future <- base::requireNamespace("future", 
[16:12:54.829]                           quietly = TRUE)
[16:12:54.829]                         if (has_future) {
[16:12:54.829]                           ns <- base::getNamespace("future")
[16:12:54.829]                           version <- ns[[".package"]][["version"]]
[16:12:54.829]                           if (is.null(version)) 
[16:12:54.829]                             version <- utils::packageVersion("future")
[16:12:54.829]                         }
[16:12:54.829]                         else {
[16:12:54.829]                           version <- NULL
[16:12:54.829]                         }
[16:12:54.829]                         if (!has_future || version < "1.8.0") {
[16:12:54.829]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:54.829]                             "", base::R.version$version.string), 
[16:12:54.829]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:54.829]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:54.829]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:54.829]                               "release", "version")], collapse = " "), 
[16:12:54.829]                             hostname = base::Sys.info()[["nodename"]])
[16:12:54.829]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:54.829]                             info)
[16:12:54.829]                           info <- base::paste(info, collapse = "; ")
[16:12:54.829]                           if (!has_future) {
[16:12:54.829]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:54.829]                               info)
[16:12:54.829]                           }
[16:12:54.829]                           else {
[16:12:54.829]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:54.829]                               info, version)
[16:12:54.829]                           }
[16:12:54.829]                           base::stop(msg)
[16:12:54.829]                         }
[16:12:54.829]                       })
[16:12:54.829]                     }
[16:12:54.829]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:54.829]                     base::options(mc.cores = 1L)
[16:12:54.829]                   }
[16:12:54.829]                   options(future.plan = NULL)
[16:12:54.829]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:54.829]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:54.829]                 }
[16:12:54.829]                 ...future.workdir <- getwd()
[16:12:54.829]             }
[16:12:54.829]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:54.829]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:54.829]         }
[16:12:54.829]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:54.829]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:54.829]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:54.829]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:54.829]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:54.829]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:54.829]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:54.829]             base::names(...future.oldOptions))
[16:12:54.829]     }
[16:12:54.829]     if (FALSE) {
[16:12:54.829]     }
[16:12:54.829]     else {
[16:12:54.829]         if (TRUE) {
[16:12:54.829]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:54.829]                 open = "w")
[16:12:54.829]         }
[16:12:54.829]         else {
[16:12:54.829]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:54.829]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:54.829]         }
[16:12:54.829]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:54.829]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:54.829]             base::sink(type = "output", split = FALSE)
[16:12:54.829]             base::close(...future.stdout)
[16:12:54.829]         }, add = TRUE)
[16:12:54.829]     }
[16:12:54.829]     ...future.frame <- base::sys.nframe()
[16:12:54.829]     ...future.conditions <- base::list()
[16:12:54.829]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:54.829]     if (FALSE) {
[16:12:54.829]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:54.829]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:54.829]     }
[16:12:54.829]     ...future.result <- base::tryCatch({
[16:12:54.829]         base::withCallingHandlers({
[16:12:54.829]             ...future.value <- base::withVisible(base::local({
[16:12:54.829]                 ...future.makeSendCondition <- local({
[16:12:54.829]                   sendCondition <- NULL
[16:12:54.829]                   function(frame = 1L) {
[16:12:54.829]                     if (is.function(sendCondition)) 
[16:12:54.829]                       return(sendCondition)
[16:12:54.829]                     ns <- getNamespace("parallel")
[16:12:54.829]                     if (exists("sendData", mode = "function", 
[16:12:54.829]                       envir = ns)) {
[16:12:54.829]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:54.829]                         envir = ns)
[16:12:54.829]                       envir <- sys.frame(frame)
[16:12:54.829]                       master <- NULL
[16:12:54.829]                       while (!identical(envir, .GlobalEnv) && 
[16:12:54.829]                         !identical(envir, emptyenv())) {
[16:12:54.829]                         if (exists("master", mode = "list", envir = envir, 
[16:12:54.829]                           inherits = FALSE)) {
[16:12:54.829]                           master <- get("master", mode = "list", 
[16:12:54.829]                             envir = envir, inherits = FALSE)
[16:12:54.829]                           if (inherits(master, c("SOCKnode", 
[16:12:54.829]                             "SOCK0node"))) {
[16:12:54.829]                             sendCondition <<- function(cond) {
[16:12:54.829]                               data <- list(type = "VALUE", value = cond, 
[16:12:54.829]                                 success = TRUE)
[16:12:54.829]                               parallel_sendData(master, data)
[16:12:54.829]                             }
[16:12:54.829]                             return(sendCondition)
[16:12:54.829]                           }
[16:12:54.829]                         }
[16:12:54.829]                         frame <- frame + 1L
[16:12:54.829]                         envir <- sys.frame(frame)
[16:12:54.829]                       }
[16:12:54.829]                     }
[16:12:54.829]                     sendCondition <<- function(cond) NULL
[16:12:54.829]                   }
[16:12:54.829]                 })
[16:12:54.829]                 withCallingHandlers({
[16:12:54.829]                   {
[16:12:54.829]                     b <- a
[16:12:54.829]                     a <- 2
[16:12:54.829]                     a * b
[16:12:54.829]                   }
[16:12:54.829]                 }, immediateCondition = function(cond) {
[16:12:54.829]                   sendCondition <- ...future.makeSendCondition()
[16:12:54.829]                   sendCondition(cond)
[16:12:54.829]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.829]                   {
[16:12:54.829]                     inherits <- base::inherits
[16:12:54.829]                     invokeRestart <- base::invokeRestart
[16:12:54.829]                     is.null <- base::is.null
[16:12:54.829]                     muffled <- FALSE
[16:12:54.829]                     if (inherits(cond, "message")) {
[16:12:54.829]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:54.829]                       if (muffled) 
[16:12:54.829]                         invokeRestart("muffleMessage")
[16:12:54.829]                     }
[16:12:54.829]                     else if (inherits(cond, "warning")) {
[16:12:54.829]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:54.829]                       if (muffled) 
[16:12:54.829]                         invokeRestart("muffleWarning")
[16:12:54.829]                     }
[16:12:54.829]                     else if (inherits(cond, "condition")) {
[16:12:54.829]                       if (!is.null(pattern)) {
[16:12:54.829]                         computeRestarts <- base::computeRestarts
[16:12:54.829]                         grepl <- base::grepl
[16:12:54.829]                         restarts <- computeRestarts(cond)
[16:12:54.829]                         for (restart in restarts) {
[16:12:54.829]                           name <- restart$name
[16:12:54.829]                           if (is.null(name)) 
[16:12:54.829]                             next
[16:12:54.829]                           if (!grepl(pattern, name)) 
[16:12:54.829]                             next
[16:12:54.829]                           invokeRestart(restart)
[16:12:54.829]                           muffled <- TRUE
[16:12:54.829]                           break
[16:12:54.829]                         }
[16:12:54.829]                       }
[16:12:54.829]                     }
[16:12:54.829]                     invisible(muffled)
[16:12:54.829]                   }
[16:12:54.829]                   muffleCondition(cond)
[16:12:54.829]                 })
[16:12:54.829]             }))
[16:12:54.829]             future::FutureResult(value = ...future.value$value, 
[16:12:54.829]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:54.829]                   ...future.rng), globalenv = if (FALSE) 
[16:12:54.829]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:54.829]                     ...future.globalenv.names))
[16:12:54.829]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:54.829]         }, condition = base::local({
[16:12:54.829]             c <- base::c
[16:12:54.829]             inherits <- base::inherits
[16:12:54.829]             invokeRestart <- base::invokeRestart
[16:12:54.829]             length <- base::length
[16:12:54.829]             list <- base::list
[16:12:54.829]             seq.int <- base::seq.int
[16:12:54.829]             signalCondition <- base::signalCondition
[16:12:54.829]             sys.calls <- base::sys.calls
[16:12:54.829]             `[[` <- base::`[[`
[16:12:54.829]             `+` <- base::`+`
[16:12:54.829]             `<<-` <- base::`<<-`
[16:12:54.829]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:54.829]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:54.829]                   3L)]
[16:12:54.829]             }
[16:12:54.829]             function(cond) {
[16:12:54.829]                 is_error <- inherits(cond, "error")
[16:12:54.829]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:54.829]                   NULL)
[16:12:54.829]                 if (is_error) {
[16:12:54.829]                   sessionInformation <- function() {
[16:12:54.829]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:54.829]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:54.829]                       search = base::search(), system = base::Sys.info())
[16:12:54.829]                   }
[16:12:54.829]                   ...future.conditions[[length(...future.conditions) + 
[16:12:54.829]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:54.829]                     cond$call), session = sessionInformation(), 
[16:12:54.829]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:54.829]                   signalCondition(cond)
[16:12:54.829]                 }
[16:12:54.829]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:54.829]                 "immediateCondition"))) {
[16:12:54.829]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:54.829]                   ...future.conditions[[length(...future.conditions) + 
[16:12:54.829]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:54.829]                   if (TRUE && !signal) {
[16:12:54.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.829]                     {
[16:12:54.829]                       inherits <- base::inherits
[16:12:54.829]                       invokeRestart <- base::invokeRestart
[16:12:54.829]                       is.null <- base::is.null
[16:12:54.829]                       muffled <- FALSE
[16:12:54.829]                       if (inherits(cond, "message")) {
[16:12:54.829]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:54.829]                         if (muffled) 
[16:12:54.829]                           invokeRestart("muffleMessage")
[16:12:54.829]                       }
[16:12:54.829]                       else if (inherits(cond, "warning")) {
[16:12:54.829]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:54.829]                         if (muffled) 
[16:12:54.829]                           invokeRestart("muffleWarning")
[16:12:54.829]                       }
[16:12:54.829]                       else if (inherits(cond, "condition")) {
[16:12:54.829]                         if (!is.null(pattern)) {
[16:12:54.829]                           computeRestarts <- base::computeRestarts
[16:12:54.829]                           grepl <- base::grepl
[16:12:54.829]                           restarts <- computeRestarts(cond)
[16:12:54.829]                           for (restart in restarts) {
[16:12:54.829]                             name <- restart$name
[16:12:54.829]                             if (is.null(name)) 
[16:12:54.829]                               next
[16:12:54.829]                             if (!grepl(pattern, name)) 
[16:12:54.829]                               next
[16:12:54.829]                             invokeRestart(restart)
[16:12:54.829]                             muffled <- TRUE
[16:12:54.829]                             break
[16:12:54.829]                           }
[16:12:54.829]                         }
[16:12:54.829]                       }
[16:12:54.829]                       invisible(muffled)
[16:12:54.829]                     }
[16:12:54.829]                     muffleCondition(cond, pattern = "^muffle")
[16:12:54.829]                   }
[16:12:54.829]                 }
[16:12:54.829]                 else {
[16:12:54.829]                   if (TRUE) {
[16:12:54.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.829]                     {
[16:12:54.829]                       inherits <- base::inherits
[16:12:54.829]                       invokeRestart <- base::invokeRestart
[16:12:54.829]                       is.null <- base::is.null
[16:12:54.829]                       muffled <- FALSE
[16:12:54.829]                       if (inherits(cond, "message")) {
[16:12:54.829]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:54.829]                         if (muffled) 
[16:12:54.829]                           invokeRestart("muffleMessage")
[16:12:54.829]                       }
[16:12:54.829]                       else if (inherits(cond, "warning")) {
[16:12:54.829]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:54.829]                         if (muffled) 
[16:12:54.829]                           invokeRestart("muffleWarning")
[16:12:54.829]                       }
[16:12:54.829]                       else if (inherits(cond, "condition")) {
[16:12:54.829]                         if (!is.null(pattern)) {
[16:12:54.829]                           computeRestarts <- base::computeRestarts
[16:12:54.829]                           grepl <- base::grepl
[16:12:54.829]                           restarts <- computeRestarts(cond)
[16:12:54.829]                           for (restart in restarts) {
[16:12:54.829]                             name <- restart$name
[16:12:54.829]                             if (is.null(name)) 
[16:12:54.829]                               next
[16:12:54.829]                             if (!grepl(pattern, name)) 
[16:12:54.829]                               next
[16:12:54.829]                             invokeRestart(restart)
[16:12:54.829]                             muffled <- TRUE
[16:12:54.829]                             break
[16:12:54.829]                           }
[16:12:54.829]                         }
[16:12:54.829]                       }
[16:12:54.829]                       invisible(muffled)
[16:12:54.829]                     }
[16:12:54.829]                     muffleCondition(cond, pattern = "^muffle")
[16:12:54.829]                   }
[16:12:54.829]                 }
[16:12:54.829]             }
[16:12:54.829]         }))
[16:12:54.829]     }, error = function(ex) {
[16:12:54.829]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:54.829]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:54.829]                 ...future.rng), started = ...future.startTime, 
[16:12:54.829]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:54.829]             version = "1.8"), class = "FutureResult")
[16:12:54.829]     }, finally = {
[16:12:54.829]         if (!identical(...future.workdir, getwd())) 
[16:12:54.829]             setwd(...future.workdir)
[16:12:54.829]         {
[16:12:54.829]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:54.829]                 ...future.oldOptions$nwarnings <- NULL
[16:12:54.829]             }
[16:12:54.829]             base::options(...future.oldOptions)
[16:12:54.829]             if (.Platform$OS.type == "windows") {
[16:12:54.829]                 old_names <- names(...future.oldEnvVars)
[16:12:54.829]                 envs <- base::Sys.getenv()
[16:12:54.829]                 names <- names(envs)
[16:12:54.829]                 common <- intersect(names, old_names)
[16:12:54.829]                 added <- setdiff(names, old_names)
[16:12:54.829]                 removed <- setdiff(old_names, names)
[16:12:54.829]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:54.829]                   envs[common]]
[16:12:54.829]                 NAMES <- toupper(changed)
[16:12:54.829]                 args <- list()
[16:12:54.829]                 for (kk in seq_along(NAMES)) {
[16:12:54.829]                   name <- changed[[kk]]
[16:12:54.829]                   NAME <- NAMES[[kk]]
[16:12:54.829]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.829]                     next
[16:12:54.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:54.829]                 }
[16:12:54.829]                 NAMES <- toupper(added)
[16:12:54.829]                 for (kk in seq_along(NAMES)) {
[16:12:54.829]                   name <- added[[kk]]
[16:12:54.829]                   NAME <- NAMES[[kk]]
[16:12:54.829]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.829]                     next
[16:12:54.829]                   args[[name]] <- ""
[16:12:54.829]                 }
[16:12:54.829]                 NAMES <- toupper(removed)
[16:12:54.829]                 for (kk in seq_along(NAMES)) {
[16:12:54.829]                   name <- removed[[kk]]
[16:12:54.829]                   NAME <- NAMES[[kk]]
[16:12:54.829]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.829]                     next
[16:12:54.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:54.829]                 }
[16:12:54.829]                 if (length(args) > 0) 
[16:12:54.829]                   base::do.call(base::Sys.setenv, args = args)
[16:12:54.829]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:54.829]             }
[16:12:54.829]             else {
[16:12:54.829]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:54.829]             }
[16:12:54.829]             {
[16:12:54.829]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:54.829]                   0L) {
[16:12:54.829]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:54.829]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:54.829]                   base::options(opts)
[16:12:54.829]                 }
[16:12:54.829]                 {
[16:12:54.829]                   {
[16:12:54.829]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:54.829]                     NULL
[16:12:54.829]                   }
[16:12:54.829]                   options(future.plan = NULL)
[16:12:54.829]                   if (is.na(NA_character_)) 
[16:12:54.829]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:54.829]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:54.829]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:54.829]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:54.829]                     envir = parent.frame()) 
[16:12:54.829]                   {
[16:12:54.829]                     if (is.function(workers)) 
[16:12:54.829]                       workers <- workers()
[16:12:54.829]                     workers <- structure(as.integer(workers), 
[16:12:54.829]                       class = class(workers))
[16:12:54.829]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:54.829]                       workers >= 1)
[16:12:54.829]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:54.829]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:54.829]                     }
[16:12:54.829]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:54.829]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:54.829]                       envir = envir)
[16:12:54.829]                     if (!future$lazy) 
[16:12:54.829]                       future <- run(future)
[16:12:54.829]                     invisible(future)
[16:12:54.829]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:54.829]                 }
[16:12:54.829]             }
[16:12:54.829]         }
[16:12:54.829]     })
[16:12:54.829]     if (TRUE) {
[16:12:54.829]         base::sink(type = "output", split = FALSE)
[16:12:54.829]         if (TRUE) {
[16:12:54.829]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:54.829]         }
[16:12:54.829]         else {
[16:12:54.829]             ...future.result["stdout"] <- base::list(NULL)
[16:12:54.829]         }
[16:12:54.829]         base::close(...future.stdout)
[16:12:54.829]         ...future.stdout <- NULL
[16:12:54.829]     }
[16:12:54.829]     ...future.result$conditions <- ...future.conditions
[16:12:54.829]     ...future.result$finished <- base::Sys.time()
[16:12:54.829]     ...future.result
[16:12:54.829] }
[16:12:54.832] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[16:12:54.832] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[16:12:54.832] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[16:12:54.833] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[16:12:54.833] MultisessionFuture started
[16:12:54.833] - Launch lazy future ... done
[16:12:54.833] run() for ‘MultisessionFuture’ ... done
[16:12:54.833] result() for ClusterFuture ...
[16:12:54.833] receiveMessageFromWorker() for ClusterFuture ...
[16:12:54.834] - Validating connection of MultisessionFuture
[16:12:54.882] - received message: FutureResult
[16:12:54.882] - Received FutureResult
[16:12:54.882] - Erased future from FutureRegistry
[16:12:54.882] result() for ClusterFuture ...
[16:12:54.882] - result already collected: FutureResult
[16:12:54.882] result() for ClusterFuture ... done
[16:12:54.882] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:54.882] result() for ClusterFuture ... done
[16:12:54.883] result() for ClusterFuture ...
[16:12:54.883] - result already collected: FutureResult
[16:12:54.883] result() for ClusterFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:54.883] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:54.884] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:54.885] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:12:54.886] Searching for globals ... DONE
[16:12:54.886] Resolving globals: TRUE
[16:12:54.886] Resolving any globals that are futures ...
[16:12:54.886] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[16:12:54.886] Resolving any globals that are futures ... DONE
[16:12:54.886] Resolving futures part of globals (recursively) ...
[16:12:54.887] resolve() on list ...
[16:12:54.887]  recursive: 99
[16:12:54.887]  length: 1
[16:12:54.887]  elements: ‘a’
[16:12:54.887]  length: 0 (resolved future 1)
[16:12:54.887] resolve() on list ... DONE
[16:12:54.887] - globals: [1] ‘a’
[16:12:54.887] Resolving futures part of globals (recursively) ... DONE
[16:12:54.887] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:54.888] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:12:54.888] - globals: [1] ‘a’
[16:12:54.888] 
[16:12:54.888] getGlobalsAndPackages() ... DONE
[16:12:54.888] run() for ‘Future’ ...
[16:12:54.889] - state: ‘created’
[16:12:54.889] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:54.903] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:54.904] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:54.904]   - Field: ‘node’
[16:12:54.904]   - Field: ‘label’
[16:12:54.904]   - Field: ‘local’
[16:12:54.904]   - Field: ‘owner’
[16:12:54.904]   - Field: ‘envir’
[16:12:54.904]   - Field: ‘workers’
[16:12:54.904]   - Field: ‘packages’
[16:12:54.904]   - Field: ‘gc’
[16:12:54.904]   - Field: ‘conditions’
[16:12:54.905]   - Field: ‘persistent’
[16:12:54.905]   - Field: ‘expr’
[16:12:54.905]   - Field: ‘uuid’
[16:12:54.905]   - Field: ‘seed’
[16:12:54.905]   - Field: ‘version’
[16:12:54.905]   - Field: ‘result’
[16:12:54.905]   - Field: ‘asynchronous’
[16:12:54.905]   - Field: ‘calls’
[16:12:54.905]   - Field: ‘globals’
[16:12:54.905]   - Field: ‘stdout’
[16:12:54.906]   - Field: ‘earlySignal’
[16:12:54.906]   - Field: ‘lazy’
[16:12:54.906]   - Field: ‘state’
[16:12:54.906] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:54.906] - Launch lazy future ...
[16:12:54.906] Packages needed by the future expression (n = 0): <none>
[16:12:54.906] Packages needed by future strategies (n = 0): <none>
[16:12:54.907] {
[16:12:54.907]     {
[16:12:54.907]         {
[16:12:54.907]             ...future.startTime <- base::Sys.time()
[16:12:54.907]             {
[16:12:54.907]                 {
[16:12:54.907]                   {
[16:12:54.907]                     {
[16:12:54.907]                       base::local({
[16:12:54.907]                         has_future <- base::requireNamespace("future", 
[16:12:54.907]                           quietly = TRUE)
[16:12:54.907]                         if (has_future) {
[16:12:54.907]                           ns <- base::getNamespace("future")
[16:12:54.907]                           version <- ns[[".package"]][["version"]]
[16:12:54.907]                           if (is.null(version)) 
[16:12:54.907]                             version <- utils::packageVersion("future")
[16:12:54.907]                         }
[16:12:54.907]                         else {
[16:12:54.907]                           version <- NULL
[16:12:54.907]                         }
[16:12:54.907]                         if (!has_future || version < "1.8.0") {
[16:12:54.907]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:54.907]                             "", base::R.version$version.string), 
[16:12:54.907]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:54.907]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:54.907]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:54.907]                               "release", "version")], collapse = " "), 
[16:12:54.907]                             hostname = base::Sys.info()[["nodename"]])
[16:12:54.907]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:54.907]                             info)
[16:12:54.907]                           info <- base::paste(info, collapse = "; ")
[16:12:54.907]                           if (!has_future) {
[16:12:54.907]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:54.907]                               info)
[16:12:54.907]                           }
[16:12:54.907]                           else {
[16:12:54.907]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:54.907]                               info, version)
[16:12:54.907]                           }
[16:12:54.907]                           base::stop(msg)
[16:12:54.907]                         }
[16:12:54.907]                       })
[16:12:54.907]                     }
[16:12:54.907]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:54.907]                     base::options(mc.cores = 1L)
[16:12:54.907]                   }
[16:12:54.907]                   options(future.plan = NULL)
[16:12:54.907]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:54.907]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:54.907]                 }
[16:12:54.907]                 ...future.workdir <- getwd()
[16:12:54.907]             }
[16:12:54.907]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:54.907]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:54.907]         }
[16:12:54.907]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:54.907]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:54.907]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:54.907]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:54.907]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:54.907]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:54.907]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:54.907]             base::names(...future.oldOptions))
[16:12:54.907]     }
[16:12:54.907]     if (FALSE) {
[16:12:54.907]     }
[16:12:54.907]     else {
[16:12:54.907]         if (TRUE) {
[16:12:54.907]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:54.907]                 open = "w")
[16:12:54.907]         }
[16:12:54.907]         else {
[16:12:54.907]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:54.907]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:54.907]         }
[16:12:54.907]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:54.907]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:54.907]             base::sink(type = "output", split = FALSE)
[16:12:54.907]             base::close(...future.stdout)
[16:12:54.907]         }, add = TRUE)
[16:12:54.907]     }
[16:12:54.907]     ...future.frame <- base::sys.nframe()
[16:12:54.907]     ...future.conditions <- base::list()
[16:12:54.907]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:54.907]     if (FALSE) {
[16:12:54.907]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:54.907]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:54.907]     }
[16:12:54.907]     ...future.result <- base::tryCatch({
[16:12:54.907]         base::withCallingHandlers({
[16:12:54.907]             ...future.value <- base::withVisible(base::local({
[16:12:54.907]                 ...future.makeSendCondition <- local({
[16:12:54.907]                   sendCondition <- NULL
[16:12:54.907]                   function(frame = 1L) {
[16:12:54.907]                     if (is.function(sendCondition)) 
[16:12:54.907]                       return(sendCondition)
[16:12:54.907]                     ns <- getNamespace("parallel")
[16:12:54.907]                     if (exists("sendData", mode = "function", 
[16:12:54.907]                       envir = ns)) {
[16:12:54.907]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:54.907]                         envir = ns)
[16:12:54.907]                       envir <- sys.frame(frame)
[16:12:54.907]                       master <- NULL
[16:12:54.907]                       while (!identical(envir, .GlobalEnv) && 
[16:12:54.907]                         !identical(envir, emptyenv())) {
[16:12:54.907]                         if (exists("master", mode = "list", envir = envir, 
[16:12:54.907]                           inherits = FALSE)) {
[16:12:54.907]                           master <- get("master", mode = "list", 
[16:12:54.907]                             envir = envir, inherits = FALSE)
[16:12:54.907]                           if (inherits(master, c("SOCKnode", 
[16:12:54.907]                             "SOCK0node"))) {
[16:12:54.907]                             sendCondition <<- function(cond) {
[16:12:54.907]                               data <- list(type = "VALUE", value = cond, 
[16:12:54.907]                                 success = TRUE)
[16:12:54.907]                               parallel_sendData(master, data)
[16:12:54.907]                             }
[16:12:54.907]                             return(sendCondition)
[16:12:54.907]                           }
[16:12:54.907]                         }
[16:12:54.907]                         frame <- frame + 1L
[16:12:54.907]                         envir <- sys.frame(frame)
[16:12:54.907]                       }
[16:12:54.907]                     }
[16:12:54.907]                     sendCondition <<- function(cond) NULL
[16:12:54.907]                   }
[16:12:54.907]                 })
[16:12:54.907]                 withCallingHandlers({
[16:12:54.907]                   {
[16:12:54.907]                     b <- a
[16:12:54.907]                     a <- 2
[16:12:54.907]                     a * b
[16:12:54.907]                   }
[16:12:54.907]                 }, immediateCondition = function(cond) {
[16:12:54.907]                   sendCondition <- ...future.makeSendCondition()
[16:12:54.907]                   sendCondition(cond)
[16:12:54.907]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.907]                   {
[16:12:54.907]                     inherits <- base::inherits
[16:12:54.907]                     invokeRestart <- base::invokeRestart
[16:12:54.907]                     is.null <- base::is.null
[16:12:54.907]                     muffled <- FALSE
[16:12:54.907]                     if (inherits(cond, "message")) {
[16:12:54.907]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:54.907]                       if (muffled) 
[16:12:54.907]                         invokeRestart("muffleMessage")
[16:12:54.907]                     }
[16:12:54.907]                     else if (inherits(cond, "warning")) {
[16:12:54.907]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:54.907]                       if (muffled) 
[16:12:54.907]                         invokeRestart("muffleWarning")
[16:12:54.907]                     }
[16:12:54.907]                     else if (inherits(cond, "condition")) {
[16:12:54.907]                       if (!is.null(pattern)) {
[16:12:54.907]                         computeRestarts <- base::computeRestarts
[16:12:54.907]                         grepl <- base::grepl
[16:12:54.907]                         restarts <- computeRestarts(cond)
[16:12:54.907]                         for (restart in restarts) {
[16:12:54.907]                           name <- restart$name
[16:12:54.907]                           if (is.null(name)) 
[16:12:54.907]                             next
[16:12:54.907]                           if (!grepl(pattern, name)) 
[16:12:54.907]                             next
[16:12:54.907]                           invokeRestart(restart)
[16:12:54.907]                           muffled <- TRUE
[16:12:54.907]                           break
[16:12:54.907]                         }
[16:12:54.907]                       }
[16:12:54.907]                     }
[16:12:54.907]                     invisible(muffled)
[16:12:54.907]                   }
[16:12:54.907]                   muffleCondition(cond)
[16:12:54.907]                 })
[16:12:54.907]             }))
[16:12:54.907]             future::FutureResult(value = ...future.value$value, 
[16:12:54.907]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:54.907]                   ...future.rng), globalenv = if (FALSE) 
[16:12:54.907]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:54.907]                     ...future.globalenv.names))
[16:12:54.907]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:54.907]         }, condition = base::local({
[16:12:54.907]             c <- base::c
[16:12:54.907]             inherits <- base::inherits
[16:12:54.907]             invokeRestart <- base::invokeRestart
[16:12:54.907]             length <- base::length
[16:12:54.907]             list <- base::list
[16:12:54.907]             seq.int <- base::seq.int
[16:12:54.907]             signalCondition <- base::signalCondition
[16:12:54.907]             sys.calls <- base::sys.calls
[16:12:54.907]             `[[` <- base::`[[`
[16:12:54.907]             `+` <- base::`+`
[16:12:54.907]             `<<-` <- base::`<<-`
[16:12:54.907]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:54.907]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:54.907]                   3L)]
[16:12:54.907]             }
[16:12:54.907]             function(cond) {
[16:12:54.907]                 is_error <- inherits(cond, "error")
[16:12:54.907]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:54.907]                   NULL)
[16:12:54.907]                 if (is_error) {
[16:12:54.907]                   sessionInformation <- function() {
[16:12:54.907]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:54.907]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:54.907]                       search = base::search(), system = base::Sys.info())
[16:12:54.907]                   }
[16:12:54.907]                   ...future.conditions[[length(...future.conditions) + 
[16:12:54.907]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:54.907]                     cond$call), session = sessionInformation(), 
[16:12:54.907]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:54.907]                   signalCondition(cond)
[16:12:54.907]                 }
[16:12:54.907]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:54.907]                 "immediateCondition"))) {
[16:12:54.907]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:54.907]                   ...future.conditions[[length(...future.conditions) + 
[16:12:54.907]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:54.907]                   if (TRUE && !signal) {
[16:12:54.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.907]                     {
[16:12:54.907]                       inherits <- base::inherits
[16:12:54.907]                       invokeRestart <- base::invokeRestart
[16:12:54.907]                       is.null <- base::is.null
[16:12:54.907]                       muffled <- FALSE
[16:12:54.907]                       if (inherits(cond, "message")) {
[16:12:54.907]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:54.907]                         if (muffled) 
[16:12:54.907]                           invokeRestart("muffleMessage")
[16:12:54.907]                       }
[16:12:54.907]                       else if (inherits(cond, "warning")) {
[16:12:54.907]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:54.907]                         if (muffled) 
[16:12:54.907]                           invokeRestart("muffleWarning")
[16:12:54.907]                       }
[16:12:54.907]                       else if (inherits(cond, "condition")) {
[16:12:54.907]                         if (!is.null(pattern)) {
[16:12:54.907]                           computeRestarts <- base::computeRestarts
[16:12:54.907]                           grepl <- base::grepl
[16:12:54.907]                           restarts <- computeRestarts(cond)
[16:12:54.907]                           for (restart in restarts) {
[16:12:54.907]                             name <- restart$name
[16:12:54.907]                             if (is.null(name)) 
[16:12:54.907]                               next
[16:12:54.907]                             if (!grepl(pattern, name)) 
[16:12:54.907]                               next
[16:12:54.907]                             invokeRestart(restart)
[16:12:54.907]                             muffled <- TRUE
[16:12:54.907]                             break
[16:12:54.907]                           }
[16:12:54.907]                         }
[16:12:54.907]                       }
[16:12:54.907]                       invisible(muffled)
[16:12:54.907]                     }
[16:12:54.907]                     muffleCondition(cond, pattern = "^muffle")
[16:12:54.907]                   }
[16:12:54.907]                 }
[16:12:54.907]                 else {
[16:12:54.907]                   if (TRUE) {
[16:12:54.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.907]                     {
[16:12:54.907]                       inherits <- base::inherits
[16:12:54.907]                       invokeRestart <- base::invokeRestart
[16:12:54.907]                       is.null <- base::is.null
[16:12:54.907]                       muffled <- FALSE
[16:12:54.907]                       if (inherits(cond, "message")) {
[16:12:54.907]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:54.907]                         if (muffled) 
[16:12:54.907]                           invokeRestart("muffleMessage")
[16:12:54.907]                       }
[16:12:54.907]                       else if (inherits(cond, "warning")) {
[16:12:54.907]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:54.907]                         if (muffled) 
[16:12:54.907]                           invokeRestart("muffleWarning")
[16:12:54.907]                       }
[16:12:54.907]                       else if (inherits(cond, "condition")) {
[16:12:54.907]                         if (!is.null(pattern)) {
[16:12:54.907]                           computeRestarts <- base::computeRestarts
[16:12:54.907]                           grepl <- base::grepl
[16:12:54.907]                           restarts <- computeRestarts(cond)
[16:12:54.907]                           for (restart in restarts) {
[16:12:54.907]                             name <- restart$name
[16:12:54.907]                             if (is.null(name)) 
[16:12:54.907]                               next
[16:12:54.907]                             if (!grepl(pattern, name)) 
[16:12:54.907]                               next
[16:12:54.907]                             invokeRestart(restart)
[16:12:54.907]                             muffled <- TRUE
[16:12:54.907]                             break
[16:12:54.907]                           }
[16:12:54.907]                         }
[16:12:54.907]                       }
[16:12:54.907]                       invisible(muffled)
[16:12:54.907]                     }
[16:12:54.907]                     muffleCondition(cond, pattern = "^muffle")
[16:12:54.907]                   }
[16:12:54.907]                 }
[16:12:54.907]             }
[16:12:54.907]         }))
[16:12:54.907]     }, error = function(ex) {
[16:12:54.907]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:54.907]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:54.907]                 ...future.rng), started = ...future.startTime, 
[16:12:54.907]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:54.907]             version = "1.8"), class = "FutureResult")
[16:12:54.907]     }, finally = {
[16:12:54.907]         if (!identical(...future.workdir, getwd())) 
[16:12:54.907]             setwd(...future.workdir)
[16:12:54.907]         {
[16:12:54.907]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:54.907]                 ...future.oldOptions$nwarnings <- NULL
[16:12:54.907]             }
[16:12:54.907]             base::options(...future.oldOptions)
[16:12:54.907]             if (.Platform$OS.type == "windows") {
[16:12:54.907]                 old_names <- names(...future.oldEnvVars)
[16:12:54.907]                 envs <- base::Sys.getenv()
[16:12:54.907]                 names <- names(envs)
[16:12:54.907]                 common <- intersect(names, old_names)
[16:12:54.907]                 added <- setdiff(names, old_names)
[16:12:54.907]                 removed <- setdiff(old_names, names)
[16:12:54.907]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:54.907]                   envs[common]]
[16:12:54.907]                 NAMES <- toupper(changed)
[16:12:54.907]                 args <- list()
[16:12:54.907]                 for (kk in seq_along(NAMES)) {
[16:12:54.907]                   name <- changed[[kk]]
[16:12:54.907]                   NAME <- NAMES[[kk]]
[16:12:54.907]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.907]                     next
[16:12:54.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:54.907]                 }
[16:12:54.907]                 NAMES <- toupper(added)
[16:12:54.907]                 for (kk in seq_along(NAMES)) {
[16:12:54.907]                   name <- added[[kk]]
[16:12:54.907]                   NAME <- NAMES[[kk]]
[16:12:54.907]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.907]                     next
[16:12:54.907]                   args[[name]] <- ""
[16:12:54.907]                 }
[16:12:54.907]                 NAMES <- toupper(removed)
[16:12:54.907]                 for (kk in seq_along(NAMES)) {
[16:12:54.907]                   name <- removed[[kk]]
[16:12:54.907]                   NAME <- NAMES[[kk]]
[16:12:54.907]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.907]                     next
[16:12:54.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:54.907]                 }
[16:12:54.907]                 if (length(args) > 0) 
[16:12:54.907]                   base::do.call(base::Sys.setenv, args = args)
[16:12:54.907]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:54.907]             }
[16:12:54.907]             else {
[16:12:54.907]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:54.907]             }
[16:12:54.907]             {
[16:12:54.907]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:54.907]                   0L) {
[16:12:54.907]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:54.907]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:54.907]                   base::options(opts)
[16:12:54.907]                 }
[16:12:54.907]                 {
[16:12:54.907]                   {
[16:12:54.907]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:54.907]                     NULL
[16:12:54.907]                   }
[16:12:54.907]                   options(future.plan = NULL)
[16:12:54.907]                   if (is.na(NA_character_)) 
[16:12:54.907]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:54.907]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:54.907]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:54.907]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:54.907]                     envir = parent.frame()) 
[16:12:54.907]                   {
[16:12:54.907]                     if (is.function(workers)) 
[16:12:54.907]                       workers <- workers()
[16:12:54.907]                     workers <- structure(as.integer(workers), 
[16:12:54.907]                       class = class(workers))
[16:12:54.907]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:54.907]                       workers >= 1)
[16:12:54.907]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:54.907]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:54.907]                     }
[16:12:54.907]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:54.907]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:54.907]                       envir = envir)
[16:12:54.907]                     if (!future$lazy) 
[16:12:54.907]                       future <- run(future)
[16:12:54.907]                     invisible(future)
[16:12:54.907]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:54.907]                 }
[16:12:54.907]             }
[16:12:54.907]         }
[16:12:54.907]     })
[16:12:54.907]     if (TRUE) {
[16:12:54.907]         base::sink(type = "output", split = FALSE)
[16:12:54.907]         if (TRUE) {
[16:12:54.907]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:54.907]         }
[16:12:54.907]         else {
[16:12:54.907]             ...future.result["stdout"] <- base::list(NULL)
[16:12:54.907]         }
[16:12:54.907]         base::close(...future.stdout)
[16:12:54.907]         ...future.stdout <- NULL
[16:12:54.907]     }
[16:12:54.907]     ...future.result$conditions <- ...future.conditions
[16:12:54.907]     ...future.result$finished <- base::Sys.time()
[16:12:54.907]     ...future.result
[16:12:54.907] }
[16:12:54.910] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[16:12:54.910] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[16:12:54.910] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[16:12:54.910] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[16:12:54.911] MultisessionFuture started
[16:12:54.911] - Launch lazy future ... done
[16:12:54.911] run() for ‘MultisessionFuture’ ... done
[16:12:54.911] result() for ClusterFuture ...
[16:12:54.911] receiveMessageFromWorker() for ClusterFuture ...
[16:12:54.911] - Validating connection of MultisessionFuture
[16:12:54.957] - received message: FutureResult
[16:12:54.957] - Received FutureResult
[16:12:54.958] - Erased future from FutureRegistry
[16:12:54.958] result() for ClusterFuture ...
[16:12:54.958] - result already collected: FutureResult
[16:12:54.958] result() for ClusterFuture ... done
[16:12:54.958] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:54.958] result() for ClusterFuture ... done
[16:12:54.958] result() for ClusterFuture ...
[16:12:54.958] - result already collected: FutureResult
[16:12:54.959] result() for ClusterFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:54.959] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:54.959] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:54.961] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:54.962] Searching for globals ... DONE
[16:12:54.962] Resolving globals: TRUE
[16:12:54.962] Resolving any globals that are futures ...
[16:12:54.962] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:54.962] Resolving any globals that are futures ... DONE
[16:12:54.962] Resolving futures part of globals (recursively) ...
[16:12:54.963] resolve() on list ...
[16:12:54.963]  recursive: 99
[16:12:54.963]  length: 2
[16:12:54.963]  elements: ‘a’, ‘ii’
[16:12:54.963]  length: 1 (resolved future 1)
[16:12:54.963]  length: 0 (resolved future 2)
[16:12:54.963] resolve() on list ... DONE
[16:12:54.963] - globals: [2] ‘a’, ‘ii’
[16:12:54.963] Resolving futures part of globals (recursively) ... DONE
[16:12:54.964] The total size of the 2 globals is 112 bytes (112 bytes)
[16:12:54.966] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:12:54.966] - globals: [2] ‘a’, ‘ii’
[16:12:54.966] 
[16:12:54.967] getGlobalsAndPackages() ... DONE
[16:12:54.967] run() for ‘Future’ ...
[16:12:54.967] - state: ‘created’
[16:12:54.967] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:54.982] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:54.982] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:54.982]   - Field: ‘node’
[16:12:54.982]   - Field: ‘label’
[16:12:54.982]   - Field: ‘local’
[16:12:54.982]   - Field: ‘owner’
[16:12:54.982]   - Field: ‘envir’
[16:12:54.983]   - Field: ‘workers’
[16:12:54.983]   - Field: ‘packages’
[16:12:54.983]   - Field: ‘gc’
[16:12:54.983]   - Field: ‘conditions’
[16:12:54.983]   - Field: ‘persistent’
[16:12:54.983]   - Field: ‘expr’
[16:12:54.983]   - Field: ‘uuid’
[16:12:54.983]   - Field: ‘seed’
[16:12:54.983]   - Field: ‘version’
[16:12:54.983]   - Field: ‘result’
[16:12:54.983]   - Field: ‘asynchronous’
[16:12:54.983]   - Field: ‘calls’
[16:12:54.984]   - Field: ‘globals’
[16:12:54.984]   - Field: ‘stdout’
[16:12:54.984]   - Field: ‘earlySignal’
[16:12:54.984]   - Field: ‘lazy’
[16:12:54.984]   - Field: ‘state’
[16:12:54.984] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:54.984] - Launch lazy future ...
[16:12:54.984] Packages needed by the future expression (n = 0): <none>
[16:12:54.985] Packages needed by future strategies (n = 0): <none>
[16:12:54.985] {
[16:12:54.985]     {
[16:12:54.985]         {
[16:12:54.985]             ...future.startTime <- base::Sys.time()
[16:12:54.985]             {
[16:12:54.985]                 {
[16:12:54.985]                   {
[16:12:54.985]                     {
[16:12:54.985]                       base::local({
[16:12:54.985]                         has_future <- base::requireNamespace("future", 
[16:12:54.985]                           quietly = TRUE)
[16:12:54.985]                         if (has_future) {
[16:12:54.985]                           ns <- base::getNamespace("future")
[16:12:54.985]                           version <- ns[[".package"]][["version"]]
[16:12:54.985]                           if (is.null(version)) 
[16:12:54.985]                             version <- utils::packageVersion("future")
[16:12:54.985]                         }
[16:12:54.985]                         else {
[16:12:54.985]                           version <- NULL
[16:12:54.985]                         }
[16:12:54.985]                         if (!has_future || version < "1.8.0") {
[16:12:54.985]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:54.985]                             "", base::R.version$version.string), 
[16:12:54.985]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:54.985]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:54.985]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:54.985]                               "release", "version")], collapse = " "), 
[16:12:54.985]                             hostname = base::Sys.info()[["nodename"]])
[16:12:54.985]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:54.985]                             info)
[16:12:54.985]                           info <- base::paste(info, collapse = "; ")
[16:12:54.985]                           if (!has_future) {
[16:12:54.985]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:54.985]                               info)
[16:12:54.985]                           }
[16:12:54.985]                           else {
[16:12:54.985]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:54.985]                               info, version)
[16:12:54.985]                           }
[16:12:54.985]                           base::stop(msg)
[16:12:54.985]                         }
[16:12:54.985]                       })
[16:12:54.985]                     }
[16:12:54.985]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:54.985]                     base::options(mc.cores = 1L)
[16:12:54.985]                   }
[16:12:54.985]                   options(future.plan = NULL)
[16:12:54.985]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:54.985]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:54.985]                 }
[16:12:54.985]                 ...future.workdir <- getwd()
[16:12:54.985]             }
[16:12:54.985]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:54.985]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:54.985]         }
[16:12:54.985]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:54.985]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:54.985]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:54.985]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:54.985]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:54.985]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:54.985]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:54.985]             base::names(...future.oldOptions))
[16:12:54.985]     }
[16:12:54.985]     if (FALSE) {
[16:12:54.985]     }
[16:12:54.985]     else {
[16:12:54.985]         if (TRUE) {
[16:12:54.985]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:54.985]                 open = "w")
[16:12:54.985]         }
[16:12:54.985]         else {
[16:12:54.985]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:54.985]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:54.985]         }
[16:12:54.985]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:54.985]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:54.985]             base::sink(type = "output", split = FALSE)
[16:12:54.985]             base::close(...future.stdout)
[16:12:54.985]         }, add = TRUE)
[16:12:54.985]     }
[16:12:54.985]     ...future.frame <- base::sys.nframe()
[16:12:54.985]     ...future.conditions <- base::list()
[16:12:54.985]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:54.985]     if (FALSE) {
[16:12:54.985]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:54.985]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:54.985]     }
[16:12:54.985]     ...future.result <- base::tryCatch({
[16:12:54.985]         base::withCallingHandlers({
[16:12:54.985]             ...future.value <- base::withVisible(base::local({
[16:12:54.985]                 ...future.makeSendCondition <- local({
[16:12:54.985]                   sendCondition <- NULL
[16:12:54.985]                   function(frame = 1L) {
[16:12:54.985]                     if (is.function(sendCondition)) 
[16:12:54.985]                       return(sendCondition)
[16:12:54.985]                     ns <- getNamespace("parallel")
[16:12:54.985]                     if (exists("sendData", mode = "function", 
[16:12:54.985]                       envir = ns)) {
[16:12:54.985]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:54.985]                         envir = ns)
[16:12:54.985]                       envir <- sys.frame(frame)
[16:12:54.985]                       master <- NULL
[16:12:54.985]                       while (!identical(envir, .GlobalEnv) && 
[16:12:54.985]                         !identical(envir, emptyenv())) {
[16:12:54.985]                         if (exists("master", mode = "list", envir = envir, 
[16:12:54.985]                           inherits = FALSE)) {
[16:12:54.985]                           master <- get("master", mode = "list", 
[16:12:54.985]                             envir = envir, inherits = FALSE)
[16:12:54.985]                           if (inherits(master, c("SOCKnode", 
[16:12:54.985]                             "SOCK0node"))) {
[16:12:54.985]                             sendCondition <<- function(cond) {
[16:12:54.985]                               data <- list(type = "VALUE", value = cond, 
[16:12:54.985]                                 success = TRUE)
[16:12:54.985]                               parallel_sendData(master, data)
[16:12:54.985]                             }
[16:12:54.985]                             return(sendCondition)
[16:12:54.985]                           }
[16:12:54.985]                         }
[16:12:54.985]                         frame <- frame + 1L
[16:12:54.985]                         envir <- sys.frame(frame)
[16:12:54.985]                       }
[16:12:54.985]                     }
[16:12:54.985]                     sendCondition <<- function(cond) NULL
[16:12:54.985]                   }
[16:12:54.985]                 })
[16:12:54.985]                 withCallingHandlers({
[16:12:54.985]                   {
[16:12:54.985]                     b <- a * ii
[16:12:54.985]                     a <- 0
[16:12:54.985]                     b
[16:12:54.985]                   }
[16:12:54.985]                 }, immediateCondition = function(cond) {
[16:12:54.985]                   sendCondition <- ...future.makeSendCondition()
[16:12:54.985]                   sendCondition(cond)
[16:12:54.985]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.985]                   {
[16:12:54.985]                     inherits <- base::inherits
[16:12:54.985]                     invokeRestart <- base::invokeRestart
[16:12:54.985]                     is.null <- base::is.null
[16:12:54.985]                     muffled <- FALSE
[16:12:54.985]                     if (inherits(cond, "message")) {
[16:12:54.985]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:54.985]                       if (muffled) 
[16:12:54.985]                         invokeRestart("muffleMessage")
[16:12:54.985]                     }
[16:12:54.985]                     else if (inherits(cond, "warning")) {
[16:12:54.985]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:54.985]                       if (muffled) 
[16:12:54.985]                         invokeRestart("muffleWarning")
[16:12:54.985]                     }
[16:12:54.985]                     else if (inherits(cond, "condition")) {
[16:12:54.985]                       if (!is.null(pattern)) {
[16:12:54.985]                         computeRestarts <- base::computeRestarts
[16:12:54.985]                         grepl <- base::grepl
[16:12:54.985]                         restarts <- computeRestarts(cond)
[16:12:54.985]                         for (restart in restarts) {
[16:12:54.985]                           name <- restart$name
[16:12:54.985]                           if (is.null(name)) 
[16:12:54.985]                             next
[16:12:54.985]                           if (!grepl(pattern, name)) 
[16:12:54.985]                             next
[16:12:54.985]                           invokeRestart(restart)
[16:12:54.985]                           muffled <- TRUE
[16:12:54.985]                           break
[16:12:54.985]                         }
[16:12:54.985]                       }
[16:12:54.985]                     }
[16:12:54.985]                     invisible(muffled)
[16:12:54.985]                   }
[16:12:54.985]                   muffleCondition(cond)
[16:12:54.985]                 })
[16:12:54.985]             }))
[16:12:54.985]             future::FutureResult(value = ...future.value$value, 
[16:12:54.985]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:54.985]                   ...future.rng), globalenv = if (FALSE) 
[16:12:54.985]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:54.985]                     ...future.globalenv.names))
[16:12:54.985]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:54.985]         }, condition = base::local({
[16:12:54.985]             c <- base::c
[16:12:54.985]             inherits <- base::inherits
[16:12:54.985]             invokeRestart <- base::invokeRestart
[16:12:54.985]             length <- base::length
[16:12:54.985]             list <- base::list
[16:12:54.985]             seq.int <- base::seq.int
[16:12:54.985]             signalCondition <- base::signalCondition
[16:12:54.985]             sys.calls <- base::sys.calls
[16:12:54.985]             `[[` <- base::`[[`
[16:12:54.985]             `+` <- base::`+`
[16:12:54.985]             `<<-` <- base::`<<-`
[16:12:54.985]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:54.985]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:54.985]                   3L)]
[16:12:54.985]             }
[16:12:54.985]             function(cond) {
[16:12:54.985]                 is_error <- inherits(cond, "error")
[16:12:54.985]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:54.985]                   NULL)
[16:12:54.985]                 if (is_error) {
[16:12:54.985]                   sessionInformation <- function() {
[16:12:54.985]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:54.985]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:54.985]                       search = base::search(), system = base::Sys.info())
[16:12:54.985]                   }
[16:12:54.985]                   ...future.conditions[[length(...future.conditions) + 
[16:12:54.985]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:54.985]                     cond$call), session = sessionInformation(), 
[16:12:54.985]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:54.985]                   signalCondition(cond)
[16:12:54.985]                 }
[16:12:54.985]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:54.985]                 "immediateCondition"))) {
[16:12:54.985]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:54.985]                   ...future.conditions[[length(...future.conditions) + 
[16:12:54.985]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:54.985]                   if (TRUE && !signal) {
[16:12:54.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.985]                     {
[16:12:54.985]                       inherits <- base::inherits
[16:12:54.985]                       invokeRestart <- base::invokeRestart
[16:12:54.985]                       is.null <- base::is.null
[16:12:54.985]                       muffled <- FALSE
[16:12:54.985]                       if (inherits(cond, "message")) {
[16:12:54.985]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:54.985]                         if (muffled) 
[16:12:54.985]                           invokeRestart("muffleMessage")
[16:12:54.985]                       }
[16:12:54.985]                       else if (inherits(cond, "warning")) {
[16:12:54.985]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:54.985]                         if (muffled) 
[16:12:54.985]                           invokeRestart("muffleWarning")
[16:12:54.985]                       }
[16:12:54.985]                       else if (inherits(cond, "condition")) {
[16:12:54.985]                         if (!is.null(pattern)) {
[16:12:54.985]                           computeRestarts <- base::computeRestarts
[16:12:54.985]                           grepl <- base::grepl
[16:12:54.985]                           restarts <- computeRestarts(cond)
[16:12:54.985]                           for (restart in restarts) {
[16:12:54.985]                             name <- restart$name
[16:12:54.985]                             if (is.null(name)) 
[16:12:54.985]                               next
[16:12:54.985]                             if (!grepl(pattern, name)) 
[16:12:54.985]                               next
[16:12:54.985]                             invokeRestart(restart)
[16:12:54.985]                             muffled <- TRUE
[16:12:54.985]                             break
[16:12:54.985]                           }
[16:12:54.985]                         }
[16:12:54.985]                       }
[16:12:54.985]                       invisible(muffled)
[16:12:54.985]                     }
[16:12:54.985]                     muffleCondition(cond, pattern = "^muffle")
[16:12:54.985]                   }
[16:12:54.985]                 }
[16:12:54.985]                 else {
[16:12:54.985]                   if (TRUE) {
[16:12:54.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:54.985]                     {
[16:12:54.985]                       inherits <- base::inherits
[16:12:54.985]                       invokeRestart <- base::invokeRestart
[16:12:54.985]                       is.null <- base::is.null
[16:12:54.985]                       muffled <- FALSE
[16:12:54.985]                       if (inherits(cond, "message")) {
[16:12:54.985]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:54.985]                         if (muffled) 
[16:12:54.985]                           invokeRestart("muffleMessage")
[16:12:54.985]                       }
[16:12:54.985]                       else if (inherits(cond, "warning")) {
[16:12:54.985]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:54.985]                         if (muffled) 
[16:12:54.985]                           invokeRestart("muffleWarning")
[16:12:54.985]                       }
[16:12:54.985]                       else if (inherits(cond, "condition")) {
[16:12:54.985]                         if (!is.null(pattern)) {
[16:12:54.985]                           computeRestarts <- base::computeRestarts
[16:12:54.985]                           grepl <- base::grepl
[16:12:54.985]                           restarts <- computeRestarts(cond)
[16:12:54.985]                           for (restart in restarts) {
[16:12:54.985]                             name <- restart$name
[16:12:54.985]                             if (is.null(name)) 
[16:12:54.985]                               next
[16:12:54.985]                             if (!grepl(pattern, name)) 
[16:12:54.985]                               next
[16:12:54.985]                             invokeRestart(restart)
[16:12:54.985]                             muffled <- TRUE
[16:12:54.985]                             break
[16:12:54.985]                           }
[16:12:54.985]                         }
[16:12:54.985]                       }
[16:12:54.985]                       invisible(muffled)
[16:12:54.985]                     }
[16:12:54.985]                     muffleCondition(cond, pattern = "^muffle")
[16:12:54.985]                   }
[16:12:54.985]                 }
[16:12:54.985]             }
[16:12:54.985]         }))
[16:12:54.985]     }, error = function(ex) {
[16:12:54.985]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:54.985]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:54.985]                 ...future.rng), started = ...future.startTime, 
[16:12:54.985]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:54.985]             version = "1.8"), class = "FutureResult")
[16:12:54.985]     }, finally = {
[16:12:54.985]         if (!identical(...future.workdir, getwd())) 
[16:12:54.985]             setwd(...future.workdir)
[16:12:54.985]         {
[16:12:54.985]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:54.985]                 ...future.oldOptions$nwarnings <- NULL
[16:12:54.985]             }
[16:12:54.985]             base::options(...future.oldOptions)
[16:12:54.985]             if (.Platform$OS.type == "windows") {
[16:12:54.985]                 old_names <- names(...future.oldEnvVars)
[16:12:54.985]                 envs <- base::Sys.getenv()
[16:12:54.985]                 names <- names(envs)
[16:12:54.985]                 common <- intersect(names, old_names)
[16:12:54.985]                 added <- setdiff(names, old_names)
[16:12:54.985]                 removed <- setdiff(old_names, names)
[16:12:54.985]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:54.985]                   envs[common]]
[16:12:54.985]                 NAMES <- toupper(changed)
[16:12:54.985]                 args <- list()
[16:12:54.985]                 for (kk in seq_along(NAMES)) {
[16:12:54.985]                   name <- changed[[kk]]
[16:12:54.985]                   NAME <- NAMES[[kk]]
[16:12:54.985]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.985]                     next
[16:12:54.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:54.985]                 }
[16:12:54.985]                 NAMES <- toupper(added)
[16:12:54.985]                 for (kk in seq_along(NAMES)) {
[16:12:54.985]                   name <- added[[kk]]
[16:12:54.985]                   NAME <- NAMES[[kk]]
[16:12:54.985]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.985]                     next
[16:12:54.985]                   args[[name]] <- ""
[16:12:54.985]                 }
[16:12:54.985]                 NAMES <- toupper(removed)
[16:12:54.985]                 for (kk in seq_along(NAMES)) {
[16:12:54.985]                   name <- removed[[kk]]
[16:12:54.985]                   NAME <- NAMES[[kk]]
[16:12:54.985]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:54.985]                     next
[16:12:54.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:54.985]                 }
[16:12:54.985]                 if (length(args) > 0) 
[16:12:54.985]                   base::do.call(base::Sys.setenv, args = args)
[16:12:54.985]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:54.985]             }
[16:12:54.985]             else {
[16:12:54.985]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:54.985]             }
[16:12:54.985]             {
[16:12:54.985]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:54.985]                   0L) {
[16:12:54.985]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:54.985]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:54.985]                   base::options(opts)
[16:12:54.985]                 }
[16:12:54.985]                 {
[16:12:54.985]                   {
[16:12:54.985]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:54.985]                     NULL
[16:12:54.985]                   }
[16:12:54.985]                   options(future.plan = NULL)
[16:12:54.985]                   if (is.na(NA_character_)) 
[16:12:54.985]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:54.985]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:54.985]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:54.985]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:54.985]                     envir = parent.frame()) 
[16:12:54.985]                   {
[16:12:54.985]                     if (is.function(workers)) 
[16:12:54.985]                       workers <- workers()
[16:12:54.985]                     workers <- structure(as.integer(workers), 
[16:12:54.985]                       class = class(workers))
[16:12:54.985]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:54.985]                       workers >= 1)
[16:12:54.985]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:54.985]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:54.985]                     }
[16:12:54.985]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:54.985]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:54.985]                       envir = envir)
[16:12:54.985]                     if (!future$lazy) 
[16:12:54.985]                       future <- run(future)
[16:12:54.985]                     invisible(future)
[16:12:54.985]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:54.985]                 }
[16:12:54.985]             }
[16:12:54.985]         }
[16:12:54.985]     })
[16:12:54.985]     if (TRUE) {
[16:12:54.985]         base::sink(type = "output", split = FALSE)
[16:12:54.985]         if (TRUE) {
[16:12:54.985]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:54.985]         }
[16:12:54.985]         else {
[16:12:54.985]             ...future.result["stdout"] <- base::list(NULL)
[16:12:54.985]         }
[16:12:54.985]         base::close(...future.stdout)
[16:12:54.985]         ...future.stdout <- NULL
[16:12:54.985]     }
[16:12:54.985]     ...future.result$conditions <- ...future.conditions
[16:12:54.985]     ...future.result$finished <- base::Sys.time()
[16:12:54.985]     ...future.result
[16:12:54.985] }
[16:12:54.988] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[16:12:54.988] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[16:12:54.988] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[16:12:54.988] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[16:12:54.989] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[16:12:54.989] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[16:12:54.989] MultisessionFuture started
[16:12:54.989] - Launch lazy future ... done
[16:12:54.989] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:54.990] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:54.990] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:54.992] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:54.992] Searching for globals ... DONE
[16:12:54.992] Resolving globals: TRUE
[16:12:54.992] Resolving any globals that are futures ...
[16:12:54.992] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:54.993] Resolving any globals that are futures ... DONE
[16:12:54.993] Resolving futures part of globals (recursively) ...
[16:12:54.993] resolve() on list ...
[16:12:54.993]  recursive: 99
[16:12:54.993]  length: 2
[16:12:54.993]  elements: ‘a’, ‘ii’
[16:12:54.993]  length: 1 (resolved future 1)
[16:12:54.994]  length: 0 (resolved future 2)
[16:12:54.994] resolve() on list ... DONE
[16:12:54.994] - globals: [2] ‘a’, ‘ii’
[16:12:54.994] Resolving futures part of globals (recursively) ... DONE
[16:12:54.994] The total size of the 2 globals is 112 bytes (112 bytes)
[16:12:54.994] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:12:54.995] - globals: [2] ‘a’, ‘ii’
[16:12:54.995] 
[16:12:54.995] getGlobalsAndPackages() ... DONE
[16:12:54.995] run() for ‘Future’ ...
[16:12:54.995] - state: ‘created’
[16:12:54.995] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:55.010] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:55.010] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:55.010]   - Field: ‘node’
[16:12:55.010]   - Field: ‘label’
[16:12:55.010]   - Field: ‘local’
[16:12:55.010]   - Field: ‘owner’
[16:12:55.010]   - Field: ‘envir’
[16:12:55.011]   - Field: ‘workers’
[16:12:55.011]   - Field: ‘packages’
[16:12:55.011]   - Field: ‘gc’
[16:12:55.011]   - Field: ‘conditions’
[16:12:55.011]   - Field: ‘persistent’
[16:12:55.011]   - Field: ‘expr’
[16:12:55.011]   - Field: ‘uuid’
[16:12:55.011]   - Field: ‘seed’
[16:12:55.011]   - Field: ‘version’
[16:12:55.011]   - Field: ‘result’
[16:12:55.011]   - Field: ‘asynchronous’
[16:12:55.012]   - Field: ‘calls’
[16:12:55.012]   - Field: ‘globals’
[16:12:55.012]   - Field: ‘stdout’
[16:12:55.012]   - Field: ‘earlySignal’
[16:12:55.012]   - Field: ‘lazy’
[16:12:55.012]   - Field: ‘state’
[16:12:55.012] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:55.012] - Launch lazy future ...
[16:12:55.012] Packages needed by the future expression (n = 0): <none>
[16:12:55.013] Packages needed by future strategies (n = 0): <none>
[16:12:55.013] {
[16:12:55.013]     {
[16:12:55.013]         {
[16:12:55.013]             ...future.startTime <- base::Sys.time()
[16:12:55.013]             {
[16:12:55.013]                 {
[16:12:55.013]                   {
[16:12:55.013]                     {
[16:12:55.013]                       base::local({
[16:12:55.013]                         has_future <- base::requireNamespace("future", 
[16:12:55.013]                           quietly = TRUE)
[16:12:55.013]                         if (has_future) {
[16:12:55.013]                           ns <- base::getNamespace("future")
[16:12:55.013]                           version <- ns[[".package"]][["version"]]
[16:12:55.013]                           if (is.null(version)) 
[16:12:55.013]                             version <- utils::packageVersion("future")
[16:12:55.013]                         }
[16:12:55.013]                         else {
[16:12:55.013]                           version <- NULL
[16:12:55.013]                         }
[16:12:55.013]                         if (!has_future || version < "1.8.0") {
[16:12:55.013]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:55.013]                             "", base::R.version$version.string), 
[16:12:55.013]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:55.013]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:55.013]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:55.013]                               "release", "version")], collapse = " "), 
[16:12:55.013]                             hostname = base::Sys.info()[["nodename"]])
[16:12:55.013]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:55.013]                             info)
[16:12:55.013]                           info <- base::paste(info, collapse = "; ")
[16:12:55.013]                           if (!has_future) {
[16:12:55.013]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:55.013]                               info)
[16:12:55.013]                           }
[16:12:55.013]                           else {
[16:12:55.013]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:55.013]                               info, version)
[16:12:55.013]                           }
[16:12:55.013]                           base::stop(msg)
[16:12:55.013]                         }
[16:12:55.013]                       })
[16:12:55.013]                     }
[16:12:55.013]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:55.013]                     base::options(mc.cores = 1L)
[16:12:55.013]                   }
[16:12:55.013]                   options(future.plan = NULL)
[16:12:55.013]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:55.013]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:55.013]                 }
[16:12:55.013]                 ...future.workdir <- getwd()
[16:12:55.013]             }
[16:12:55.013]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:55.013]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:55.013]         }
[16:12:55.013]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:55.013]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:55.013]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:55.013]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:55.013]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:55.013]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:55.013]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:55.013]             base::names(...future.oldOptions))
[16:12:55.013]     }
[16:12:55.013]     if (FALSE) {
[16:12:55.013]     }
[16:12:55.013]     else {
[16:12:55.013]         if (TRUE) {
[16:12:55.013]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:55.013]                 open = "w")
[16:12:55.013]         }
[16:12:55.013]         else {
[16:12:55.013]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:55.013]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:55.013]         }
[16:12:55.013]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:55.013]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:55.013]             base::sink(type = "output", split = FALSE)
[16:12:55.013]             base::close(...future.stdout)
[16:12:55.013]         }, add = TRUE)
[16:12:55.013]     }
[16:12:55.013]     ...future.frame <- base::sys.nframe()
[16:12:55.013]     ...future.conditions <- base::list()
[16:12:55.013]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:55.013]     if (FALSE) {
[16:12:55.013]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:55.013]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:55.013]     }
[16:12:55.013]     ...future.result <- base::tryCatch({
[16:12:55.013]         base::withCallingHandlers({
[16:12:55.013]             ...future.value <- base::withVisible(base::local({
[16:12:55.013]                 ...future.makeSendCondition <- local({
[16:12:55.013]                   sendCondition <- NULL
[16:12:55.013]                   function(frame = 1L) {
[16:12:55.013]                     if (is.function(sendCondition)) 
[16:12:55.013]                       return(sendCondition)
[16:12:55.013]                     ns <- getNamespace("parallel")
[16:12:55.013]                     if (exists("sendData", mode = "function", 
[16:12:55.013]                       envir = ns)) {
[16:12:55.013]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:55.013]                         envir = ns)
[16:12:55.013]                       envir <- sys.frame(frame)
[16:12:55.013]                       master <- NULL
[16:12:55.013]                       while (!identical(envir, .GlobalEnv) && 
[16:12:55.013]                         !identical(envir, emptyenv())) {
[16:12:55.013]                         if (exists("master", mode = "list", envir = envir, 
[16:12:55.013]                           inherits = FALSE)) {
[16:12:55.013]                           master <- get("master", mode = "list", 
[16:12:55.013]                             envir = envir, inherits = FALSE)
[16:12:55.013]                           if (inherits(master, c("SOCKnode", 
[16:12:55.013]                             "SOCK0node"))) {
[16:12:55.013]                             sendCondition <<- function(cond) {
[16:12:55.013]                               data <- list(type = "VALUE", value = cond, 
[16:12:55.013]                                 success = TRUE)
[16:12:55.013]                               parallel_sendData(master, data)
[16:12:55.013]                             }
[16:12:55.013]                             return(sendCondition)
[16:12:55.013]                           }
[16:12:55.013]                         }
[16:12:55.013]                         frame <- frame + 1L
[16:12:55.013]                         envir <- sys.frame(frame)
[16:12:55.013]                       }
[16:12:55.013]                     }
[16:12:55.013]                     sendCondition <<- function(cond) NULL
[16:12:55.013]                   }
[16:12:55.013]                 })
[16:12:55.013]                 withCallingHandlers({
[16:12:55.013]                   {
[16:12:55.013]                     b <- a * ii
[16:12:55.013]                     a <- 0
[16:12:55.013]                     b
[16:12:55.013]                   }
[16:12:55.013]                 }, immediateCondition = function(cond) {
[16:12:55.013]                   sendCondition <- ...future.makeSendCondition()
[16:12:55.013]                   sendCondition(cond)
[16:12:55.013]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.013]                   {
[16:12:55.013]                     inherits <- base::inherits
[16:12:55.013]                     invokeRestart <- base::invokeRestart
[16:12:55.013]                     is.null <- base::is.null
[16:12:55.013]                     muffled <- FALSE
[16:12:55.013]                     if (inherits(cond, "message")) {
[16:12:55.013]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:55.013]                       if (muffled) 
[16:12:55.013]                         invokeRestart("muffleMessage")
[16:12:55.013]                     }
[16:12:55.013]                     else if (inherits(cond, "warning")) {
[16:12:55.013]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:55.013]                       if (muffled) 
[16:12:55.013]                         invokeRestart("muffleWarning")
[16:12:55.013]                     }
[16:12:55.013]                     else if (inherits(cond, "condition")) {
[16:12:55.013]                       if (!is.null(pattern)) {
[16:12:55.013]                         computeRestarts <- base::computeRestarts
[16:12:55.013]                         grepl <- base::grepl
[16:12:55.013]                         restarts <- computeRestarts(cond)
[16:12:55.013]                         for (restart in restarts) {
[16:12:55.013]                           name <- restart$name
[16:12:55.013]                           if (is.null(name)) 
[16:12:55.013]                             next
[16:12:55.013]                           if (!grepl(pattern, name)) 
[16:12:55.013]                             next
[16:12:55.013]                           invokeRestart(restart)
[16:12:55.013]                           muffled <- TRUE
[16:12:55.013]                           break
[16:12:55.013]                         }
[16:12:55.013]                       }
[16:12:55.013]                     }
[16:12:55.013]                     invisible(muffled)
[16:12:55.013]                   }
[16:12:55.013]                   muffleCondition(cond)
[16:12:55.013]                 })
[16:12:55.013]             }))
[16:12:55.013]             future::FutureResult(value = ...future.value$value, 
[16:12:55.013]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:55.013]                   ...future.rng), globalenv = if (FALSE) 
[16:12:55.013]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:55.013]                     ...future.globalenv.names))
[16:12:55.013]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:55.013]         }, condition = base::local({
[16:12:55.013]             c <- base::c
[16:12:55.013]             inherits <- base::inherits
[16:12:55.013]             invokeRestart <- base::invokeRestart
[16:12:55.013]             length <- base::length
[16:12:55.013]             list <- base::list
[16:12:55.013]             seq.int <- base::seq.int
[16:12:55.013]             signalCondition <- base::signalCondition
[16:12:55.013]             sys.calls <- base::sys.calls
[16:12:55.013]             `[[` <- base::`[[`
[16:12:55.013]             `+` <- base::`+`
[16:12:55.013]             `<<-` <- base::`<<-`
[16:12:55.013]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:55.013]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:55.013]                   3L)]
[16:12:55.013]             }
[16:12:55.013]             function(cond) {
[16:12:55.013]                 is_error <- inherits(cond, "error")
[16:12:55.013]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:55.013]                   NULL)
[16:12:55.013]                 if (is_error) {
[16:12:55.013]                   sessionInformation <- function() {
[16:12:55.013]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:55.013]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:55.013]                       search = base::search(), system = base::Sys.info())
[16:12:55.013]                   }
[16:12:55.013]                   ...future.conditions[[length(...future.conditions) + 
[16:12:55.013]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:55.013]                     cond$call), session = sessionInformation(), 
[16:12:55.013]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:55.013]                   signalCondition(cond)
[16:12:55.013]                 }
[16:12:55.013]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:55.013]                 "immediateCondition"))) {
[16:12:55.013]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:55.013]                   ...future.conditions[[length(...future.conditions) + 
[16:12:55.013]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:55.013]                   if (TRUE && !signal) {
[16:12:55.013]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.013]                     {
[16:12:55.013]                       inherits <- base::inherits
[16:12:55.013]                       invokeRestart <- base::invokeRestart
[16:12:55.013]                       is.null <- base::is.null
[16:12:55.013]                       muffled <- FALSE
[16:12:55.013]                       if (inherits(cond, "message")) {
[16:12:55.013]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:55.013]                         if (muffled) 
[16:12:55.013]                           invokeRestart("muffleMessage")
[16:12:55.013]                       }
[16:12:55.013]                       else if (inherits(cond, "warning")) {
[16:12:55.013]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:55.013]                         if (muffled) 
[16:12:55.013]                           invokeRestart("muffleWarning")
[16:12:55.013]                       }
[16:12:55.013]                       else if (inherits(cond, "condition")) {
[16:12:55.013]                         if (!is.null(pattern)) {
[16:12:55.013]                           computeRestarts <- base::computeRestarts
[16:12:55.013]                           grepl <- base::grepl
[16:12:55.013]                           restarts <- computeRestarts(cond)
[16:12:55.013]                           for (restart in restarts) {
[16:12:55.013]                             name <- restart$name
[16:12:55.013]                             if (is.null(name)) 
[16:12:55.013]                               next
[16:12:55.013]                             if (!grepl(pattern, name)) 
[16:12:55.013]                               next
[16:12:55.013]                             invokeRestart(restart)
[16:12:55.013]                             muffled <- TRUE
[16:12:55.013]                             break
[16:12:55.013]                           }
[16:12:55.013]                         }
[16:12:55.013]                       }
[16:12:55.013]                       invisible(muffled)
[16:12:55.013]                     }
[16:12:55.013]                     muffleCondition(cond, pattern = "^muffle")
[16:12:55.013]                   }
[16:12:55.013]                 }
[16:12:55.013]                 else {
[16:12:55.013]                   if (TRUE) {
[16:12:55.013]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.013]                     {
[16:12:55.013]                       inherits <- base::inherits
[16:12:55.013]                       invokeRestart <- base::invokeRestart
[16:12:55.013]                       is.null <- base::is.null
[16:12:55.013]                       muffled <- FALSE
[16:12:55.013]                       if (inherits(cond, "message")) {
[16:12:55.013]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:55.013]                         if (muffled) 
[16:12:55.013]                           invokeRestart("muffleMessage")
[16:12:55.013]                       }
[16:12:55.013]                       else if (inherits(cond, "warning")) {
[16:12:55.013]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:55.013]                         if (muffled) 
[16:12:55.013]                           invokeRestart("muffleWarning")
[16:12:55.013]                       }
[16:12:55.013]                       else if (inherits(cond, "condition")) {
[16:12:55.013]                         if (!is.null(pattern)) {
[16:12:55.013]                           computeRestarts <- base::computeRestarts
[16:12:55.013]                           grepl <- base::grepl
[16:12:55.013]                           restarts <- computeRestarts(cond)
[16:12:55.013]                           for (restart in restarts) {
[16:12:55.013]                             name <- restart$name
[16:12:55.013]                             if (is.null(name)) 
[16:12:55.013]                               next
[16:12:55.013]                             if (!grepl(pattern, name)) 
[16:12:55.013]                               next
[16:12:55.013]                             invokeRestart(restart)
[16:12:55.013]                             muffled <- TRUE
[16:12:55.013]                             break
[16:12:55.013]                           }
[16:12:55.013]                         }
[16:12:55.013]                       }
[16:12:55.013]                       invisible(muffled)
[16:12:55.013]                     }
[16:12:55.013]                     muffleCondition(cond, pattern = "^muffle")
[16:12:55.013]                   }
[16:12:55.013]                 }
[16:12:55.013]             }
[16:12:55.013]         }))
[16:12:55.013]     }, error = function(ex) {
[16:12:55.013]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:55.013]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:55.013]                 ...future.rng), started = ...future.startTime, 
[16:12:55.013]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:55.013]             version = "1.8"), class = "FutureResult")
[16:12:55.013]     }, finally = {
[16:12:55.013]         if (!identical(...future.workdir, getwd())) 
[16:12:55.013]             setwd(...future.workdir)
[16:12:55.013]         {
[16:12:55.013]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:55.013]                 ...future.oldOptions$nwarnings <- NULL
[16:12:55.013]             }
[16:12:55.013]             base::options(...future.oldOptions)
[16:12:55.013]             if (.Platform$OS.type == "windows") {
[16:12:55.013]                 old_names <- names(...future.oldEnvVars)
[16:12:55.013]                 envs <- base::Sys.getenv()
[16:12:55.013]                 names <- names(envs)
[16:12:55.013]                 common <- intersect(names, old_names)
[16:12:55.013]                 added <- setdiff(names, old_names)
[16:12:55.013]                 removed <- setdiff(old_names, names)
[16:12:55.013]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:55.013]                   envs[common]]
[16:12:55.013]                 NAMES <- toupper(changed)
[16:12:55.013]                 args <- list()
[16:12:55.013]                 for (kk in seq_along(NAMES)) {
[16:12:55.013]                   name <- changed[[kk]]
[16:12:55.013]                   NAME <- NAMES[[kk]]
[16:12:55.013]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.013]                     next
[16:12:55.013]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:55.013]                 }
[16:12:55.013]                 NAMES <- toupper(added)
[16:12:55.013]                 for (kk in seq_along(NAMES)) {
[16:12:55.013]                   name <- added[[kk]]
[16:12:55.013]                   NAME <- NAMES[[kk]]
[16:12:55.013]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.013]                     next
[16:12:55.013]                   args[[name]] <- ""
[16:12:55.013]                 }
[16:12:55.013]                 NAMES <- toupper(removed)
[16:12:55.013]                 for (kk in seq_along(NAMES)) {
[16:12:55.013]                   name <- removed[[kk]]
[16:12:55.013]                   NAME <- NAMES[[kk]]
[16:12:55.013]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.013]                     next
[16:12:55.013]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:55.013]                 }
[16:12:55.013]                 if (length(args) > 0) 
[16:12:55.013]                   base::do.call(base::Sys.setenv, args = args)
[16:12:55.013]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:55.013]             }
[16:12:55.013]             else {
[16:12:55.013]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:55.013]             }
[16:12:55.013]             {
[16:12:55.013]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:55.013]                   0L) {
[16:12:55.013]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:55.013]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:55.013]                   base::options(opts)
[16:12:55.013]                 }
[16:12:55.013]                 {
[16:12:55.013]                   {
[16:12:55.013]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:55.013]                     NULL
[16:12:55.013]                   }
[16:12:55.013]                   options(future.plan = NULL)
[16:12:55.013]                   if (is.na(NA_character_)) 
[16:12:55.013]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:55.013]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:55.013]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:55.013]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:55.013]                     envir = parent.frame()) 
[16:12:55.013]                   {
[16:12:55.013]                     if (is.function(workers)) 
[16:12:55.013]                       workers <- workers()
[16:12:55.013]                     workers <- structure(as.integer(workers), 
[16:12:55.013]                       class = class(workers))
[16:12:55.013]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:55.013]                       workers >= 1)
[16:12:55.013]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:55.013]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:55.013]                     }
[16:12:55.013]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:55.013]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:55.013]                       envir = envir)
[16:12:55.013]                     if (!future$lazy) 
[16:12:55.013]                       future <- run(future)
[16:12:55.013]                     invisible(future)
[16:12:55.013]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:55.013]                 }
[16:12:55.013]             }
[16:12:55.013]         }
[16:12:55.013]     })
[16:12:55.013]     if (TRUE) {
[16:12:55.013]         base::sink(type = "output", split = FALSE)
[16:12:55.013]         if (TRUE) {
[16:12:55.013]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:55.013]         }
[16:12:55.013]         else {
[16:12:55.013]             ...future.result["stdout"] <- base::list(NULL)
[16:12:55.013]         }
[16:12:55.013]         base::close(...future.stdout)
[16:12:55.013]         ...future.stdout <- NULL
[16:12:55.013]     }
[16:12:55.013]     ...future.result$conditions <- ...future.conditions
[16:12:55.013]     ...future.result$finished <- base::Sys.time()
[16:12:55.013]     ...future.result
[16:12:55.013] }
[16:12:55.015] Poll #1 (0): usedNodes() = 2, workers = 2
[16:12:55.026] receiveMessageFromWorker() for ClusterFuture ...
[16:12:55.026] - Validating connection of MultisessionFuture
[16:12:55.027] - received message: FutureResult
[16:12:55.027] - Received FutureResult
[16:12:55.027] - Erased future from FutureRegistry
[16:12:55.027] result() for ClusterFuture ...
[16:12:55.027] - result already collected: FutureResult
[16:12:55.027] result() for ClusterFuture ... done
[16:12:55.027] signalConditions() ...
[16:12:55.027]  - include = ‘immediateCondition’
[16:12:55.028]  - exclude = 
[16:12:55.028]  - resignal = FALSE
[16:12:55.028]  - Number of conditions: 1
[16:12:55.028] signalConditions() ... done
[16:12:55.028] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:55.028] result() for ClusterFuture ...
[16:12:55.028] - result already collected: FutureResult
[16:12:55.028] result() for ClusterFuture ... done
[16:12:55.028] result() for ClusterFuture ...
[16:12:55.028] - result already collected: FutureResult
[16:12:55.029] result() for ClusterFuture ... done
[16:12:55.029] signalConditions() ...
[16:12:55.029]  - include = ‘immediateCondition’
[16:12:55.029]  - exclude = 
[16:12:55.029]  - resignal = FALSE
[16:12:55.029]  - Number of conditions: 1
[16:12:55.029] signalConditions() ... done
[16:12:55.030] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[16:12:55.030] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:12:55.030] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:12:55.031] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:12:55.031] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:12:55.031] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[16:12:55.032] MultisessionFuture started
[16:12:55.032] - Launch lazy future ... done
[16:12:55.032] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:55.033] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:55.033] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:55.035] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:55.035] Searching for globals ... DONE
[16:12:55.035] Resolving globals: TRUE
[16:12:55.035] Resolving any globals that are futures ...
[16:12:55.035] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:55.036] Resolving any globals that are futures ... DONE
[16:12:55.036] Resolving futures part of globals (recursively) ...
[16:12:55.036] resolve() on list ...
[16:12:55.037]  recursive: 99
[16:12:55.037]  length: 2
[16:12:55.037]  elements: ‘a’, ‘ii’
[16:12:55.037]  length: 1 (resolved future 1)
[16:12:55.037]  length: 0 (resolved future 2)
[16:12:55.037] resolve() on list ... DONE
[16:12:55.037] - globals: [2] ‘a’, ‘ii’
[16:12:55.037] Resolving futures part of globals (recursively) ... DONE
[16:12:55.038] The total size of the 2 globals is 112 bytes (112 bytes)
[16:12:55.038] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:12:55.038] - globals: [2] ‘a’, ‘ii’
[16:12:55.038] 
[16:12:55.039] getGlobalsAndPackages() ... DONE
[16:12:55.039] run() for ‘Future’ ...
[16:12:55.039] - state: ‘created’
[16:12:55.039] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:55.054] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:55.054] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:55.054]   - Field: ‘node’
[16:12:55.054]   - Field: ‘label’
[16:12:55.055]   - Field: ‘local’
[16:12:55.055]   - Field: ‘owner’
[16:12:55.055]   - Field: ‘envir’
[16:12:55.055]   - Field: ‘workers’
[16:12:55.055]   - Field: ‘packages’
[16:12:55.055]   - Field: ‘gc’
[16:12:55.055]   - Field: ‘conditions’
[16:12:55.055]   - Field: ‘persistent’
[16:12:55.055]   - Field: ‘expr’
[16:12:55.055]   - Field: ‘uuid’
[16:12:55.055]   - Field: ‘seed’
[16:12:55.056]   - Field: ‘version’
[16:12:55.056]   - Field: ‘result’
[16:12:55.056]   - Field: ‘asynchronous’
[16:12:55.056]   - Field: ‘calls’
[16:12:55.056]   - Field: ‘globals’
[16:12:55.056]   - Field: ‘stdout’
[16:12:55.056]   - Field: ‘earlySignal’
[16:12:55.056]   - Field: ‘lazy’
[16:12:55.056]   - Field: ‘state’
[16:12:55.056] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:55.057] - Launch lazy future ...
[16:12:55.057] Packages needed by the future expression (n = 0): <none>
[16:12:55.057] Packages needed by future strategies (n = 0): <none>
[16:12:55.057] {
[16:12:55.057]     {
[16:12:55.057]         {
[16:12:55.057]             ...future.startTime <- base::Sys.time()
[16:12:55.057]             {
[16:12:55.057]                 {
[16:12:55.057]                   {
[16:12:55.057]                     {
[16:12:55.057]                       base::local({
[16:12:55.057]                         has_future <- base::requireNamespace("future", 
[16:12:55.057]                           quietly = TRUE)
[16:12:55.057]                         if (has_future) {
[16:12:55.057]                           ns <- base::getNamespace("future")
[16:12:55.057]                           version <- ns[[".package"]][["version"]]
[16:12:55.057]                           if (is.null(version)) 
[16:12:55.057]                             version <- utils::packageVersion("future")
[16:12:55.057]                         }
[16:12:55.057]                         else {
[16:12:55.057]                           version <- NULL
[16:12:55.057]                         }
[16:12:55.057]                         if (!has_future || version < "1.8.0") {
[16:12:55.057]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:55.057]                             "", base::R.version$version.string), 
[16:12:55.057]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:55.057]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:55.057]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:55.057]                               "release", "version")], collapse = " "), 
[16:12:55.057]                             hostname = base::Sys.info()[["nodename"]])
[16:12:55.057]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:55.057]                             info)
[16:12:55.057]                           info <- base::paste(info, collapse = "; ")
[16:12:55.057]                           if (!has_future) {
[16:12:55.057]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:55.057]                               info)
[16:12:55.057]                           }
[16:12:55.057]                           else {
[16:12:55.057]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:55.057]                               info, version)
[16:12:55.057]                           }
[16:12:55.057]                           base::stop(msg)
[16:12:55.057]                         }
[16:12:55.057]                       })
[16:12:55.057]                     }
[16:12:55.057]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:55.057]                     base::options(mc.cores = 1L)
[16:12:55.057]                   }
[16:12:55.057]                   options(future.plan = NULL)
[16:12:55.057]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:55.057]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:55.057]                 }
[16:12:55.057]                 ...future.workdir <- getwd()
[16:12:55.057]             }
[16:12:55.057]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:55.057]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:55.057]         }
[16:12:55.057]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:55.057]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:55.057]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:55.057]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:55.057]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:55.057]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:55.057]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:55.057]             base::names(...future.oldOptions))
[16:12:55.057]     }
[16:12:55.057]     if (FALSE) {
[16:12:55.057]     }
[16:12:55.057]     else {
[16:12:55.057]         if (TRUE) {
[16:12:55.057]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:55.057]                 open = "w")
[16:12:55.057]         }
[16:12:55.057]         else {
[16:12:55.057]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:55.057]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:55.057]         }
[16:12:55.057]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:55.057]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:55.057]             base::sink(type = "output", split = FALSE)
[16:12:55.057]             base::close(...future.stdout)
[16:12:55.057]         }, add = TRUE)
[16:12:55.057]     }
[16:12:55.057]     ...future.frame <- base::sys.nframe()
[16:12:55.057]     ...future.conditions <- base::list()
[16:12:55.057]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:55.057]     if (FALSE) {
[16:12:55.057]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:55.057]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:55.057]     }
[16:12:55.057]     ...future.result <- base::tryCatch({
[16:12:55.057]         base::withCallingHandlers({
[16:12:55.057]             ...future.value <- base::withVisible(base::local({
[16:12:55.057]                 ...future.makeSendCondition <- local({
[16:12:55.057]                   sendCondition <- NULL
[16:12:55.057]                   function(frame = 1L) {
[16:12:55.057]                     if (is.function(sendCondition)) 
[16:12:55.057]                       return(sendCondition)
[16:12:55.057]                     ns <- getNamespace("parallel")
[16:12:55.057]                     if (exists("sendData", mode = "function", 
[16:12:55.057]                       envir = ns)) {
[16:12:55.057]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:55.057]                         envir = ns)
[16:12:55.057]                       envir <- sys.frame(frame)
[16:12:55.057]                       master <- NULL
[16:12:55.057]                       while (!identical(envir, .GlobalEnv) && 
[16:12:55.057]                         !identical(envir, emptyenv())) {
[16:12:55.057]                         if (exists("master", mode = "list", envir = envir, 
[16:12:55.057]                           inherits = FALSE)) {
[16:12:55.057]                           master <- get("master", mode = "list", 
[16:12:55.057]                             envir = envir, inherits = FALSE)
[16:12:55.057]                           if (inherits(master, c("SOCKnode", 
[16:12:55.057]                             "SOCK0node"))) {
[16:12:55.057]                             sendCondition <<- function(cond) {
[16:12:55.057]                               data <- list(type = "VALUE", value = cond, 
[16:12:55.057]                                 success = TRUE)
[16:12:55.057]                               parallel_sendData(master, data)
[16:12:55.057]                             }
[16:12:55.057]                             return(sendCondition)
[16:12:55.057]                           }
[16:12:55.057]                         }
[16:12:55.057]                         frame <- frame + 1L
[16:12:55.057]                         envir <- sys.frame(frame)
[16:12:55.057]                       }
[16:12:55.057]                     }
[16:12:55.057]                     sendCondition <<- function(cond) NULL
[16:12:55.057]                   }
[16:12:55.057]                 })
[16:12:55.057]                 withCallingHandlers({
[16:12:55.057]                   {
[16:12:55.057]                     b <- a * ii
[16:12:55.057]                     a <- 0
[16:12:55.057]                     b
[16:12:55.057]                   }
[16:12:55.057]                 }, immediateCondition = function(cond) {
[16:12:55.057]                   sendCondition <- ...future.makeSendCondition()
[16:12:55.057]                   sendCondition(cond)
[16:12:55.057]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.057]                   {
[16:12:55.057]                     inherits <- base::inherits
[16:12:55.057]                     invokeRestart <- base::invokeRestart
[16:12:55.057]                     is.null <- base::is.null
[16:12:55.057]                     muffled <- FALSE
[16:12:55.057]                     if (inherits(cond, "message")) {
[16:12:55.057]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:55.057]                       if (muffled) 
[16:12:55.057]                         invokeRestart("muffleMessage")
[16:12:55.057]                     }
[16:12:55.057]                     else if (inherits(cond, "warning")) {
[16:12:55.057]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:55.057]                       if (muffled) 
[16:12:55.057]                         invokeRestart("muffleWarning")
[16:12:55.057]                     }
[16:12:55.057]                     else if (inherits(cond, "condition")) {
[16:12:55.057]                       if (!is.null(pattern)) {
[16:12:55.057]                         computeRestarts <- base::computeRestarts
[16:12:55.057]                         grepl <- base::grepl
[16:12:55.057]                         restarts <- computeRestarts(cond)
[16:12:55.057]                         for (restart in restarts) {
[16:12:55.057]                           name <- restart$name
[16:12:55.057]                           if (is.null(name)) 
[16:12:55.057]                             next
[16:12:55.057]                           if (!grepl(pattern, name)) 
[16:12:55.057]                             next
[16:12:55.057]                           invokeRestart(restart)
[16:12:55.057]                           muffled <- TRUE
[16:12:55.057]                           break
[16:12:55.057]                         }
[16:12:55.057]                       }
[16:12:55.057]                     }
[16:12:55.057]                     invisible(muffled)
[16:12:55.057]                   }
[16:12:55.057]                   muffleCondition(cond)
[16:12:55.057]                 })
[16:12:55.057]             }))
[16:12:55.057]             future::FutureResult(value = ...future.value$value, 
[16:12:55.057]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:55.057]                   ...future.rng), globalenv = if (FALSE) 
[16:12:55.057]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:55.057]                     ...future.globalenv.names))
[16:12:55.057]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:55.057]         }, condition = base::local({
[16:12:55.057]             c <- base::c
[16:12:55.057]             inherits <- base::inherits
[16:12:55.057]             invokeRestart <- base::invokeRestart
[16:12:55.057]             length <- base::length
[16:12:55.057]             list <- base::list
[16:12:55.057]             seq.int <- base::seq.int
[16:12:55.057]             signalCondition <- base::signalCondition
[16:12:55.057]             sys.calls <- base::sys.calls
[16:12:55.057]             `[[` <- base::`[[`
[16:12:55.057]             `+` <- base::`+`
[16:12:55.057]             `<<-` <- base::`<<-`
[16:12:55.057]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:55.057]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:55.057]                   3L)]
[16:12:55.057]             }
[16:12:55.057]             function(cond) {
[16:12:55.057]                 is_error <- inherits(cond, "error")
[16:12:55.057]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:55.057]                   NULL)
[16:12:55.057]                 if (is_error) {
[16:12:55.057]                   sessionInformation <- function() {
[16:12:55.057]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:55.057]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:55.057]                       search = base::search(), system = base::Sys.info())
[16:12:55.057]                   }
[16:12:55.057]                   ...future.conditions[[length(...future.conditions) + 
[16:12:55.057]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:55.057]                     cond$call), session = sessionInformation(), 
[16:12:55.057]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:55.057]                   signalCondition(cond)
[16:12:55.057]                 }
[16:12:55.057]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:55.057]                 "immediateCondition"))) {
[16:12:55.057]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:55.057]                   ...future.conditions[[length(...future.conditions) + 
[16:12:55.057]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:55.057]                   if (TRUE && !signal) {
[16:12:55.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.057]                     {
[16:12:55.057]                       inherits <- base::inherits
[16:12:55.057]                       invokeRestart <- base::invokeRestart
[16:12:55.057]                       is.null <- base::is.null
[16:12:55.057]                       muffled <- FALSE
[16:12:55.057]                       if (inherits(cond, "message")) {
[16:12:55.057]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:55.057]                         if (muffled) 
[16:12:55.057]                           invokeRestart("muffleMessage")
[16:12:55.057]                       }
[16:12:55.057]                       else if (inherits(cond, "warning")) {
[16:12:55.057]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:55.057]                         if (muffled) 
[16:12:55.057]                           invokeRestart("muffleWarning")
[16:12:55.057]                       }
[16:12:55.057]                       else if (inherits(cond, "condition")) {
[16:12:55.057]                         if (!is.null(pattern)) {
[16:12:55.057]                           computeRestarts <- base::computeRestarts
[16:12:55.057]                           grepl <- base::grepl
[16:12:55.057]                           restarts <- computeRestarts(cond)
[16:12:55.057]                           for (restart in restarts) {
[16:12:55.057]                             name <- restart$name
[16:12:55.057]                             if (is.null(name)) 
[16:12:55.057]                               next
[16:12:55.057]                             if (!grepl(pattern, name)) 
[16:12:55.057]                               next
[16:12:55.057]                             invokeRestart(restart)
[16:12:55.057]                             muffled <- TRUE
[16:12:55.057]                             break
[16:12:55.057]                           }
[16:12:55.057]                         }
[16:12:55.057]                       }
[16:12:55.057]                       invisible(muffled)
[16:12:55.057]                     }
[16:12:55.057]                     muffleCondition(cond, pattern = "^muffle")
[16:12:55.057]                   }
[16:12:55.057]                 }
[16:12:55.057]                 else {
[16:12:55.057]                   if (TRUE) {
[16:12:55.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.057]                     {
[16:12:55.057]                       inherits <- base::inherits
[16:12:55.057]                       invokeRestart <- base::invokeRestart
[16:12:55.057]                       is.null <- base::is.null
[16:12:55.057]                       muffled <- FALSE
[16:12:55.057]                       if (inherits(cond, "message")) {
[16:12:55.057]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:55.057]                         if (muffled) 
[16:12:55.057]                           invokeRestart("muffleMessage")
[16:12:55.057]                       }
[16:12:55.057]                       else if (inherits(cond, "warning")) {
[16:12:55.057]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:55.057]                         if (muffled) 
[16:12:55.057]                           invokeRestart("muffleWarning")
[16:12:55.057]                       }
[16:12:55.057]                       else if (inherits(cond, "condition")) {
[16:12:55.057]                         if (!is.null(pattern)) {
[16:12:55.057]                           computeRestarts <- base::computeRestarts
[16:12:55.057]                           grepl <- base::grepl
[16:12:55.057]                           restarts <- computeRestarts(cond)
[16:12:55.057]                           for (restart in restarts) {
[16:12:55.057]                             name <- restart$name
[16:12:55.057]                             if (is.null(name)) 
[16:12:55.057]                               next
[16:12:55.057]                             if (!grepl(pattern, name)) 
[16:12:55.057]                               next
[16:12:55.057]                             invokeRestart(restart)
[16:12:55.057]                             muffled <- TRUE
[16:12:55.057]                             break
[16:12:55.057]                           }
[16:12:55.057]                         }
[16:12:55.057]                       }
[16:12:55.057]                       invisible(muffled)
[16:12:55.057]                     }
[16:12:55.057]                     muffleCondition(cond, pattern = "^muffle")
[16:12:55.057]                   }
[16:12:55.057]                 }
[16:12:55.057]             }
[16:12:55.057]         }))
[16:12:55.057]     }, error = function(ex) {
[16:12:55.057]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:55.057]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:55.057]                 ...future.rng), started = ...future.startTime, 
[16:12:55.057]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:55.057]             version = "1.8"), class = "FutureResult")
[16:12:55.057]     }, finally = {
[16:12:55.057]         if (!identical(...future.workdir, getwd())) 
[16:12:55.057]             setwd(...future.workdir)
[16:12:55.057]         {
[16:12:55.057]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:55.057]                 ...future.oldOptions$nwarnings <- NULL
[16:12:55.057]             }
[16:12:55.057]             base::options(...future.oldOptions)
[16:12:55.057]             if (.Platform$OS.type == "windows") {
[16:12:55.057]                 old_names <- names(...future.oldEnvVars)
[16:12:55.057]                 envs <- base::Sys.getenv()
[16:12:55.057]                 names <- names(envs)
[16:12:55.057]                 common <- intersect(names, old_names)
[16:12:55.057]                 added <- setdiff(names, old_names)
[16:12:55.057]                 removed <- setdiff(old_names, names)
[16:12:55.057]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:55.057]                   envs[common]]
[16:12:55.057]                 NAMES <- toupper(changed)
[16:12:55.057]                 args <- list()
[16:12:55.057]                 for (kk in seq_along(NAMES)) {
[16:12:55.057]                   name <- changed[[kk]]
[16:12:55.057]                   NAME <- NAMES[[kk]]
[16:12:55.057]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.057]                     next
[16:12:55.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:55.057]                 }
[16:12:55.057]                 NAMES <- toupper(added)
[16:12:55.057]                 for (kk in seq_along(NAMES)) {
[16:12:55.057]                   name <- added[[kk]]
[16:12:55.057]                   NAME <- NAMES[[kk]]
[16:12:55.057]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.057]                     next
[16:12:55.057]                   args[[name]] <- ""
[16:12:55.057]                 }
[16:12:55.057]                 NAMES <- toupper(removed)
[16:12:55.057]                 for (kk in seq_along(NAMES)) {
[16:12:55.057]                   name <- removed[[kk]]
[16:12:55.057]                   NAME <- NAMES[[kk]]
[16:12:55.057]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.057]                     next
[16:12:55.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:55.057]                 }
[16:12:55.057]                 if (length(args) > 0) 
[16:12:55.057]                   base::do.call(base::Sys.setenv, args = args)
[16:12:55.057]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:55.057]             }
[16:12:55.057]             else {
[16:12:55.057]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:55.057]             }
[16:12:55.057]             {
[16:12:55.057]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:55.057]                   0L) {
[16:12:55.057]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:55.057]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:55.057]                   base::options(opts)
[16:12:55.057]                 }
[16:12:55.057]                 {
[16:12:55.057]                   {
[16:12:55.057]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:55.057]                     NULL
[16:12:55.057]                   }
[16:12:55.057]                   options(future.plan = NULL)
[16:12:55.057]                   if (is.na(NA_character_)) 
[16:12:55.057]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:55.057]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:55.057]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:55.057]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:55.057]                     envir = parent.frame()) 
[16:12:55.057]                   {
[16:12:55.057]                     if (is.function(workers)) 
[16:12:55.057]                       workers <- workers()
[16:12:55.057]                     workers <- structure(as.integer(workers), 
[16:12:55.057]                       class = class(workers))
[16:12:55.057]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:55.057]                       workers >= 1)
[16:12:55.057]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:55.057]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:55.057]                     }
[16:12:55.057]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:55.057]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:55.057]                       envir = envir)
[16:12:55.057]                     if (!future$lazy) 
[16:12:55.057]                       future <- run(future)
[16:12:55.057]                     invisible(future)
[16:12:55.057]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:55.057]                 }
[16:12:55.057]             }
[16:12:55.057]         }
[16:12:55.057]     })
[16:12:55.057]     if (TRUE) {
[16:12:55.057]         base::sink(type = "output", split = FALSE)
[16:12:55.057]         if (TRUE) {
[16:12:55.057]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:55.057]         }
[16:12:55.057]         else {
[16:12:55.057]             ...future.result["stdout"] <- base::list(NULL)
[16:12:55.057]         }
[16:12:55.057]         base::close(...future.stdout)
[16:12:55.057]         ...future.stdout <- NULL
[16:12:55.057]     }
[16:12:55.057]     ...future.result$conditions <- ...future.conditions
[16:12:55.057]     ...future.result$finished <- base::Sys.time()
[16:12:55.057]     ...future.result
[16:12:55.057] }
[16:12:55.060] Poll #1 (0): usedNodes() = 2, workers = 2
[16:12:55.071] receiveMessageFromWorker() for ClusterFuture ...
[16:12:55.071] - Validating connection of MultisessionFuture
[16:12:55.071] - received message: FutureResult
[16:12:55.071] - Received FutureResult
[16:12:55.071] - Erased future from FutureRegistry
[16:12:55.071] result() for ClusterFuture ...
[16:12:55.071] - result already collected: FutureResult
[16:12:55.072] result() for ClusterFuture ... done
[16:12:55.072] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:55.072] result() for ClusterFuture ...
[16:12:55.072] - result already collected: FutureResult
[16:12:55.072] result() for ClusterFuture ... done
[16:12:55.072] result() for ClusterFuture ...
[16:12:55.073] - result already collected: FutureResult
[16:12:55.073] result() for ClusterFuture ... done
[16:12:55.074] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[16:12:55.074] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[16:12:55.074] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[16:12:55.075] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[16:12:55.075] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[16:12:55.075] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[16:12:55.076] MultisessionFuture started
[16:12:55.076] - Launch lazy future ... done
[16:12:55.076] run() for ‘MultisessionFuture’ ... done
[16:12:55.076] result() for ClusterFuture ...
[16:12:55.076] - result already collected: FutureResult
[16:12:55.077] result() for ClusterFuture ... done
[16:12:55.077] result() for ClusterFuture ...
[16:12:55.077] - result already collected: FutureResult
[16:12:55.077] result() for ClusterFuture ... done
[16:12:55.077] result() for ClusterFuture ...
[16:12:55.077] receiveMessageFromWorker() for ClusterFuture ...
[16:12:55.078] - Validating connection of MultisessionFuture
[16:12:55.078] - received message: FutureResult
[16:12:55.078] - Received FutureResult
[16:12:55.078] - Erased future from FutureRegistry
[16:12:55.078] result() for ClusterFuture ...
[16:12:55.079] - result already collected: FutureResult
[16:12:55.079] result() for ClusterFuture ... done
[16:12:55.079] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:55.079] result() for ClusterFuture ... done
[16:12:55.079] result() for ClusterFuture ...
[16:12:55.079] - result already collected: FutureResult
[16:12:55.079] result() for ClusterFuture ... done
[16:12:55.079] result() for ClusterFuture ...
[16:12:55.079] receiveMessageFromWorker() for ClusterFuture ...
[16:12:55.079] - Validating connection of MultisessionFuture
[16:12:55.121] - received message: FutureResult
[16:12:55.121] - Received FutureResult
[16:12:55.122] - Erased future from FutureRegistry
[16:12:55.122] result() for ClusterFuture ...
[16:12:55.122] - result already collected: FutureResult
[16:12:55.122] result() for ClusterFuture ... done
[16:12:55.122] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:55.122] result() for ClusterFuture ... done
[16:12:55.122] result() for ClusterFuture ...
[16:12:55.122] - result already collected: FutureResult
[16:12:55.122] result() for ClusterFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:55.123] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:55.123] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:55.125] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:55.125] Searching for globals ... DONE
[16:12:55.125] Resolving globals: TRUE
[16:12:55.126] Resolving any globals that are futures ...
[16:12:55.126] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:55.126] Resolving any globals that are futures ... DONE
[16:12:55.126] Resolving futures part of globals (recursively) ...
[16:12:55.126] resolve() on list ...
[16:12:55.126]  recursive: 99
[16:12:55.127]  length: 2
[16:12:55.127]  elements: ‘a’, ‘ii’
[16:12:55.127]  length: 1 (resolved future 1)
[16:12:55.127]  length: 0 (resolved future 2)
[16:12:55.127] resolve() on list ... DONE
[16:12:55.127] - globals: [2] ‘a’, ‘ii’
[16:12:55.127] Resolving futures part of globals (recursively) ... DONE
[16:12:55.127] The total size of the 2 globals is 112 bytes (112 bytes)
[16:12:55.128] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:12:55.128] - globals: [2] ‘a’, ‘ii’
[16:12:55.128] 
[16:12:55.128] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:55.129] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:55.129] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:55.131] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:55.131] Searching for globals ... DONE
[16:12:55.131] Resolving globals: TRUE
[16:12:55.131] Resolving any globals that are futures ...
[16:12:55.131] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:55.131] Resolving any globals that are futures ... DONE
[16:12:55.131] Resolving futures part of globals (recursively) ...
[16:12:55.132] resolve() on list ...
[16:12:55.132]  recursive: 99
[16:12:55.132]  length: 2
[16:12:55.132]  elements: ‘a’, ‘ii’
[16:12:55.132]  length: 1 (resolved future 1)
[16:12:55.132]  length: 0 (resolved future 2)
[16:12:55.132] resolve() on list ... DONE
[16:12:55.132] - globals: [2] ‘a’, ‘ii’
[16:12:55.133] Resolving futures part of globals (recursively) ... DONE
[16:12:55.133] The total size of the 2 globals is 112 bytes (112 bytes)
[16:12:55.133] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:12:55.133] - globals: [2] ‘a’, ‘ii’
[16:12:55.133] 
[16:12:55.133] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:55.134] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:55.134] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:55.136] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:55.136] Searching for globals ... DONE
[16:12:55.136] Resolving globals: TRUE
[16:12:55.136] Resolving any globals that are futures ...
[16:12:55.136] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[16:12:55.136] Resolving any globals that are futures ... DONE
[16:12:55.137] Resolving futures part of globals (recursively) ...
[16:12:55.137] resolve() on list ...
[16:12:55.137]  recursive: 99
[16:12:55.137]  length: 2
[16:12:55.137]  elements: ‘a’, ‘ii’
[16:12:55.137]  length: 1 (resolved future 1)
[16:12:55.137]  length: 0 (resolved future 2)
[16:12:55.138] resolve() on list ... DONE
[16:12:55.138] - globals: [2] ‘a’, ‘ii’
[16:12:55.138] Resolving futures part of globals (recursively) ... DONE
[16:12:55.138] The total size of the 2 globals is 112 bytes (112 bytes)
[16:12:55.138] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:12:55.138] - globals: [2] ‘a’, ‘ii’
[16:12:55.139] 
[16:12:55.139] getGlobalsAndPackages() ... DONE
[16:12:55.139] run() for ‘Future’ ...
[16:12:55.139] - state: ‘created’
[16:12:55.139] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:55.154] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:55.155] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:55.155]   - Field: ‘node’
[16:12:55.155]   - Field: ‘label’
[16:12:55.155]   - Field: ‘local’
[16:12:55.155]   - Field: ‘owner’
[16:12:55.155]   - Field: ‘envir’
[16:12:55.155]   - Field: ‘workers’
[16:12:55.155]   - Field: ‘packages’
[16:12:55.155]   - Field: ‘gc’
[16:12:55.156]   - Field: ‘conditions’
[16:12:55.156]   - Field: ‘persistent’
[16:12:55.156]   - Field: ‘expr’
[16:12:55.156]   - Field: ‘uuid’
[16:12:55.156]   - Field: ‘seed’
[16:12:55.156]   - Field: ‘version’
[16:12:55.156]   - Field: ‘result’
[16:12:55.156]   - Field: ‘asynchronous’
[16:12:55.156]   - Field: ‘calls’
[16:12:55.156]   - Field: ‘globals’
[16:12:55.157]   - Field: ‘stdout’
[16:12:55.159]   - Field: ‘earlySignal’
[16:12:55.159]   - Field: ‘lazy’
[16:12:55.159]   - Field: ‘state’
[16:12:55.159] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:55.159] - Launch lazy future ...
[16:12:55.159] Packages needed by the future expression (n = 0): <none>
[16:12:55.160] Packages needed by future strategies (n = 0): <none>
[16:12:55.160] {
[16:12:55.160]     {
[16:12:55.160]         {
[16:12:55.160]             ...future.startTime <- base::Sys.time()
[16:12:55.160]             {
[16:12:55.160]                 {
[16:12:55.160]                   {
[16:12:55.160]                     {
[16:12:55.160]                       base::local({
[16:12:55.160]                         has_future <- base::requireNamespace("future", 
[16:12:55.160]                           quietly = TRUE)
[16:12:55.160]                         if (has_future) {
[16:12:55.160]                           ns <- base::getNamespace("future")
[16:12:55.160]                           version <- ns[[".package"]][["version"]]
[16:12:55.160]                           if (is.null(version)) 
[16:12:55.160]                             version <- utils::packageVersion("future")
[16:12:55.160]                         }
[16:12:55.160]                         else {
[16:12:55.160]                           version <- NULL
[16:12:55.160]                         }
[16:12:55.160]                         if (!has_future || version < "1.8.0") {
[16:12:55.160]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:55.160]                             "", base::R.version$version.string), 
[16:12:55.160]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:55.160]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:55.160]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:55.160]                               "release", "version")], collapse = " "), 
[16:12:55.160]                             hostname = base::Sys.info()[["nodename"]])
[16:12:55.160]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:55.160]                             info)
[16:12:55.160]                           info <- base::paste(info, collapse = "; ")
[16:12:55.160]                           if (!has_future) {
[16:12:55.160]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:55.160]                               info)
[16:12:55.160]                           }
[16:12:55.160]                           else {
[16:12:55.160]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:55.160]                               info, version)
[16:12:55.160]                           }
[16:12:55.160]                           base::stop(msg)
[16:12:55.160]                         }
[16:12:55.160]                       })
[16:12:55.160]                     }
[16:12:55.160]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:55.160]                     base::options(mc.cores = 1L)
[16:12:55.160]                   }
[16:12:55.160]                   options(future.plan = NULL)
[16:12:55.160]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:55.160]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:55.160]                 }
[16:12:55.160]                 ...future.workdir <- getwd()
[16:12:55.160]             }
[16:12:55.160]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:55.160]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:55.160]         }
[16:12:55.160]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:55.160]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:55.160]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:55.160]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:55.160]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:55.160]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:55.160]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:55.160]             base::names(...future.oldOptions))
[16:12:55.160]     }
[16:12:55.160]     if (FALSE) {
[16:12:55.160]     }
[16:12:55.160]     else {
[16:12:55.160]         if (TRUE) {
[16:12:55.160]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:55.160]                 open = "w")
[16:12:55.160]         }
[16:12:55.160]         else {
[16:12:55.160]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:55.160]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:55.160]         }
[16:12:55.160]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:55.160]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:55.160]             base::sink(type = "output", split = FALSE)
[16:12:55.160]             base::close(...future.stdout)
[16:12:55.160]         }, add = TRUE)
[16:12:55.160]     }
[16:12:55.160]     ...future.frame <- base::sys.nframe()
[16:12:55.160]     ...future.conditions <- base::list()
[16:12:55.160]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:55.160]     if (FALSE) {
[16:12:55.160]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:55.160]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:55.160]     }
[16:12:55.160]     ...future.result <- base::tryCatch({
[16:12:55.160]         base::withCallingHandlers({
[16:12:55.160]             ...future.value <- base::withVisible(base::local({
[16:12:55.160]                 ...future.makeSendCondition <- local({
[16:12:55.160]                   sendCondition <- NULL
[16:12:55.160]                   function(frame = 1L) {
[16:12:55.160]                     if (is.function(sendCondition)) 
[16:12:55.160]                       return(sendCondition)
[16:12:55.160]                     ns <- getNamespace("parallel")
[16:12:55.160]                     if (exists("sendData", mode = "function", 
[16:12:55.160]                       envir = ns)) {
[16:12:55.160]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:55.160]                         envir = ns)
[16:12:55.160]                       envir <- sys.frame(frame)
[16:12:55.160]                       master <- NULL
[16:12:55.160]                       while (!identical(envir, .GlobalEnv) && 
[16:12:55.160]                         !identical(envir, emptyenv())) {
[16:12:55.160]                         if (exists("master", mode = "list", envir = envir, 
[16:12:55.160]                           inherits = FALSE)) {
[16:12:55.160]                           master <- get("master", mode = "list", 
[16:12:55.160]                             envir = envir, inherits = FALSE)
[16:12:55.160]                           if (inherits(master, c("SOCKnode", 
[16:12:55.160]                             "SOCK0node"))) {
[16:12:55.160]                             sendCondition <<- function(cond) {
[16:12:55.160]                               data <- list(type = "VALUE", value = cond, 
[16:12:55.160]                                 success = TRUE)
[16:12:55.160]                               parallel_sendData(master, data)
[16:12:55.160]                             }
[16:12:55.160]                             return(sendCondition)
[16:12:55.160]                           }
[16:12:55.160]                         }
[16:12:55.160]                         frame <- frame + 1L
[16:12:55.160]                         envir <- sys.frame(frame)
[16:12:55.160]                       }
[16:12:55.160]                     }
[16:12:55.160]                     sendCondition <<- function(cond) NULL
[16:12:55.160]                   }
[16:12:55.160]                 })
[16:12:55.160]                 withCallingHandlers({
[16:12:55.160]                   {
[16:12:55.160]                     b <- a * ii
[16:12:55.160]                     a <- 0
[16:12:55.160]                     b
[16:12:55.160]                   }
[16:12:55.160]                 }, immediateCondition = function(cond) {
[16:12:55.160]                   sendCondition <- ...future.makeSendCondition()
[16:12:55.160]                   sendCondition(cond)
[16:12:55.160]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.160]                   {
[16:12:55.160]                     inherits <- base::inherits
[16:12:55.160]                     invokeRestart <- base::invokeRestart
[16:12:55.160]                     is.null <- base::is.null
[16:12:55.160]                     muffled <- FALSE
[16:12:55.160]                     if (inherits(cond, "message")) {
[16:12:55.160]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:55.160]                       if (muffled) 
[16:12:55.160]                         invokeRestart("muffleMessage")
[16:12:55.160]                     }
[16:12:55.160]                     else if (inherits(cond, "warning")) {
[16:12:55.160]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:55.160]                       if (muffled) 
[16:12:55.160]                         invokeRestart("muffleWarning")
[16:12:55.160]                     }
[16:12:55.160]                     else if (inherits(cond, "condition")) {
[16:12:55.160]                       if (!is.null(pattern)) {
[16:12:55.160]                         computeRestarts <- base::computeRestarts
[16:12:55.160]                         grepl <- base::grepl
[16:12:55.160]                         restarts <- computeRestarts(cond)
[16:12:55.160]                         for (restart in restarts) {
[16:12:55.160]                           name <- restart$name
[16:12:55.160]                           if (is.null(name)) 
[16:12:55.160]                             next
[16:12:55.160]                           if (!grepl(pattern, name)) 
[16:12:55.160]                             next
[16:12:55.160]                           invokeRestart(restart)
[16:12:55.160]                           muffled <- TRUE
[16:12:55.160]                           break
[16:12:55.160]                         }
[16:12:55.160]                       }
[16:12:55.160]                     }
[16:12:55.160]                     invisible(muffled)
[16:12:55.160]                   }
[16:12:55.160]                   muffleCondition(cond)
[16:12:55.160]                 })
[16:12:55.160]             }))
[16:12:55.160]             future::FutureResult(value = ...future.value$value, 
[16:12:55.160]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:55.160]                   ...future.rng), globalenv = if (FALSE) 
[16:12:55.160]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:55.160]                     ...future.globalenv.names))
[16:12:55.160]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:55.160]         }, condition = base::local({
[16:12:55.160]             c <- base::c
[16:12:55.160]             inherits <- base::inherits
[16:12:55.160]             invokeRestart <- base::invokeRestart
[16:12:55.160]             length <- base::length
[16:12:55.160]             list <- base::list
[16:12:55.160]             seq.int <- base::seq.int
[16:12:55.160]             signalCondition <- base::signalCondition
[16:12:55.160]             sys.calls <- base::sys.calls
[16:12:55.160]             `[[` <- base::`[[`
[16:12:55.160]             `+` <- base::`+`
[16:12:55.160]             `<<-` <- base::`<<-`
[16:12:55.160]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:55.160]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:55.160]                   3L)]
[16:12:55.160]             }
[16:12:55.160]             function(cond) {
[16:12:55.160]                 is_error <- inherits(cond, "error")
[16:12:55.160]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:55.160]                   NULL)
[16:12:55.160]                 if (is_error) {
[16:12:55.160]                   sessionInformation <- function() {
[16:12:55.160]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:55.160]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:55.160]                       search = base::search(), system = base::Sys.info())
[16:12:55.160]                   }
[16:12:55.160]                   ...future.conditions[[length(...future.conditions) + 
[16:12:55.160]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:55.160]                     cond$call), session = sessionInformation(), 
[16:12:55.160]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:55.160]                   signalCondition(cond)
[16:12:55.160]                 }
[16:12:55.160]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:55.160]                 "immediateCondition"))) {
[16:12:55.160]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:55.160]                   ...future.conditions[[length(...future.conditions) + 
[16:12:55.160]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:55.160]                   if (TRUE && !signal) {
[16:12:55.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.160]                     {
[16:12:55.160]                       inherits <- base::inherits
[16:12:55.160]                       invokeRestart <- base::invokeRestart
[16:12:55.160]                       is.null <- base::is.null
[16:12:55.160]                       muffled <- FALSE
[16:12:55.160]                       if (inherits(cond, "message")) {
[16:12:55.160]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:55.160]                         if (muffled) 
[16:12:55.160]                           invokeRestart("muffleMessage")
[16:12:55.160]                       }
[16:12:55.160]                       else if (inherits(cond, "warning")) {
[16:12:55.160]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:55.160]                         if (muffled) 
[16:12:55.160]                           invokeRestart("muffleWarning")
[16:12:55.160]                       }
[16:12:55.160]                       else if (inherits(cond, "condition")) {
[16:12:55.160]                         if (!is.null(pattern)) {
[16:12:55.160]                           computeRestarts <- base::computeRestarts
[16:12:55.160]                           grepl <- base::grepl
[16:12:55.160]                           restarts <- computeRestarts(cond)
[16:12:55.160]                           for (restart in restarts) {
[16:12:55.160]                             name <- restart$name
[16:12:55.160]                             if (is.null(name)) 
[16:12:55.160]                               next
[16:12:55.160]                             if (!grepl(pattern, name)) 
[16:12:55.160]                               next
[16:12:55.160]                             invokeRestart(restart)
[16:12:55.160]                             muffled <- TRUE
[16:12:55.160]                             break
[16:12:55.160]                           }
[16:12:55.160]                         }
[16:12:55.160]                       }
[16:12:55.160]                       invisible(muffled)
[16:12:55.160]                     }
[16:12:55.160]                     muffleCondition(cond, pattern = "^muffle")
[16:12:55.160]                   }
[16:12:55.160]                 }
[16:12:55.160]                 else {
[16:12:55.160]                   if (TRUE) {
[16:12:55.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.160]                     {
[16:12:55.160]                       inherits <- base::inherits
[16:12:55.160]                       invokeRestart <- base::invokeRestart
[16:12:55.160]                       is.null <- base::is.null
[16:12:55.160]                       muffled <- FALSE
[16:12:55.160]                       if (inherits(cond, "message")) {
[16:12:55.160]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:55.160]                         if (muffled) 
[16:12:55.160]                           invokeRestart("muffleMessage")
[16:12:55.160]                       }
[16:12:55.160]                       else if (inherits(cond, "warning")) {
[16:12:55.160]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:55.160]                         if (muffled) 
[16:12:55.160]                           invokeRestart("muffleWarning")
[16:12:55.160]                       }
[16:12:55.160]                       else if (inherits(cond, "condition")) {
[16:12:55.160]                         if (!is.null(pattern)) {
[16:12:55.160]                           computeRestarts <- base::computeRestarts
[16:12:55.160]                           grepl <- base::grepl
[16:12:55.160]                           restarts <- computeRestarts(cond)
[16:12:55.160]                           for (restart in restarts) {
[16:12:55.160]                             name <- restart$name
[16:12:55.160]                             if (is.null(name)) 
[16:12:55.160]                               next
[16:12:55.160]                             if (!grepl(pattern, name)) 
[16:12:55.160]                               next
[16:12:55.160]                             invokeRestart(restart)
[16:12:55.160]                             muffled <- TRUE
[16:12:55.160]                             break
[16:12:55.160]                           }
[16:12:55.160]                         }
[16:12:55.160]                       }
[16:12:55.160]                       invisible(muffled)
[16:12:55.160]                     }
[16:12:55.160]                     muffleCondition(cond, pattern = "^muffle")
[16:12:55.160]                   }
[16:12:55.160]                 }
[16:12:55.160]             }
[16:12:55.160]         }))
[16:12:55.160]     }, error = function(ex) {
[16:12:55.160]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:55.160]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:55.160]                 ...future.rng), started = ...future.startTime, 
[16:12:55.160]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:55.160]             version = "1.8"), class = "FutureResult")
[16:12:55.160]     }, finally = {
[16:12:55.160]         if (!identical(...future.workdir, getwd())) 
[16:12:55.160]             setwd(...future.workdir)
[16:12:55.160]         {
[16:12:55.160]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:55.160]                 ...future.oldOptions$nwarnings <- NULL
[16:12:55.160]             }
[16:12:55.160]             base::options(...future.oldOptions)
[16:12:55.160]             if (.Platform$OS.type == "windows") {
[16:12:55.160]                 old_names <- names(...future.oldEnvVars)
[16:12:55.160]                 envs <- base::Sys.getenv()
[16:12:55.160]                 names <- names(envs)
[16:12:55.160]                 common <- intersect(names, old_names)
[16:12:55.160]                 added <- setdiff(names, old_names)
[16:12:55.160]                 removed <- setdiff(old_names, names)
[16:12:55.160]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:55.160]                   envs[common]]
[16:12:55.160]                 NAMES <- toupper(changed)
[16:12:55.160]                 args <- list()
[16:12:55.160]                 for (kk in seq_along(NAMES)) {
[16:12:55.160]                   name <- changed[[kk]]
[16:12:55.160]                   NAME <- NAMES[[kk]]
[16:12:55.160]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.160]                     next
[16:12:55.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:55.160]                 }
[16:12:55.160]                 NAMES <- toupper(added)
[16:12:55.160]                 for (kk in seq_along(NAMES)) {
[16:12:55.160]                   name <- added[[kk]]
[16:12:55.160]                   NAME <- NAMES[[kk]]
[16:12:55.160]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.160]                     next
[16:12:55.160]                   args[[name]] <- ""
[16:12:55.160]                 }
[16:12:55.160]                 NAMES <- toupper(removed)
[16:12:55.160]                 for (kk in seq_along(NAMES)) {
[16:12:55.160]                   name <- removed[[kk]]
[16:12:55.160]                   NAME <- NAMES[[kk]]
[16:12:55.160]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.160]                     next
[16:12:55.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:55.160]                 }
[16:12:55.160]                 if (length(args) > 0) 
[16:12:55.160]                   base::do.call(base::Sys.setenv, args = args)
[16:12:55.160]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:55.160]             }
[16:12:55.160]             else {
[16:12:55.160]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:55.160]             }
[16:12:55.160]             {
[16:12:55.160]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:55.160]                   0L) {
[16:12:55.160]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:55.160]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:55.160]                   base::options(opts)
[16:12:55.160]                 }
[16:12:55.160]                 {
[16:12:55.160]                   {
[16:12:55.160]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:55.160]                     NULL
[16:12:55.160]                   }
[16:12:55.160]                   options(future.plan = NULL)
[16:12:55.160]                   if (is.na(NA_character_)) 
[16:12:55.160]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:55.160]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:55.160]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:55.160]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:55.160]                     envir = parent.frame()) 
[16:12:55.160]                   {
[16:12:55.160]                     if (is.function(workers)) 
[16:12:55.160]                       workers <- workers()
[16:12:55.160]                     workers <- structure(as.integer(workers), 
[16:12:55.160]                       class = class(workers))
[16:12:55.160]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:55.160]                       workers >= 1)
[16:12:55.160]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:55.160]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:55.160]                     }
[16:12:55.160]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:55.160]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:55.160]                       envir = envir)
[16:12:55.160]                     if (!future$lazy) 
[16:12:55.160]                       future <- run(future)
[16:12:55.160]                     invisible(future)
[16:12:55.160]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:55.160]                 }
[16:12:55.160]             }
[16:12:55.160]         }
[16:12:55.160]     })
[16:12:55.160]     if (TRUE) {
[16:12:55.160]         base::sink(type = "output", split = FALSE)
[16:12:55.160]         if (TRUE) {
[16:12:55.160]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:55.160]         }
[16:12:55.160]         else {
[16:12:55.160]             ...future.result["stdout"] <- base::list(NULL)
[16:12:55.160]         }
[16:12:55.160]         base::close(...future.stdout)
[16:12:55.160]         ...future.stdout <- NULL
[16:12:55.160]     }
[16:12:55.160]     ...future.result$conditions <- ...future.conditions
[16:12:55.160]     ...future.result$finished <- base::Sys.time()
[16:12:55.160]     ...future.result
[16:12:55.160] }
[16:12:55.163] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[16:12:55.163] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:12:55.163] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:12:55.163] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:12:55.164] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:12:55.164] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[16:12:55.164] MultisessionFuture started
[16:12:55.165] - Launch lazy future ... done
[16:12:55.165] run() for ‘MultisessionFuture’ ... done
[16:12:55.165] result() for ClusterFuture ...
[16:12:55.165] receiveMessageFromWorker() for ClusterFuture ...
[16:12:55.165] - Validating connection of MultisessionFuture
[16:12:55.213] - received message: FutureResult
[16:12:55.213] - Received FutureResult
[16:12:55.213] - Erased future from FutureRegistry
[16:12:55.213] result() for ClusterFuture ...
[16:12:55.214] - result already collected: FutureResult
[16:12:55.214] result() for ClusterFuture ... done
[16:12:55.214] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:55.214] result() for ClusterFuture ... done
[16:12:55.214] result() for ClusterFuture ...
[16:12:55.214] - result already collected: FutureResult
[16:12:55.214] result() for ClusterFuture ... done
[16:12:55.214] run() for ‘Future’ ...
[16:12:55.215] - state: ‘created’
[16:12:55.215] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:55.230] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:55.230] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:55.230]   - Field: ‘node’
[16:12:55.231]   - Field: ‘label’
[16:12:55.231]   - Field: ‘local’
[16:12:55.231]   - Field: ‘owner’
[16:12:55.231]   - Field: ‘envir’
[16:12:55.231]   - Field: ‘workers’
[16:12:55.231]   - Field: ‘packages’
[16:12:55.231]   - Field: ‘gc’
[16:12:55.231]   - Field: ‘conditions’
[16:12:55.231]   - Field: ‘persistent’
[16:12:55.231]   - Field: ‘expr’
[16:12:55.231]   - Field: ‘uuid’
[16:12:55.232]   - Field: ‘seed’
[16:12:55.232]   - Field: ‘version’
[16:12:55.232]   - Field: ‘result’
[16:12:55.232]   - Field: ‘asynchronous’
[16:12:55.232]   - Field: ‘calls’
[16:12:55.232]   - Field: ‘globals’
[16:12:55.232]   - Field: ‘stdout’
[16:12:55.232]   - Field: ‘earlySignal’
[16:12:55.232]   - Field: ‘lazy’
[16:12:55.232]   - Field: ‘state’
[16:12:55.233] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:55.233] - Launch lazy future ...
[16:12:55.233] Packages needed by the future expression (n = 0): <none>
[16:12:55.233] Packages needed by future strategies (n = 0): <none>
[16:12:55.234] {
[16:12:55.234]     {
[16:12:55.234]         {
[16:12:55.234]             ...future.startTime <- base::Sys.time()
[16:12:55.234]             {
[16:12:55.234]                 {
[16:12:55.234]                   {
[16:12:55.234]                     {
[16:12:55.234]                       base::local({
[16:12:55.234]                         has_future <- base::requireNamespace("future", 
[16:12:55.234]                           quietly = TRUE)
[16:12:55.234]                         if (has_future) {
[16:12:55.234]                           ns <- base::getNamespace("future")
[16:12:55.234]                           version <- ns[[".package"]][["version"]]
[16:12:55.234]                           if (is.null(version)) 
[16:12:55.234]                             version <- utils::packageVersion("future")
[16:12:55.234]                         }
[16:12:55.234]                         else {
[16:12:55.234]                           version <- NULL
[16:12:55.234]                         }
[16:12:55.234]                         if (!has_future || version < "1.8.0") {
[16:12:55.234]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:55.234]                             "", base::R.version$version.string), 
[16:12:55.234]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:55.234]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:55.234]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:55.234]                               "release", "version")], collapse = " "), 
[16:12:55.234]                             hostname = base::Sys.info()[["nodename"]])
[16:12:55.234]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:55.234]                             info)
[16:12:55.234]                           info <- base::paste(info, collapse = "; ")
[16:12:55.234]                           if (!has_future) {
[16:12:55.234]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:55.234]                               info)
[16:12:55.234]                           }
[16:12:55.234]                           else {
[16:12:55.234]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:55.234]                               info, version)
[16:12:55.234]                           }
[16:12:55.234]                           base::stop(msg)
[16:12:55.234]                         }
[16:12:55.234]                       })
[16:12:55.234]                     }
[16:12:55.234]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:55.234]                     base::options(mc.cores = 1L)
[16:12:55.234]                   }
[16:12:55.234]                   options(future.plan = NULL)
[16:12:55.234]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:55.234]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:55.234]                 }
[16:12:55.234]                 ...future.workdir <- getwd()
[16:12:55.234]             }
[16:12:55.234]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:55.234]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:55.234]         }
[16:12:55.234]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:55.234]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:55.234]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:55.234]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:55.234]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:55.234]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:55.234]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:55.234]             base::names(...future.oldOptions))
[16:12:55.234]     }
[16:12:55.234]     if (FALSE) {
[16:12:55.234]     }
[16:12:55.234]     else {
[16:12:55.234]         if (TRUE) {
[16:12:55.234]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:55.234]                 open = "w")
[16:12:55.234]         }
[16:12:55.234]         else {
[16:12:55.234]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:55.234]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:55.234]         }
[16:12:55.234]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:55.234]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:55.234]             base::sink(type = "output", split = FALSE)
[16:12:55.234]             base::close(...future.stdout)
[16:12:55.234]         }, add = TRUE)
[16:12:55.234]     }
[16:12:55.234]     ...future.frame <- base::sys.nframe()
[16:12:55.234]     ...future.conditions <- base::list()
[16:12:55.234]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:55.234]     if (FALSE) {
[16:12:55.234]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:55.234]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:55.234]     }
[16:12:55.234]     ...future.result <- base::tryCatch({
[16:12:55.234]         base::withCallingHandlers({
[16:12:55.234]             ...future.value <- base::withVisible(base::local({
[16:12:55.234]                 ...future.makeSendCondition <- local({
[16:12:55.234]                   sendCondition <- NULL
[16:12:55.234]                   function(frame = 1L) {
[16:12:55.234]                     if (is.function(sendCondition)) 
[16:12:55.234]                       return(sendCondition)
[16:12:55.234]                     ns <- getNamespace("parallel")
[16:12:55.234]                     if (exists("sendData", mode = "function", 
[16:12:55.234]                       envir = ns)) {
[16:12:55.234]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:55.234]                         envir = ns)
[16:12:55.234]                       envir <- sys.frame(frame)
[16:12:55.234]                       master <- NULL
[16:12:55.234]                       while (!identical(envir, .GlobalEnv) && 
[16:12:55.234]                         !identical(envir, emptyenv())) {
[16:12:55.234]                         if (exists("master", mode = "list", envir = envir, 
[16:12:55.234]                           inherits = FALSE)) {
[16:12:55.234]                           master <- get("master", mode = "list", 
[16:12:55.234]                             envir = envir, inherits = FALSE)
[16:12:55.234]                           if (inherits(master, c("SOCKnode", 
[16:12:55.234]                             "SOCK0node"))) {
[16:12:55.234]                             sendCondition <<- function(cond) {
[16:12:55.234]                               data <- list(type = "VALUE", value = cond, 
[16:12:55.234]                                 success = TRUE)
[16:12:55.234]                               parallel_sendData(master, data)
[16:12:55.234]                             }
[16:12:55.234]                             return(sendCondition)
[16:12:55.234]                           }
[16:12:55.234]                         }
[16:12:55.234]                         frame <- frame + 1L
[16:12:55.234]                         envir <- sys.frame(frame)
[16:12:55.234]                       }
[16:12:55.234]                     }
[16:12:55.234]                     sendCondition <<- function(cond) NULL
[16:12:55.234]                   }
[16:12:55.234]                 })
[16:12:55.234]                 withCallingHandlers({
[16:12:55.234]                   {
[16:12:55.234]                     b <- a * ii
[16:12:55.234]                     a <- 0
[16:12:55.234]                     b
[16:12:55.234]                   }
[16:12:55.234]                 }, immediateCondition = function(cond) {
[16:12:55.234]                   sendCondition <- ...future.makeSendCondition()
[16:12:55.234]                   sendCondition(cond)
[16:12:55.234]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.234]                   {
[16:12:55.234]                     inherits <- base::inherits
[16:12:55.234]                     invokeRestart <- base::invokeRestart
[16:12:55.234]                     is.null <- base::is.null
[16:12:55.234]                     muffled <- FALSE
[16:12:55.234]                     if (inherits(cond, "message")) {
[16:12:55.234]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:55.234]                       if (muffled) 
[16:12:55.234]                         invokeRestart("muffleMessage")
[16:12:55.234]                     }
[16:12:55.234]                     else if (inherits(cond, "warning")) {
[16:12:55.234]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:55.234]                       if (muffled) 
[16:12:55.234]                         invokeRestart("muffleWarning")
[16:12:55.234]                     }
[16:12:55.234]                     else if (inherits(cond, "condition")) {
[16:12:55.234]                       if (!is.null(pattern)) {
[16:12:55.234]                         computeRestarts <- base::computeRestarts
[16:12:55.234]                         grepl <- base::grepl
[16:12:55.234]                         restarts <- computeRestarts(cond)
[16:12:55.234]                         for (restart in restarts) {
[16:12:55.234]                           name <- restart$name
[16:12:55.234]                           if (is.null(name)) 
[16:12:55.234]                             next
[16:12:55.234]                           if (!grepl(pattern, name)) 
[16:12:55.234]                             next
[16:12:55.234]                           invokeRestart(restart)
[16:12:55.234]                           muffled <- TRUE
[16:12:55.234]                           break
[16:12:55.234]                         }
[16:12:55.234]                       }
[16:12:55.234]                     }
[16:12:55.234]                     invisible(muffled)
[16:12:55.234]                   }
[16:12:55.234]                   muffleCondition(cond)
[16:12:55.234]                 })
[16:12:55.234]             }))
[16:12:55.234]             future::FutureResult(value = ...future.value$value, 
[16:12:55.234]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:55.234]                   ...future.rng), globalenv = if (FALSE) 
[16:12:55.234]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:55.234]                     ...future.globalenv.names))
[16:12:55.234]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:55.234]         }, condition = base::local({
[16:12:55.234]             c <- base::c
[16:12:55.234]             inherits <- base::inherits
[16:12:55.234]             invokeRestart <- base::invokeRestart
[16:12:55.234]             length <- base::length
[16:12:55.234]             list <- base::list
[16:12:55.234]             seq.int <- base::seq.int
[16:12:55.234]             signalCondition <- base::signalCondition
[16:12:55.234]             sys.calls <- base::sys.calls
[16:12:55.234]             `[[` <- base::`[[`
[16:12:55.234]             `+` <- base::`+`
[16:12:55.234]             `<<-` <- base::`<<-`
[16:12:55.234]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:55.234]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:55.234]                   3L)]
[16:12:55.234]             }
[16:12:55.234]             function(cond) {
[16:12:55.234]                 is_error <- inherits(cond, "error")
[16:12:55.234]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:55.234]                   NULL)
[16:12:55.234]                 if (is_error) {
[16:12:55.234]                   sessionInformation <- function() {
[16:12:55.234]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:55.234]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:55.234]                       search = base::search(), system = base::Sys.info())
[16:12:55.234]                   }
[16:12:55.234]                   ...future.conditions[[length(...future.conditions) + 
[16:12:55.234]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:55.234]                     cond$call), session = sessionInformation(), 
[16:12:55.234]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:55.234]                   signalCondition(cond)
[16:12:55.234]                 }
[16:12:55.234]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:55.234]                 "immediateCondition"))) {
[16:12:55.234]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:55.234]                   ...future.conditions[[length(...future.conditions) + 
[16:12:55.234]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:55.234]                   if (TRUE && !signal) {
[16:12:55.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.234]                     {
[16:12:55.234]                       inherits <- base::inherits
[16:12:55.234]                       invokeRestart <- base::invokeRestart
[16:12:55.234]                       is.null <- base::is.null
[16:12:55.234]                       muffled <- FALSE
[16:12:55.234]                       if (inherits(cond, "message")) {
[16:12:55.234]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:55.234]                         if (muffled) 
[16:12:55.234]                           invokeRestart("muffleMessage")
[16:12:55.234]                       }
[16:12:55.234]                       else if (inherits(cond, "warning")) {
[16:12:55.234]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:55.234]                         if (muffled) 
[16:12:55.234]                           invokeRestart("muffleWarning")
[16:12:55.234]                       }
[16:12:55.234]                       else if (inherits(cond, "condition")) {
[16:12:55.234]                         if (!is.null(pattern)) {
[16:12:55.234]                           computeRestarts <- base::computeRestarts
[16:12:55.234]                           grepl <- base::grepl
[16:12:55.234]                           restarts <- computeRestarts(cond)
[16:12:55.234]                           for (restart in restarts) {
[16:12:55.234]                             name <- restart$name
[16:12:55.234]                             if (is.null(name)) 
[16:12:55.234]                               next
[16:12:55.234]                             if (!grepl(pattern, name)) 
[16:12:55.234]                               next
[16:12:55.234]                             invokeRestart(restart)
[16:12:55.234]                             muffled <- TRUE
[16:12:55.234]                             break
[16:12:55.234]                           }
[16:12:55.234]                         }
[16:12:55.234]                       }
[16:12:55.234]                       invisible(muffled)
[16:12:55.234]                     }
[16:12:55.234]                     muffleCondition(cond, pattern = "^muffle")
[16:12:55.234]                   }
[16:12:55.234]                 }
[16:12:55.234]                 else {
[16:12:55.234]                   if (TRUE) {
[16:12:55.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.234]                     {
[16:12:55.234]                       inherits <- base::inherits
[16:12:55.234]                       invokeRestart <- base::invokeRestart
[16:12:55.234]                       is.null <- base::is.null
[16:12:55.234]                       muffled <- FALSE
[16:12:55.234]                       if (inherits(cond, "message")) {
[16:12:55.234]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:55.234]                         if (muffled) 
[16:12:55.234]                           invokeRestart("muffleMessage")
[16:12:55.234]                       }
[16:12:55.234]                       else if (inherits(cond, "warning")) {
[16:12:55.234]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:55.234]                         if (muffled) 
[16:12:55.234]                           invokeRestart("muffleWarning")
[16:12:55.234]                       }
[16:12:55.234]                       else if (inherits(cond, "condition")) {
[16:12:55.234]                         if (!is.null(pattern)) {
[16:12:55.234]                           computeRestarts <- base::computeRestarts
[16:12:55.234]                           grepl <- base::grepl
[16:12:55.234]                           restarts <- computeRestarts(cond)
[16:12:55.234]                           for (restart in restarts) {
[16:12:55.234]                             name <- restart$name
[16:12:55.234]                             if (is.null(name)) 
[16:12:55.234]                               next
[16:12:55.234]                             if (!grepl(pattern, name)) 
[16:12:55.234]                               next
[16:12:55.234]                             invokeRestart(restart)
[16:12:55.234]                             muffled <- TRUE
[16:12:55.234]                             break
[16:12:55.234]                           }
[16:12:55.234]                         }
[16:12:55.234]                       }
[16:12:55.234]                       invisible(muffled)
[16:12:55.234]                     }
[16:12:55.234]                     muffleCondition(cond, pattern = "^muffle")
[16:12:55.234]                   }
[16:12:55.234]                 }
[16:12:55.234]             }
[16:12:55.234]         }))
[16:12:55.234]     }, error = function(ex) {
[16:12:55.234]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:55.234]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:55.234]                 ...future.rng), started = ...future.startTime, 
[16:12:55.234]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:55.234]             version = "1.8"), class = "FutureResult")
[16:12:55.234]     }, finally = {
[16:12:55.234]         if (!identical(...future.workdir, getwd())) 
[16:12:55.234]             setwd(...future.workdir)
[16:12:55.234]         {
[16:12:55.234]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:55.234]                 ...future.oldOptions$nwarnings <- NULL
[16:12:55.234]             }
[16:12:55.234]             base::options(...future.oldOptions)
[16:12:55.234]             if (.Platform$OS.type == "windows") {
[16:12:55.234]                 old_names <- names(...future.oldEnvVars)
[16:12:55.234]                 envs <- base::Sys.getenv()
[16:12:55.234]                 names <- names(envs)
[16:12:55.234]                 common <- intersect(names, old_names)
[16:12:55.234]                 added <- setdiff(names, old_names)
[16:12:55.234]                 removed <- setdiff(old_names, names)
[16:12:55.234]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:55.234]                   envs[common]]
[16:12:55.234]                 NAMES <- toupper(changed)
[16:12:55.234]                 args <- list()
[16:12:55.234]                 for (kk in seq_along(NAMES)) {
[16:12:55.234]                   name <- changed[[kk]]
[16:12:55.234]                   NAME <- NAMES[[kk]]
[16:12:55.234]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.234]                     next
[16:12:55.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:55.234]                 }
[16:12:55.234]                 NAMES <- toupper(added)
[16:12:55.234]                 for (kk in seq_along(NAMES)) {
[16:12:55.234]                   name <- added[[kk]]
[16:12:55.234]                   NAME <- NAMES[[kk]]
[16:12:55.234]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.234]                     next
[16:12:55.234]                   args[[name]] <- ""
[16:12:55.234]                 }
[16:12:55.234]                 NAMES <- toupper(removed)
[16:12:55.234]                 for (kk in seq_along(NAMES)) {
[16:12:55.234]                   name <- removed[[kk]]
[16:12:55.234]                   NAME <- NAMES[[kk]]
[16:12:55.234]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.234]                     next
[16:12:55.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:55.234]                 }
[16:12:55.234]                 if (length(args) > 0) 
[16:12:55.234]                   base::do.call(base::Sys.setenv, args = args)
[16:12:55.234]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:55.234]             }
[16:12:55.234]             else {
[16:12:55.234]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:55.234]             }
[16:12:55.234]             {
[16:12:55.234]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:55.234]                   0L) {
[16:12:55.234]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:55.234]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:55.234]                   base::options(opts)
[16:12:55.234]                 }
[16:12:55.234]                 {
[16:12:55.234]                   {
[16:12:55.234]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:55.234]                     NULL
[16:12:55.234]                   }
[16:12:55.234]                   options(future.plan = NULL)
[16:12:55.234]                   if (is.na(NA_character_)) 
[16:12:55.234]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:55.234]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:55.234]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:55.234]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:55.234]                     envir = parent.frame()) 
[16:12:55.234]                   {
[16:12:55.234]                     if (is.function(workers)) 
[16:12:55.234]                       workers <- workers()
[16:12:55.234]                     workers <- structure(as.integer(workers), 
[16:12:55.234]                       class = class(workers))
[16:12:55.234]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:55.234]                       workers >= 1)
[16:12:55.234]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:55.234]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:55.234]                     }
[16:12:55.234]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:55.234]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:55.234]                       envir = envir)
[16:12:55.234]                     if (!future$lazy) 
[16:12:55.234]                       future <- run(future)
[16:12:55.234]                     invisible(future)
[16:12:55.234]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:55.234]                 }
[16:12:55.234]             }
[16:12:55.234]         }
[16:12:55.234]     })
[16:12:55.234]     if (TRUE) {
[16:12:55.234]         base::sink(type = "output", split = FALSE)
[16:12:55.234]         if (TRUE) {
[16:12:55.234]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:55.234]         }
[16:12:55.234]         else {
[16:12:55.234]             ...future.result["stdout"] <- base::list(NULL)
[16:12:55.234]         }
[16:12:55.234]         base::close(...future.stdout)
[16:12:55.234]         ...future.stdout <- NULL
[16:12:55.234]     }
[16:12:55.234]     ...future.result$conditions <- ...future.conditions
[16:12:55.234]     ...future.result$finished <- base::Sys.time()
[16:12:55.234]     ...future.result
[16:12:55.234] }
[16:12:55.236] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[16:12:55.237] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:12:55.237] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:12:55.237] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:12:55.237] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:12:55.237] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[16:12:55.238] MultisessionFuture started
[16:12:55.238] - Launch lazy future ... done
[16:12:55.238] run() for ‘MultisessionFuture’ ... done
[16:12:55.238] result() for ClusterFuture ...
[16:12:55.238] receiveMessageFromWorker() for ClusterFuture ...
[16:12:55.238] - Validating connection of MultisessionFuture
[16:12:55.284] - received message: FutureResult
[16:12:55.285] - Received FutureResult
[16:12:55.285] - Erased future from FutureRegistry
[16:12:55.285] result() for ClusterFuture ...
[16:12:55.285] - result already collected: FutureResult
[16:12:55.285] result() for ClusterFuture ... done
[16:12:55.285] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:55.285] result() for ClusterFuture ... done
[16:12:55.286] result() for ClusterFuture ...
[16:12:55.286] - result already collected: FutureResult
[16:12:55.286] result() for ClusterFuture ... done
[16:12:55.286] run() for ‘Future’ ...
[16:12:55.286] - state: ‘created’
[16:12:55.286] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:55.301] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:55.301] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:55.301]   - Field: ‘node’
[16:12:55.301]   - Field: ‘label’
[16:12:55.301]   - Field: ‘local’
[16:12:55.302]   - Field: ‘owner’
[16:12:55.302]   - Field: ‘envir’
[16:12:55.302]   - Field: ‘workers’
[16:12:55.302]   - Field: ‘packages’
[16:12:55.302]   - Field: ‘gc’
[16:12:55.302]   - Field: ‘conditions’
[16:12:55.302]   - Field: ‘persistent’
[16:12:55.302]   - Field: ‘expr’
[16:12:55.302]   - Field: ‘uuid’
[16:12:55.302]   - Field: ‘seed’
[16:12:55.302]   - Field: ‘version’
[16:12:55.303]   - Field: ‘result’
[16:12:55.303]   - Field: ‘asynchronous’
[16:12:55.303]   - Field: ‘calls’
[16:12:55.303]   - Field: ‘globals’
[16:12:55.303]   - Field: ‘stdout’
[16:12:55.303]   - Field: ‘earlySignal’
[16:12:55.303]   - Field: ‘lazy’
[16:12:55.303]   - Field: ‘state’
[16:12:55.303] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:55.303] - Launch lazy future ...
[16:12:55.304] Packages needed by the future expression (n = 0): <none>
[16:12:55.304] Packages needed by future strategies (n = 0): <none>
[16:12:55.304] {
[16:12:55.304]     {
[16:12:55.304]         {
[16:12:55.304]             ...future.startTime <- base::Sys.time()
[16:12:55.304]             {
[16:12:55.304]                 {
[16:12:55.304]                   {
[16:12:55.304]                     {
[16:12:55.304]                       base::local({
[16:12:55.304]                         has_future <- base::requireNamespace("future", 
[16:12:55.304]                           quietly = TRUE)
[16:12:55.304]                         if (has_future) {
[16:12:55.304]                           ns <- base::getNamespace("future")
[16:12:55.304]                           version <- ns[[".package"]][["version"]]
[16:12:55.304]                           if (is.null(version)) 
[16:12:55.304]                             version <- utils::packageVersion("future")
[16:12:55.304]                         }
[16:12:55.304]                         else {
[16:12:55.304]                           version <- NULL
[16:12:55.304]                         }
[16:12:55.304]                         if (!has_future || version < "1.8.0") {
[16:12:55.304]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:55.304]                             "", base::R.version$version.string), 
[16:12:55.304]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:55.304]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:55.304]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:55.304]                               "release", "version")], collapse = " "), 
[16:12:55.304]                             hostname = base::Sys.info()[["nodename"]])
[16:12:55.304]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:55.304]                             info)
[16:12:55.304]                           info <- base::paste(info, collapse = "; ")
[16:12:55.304]                           if (!has_future) {
[16:12:55.304]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:55.304]                               info)
[16:12:55.304]                           }
[16:12:55.304]                           else {
[16:12:55.304]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:55.304]                               info, version)
[16:12:55.304]                           }
[16:12:55.304]                           base::stop(msg)
[16:12:55.304]                         }
[16:12:55.304]                       })
[16:12:55.304]                     }
[16:12:55.304]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:55.304]                     base::options(mc.cores = 1L)
[16:12:55.304]                   }
[16:12:55.304]                   options(future.plan = NULL)
[16:12:55.304]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:55.304]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:55.304]                 }
[16:12:55.304]                 ...future.workdir <- getwd()
[16:12:55.304]             }
[16:12:55.304]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:55.304]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:55.304]         }
[16:12:55.304]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:55.304]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:55.304]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:55.304]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:55.304]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:55.304]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:55.304]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:55.304]             base::names(...future.oldOptions))
[16:12:55.304]     }
[16:12:55.304]     if (FALSE) {
[16:12:55.304]     }
[16:12:55.304]     else {
[16:12:55.304]         if (TRUE) {
[16:12:55.304]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:55.304]                 open = "w")
[16:12:55.304]         }
[16:12:55.304]         else {
[16:12:55.304]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:55.304]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:55.304]         }
[16:12:55.304]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:55.304]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:55.304]             base::sink(type = "output", split = FALSE)
[16:12:55.304]             base::close(...future.stdout)
[16:12:55.304]         }, add = TRUE)
[16:12:55.304]     }
[16:12:55.304]     ...future.frame <- base::sys.nframe()
[16:12:55.304]     ...future.conditions <- base::list()
[16:12:55.304]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:55.304]     if (FALSE) {
[16:12:55.304]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:55.304]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:55.304]     }
[16:12:55.304]     ...future.result <- base::tryCatch({
[16:12:55.304]         base::withCallingHandlers({
[16:12:55.304]             ...future.value <- base::withVisible(base::local({
[16:12:55.304]                 ...future.makeSendCondition <- local({
[16:12:55.304]                   sendCondition <- NULL
[16:12:55.304]                   function(frame = 1L) {
[16:12:55.304]                     if (is.function(sendCondition)) 
[16:12:55.304]                       return(sendCondition)
[16:12:55.304]                     ns <- getNamespace("parallel")
[16:12:55.304]                     if (exists("sendData", mode = "function", 
[16:12:55.304]                       envir = ns)) {
[16:12:55.304]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:55.304]                         envir = ns)
[16:12:55.304]                       envir <- sys.frame(frame)
[16:12:55.304]                       master <- NULL
[16:12:55.304]                       while (!identical(envir, .GlobalEnv) && 
[16:12:55.304]                         !identical(envir, emptyenv())) {
[16:12:55.304]                         if (exists("master", mode = "list", envir = envir, 
[16:12:55.304]                           inherits = FALSE)) {
[16:12:55.304]                           master <- get("master", mode = "list", 
[16:12:55.304]                             envir = envir, inherits = FALSE)
[16:12:55.304]                           if (inherits(master, c("SOCKnode", 
[16:12:55.304]                             "SOCK0node"))) {
[16:12:55.304]                             sendCondition <<- function(cond) {
[16:12:55.304]                               data <- list(type = "VALUE", value = cond, 
[16:12:55.304]                                 success = TRUE)
[16:12:55.304]                               parallel_sendData(master, data)
[16:12:55.304]                             }
[16:12:55.304]                             return(sendCondition)
[16:12:55.304]                           }
[16:12:55.304]                         }
[16:12:55.304]                         frame <- frame + 1L
[16:12:55.304]                         envir <- sys.frame(frame)
[16:12:55.304]                       }
[16:12:55.304]                     }
[16:12:55.304]                     sendCondition <<- function(cond) NULL
[16:12:55.304]                   }
[16:12:55.304]                 })
[16:12:55.304]                 withCallingHandlers({
[16:12:55.304]                   {
[16:12:55.304]                     b <- a * ii
[16:12:55.304]                     a <- 0
[16:12:55.304]                     b
[16:12:55.304]                   }
[16:12:55.304]                 }, immediateCondition = function(cond) {
[16:12:55.304]                   sendCondition <- ...future.makeSendCondition()
[16:12:55.304]                   sendCondition(cond)
[16:12:55.304]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.304]                   {
[16:12:55.304]                     inherits <- base::inherits
[16:12:55.304]                     invokeRestart <- base::invokeRestart
[16:12:55.304]                     is.null <- base::is.null
[16:12:55.304]                     muffled <- FALSE
[16:12:55.304]                     if (inherits(cond, "message")) {
[16:12:55.304]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:55.304]                       if (muffled) 
[16:12:55.304]                         invokeRestart("muffleMessage")
[16:12:55.304]                     }
[16:12:55.304]                     else if (inherits(cond, "warning")) {
[16:12:55.304]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:55.304]                       if (muffled) 
[16:12:55.304]                         invokeRestart("muffleWarning")
[16:12:55.304]                     }
[16:12:55.304]                     else if (inherits(cond, "condition")) {
[16:12:55.304]                       if (!is.null(pattern)) {
[16:12:55.304]                         computeRestarts <- base::computeRestarts
[16:12:55.304]                         grepl <- base::grepl
[16:12:55.304]                         restarts <- computeRestarts(cond)
[16:12:55.304]                         for (restart in restarts) {
[16:12:55.304]                           name <- restart$name
[16:12:55.304]                           if (is.null(name)) 
[16:12:55.304]                             next
[16:12:55.304]                           if (!grepl(pattern, name)) 
[16:12:55.304]                             next
[16:12:55.304]                           invokeRestart(restart)
[16:12:55.304]                           muffled <- TRUE
[16:12:55.304]                           break
[16:12:55.304]                         }
[16:12:55.304]                       }
[16:12:55.304]                     }
[16:12:55.304]                     invisible(muffled)
[16:12:55.304]                   }
[16:12:55.304]                   muffleCondition(cond)
[16:12:55.304]                 })
[16:12:55.304]             }))
[16:12:55.304]             future::FutureResult(value = ...future.value$value, 
[16:12:55.304]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:55.304]                   ...future.rng), globalenv = if (FALSE) 
[16:12:55.304]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:55.304]                     ...future.globalenv.names))
[16:12:55.304]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:55.304]         }, condition = base::local({
[16:12:55.304]             c <- base::c
[16:12:55.304]             inherits <- base::inherits
[16:12:55.304]             invokeRestart <- base::invokeRestart
[16:12:55.304]             length <- base::length
[16:12:55.304]             list <- base::list
[16:12:55.304]             seq.int <- base::seq.int
[16:12:55.304]             signalCondition <- base::signalCondition
[16:12:55.304]             sys.calls <- base::sys.calls
[16:12:55.304]             `[[` <- base::`[[`
[16:12:55.304]             `+` <- base::`+`
[16:12:55.304]             `<<-` <- base::`<<-`
[16:12:55.304]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:55.304]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:55.304]                   3L)]
[16:12:55.304]             }
[16:12:55.304]             function(cond) {
[16:12:55.304]                 is_error <- inherits(cond, "error")
[16:12:55.304]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:55.304]                   NULL)
[16:12:55.304]                 if (is_error) {
[16:12:55.304]                   sessionInformation <- function() {
[16:12:55.304]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:55.304]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:55.304]                       search = base::search(), system = base::Sys.info())
[16:12:55.304]                   }
[16:12:55.304]                   ...future.conditions[[length(...future.conditions) + 
[16:12:55.304]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:55.304]                     cond$call), session = sessionInformation(), 
[16:12:55.304]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:55.304]                   signalCondition(cond)
[16:12:55.304]                 }
[16:12:55.304]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:55.304]                 "immediateCondition"))) {
[16:12:55.304]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:55.304]                   ...future.conditions[[length(...future.conditions) + 
[16:12:55.304]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:55.304]                   if (TRUE && !signal) {
[16:12:55.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.304]                     {
[16:12:55.304]                       inherits <- base::inherits
[16:12:55.304]                       invokeRestart <- base::invokeRestart
[16:12:55.304]                       is.null <- base::is.null
[16:12:55.304]                       muffled <- FALSE
[16:12:55.304]                       if (inherits(cond, "message")) {
[16:12:55.304]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:55.304]                         if (muffled) 
[16:12:55.304]                           invokeRestart("muffleMessage")
[16:12:55.304]                       }
[16:12:55.304]                       else if (inherits(cond, "warning")) {
[16:12:55.304]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:55.304]                         if (muffled) 
[16:12:55.304]                           invokeRestart("muffleWarning")
[16:12:55.304]                       }
[16:12:55.304]                       else if (inherits(cond, "condition")) {
[16:12:55.304]                         if (!is.null(pattern)) {
[16:12:55.304]                           computeRestarts <- base::computeRestarts
[16:12:55.304]                           grepl <- base::grepl
[16:12:55.304]                           restarts <- computeRestarts(cond)
[16:12:55.304]                           for (restart in restarts) {
[16:12:55.304]                             name <- restart$name
[16:12:55.304]                             if (is.null(name)) 
[16:12:55.304]                               next
[16:12:55.304]                             if (!grepl(pattern, name)) 
[16:12:55.304]                               next
[16:12:55.304]                             invokeRestart(restart)
[16:12:55.304]                             muffled <- TRUE
[16:12:55.304]                             break
[16:12:55.304]                           }
[16:12:55.304]                         }
[16:12:55.304]                       }
[16:12:55.304]                       invisible(muffled)
[16:12:55.304]                     }
[16:12:55.304]                     muffleCondition(cond, pattern = "^muffle")
[16:12:55.304]                   }
[16:12:55.304]                 }
[16:12:55.304]                 else {
[16:12:55.304]                   if (TRUE) {
[16:12:55.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.304]                     {
[16:12:55.304]                       inherits <- base::inherits
[16:12:55.304]                       invokeRestart <- base::invokeRestart
[16:12:55.304]                       is.null <- base::is.null
[16:12:55.304]                       muffled <- FALSE
[16:12:55.304]                       if (inherits(cond, "message")) {
[16:12:55.304]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:55.304]                         if (muffled) 
[16:12:55.304]                           invokeRestart("muffleMessage")
[16:12:55.304]                       }
[16:12:55.304]                       else if (inherits(cond, "warning")) {
[16:12:55.304]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:55.304]                         if (muffled) 
[16:12:55.304]                           invokeRestart("muffleWarning")
[16:12:55.304]                       }
[16:12:55.304]                       else if (inherits(cond, "condition")) {
[16:12:55.304]                         if (!is.null(pattern)) {
[16:12:55.304]                           computeRestarts <- base::computeRestarts
[16:12:55.304]                           grepl <- base::grepl
[16:12:55.304]                           restarts <- computeRestarts(cond)
[16:12:55.304]                           for (restart in restarts) {
[16:12:55.304]                             name <- restart$name
[16:12:55.304]                             if (is.null(name)) 
[16:12:55.304]                               next
[16:12:55.304]                             if (!grepl(pattern, name)) 
[16:12:55.304]                               next
[16:12:55.304]                             invokeRestart(restart)
[16:12:55.304]                             muffled <- TRUE
[16:12:55.304]                             break
[16:12:55.304]                           }
[16:12:55.304]                         }
[16:12:55.304]                       }
[16:12:55.304]                       invisible(muffled)
[16:12:55.304]                     }
[16:12:55.304]                     muffleCondition(cond, pattern = "^muffle")
[16:12:55.304]                   }
[16:12:55.304]                 }
[16:12:55.304]             }
[16:12:55.304]         }))
[16:12:55.304]     }, error = function(ex) {
[16:12:55.304]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:55.304]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:55.304]                 ...future.rng), started = ...future.startTime, 
[16:12:55.304]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:55.304]             version = "1.8"), class = "FutureResult")
[16:12:55.304]     }, finally = {
[16:12:55.304]         if (!identical(...future.workdir, getwd())) 
[16:12:55.304]             setwd(...future.workdir)
[16:12:55.304]         {
[16:12:55.304]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:55.304]                 ...future.oldOptions$nwarnings <- NULL
[16:12:55.304]             }
[16:12:55.304]             base::options(...future.oldOptions)
[16:12:55.304]             if (.Platform$OS.type == "windows") {
[16:12:55.304]                 old_names <- names(...future.oldEnvVars)
[16:12:55.304]                 envs <- base::Sys.getenv()
[16:12:55.304]                 names <- names(envs)
[16:12:55.304]                 common <- intersect(names, old_names)
[16:12:55.304]                 added <- setdiff(names, old_names)
[16:12:55.304]                 removed <- setdiff(old_names, names)
[16:12:55.304]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:55.304]                   envs[common]]
[16:12:55.304]                 NAMES <- toupper(changed)
[16:12:55.304]                 args <- list()
[16:12:55.304]                 for (kk in seq_along(NAMES)) {
[16:12:55.304]                   name <- changed[[kk]]
[16:12:55.304]                   NAME <- NAMES[[kk]]
[16:12:55.304]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.304]                     next
[16:12:55.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:55.304]                 }
[16:12:55.304]                 NAMES <- toupper(added)
[16:12:55.304]                 for (kk in seq_along(NAMES)) {
[16:12:55.304]                   name <- added[[kk]]
[16:12:55.304]                   NAME <- NAMES[[kk]]
[16:12:55.304]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.304]                     next
[16:12:55.304]                   args[[name]] <- ""
[16:12:55.304]                 }
[16:12:55.304]                 NAMES <- toupper(removed)
[16:12:55.304]                 for (kk in seq_along(NAMES)) {
[16:12:55.304]                   name <- removed[[kk]]
[16:12:55.304]                   NAME <- NAMES[[kk]]
[16:12:55.304]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.304]                     next
[16:12:55.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:55.304]                 }
[16:12:55.304]                 if (length(args) > 0) 
[16:12:55.304]                   base::do.call(base::Sys.setenv, args = args)
[16:12:55.304]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:55.304]             }
[16:12:55.304]             else {
[16:12:55.304]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:55.304]             }
[16:12:55.304]             {
[16:12:55.304]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:55.304]                   0L) {
[16:12:55.304]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:55.304]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:55.304]                   base::options(opts)
[16:12:55.304]                 }
[16:12:55.304]                 {
[16:12:55.304]                   {
[16:12:55.304]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:55.304]                     NULL
[16:12:55.304]                   }
[16:12:55.304]                   options(future.plan = NULL)
[16:12:55.304]                   if (is.na(NA_character_)) 
[16:12:55.304]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:55.304]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:55.304]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:55.304]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:55.304]                     envir = parent.frame()) 
[16:12:55.304]                   {
[16:12:55.304]                     if (is.function(workers)) 
[16:12:55.304]                       workers <- workers()
[16:12:55.304]                     workers <- structure(as.integer(workers), 
[16:12:55.304]                       class = class(workers))
[16:12:55.304]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:55.304]                       workers >= 1)
[16:12:55.304]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:55.304]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:55.304]                     }
[16:12:55.304]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:55.304]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:55.304]                       envir = envir)
[16:12:55.304]                     if (!future$lazy) 
[16:12:55.304]                       future <- run(future)
[16:12:55.304]                     invisible(future)
[16:12:55.304]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:55.304]                 }
[16:12:55.304]             }
[16:12:55.304]         }
[16:12:55.304]     })
[16:12:55.304]     if (TRUE) {
[16:12:55.304]         base::sink(type = "output", split = FALSE)
[16:12:55.304]         if (TRUE) {
[16:12:55.304]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:55.304]         }
[16:12:55.304]         else {
[16:12:55.304]             ...future.result["stdout"] <- base::list(NULL)
[16:12:55.304]         }
[16:12:55.304]         base::close(...future.stdout)
[16:12:55.304]         ...future.stdout <- NULL
[16:12:55.304]     }
[16:12:55.304]     ...future.result$conditions <- ...future.conditions
[16:12:55.304]     ...future.result$finished <- base::Sys.time()
[16:12:55.304]     ...future.result
[16:12:55.304] }
[16:12:55.307] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[16:12:55.307] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:12:55.307] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:12:55.308] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:12:55.308] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:12:55.308] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[16:12:55.309] MultisessionFuture started
[16:12:55.309] - Launch lazy future ... done
[16:12:55.309] run() for ‘MultisessionFuture’ ... done
[16:12:55.309] result() for ClusterFuture ...
[16:12:55.309] receiveMessageFromWorker() for ClusterFuture ...
[16:12:55.309] - Validating connection of MultisessionFuture
[16:12:55.357] - received message: FutureResult
[16:12:55.357] - Received FutureResult
[16:12:55.357] - Erased future from FutureRegistry
[16:12:55.357] result() for ClusterFuture ...
[16:12:55.357] - result already collected: FutureResult
[16:12:55.358] result() for ClusterFuture ... done
[16:12:55.358] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:55.358] result() for ClusterFuture ... done
[16:12:55.358] result() for ClusterFuture ...
[16:12:55.358] - result already collected: FutureResult
[16:12:55.358] result() for ClusterFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:55.358] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:55.359] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:55.359] 
[16:12:55.359] Searching for globals ... DONE
[16:12:55.359] - globals: [0] <none>
[16:12:55.359] getGlobalsAndPackages() ... DONE
[16:12:55.360] run() for ‘Future’ ...
[16:12:55.360] - state: ‘created’
[16:12:55.360] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:55.374] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:55.375] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:55.375]   - Field: ‘node’
[16:12:55.375]   - Field: ‘label’
[16:12:55.375]   - Field: ‘local’
[16:12:55.375]   - Field: ‘owner’
[16:12:55.375]   - Field: ‘envir’
[16:12:55.375]   - Field: ‘workers’
[16:12:55.375]   - Field: ‘packages’
[16:12:55.375]   - Field: ‘gc’
[16:12:55.376]   - Field: ‘conditions’
[16:12:55.376]   - Field: ‘persistent’
[16:12:55.376]   - Field: ‘expr’
[16:12:55.376]   - Field: ‘uuid’
[16:12:55.376]   - Field: ‘seed’
[16:12:55.376]   - Field: ‘version’
[16:12:55.376]   - Field: ‘result’
[16:12:55.376]   - Field: ‘asynchronous’
[16:12:55.376]   - Field: ‘calls’
[16:12:55.376]   - Field: ‘globals’
[16:12:55.377]   - Field: ‘stdout’
[16:12:55.377]   - Field: ‘earlySignal’
[16:12:55.377]   - Field: ‘lazy’
[16:12:55.377]   - Field: ‘state’
[16:12:55.377] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:55.377] - Launch lazy future ...
[16:12:55.377] Packages needed by the future expression (n = 0): <none>
[16:12:55.377] Packages needed by future strategies (n = 0): <none>
[16:12:55.378] {
[16:12:55.378]     {
[16:12:55.378]         {
[16:12:55.378]             ...future.startTime <- base::Sys.time()
[16:12:55.378]             {
[16:12:55.378]                 {
[16:12:55.378]                   {
[16:12:55.378]                     {
[16:12:55.378]                       base::local({
[16:12:55.378]                         has_future <- base::requireNamespace("future", 
[16:12:55.378]                           quietly = TRUE)
[16:12:55.378]                         if (has_future) {
[16:12:55.378]                           ns <- base::getNamespace("future")
[16:12:55.378]                           version <- ns[[".package"]][["version"]]
[16:12:55.378]                           if (is.null(version)) 
[16:12:55.378]                             version <- utils::packageVersion("future")
[16:12:55.378]                         }
[16:12:55.378]                         else {
[16:12:55.378]                           version <- NULL
[16:12:55.378]                         }
[16:12:55.378]                         if (!has_future || version < "1.8.0") {
[16:12:55.378]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:55.378]                             "", base::R.version$version.string), 
[16:12:55.378]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:55.378]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:55.378]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:55.378]                               "release", "version")], collapse = " "), 
[16:12:55.378]                             hostname = base::Sys.info()[["nodename"]])
[16:12:55.378]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:55.378]                             info)
[16:12:55.378]                           info <- base::paste(info, collapse = "; ")
[16:12:55.378]                           if (!has_future) {
[16:12:55.378]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:55.378]                               info)
[16:12:55.378]                           }
[16:12:55.378]                           else {
[16:12:55.378]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:55.378]                               info, version)
[16:12:55.378]                           }
[16:12:55.378]                           base::stop(msg)
[16:12:55.378]                         }
[16:12:55.378]                       })
[16:12:55.378]                     }
[16:12:55.378]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:55.378]                     base::options(mc.cores = 1L)
[16:12:55.378]                   }
[16:12:55.378]                   options(future.plan = NULL)
[16:12:55.378]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:55.378]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:55.378]                 }
[16:12:55.378]                 ...future.workdir <- getwd()
[16:12:55.378]             }
[16:12:55.378]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:55.378]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:55.378]         }
[16:12:55.378]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:55.378]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:55.378]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:55.378]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:55.378]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:55.378]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:55.378]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:55.378]             base::names(...future.oldOptions))
[16:12:55.378]     }
[16:12:55.378]     if (FALSE) {
[16:12:55.378]     }
[16:12:55.378]     else {
[16:12:55.378]         if (TRUE) {
[16:12:55.378]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:55.378]                 open = "w")
[16:12:55.378]         }
[16:12:55.378]         else {
[16:12:55.378]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:55.378]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:55.378]         }
[16:12:55.378]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:55.378]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:55.378]             base::sink(type = "output", split = FALSE)
[16:12:55.378]             base::close(...future.stdout)
[16:12:55.378]         }, add = TRUE)
[16:12:55.378]     }
[16:12:55.378]     ...future.frame <- base::sys.nframe()
[16:12:55.378]     ...future.conditions <- base::list()
[16:12:55.378]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:55.378]     if (FALSE) {
[16:12:55.378]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:55.378]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:55.378]     }
[16:12:55.378]     ...future.result <- base::tryCatch({
[16:12:55.378]         base::withCallingHandlers({
[16:12:55.378]             ...future.value <- base::withVisible(base::local({
[16:12:55.378]                 ...future.makeSendCondition <- local({
[16:12:55.378]                   sendCondition <- NULL
[16:12:55.378]                   function(frame = 1L) {
[16:12:55.378]                     if (is.function(sendCondition)) 
[16:12:55.378]                       return(sendCondition)
[16:12:55.378]                     ns <- getNamespace("parallel")
[16:12:55.378]                     if (exists("sendData", mode = "function", 
[16:12:55.378]                       envir = ns)) {
[16:12:55.378]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:55.378]                         envir = ns)
[16:12:55.378]                       envir <- sys.frame(frame)
[16:12:55.378]                       master <- NULL
[16:12:55.378]                       while (!identical(envir, .GlobalEnv) && 
[16:12:55.378]                         !identical(envir, emptyenv())) {
[16:12:55.378]                         if (exists("master", mode = "list", envir = envir, 
[16:12:55.378]                           inherits = FALSE)) {
[16:12:55.378]                           master <- get("master", mode = "list", 
[16:12:55.378]                             envir = envir, inherits = FALSE)
[16:12:55.378]                           if (inherits(master, c("SOCKnode", 
[16:12:55.378]                             "SOCK0node"))) {
[16:12:55.378]                             sendCondition <<- function(cond) {
[16:12:55.378]                               data <- list(type = "VALUE", value = cond, 
[16:12:55.378]                                 success = TRUE)
[16:12:55.378]                               parallel_sendData(master, data)
[16:12:55.378]                             }
[16:12:55.378]                             return(sendCondition)
[16:12:55.378]                           }
[16:12:55.378]                         }
[16:12:55.378]                         frame <- frame + 1L
[16:12:55.378]                         envir <- sys.frame(frame)
[16:12:55.378]                       }
[16:12:55.378]                     }
[16:12:55.378]                     sendCondition <<- function(cond) NULL
[16:12:55.378]                   }
[16:12:55.378]                 })
[16:12:55.378]                 withCallingHandlers({
[16:12:55.378]                   1
[16:12:55.378]                 }, immediateCondition = function(cond) {
[16:12:55.378]                   sendCondition <- ...future.makeSendCondition()
[16:12:55.378]                   sendCondition(cond)
[16:12:55.378]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.378]                   {
[16:12:55.378]                     inherits <- base::inherits
[16:12:55.378]                     invokeRestart <- base::invokeRestart
[16:12:55.378]                     is.null <- base::is.null
[16:12:55.378]                     muffled <- FALSE
[16:12:55.378]                     if (inherits(cond, "message")) {
[16:12:55.378]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:55.378]                       if (muffled) 
[16:12:55.378]                         invokeRestart("muffleMessage")
[16:12:55.378]                     }
[16:12:55.378]                     else if (inherits(cond, "warning")) {
[16:12:55.378]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:55.378]                       if (muffled) 
[16:12:55.378]                         invokeRestart("muffleWarning")
[16:12:55.378]                     }
[16:12:55.378]                     else if (inherits(cond, "condition")) {
[16:12:55.378]                       if (!is.null(pattern)) {
[16:12:55.378]                         computeRestarts <- base::computeRestarts
[16:12:55.378]                         grepl <- base::grepl
[16:12:55.378]                         restarts <- computeRestarts(cond)
[16:12:55.378]                         for (restart in restarts) {
[16:12:55.378]                           name <- restart$name
[16:12:55.378]                           if (is.null(name)) 
[16:12:55.378]                             next
[16:12:55.378]                           if (!grepl(pattern, name)) 
[16:12:55.378]                             next
[16:12:55.378]                           invokeRestart(restart)
[16:12:55.378]                           muffled <- TRUE
[16:12:55.378]                           break
[16:12:55.378]                         }
[16:12:55.378]                       }
[16:12:55.378]                     }
[16:12:55.378]                     invisible(muffled)
[16:12:55.378]                   }
[16:12:55.378]                   muffleCondition(cond)
[16:12:55.378]                 })
[16:12:55.378]             }))
[16:12:55.378]             future::FutureResult(value = ...future.value$value, 
[16:12:55.378]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:55.378]                   ...future.rng), globalenv = if (FALSE) 
[16:12:55.378]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:55.378]                     ...future.globalenv.names))
[16:12:55.378]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:55.378]         }, condition = base::local({
[16:12:55.378]             c <- base::c
[16:12:55.378]             inherits <- base::inherits
[16:12:55.378]             invokeRestart <- base::invokeRestart
[16:12:55.378]             length <- base::length
[16:12:55.378]             list <- base::list
[16:12:55.378]             seq.int <- base::seq.int
[16:12:55.378]             signalCondition <- base::signalCondition
[16:12:55.378]             sys.calls <- base::sys.calls
[16:12:55.378]             `[[` <- base::`[[`
[16:12:55.378]             `+` <- base::`+`
[16:12:55.378]             `<<-` <- base::`<<-`
[16:12:55.378]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:55.378]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:55.378]                   3L)]
[16:12:55.378]             }
[16:12:55.378]             function(cond) {
[16:12:55.378]                 is_error <- inherits(cond, "error")
[16:12:55.378]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:55.378]                   NULL)
[16:12:55.378]                 if (is_error) {
[16:12:55.378]                   sessionInformation <- function() {
[16:12:55.378]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:55.378]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:55.378]                       search = base::search(), system = base::Sys.info())
[16:12:55.378]                   }
[16:12:55.378]                   ...future.conditions[[length(...future.conditions) + 
[16:12:55.378]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:55.378]                     cond$call), session = sessionInformation(), 
[16:12:55.378]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:55.378]                   signalCondition(cond)
[16:12:55.378]                 }
[16:12:55.378]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:55.378]                 "immediateCondition"))) {
[16:12:55.378]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:55.378]                   ...future.conditions[[length(...future.conditions) + 
[16:12:55.378]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:55.378]                   if (TRUE && !signal) {
[16:12:55.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.378]                     {
[16:12:55.378]                       inherits <- base::inherits
[16:12:55.378]                       invokeRestart <- base::invokeRestart
[16:12:55.378]                       is.null <- base::is.null
[16:12:55.378]                       muffled <- FALSE
[16:12:55.378]                       if (inherits(cond, "message")) {
[16:12:55.378]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:55.378]                         if (muffled) 
[16:12:55.378]                           invokeRestart("muffleMessage")
[16:12:55.378]                       }
[16:12:55.378]                       else if (inherits(cond, "warning")) {
[16:12:55.378]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:55.378]                         if (muffled) 
[16:12:55.378]                           invokeRestart("muffleWarning")
[16:12:55.378]                       }
[16:12:55.378]                       else if (inherits(cond, "condition")) {
[16:12:55.378]                         if (!is.null(pattern)) {
[16:12:55.378]                           computeRestarts <- base::computeRestarts
[16:12:55.378]                           grepl <- base::grepl
[16:12:55.378]                           restarts <- computeRestarts(cond)
[16:12:55.378]                           for (restart in restarts) {
[16:12:55.378]                             name <- restart$name
[16:12:55.378]                             if (is.null(name)) 
[16:12:55.378]                               next
[16:12:55.378]                             if (!grepl(pattern, name)) 
[16:12:55.378]                               next
[16:12:55.378]                             invokeRestart(restart)
[16:12:55.378]                             muffled <- TRUE
[16:12:55.378]                             break
[16:12:55.378]                           }
[16:12:55.378]                         }
[16:12:55.378]                       }
[16:12:55.378]                       invisible(muffled)
[16:12:55.378]                     }
[16:12:55.378]                     muffleCondition(cond, pattern = "^muffle")
[16:12:55.378]                   }
[16:12:55.378]                 }
[16:12:55.378]                 else {
[16:12:55.378]                   if (TRUE) {
[16:12:55.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.378]                     {
[16:12:55.378]                       inherits <- base::inherits
[16:12:55.378]                       invokeRestart <- base::invokeRestart
[16:12:55.378]                       is.null <- base::is.null
[16:12:55.378]                       muffled <- FALSE
[16:12:55.378]                       if (inherits(cond, "message")) {
[16:12:55.378]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:55.378]                         if (muffled) 
[16:12:55.378]                           invokeRestart("muffleMessage")
[16:12:55.378]                       }
[16:12:55.378]                       else if (inherits(cond, "warning")) {
[16:12:55.378]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:55.378]                         if (muffled) 
[16:12:55.378]                           invokeRestart("muffleWarning")
[16:12:55.378]                       }
[16:12:55.378]                       else if (inherits(cond, "condition")) {
[16:12:55.378]                         if (!is.null(pattern)) {
[16:12:55.378]                           computeRestarts <- base::computeRestarts
[16:12:55.378]                           grepl <- base::grepl
[16:12:55.378]                           restarts <- computeRestarts(cond)
[16:12:55.378]                           for (restart in restarts) {
[16:12:55.378]                             name <- restart$name
[16:12:55.378]                             if (is.null(name)) 
[16:12:55.378]                               next
[16:12:55.378]                             if (!grepl(pattern, name)) 
[16:12:55.378]                               next
[16:12:55.378]                             invokeRestart(restart)
[16:12:55.378]                             muffled <- TRUE
[16:12:55.378]                             break
[16:12:55.378]                           }
[16:12:55.378]                         }
[16:12:55.378]                       }
[16:12:55.378]                       invisible(muffled)
[16:12:55.378]                     }
[16:12:55.378]                     muffleCondition(cond, pattern = "^muffle")
[16:12:55.378]                   }
[16:12:55.378]                 }
[16:12:55.378]             }
[16:12:55.378]         }))
[16:12:55.378]     }, error = function(ex) {
[16:12:55.378]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:55.378]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:55.378]                 ...future.rng), started = ...future.startTime, 
[16:12:55.378]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:55.378]             version = "1.8"), class = "FutureResult")
[16:12:55.378]     }, finally = {
[16:12:55.378]         if (!identical(...future.workdir, getwd())) 
[16:12:55.378]             setwd(...future.workdir)
[16:12:55.378]         {
[16:12:55.378]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:55.378]                 ...future.oldOptions$nwarnings <- NULL
[16:12:55.378]             }
[16:12:55.378]             base::options(...future.oldOptions)
[16:12:55.378]             if (.Platform$OS.type == "windows") {
[16:12:55.378]                 old_names <- names(...future.oldEnvVars)
[16:12:55.378]                 envs <- base::Sys.getenv()
[16:12:55.378]                 names <- names(envs)
[16:12:55.378]                 common <- intersect(names, old_names)
[16:12:55.378]                 added <- setdiff(names, old_names)
[16:12:55.378]                 removed <- setdiff(old_names, names)
[16:12:55.378]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:55.378]                   envs[common]]
[16:12:55.378]                 NAMES <- toupper(changed)
[16:12:55.378]                 args <- list()
[16:12:55.378]                 for (kk in seq_along(NAMES)) {
[16:12:55.378]                   name <- changed[[kk]]
[16:12:55.378]                   NAME <- NAMES[[kk]]
[16:12:55.378]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.378]                     next
[16:12:55.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:55.378]                 }
[16:12:55.378]                 NAMES <- toupper(added)
[16:12:55.378]                 for (kk in seq_along(NAMES)) {
[16:12:55.378]                   name <- added[[kk]]
[16:12:55.378]                   NAME <- NAMES[[kk]]
[16:12:55.378]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.378]                     next
[16:12:55.378]                   args[[name]] <- ""
[16:12:55.378]                 }
[16:12:55.378]                 NAMES <- toupper(removed)
[16:12:55.378]                 for (kk in seq_along(NAMES)) {
[16:12:55.378]                   name <- removed[[kk]]
[16:12:55.378]                   NAME <- NAMES[[kk]]
[16:12:55.378]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.378]                     next
[16:12:55.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:55.378]                 }
[16:12:55.378]                 if (length(args) > 0) 
[16:12:55.378]                   base::do.call(base::Sys.setenv, args = args)
[16:12:55.378]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:55.378]             }
[16:12:55.378]             else {
[16:12:55.378]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:55.378]             }
[16:12:55.378]             {
[16:12:55.378]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:55.378]                   0L) {
[16:12:55.378]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:55.378]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:55.378]                   base::options(opts)
[16:12:55.378]                 }
[16:12:55.378]                 {
[16:12:55.378]                   {
[16:12:55.378]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:55.378]                     NULL
[16:12:55.378]                   }
[16:12:55.378]                   options(future.plan = NULL)
[16:12:55.378]                   if (is.na(NA_character_)) 
[16:12:55.378]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:55.378]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:55.378]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:55.378]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:55.378]                     envir = parent.frame()) 
[16:12:55.378]                   {
[16:12:55.378]                     if (is.function(workers)) 
[16:12:55.378]                       workers <- workers()
[16:12:55.378]                     workers <- structure(as.integer(workers), 
[16:12:55.378]                       class = class(workers))
[16:12:55.378]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:55.378]                       workers >= 1)
[16:12:55.378]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:55.378]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:55.378]                     }
[16:12:55.378]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:55.378]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:55.378]                       envir = envir)
[16:12:55.378]                     if (!future$lazy) 
[16:12:55.378]                       future <- run(future)
[16:12:55.378]                     invisible(future)
[16:12:55.378]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:55.378]                 }
[16:12:55.378]             }
[16:12:55.378]         }
[16:12:55.378]     })
[16:12:55.378]     if (TRUE) {
[16:12:55.378]         base::sink(type = "output", split = FALSE)
[16:12:55.378]         if (TRUE) {
[16:12:55.378]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:55.378]         }
[16:12:55.378]         else {
[16:12:55.378]             ...future.result["stdout"] <- base::list(NULL)
[16:12:55.378]         }
[16:12:55.378]         base::close(...future.stdout)
[16:12:55.378]         ...future.stdout <- NULL
[16:12:55.378]     }
[16:12:55.378]     ...future.result$conditions <- ...future.conditions
[16:12:55.378]     ...future.result$finished <- base::Sys.time()
[16:12:55.378]     ...future.result
[16:12:55.378] }
[16:12:55.381] MultisessionFuture started
[16:12:55.381] - Launch lazy future ... done
[16:12:55.381] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:55.382] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:55.382] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:55.383] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:55.383] Searching for globals ... DONE
[16:12:55.383] Resolving globals: TRUE
[16:12:55.383] Resolving any globals that are futures ...
[16:12:55.383] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:55.383] Resolving any globals that are futures ... DONE
[16:12:55.384] Resolving futures part of globals (recursively) ...
[16:12:55.384] resolve() on list ...
[16:12:55.384]  recursive: 99
[16:12:55.384]  length: 1
[16:12:55.384]  elements: ‘a’
[16:12:55.429] receiveMessageFromWorker() for ClusterFuture ...
[16:12:55.429] - Validating connection of MultisessionFuture
[16:12:55.429] - received message: FutureResult
[16:12:55.429] - Received FutureResult
[16:12:55.429] - Erased future from FutureRegistry
[16:12:55.430] result() for ClusterFuture ...
[16:12:55.430] - result already collected: FutureResult
[16:12:55.430] result() for ClusterFuture ... done
[16:12:55.430] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:55.430] Future #1
[16:12:55.430] result() for ClusterFuture ...
[16:12:55.430] - result already collected: FutureResult
[16:12:55.430] result() for ClusterFuture ... done
[16:12:55.430] result() for ClusterFuture ...
[16:12:55.430] - result already collected: FutureResult
[16:12:55.431] result() for ClusterFuture ... done
[16:12:55.431] A MultisessionFuture was resolved
[16:12:55.431]  length: 0 (resolved future 1)
[16:12:55.431] resolve() on list ... DONE
[16:12:55.431] - globals: [1] ‘a’
[16:12:55.431] Resolving futures part of globals (recursively) ... DONE
[16:12:55.433] The total size of the 1 globals is 1.55 MiB (1629496 bytes)
[16:12:55.434] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[16:12:55.434] - globals: [1] ‘a’
[16:12:55.434] - packages: [1] ‘future’
[16:12:55.434] getGlobalsAndPackages() ... DONE
[16:12:55.434] run() for ‘Future’ ...
[16:12:55.434] - state: ‘created’
[16:12:55.435] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:55.450] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:55.450] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:55.450]   - Field: ‘node’
[16:12:55.450]   - Field: ‘label’
[16:12:55.450]   - Field: ‘local’
[16:12:55.450]   - Field: ‘owner’
[16:12:55.451]   - Field: ‘envir’
[16:12:55.451]   - Field: ‘workers’
[16:12:55.451]   - Field: ‘packages’
[16:12:55.451]   - Field: ‘gc’
[16:12:55.451]   - Field: ‘conditions’
[16:12:55.451]   - Field: ‘persistent’
[16:12:55.451]   - Field: ‘expr’
[16:12:55.451]   - Field: ‘uuid’
[16:12:55.451]   - Field: ‘seed’
[16:12:55.451]   - Field: ‘version’
[16:12:55.451]   - Field: ‘result’
[16:12:55.452]   - Field: ‘asynchronous’
[16:12:55.452]   - Field: ‘calls’
[16:12:55.452]   - Field: ‘globals’
[16:12:55.452]   - Field: ‘stdout’
[16:12:55.452]   - Field: ‘earlySignal’
[16:12:55.452]   - Field: ‘lazy’
[16:12:55.452]   - Field: ‘state’
[16:12:55.452] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:55.452] - Launch lazy future ...
[16:12:55.453] Packages needed by the future expression (n = 1): ‘future’
[16:12:55.453] Packages needed by future strategies (n = 0): <none>
[16:12:55.453] {
[16:12:55.453]     {
[16:12:55.453]         {
[16:12:55.453]             ...future.startTime <- base::Sys.time()
[16:12:55.453]             {
[16:12:55.453]                 {
[16:12:55.453]                   {
[16:12:55.453]                     {
[16:12:55.453]                       {
[16:12:55.453]                         base::local({
[16:12:55.453]                           has_future <- base::requireNamespace("future", 
[16:12:55.453]                             quietly = TRUE)
[16:12:55.453]                           if (has_future) {
[16:12:55.453]                             ns <- base::getNamespace("future")
[16:12:55.453]                             version <- ns[[".package"]][["version"]]
[16:12:55.453]                             if (is.null(version)) 
[16:12:55.453]                               version <- utils::packageVersion("future")
[16:12:55.453]                           }
[16:12:55.453]                           else {
[16:12:55.453]                             version <- NULL
[16:12:55.453]                           }
[16:12:55.453]                           if (!has_future || version < "1.8.0") {
[16:12:55.453]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:55.453]                               "", base::R.version$version.string), 
[16:12:55.453]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:55.453]                                 base::R.version$platform, 8 * 
[16:12:55.453]                                   base::.Machine$sizeof.pointer), 
[16:12:55.453]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:55.453]                                 "release", "version")], collapse = " "), 
[16:12:55.453]                               hostname = base::Sys.info()[["nodename"]])
[16:12:55.453]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:55.453]                               info)
[16:12:55.453]                             info <- base::paste(info, collapse = "; ")
[16:12:55.453]                             if (!has_future) {
[16:12:55.453]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:55.453]                                 info)
[16:12:55.453]                             }
[16:12:55.453]                             else {
[16:12:55.453]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:55.453]                                 info, version)
[16:12:55.453]                             }
[16:12:55.453]                             base::stop(msg)
[16:12:55.453]                           }
[16:12:55.453]                         })
[16:12:55.453]                       }
[16:12:55.453]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:55.453]                       base::options(mc.cores = 1L)
[16:12:55.453]                     }
[16:12:55.453]                     base::local({
[16:12:55.453]                       for (pkg in "future") {
[16:12:55.453]                         base::loadNamespace(pkg)
[16:12:55.453]                         base::library(pkg, character.only = TRUE)
[16:12:55.453]                       }
[16:12:55.453]                     })
[16:12:55.453]                   }
[16:12:55.453]                   options(future.plan = NULL)
[16:12:55.453]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:55.453]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:55.453]                 }
[16:12:55.453]                 ...future.workdir <- getwd()
[16:12:55.453]             }
[16:12:55.453]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:55.453]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:55.453]         }
[16:12:55.453]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:55.453]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:55.453]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:55.453]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:55.453]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:55.453]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:55.453]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:55.453]             base::names(...future.oldOptions))
[16:12:55.453]     }
[16:12:55.453]     if (FALSE) {
[16:12:55.453]     }
[16:12:55.453]     else {
[16:12:55.453]         if (TRUE) {
[16:12:55.453]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:55.453]                 open = "w")
[16:12:55.453]         }
[16:12:55.453]         else {
[16:12:55.453]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:55.453]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:55.453]         }
[16:12:55.453]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:55.453]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:55.453]             base::sink(type = "output", split = FALSE)
[16:12:55.453]             base::close(...future.stdout)
[16:12:55.453]         }, add = TRUE)
[16:12:55.453]     }
[16:12:55.453]     ...future.frame <- base::sys.nframe()
[16:12:55.453]     ...future.conditions <- base::list()
[16:12:55.453]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:55.453]     if (FALSE) {
[16:12:55.453]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:55.453]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:55.453]     }
[16:12:55.453]     ...future.result <- base::tryCatch({
[16:12:55.453]         base::withCallingHandlers({
[16:12:55.453]             ...future.value <- base::withVisible(base::local({
[16:12:55.453]                 ...future.makeSendCondition <- local({
[16:12:55.453]                   sendCondition <- NULL
[16:12:55.453]                   function(frame = 1L) {
[16:12:55.453]                     if (is.function(sendCondition)) 
[16:12:55.453]                       return(sendCondition)
[16:12:55.453]                     ns <- getNamespace("parallel")
[16:12:55.453]                     if (exists("sendData", mode = "function", 
[16:12:55.453]                       envir = ns)) {
[16:12:55.453]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:55.453]                         envir = ns)
[16:12:55.453]                       envir <- sys.frame(frame)
[16:12:55.453]                       master <- NULL
[16:12:55.453]                       while (!identical(envir, .GlobalEnv) && 
[16:12:55.453]                         !identical(envir, emptyenv())) {
[16:12:55.453]                         if (exists("master", mode = "list", envir = envir, 
[16:12:55.453]                           inherits = FALSE)) {
[16:12:55.453]                           master <- get("master", mode = "list", 
[16:12:55.453]                             envir = envir, inherits = FALSE)
[16:12:55.453]                           if (inherits(master, c("SOCKnode", 
[16:12:55.453]                             "SOCK0node"))) {
[16:12:55.453]                             sendCondition <<- function(cond) {
[16:12:55.453]                               data <- list(type = "VALUE", value = cond, 
[16:12:55.453]                                 success = TRUE)
[16:12:55.453]                               parallel_sendData(master, data)
[16:12:55.453]                             }
[16:12:55.453]                             return(sendCondition)
[16:12:55.453]                           }
[16:12:55.453]                         }
[16:12:55.453]                         frame <- frame + 1L
[16:12:55.453]                         envir <- sys.frame(frame)
[16:12:55.453]                       }
[16:12:55.453]                     }
[16:12:55.453]                     sendCondition <<- function(cond) NULL
[16:12:55.453]                   }
[16:12:55.453]                 })
[16:12:55.453]                 withCallingHandlers({
[16:12:55.453]                   value(a) + 1
[16:12:55.453]                 }, immediateCondition = function(cond) {
[16:12:55.453]                   sendCondition <- ...future.makeSendCondition()
[16:12:55.453]                   sendCondition(cond)
[16:12:55.453]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.453]                   {
[16:12:55.453]                     inherits <- base::inherits
[16:12:55.453]                     invokeRestart <- base::invokeRestart
[16:12:55.453]                     is.null <- base::is.null
[16:12:55.453]                     muffled <- FALSE
[16:12:55.453]                     if (inherits(cond, "message")) {
[16:12:55.453]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:55.453]                       if (muffled) 
[16:12:55.453]                         invokeRestart("muffleMessage")
[16:12:55.453]                     }
[16:12:55.453]                     else if (inherits(cond, "warning")) {
[16:12:55.453]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:55.453]                       if (muffled) 
[16:12:55.453]                         invokeRestart("muffleWarning")
[16:12:55.453]                     }
[16:12:55.453]                     else if (inherits(cond, "condition")) {
[16:12:55.453]                       if (!is.null(pattern)) {
[16:12:55.453]                         computeRestarts <- base::computeRestarts
[16:12:55.453]                         grepl <- base::grepl
[16:12:55.453]                         restarts <- computeRestarts(cond)
[16:12:55.453]                         for (restart in restarts) {
[16:12:55.453]                           name <- restart$name
[16:12:55.453]                           if (is.null(name)) 
[16:12:55.453]                             next
[16:12:55.453]                           if (!grepl(pattern, name)) 
[16:12:55.453]                             next
[16:12:55.453]                           invokeRestart(restart)
[16:12:55.453]                           muffled <- TRUE
[16:12:55.453]                           break
[16:12:55.453]                         }
[16:12:55.453]                       }
[16:12:55.453]                     }
[16:12:55.453]                     invisible(muffled)
[16:12:55.453]                   }
[16:12:55.453]                   muffleCondition(cond)
[16:12:55.453]                 })
[16:12:55.453]             }))
[16:12:55.453]             future::FutureResult(value = ...future.value$value, 
[16:12:55.453]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:55.453]                   ...future.rng), globalenv = if (FALSE) 
[16:12:55.453]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:55.453]                     ...future.globalenv.names))
[16:12:55.453]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:55.453]         }, condition = base::local({
[16:12:55.453]             c <- base::c
[16:12:55.453]             inherits <- base::inherits
[16:12:55.453]             invokeRestart <- base::invokeRestart
[16:12:55.453]             length <- base::length
[16:12:55.453]             list <- base::list
[16:12:55.453]             seq.int <- base::seq.int
[16:12:55.453]             signalCondition <- base::signalCondition
[16:12:55.453]             sys.calls <- base::sys.calls
[16:12:55.453]             `[[` <- base::`[[`
[16:12:55.453]             `+` <- base::`+`
[16:12:55.453]             `<<-` <- base::`<<-`
[16:12:55.453]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:55.453]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:55.453]                   3L)]
[16:12:55.453]             }
[16:12:55.453]             function(cond) {
[16:12:55.453]                 is_error <- inherits(cond, "error")
[16:12:55.453]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:55.453]                   NULL)
[16:12:55.453]                 if (is_error) {
[16:12:55.453]                   sessionInformation <- function() {
[16:12:55.453]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:55.453]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:55.453]                       search = base::search(), system = base::Sys.info())
[16:12:55.453]                   }
[16:12:55.453]                   ...future.conditions[[length(...future.conditions) + 
[16:12:55.453]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:55.453]                     cond$call), session = sessionInformation(), 
[16:12:55.453]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:55.453]                   signalCondition(cond)
[16:12:55.453]                 }
[16:12:55.453]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:55.453]                 "immediateCondition"))) {
[16:12:55.453]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:55.453]                   ...future.conditions[[length(...future.conditions) + 
[16:12:55.453]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:55.453]                   if (TRUE && !signal) {
[16:12:55.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.453]                     {
[16:12:55.453]                       inherits <- base::inherits
[16:12:55.453]                       invokeRestart <- base::invokeRestart
[16:12:55.453]                       is.null <- base::is.null
[16:12:55.453]                       muffled <- FALSE
[16:12:55.453]                       if (inherits(cond, "message")) {
[16:12:55.453]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:55.453]                         if (muffled) 
[16:12:55.453]                           invokeRestart("muffleMessage")
[16:12:55.453]                       }
[16:12:55.453]                       else if (inherits(cond, "warning")) {
[16:12:55.453]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:55.453]                         if (muffled) 
[16:12:55.453]                           invokeRestart("muffleWarning")
[16:12:55.453]                       }
[16:12:55.453]                       else if (inherits(cond, "condition")) {
[16:12:55.453]                         if (!is.null(pattern)) {
[16:12:55.453]                           computeRestarts <- base::computeRestarts
[16:12:55.453]                           grepl <- base::grepl
[16:12:55.453]                           restarts <- computeRestarts(cond)
[16:12:55.453]                           for (restart in restarts) {
[16:12:55.453]                             name <- restart$name
[16:12:55.453]                             if (is.null(name)) 
[16:12:55.453]                               next
[16:12:55.453]                             if (!grepl(pattern, name)) 
[16:12:55.453]                               next
[16:12:55.453]                             invokeRestart(restart)
[16:12:55.453]                             muffled <- TRUE
[16:12:55.453]                             break
[16:12:55.453]                           }
[16:12:55.453]                         }
[16:12:55.453]                       }
[16:12:55.453]                       invisible(muffled)
[16:12:55.453]                     }
[16:12:55.453]                     muffleCondition(cond, pattern = "^muffle")
[16:12:55.453]                   }
[16:12:55.453]                 }
[16:12:55.453]                 else {
[16:12:55.453]                   if (TRUE) {
[16:12:55.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.453]                     {
[16:12:55.453]                       inherits <- base::inherits
[16:12:55.453]                       invokeRestart <- base::invokeRestart
[16:12:55.453]                       is.null <- base::is.null
[16:12:55.453]                       muffled <- FALSE
[16:12:55.453]                       if (inherits(cond, "message")) {
[16:12:55.453]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:55.453]                         if (muffled) 
[16:12:55.453]                           invokeRestart("muffleMessage")
[16:12:55.453]                       }
[16:12:55.453]                       else if (inherits(cond, "warning")) {
[16:12:55.453]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:55.453]                         if (muffled) 
[16:12:55.453]                           invokeRestart("muffleWarning")
[16:12:55.453]                       }
[16:12:55.453]                       else if (inherits(cond, "condition")) {
[16:12:55.453]                         if (!is.null(pattern)) {
[16:12:55.453]                           computeRestarts <- base::computeRestarts
[16:12:55.453]                           grepl <- base::grepl
[16:12:55.453]                           restarts <- computeRestarts(cond)
[16:12:55.453]                           for (restart in restarts) {
[16:12:55.453]                             name <- restart$name
[16:12:55.453]                             if (is.null(name)) 
[16:12:55.453]                               next
[16:12:55.453]                             if (!grepl(pattern, name)) 
[16:12:55.453]                               next
[16:12:55.453]                             invokeRestart(restart)
[16:12:55.453]                             muffled <- TRUE
[16:12:55.453]                             break
[16:12:55.453]                           }
[16:12:55.453]                         }
[16:12:55.453]                       }
[16:12:55.453]                       invisible(muffled)
[16:12:55.453]                     }
[16:12:55.453]                     muffleCondition(cond, pattern = "^muffle")
[16:12:55.453]                   }
[16:12:55.453]                 }
[16:12:55.453]             }
[16:12:55.453]         }))
[16:12:55.453]     }, error = function(ex) {
[16:12:55.453]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:55.453]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:55.453]                 ...future.rng), started = ...future.startTime, 
[16:12:55.453]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:55.453]             version = "1.8"), class = "FutureResult")
[16:12:55.453]     }, finally = {
[16:12:55.453]         if (!identical(...future.workdir, getwd())) 
[16:12:55.453]             setwd(...future.workdir)
[16:12:55.453]         {
[16:12:55.453]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:55.453]                 ...future.oldOptions$nwarnings <- NULL
[16:12:55.453]             }
[16:12:55.453]             base::options(...future.oldOptions)
[16:12:55.453]             if (.Platform$OS.type == "windows") {
[16:12:55.453]                 old_names <- names(...future.oldEnvVars)
[16:12:55.453]                 envs <- base::Sys.getenv()
[16:12:55.453]                 names <- names(envs)
[16:12:55.453]                 common <- intersect(names, old_names)
[16:12:55.453]                 added <- setdiff(names, old_names)
[16:12:55.453]                 removed <- setdiff(old_names, names)
[16:12:55.453]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:55.453]                   envs[common]]
[16:12:55.453]                 NAMES <- toupper(changed)
[16:12:55.453]                 args <- list()
[16:12:55.453]                 for (kk in seq_along(NAMES)) {
[16:12:55.453]                   name <- changed[[kk]]
[16:12:55.453]                   NAME <- NAMES[[kk]]
[16:12:55.453]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.453]                     next
[16:12:55.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:55.453]                 }
[16:12:55.453]                 NAMES <- toupper(added)
[16:12:55.453]                 for (kk in seq_along(NAMES)) {
[16:12:55.453]                   name <- added[[kk]]
[16:12:55.453]                   NAME <- NAMES[[kk]]
[16:12:55.453]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.453]                     next
[16:12:55.453]                   args[[name]] <- ""
[16:12:55.453]                 }
[16:12:55.453]                 NAMES <- toupper(removed)
[16:12:55.453]                 for (kk in seq_along(NAMES)) {
[16:12:55.453]                   name <- removed[[kk]]
[16:12:55.453]                   NAME <- NAMES[[kk]]
[16:12:55.453]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.453]                     next
[16:12:55.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:55.453]                 }
[16:12:55.453]                 if (length(args) > 0) 
[16:12:55.453]                   base::do.call(base::Sys.setenv, args = args)
[16:12:55.453]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:55.453]             }
[16:12:55.453]             else {
[16:12:55.453]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:55.453]             }
[16:12:55.453]             {
[16:12:55.453]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:55.453]                   0L) {
[16:12:55.453]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:55.453]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:55.453]                   base::options(opts)
[16:12:55.453]                 }
[16:12:55.453]                 {
[16:12:55.453]                   {
[16:12:55.453]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:55.453]                     NULL
[16:12:55.453]                   }
[16:12:55.453]                   options(future.plan = NULL)
[16:12:55.453]                   if (is.na(NA_character_)) 
[16:12:55.453]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:55.453]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:55.453]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:55.453]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:55.453]                     envir = parent.frame()) 
[16:12:55.453]                   {
[16:12:55.453]                     if (is.function(workers)) 
[16:12:55.453]                       workers <- workers()
[16:12:55.453]                     workers <- structure(as.integer(workers), 
[16:12:55.453]                       class = class(workers))
[16:12:55.453]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:55.453]                       workers >= 1)
[16:12:55.453]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:55.453]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:55.453]                     }
[16:12:55.453]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:55.453]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:55.453]                       envir = envir)
[16:12:55.453]                     if (!future$lazy) 
[16:12:55.453]                       future <- run(future)
[16:12:55.453]                     invisible(future)
[16:12:55.453]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:55.453]                 }
[16:12:55.453]             }
[16:12:55.453]         }
[16:12:55.453]     })
[16:12:55.453]     if (TRUE) {
[16:12:55.453]         base::sink(type = "output", split = FALSE)
[16:12:55.453]         if (TRUE) {
[16:12:55.453]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:55.453]         }
[16:12:55.453]         else {
[16:12:55.453]             ...future.result["stdout"] <- base::list(NULL)
[16:12:55.453]         }
[16:12:55.453]         base::close(...future.stdout)
[16:12:55.453]         ...future.stdout <- NULL
[16:12:55.453]     }
[16:12:55.453]     ...future.result$conditions <- ...future.conditions
[16:12:55.453]     ...future.result$finished <- base::Sys.time()
[16:12:55.453]     ...future.result
[16:12:55.453] }
[16:12:55.456] Exporting 1 global objects (1.55 MiB) to cluster node #1 ...
[16:12:55.458] Exporting ‘a’ (1.55 MiB) to cluster node #1 ...
[16:12:55.512] Exporting ‘a’ (1.55 MiB) to cluster node #1 ... DONE
[16:12:55.512] Exporting 1 global objects (1.55 MiB) to cluster node #1 ... DONE
[16:12:55.513] MultisessionFuture started
[16:12:55.513] - Launch lazy future ... done
[16:12:55.513] run() for ‘MultisessionFuture’ ... done
[16:12:55.514] result() for ClusterFuture ...
[16:12:55.514] receiveMessageFromWorker() for ClusterFuture ...
[16:12:55.514] - Validating connection of MultisessionFuture
[16:12:55.567] - received message: FutureResult
[16:12:55.568] - Received FutureResult
[16:12:55.568] - Erased future from FutureRegistry
[16:12:55.568] result() for ClusterFuture ...
[16:12:55.568] - result already collected: FutureResult
[16:12:55.568] result() for ClusterFuture ... done
[16:12:55.568] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:55.568] result() for ClusterFuture ... done
[16:12:55.569] result() for ClusterFuture ...
[16:12:55.569] - result already collected: FutureResult
[16:12:55.569] result() for ClusterFuture ... done
value(b) = 2
[16:12:55.569] result() for ClusterFuture ...
[16:12:55.569] - result already collected: FutureResult
[16:12:55.569] result() for ClusterFuture ... done
[16:12:55.569] result() for ClusterFuture ...
[16:12:55.569] - result already collected: FutureResult
[16:12:55.570] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:55.570] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:55.570] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:55.570] 
[16:12:55.571] Searching for globals ... DONE
[16:12:55.571] - globals: [0] <none>
[16:12:55.571] getGlobalsAndPackages() ... DONE
[16:12:55.571] run() for ‘Future’ ...
[16:12:55.571] - state: ‘created’
[16:12:55.571] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:55.586] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:55.586] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:55.586]   - Field: ‘node’
[16:12:55.586]   - Field: ‘label’
[16:12:55.587]   - Field: ‘local’
[16:12:55.587]   - Field: ‘owner’
[16:12:55.587]   - Field: ‘envir’
[16:12:55.587]   - Field: ‘workers’
[16:12:55.587]   - Field: ‘packages’
[16:12:55.587]   - Field: ‘gc’
[16:12:55.587]   - Field: ‘conditions’
[16:12:55.587]   - Field: ‘persistent’
[16:12:55.587]   - Field: ‘expr’
[16:12:55.587]   - Field: ‘uuid’
[16:12:55.587]   - Field: ‘seed’
[16:12:55.588]   - Field: ‘version’
[16:12:55.588]   - Field: ‘result’
[16:12:55.588]   - Field: ‘asynchronous’
[16:12:55.588]   - Field: ‘calls’
[16:12:55.588]   - Field: ‘globals’
[16:12:55.588]   - Field: ‘stdout’
[16:12:55.588]   - Field: ‘earlySignal’
[16:12:55.588]   - Field: ‘lazy’
[16:12:55.588]   - Field: ‘state’
[16:12:55.588] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:55.589] - Launch lazy future ...
[16:12:55.589] Packages needed by the future expression (n = 0): <none>
[16:12:55.589] Packages needed by future strategies (n = 0): <none>
[16:12:55.589] {
[16:12:55.589]     {
[16:12:55.589]         {
[16:12:55.589]             ...future.startTime <- base::Sys.time()
[16:12:55.589]             {
[16:12:55.589]                 {
[16:12:55.589]                   {
[16:12:55.589]                     {
[16:12:55.589]                       base::local({
[16:12:55.589]                         has_future <- base::requireNamespace("future", 
[16:12:55.589]                           quietly = TRUE)
[16:12:55.589]                         if (has_future) {
[16:12:55.589]                           ns <- base::getNamespace("future")
[16:12:55.589]                           version <- ns[[".package"]][["version"]]
[16:12:55.589]                           if (is.null(version)) 
[16:12:55.589]                             version <- utils::packageVersion("future")
[16:12:55.589]                         }
[16:12:55.589]                         else {
[16:12:55.589]                           version <- NULL
[16:12:55.589]                         }
[16:12:55.589]                         if (!has_future || version < "1.8.0") {
[16:12:55.589]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:55.589]                             "", base::R.version$version.string), 
[16:12:55.589]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:55.589]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:55.589]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:55.589]                               "release", "version")], collapse = " "), 
[16:12:55.589]                             hostname = base::Sys.info()[["nodename"]])
[16:12:55.589]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:55.589]                             info)
[16:12:55.589]                           info <- base::paste(info, collapse = "; ")
[16:12:55.589]                           if (!has_future) {
[16:12:55.589]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:55.589]                               info)
[16:12:55.589]                           }
[16:12:55.589]                           else {
[16:12:55.589]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:55.589]                               info, version)
[16:12:55.589]                           }
[16:12:55.589]                           base::stop(msg)
[16:12:55.589]                         }
[16:12:55.589]                       })
[16:12:55.589]                     }
[16:12:55.589]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:55.589]                     base::options(mc.cores = 1L)
[16:12:55.589]                   }
[16:12:55.589]                   options(future.plan = NULL)
[16:12:55.589]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:55.589]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:55.589]                 }
[16:12:55.589]                 ...future.workdir <- getwd()
[16:12:55.589]             }
[16:12:55.589]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:55.589]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:55.589]         }
[16:12:55.589]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:55.589]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:55.589]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:55.589]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:55.589]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:55.589]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:55.589]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:55.589]             base::names(...future.oldOptions))
[16:12:55.589]     }
[16:12:55.589]     if (FALSE) {
[16:12:55.589]     }
[16:12:55.589]     else {
[16:12:55.589]         if (TRUE) {
[16:12:55.589]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:55.589]                 open = "w")
[16:12:55.589]         }
[16:12:55.589]         else {
[16:12:55.589]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:55.589]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:55.589]         }
[16:12:55.589]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:55.589]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:55.589]             base::sink(type = "output", split = FALSE)
[16:12:55.589]             base::close(...future.stdout)
[16:12:55.589]         }, add = TRUE)
[16:12:55.589]     }
[16:12:55.589]     ...future.frame <- base::sys.nframe()
[16:12:55.589]     ...future.conditions <- base::list()
[16:12:55.589]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:55.589]     if (FALSE) {
[16:12:55.589]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:55.589]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:55.589]     }
[16:12:55.589]     ...future.result <- base::tryCatch({
[16:12:55.589]         base::withCallingHandlers({
[16:12:55.589]             ...future.value <- base::withVisible(base::local({
[16:12:55.589]                 ...future.makeSendCondition <- local({
[16:12:55.589]                   sendCondition <- NULL
[16:12:55.589]                   function(frame = 1L) {
[16:12:55.589]                     if (is.function(sendCondition)) 
[16:12:55.589]                       return(sendCondition)
[16:12:55.589]                     ns <- getNamespace("parallel")
[16:12:55.589]                     if (exists("sendData", mode = "function", 
[16:12:55.589]                       envir = ns)) {
[16:12:55.589]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:55.589]                         envir = ns)
[16:12:55.589]                       envir <- sys.frame(frame)
[16:12:55.589]                       master <- NULL
[16:12:55.589]                       while (!identical(envir, .GlobalEnv) && 
[16:12:55.589]                         !identical(envir, emptyenv())) {
[16:12:55.589]                         if (exists("master", mode = "list", envir = envir, 
[16:12:55.589]                           inherits = FALSE)) {
[16:12:55.589]                           master <- get("master", mode = "list", 
[16:12:55.589]                             envir = envir, inherits = FALSE)
[16:12:55.589]                           if (inherits(master, c("SOCKnode", 
[16:12:55.589]                             "SOCK0node"))) {
[16:12:55.589]                             sendCondition <<- function(cond) {
[16:12:55.589]                               data <- list(type = "VALUE", value = cond, 
[16:12:55.589]                                 success = TRUE)
[16:12:55.589]                               parallel_sendData(master, data)
[16:12:55.589]                             }
[16:12:55.589]                             return(sendCondition)
[16:12:55.589]                           }
[16:12:55.589]                         }
[16:12:55.589]                         frame <- frame + 1L
[16:12:55.589]                         envir <- sys.frame(frame)
[16:12:55.589]                       }
[16:12:55.589]                     }
[16:12:55.589]                     sendCondition <<- function(cond) NULL
[16:12:55.589]                   }
[16:12:55.589]                 })
[16:12:55.589]                 withCallingHandlers({
[16:12:55.589]                   1
[16:12:55.589]                 }, immediateCondition = function(cond) {
[16:12:55.589]                   sendCondition <- ...future.makeSendCondition()
[16:12:55.589]                   sendCondition(cond)
[16:12:55.589]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.589]                   {
[16:12:55.589]                     inherits <- base::inherits
[16:12:55.589]                     invokeRestart <- base::invokeRestart
[16:12:55.589]                     is.null <- base::is.null
[16:12:55.589]                     muffled <- FALSE
[16:12:55.589]                     if (inherits(cond, "message")) {
[16:12:55.589]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:55.589]                       if (muffled) 
[16:12:55.589]                         invokeRestart("muffleMessage")
[16:12:55.589]                     }
[16:12:55.589]                     else if (inherits(cond, "warning")) {
[16:12:55.589]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:55.589]                       if (muffled) 
[16:12:55.589]                         invokeRestart("muffleWarning")
[16:12:55.589]                     }
[16:12:55.589]                     else if (inherits(cond, "condition")) {
[16:12:55.589]                       if (!is.null(pattern)) {
[16:12:55.589]                         computeRestarts <- base::computeRestarts
[16:12:55.589]                         grepl <- base::grepl
[16:12:55.589]                         restarts <- computeRestarts(cond)
[16:12:55.589]                         for (restart in restarts) {
[16:12:55.589]                           name <- restart$name
[16:12:55.589]                           if (is.null(name)) 
[16:12:55.589]                             next
[16:12:55.589]                           if (!grepl(pattern, name)) 
[16:12:55.589]                             next
[16:12:55.589]                           invokeRestart(restart)
[16:12:55.589]                           muffled <- TRUE
[16:12:55.589]                           break
[16:12:55.589]                         }
[16:12:55.589]                       }
[16:12:55.589]                     }
[16:12:55.589]                     invisible(muffled)
[16:12:55.589]                   }
[16:12:55.589]                   muffleCondition(cond)
[16:12:55.589]                 })
[16:12:55.589]             }))
[16:12:55.589]             future::FutureResult(value = ...future.value$value, 
[16:12:55.589]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:55.589]                   ...future.rng), globalenv = if (FALSE) 
[16:12:55.589]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:55.589]                     ...future.globalenv.names))
[16:12:55.589]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:55.589]         }, condition = base::local({
[16:12:55.589]             c <- base::c
[16:12:55.589]             inherits <- base::inherits
[16:12:55.589]             invokeRestart <- base::invokeRestart
[16:12:55.589]             length <- base::length
[16:12:55.589]             list <- base::list
[16:12:55.589]             seq.int <- base::seq.int
[16:12:55.589]             signalCondition <- base::signalCondition
[16:12:55.589]             sys.calls <- base::sys.calls
[16:12:55.589]             `[[` <- base::`[[`
[16:12:55.589]             `+` <- base::`+`
[16:12:55.589]             `<<-` <- base::`<<-`
[16:12:55.589]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:55.589]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:55.589]                   3L)]
[16:12:55.589]             }
[16:12:55.589]             function(cond) {
[16:12:55.589]                 is_error <- inherits(cond, "error")
[16:12:55.589]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:55.589]                   NULL)
[16:12:55.589]                 if (is_error) {
[16:12:55.589]                   sessionInformation <- function() {
[16:12:55.589]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:55.589]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:55.589]                       search = base::search(), system = base::Sys.info())
[16:12:55.589]                   }
[16:12:55.589]                   ...future.conditions[[length(...future.conditions) + 
[16:12:55.589]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:55.589]                     cond$call), session = sessionInformation(), 
[16:12:55.589]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:55.589]                   signalCondition(cond)
[16:12:55.589]                 }
[16:12:55.589]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:55.589]                 "immediateCondition"))) {
[16:12:55.589]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:55.589]                   ...future.conditions[[length(...future.conditions) + 
[16:12:55.589]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:55.589]                   if (TRUE && !signal) {
[16:12:55.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.589]                     {
[16:12:55.589]                       inherits <- base::inherits
[16:12:55.589]                       invokeRestart <- base::invokeRestart
[16:12:55.589]                       is.null <- base::is.null
[16:12:55.589]                       muffled <- FALSE
[16:12:55.589]                       if (inherits(cond, "message")) {
[16:12:55.589]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:55.589]                         if (muffled) 
[16:12:55.589]                           invokeRestart("muffleMessage")
[16:12:55.589]                       }
[16:12:55.589]                       else if (inherits(cond, "warning")) {
[16:12:55.589]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:55.589]                         if (muffled) 
[16:12:55.589]                           invokeRestart("muffleWarning")
[16:12:55.589]                       }
[16:12:55.589]                       else if (inherits(cond, "condition")) {
[16:12:55.589]                         if (!is.null(pattern)) {
[16:12:55.589]                           computeRestarts <- base::computeRestarts
[16:12:55.589]                           grepl <- base::grepl
[16:12:55.589]                           restarts <- computeRestarts(cond)
[16:12:55.589]                           for (restart in restarts) {
[16:12:55.589]                             name <- restart$name
[16:12:55.589]                             if (is.null(name)) 
[16:12:55.589]                               next
[16:12:55.589]                             if (!grepl(pattern, name)) 
[16:12:55.589]                               next
[16:12:55.589]                             invokeRestart(restart)
[16:12:55.589]                             muffled <- TRUE
[16:12:55.589]                             break
[16:12:55.589]                           }
[16:12:55.589]                         }
[16:12:55.589]                       }
[16:12:55.589]                       invisible(muffled)
[16:12:55.589]                     }
[16:12:55.589]                     muffleCondition(cond, pattern = "^muffle")
[16:12:55.589]                   }
[16:12:55.589]                 }
[16:12:55.589]                 else {
[16:12:55.589]                   if (TRUE) {
[16:12:55.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.589]                     {
[16:12:55.589]                       inherits <- base::inherits
[16:12:55.589]                       invokeRestart <- base::invokeRestart
[16:12:55.589]                       is.null <- base::is.null
[16:12:55.589]                       muffled <- FALSE
[16:12:55.589]                       if (inherits(cond, "message")) {
[16:12:55.589]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:55.589]                         if (muffled) 
[16:12:55.589]                           invokeRestart("muffleMessage")
[16:12:55.589]                       }
[16:12:55.589]                       else if (inherits(cond, "warning")) {
[16:12:55.589]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:55.589]                         if (muffled) 
[16:12:55.589]                           invokeRestart("muffleWarning")
[16:12:55.589]                       }
[16:12:55.589]                       else if (inherits(cond, "condition")) {
[16:12:55.589]                         if (!is.null(pattern)) {
[16:12:55.589]                           computeRestarts <- base::computeRestarts
[16:12:55.589]                           grepl <- base::grepl
[16:12:55.589]                           restarts <- computeRestarts(cond)
[16:12:55.589]                           for (restart in restarts) {
[16:12:55.589]                             name <- restart$name
[16:12:55.589]                             if (is.null(name)) 
[16:12:55.589]                               next
[16:12:55.589]                             if (!grepl(pattern, name)) 
[16:12:55.589]                               next
[16:12:55.589]                             invokeRestart(restart)
[16:12:55.589]                             muffled <- TRUE
[16:12:55.589]                             break
[16:12:55.589]                           }
[16:12:55.589]                         }
[16:12:55.589]                       }
[16:12:55.589]                       invisible(muffled)
[16:12:55.589]                     }
[16:12:55.589]                     muffleCondition(cond, pattern = "^muffle")
[16:12:55.589]                   }
[16:12:55.589]                 }
[16:12:55.589]             }
[16:12:55.589]         }))
[16:12:55.589]     }, error = function(ex) {
[16:12:55.589]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:55.589]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:55.589]                 ...future.rng), started = ...future.startTime, 
[16:12:55.589]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:55.589]             version = "1.8"), class = "FutureResult")
[16:12:55.589]     }, finally = {
[16:12:55.589]         if (!identical(...future.workdir, getwd())) 
[16:12:55.589]             setwd(...future.workdir)
[16:12:55.589]         {
[16:12:55.589]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:55.589]                 ...future.oldOptions$nwarnings <- NULL
[16:12:55.589]             }
[16:12:55.589]             base::options(...future.oldOptions)
[16:12:55.589]             if (.Platform$OS.type == "windows") {
[16:12:55.589]                 old_names <- names(...future.oldEnvVars)
[16:12:55.589]                 envs <- base::Sys.getenv()
[16:12:55.589]                 names <- names(envs)
[16:12:55.589]                 common <- intersect(names, old_names)
[16:12:55.589]                 added <- setdiff(names, old_names)
[16:12:55.589]                 removed <- setdiff(old_names, names)
[16:12:55.589]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:55.589]                   envs[common]]
[16:12:55.589]                 NAMES <- toupper(changed)
[16:12:55.589]                 args <- list()
[16:12:55.589]                 for (kk in seq_along(NAMES)) {
[16:12:55.589]                   name <- changed[[kk]]
[16:12:55.589]                   NAME <- NAMES[[kk]]
[16:12:55.589]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.589]                     next
[16:12:55.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:55.589]                 }
[16:12:55.589]                 NAMES <- toupper(added)
[16:12:55.589]                 for (kk in seq_along(NAMES)) {
[16:12:55.589]                   name <- added[[kk]]
[16:12:55.589]                   NAME <- NAMES[[kk]]
[16:12:55.589]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.589]                     next
[16:12:55.589]                   args[[name]] <- ""
[16:12:55.589]                 }
[16:12:55.589]                 NAMES <- toupper(removed)
[16:12:55.589]                 for (kk in seq_along(NAMES)) {
[16:12:55.589]                   name <- removed[[kk]]
[16:12:55.589]                   NAME <- NAMES[[kk]]
[16:12:55.589]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.589]                     next
[16:12:55.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:55.589]                 }
[16:12:55.589]                 if (length(args) > 0) 
[16:12:55.589]                   base::do.call(base::Sys.setenv, args = args)
[16:12:55.589]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:55.589]             }
[16:12:55.589]             else {
[16:12:55.589]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:55.589]             }
[16:12:55.589]             {
[16:12:55.589]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:55.589]                   0L) {
[16:12:55.589]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:55.589]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:55.589]                   base::options(opts)
[16:12:55.589]                 }
[16:12:55.589]                 {
[16:12:55.589]                   {
[16:12:55.589]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:55.589]                     NULL
[16:12:55.589]                   }
[16:12:55.589]                   options(future.plan = NULL)
[16:12:55.589]                   if (is.na(NA_character_)) 
[16:12:55.589]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:55.589]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:55.589]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:55.589]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:55.589]                     envir = parent.frame()) 
[16:12:55.589]                   {
[16:12:55.589]                     if (is.function(workers)) 
[16:12:55.589]                       workers <- workers()
[16:12:55.589]                     workers <- structure(as.integer(workers), 
[16:12:55.589]                       class = class(workers))
[16:12:55.589]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:55.589]                       workers >= 1)
[16:12:55.589]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:55.589]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:55.589]                     }
[16:12:55.589]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:55.589]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:55.589]                       envir = envir)
[16:12:55.589]                     if (!future$lazy) 
[16:12:55.589]                       future <- run(future)
[16:12:55.589]                     invisible(future)
[16:12:55.589]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:55.589]                 }
[16:12:55.589]             }
[16:12:55.589]         }
[16:12:55.589]     })
[16:12:55.589]     if (TRUE) {
[16:12:55.589]         base::sink(type = "output", split = FALSE)
[16:12:55.589]         if (TRUE) {
[16:12:55.589]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:55.589]         }
[16:12:55.589]         else {
[16:12:55.589]             ...future.result["stdout"] <- base::list(NULL)
[16:12:55.589]         }
[16:12:55.589]         base::close(...future.stdout)
[16:12:55.589]         ...future.stdout <- NULL
[16:12:55.589]     }
[16:12:55.589]     ...future.result$conditions <- ...future.conditions
[16:12:55.589]     ...future.result$finished <- base::Sys.time()
[16:12:55.589]     ...future.result
[16:12:55.589] }
[16:12:55.593] MultisessionFuture started
[16:12:55.593] - Launch lazy future ... done
[16:12:55.593] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:55.593] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:55.593] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:55.594] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:55.594] Searching for globals ... DONE
[16:12:55.594] Resolving globals: TRUE
[16:12:55.595] Resolving any globals that are futures ...
[16:12:55.595] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:55.595] Resolving any globals that are futures ... DONE
[16:12:55.595] Resolving futures part of globals (recursively) ...
[16:12:55.595] resolve() on list ...
[16:12:55.595]  recursive: 99
[16:12:55.596]  length: 1
[16:12:55.596]  elements: ‘a’
[16:12:55.641] receiveMessageFromWorker() for ClusterFuture ...
[16:12:55.641] - Validating connection of MultisessionFuture
[16:12:55.642] - received message: FutureResult
[16:12:55.642] - Received FutureResult
[16:12:55.642] - Erased future from FutureRegistry
[16:12:55.642] result() for ClusterFuture ...
[16:12:55.642] - result already collected: FutureResult
[16:12:55.642] result() for ClusterFuture ... done
[16:12:55.642] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:55.642] Future #1
[16:12:55.643] result() for ClusterFuture ...
[16:12:55.643] - result already collected: FutureResult
[16:12:55.643] result() for ClusterFuture ... done
[16:12:55.643] result() for ClusterFuture ...
[16:12:55.643] - result already collected: FutureResult
[16:12:55.643] result() for ClusterFuture ... done
[16:12:55.643] A MultisessionFuture was resolved
[16:12:55.646]  length: 0 (resolved future 1)
[16:12:55.646] resolve() on list ... DONE
[16:12:55.646] - globals: [1] ‘a’
[16:12:55.646] Resolving futures part of globals (recursively) ... DONE
[16:12:55.648] The total size of the 1 globals is 1.55 MiB (1629496 bytes)
[16:12:55.648] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[16:12:55.649] - globals: [1] ‘a’
[16:12:55.649] - packages: [1] ‘future’
[16:12:55.649] getGlobalsAndPackages() ... DONE
[16:12:55.649] run() for ‘Future’ ...
[16:12:55.649] - state: ‘created’
[16:12:55.649] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:55.664] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:55.664] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:55.664]   - Field: ‘node’
[16:12:55.664]   - Field: ‘label’
[16:12:55.664]   - Field: ‘local’
[16:12:55.664]   - Field: ‘owner’
[16:12:55.664]   - Field: ‘envir’
[16:12:55.664]   - Field: ‘workers’
[16:12:55.665]   - Field: ‘packages’
[16:12:55.665]   - Field: ‘gc’
[16:12:55.665]   - Field: ‘conditions’
[16:12:55.665]   - Field: ‘persistent’
[16:12:55.665]   - Field: ‘expr’
[16:12:55.665]   - Field: ‘uuid’
[16:12:55.665]   - Field: ‘seed’
[16:12:55.665]   - Field: ‘version’
[16:12:55.665]   - Field: ‘result’
[16:12:55.665]   - Field: ‘asynchronous’
[16:12:55.665]   - Field: ‘calls’
[16:12:55.666]   - Field: ‘globals’
[16:12:55.666]   - Field: ‘stdout’
[16:12:55.666]   - Field: ‘earlySignal’
[16:12:55.666]   - Field: ‘lazy’
[16:12:55.666]   - Field: ‘state’
[16:12:55.666] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:55.666] - Launch lazy future ...
[16:12:55.666] Packages needed by the future expression (n = 1): ‘future’
[16:12:55.666] Packages needed by future strategies (n = 0): <none>
[16:12:55.667] {
[16:12:55.667]     {
[16:12:55.667]         {
[16:12:55.667]             ...future.startTime <- base::Sys.time()
[16:12:55.667]             {
[16:12:55.667]                 {
[16:12:55.667]                   {
[16:12:55.667]                     {
[16:12:55.667]                       {
[16:12:55.667]                         base::local({
[16:12:55.667]                           has_future <- base::requireNamespace("future", 
[16:12:55.667]                             quietly = TRUE)
[16:12:55.667]                           if (has_future) {
[16:12:55.667]                             ns <- base::getNamespace("future")
[16:12:55.667]                             version <- ns[[".package"]][["version"]]
[16:12:55.667]                             if (is.null(version)) 
[16:12:55.667]                               version <- utils::packageVersion("future")
[16:12:55.667]                           }
[16:12:55.667]                           else {
[16:12:55.667]                             version <- NULL
[16:12:55.667]                           }
[16:12:55.667]                           if (!has_future || version < "1.8.0") {
[16:12:55.667]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:55.667]                               "", base::R.version$version.string), 
[16:12:55.667]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:55.667]                                 base::R.version$platform, 8 * 
[16:12:55.667]                                   base::.Machine$sizeof.pointer), 
[16:12:55.667]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:55.667]                                 "release", "version")], collapse = " "), 
[16:12:55.667]                               hostname = base::Sys.info()[["nodename"]])
[16:12:55.667]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:55.667]                               info)
[16:12:55.667]                             info <- base::paste(info, collapse = "; ")
[16:12:55.667]                             if (!has_future) {
[16:12:55.667]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:55.667]                                 info)
[16:12:55.667]                             }
[16:12:55.667]                             else {
[16:12:55.667]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:55.667]                                 info, version)
[16:12:55.667]                             }
[16:12:55.667]                             base::stop(msg)
[16:12:55.667]                           }
[16:12:55.667]                         })
[16:12:55.667]                       }
[16:12:55.667]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:55.667]                       base::options(mc.cores = 1L)
[16:12:55.667]                     }
[16:12:55.667]                     base::local({
[16:12:55.667]                       for (pkg in "future") {
[16:12:55.667]                         base::loadNamespace(pkg)
[16:12:55.667]                         base::library(pkg, character.only = TRUE)
[16:12:55.667]                       }
[16:12:55.667]                     })
[16:12:55.667]                   }
[16:12:55.667]                   options(future.plan = NULL)
[16:12:55.667]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:55.667]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:55.667]                 }
[16:12:55.667]                 ...future.workdir <- getwd()
[16:12:55.667]             }
[16:12:55.667]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:55.667]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:55.667]         }
[16:12:55.667]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:55.667]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:55.667]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:55.667]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:55.667]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:55.667]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:55.667]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:55.667]             base::names(...future.oldOptions))
[16:12:55.667]     }
[16:12:55.667]     if (FALSE) {
[16:12:55.667]     }
[16:12:55.667]     else {
[16:12:55.667]         if (TRUE) {
[16:12:55.667]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:55.667]                 open = "w")
[16:12:55.667]         }
[16:12:55.667]         else {
[16:12:55.667]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:55.667]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:55.667]         }
[16:12:55.667]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:55.667]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:55.667]             base::sink(type = "output", split = FALSE)
[16:12:55.667]             base::close(...future.stdout)
[16:12:55.667]         }, add = TRUE)
[16:12:55.667]     }
[16:12:55.667]     ...future.frame <- base::sys.nframe()
[16:12:55.667]     ...future.conditions <- base::list()
[16:12:55.667]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:55.667]     if (FALSE) {
[16:12:55.667]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:55.667]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:55.667]     }
[16:12:55.667]     ...future.result <- base::tryCatch({
[16:12:55.667]         base::withCallingHandlers({
[16:12:55.667]             ...future.value <- base::withVisible(base::local({
[16:12:55.667]                 ...future.makeSendCondition <- local({
[16:12:55.667]                   sendCondition <- NULL
[16:12:55.667]                   function(frame = 1L) {
[16:12:55.667]                     if (is.function(sendCondition)) 
[16:12:55.667]                       return(sendCondition)
[16:12:55.667]                     ns <- getNamespace("parallel")
[16:12:55.667]                     if (exists("sendData", mode = "function", 
[16:12:55.667]                       envir = ns)) {
[16:12:55.667]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:55.667]                         envir = ns)
[16:12:55.667]                       envir <- sys.frame(frame)
[16:12:55.667]                       master <- NULL
[16:12:55.667]                       while (!identical(envir, .GlobalEnv) && 
[16:12:55.667]                         !identical(envir, emptyenv())) {
[16:12:55.667]                         if (exists("master", mode = "list", envir = envir, 
[16:12:55.667]                           inherits = FALSE)) {
[16:12:55.667]                           master <- get("master", mode = "list", 
[16:12:55.667]                             envir = envir, inherits = FALSE)
[16:12:55.667]                           if (inherits(master, c("SOCKnode", 
[16:12:55.667]                             "SOCK0node"))) {
[16:12:55.667]                             sendCondition <<- function(cond) {
[16:12:55.667]                               data <- list(type = "VALUE", value = cond, 
[16:12:55.667]                                 success = TRUE)
[16:12:55.667]                               parallel_sendData(master, data)
[16:12:55.667]                             }
[16:12:55.667]                             return(sendCondition)
[16:12:55.667]                           }
[16:12:55.667]                         }
[16:12:55.667]                         frame <- frame + 1L
[16:12:55.667]                         envir <- sys.frame(frame)
[16:12:55.667]                       }
[16:12:55.667]                     }
[16:12:55.667]                     sendCondition <<- function(cond) NULL
[16:12:55.667]                   }
[16:12:55.667]                 })
[16:12:55.667]                 withCallingHandlers({
[16:12:55.667]                   value(a) + 1
[16:12:55.667]                 }, immediateCondition = function(cond) {
[16:12:55.667]                   sendCondition <- ...future.makeSendCondition()
[16:12:55.667]                   sendCondition(cond)
[16:12:55.667]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.667]                   {
[16:12:55.667]                     inherits <- base::inherits
[16:12:55.667]                     invokeRestart <- base::invokeRestart
[16:12:55.667]                     is.null <- base::is.null
[16:12:55.667]                     muffled <- FALSE
[16:12:55.667]                     if (inherits(cond, "message")) {
[16:12:55.667]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:55.667]                       if (muffled) 
[16:12:55.667]                         invokeRestart("muffleMessage")
[16:12:55.667]                     }
[16:12:55.667]                     else if (inherits(cond, "warning")) {
[16:12:55.667]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:55.667]                       if (muffled) 
[16:12:55.667]                         invokeRestart("muffleWarning")
[16:12:55.667]                     }
[16:12:55.667]                     else if (inherits(cond, "condition")) {
[16:12:55.667]                       if (!is.null(pattern)) {
[16:12:55.667]                         computeRestarts <- base::computeRestarts
[16:12:55.667]                         grepl <- base::grepl
[16:12:55.667]                         restarts <- computeRestarts(cond)
[16:12:55.667]                         for (restart in restarts) {
[16:12:55.667]                           name <- restart$name
[16:12:55.667]                           if (is.null(name)) 
[16:12:55.667]                             next
[16:12:55.667]                           if (!grepl(pattern, name)) 
[16:12:55.667]                             next
[16:12:55.667]                           invokeRestart(restart)
[16:12:55.667]                           muffled <- TRUE
[16:12:55.667]                           break
[16:12:55.667]                         }
[16:12:55.667]                       }
[16:12:55.667]                     }
[16:12:55.667]                     invisible(muffled)
[16:12:55.667]                   }
[16:12:55.667]                   muffleCondition(cond)
[16:12:55.667]                 })
[16:12:55.667]             }))
[16:12:55.667]             future::FutureResult(value = ...future.value$value, 
[16:12:55.667]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:55.667]                   ...future.rng), globalenv = if (FALSE) 
[16:12:55.667]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:55.667]                     ...future.globalenv.names))
[16:12:55.667]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:55.667]         }, condition = base::local({
[16:12:55.667]             c <- base::c
[16:12:55.667]             inherits <- base::inherits
[16:12:55.667]             invokeRestart <- base::invokeRestart
[16:12:55.667]             length <- base::length
[16:12:55.667]             list <- base::list
[16:12:55.667]             seq.int <- base::seq.int
[16:12:55.667]             signalCondition <- base::signalCondition
[16:12:55.667]             sys.calls <- base::sys.calls
[16:12:55.667]             `[[` <- base::`[[`
[16:12:55.667]             `+` <- base::`+`
[16:12:55.667]             `<<-` <- base::`<<-`
[16:12:55.667]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:55.667]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:55.667]                   3L)]
[16:12:55.667]             }
[16:12:55.667]             function(cond) {
[16:12:55.667]                 is_error <- inherits(cond, "error")
[16:12:55.667]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:55.667]                   NULL)
[16:12:55.667]                 if (is_error) {
[16:12:55.667]                   sessionInformation <- function() {
[16:12:55.667]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:55.667]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:55.667]                       search = base::search(), system = base::Sys.info())
[16:12:55.667]                   }
[16:12:55.667]                   ...future.conditions[[length(...future.conditions) + 
[16:12:55.667]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:55.667]                     cond$call), session = sessionInformation(), 
[16:12:55.667]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:55.667]                   signalCondition(cond)
[16:12:55.667]                 }
[16:12:55.667]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:55.667]                 "immediateCondition"))) {
[16:12:55.667]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:55.667]                   ...future.conditions[[length(...future.conditions) + 
[16:12:55.667]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:55.667]                   if (TRUE && !signal) {
[16:12:55.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.667]                     {
[16:12:55.667]                       inherits <- base::inherits
[16:12:55.667]                       invokeRestart <- base::invokeRestart
[16:12:55.667]                       is.null <- base::is.null
[16:12:55.667]                       muffled <- FALSE
[16:12:55.667]                       if (inherits(cond, "message")) {
[16:12:55.667]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:55.667]                         if (muffled) 
[16:12:55.667]                           invokeRestart("muffleMessage")
[16:12:55.667]                       }
[16:12:55.667]                       else if (inherits(cond, "warning")) {
[16:12:55.667]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:55.667]                         if (muffled) 
[16:12:55.667]                           invokeRestart("muffleWarning")
[16:12:55.667]                       }
[16:12:55.667]                       else if (inherits(cond, "condition")) {
[16:12:55.667]                         if (!is.null(pattern)) {
[16:12:55.667]                           computeRestarts <- base::computeRestarts
[16:12:55.667]                           grepl <- base::grepl
[16:12:55.667]                           restarts <- computeRestarts(cond)
[16:12:55.667]                           for (restart in restarts) {
[16:12:55.667]                             name <- restart$name
[16:12:55.667]                             if (is.null(name)) 
[16:12:55.667]                               next
[16:12:55.667]                             if (!grepl(pattern, name)) 
[16:12:55.667]                               next
[16:12:55.667]                             invokeRestart(restart)
[16:12:55.667]                             muffled <- TRUE
[16:12:55.667]                             break
[16:12:55.667]                           }
[16:12:55.667]                         }
[16:12:55.667]                       }
[16:12:55.667]                       invisible(muffled)
[16:12:55.667]                     }
[16:12:55.667]                     muffleCondition(cond, pattern = "^muffle")
[16:12:55.667]                   }
[16:12:55.667]                 }
[16:12:55.667]                 else {
[16:12:55.667]                   if (TRUE) {
[16:12:55.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.667]                     {
[16:12:55.667]                       inherits <- base::inherits
[16:12:55.667]                       invokeRestart <- base::invokeRestart
[16:12:55.667]                       is.null <- base::is.null
[16:12:55.667]                       muffled <- FALSE
[16:12:55.667]                       if (inherits(cond, "message")) {
[16:12:55.667]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:55.667]                         if (muffled) 
[16:12:55.667]                           invokeRestart("muffleMessage")
[16:12:55.667]                       }
[16:12:55.667]                       else if (inherits(cond, "warning")) {
[16:12:55.667]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:55.667]                         if (muffled) 
[16:12:55.667]                           invokeRestart("muffleWarning")
[16:12:55.667]                       }
[16:12:55.667]                       else if (inherits(cond, "condition")) {
[16:12:55.667]                         if (!is.null(pattern)) {
[16:12:55.667]                           computeRestarts <- base::computeRestarts
[16:12:55.667]                           grepl <- base::grepl
[16:12:55.667]                           restarts <- computeRestarts(cond)
[16:12:55.667]                           for (restart in restarts) {
[16:12:55.667]                             name <- restart$name
[16:12:55.667]                             if (is.null(name)) 
[16:12:55.667]                               next
[16:12:55.667]                             if (!grepl(pattern, name)) 
[16:12:55.667]                               next
[16:12:55.667]                             invokeRestart(restart)
[16:12:55.667]                             muffled <- TRUE
[16:12:55.667]                             break
[16:12:55.667]                           }
[16:12:55.667]                         }
[16:12:55.667]                       }
[16:12:55.667]                       invisible(muffled)
[16:12:55.667]                     }
[16:12:55.667]                     muffleCondition(cond, pattern = "^muffle")
[16:12:55.667]                   }
[16:12:55.667]                 }
[16:12:55.667]             }
[16:12:55.667]         }))
[16:12:55.667]     }, error = function(ex) {
[16:12:55.667]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:55.667]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:55.667]                 ...future.rng), started = ...future.startTime, 
[16:12:55.667]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:55.667]             version = "1.8"), class = "FutureResult")
[16:12:55.667]     }, finally = {
[16:12:55.667]         if (!identical(...future.workdir, getwd())) 
[16:12:55.667]             setwd(...future.workdir)
[16:12:55.667]         {
[16:12:55.667]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:55.667]                 ...future.oldOptions$nwarnings <- NULL
[16:12:55.667]             }
[16:12:55.667]             base::options(...future.oldOptions)
[16:12:55.667]             if (.Platform$OS.type == "windows") {
[16:12:55.667]                 old_names <- names(...future.oldEnvVars)
[16:12:55.667]                 envs <- base::Sys.getenv()
[16:12:55.667]                 names <- names(envs)
[16:12:55.667]                 common <- intersect(names, old_names)
[16:12:55.667]                 added <- setdiff(names, old_names)
[16:12:55.667]                 removed <- setdiff(old_names, names)
[16:12:55.667]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:55.667]                   envs[common]]
[16:12:55.667]                 NAMES <- toupper(changed)
[16:12:55.667]                 args <- list()
[16:12:55.667]                 for (kk in seq_along(NAMES)) {
[16:12:55.667]                   name <- changed[[kk]]
[16:12:55.667]                   NAME <- NAMES[[kk]]
[16:12:55.667]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.667]                     next
[16:12:55.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:55.667]                 }
[16:12:55.667]                 NAMES <- toupper(added)
[16:12:55.667]                 for (kk in seq_along(NAMES)) {
[16:12:55.667]                   name <- added[[kk]]
[16:12:55.667]                   NAME <- NAMES[[kk]]
[16:12:55.667]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.667]                     next
[16:12:55.667]                   args[[name]] <- ""
[16:12:55.667]                 }
[16:12:55.667]                 NAMES <- toupper(removed)
[16:12:55.667]                 for (kk in seq_along(NAMES)) {
[16:12:55.667]                   name <- removed[[kk]]
[16:12:55.667]                   NAME <- NAMES[[kk]]
[16:12:55.667]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.667]                     next
[16:12:55.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:55.667]                 }
[16:12:55.667]                 if (length(args) > 0) 
[16:12:55.667]                   base::do.call(base::Sys.setenv, args = args)
[16:12:55.667]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:55.667]             }
[16:12:55.667]             else {
[16:12:55.667]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:55.667]             }
[16:12:55.667]             {
[16:12:55.667]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:55.667]                   0L) {
[16:12:55.667]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:55.667]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:55.667]                   base::options(opts)
[16:12:55.667]                 }
[16:12:55.667]                 {
[16:12:55.667]                   {
[16:12:55.667]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:55.667]                     NULL
[16:12:55.667]                   }
[16:12:55.667]                   options(future.plan = NULL)
[16:12:55.667]                   if (is.na(NA_character_)) 
[16:12:55.667]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:55.667]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:55.667]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:55.667]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:55.667]                     envir = parent.frame()) 
[16:12:55.667]                   {
[16:12:55.667]                     if (is.function(workers)) 
[16:12:55.667]                       workers <- workers()
[16:12:55.667]                     workers <- structure(as.integer(workers), 
[16:12:55.667]                       class = class(workers))
[16:12:55.667]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:55.667]                       workers >= 1)
[16:12:55.667]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:55.667]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:55.667]                     }
[16:12:55.667]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:55.667]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:55.667]                       envir = envir)
[16:12:55.667]                     if (!future$lazy) 
[16:12:55.667]                       future <- run(future)
[16:12:55.667]                     invisible(future)
[16:12:55.667]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:55.667]                 }
[16:12:55.667]             }
[16:12:55.667]         }
[16:12:55.667]     })
[16:12:55.667]     if (TRUE) {
[16:12:55.667]         base::sink(type = "output", split = FALSE)
[16:12:55.667]         if (TRUE) {
[16:12:55.667]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:55.667]         }
[16:12:55.667]         else {
[16:12:55.667]             ...future.result["stdout"] <- base::list(NULL)
[16:12:55.667]         }
[16:12:55.667]         base::close(...future.stdout)
[16:12:55.667]         ...future.stdout <- NULL
[16:12:55.667]     }
[16:12:55.667]     ...future.result$conditions <- ...future.conditions
[16:12:55.667]     ...future.result$finished <- base::Sys.time()
[16:12:55.667]     ...future.result
[16:12:55.667] }
[16:12:55.670] Exporting 1 global objects (1.55 MiB) to cluster node #1 ...
[16:12:55.672] Exporting ‘a’ (1.55 MiB) to cluster node #1 ...
[16:12:55.724] Exporting ‘a’ (1.55 MiB) to cluster node #1 ... DONE
[16:12:55.724] Exporting 1 global objects (1.55 MiB) to cluster node #1 ... DONE
[16:12:55.725] MultisessionFuture started
[16:12:55.725] - Launch lazy future ... done
[16:12:55.725] run() for ‘MultisessionFuture’ ... done
[16:12:55.725] result() for ClusterFuture ...
[16:12:55.725] receiveMessageFromWorker() for ClusterFuture ...
[16:12:55.726] - Validating connection of MultisessionFuture
[16:12:55.773] - received message: FutureResult
[16:12:55.774] - Received FutureResult
[16:12:55.774] - Erased future from FutureRegistry
[16:12:55.774] result() for ClusterFuture ...
[16:12:55.774] - result already collected: FutureResult
[16:12:55.774] result() for ClusterFuture ... done
[16:12:55.774] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:55.774] result() for ClusterFuture ... done
[16:12:55.774] result() for ClusterFuture ...
[16:12:55.775] - result already collected: FutureResult
[16:12:55.775] result() for ClusterFuture ... done
value(b) = 2
[16:12:55.775] result() for ClusterFuture ...
[16:12:55.775] - result already collected: FutureResult
[16:12:55.775] result() for ClusterFuture ... done
[16:12:55.775] result() for ClusterFuture ...
[16:12:55.775] - result already collected: FutureResult
[16:12:55.775] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:55.776] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:55.776] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:55.776] 
[16:12:55.776] Searching for globals ... DONE
[16:12:55.776] - globals: [0] <none>
[16:12:55.777] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:55.777] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:55.777] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:55.778] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:55.778] Searching for globals ... DONE
[16:12:55.778] Resolving globals: TRUE
[16:12:55.778] Resolving any globals that are futures ...
[16:12:55.778] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:55.778] Resolving any globals that are futures ... DONE
[16:12:55.779] Resolving futures part of globals (recursively) ...
[16:12:55.779] resolve() on list ...
[16:12:55.779]  recursive: 99
[16:12:55.779]  length: 1
[16:12:55.779]  elements: ‘a’
[16:12:55.779] run() for ‘Future’ ...
[16:12:55.779] - state: ‘created’
[16:12:55.779] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:55.795] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:55.795] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:55.796]   - Field: ‘node’
[16:12:55.796]   - Field: ‘label’
[16:12:55.796]   - Field: ‘local’
[16:12:55.796]   - Field: ‘owner’
[16:12:55.796]   - Field: ‘envir’
[16:12:55.796]   - Field: ‘workers’
[16:12:55.796]   - Field: ‘packages’
[16:12:55.796]   - Field: ‘gc’
[16:12:55.796]   - Field: ‘conditions’
[16:12:55.796]   - Field: ‘persistent’
[16:12:55.797]   - Field: ‘expr’
[16:12:55.797]   - Field: ‘uuid’
[16:12:55.797]   - Field: ‘seed’
[16:12:55.797]   - Field: ‘version’
[16:12:55.797]   - Field: ‘result’
[16:12:55.797]   - Field: ‘asynchronous’
[16:12:55.797]   - Field: ‘calls’
[16:12:55.797]   - Field: ‘globals’
[16:12:55.797]   - Field: ‘stdout’
[16:12:55.797]   - Field: ‘earlySignal’
[16:12:55.797]   - Field: ‘lazy’
[16:12:55.798]   - Field: ‘state’
[16:12:55.798] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:55.798] - Launch lazy future ...
[16:12:55.798] Packages needed by the future expression (n = 0): <none>
[16:12:55.798] Packages needed by future strategies (n = 0): <none>
[16:12:55.799] {
[16:12:55.799]     {
[16:12:55.799]         {
[16:12:55.799]             ...future.startTime <- base::Sys.time()
[16:12:55.799]             {
[16:12:55.799]                 {
[16:12:55.799]                   {
[16:12:55.799]                     {
[16:12:55.799]                       base::local({
[16:12:55.799]                         has_future <- base::requireNamespace("future", 
[16:12:55.799]                           quietly = TRUE)
[16:12:55.799]                         if (has_future) {
[16:12:55.799]                           ns <- base::getNamespace("future")
[16:12:55.799]                           version <- ns[[".package"]][["version"]]
[16:12:55.799]                           if (is.null(version)) 
[16:12:55.799]                             version <- utils::packageVersion("future")
[16:12:55.799]                         }
[16:12:55.799]                         else {
[16:12:55.799]                           version <- NULL
[16:12:55.799]                         }
[16:12:55.799]                         if (!has_future || version < "1.8.0") {
[16:12:55.799]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:55.799]                             "", base::R.version$version.string), 
[16:12:55.799]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:55.799]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:55.799]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:55.799]                               "release", "version")], collapse = " "), 
[16:12:55.799]                             hostname = base::Sys.info()[["nodename"]])
[16:12:55.799]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:55.799]                             info)
[16:12:55.799]                           info <- base::paste(info, collapse = "; ")
[16:12:55.799]                           if (!has_future) {
[16:12:55.799]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:55.799]                               info)
[16:12:55.799]                           }
[16:12:55.799]                           else {
[16:12:55.799]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:55.799]                               info, version)
[16:12:55.799]                           }
[16:12:55.799]                           base::stop(msg)
[16:12:55.799]                         }
[16:12:55.799]                       })
[16:12:55.799]                     }
[16:12:55.799]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:55.799]                     base::options(mc.cores = 1L)
[16:12:55.799]                   }
[16:12:55.799]                   options(future.plan = NULL)
[16:12:55.799]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:55.799]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:55.799]                 }
[16:12:55.799]                 ...future.workdir <- getwd()
[16:12:55.799]             }
[16:12:55.799]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:55.799]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:55.799]         }
[16:12:55.799]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:55.799]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:55.799]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:55.799]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:55.799]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:55.799]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:55.799]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:55.799]             base::names(...future.oldOptions))
[16:12:55.799]     }
[16:12:55.799]     if (FALSE) {
[16:12:55.799]     }
[16:12:55.799]     else {
[16:12:55.799]         if (TRUE) {
[16:12:55.799]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:55.799]                 open = "w")
[16:12:55.799]         }
[16:12:55.799]         else {
[16:12:55.799]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:55.799]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:55.799]         }
[16:12:55.799]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:55.799]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:55.799]             base::sink(type = "output", split = FALSE)
[16:12:55.799]             base::close(...future.stdout)
[16:12:55.799]         }, add = TRUE)
[16:12:55.799]     }
[16:12:55.799]     ...future.frame <- base::sys.nframe()
[16:12:55.799]     ...future.conditions <- base::list()
[16:12:55.799]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:55.799]     if (FALSE) {
[16:12:55.799]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:55.799]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:55.799]     }
[16:12:55.799]     ...future.result <- base::tryCatch({
[16:12:55.799]         base::withCallingHandlers({
[16:12:55.799]             ...future.value <- base::withVisible(base::local({
[16:12:55.799]                 ...future.makeSendCondition <- local({
[16:12:55.799]                   sendCondition <- NULL
[16:12:55.799]                   function(frame = 1L) {
[16:12:55.799]                     if (is.function(sendCondition)) 
[16:12:55.799]                       return(sendCondition)
[16:12:55.799]                     ns <- getNamespace("parallel")
[16:12:55.799]                     if (exists("sendData", mode = "function", 
[16:12:55.799]                       envir = ns)) {
[16:12:55.799]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:55.799]                         envir = ns)
[16:12:55.799]                       envir <- sys.frame(frame)
[16:12:55.799]                       master <- NULL
[16:12:55.799]                       while (!identical(envir, .GlobalEnv) && 
[16:12:55.799]                         !identical(envir, emptyenv())) {
[16:12:55.799]                         if (exists("master", mode = "list", envir = envir, 
[16:12:55.799]                           inherits = FALSE)) {
[16:12:55.799]                           master <- get("master", mode = "list", 
[16:12:55.799]                             envir = envir, inherits = FALSE)
[16:12:55.799]                           if (inherits(master, c("SOCKnode", 
[16:12:55.799]                             "SOCK0node"))) {
[16:12:55.799]                             sendCondition <<- function(cond) {
[16:12:55.799]                               data <- list(type = "VALUE", value = cond, 
[16:12:55.799]                                 success = TRUE)
[16:12:55.799]                               parallel_sendData(master, data)
[16:12:55.799]                             }
[16:12:55.799]                             return(sendCondition)
[16:12:55.799]                           }
[16:12:55.799]                         }
[16:12:55.799]                         frame <- frame + 1L
[16:12:55.799]                         envir <- sys.frame(frame)
[16:12:55.799]                       }
[16:12:55.799]                     }
[16:12:55.799]                     sendCondition <<- function(cond) NULL
[16:12:55.799]                   }
[16:12:55.799]                 })
[16:12:55.799]                 withCallingHandlers({
[16:12:55.799]                   1
[16:12:55.799]                 }, immediateCondition = function(cond) {
[16:12:55.799]                   sendCondition <- ...future.makeSendCondition()
[16:12:55.799]                   sendCondition(cond)
[16:12:55.799]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.799]                   {
[16:12:55.799]                     inherits <- base::inherits
[16:12:55.799]                     invokeRestart <- base::invokeRestart
[16:12:55.799]                     is.null <- base::is.null
[16:12:55.799]                     muffled <- FALSE
[16:12:55.799]                     if (inherits(cond, "message")) {
[16:12:55.799]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:55.799]                       if (muffled) 
[16:12:55.799]                         invokeRestart("muffleMessage")
[16:12:55.799]                     }
[16:12:55.799]                     else if (inherits(cond, "warning")) {
[16:12:55.799]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:55.799]                       if (muffled) 
[16:12:55.799]                         invokeRestart("muffleWarning")
[16:12:55.799]                     }
[16:12:55.799]                     else if (inherits(cond, "condition")) {
[16:12:55.799]                       if (!is.null(pattern)) {
[16:12:55.799]                         computeRestarts <- base::computeRestarts
[16:12:55.799]                         grepl <- base::grepl
[16:12:55.799]                         restarts <- computeRestarts(cond)
[16:12:55.799]                         for (restart in restarts) {
[16:12:55.799]                           name <- restart$name
[16:12:55.799]                           if (is.null(name)) 
[16:12:55.799]                             next
[16:12:55.799]                           if (!grepl(pattern, name)) 
[16:12:55.799]                             next
[16:12:55.799]                           invokeRestart(restart)
[16:12:55.799]                           muffled <- TRUE
[16:12:55.799]                           break
[16:12:55.799]                         }
[16:12:55.799]                       }
[16:12:55.799]                     }
[16:12:55.799]                     invisible(muffled)
[16:12:55.799]                   }
[16:12:55.799]                   muffleCondition(cond)
[16:12:55.799]                 })
[16:12:55.799]             }))
[16:12:55.799]             future::FutureResult(value = ...future.value$value, 
[16:12:55.799]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:55.799]                   ...future.rng), globalenv = if (FALSE) 
[16:12:55.799]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:55.799]                     ...future.globalenv.names))
[16:12:55.799]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:55.799]         }, condition = base::local({
[16:12:55.799]             c <- base::c
[16:12:55.799]             inherits <- base::inherits
[16:12:55.799]             invokeRestart <- base::invokeRestart
[16:12:55.799]             length <- base::length
[16:12:55.799]             list <- base::list
[16:12:55.799]             seq.int <- base::seq.int
[16:12:55.799]             signalCondition <- base::signalCondition
[16:12:55.799]             sys.calls <- base::sys.calls
[16:12:55.799]             `[[` <- base::`[[`
[16:12:55.799]             `+` <- base::`+`
[16:12:55.799]             `<<-` <- base::`<<-`
[16:12:55.799]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:55.799]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:55.799]                   3L)]
[16:12:55.799]             }
[16:12:55.799]             function(cond) {
[16:12:55.799]                 is_error <- inherits(cond, "error")
[16:12:55.799]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:55.799]                   NULL)
[16:12:55.799]                 if (is_error) {
[16:12:55.799]                   sessionInformation <- function() {
[16:12:55.799]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:55.799]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:55.799]                       search = base::search(), system = base::Sys.info())
[16:12:55.799]                   }
[16:12:55.799]                   ...future.conditions[[length(...future.conditions) + 
[16:12:55.799]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:55.799]                     cond$call), session = sessionInformation(), 
[16:12:55.799]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:55.799]                   signalCondition(cond)
[16:12:55.799]                 }
[16:12:55.799]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:55.799]                 "immediateCondition"))) {
[16:12:55.799]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:55.799]                   ...future.conditions[[length(...future.conditions) + 
[16:12:55.799]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:55.799]                   if (TRUE && !signal) {
[16:12:55.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.799]                     {
[16:12:55.799]                       inherits <- base::inherits
[16:12:55.799]                       invokeRestart <- base::invokeRestart
[16:12:55.799]                       is.null <- base::is.null
[16:12:55.799]                       muffled <- FALSE
[16:12:55.799]                       if (inherits(cond, "message")) {
[16:12:55.799]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:55.799]                         if (muffled) 
[16:12:55.799]                           invokeRestart("muffleMessage")
[16:12:55.799]                       }
[16:12:55.799]                       else if (inherits(cond, "warning")) {
[16:12:55.799]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:55.799]                         if (muffled) 
[16:12:55.799]                           invokeRestart("muffleWarning")
[16:12:55.799]                       }
[16:12:55.799]                       else if (inherits(cond, "condition")) {
[16:12:55.799]                         if (!is.null(pattern)) {
[16:12:55.799]                           computeRestarts <- base::computeRestarts
[16:12:55.799]                           grepl <- base::grepl
[16:12:55.799]                           restarts <- computeRestarts(cond)
[16:12:55.799]                           for (restart in restarts) {
[16:12:55.799]                             name <- restart$name
[16:12:55.799]                             if (is.null(name)) 
[16:12:55.799]                               next
[16:12:55.799]                             if (!grepl(pattern, name)) 
[16:12:55.799]                               next
[16:12:55.799]                             invokeRestart(restart)
[16:12:55.799]                             muffled <- TRUE
[16:12:55.799]                             break
[16:12:55.799]                           }
[16:12:55.799]                         }
[16:12:55.799]                       }
[16:12:55.799]                       invisible(muffled)
[16:12:55.799]                     }
[16:12:55.799]                     muffleCondition(cond, pattern = "^muffle")
[16:12:55.799]                   }
[16:12:55.799]                 }
[16:12:55.799]                 else {
[16:12:55.799]                   if (TRUE) {
[16:12:55.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.799]                     {
[16:12:55.799]                       inherits <- base::inherits
[16:12:55.799]                       invokeRestart <- base::invokeRestart
[16:12:55.799]                       is.null <- base::is.null
[16:12:55.799]                       muffled <- FALSE
[16:12:55.799]                       if (inherits(cond, "message")) {
[16:12:55.799]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:55.799]                         if (muffled) 
[16:12:55.799]                           invokeRestart("muffleMessage")
[16:12:55.799]                       }
[16:12:55.799]                       else if (inherits(cond, "warning")) {
[16:12:55.799]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:55.799]                         if (muffled) 
[16:12:55.799]                           invokeRestart("muffleWarning")
[16:12:55.799]                       }
[16:12:55.799]                       else if (inherits(cond, "condition")) {
[16:12:55.799]                         if (!is.null(pattern)) {
[16:12:55.799]                           computeRestarts <- base::computeRestarts
[16:12:55.799]                           grepl <- base::grepl
[16:12:55.799]                           restarts <- computeRestarts(cond)
[16:12:55.799]                           for (restart in restarts) {
[16:12:55.799]                             name <- restart$name
[16:12:55.799]                             if (is.null(name)) 
[16:12:55.799]                               next
[16:12:55.799]                             if (!grepl(pattern, name)) 
[16:12:55.799]                               next
[16:12:55.799]                             invokeRestart(restart)
[16:12:55.799]                             muffled <- TRUE
[16:12:55.799]                             break
[16:12:55.799]                           }
[16:12:55.799]                         }
[16:12:55.799]                       }
[16:12:55.799]                       invisible(muffled)
[16:12:55.799]                     }
[16:12:55.799]                     muffleCondition(cond, pattern = "^muffle")
[16:12:55.799]                   }
[16:12:55.799]                 }
[16:12:55.799]             }
[16:12:55.799]         }))
[16:12:55.799]     }, error = function(ex) {
[16:12:55.799]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:55.799]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:55.799]                 ...future.rng), started = ...future.startTime, 
[16:12:55.799]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:55.799]             version = "1.8"), class = "FutureResult")
[16:12:55.799]     }, finally = {
[16:12:55.799]         if (!identical(...future.workdir, getwd())) 
[16:12:55.799]             setwd(...future.workdir)
[16:12:55.799]         {
[16:12:55.799]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:55.799]                 ...future.oldOptions$nwarnings <- NULL
[16:12:55.799]             }
[16:12:55.799]             base::options(...future.oldOptions)
[16:12:55.799]             if (.Platform$OS.type == "windows") {
[16:12:55.799]                 old_names <- names(...future.oldEnvVars)
[16:12:55.799]                 envs <- base::Sys.getenv()
[16:12:55.799]                 names <- names(envs)
[16:12:55.799]                 common <- intersect(names, old_names)
[16:12:55.799]                 added <- setdiff(names, old_names)
[16:12:55.799]                 removed <- setdiff(old_names, names)
[16:12:55.799]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:55.799]                   envs[common]]
[16:12:55.799]                 NAMES <- toupper(changed)
[16:12:55.799]                 args <- list()
[16:12:55.799]                 for (kk in seq_along(NAMES)) {
[16:12:55.799]                   name <- changed[[kk]]
[16:12:55.799]                   NAME <- NAMES[[kk]]
[16:12:55.799]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.799]                     next
[16:12:55.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:55.799]                 }
[16:12:55.799]                 NAMES <- toupper(added)
[16:12:55.799]                 for (kk in seq_along(NAMES)) {
[16:12:55.799]                   name <- added[[kk]]
[16:12:55.799]                   NAME <- NAMES[[kk]]
[16:12:55.799]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.799]                     next
[16:12:55.799]                   args[[name]] <- ""
[16:12:55.799]                 }
[16:12:55.799]                 NAMES <- toupper(removed)
[16:12:55.799]                 for (kk in seq_along(NAMES)) {
[16:12:55.799]                   name <- removed[[kk]]
[16:12:55.799]                   NAME <- NAMES[[kk]]
[16:12:55.799]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.799]                     next
[16:12:55.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:55.799]                 }
[16:12:55.799]                 if (length(args) > 0) 
[16:12:55.799]                   base::do.call(base::Sys.setenv, args = args)
[16:12:55.799]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:55.799]             }
[16:12:55.799]             else {
[16:12:55.799]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:55.799]             }
[16:12:55.799]             {
[16:12:55.799]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:55.799]                   0L) {
[16:12:55.799]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:55.799]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:55.799]                   base::options(opts)
[16:12:55.799]                 }
[16:12:55.799]                 {
[16:12:55.799]                   {
[16:12:55.799]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:55.799]                     NULL
[16:12:55.799]                   }
[16:12:55.799]                   options(future.plan = NULL)
[16:12:55.799]                   if (is.na(NA_character_)) 
[16:12:55.799]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:55.799]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:55.799]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:55.799]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:55.799]                     envir = parent.frame()) 
[16:12:55.799]                   {
[16:12:55.799]                     if (is.function(workers)) 
[16:12:55.799]                       workers <- workers()
[16:12:55.799]                     workers <- structure(as.integer(workers), 
[16:12:55.799]                       class = class(workers))
[16:12:55.799]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:55.799]                       workers >= 1)
[16:12:55.799]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:55.799]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:55.799]                     }
[16:12:55.799]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:55.799]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:55.799]                       envir = envir)
[16:12:55.799]                     if (!future$lazy) 
[16:12:55.799]                       future <- run(future)
[16:12:55.799]                     invisible(future)
[16:12:55.799]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:55.799]                 }
[16:12:55.799]             }
[16:12:55.799]         }
[16:12:55.799]     })
[16:12:55.799]     if (TRUE) {
[16:12:55.799]         base::sink(type = "output", split = FALSE)
[16:12:55.799]         if (TRUE) {
[16:12:55.799]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:55.799]         }
[16:12:55.799]         else {
[16:12:55.799]             ...future.result["stdout"] <- base::list(NULL)
[16:12:55.799]         }
[16:12:55.799]         base::close(...future.stdout)
[16:12:55.799]         ...future.stdout <- NULL
[16:12:55.799]     }
[16:12:55.799]     ...future.result$conditions <- ...future.conditions
[16:12:55.799]     ...future.result$finished <- base::Sys.time()
[16:12:55.799]     ...future.result
[16:12:55.799] }
[16:12:55.802] MultisessionFuture started
[16:12:55.802] - Launch lazy future ... done
[16:12:55.802] run() for ‘MultisessionFuture’ ... done
[16:12:55.849] receiveMessageFromWorker() for ClusterFuture ...
[16:12:55.849] - Validating connection of MultisessionFuture
[16:12:55.849] - received message: FutureResult
[16:12:55.849] - Received FutureResult
[16:12:55.849] - Erased future from FutureRegistry
[16:12:55.850] result() for ClusterFuture ...
[16:12:55.850] - result already collected: FutureResult
[16:12:55.850] result() for ClusterFuture ... done
[16:12:55.850] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:55.850] Future #1
[16:12:55.850] result() for ClusterFuture ...
[16:12:55.850] - result already collected: FutureResult
[16:12:55.850] result() for ClusterFuture ... done
[16:12:55.850] result() for ClusterFuture ...
[16:12:55.850] - result already collected: FutureResult
[16:12:55.850] result() for ClusterFuture ... done
[16:12:55.851] A MultisessionFuture was resolved
[16:12:55.851]  length: 0 (resolved future 1)
[16:12:55.851] resolve() on list ... DONE
[16:12:55.851] - globals: [1] ‘a’
[16:12:55.851] Resolving futures part of globals (recursively) ... DONE
[16:12:55.853] The total size of the 1 globals is 1.55 MiB (1629664 bytes)
[16:12:55.853] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[16:12:55.854] - globals: [1] ‘a’
[16:12:55.854] - packages: [1] ‘future’
[16:12:55.854] getGlobalsAndPackages() ... DONE
[16:12:55.854] run() for ‘Future’ ...
[16:12:55.854] - state: ‘created’
[16:12:55.854] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:55.869] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:55.869] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:55.869]   - Field: ‘node’
[16:12:55.869]   - Field: ‘label’
[16:12:55.869]   - Field: ‘local’
[16:12:55.869]   - Field: ‘owner’
[16:12:55.869]   - Field: ‘envir’
[16:12:55.870]   - Field: ‘workers’
[16:12:55.870]   - Field: ‘packages’
[16:12:55.870]   - Field: ‘gc’
[16:12:55.870]   - Field: ‘conditions’
[16:12:55.870]   - Field: ‘persistent’
[16:12:55.870]   - Field: ‘expr’
[16:12:55.870]   - Field: ‘uuid’
[16:12:55.870]   - Field: ‘seed’
[16:12:55.870]   - Field: ‘version’
[16:12:55.870]   - Field: ‘result’
[16:12:55.871]   - Field: ‘asynchronous’
[16:12:55.871]   - Field: ‘calls’
[16:12:55.871]   - Field: ‘globals’
[16:12:55.871]   - Field: ‘stdout’
[16:12:55.871]   - Field: ‘earlySignal’
[16:12:55.871]   - Field: ‘lazy’
[16:12:55.871]   - Field: ‘state’
[16:12:55.871] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:55.871] - Launch lazy future ...
[16:12:55.871] Packages needed by the future expression (n = 1): ‘future’
[16:12:55.872] Packages needed by future strategies (n = 0): <none>
[16:12:55.872] {
[16:12:55.872]     {
[16:12:55.872]         {
[16:12:55.872]             ...future.startTime <- base::Sys.time()
[16:12:55.872]             {
[16:12:55.872]                 {
[16:12:55.872]                   {
[16:12:55.872]                     {
[16:12:55.872]                       {
[16:12:55.872]                         base::local({
[16:12:55.872]                           has_future <- base::requireNamespace("future", 
[16:12:55.872]                             quietly = TRUE)
[16:12:55.872]                           if (has_future) {
[16:12:55.872]                             ns <- base::getNamespace("future")
[16:12:55.872]                             version <- ns[[".package"]][["version"]]
[16:12:55.872]                             if (is.null(version)) 
[16:12:55.872]                               version <- utils::packageVersion("future")
[16:12:55.872]                           }
[16:12:55.872]                           else {
[16:12:55.872]                             version <- NULL
[16:12:55.872]                           }
[16:12:55.872]                           if (!has_future || version < "1.8.0") {
[16:12:55.872]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:55.872]                               "", base::R.version$version.string), 
[16:12:55.872]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:55.872]                                 base::R.version$platform, 8 * 
[16:12:55.872]                                   base::.Machine$sizeof.pointer), 
[16:12:55.872]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:55.872]                                 "release", "version")], collapse = " "), 
[16:12:55.872]                               hostname = base::Sys.info()[["nodename"]])
[16:12:55.872]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:55.872]                               info)
[16:12:55.872]                             info <- base::paste(info, collapse = "; ")
[16:12:55.872]                             if (!has_future) {
[16:12:55.872]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:55.872]                                 info)
[16:12:55.872]                             }
[16:12:55.872]                             else {
[16:12:55.872]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:55.872]                                 info, version)
[16:12:55.872]                             }
[16:12:55.872]                             base::stop(msg)
[16:12:55.872]                           }
[16:12:55.872]                         })
[16:12:55.872]                       }
[16:12:55.872]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:55.872]                       base::options(mc.cores = 1L)
[16:12:55.872]                     }
[16:12:55.872]                     base::local({
[16:12:55.872]                       for (pkg in "future") {
[16:12:55.872]                         base::loadNamespace(pkg)
[16:12:55.872]                         base::library(pkg, character.only = TRUE)
[16:12:55.872]                       }
[16:12:55.872]                     })
[16:12:55.872]                   }
[16:12:55.872]                   options(future.plan = NULL)
[16:12:55.872]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:55.872]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:55.872]                 }
[16:12:55.872]                 ...future.workdir <- getwd()
[16:12:55.872]             }
[16:12:55.872]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:55.872]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:55.872]         }
[16:12:55.872]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:55.872]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:55.872]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:55.872]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:55.872]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:55.872]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:55.872]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:55.872]             base::names(...future.oldOptions))
[16:12:55.872]     }
[16:12:55.872]     if (FALSE) {
[16:12:55.872]     }
[16:12:55.872]     else {
[16:12:55.872]         if (TRUE) {
[16:12:55.872]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:55.872]                 open = "w")
[16:12:55.872]         }
[16:12:55.872]         else {
[16:12:55.872]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:55.872]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:55.872]         }
[16:12:55.872]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:55.872]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:55.872]             base::sink(type = "output", split = FALSE)
[16:12:55.872]             base::close(...future.stdout)
[16:12:55.872]         }, add = TRUE)
[16:12:55.872]     }
[16:12:55.872]     ...future.frame <- base::sys.nframe()
[16:12:55.872]     ...future.conditions <- base::list()
[16:12:55.872]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:55.872]     if (FALSE) {
[16:12:55.872]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:55.872]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:55.872]     }
[16:12:55.872]     ...future.result <- base::tryCatch({
[16:12:55.872]         base::withCallingHandlers({
[16:12:55.872]             ...future.value <- base::withVisible(base::local({
[16:12:55.872]                 ...future.makeSendCondition <- local({
[16:12:55.872]                   sendCondition <- NULL
[16:12:55.872]                   function(frame = 1L) {
[16:12:55.872]                     if (is.function(sendCondition)) 
[16:12:55.872]                       return(sendCondition)
[16:12:55.872]                     ns <- getNamespace("parallel")
[16:12:55.872]                     if (exists("sendData", mode = "function", 
[16:12:55.872]                       envir = ns)) {
[16:12:55.872]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:55.872]                         envir = ns)
[16:12:55.872]                       envir <- sys.frame(frame)
[16:12:55.872]                       master <- NULL
[16:12:55.872]                       while (!identical(envir, .GlobalEnv) && 
[16:12:55.872]                         !identical(envir, emptyenv())) {
[16:12:55.872]                         if (exists("master", mode = "list", envir = envir, 
[16:12:55.872]                           inherits = FALSE)) {
[16:12:55.872]                           master <- get("master", mode = "list", 
[16:12:55.872]                             envir = envir, inherits = FALSE)
[16:12:55.872]                           if (inherits(master, c("SOCKnode", 
[16:12:55.872]                             "SOCK0node"))) {
[16:12:55.872]                             sendCondition <<- function(cond) {
[16:12:55.872]                               data <- list(type = "VALUE", value = cond, 
[16:12:55.872]                                 success = TRUE)
[16:12:55.872]                               parallel_sendData(master, data)
[16:12:55.872]                             }
[16:12:55.872]                             return(sendCondition)
[16:12:55.872]                           }
[16:12:55.872]                         }
[16:12:55.872]                         frame <- frame + 1L
[16:12:55.872]                         envir <- sys.frame(frame)
[16:12:55.872]                       }
[16:12:55.872]                     }
[16:12:55.872]                     sendCondition <<- function(cond) NULL
[16:12:55.872]                   }
[16:12:55.872]                 })
[16:12:55.872]                 withCallingHandlers({
[16:12:55.872]                   value(a) + 1
[16:12:55.872]                 }, immediateCondition = function(cond) {
[16:12:55.872]                   sendCondition <- ...future.makeSendCondition()
[16:12:55.872]                   sendCondition(cond)
[16:12:55.872]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.872]                   {
[16:12:55.872]                     inherits <- base::inherits
[16:12:55.872]                     invokeRestart <- base::invokeRestart
[16:12:55.872]                     is.null <- base::is.null
[16:12:55.872]                     muffled <- FALSE
[16:12:55.872]                     if (inherits(cond, "message")) {
[16:12:55.872]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:55.872]                       if (muffled) 
[16:12:55.872]                         invokeRestart("muffleMessage")
[16:12:55.872]                     }
[16:12:55.872]                     else if (inherits(cond, "warning")) {
[16:12:55.872]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:55.872]                       if (muffled) 
[16:12:55.872]                         invokeRestart("muffleWarning")
[16:12:55.872]                     }
[16:12:55.872]                     else if (inherits(cond, "condition")) {
[16:12:55.872]                       if (!is.null(pattern)) {
[16:12:55.872]                         computeRestarts <- base::computeRestarts
[16:12:55.872]                         grepl <- base::grepl
[16:12:55.872]                         restarts <- computeRestarts(cond)
[16:12:55.872]                         for (restart in restarts) {
[16:12:55.872]                           name <- restart$name
[16:12:55.872]                           if (is.null(name)) 
[16:12:55.872]                             next
[16:12:55.872]                           if (!grepl(pattern, name)) 
[16:12:55.872]                             next
[16:12:55.872]                           invokeRestart(restart)
[16:12:55.872]                           muffled <- TRUE
[16:12:55.872]                           break
[16:12:55.872]                         }
[16:12:55.872]                       }
[16:12:55.872]                     }
[16:12:55.872]                     invisible(muffled)
[16:12:55.872]                   }
[16:12:55.872]                   muffleCondition(cond)
[16:12:55.872]                 })
[16:12:55.872]             }))
[16:12:55.872]             future::FutureResult(value = ...future.value$value, 
[16:12:55.872]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:55.872]                   ...future.rng), globalenv = if (FALSE) 
[16:12:55.872]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:55.872]                     ...future.globalenv.names))
[16:12:55.872]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:55.872]         }, condition = base::local({
[16:12:55.872]             c <- base::c
[16:12:55.872]             inherits <- base::inherits
[16:12:55.872]             invokeRestart <- base::invokeRestart
[16:12:55.872]             length <- base::length
[16:12:55.872]             list <- base::list
[16:12:55.872]             seq.int <- base::seq.int
[16:12:55.872]             signalCondition <- base::signalCondition
[16:12:55.872]             sys.calls <- base::sys.calls
[16:12:55.872]             `[[` <- base::`[[`
[16:12:55.872]             `+` <- base::`+`
[16:12:55.872]             `<<-` <- base::`<<-`
[16:12:55.872]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:55.872]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:55.872]                   3L)]
[16:12:55.872]             }
[16:12:55.872]             function(cond) {
[16:12:55.872]                 is_error <- inherits(cond, "error")
[16:12:55.872]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:55.872]                   NULL)
[16:12:55.872]                 if (is_error) {
[16:12:55.872]                   sessionInformation <- function() {
[16:12:55.872]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:55.872]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:55.872]                       search = base::search(), system = base::Sys.info())
[16:12:55.872]                   }
[16:12:55.872]                   ...future.conditions[[length(...future.conditions) + 
[16:12:55.872]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:55.872]                     cond$call), session = sessionInformation(), 
[16:12:55.872]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:55.872]                   signalCondition(cond)
[16:12:55.872]                 }
[16:12:55.872]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:55.872]                 "immediateCondition"))) {
[16:12:55.872]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:55.872]                   ...future.conditions[[length(...future.conditions) + 
[16:12:55.872]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:55.872]                   if (TRUE && !signal) {
[16:12:55.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.872]                     {
[16:12:55.872]                       inherits <- base::inherits
[16:12:55.872]                       invokeRestart <- base::invokeRestart
[16:12:55.872]                       is.null <- base::is.null
[16:12:55.872]                       muffled <- FALSE
[16:12:55.872]                       if (inherits(cond, "message")) {
[16:12:55.872]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:55.872]                         if (muffled) 
[16:12:55.872]                           invokeRestart("muffleMessage")
[16:12:55.872]                       }
[16:12:55.872]                       else if (inherits(cond, "warning")) {
[16:12:55.872]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:55.872]                         if (muffled) 
[16:12:55.872]                           invokeRestart("muffleWarning")
[16:12:55.872]                       }
[16:12:55.872]                       else if (inherits(cond, "condition")) {
[16:12:55.872]                         if (!is.null(pattern)) {
[16:12:55.872]                           computeRestarts <- base::computeRestarts
[16:12:55.872]                           grepl <- base::grepl
[16:12:55.872]                           restarts <- computeRestarts(cond)
[16:12:55.872]                           for (restart in restarts) {
[16:12:55.872]                             name <- restart$name
[16:12:55.872]                             if (is.null(name)) 
[16:12:55.872]                               next
[16:12:55.872]                             if (!grepl(pattern, name)) 
[16:12:55.872]                               next
[16:12:55.872]                             invokeRestart(restart)
[16:12:55.872]                             muffled <- TRUE
[16:12:55.872]                             break
[16:12:55.872]                           }
[16:12:55.872]                         }
[16:12:55.872]                       }
[16:12:55.872]                       invisible(muffled)
[16:12:55.872]                     }
[16:12:55.872]                     muffleCondition(cond, pattern = "^muffle")
[16:12:55.872]                   }
[16:12:55.872]                 }
[16:12:55.872]                 else {
[16:12:55.872]                   if (TRUE) {
[16:12:55.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:55.872]                     {
[16:12:55.872]                       inherits <- base::inherits
[16:12:55.872]                       invokeRestart <- base::invokeRestart
[16:12:55.872]                       is.null <- base::is.null
[16:12:55.872]                       muffled <- FALSE
[16:12:55.872]                       if (inherits(cond, "message")) {
[16:12:55.872]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:55.872]                         if (muffled) 
[16:12:55.872]                           invokeRestart("muffleMessage")
[16:12:55.872]                       }
[16:12:55.872]                       else if (inherits(cond, "warning")) {
[16:12:55.872]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:55.872]                         if (muffled) 
[16:12:55.872]                           invokeRestart("muffleWarning")
[16:12:55.872]                       }
[16:12:55.872]                       else if (inherits(cond, "condition")) {
[16:12:55.872]                         if (!is.null(pattern)) {
[16:12:55.872]                           computeRestarts <- base::computeRestarts
[16:12:55.872]                           grepl <- base::grepl
[16:12:55.872]                           restarts <- computeRestarts(cond)
[16:12:55.872]                           for (restart in restarts) {
[16:12:55.872]                             name <- restart$name
[16:12:55.872]                             if (is.null(name)) 
[16:12:55.872]                               next
[16:12:55.872]                             if (!grepl(pattern, name)) 
[16:12:55.872]                               next
[16:12:55.872]                             invokeRestart(restart)
[16:12:55.872]                             muffled <- TRUE
[16:12:55.872]                             break
[16:12:55.872]                           }
[16:12:55.872]                         }
[16:12:55.872]                       }
[16:12:55.872]                       invisible(muffled)
[16:12:55.872]                     }
[16:12:55.872]                     muffleCondition(cond, pattern = "^muffle")
[16:12:55.872]                   }
[16:12:55.872]                 }
[16:12:55.872]             }
[16:12:55.872]         }))
[16:12:55.872]     }, error = function(ex) {
[16:12:55.872]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:55.872]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:55.872]                 ...future.rng), started = ...future.startTime, 
[16:12:55.872]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:55.872]             version = "1.8"), class = "FutureResult")
[16:12:55.872]     }, finally = {
[16:12:55.872]         if (!identical(...future.workdir, getwd())) 
[16:12:55.872]             setwd(...future.workdir)
[16:12:55.872]         {
[16:12:55.872]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:55.872]                 ...future.oldOptions$nwarnings <- NULL
[16:12:55.872]             }
[16:12:55.872]             base::options(...future.oldOptions)
[16:12:55.872]             if (.Platform$OS.type == "windows") {
[16:12:55.872]                 old_names <- names(...future.oldEnvVars)
[16:12:55.872]                 envs <- base::Sys.getenv()
[16:12:55.872]                 names <- names(envs)
[16:12:55.872]                 common <- intersect(names, old_names)
[16:12:55.872]                 added <- setdiff(names, old_names)
[16:12:55.872]                 removed <- setdiff(old_names, names)
[16:12:55.872]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:55.872]                   envs[common]]
[16:12:55.872]                 NAMES <- toupper(changed)
[16:12:55.872]                 args <- list()
[16:12:55.872]                 for (kk in seq_along(NAMES)) {
[16:12:55.872]                   name <- changed[[kk]]
[16:12:55.872]                   NAME <- NAMES[[kk]]
[16:12:55.872]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.872]                     next
[16:12:55.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:55.872]                 }
[16:12:55.872]                 NAMES <- toupper(added)
[16:12:55.872]                 for (kk in seq_along(NAMES)) {
[16:12:55.872]                   name <- added[[kk]]
[16:12:55.872]                   NAME <- NAMES[[kk]]
[16:12:55.872]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.872]                     next
[16:12:55.872]                   args[[name]] <- ""
[16:12:55.872]                 }
[16:12:55.872]                 NAMES <- toupper(removed)
[16:12:55.872]                 for (kk in seq_along(NAMES)) {
[16:12:55.872]                   name <- removed[[kk]]
[16:12:55.872]                   NAME <- NAMES[[kk]]
[16:12:55.872]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:55.872]                     next
[16:12:55.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:55.872]                 }
[16:12:55.872]                 if (length(args) > 0) 
[16:12:55.872]                   base::do.call(base::Sys.setenv, args = args)
[16:12:55.872]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:55.872]             }
[16:12:55.872]             else {
[16:12:55.872]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:55.872]             }
[16:12:55.872]             {
[16:12:55.872]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:55.872]                   0L) {
[16:12:55.872]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:55.872]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:55.872]                   base::options(opts)
[16:12:55.872]                 }
[16:12:55.872]                 {
[16:12:55.872]                   {
[16:12:55.872]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:55.872]                     NULL
[16:12:55.872]                   }
[16:12:55.872]                   options(future.plan = NULL)
[16:12:55.872]                   if (is.na(NA_character_)) 
[16:12:55.872]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:55.872]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:55.872]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:55.872]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:55.872]                     envir = parent.frame()) 
[16:12:55.872]                   {
[16:12:55.872]                     if (is.function(workers)) 
[16:12:55.872]                       workers <- workers()
[16:12:55.872]                     workers <- structure(as.integer(workers), 
[16:12:55.872]                       class = class(workers))
[16:12:55.872]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:55.872]                       workers >= 1)
[16:12:55.872]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:55.872]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:55.872]                     }
[16:12:55.872]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:55.872]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:55.872]                       envir = envir)
[16:12:55.872]                     if (!future$lazy) 
[16:12:55.872]                       future <- run(future)
[16:12:55.872]                     invisible(future)
[16:12:55.872]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:55.872]                 }
[16:12:55.872]             }
[16:12:55.872]         }
[16:12:55.872]     })
[16:12:55.872]     if (TRUE) {
[16:12:55.872]         base::sink(type = "output", split = FALSE)
[16:12:55.872]         if (TRUE) {
[16:12:55.872]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:55.872]         }
[16:12:55.872]         else {
[16:12:55.872]             ...future.result["stdout"] <- base::list(NULL)
[16:12:55.872]         }
[16:12:55.872]         base::close(...future.stdout)
[16:12:55.872]         ...future.stdout <- NULL
[16:12:55.872]     }
[16:12:55.872]     ...future.result$conditions <- ...future.conditions
[16:12:55.872]     ...future.result$finished <- base::Sys.time()
[16:12:55.872]     ...future.result
[16:12:55.872] }
[16:12:55.875] Exporting 1 global objects (1.55 MiB) to cluster node #1 ...
[16:12:55.877] Exporting ‘a’ (1.55 MiB) to cluster node #1 ...
[16:12:55.928] Exporting ‘a’ (1.55 MiB) to cluster node #1 ... DONE
[16:12:55.928] Exporting 1 global objects (1.55 MiB) to cluster node #1 ... DONE
[16:12:55.929] MultisessionFuture started
[16:12:55.929] - Launch lazy future ... done
[16:12:55.929] run() for ‘MultisessionFuture’ ... done
[16:12:55.929] result() for ClusterFuture ...
[16:12:55.929] receiveMessageFromWorker() for ClusterFuture ...
[16:12:55.929] - Validating connection of MultisessionFuture
[16:12:55.977] - received message: FutureResult
[16:12:55.977] - Received FutureResult
[16:12:55.977] - Erased future from FutureRegistry
[16:12:55.978] result() for ClusterFuture ...
[16:12:55.978] - result already collected: FutureResult
[16:12:55.978] result() for ClusterFuture ... done
[16:12:55.978] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:55.978] result() for ClusterFuture ... done
[16:12:55.978] result() for ClusterFuture ...
[16:12:55.978] - result already collected: FutureResult
[16:12:55.978] result() for ClusterFuture ... done
value(b) = 2
[16:12:55.978] result() for ClusterFuture ...
[16:12:55.979] - result already collected: FutureResult
[16:12:55.979] result() for ClusterFuture ... done
[16:12:55.979] result() for ClusterFuture ...
[16:12:55.979] - result already collected: FutureResult
[16:12:55.979] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:55.979] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:55.979] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:55.980] 
[16:12:55.980] Searching for globals ... DONE
[16:12:55.980] - globals: [0] <none>
[16:12:55.980] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:55.980] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:55.981] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:55.981] - globals found: [3] ‘+’, ‘value’, ‘a’
[16:12:55.981] Searching for globals ... DONE
[16:12:55.981] Resolving globals: TRUE
[16:12:55.982] Resolving any globals that are futures ...
[16:12:55.982] - globals: [3] ‘+’, ‘value’, ‘a’
[16:12:55.982] Resolving any globals that are futures ... DONE
[16:12:55.982] Resolving futures part of globals (recursively) ...
[16:12:55.982] resolve() on list ...
[16:12:55.982]  recursive: 99
[16:12:55.983]  length: 1
[16:12:55.983]  elements: ‘a’
[16:12:55.983] run() for ‘Future’ ...
[16:12:55.983] - state: ‘created’
[16:12:55.983] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:55.997] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:55.998] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:55.998]   - Field: ‘node’
[16:12:55.998]   - Field: ‘label’
[16:12:55.998]   - Field: ‘local’
[16:12:55.998]   - Field: ‘owner’
[16:12:55.998]   - Field: ‘envir’
[16:12:55.998]   - Field: ‘workers’
[16:12:55.998]   - Field: ‘packages’
[16:12:55.998]   - Field: ‘gc’
[16:12:55.998]   - Field: ‘conditions’
[16:12:55.999]   - Field: ‘persistent’
[16:12:55.999]   - Field: ‘expr’
[16:12:55.999]   - Field: ‘uuid’
[16:12:55.999]   - Field: ‘seed’
[16:12:55.999]   - Field: ‘version’
[16:12:55.999]   - Field: ‘result’
[16:12:55.999]   - Field: ‘asynchronous’
[16:12:55.999]   - Field: ‘calls’
[16:12:55.999]   - Field: ‘globals’
[16:12:55.999]   - Field: ‘stdout’
[16:12:55.999]   - Field: ‘earlySignal’
[16:12:56.000]   - Field: ‘lazy’
[16:12:56.000]   - Field: ‘state’
[16:12:56.000] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:56.000] - Launch lazy future ...
[16:12:56.000] Packages needed by the future expression (n = 0): <none>
[16:12:56.000] Packages needed by future strategies (n = 0): <none>
[16:12:56.001] {
[16:12:56.001]     {
[16:12:56.001]         {
[16:12:56.001]             ...future.startTime <- base::Sys.time()
[16:12:56.001]             {
[16:12:56.001]                 {
[16:12:56.001]                   {
[16:12:56.001]                     {
[16:12:56.001]                       base::local({
[16:12:56.001]                         has_future <- base::requireNamespace("future", 
[16:12:56.001]                           quietly = TRUE)
[16:12:56.001]                         if (has_future) {
[16:12:56.001]                           ns <- base::getNamespace("future")
[16:12:56.001]                           version <- ns[[".package"]][["version"]]
[16:12:56.001]                           if (is.null(version)) 
[16:12:56.001]                             version <- utils::packageVersion("future")
[16:12:56.001]                         }
[16:12:56.001]                         else {
[16:12:56.001]                           version <- NULL
[16:12:56.001]                         }
[16:12:56.001]                         if (!has_future || version < "1.8.0") {
[16:12:56.001]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:56.001]                             "", base::R.version$version.string), 
[16:12:56.001]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:56.001]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:56.001]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:56.001]                               "release", "version")], collapse = " "), 
[16:12:56.001]                             hostname = base::Sys.info()[["nodename"]])
[16:12:56.001]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:56.001]                             info)
[16:12:56.001]                           info <- base::paste(info, collapse = "; ")
[16:12:56.001]                           if (!has_future) {
[16:12:56.001]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:56.001]                               info)
[16:12:56.001]                           }
[16:12:56.001]                           else {
[16:12:56.001]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:56.001]                               info, version)
[16:12:56.001]                           }
[16:12:56.001]                           base::stop(msg)
[16:12:56.001]                         }
[16:12:56.001]                       })
[16:12:56.001]                     }
[16:12:56.001]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:56.001]                     base::options(mc.cores = 1L)
[16:12:56.001]                   }
[16:12:56.001]                   options(future.plan = NULL)
[16:12:56.001]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:56.001]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:56.001]                 }
[16:12:56.001]                 ...future.workdir <- getwd()
[16:12:56.001]             }
[16:12:56.001]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:56.001]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:56.001]         }
[16:12:56.001]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:56.001]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:56.001]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:56.001]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:56.001]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:56.001]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:56.001]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:56.001]             base::names(...future.oldOptions))
[16:12:56.001]     }
[16:12:56.001]     if (FALSE) {
[16:12:56.001]     }
[16:12:56.001]     else {
[16:12:56.001]         if (TRUE) {
[16:12:56.001]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:56.001]                 open = "w")
[16:12:56.001]         }
[16:12:56.001]         else {
[16:12:56.001]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:56.001]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:56.001]         }
[16:12:56.001]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:56.001]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:56.001]             base::sink(type = "output", split = FALSE)
[16:12:56.001]             base::close(...future.stdout)
[16:12:56.001]         }, add = TRUE)
[16:12:56.001]     }
[16:12:56.001]     ...future.frame <- base::sys.nframe()
[16:12:56.001]     ...future.conditions <- base::list()
[16:12:56.001]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:56.001]     if (FALSE) {
[16:12:56.001]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:56.001]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:56.001]     }
[16:12:56.001]     ...future.result <- base::tryCatch({
[16:12:56.001]         base::withCallingHandlers({
[16:12:56.001]             ...future.value <- base::withVisible(base::local({
[16:12:56.001]                 ...future.makeSendCondition <- local({
[16:12:56.001]                   sendCondition <- NULL
[16:12:56.001]                   function(frame = 1L) {
[16:12:56.001]                     if (is.function(sendCondition)) 
[16:12:56.001]                       return(sendCondition)
[16:12:56.001]                     ns <- getNamespace("parallel")
[16:12:56.001]                     if (exists("sendData", mode = "function", 
[16:12:56.001]                       envir = ns)) {
[16:12:56.001]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:56.001]                         envir = ns)
[16:12:56.001]                       envir <- sys.frame(frame)
[16:12:56.001]                       master <- NULL
[16:12:56.001]                       while (!identical(envir, .GlobalEnv) && 
[16:12:56.001]                         !identical(envir, emptyenv())) {
[16:12:56.001]                         if (exists("master", mode = "list", envir = envir, 
[16:12:56.001]                           inherits = FALSE)) {
[16:12:56.001]                           master <- get("master", mode = "list", 
[16:12:56.001]                             envir = envir, inherits = FALSE)
[16:12:56.001]                           if (inherits(master, c("SOCKnode", 
[16:12:56.001]                             "SOCK0node"))) {
[16:12:56.001]                             sendCondition <<- function(cond) {
[16:12:56.001]                               data <- list(type = "VALUE", value = cond, 
[16:12:56.001]                                 success = TRUE)
[16:12:56.001]                               parallel_sendData(master, data)
[16:12:56.001]                             }
[16:12:56.001]                             return(sendCondition)
[16:12:56.001]                           }
[16:12:56.001]                         }
[16:12:56.001]                         frame <- frame + 1L
[16:12:56.001]                         envir <- sys.frame(frame)
[16:12:56.001]                       }
[16:12:56.001]                     }
[16:12:56.001]                     sendCondition <<- function(cond) NULL
[16:12:56.001]                   }
[16:12:56.001]                 })
[16:12:56.001]                 withCallingHandlers({
[16:12:56.001]                   1
[16:12:56.001]                 }, immediateCondition = function(cond) {
[16:12:56.001]                   sendCondition <- ...future.makeSendCondition()
[16:12:56.001]                   sendCondition(cond)
[16:12:56.001]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:56.001]                   {
[16:12:56.001]                     inherits <- base::inherits
[16:12:56.001]                     invokeRestart <- base::invokeRestart
[16:12:56.001]                     is.null <- base::is.null
[16:12:56.001]                     muffled <- FALSE
[16:12:56.001]                     if (inherits(cond, "message")) {
[16:12:56.001]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:56.001]                       if (muffled) 
[16:12:56.001]                         invokeRestart("muffleMessage")
[16:12:56.001]                     }
[16:12:56.001]                     else if (inherits(cond, "warning")) {
[16:12:56.001]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:56.001]                       if (muffled) 
[16:12:56.001]                         invokeRestart("muffleWarning")
[16:12:56.001]                     }
[16:12:56.001]                     else if (inherits(cond, "condition")) {
[16:12:56.001]                       if (!is.null(pattern)) {
[16:12:56.001]                         computeRestarts <- base::computeRestarts
[16:12:56.001]                         grepl <- base::grepl
[16:12:56.001]                         restarts <- computeRestarts(cond)
[16:12:56.001]                         for (restart in restarts) {
[16:12:56.001]                           name <- restart$name
[16:12:56.001]                           if (is.null(name)) 
[16:12:56.001]                             next
[16:12:56.001]                           if (!grepl(pattern, name)) 
[16:12:56.001]                             next
[16:12:56.001]                           invokeRestart(restart)
[16:12:56.001]                           muffled <- TRUE
[16:12:56.001]                           break
[16:12:56.001]                         }
[16:12:56.001]                       }
[16:12:56.001]                     }
[16:12:56.001]                     invisible(muffled)
[16:12:56.001]                   }
[16:12:56.001]                   muffleCondition(cond)
[16:12:56.001]                 })
[16:12:56.001]             }))
[16:12:56.001]             future::FutureResult(value = ...future.value$value, 
[16:12:56.001]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:56.001]                   ...future.rng), globalenv = if (FALSE) 
[16:12:56.001]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:56.001]                     ...future.globalenv.names))
[16:12:56.001]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:56.001]         }, condition = base::local({
[16:12:56.001]             c <- base::c
[16:12:56.001]             inherits <- base::inherits
[16:12:56.001]             invokeRestart <- base::invokeRestart
[16:12:56.001]             length <- base::length
[16:12:56.001]             list <- base::list
[16:12:56.001]             seq.int <- base::seq.int
[16:12:56.001]             signalCondition <- base::signalCondition
[16:12:56.001]             sys.calls <- base::sys.calls
[16:12:56.001]             `[[` <- base::`[[`
[16:12:56.001]             `+` <- base::`+`
[16:12:56.001]             `<<-` <- base::`<<-`
[16:12:56.001]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:56.001]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:56.001]                   3L)]
[16:12:56.001]             }
[16:12:56.001]             function(cond) {
[16:12:56.001]                 is_error <- inherits(cond, "error")
[16:12:56.001]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:56.001]                   NULL)
[16:12:56.001]                 if (is_error) {
[16:12:56.001]                   sessionInformation <- function() {
[16:12:56.001]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:56.001]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:56.001]                       search = base::search(), system = base::Sys.info())
[16:12:56.001]                   }
[16:12:56.001]                   ...future.conditions[[length(...future.conditions) + 
[16:12:56.001]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:56.001]                     cond$call), session = sessionInformation(), 
[16:12:56.001]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:56.001]                   signalCondition(cond)
[16:12:56.001]                 }
[16:12:56.001]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:56.001]                 "immediateCondition"))) {
[16:12:56.001]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:56.001]                   ...future.conditions[[length(...future.conditions) + 
[16:12:56.001]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:56.001]                   if (TRUE && !signal) {
[16:12:56.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:56.001]                     {
[16:12:56.001]                       inherits <- base::inherits
[16:12:56.001]                       invokeRestart <- base::invokeRestart
[16:12:56.001]                       is.null <- base::is.null
[16:12:56.001]                       muffled <- FALSE
[16:12:56.001]                       if (inherits(cond, "message")) {
[16:12:56.001]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:56.001]                         if (muffled) 
[16:12:56.001]                           invokeRestart("muffleMessage")
[16:12:56.001]                       }
[16:12:56.001]                       else if (inherits(cond, "warning")) {
[16:12:56.001]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:56.001]                         if (muffled) 
[16:12:56.001]                           invokeRestart("muffleWarning")
[16:12:56.001]                       }
[16:12:56.001]                       else if (inherits(cond, "condition")) {
[16:12:56.001]                         if (!is.null(pattern)) {
[16:12:56.001]                           computeRestarts <- base::computeRestarts
[16:12:56.001]                           grepl <- base::grepl
[16:12:56.001]                           restarts <- computeRestarts(cond)
[16:12:56.001]                           for (restart in restarts) {
[16:12:56.001]                             name <- restart$name
[16:12:56.001]                             if (is.null(name)) 
[16:12:56.001]                               next
[16:12:56.001]                             if (!grepl(pattern, name)) 
[16:12:56.001]                               next
[16:12:56.001]                             invokeRestart(restart)
[16:12:56.001]                             muffled <- TRUE
[16:12:56.001]                             break
[16:12:56.001]                           }
[16:12:56.001]                         }
[16:12:56.001]                       }
[16:12:56.001]                       invisible(muffled)
[16:12:56.001]                     }
[16:12:56.001]                     muffleCondition(cond, pattern = "^muffle")
[16:12:56.001]                   }
[16:12:56.001]                 }
[16:12:56.001]                 else {
[16:12:56.001]                   if (TRUE) {
[16:12:56.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:56.001]                     {
[16:12:56.001]                       inherits <- base::inherits
[16:12:56.001]                       invokeRestart <- base::invokeRestart
[16:12:56.001]                       is.null <- base::is.null
[16:12:56.001]                       muffled <- FALSE
[16:12:56.001]                       if (inherits(cond, "message")) {
[16:12:56.001]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:56.001]                         if (muffled) 
[16:12:56.001]                           invokeRestart("muffleMessage")
[16:12:56.001]                       }
[16:12:56.001]                       else if (inherits(cond, "warning")) {
[16:12:56.001]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:56.001]                         if (muffled) 
[16:12:56.001]                           invokeRestart("muffleWarning")
[16:12:56.001]                       }
[16:12:56.001]                       else if (inherits(cond, "condition")) {
[16:12:56.001]                         if (!is.null(pattern)) {
[16:12:56.001]                           computeRestarts <- base::computeRestarts
[16:12:56.001]                           grepl <- base::grepl
[16:12:56.001]                           restarts <- computeRestarts(cond)
[16:12:56.001]                           for (restart in restarts) {
[16:12:56.001]                             name <- restart$name
[16:12:56.001]                             if (is.null(name)) 
[16:12:56.001]                               next
[16:12:56.001]                             if (!grepl(pattern, name)) 
[16:12:56.001]                               next
[16:12:56.001]                             invokeRestart(restart)
[16:12:56.001]                             muffled <- TRUE
[16:12:56.001]                             break
[16:12:56.001]                           }
[16:12:56.001]                         }
[16:12:56.001]                       }
[16:12:56.001]                       invisible(muffled)
[16:12:56.001]                     }
[16:12:56.001]                     muffleCondition(cond, pattern = "^muffle")
[16:12:56.001]                   }
[16:12:56.001]                 }
[16:12:56.001]             }
[16:12:56.001]         }))
[16:12:56.001]     }, error = function(ex) {
[16:12:56.001]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:56.001]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:56.001]                 ...future.rng), started = ...future.startTime, 
[16:12:56.001]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:56.001]             version = "1.8"), class = "FutureResult")
[16:12:56.001]     }, finally = {
[16:12:56.001]         if (!identical(...future.workdir, getwd())) 
[16:12:56.001]             setwd(...future.workdir)
[16:12:56.001]         {
[16:12:56.001]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:56.001]                 ...future.oldOptions$nwarnings <- NULL
[16:12:56.001]             }
[16:12:56.001]             base::options(...future.oldOptions)
[16:12:56.001]             if (.Platform$OS.type == "windows") {
[16:12:56.001]                 old_names <- names(...future.oldEnvVars)
[16:12:56.001]                 envs <- base::Sys.getenv()
[16:12:56.001]                 names <- names(envs)
[16:12:56.001]                 common <- intersect(names, old_names)
[16:12:56.001]                 added <- setdiff(names, old_names)
[16:12:56.001]                 removed <- setdiff(old_names, names)
[16:12:56.001]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:56.001]                   envs[common]]
[16:12:56.001]                 NAMES <- toupper(changed)
[16:12:56.001]                 args <- list()
[16:12:56.001]                 for (kk in seq_along(NAMES)) {
[16:12:56.001]                   name <- changed[[kk]]
[16:12:56.001]                   NAME <- NAMES[[kk]]
[16:12:56.001]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:56.001]                     next
[16:12:56.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:56.001]                 }
[16:12:56.001]                 NAMES <- toupper(added)
[16:12:56.001]                 for (kk in seq_along(NAMES)) {
[16:12:56.001]                   name <- added[[kk]]
[16:12:56.001]                   NAME <- NAMES[[kk]]
[16:12:56.001]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:56.001]                     next
[16:12:56.001]                   args[[name]] <- ""
[16:12:56.001]                 }
[16:12:56.001]                 NAMES <- toupper(removed)
[16:12:56.001]                 for (kk in seq_along(NAMES)) {
[16:12:56.001]                   name <- removed[[kk]]
[16:12:56.001]                   NAME <- NAMES[[kk]]
[16:12:56.001]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:56.001]                     next
[16:12:56.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:56.001]                 }
[16:12:56.001]                 if (length(args) > 0) 
[16:12:56.001]                   base::do.call(base::Sys.setenv, args = args)
[16:12:56.001]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:56.001]             }
[16:12:56.001]             else {
[16:12:56.001]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:56.001]             }
[16:12:56.001]             {
[16:12:56.001]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:56.001]                   0L) {
[16:12:56.001]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:56.001]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:56.001]                   base::options(opts)
[16:12:56.001]                 }
[16:12:56.001]                 {
[16:12:56.001]                   {
[16:12:56.001]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:56.001]                     NULL
[16:12:56.001]                   }
[16:12:56.001]                   options(future.plan = NULL)
[16:12:56.001]                   if (is.na(NA_character_)) 
[16:12:56.001]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:56.001]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:56.001]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:56.001]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:56.001]                     envir = parent.frame()) 
[16:12:56.001]                   {
[16:12:56.001]                     if (is.function(workers)) 
[16:12:56.001]                       workers <- workers()
[16:12:56.001]                     workers <- structure(as.integer(workers), 
[16:12:56.001]                       class = class(workers))
[16:12:56.001]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:56.001]                       workers >= 1)
[16:12:56.001]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:56.001]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:56.001]                     }
[16:12:56.001]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:56.001]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:56.001]                       envir = envir)
[16:12:56.001]                     if (!future$lazy) 
[16:12:56.001]                       future <- run(future)
[16:12:56.001]                     invisible(future)
[16:12:56.001]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:56.001]                 }
[16:12:56.001]             }
[16:12:56.001]         }
[16:12:56.001]     })
[16:12:56.001]     if (TRUE) {
[16:12:56.001]         base::sink(type = "output", split = FALSE)
[16:12:56.001]         if (TRUE) {
[16:12:56.001]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:56.001]         }
[16:12:56.001]         else {
[16:12:56.001]             ...future.result["stdout"] <- base::list(NULL)
[16:12:56.001]         }
[16:12:56.001]         base::close(...future.stdout)
[16:12:56.001]         ...future.stdout <- NULL
[16:12:56.001]     }
[16:12:56.001]     ...future.result$conditions <- ...future.conditions
[16:12:56.001]     ...future.result$finished <- base::Sys.time()
[16:12:56.001]     ...future.result
[16:12:56.001] }
[16:12:56.004] MultisessionFuture started
[16:12:56.004] - Launch lazy future ... done
[16:12:56.004] run() for ‘MultisessionFuture’ ... done
[16:12:56.053] receiveMessageFromWorker() for ClusterFuture ...
[16:12:56.053] - Validating connection of MultisessionFuture
[16:12:56.053] - received message: FutureResult
[16:12:56.054] - Received FutureResult
[16:12:56.054] - Erased future from FutureRegistry
[16:12:56.054] result() for ClusterFuture ...
[16:12:56.054] - result already collected: FutureResult
[16:12:56.054] result() for ClusterFuture ... done
[16:12:56.054] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:56.054] Future #1
[16:12:56.054] result() for ClusterFuture ...
[16:12:56.054] - result already collected: FutureResult
[16:12:56.054] result() for ClusterFuture ... done
[16:12:56.054] result() for ClusterFuture ...
[16:12:56.055] - result already collected: FutureResult
[16:12:56.055] result() for ClusterFuture ... done
[16:12:56.055] A MultisessionFuture was resolved
[16:12:56.055]  length: 0 (resolved future 1)
[16:12:56.055] resolve() on list ... DONE
[16:12:56.055] - globals: [1] ‘a’
[16:12:56.055] Resolving futures part of globals (recursively) ... DONE
[16:12:56.057] The total size of the 1 globals is 1.55 MiB (1629664 bytes)
[16:12:56.058] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[16:12:56.058] - globals: [1] ‘a’
[16:12:56.058] - packages: [1] ‘future’
[16:12:56.058] getGlobalsAndPackages() ... DONE
[16:12:56.058] run() for ‘Future’ ...
[16:12:56.058] - state: ‘created’
[16:12:56.059] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:56.076] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:56.076] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:56.076]   - Field: ‘node’
[16:12:56.076]   - Field: ‘label’
[16:12:56.076]   - Field: ‘local’
[16:12:56.076]   - Field: ‘owner’
[16:12:56.077]   - Field: ‘envir’
[16:12:56.077]   - Field: ‘workers’
[16:12:56.077]   - Field: ‘packages’
[16:12:56.077]   - Field: ‘gc’
[16:12:56.077]   - Field: ‘conditions’
[16:12:56.077]   - Field: ‘persistent’
[16:12:56.077]   - Field: ‘expr’
[16:12:56.077]   - Field: ‘uuid’
[16:12:56.077]   - Field: ‘seed’
[16:12:56.077]   - Field: ‘version’
[16:12:56.078]   - Field: ‘result’
[16:12:56.078]   - Field: ‘asynchronous’
[16:12:56.078]   - Field: ‘calls’
[16:12:56.078]   - Field: ‘globals’
[16:12:56.078]   - Field: ‘stdout’
[16:12:56.078]   - Field: ‘earlySignal’
[16:12:56.078]   - Field: ‘lazy’
[16:12:56.078]   - Field: ‘state’
[16:12:56.078] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:56.078] - Launch lazy future ...
[16:12:56.079] Packages needed by the future expression (n = 1): ‘future’
[16:12:56.079] Packages needed by future strategies (n = 0): <none>
[16:12:56.079] {
[16:12:56.079]     {
[16:12:56.079]         {
[16:12:56.079]             ...future.startTime <- base::Sys.time()
[16:12:56.079]             {
[16:12:56.079]                 {
[16:12:56.079]                   {
[16:12:56.079]                     {
[16:12:56.079]                       {
[16:12:56.079]                         base::local({
[16:12:56.079]                           has_future <- base::requireNamespace("future", 
[16:12:56.079]                             quietly = TRUE)
[16:12:56.079]                           if (has_future) {
[16:12:56.079]                             ns <- base::getNamespace("future")
[16:12:56.079]                             version <- ns[[".package"]][["version"]]
[16:12:56.079]                             if (is.null(version)) 
[16:12:56.079]                               version <- utils::packageVersion("future")
[16:12:56.079]                           }
[16:12:56.079]                           else {
[16:12:56.079]                             version <- NULL
[16:12:56.079]                           }
[16:12:56.079]                           if (!has_future || version < "1.8.0") {
[16:12:56.079]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:56.079]                               "", base::R.version$version.string), 
[16:12:56.079]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:56.079]                                 base::R.version$platform, 8 * 
[16:12:56.079]                                   base::.Machine$sizeof.pointer), 
[16:12:56.079]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:56.079]                                 "release", "version")], collapse = " "), 
[16:12:56.079]                               hostname = base::Sys.info()[["nodename"]])
[16:12:56.079]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:56.079]                               info)
[16:12:56.079]                             info <- base::paste(info, collapse = "; ")
[16:12:56.079]                             if (!has_future) {
[16:12:56.079]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:56.079]                                 info)
[16:12:56.079]                             }
[16:12:56.079]                             else {
[16:12:56.079]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:56.079]                                 info, version)
[16:12:56.079]                             }
[16:12:56.079]                             base::stop(msg)
[16:12:56.079]                           }
[16:12:56.079]                         })
[16:12:56.079]                       }
[16:12:56.079]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:56.079]                       base::options(mc.cores = 1L)
[16:12:56.079]                     }
[16:12:56.079]                     base::local({
[16:12:56.079]                       for (pkg in "future") {
[16:12:56.079]                         base::loadNamespace(pkg)
[16:12:56.079]                         base::library(pkg, character.only = TRUE)
[16:12:56.079]                       }
[16:12:56.079]                     })
[16:12:56.079]                   }
[16:12:56.079]                   options(future.plan = NULL)
[16:12:56.079]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:56.079]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:56.079]                 }
[16:12:56.079]                 ...future.workdir <- getwd()
[16:12:56.079]             }
[16:12:56.079]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:56.079]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:56.079]         }
[16:12:56.079]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:56.079]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:56.079]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:56.079]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:56.079]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:56.079]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:56.079]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:56.079]             base::names(...future.oldOptions))
[16:12:56.079]     }
[16:12:56.079]     if (FALSE) {
[16:12:56.079]     }
[16:12:56.079]     else {
[16:12:56.079]         if (TRUE) {
[16:12:56.079]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:56.079]                 open = "w")
[16:12:56.079]         }
[16:12:56.079]         else {
[16:12:56.079]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:56.079]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:56.079]         }
[16:12:56.079]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:56.079]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:56.079]             base::sink(type = "output", split = FALSE)
[16:12:56.079]             base::close(...future.stdout)
[16:12:56.079]         }, add = TRUE)
[16:12:56.079]     }
[16:12:56.079]     ...future.frame <- base::sys.nframe()
[16:12:56.079]     ...future.conditions <- base::list()
[16:12:56.079]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:56.079]     if (FALSE) {
[16:12:56.079]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:56.079]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:56.079]     }
[16:12:56.079]     ...future.result <- base::tryCatch({
[16:12:56.079]         base::withCallingHandlers({
[16:12:56.079]             ...future.value <- base::withVisible(base::local({
[16:12:56.079]                 ...future.makeSendCondition <- local({
[16:12:56.079]                   sendCondition <- NULL
[16:12:56.079]                   function(frame = 1L) {
[16:12:56.079]                     if (is.function(sendCondition)) 
[16:12:56.079]                       return(sendCondition)
[16:12:56.079]                     ns <- getNamespace("parallel")
[16:12:56.079]                     if (exists("sendData", mode = "function", 
[16:12:56.079]                       envir = ns)) {
[16:12:56.079]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:56.079]                         envir = ns)
[16:12:56.079]                       envir <- sys.frame(frame)
[16:12:56.079]                       master <- NULL
[16:12:56.079]                       while (!identical(envir, .GlobalEnv) && 
[16:12:56.079]                         !identical(envir, emptyenv())) {
[16:12:56.079]                         if (exists("master", mode = "list", envir = envir, 
[16:12:56.079]                           inherits = FALSE)) {
[16:12:56.079]                           master <- get("master", mode = "list", 
[16:12:56.079]                             envir = envir, inherits = FALSE)
[16:12:56.079]                           if (inherits(master, c("SOCKnode", 
[16:12:56.079]                             "SOCK0node"))) {
[16:12:56.079]                             sendCondition <<- function(cond) {
[16:12:56.079]                               data <- list(type = "VALUE", value = cond, 
[16:12:56.079]                                 success = TRUE)
[16:12:56.079]                               parallel_sendData(master, data)
[16:12:56.079]                             }
[16:12:56.079]                             return(sendCondition)
[16:12:56.079]                           }
[16:12:56.079]                         }
[16:12:56.079]                         frame <- frame + 1L
[16:12:56.079]                         envir <- sys.frame(frame)
[16:12:56.079]                       }
[16:12:56.079]                     }
[16:12:56.079]                     sendCondition <<- function(cond) NULL
[16:12:56.079]                   }
[16:12:56.079]                 })
[16:12:56.079]                 withCallingHandlers({
[16:12:56.079]                   value(a) + 1
[16:12:56.079]                 }, immediateCondition = function(cond) {
[16:12:56.079]                   sendCondition <- ...future.makeSendCondition()
[16:12:56.079]                   sendCondition(cond)
[16:12:56.079]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:56.079]                   {
[16:12:56.079]                     inherits <- base::inherits
[16:12:56.079]                     invokeRestart <- base::invokeRestart
[16:12:56.079]                     is.null <- base::is.null
[16:12:56.079]                     muffled <- FALSE
[16:12:56.079]                     if (inherits(cond, "message")) {
[16:12:56.079]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:56.079]                       if (muffled) 
[16:12:56.079]                         invokeRestart("muffleMessage")
[16:12:56.079]                     }
[16:12:56.079]                     else if (inherits(cond, "warning")) {
[16:12:56.079]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:56.079]                       if (muffled) 
[16:12:56.079]                         invokeRestart("muffleWarning")
[16:12:56.079]                     }
[16:12:56.079]                     else if (inherits(cond, "condition")) {
[16:12:56.079]                       if (!is.null(pattern)) {
[16:12:56.079]                         computeRestarts <- base::computeRestarts
[16:12:56.079]                         grepl <- base::grepl
[16:12:56.079]                         restarts <- computeRestarts(cond)
[16:12:56.079]                         for (restart in restarts) {
[16:12:56.079]                           name <- restart$name
[16:12:56.079]                           if (is.null(name)) 
[16:12:56.079]                             next
[16:12:56.079]                           if (!grepl(pattern, name)) 
[16:12:56.079]                             next
[16:12:56.079]                           invokeRestart(restart)
[16:12:56.079]                           muffled <- TRUE
[16:12:56.079]                           break
[16:12:56.079]                         }
[16:12:56.079]                       }
[16:12:56.079]                     }
[16:12:56.079]                     invisible(muffled)
[16:12:56.079]                   }
[16:12:56.079]                   muffleCondition(cond)
[16:12:56.079]                 })
[16:12:56.079]             }))
[16:12:56.079]             future::FutureResult(value = ...future.value$value, 
[16:12:56.079]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:56.079]                   ...future.rng), globalenv = if (FALSE) 
[16:12:56.079]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:56.079]                     ...future.globalenv.names))
[16:12:56.079]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:56.079]         }, condition = base::local({
[16:12:56.079]             c <- base::c
[16:12:56.079]             inherits <- base::inherits
[16:12:56.079]             invokeRestart <- base::invokeRestart
[16:12:56.079]             length <- base::length
[16:12:56.079]             list <- base::list
[16:12:56.079]             seq.int <- base::seq.int
[16:12:56.079]             signalCondition <- base::signalCondition
[16:12:56.079]             sys.calls <- base::sys.calls
[16:12:56.079]             `[[` <- base::`[[`
[16:12:56.079]             `+` <- base::`+`
[16:12:56.079]             `<<-` <- base::`<<-`
[16:12:56.079]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:56.079]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:56.079]                   3L)]
[16:12:56.079]             }
[16:12:56.079]             function(cond) {
[16:12:56.079]                 is_error <- inherits(cond, "error")
[16:12:56.079]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:56.079]                   NULL)
[16:12:56.079]                 if (is_error) {
[16:12:56.079]                   sessionInformation <- function() {
[16:12:56.079]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:56.079]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:56.079]                       search = base::search(), system = base::Sys.info())
[16:12:56.079]                   }
[16:12:56.079]                   ...future.conditions[[length(...future.conditions) + 
[16:12:56.079]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:56.079]                     cond$call), session = sessionInformation(), 
[16:12:56.079]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:56.079]                   signalCondition(cond)
[16:12:56.079]                 }
[16:12:56.079]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:56.079]                 "immediateCondition"))) {
[16:12:56.079]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:56.079]                   ...future.conditions[[length(...future.conditions) + 
[16:12:56.079]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:56.079]                   if (TRUE && !signal) {
[16:12:56.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:56.079]                     {
[16:12:56.079]                       inherits <- base::inherits
[16:12:56.079]                       invokeRestart <- base::invokeRestart
[16:12:56.079]                       is.null <- base::is.null
[16:12:56.079]                       muffled <- FALSE
[16:12:56.079]                       if (inherits(cond, "message")) {
[16:12:56.079]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:56.079]                         if (muffled) 
[16:12:56.079]                           invokeRestart("muffleMessage")
[16:12:56.079]                       }
[16:12:56.079]                       else if (inherits(cond, "warning")) {
[16:12:56.079]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:56.079]                         if (muffled) 
[16:12:56.079]                           invokeRestart("muffleWarning")
[16:12:56.079]                       }
[16:12:56.079]                       else if (inherits(cond, "condition")) {
[16:12:56.079]                         if (!is.null(pattern)) {
[16:12:56.079]                           computeRestarts <- base::computeRestarts
[16:12:56.079]                           grepl <- base::grepl
[16:12:56.079]                           restarts <- computeRestarts(cond)
[16:12:56.079]                           for (restart in restarts) {
[16:12:56.079]                             name <- restart$name
[16:12:56.079]                             if (is.null(name)) 
[16:12:56.079]                               next
[16:12:56.079]                             if (!grepl(pattern, name)) 
[16:12:56.079]                               next
[16:12:56.079]                             invokeRestart(restart)
[16:12:56.079]                             muffled <- TRUE
[16:12:56.079]                             break
[16:12:56.079]                           }
[16:12:56.079]                         }
[16:12:56.079]                       }
[16:12:56.079]                       invisible(muffled)
[16:12:56.079]                     }
[16:12:56.079]                     muffleCondition(cond, pattern = "^muffle")
[16:12:56.079]                   }
[16:12:56.079]                 }
[16:12:56.079]                 else {
[16:12:56.079]                   if (TRUE) {
[16:12:56.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:56.079]                     {
[16:12:56.079]                       inherits <- base::inherits
[16:12:56.079]                       invokeRestart <- base::invokeRestart
[16:12:56.079]                       is.null <- base::is.null
[16:12:56.079]                       muffled <- FALSE
[16:12:56.079]                       if (inherits(cond, "message")) {
[16:12:56.079]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:56.079]                         if (muffled) 
[16:12:56.079]                           invokeRestart("muffleMessage")
[16:12:56.079]                       }
[16:12:56.079]                       else if (inherits(cond, "warning")) {
[16:12:56.079]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:56.079]                         if (muffled) 
[16:12:56.079]                           invokeRestart("muffleWarning")
[16:12:56.079]                       }
[16:12:56.079]                       else if (inherits(cond, "condition")) {
[16:12:56.079]                         if (!is.null(pattern)) {
[16:12:56.079]                           computeRestarts <- base::computeRestarts
[16:12:56.079]                           grepl <- base::grepl
[16:12:56.079]                           restarts <- computeRestarts(cond)
[16:12:56.079]                           for (restart in restarts) {
[16:12:56.079]                             name <- restart$name
[16:12:56.079]                             if (is.null(name)) 
[16:12:56.079]                               next
[16:12:56.079]                             if (!grepl(pattern, name)) 
[16:12:56.079]                               next
[16:12:56.079]                             invokeRestart(restart)
[16:12:56.079]                             muffled <- TRUE
[16:12:56.079]                             break
[16:12:56.079]                           }
[16:12:56.079]                         }
[16:12:56.079]                       }
[16:12:56.079]                       invisible(muffled)
[16:12:56.079]                     }
[16:12:56.079]                     muffleCondition(cond, pattern = "^muffle")
[16:12:56.079]                   }
[16:12:56.079]                 }
[16:12:56.079]             }
[16:12:56.079]         }))
[16:12:56.079]     }, error = function(ex) {
[16:12:56.079]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:56.079]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:56.079]                 ...future.rng), started = ...future.startTime, 
[16:12:56.079]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:56.079]             version = "1.8"), class = "FutureResult")
[16:12:56.079]     }, finally = {
[16:12:56.079]         if (!identical(...future.workdir, getwd())) 
[16:12:56.079]             setwd(...future.workdir)
[16:12:56.079]         {
[16:12:56.079]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:56.079]                 ...future.oldOptions$nwarnings <- NULL
[16:12:56.079]             }
[16:12:56.079]             base::options(...future.oldOptions)
[16:12:56.079]             if (.Platform$OS.type == "windows") {
[16:12:56.079]                 old_names <- names(...future.oldEnvVars)
[16:12:56.079]                 envs <- base::Sys.getenv()
[16:12:56.079]                 names <- names(envs)
[16:12:56.079]                 common <- intersect(names, old_names)
[16:12:56.079]                 added <- setdiff(names, old_names)
[16:12:56.079]                 removed <- setdiff(old_names, names)
[16:12:56.079]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:56.079]                   envs[common]]
[16:12:56.079]                 NAMES <- toupper(changed)
[16:12:56.079]                 args <- list()
[16:12:56.079]                 for (kk in seq_along(NAMES)) {
[16:12:56.079]                   name <- changed[[kk]]
[16:12:56.079]                   NAME <- NAMES[[kk]]
[16:12:56.079]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:56.079]                     next
[16:12:56.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:56.079]                 }
[16:12:56.079]                 NAMES <- toupper(added)
[16:12:56.079]                 for (kk in seq_along(NAMES)) {
[16:12:56.079]                   name <- added[[kk]]
[16:12:56.079]                   NAME <- NAMES[[kk]]
[16:12:56.079]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:56.079]                     next
[16:12:56.079]                   args[[name]] <- ""
[16:12:56.079]                 }
[16:12:56.079]                 NAMES <- toupper(removed)
[16:12:56.079]                 for (kk in seq_along(NAMES)) {
[16:12:56.079]                   name <- removed[[kk]]
[16:12:56.079]                   NAME <- NAMES[[kk]]
[16:12:56.079]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:56.079]                     next
[16:12:56.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:56.079]                 }
[16:12:56.079]                 if (length(args) > 0) 
[16:12:56.079]                   base::do.call(base::Sys.setenv, args = args)
[16:12:56.079]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:56.079]             }
[16:12:56.079]             else {
[16:12:56.079]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:56.079]             }
[16:12:56.079]             {
[16:12:56.079]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:56.079]                   0L) {
[16:12:56.079]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:56.079]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:56.079]                   base::options(opts)
[16:12:56.079]                 }
[16:12:56.079]                 {
[16:12:56.079]                   {
[16:12:56.079]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:56.079]                     NULL
[16:12:56.079]                   }
[16:12:56.079]                   options(future.plan = NULL)
[16:12:56.079]                   if (is.na(NA_character_)) 
[16:12:56.079]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:56.079]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:56.079]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:56.079]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:56.079]                     envir = parent.frame()) 
[16:12:56.079]                   {
[16:12:56.079]                     if (is.function(workers)) 
[16:12:56.079]                       workers <- workers()
[16:12:56.079]                     workers <- structure(as.integer(workers), 
[16:12:56.079]                       class = class(workers))
[16:12:56.079]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:56.079]                       workers >= 1)
[16:12:56.079]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:56.079]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:56.079]                     }
[16:12:56.079]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:56.079]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:56.079]                       envir = envir)
[16:12:56.079]                     if (!future$lazy) 
[16:12:56.079]                       future <- run(future)
[16:12:56.079]                     invisible(future)
[16:12:56.079]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:56.079]                 }
[16:12:56.079]             }
[16:12:56.079]         }
[16:12:56.079]     })
[16:12:56.079]     if (TRUE) {
[16:12:56.079]         base::sink(type = "output", split = FALSE)
[16:12:56.079]         if (TRUE) {
[16:12:56.079]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:56.079]         }
[16:12:56.079]         else {
[16:12:56.079]             ...future.result["stdout"] <- base::list(NULL)
[16:12:56.079]         }
[16:12:56.079]         base::close(...future.stdout)
[16:12:56.079]         ...future.stdout <- NULL
[16:12:56.079]     }
[16:12:56.079]     ...future.result$conditions <- ...future.conditions
[16:12:56.079]     ...future.result$finished <- base::Sys.time()
[16:12:56.079]     ...future.result
[16:12:56.079] }
[16:12:56.082] Exporting 1 global objects (1.55 MiB) to cluster node #1 ...
[16:12:56.084] Exporting ‘a’ (1.55 MiB) to cluster node #1 ...
[16:12:56.136] Exporting ‘a’ (1.55 MiB) to cluster node #1 ... DONE
[16:12:56.136] Exporting 1 global objects (1.55 MiB) to cluster node #1 ... DONE
[16:12:56.137] MultisessionFuture started
[16:12:56.137] - Launch lazy future ... done
[16:12:56.137] run() for ‘MultisessionFuture’ ... done
[16:12:56.137] result() for ClusterFuture ...
[16:12:56.137] receiveMessageFromWorker() for ClusterFuture ...
[16:12:56.138] - Validating connection of MultisessionFuture
[16:12:56.185] - received message: FutureResult
[16:12:56.186] - Received FutureResult
[16:12:56.186] - Erased future from FutureRegistry
[16:12:56.186] result() for ClusterFuture ...
[16:12:56.186] - result already collected: FutureResult
[16:12:56.186] result() for ClusterFuture ... done
[16:12:56.186] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:56.186] result() for ClusterFuture ... done
[16:12:56.186] result() for ClusterFuture ...
[16:12:56.186] - result already collected: FutureResult
[16:12:56.186] result() for ClusterFuture ... done
value(b) = 2
[16:12:56.187] result() for ClusterFuture ...
[16:12:56.187] - result already collected: FutureResult
[16:12:56.187] result() for ClusterFuture ... done
[16:12:56.187] result() for ClusterFuture ...
[16:12:56.187] - result already collected: FutureResult
[16:12:56.187] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:56.187] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:56.188] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:56.188] - globals found: [2] ‘{’, ‘pkg’
[16:12:56.189] Searching for globals ... DONE
[16:12:56.189] Resolving globals: TRUE
[16:12:56.189] Resolving any globals that are futures ...
[16:12:56.189] - globals: [2] ‘{’, ‘pkg’
[16:12:56.189] Resolving any globals that are futures ... DONE
[16:12:56.189] Resolving futures part of globals (recursively) ...
[16:12:56.190] resolve() on list ...
[16:12:56.190]  recursive: 99
[16:12:56.190]  length: 1
[16:12:56.190]  elements: ‘pkg’
[16:12:56.190]  length: 0 (resolved future 1)
[16:12:56.190] resolve() on list ... DONE
[16:12:56.190] - globals: [1] ‘pkg’
[16:12:56.190] Resolving futures part of globals (recursively) ... DONE
[16:12:56.190] The total size of the 1 globals is 112 bytes (112 bytes)
[16:12:56.191] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[16:12:56.191] - globals: [1] ‘pkg’
[16:12:56.191] 
[16:12:56.191] getGlobalsAndPackages() ... DONE
[16:12:56.191] Packages needed by the future expression (n = 0): <none>
[16:12:56.191] Packages needed by future strategies (n = 0): <none>
[16:12:56.192] {
[16:12:56.192]     {
[16:12:56.192]         {
[16:12:56.192]             ...future.startTime <- base::Sys.time()
[16:12:56.192]             {
[16:12:56.192]                 {
[16:12:56.192]                   {
[16:12:56.192]                     base::local({
[16:12:56.192]                       has_future <- base::requireNamespace("future", 
[16:12:56.192]                         quietly = TRUE)
[16:12:56.192]                       if (has_future) {
[16:12:56.192]                         ns <- base::getNamespace("future")
[16:12:56.192]                         version <- ns[[".package"]][["version"]]
[16:12:56.192]                         if (is.null(version)) 
[16:12:56.192]                           version <- utils::packageVersion("future")
[16:12:56.192]                       }
[16:12:56.192]                       else {
[16:12:56.192]                         version <- NULL
[16:12:56.192]                       }
[16:12:56.192]                       if (!has_future || version < "1.8.0") {
[16:12:56.192]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:56.192]                           "", base::R.version$version.string), 
[16:12:56.192]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:56.192]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:56.192]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:56.192]                             "release", "version")], collapse = " "), 
[16:12:56.192]                           hostname = base::Sys.info()[["nodename"]])
[16:12:56.192]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:56.192]                           info)
[16:12:56.192]                         info <- base::paste(info, collapse = "; ")
[16:12:56.192]                         if (!has_future) {
[16:12:56.192]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:56.192]                             info)
[16:12:56.192]                         }
[16:12:56.192]                         else {
[16:12:56.192]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:56.192]                             info, version)
[16:12:56.192]                         }
[16:12:56.192]                         base::stop(msg)
[16:12:56.192]                       }
[16:12:56.192]                     })
[16:12:56.192]                   }
[16:12:56.192]                   options(future.plan = NULL)
[16:12:56.192]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:56.192]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:56.192]                 }
[16:12:56.192]                 ...future.workdir <- getwd()
[16:12:56.192]             }
[16:12:56.192]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:56.192]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:56.192]         }
[16:12:56.192]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:56.192]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:56.192]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:56.192]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:56.192]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:56.192]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:56.192]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:56.192]             base::names(...future.oldOptions))
[16:12:56.192]     }
[16:12:56.192]     if (FALSE) {
[16:12:56.192]     }
[16:12:56.192]     else {
[16:12:56.192]         if (TRUE) {
[16:12:56.192]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:56.192]                 open = "w")
[16:12:56.192]         }
[16:12:56.192]         else {
[16:12:56.192]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:56.192]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:56.192]         }
[16:12:56.192]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:56.192]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:56.192]             base::sink(type = "output", split = FALSE)
[16:12:56.192]             base::close(...future.stdout)
[16:12:56.192]         }, add = TRUE)
[16:12:56.192]     }
[16:12:56.192]     ...future.frame <- base::sys.nframe()
[16:12:56.192]     ...future.conditions <- base::list()
[16:12:56.192]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:56.192]     if (FALSE) {
[16:12:56.192]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:56.192]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:56.192]     }
[16:12:56.192]     ...future.result <- base::tryCatch({
[16:12:56.192]         base::withCallingHandlers({
[16:12:56.192]             ...future.value <- base::withVisible(base::local({
[16:12:56.192]                 pkg
[16:12:56.192]             }))
[16:12:56.192]             future::FutureResult(value = ...future.value$value, 
[16:12:56.192]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:56.192]                   ...future.rng), globalenv = if (FALSE) 
[16:12:56.192]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:56.192]                     ...future.globalenv.names))
[16:12:56.192]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:56.192]         }, condition = base::local({
[16:12:56.192]             c <- base::c
[16:12:56.192]             inherits <- base::inherits
[16:12:56.192]             invokeRestart <- base::invokeRestart
[16:12:56.192]             length <- base::length
[16:12:56.192]             list <- base::list
[16:12:56.192]             seq.int <- base::seq.int
[16:12:56.192]             signalCondition <- base::signalCondition
[16:12:56.192]             sys.calls <- base::sys.calls
[16:12:56.192]             `[[` <- base::`[[`
[16:12:56.192]             `+` <- base::`+`
[16:12:56.192]             `<<-` <- base::`<<-`
[16:12:56.192]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:56.192]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:56.192]                   3L)]
[16:12:56.192]             }
[16:12:56.192]             function(cond) {
[16:12:56.192]                 is_error <- inherits(cond, "error")
[16:12:56.192]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:56.192]                   NULL)
[16:12:56.192]                 if (is_error) {
[16:12:56.192]                   sessionInformation <- function() {
[16:12:56.192]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:56.192]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:56.192]                       search = base::search(), system = base::Sys.info())
[16:12:56.192]                   }
[16:12:56.192]                   ...future.conditions[[length(...future.conditions) + 
[16:12:56.192]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:56.192]                     cond$call), session = sessionInformation(), 
[16:12:56.192]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:56.192]                   signalCondition(cond)
[16:12:56.192]                 }
[16:12:56.192]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:56.192]                 "immediateCondition"))) {
[16:12:56.192]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:56.192]                   ...future.conditions[[length(...future.conditions) + 
[16:12:56.192]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:56.192]                   if (TRUE && !signal) {
[16:12:56.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:56.192]                     {
[16:12:56.192]                       inherits <- base::inherits
[16:12:56.192]                       invokeRestart <- base::invokeRestart
[16:12:56.192]                       is.null <- base::is.null
[16:12:56.192]                       muffled <- FALSE
[16:12:56.192]                       if (inherits(cond, "message")) {
[16:12:56.192]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:56.192]                         if (muffled) 
[16:12:56.192]                           invokeRestart("muffleMessage")
[16:12:56.192]                       }
[16:12:56.192]                       else if (inherits(cond, "warning")) {
[16:12:56.192]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:56.192]                         if (muffled) 
[16:12:56.192]                           invokeRestart("muffleWarning")
[16:12:56.192]                       }
[16:12:56.192]                       else if (inherits(cond, "condition")) {
[16:12:56.192]                         if (!is.null(pattern)) {
[16:12:56.192]                           computeRestarts <- base::computeRestarts
[16:12:56.192]                           grepl <- base::grepl
[16:12:56.192]                           restarts <- computeRestarts(cond)
[16:12:56.192]                           for (restart in restarts) {
[16:12:56.192]                             name <- restart$name
[16:12:56.192]                             if (is.null(name)) 
[16:12:56.192]                               next
[16:12:56.192]                             if (!grepl(pattern, name)) 
[16:12:56.192]                               next
[16:12:56.192]                             invokeRestart(restart)
[16:12:56.192]                             muffled <- TRUE
[16:12:56.192]                             break
[16:12:56.192]                           }
[16:12:56.192]                         }
[16:12:56.192]                       }
[16:12:56.192]                       invisible(muffled)
[16:12:56.192]                     }
[16:12:56.192]                     muffleCondition(cond, pattern = "^muffle")
[16:12:56.192]                   }
[16:12:56.192]                 }
[16:12:56.192]                 else {
[16:12:56.192]                   if (TRUE) {
[16:12:56.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:56.192]                     {
[16:12:56.192]                       inherits <- base::inherits
[16:12:56.192]                       invokeRestart <- base::invokeRestart
[16:12:56.192]                       is.null <- base::is.null
[16:12:56.192]                       muffled <- FALSE
[16:12:56.192]                       if (inherits(cond, "message")) {
[16:12:56.192]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:56.192]                         if (muffled) 
[16:12:56.192]                           invokeRestart("muffleMessage")
[16:12:56.192]                       }
[16:12:56.192]                       else if (inherits(cond, "warning")) {
[16:12:56.192]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:56.192]                         if (muffled) 
[16:12:56.192]                           invokeRestart("muffleWarning")
[16:12:56.192]                       }
[16:12:56.192]                       else if (inherits(cond, "condition")) {
[16:12:56.192]                         if (!is.null(pattern)) {
[16:12:56.192]                           computeRestarts <- base::computeRestarts
[16:12:56.192]                           grepl <- base::grepl
[16:12:56.192]                           restarts <- computeRestarts(cond)
[16:12:56.192]                           for (restart in restarts) {
[16:12:56.192]                             name <- restart$name
[16:12:56.192]                             if (is.null(name)) 
[16:12:56.192]                               next
[16:12:56.192]                             if (!grepl(pattern, name)) 
[16:12:56.192]                               next
[16:12:56.192]                             invokeRestart(restart)
[16:12:56.192]                             muffled <- TRUE
[16:12:56.192]                             break
[16:12:56.192]                           }
[16:12:56.192]                         }
[16:12:56.192]                       }
[16:12:56.192]                       invisible(muffled)
[16:12:56.192]                     }
[16:12:56.192]                     muffleCondition(cond, pattern = "^muffle")
[16:12:56.192]                   }
[16:12:56.192]                 }
[16:12:56.192]             }
[16:12:56.192]         }))
[16:12:56.192]     }, error = function(ex) {
[16:12:56.192]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:56.192]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:56.192]                 ...future.rng), started = ...future.startTime, 
[16:12:56.192]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:56.192]             version = "1.8"), class = "FutureResult")
[16:12:56.192]     }, finally = {
[16:12:56.192]         if (!identical(...future.workdir, getwd())) 
[16:12:56.192]             setwd(...future.workdir)
[16:12:56.192]         {
[16:12:56.192]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:56.192]                 ...future.oldOptions$nwarnings <- NULL
[16:12:56.192]             }
[16:12:56.192]             base::options(...future.oldOptions)
[16:12:56.192]             if (.Platform$OS.type == "windows") {
[16:12:56.192]                 old_names <- names(...future.oldEnvVars)
[16:12:56.192]                 envs <- base::Sys.getenv()
[16:12:56.192]                 names <- names(envs)
[16:12:56.192]                 common <- intersect(names, old_names)
[16:12:56.192]                 added <- setdiff(names, old_names)
[16:12:56.192]                 removed <- setdiff(old_names, names)
[16:12:56.192]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:56.192]                   envs[common]]
[16:12:56.192]                 NAMES <- toupper(changed)
[16:12:56.192]                 args <- list()
[16:12:56.192]                 for (kk in seq_along(NAMES)) {
[16:12:56.192]                   name <- changed[[kk]]
[16:12:56.192]                   NAME <- NAMES[[kk]]
[16:12:56.192]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:56.192]                     next
[16:12:56.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:56.192]                 }
[16:12:56.192]                 NAMES <- toupper(added)
[16:12:56.192]                 for (kk in seq_along(NAMES)) {
[16:12:56.192]                   name <- added[[kk]]
[16:12:56.192]                   NAME <- NAMES[[kk]]
[16:12:56.192]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:56.192]                     next
[16:12:56.192]                   args[[name]] <- ""
[16:12:56.192]                 }
[16:12:56.192]                 NAMES <- toupper(removed)
[16:12:56.192]                 for (kk in seq_along(NAMES)) {
[16:12:56.192]                   name <- removed[[kk]]
[16:12:56.192]                   NAME <- NAMES[[kk]]
[16:12:56.192]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:56.192]                     next
[16:12:56.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:56.192]                 }
[16:12:56.192]                 if (length(args) > 0) 
[16:12:56.192]                   base::do.call(base::Sys.setenv, args = args)
[16:12:56.192]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:56.192]             }
[16:12:56.192]             else {
[16:12:56.192]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:56.192]             }
[16:12:56.192]             {
[16:12:56.192]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:56.192]                   0L) {
[16:12:56.192]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:56.192]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:56.192]                   base::options(opts)
[16:12:56.192]                 }
[16:12:56.192]                 {
[16:12:56.192]                   {
[16:12:56.192]                     NULL
[16:12:56.192]                     RNGkind("Mersenne-Twister")
[16:12:56.192]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:56.192]                       inherits = FALSE)
[16:12:56.192]                   }
[16:12:56.192]                   options(future.plan = NULL)
[16:12:56.192]                   if (is.na(NA_character_)) 
[16:12:56.192]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:56.192]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:56.192]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:56.192]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:56.192]                     envir = parent.frame()) 
[16:12:56.192]                   {
[16:12:56.192]                     if (is.function(workers)) 
[16:12:56.192]                       workers <- workers()
[16:12:56.192]                     workers <- structure(as.integer(workers), 
[16:12:56.192]                       class = class(workers))
[16:12:56.192]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:56.192]                       workers >= 1)
[16:12:56.192]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:56.192]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:56.192]                     }
[16:12:56.192]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:56.192]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:56.192]                       envir = envir)
[16:12:56.192]                     if (!future$lazy) 
[16:12:56.192]                       future <- run(future)
[16:12:56.192]                     invisible(future)
[16:12:56.192]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:56.192]                 }
[16:12:56.192]             }
[16:12:56.192]         }
[16:12:56.192]     })
[16:12:56.192]     if (TRUE) {
[16:12:56.192]         base::sink(type = "output", split = FALSE)
[16:12:56.192]         if (TRUE) {
[16:12:56.192]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:56.192]         }
[16:12:56.192]         else {
[16:12:56.192]             ...future.result["stdout"] <- base::list(NULL)
[16:12:56.192]         }
[16:12:56.192]         base::close(...future.stdout)
[16:12:56.192]         ...future.stdout <- NULL
[16:12:56.192]     }
[16:12:56.192]     ...future.result$conditions <- ...future.conditions
[16:12:56.192]     ...future.result$finished <- base::Sys.time()
[16:12:56.192]     ...future.result
[16:12:56.192] }
[16:12:56.194] assign_globals() ...
[16:12:56.194] List of 1
[16:12:56.194]  $ pkg: chr "foo"
[16:12:56.194]  - attr(*, "where")=List of 1
[16:12:56.194]   ..$ pkg:<environment: R_EmptyEnv> 
[16:12:56.194]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:56.194]  - attr(*, "resolved")= logi TRUE
[16:12:56.194]  - attr(*, "total_size")= num 112
[16:12:56.196] - copied ‘pkg’ to environment
[16:12:56.196] assign_globals() ... done
[16:12:56.196] plan(): Setting new future strategy stack:
[16:12:56.196] List of future strategies:
[16:12:56.196] 1. sequential:
[16:12:56.196]    - args: function (..., envir = parent.frame())
[16:12:56.196]    - tweaked: FALSE
[16:12:56.196]    - call: NULL
[16:12:56.197] plan(): nbrOfWorkers() = 1
[16:12:56.198] plan(): Setting new future strategy stack:
[16:12:56.198] List of future strategies:
[16:12:56.198] 1. multisession:
[16:12:56.198]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:12:56.198]    - tweaked: FALSE
[16:12:56.198]    - call: plan(strategy)
[16:12:56.201] plan(): nbrOfWorkers() = 2
[16:12:56.201] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:56.202] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:56.202] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:56.204] - globals found: [3] ‘{’, ‘<-’, ‘+’
[16:12:56.204] Searching for globals ... DONE
[16:12:56.204] Resolving globals: TRUE
[16:12:56.204] Resolving any globals that are futures ...
[16:12:56.204] - globals: [3] ‘{’, ‘<-’, ‘+’
[16:12:56.204] Resolving any globals that are futures ... DONE
[16:12:56.205] 
[16:12:56.205] 
[16:12:56.205] getGlobalsAndPackages() ... DONE
[16:12:56.205] run() for ‘Future’ ...
[16:12:56.205] - state: ‘created’
[16:12:56.205] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:56.220] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:56.220] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:56.221]   - Field: ‘node’
[16:12:56.221]   - Field: ‘label’
[16:12:56.221]   - Field: ‘local’
[16:12:56.221]   - Field: ‘owner’
[16:12:56.221]   - Field: ‘envir’
[16:12:56.221]   - Field: ‘workers’
[16:12:56.221]   - Field: ‘packages’
[16:12:56.221]   - Field: ‘gc’
[16:12:56.221]   - Field: ‘conditions’
[16:12:56.221]   - Field: ‘persistent’
[16:12:56.221]   - Field: ‘expr’
[16:12:56.222]   - Field: ‘uuid’
[16:12:56.222]   - Field: ‘seed’
[16:12:56.222]   - Field: ‘version’
[16:12:56.222]   - Field: ‘result’
[16:12:56.222]   - Field: ‘asynchronous’
[16:12:56.222]   - Field: ‘calls’
[16:12:56.222]   - Field: ‘globals’
[16:12:56.222]   - Field: ‘stdout’
[16:12:56.222]   - Field: ‘earlySignal’
[16:12:56.222]   - Field: ‘lazy’
[16:12:56.222]   - Field: ‘state’
[16:12:56.223] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:56.223] - Launch lazy future ...
[16:12:56.223] Packages needed by the future expression (n = 0): <none>
[16:12:56.223] Packages needed by future strategies (n = 0): <none>
[16:12:56.223] {
[16:12:56.223]     {
[16:12:56.223]         {
[16:12:56.223]             ...future.startTime <- base::Sys.time()
[16:12:56.223]             {
[16:12:56.223]                 {
[16:12:56.223]                   {
[16:12:56.223]                     {
[16:12:56.223]                       base::local({
[16:12:56.223]                         has_future <- base::requireNamespace("future", 
[16:12:56.223]                           quietly = TRUE)
[16:12:56.223]                         if (has_future) {
[16:12:56.223]                           ns <- base::getNamespace("future")
[16:12:56.223]                           version <- ns[[".package"]][["version"]]
[16:12:56.223]                           if (is.null(version)) 
[16:12:56.223]                             version <- utils::packageVersion("future")
[16:12:56.223]                         }
[16:12:56.223]                         else {
[16:12:56.223]                           version <- NULL
[16:12:56.223]                         }
[16:12:56.223]                         if (!has_future || version < "1.8.0") {
[16:12:56.223]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:56.223]                             "", base::R.version$version.string), 
[16:12:56.223]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:56.223]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:56.223]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:56.223]                               "release", "version")], collapse = " "), 
[16:12:56.223]                             hostname = base::Sys.info()[["nodename"]])
[16:12:56.223]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:56.223]                             info)
[16:12:56.223]                           info <- base::paste(info, collapse = "; ")
[16:12:56.223]                           if (!has_future) {
[16:12:56.223]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:56.223]                               info)
[16:12:56.223]                           }
[16:12:56.223]                           else {
[16:12:56.223]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:56.223]                               info, version)
[16:12:56.223]                           }
[16:12:56.223]                           base::stop(msg)
[16:12:56.223]                         }
[16:12:56.223]                       })
[16:12:56.223]                     }
[16:12:56.223]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:56.223]                     base::options(mc.cores = 1L)
[16:12:56.223]                   }
[16:12:56.223]                   options(future.plan = NULL)
[16:12:56.223]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:56.223]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:56.223]                 }
[16:12:56.223]                 ...future.workdir <- getwd()
[16:12:56.223]             }
[16:12:56.223]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:56.223]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:56.223]         }
[16:12:56.223]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:56.223]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:56.223]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:56.223]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:56.223]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:56.223]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:56.223]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:56.223]             base::names(...future.oldOptions))
[16:12:56.223]     }
[16:12:56.223]     if (FALSE) {
[16:12:56.223]     }
[16:12:56.223]     else {
[16:12:56.223]         if (TRUE) {
[16:12:56.223]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:56.223]                 open = "w")
[16:12:56.223]         }
[16:12:56.223]         else {
[16:12:56.223]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:56.223]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:56.223]         }
[16:12:56.223]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:56.223]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:56.223]             base::sink(type = "output", split = FALSE)
[16:12:56.223]             base::close(...future.stdout)
[16:12:56.223]         }, add = TRUE)
[16:12:56.223]     }
[16:12:56.223]     ...future.frame <- base::sys.nframe()
[16:12:56.223]     ...future.conditions <- base::list()
[16:12:56.223]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:56.223]     if (FALSE) {
[16:12:56.223]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:56.223]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:56.223]     }
[16:12:56.223]     ...future.result <- base::tryCatch({
[16:12:56.223]         base::withCallingHandlers({
[16:12:56.223]             ...future.value <- base::withVisible(base::local({
[16:12:56.223]                 ...future.makeSendCondition <- local({
[16:12:56.223]                   sendCondition <- NULL
[16:12:56.223]                   function(frame = 1L) {
[16:12:56.223]                     if (is.function(sendCondition)) 
[16:12:56.223]                       return(sendCondition)
[16:12:56.223]                     ns <- getNamespace("parallel")
[16:12:56.223]                     if (exists("sendData", mode = "function", 
[16:12:56.223]                       envir = ns)) {
[16:12:56.223]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:56.223]                         envir = ns)
[16:12:56.223]                       envir <- sys.frame(frame)
[16:12:56.223]                       master <- NULL
[16:12:56.223]                       while (!identical(envir, .GlobalEnv) && 
[16:12:56.223]                         !identical(envir, emptyenv())) {
[16:12:56.223]                         if (exists("master", mode = "list", envir = envir, 
[16:12:56.223]                           inherits = FALSE)) {
[16:12:56.223]                           master <- get("master", mode = "list", 
[16:12:56.223]                             envir = envir, inherits = FALSE)
[16:12:56.223]                           if (inherits(master, c("SOCKnode", 
[16:12:56.223]                             "SOCK0node"))) {
[16:12:56.223]                             sendCondition <<- function(cond) {
[16:12:56.223]                               data <- list(type = "VALUE", value = cond, 
[16:12:56.223]                                 success = TRUE)
[16:12:56.223]                               parallel_sendData(master, data)
[16:12:56.223]                             }
[16:12:56.223]                             return(sendCondition)
[16:12:56.223]                           }
[16:12:56.223]                         }
[16:12:56.223]                         frame <- frame + 1L
[16:12:56.223]                         envir <- sys.frame(frame)
[16:12:56.223]                       }
[16:12:56.223]                     }
[16:12:56.223]                     sendCondition <<- function(cond) NULL
[16:12:56.223]                   }
[16:12:56.223]                 })
[16:12:56.223]                 withCallingHandlers({
[16:12:56.223]                   {
[16:12:56.223]                     x <- 0
[16:12:56.223]                     x <- x + 1
[16:12:56.223]                     x
[16:12:56.223]                   }
[16:12:56.223]                 }, immediateCondition = function(cond) {
[16:12:56.223]                   sendCondition <- ...future.makeSendCondition()
[16:12:56.223]                   sendCondition(cond)
[16:12:56.223]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:56.223]                   {
[16:12:56.223]                     inherits <- base::inherits
[16:12:56.223]                     invokeRestart <- base::invokeRestart
[16:12:56.223]                     is.null <- base::is.null
[16:12:56.223]                     muffled <- FALSE
[16:12:56.223]                     if (inherits(cond, "message")) {
[16:12:56.223]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:56.223]                       if (muffled) 
[16:12:56.223]                         invokeRestart("muffleMessage")
[16:12:56.223]                     }
[16:12:56.223]                     else if (inherits(cond, "warning")) {
[16:12:56.223]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:56.223]                       if (muffled) 
[16:12:56.223]                         invokeRestart("muffleWarning")
[16:12:56.223]                     }
[16:12:56.223]                     else if (inherits(cond, "condition")) {
[16:12:56.223]                       if (!is.null(pattern)) {
[16:12:56.223]                         computeRestarts <- base::computeRestarts
[16:12:56.223]                         grepl <- base::grepl
[16:12:56.223]                         restarts <- computeRestarts(cond)
[16:12:56.223]                         for (restart in restarts) {
[16:12:56.223]                           name <- restart$name
[16:12:56.223]                           if (is.null(name)) 
[16:12:56.223]                             next
[16:12:56.223]                           if (!grepl(pattern, name)) 
[16:12:56.223]                             next
[16:12:56.223]                           invokeRestart(restart)
[16:12:56.223]                           muffled <- TRUE
[16:12:56.223]                           break
[16:12:56.223]                         }
[16:12:56.223]                       }
[16:12:56.223]                     }
[16:12:56.223]                     invisible(muffled)
[16:12:56.223]                   }
[16:12:56.223]                   muffleCondition(cond)
[16:12:56.223]                 })
[16:12:56.223]             }))
[16:12:56.223]             future::FutureResult(value = ...future.value$value, 
[16:12:56.223]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:56.223]                   ...future.rng), globalenv = if (FALSE) 
[16:12:56.223]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:56.223]                     ...future.globalenv.names))
[16:12:56.223]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:56.223]         }, condition = base::local({
[16:12:56.223]             c <- base::c
[16:12:56.223]             inherits <- base::inherits
[16:12:56.223]             invokeRestart <- base::invokeRestart
[16:12:56.223]             length <- base::length
[16:12:56.223]             list <- base::list
[16:12:56.223]             seq.int <- base::seq.int
[16:12:56.223]             signalCondition <- base::signalCondition
[16:12:56.223]             sys.calls <- base::sys.calls
[16:12:56.223]             `[[` <- base::`[[`
[16:12:56.223]             `+` <- base::`+`
[16:12:56.223]             `<<-` <- base::`<<-`
[16:12:56.223]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:56.223]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:56.223]                   3L)]
[16:12:56.223]             }
[16:12:56.223]             function(cond) {
[16:12:56.223]                 is_error <- inherits(cond, "error")
[16:12:56.223]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:56.223]                   NULL)
[16:12:56.223]                 if (is_error) {
[16:12:56.223]                   sessionInformation <- function() {
[16:12:56.223]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:56.223]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:56.223]                       search = base::search(), system = base::Sys.info())
[16:12:56.223]                   }
[16:12:56.223]                   ...future.conditions[[length(...future.conditions) + 
[16:12:56.223]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:56.223]                     cond$call), session = sessionInformation(), 
[16:12:56.223]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:56.223]                   signalCondition(cond)
[16:12:56.223]                 }
[16:12:56.223]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:56.223]                 "immediateCondition"))) {
[16:12:56.223]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:56.223]                   ...future.conditions[[length(...future.conditions) + 
[16:12:56.223]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:56.223]                   if (TRUE && !signal) {
[16:12:56.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:56.223]                     {
[16:12:56.223]                       inherits <- base::inherits
[16:12:56.223]                       invokeRestart <- base::invokeRestart
[16:12:56.223]                       is.null <- base::is.null
[16:12:56.223]                       muffled <- FALSE
[16:12:56.223]                       if (inherits(cond, "message")) {
[16:12:56.223]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:56.223]                         if (muffled) 
[16:12:56.223]                           invokeRestart("muffleMessage")
[16:12:56.223]                       }
[16:12:56.223]                       else if (inherits(cond, "warning")) {
[16:12:56.223]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:56.223]                         if (muffled) 
[16:12:56.223]                           invokeRestart("muffleWarning")
[16:12:56.223]                       }
[16:12:56.223]                       else if (inherits(cond, "condition")) {
[16:12:56.223]                         if (!is.null(pattern)) {
[16:12:56.223]                           computeRestarts <- base::computeRestarts
[16:12:56.223]                           grepl <- base::grepl
[16:12:56.223]                           restarts <- computeRestarts(cond)
[16:12:56.223]                           for (restart in restarts) {
[16:12:56.223]                             name <- restart$name
[16:12:56.223]                             if (is.null(name)) 
[16:12:56.223]                               next
[16:12:56.223]                             if (!grepl(pattern, name)) 
[16:12:56.223]                               next
[16:12:56.223]                             invokeRestart(restart)
[16:12:56.223]                             muffled <- TRUE
[16:12:56.223]                             break
[16:12:56.223]                           }
[16:12:56.223]                         }
[16:12:56.223]                       }
[16:12:56.223]                       invisible(muffled)
[16:12:56.223]                     }
[16:12:56.223]                     muffleCondition(cond, pattern = "^muffle")
[16:12:56.223]                   }
[16:12:56.223]                 }
[16:12:56.223]                 else {
[16:12:56.223]                   if (TRUE) {
[16:12:56.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:56.223]                     {
[16:12:56.223]                       inherits <- base::inherits
[16:12:56.223]                       invokeRestart <- base::invokeRestart
[16:12:56.223]                       is.null <- base::is.null
[16:12:56.223]                       muffled <- FALSE
[16:12:56.223]                       if (inherits(cond, "message")) {
[16:12:56.223]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:56.223]                         if (muffled) 
[16:12:56.223]                           invokeRestart("muffleMessage")
[16:12:56.223]                       }
[16:12:56.223]                       else if (inherits(cond, "warning")) {
[16:12:56.223]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:56.223]                         if (muffled) 
[16:12:56.223]                           invokeRestart("muffleWarning")
[16:12:56.223]                       }
[16:12:56.223]                       else if (inherits(cond, "condition")) {
[16:12:56.223]                         if (!is.null(pattern)) {
[16:12:56.223]                           computeRestarts <- base::computeRestarts
[16:12:56.223]                           grepl <- base::grepl
[16:12:56.223]                           restarts <- computeRestarts(cond)
[16:12:56.223]                           for (restart in restarts) {
[16:12:56.223]                             name <- restart$name
[16:12:56.223]                             if (is.null(name)) 
[16:12:56.223]                               next
[16:12:56.223]                             if (!grepl(pattern, name)) 
[16:12:56.223]                               next
[16:12:56.223]                             invokeRestart(restart)
[16:12:56.223]                             muffled <- TRUE
[16:12:56.223]                             break
[16:12:56.223]                           }
[16:12:56.223]                         }
[16:12:56.223]                       }
[16:12:56.223]                       invisible(muffled)
[16:12:56.223]                     }
[16:12:56.223]                     muffleCondition(cond, pattern = "^muffle")
[16:12:56.223]                   }
[16:12:56.223]                 }
[16:12:56.223]             }
[16:12:56.223]         }))
[16:12:56.223]     }, error = function(ex) {
[16:12:56.223]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:56.223]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:56.223]                 ...future.rng), started = ...future.startTime, 
[16:12:56.223]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:56.223]             version = "1.8"), class = "FutureResult")
[16:12:56.223]     }, finally = {
[16:12:56.223]         if (!identical(...future.workdir, getwd())) 
[16:12:56.223]             setwd(...future.workdir)
[16:12:56.223]         {
[16:12:56.223]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:56.223]                 ...future.oldOptions$nwarnings <- NULL
[16:12:56.223]             }
[16:12:56.223]             base::options(...future.oldOptions)
[16:12:56.223]             if (.Platform$OS.type == "windows") {
[16:12:56.223]                 old_names <- names(...future.oldEnvVars)
[16:12:56.223]                 envs <- base::Sys.getenv()
[16:12:56.223]                 names <- names(envs)
[16:12:56.223]                 common <- intersect(names, old_names)
[16:12:56.223]                 added <- setdiff(names, old_names)
[16:12:56.223]                 removed <- setdiff(old_names, names)
[16:12:56.223]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:56.223]                   envs[common]]
[16:12:56.223]                 NAMES <- toupper(changed)
[16:12:56.223]                 args <- list()
[16:12:56.223]                 for (kk in seq_along(NAMES)) {
[16:12:56.223]                   name <- changed[[kk]]
[16:12:56.223]                   NAME <- NAMES[[kk]]
[16:12:56.223]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:56.223]                     next
[16:12:56.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:56.223]                 }
[16:12:56.223]                 NAMES <- toupper(added)
[16:12:56.223]                 for (kk in seq_along(NAMES)) {
[16:12:56.223]                   name <- added[[kk]]
[16:12:56.223]                   NAME <- NAMES[[kk]]
[16:12:56.223]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:56.223]                     next
[16:12:56.223]                   args[[name]] <- ""
[16:12:56.223]                 }
[16:12:56.223]                 NAMES <- toupper(removed)
[16:12:56.223]                 for (kk in seq_along(NAMES)) {
[16:12:56.223]                   name <- removed[[kk]]
[16:12:56.223]                   NAME <- NAMES[[kk]]
[16:12:56.223]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:56.223]                     next
[16:12:56.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:56.223]                 }
[16:12:56.223]                 if (length(args) > 0) 
[16:12:56.223]                   base::do.call(base::Sys.setenv, args = args)
[16:12:56.223]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:56.223]             }
[16:12:56.223]             else {
[16:12:56.223]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:56.223]             }
[16:12:56.223]             {
[16:12:56.223]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:56.223]                   0L) {
[16:12:56.223]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:56.223]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:56.223]                   base::options(opts)
[16:12:56.223]                 }
[16:12:56.223]                 {
[16:12:56.223]                   {
[16:12:56.223]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:56.223]                     NULL
[16:12:56.223]                   }
[16:12:56.223]                   options(future.plan = NULL)
[16:12:56.223]                   if (is.na(NA_character_)) 
[16:12:56.223]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:56.223]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:56.223]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:56.223]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:56.223]                     envir = parent.frame()) 
[16:12:56.223]                   {
[16:12:56.223]                     if (is.function(workers)) 
[16:12:56.223]                       workers <- workers()
[16:12:56.223]                     workers <- structure(as.integer(workers), 
[16:12:56.223]                       class = class(workers))
[16:12:56.223]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:56.223]                       workers >= 1)
[16:12:56.223]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:56.223]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:56.223]                     }
[16:12:56.223]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:56.223]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:56.223]                       envir = envir)
[16:12:56.223]                     if (!future$lazy) 
[16:12:56.223]                       future <- run(future)
[16:12:56.223]                     invisible(future)
[16:12:56.223]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:56.223]                 }
[16:12:56.223]             }
[16:12:56.223]         }
[16:12:56.223]     })
[16:12:56.223]     if (TRUE) {
[16:12:56.223]         base::sink(type = "output", split = FALSE)
[16:12:56.223]         if (TRUE) {
[16:12:56.223]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:56.223]         }
[16:12:56.223]         else {
[16:12:56.223]             ...future.result["stdout"] <- base::list(NULL)
[16:12:56.223]         }
[16:12:56.223]         base::close(...future.stdout)
[16:12:56.223]         ...future.stdout <- NULL
[16:12:56.223]     }
[16:12:56.223]     ...future.result$conditions <- ...future.conditions
[16:12:56.223]     ...future.result$finished <- base::Sys.time()
[16:12:56.223]     ...future.result
[16:12:56.223] }
[16:12:56.227] MultisessionFuture started
[16:12:56.227] - Launch lazy future ... done
[16:12:56.227] run() for ‘MultisessionFuture’ ... done
[16:12:56.227] result() for ClusterFuture ...
[16:12:56.227] receiveMessageFromWorker() for ClusterFuture ...
[16:12:56.227] - Validating connection of MultisessionFuture
[16:12:56.273] - received message: FutureResult
[16:12:56.273] - Received FutureResult
[16:12:56.274] - Erased future from FutureRegistry
[16:12:56.274] result() for ClusterFuture ...
[16:12:56.274] - result already collected: FutureResult
[16:12:56.274] result() for ClusterFuture ... done
[16:12:56.274] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:56.274] result() for ClusterFuture ... done
[16:12:56.274] result() for ClusterFuture ...
[16:12:56.274] - result already collected: FutureResult
[16:12:56.274] result() for ClusterFuture ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:56.275] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:56.275] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:56.276] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[16:12:56.277] Searching for globals ... DONE
[16:12:56.277] Resolving globals: TRUE
[16:12:56.277] Resolving any globals that are futures ...
[16:12:56.277] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[16:12:56.277] Resolving any globals that are futures ... DONE
[16:12:56.277] Resolving futures part of globals (recursively) ...
[16:12:56.278] resolve() on list ...
[16:12:56.278]  recursive: 99
[16:12:56.278]  length: 1
[16:12:56.278]  elements: ‘x’
[16:12:56.278]  length: 0 (resolved future 1)
[16:12:56.278] resolve() on list ... DONE
[16:12:56.278] - globals: [1] ‘x’
[16:12:56.278] Resolving futures part of globals (recursively) ... DONE
[16:12:56.278] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:56.279] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[16:12:56.279] - globals: [1] ‘x’
[16:12:56.279] 
[16:12:56.279] getGlobalsAndPackages() ... DONE
[16:12:56.279] run() for ‘Future’ ...
[16:12:56.279] - state: ‘created’
[16:12:56.279] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:56.294] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:56.294] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:56.294]   - Field: ‘node’
[16:12:56.294]   - Field: ‘label’
[16:12:56.294]   - Field: ‘local’
[16:12:56.294]   - Field: ‘owner’
[16:12:56.295]   - Field: ‘envir’
[16:12:56.295]   - Field: ‘workers’
[16:12:56.295]   - Field: ‘packages’
[16:12:56.295]   - Field: ‘gc’
[16:12:56.295]   - Field: ‘conditions’
[16:12:56.295]   - Field: ‘persistent’
[16:12:56.295]   - Field: ‘expr’
[16:12:56.295]   - Field: ‘uuid’
[16:12:56.295]   - Field: ‘seed’
[16:12:56.295]   - Field: ‘version’
[16:12:56.295]   - Field: ‘result’
[16:12:56.296]   - Field: ‘asynchronous’
[16:12:56.296]   - Field: ‘calls’
[16:12:56.296]   - Field: ‘globals’
[16:12:56.296]   - Field: ‘stdout’
[16:12:56.296]   - Field: ‘earlySignal’
[16:12:56.296]   - Field: ‘lazy’
[16:12:56.296]   - Field: ‘state’
[16:12:56.296] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:56.296] - Launch lazy future ...
[16:12:56.297] Packages needed by the future expression (n = 0): <none>
[16:12:56.297] Packages needed by future strategies (n = 0): <none>
[16:12:56.297] {
[16:12:56.297]     {
[16:12:56.297]         {
[16:12:56.297]             ...future.startTime <- base::Sys.time()
[16:12:56.297]             {
[16:12:56.297]                 {
[16:12:56.297]                   {
[16:12:56.297]                     {
[16:12:56.297]                       base::local({
[16:12:56.297]                         has_future <- base::requireNamespace("future", 
[16:12:56.297]                           quietly = TRUE)
[16:12:56.297]                         if (has_future) {
[16:12:56.297]                           ns <- base::getNamespace("future")
[16:12:56.297]                           version <- ns[[".package"]][["version"]]
[16:12:56.297]                           if (is.null(version)) 
[16:12:56.297]                             version <- utils::packageVersion("future")
[16:12:56.297]                         }
[16:12:56.297]                         else {
[16:12:56.297]                           version <- NULL
[16:12:56.297]                         }
[16:12:56.297]                         if (!has_future || version < "1.8.0") {
[16:12:56.297]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:56.297]                             "", base::R.version$version.string), 
[16:12:56.297]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:56.297]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:56.297]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:56.297]                               "release", "version")], collapse = " "), 
[16:12:56.297]                             hostname = base::Sys.info()[["nodename"]])
[16:12:56.297]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:56.297]                             info)
[16:12:56.297]                           info <- base::paste(info, collapse = "; ")
[16:12:56.297]                           if (!has_future) {
[16:12:56.297]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:56.297]                               info)
[16:12:56.297]                           }
[16:12:56.297]                           else {
[16:12:56.297]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:56.297]                               info, version)
[16:12:56.297]                           }
[16:12:56.297]                           base::stop(msg)
[16:12:56.297]                         }
[16:12:56.297]                       })
[16:12:56.297]                     }
[16:12:56.297]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:56.297]                     base::options(mc.cores = 1L)
[16:12:56.297]                   }
[16:12:56.297]                   options(future.plan = NULL)
[16:12:56.297]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:56.297]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:56.297]                 }
[16:12:56.297]                 ...future.workdir <- getwd()
[16:12:56.297]             }
[16:12:56.297]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:56.297]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:56.297]         }
[16:12:56.297]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:56.297]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:56.297]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:56.297]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:56.297]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:56.297]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:56.297]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:56.297]             base::names(...future.oldOptions))
[16:12:56.297]     }
[16:12:56.297]     if (FALSE) {
[16:12:56.297]     }
[16:12:56.297]     else {
[16:12:56.297]         if (TRUE) {
[16:12:56.297]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:56.297]                 open = "w")
[16:12:56.297]         }
[16:12:56.297]         else {
[16:12:56.297]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:56.297]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:56.297]         }
[16:12:56.297]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:56.297]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:56.297]             base::sink(type = "output", split = FALSE)
[16:12:56.297]             base::close(...future.stdout)
[16:12:56.297]         }, add = TRUE)
[16:12:56.297]     }
[16:12:56.297]     ...future.frame <- base::sys.nframe()
[16:12:56.297]     ...future.conditions <- base::list()
[16:12:56.297]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:56.297]     if (FALSE) {
[16:12:56.297]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:56.297]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:56.297]     }
[16:12:56.297]     ...future.result <- base::tryCatch({
[16:12:56.297]         base::withCallingHandlers({
[16:12:56.297]             ...future.value <- base::withVisible(base::local({
[16:12:56.297]                 ...future.makeSendCondition <- local({
[16:12:56.297]                   sendCondition <- NULL
[16:12:56.297]                   function(frame = 1L) {
[16:12:56.297]                     if (is.function(sendCondition)) 
[16:12:56.297]                       return(sendCondition)
[16:12:56.297]                     ns <- getNamespace("parallel")
[16:12:56.297]                     if (exists("sendData", mode = "function", 
[16:12:56.297]                       envir = ns)) {
[16:12:56.297]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:56.297]                         envir = ns)
[16:12:56.297]                       envir <- sys.frame(frame)
[16:12:56.297]                       master <- NULL
[16:12:56.297]                       while (!identical(envir, .GlobalEnv) && 
[16:12:56.297]                         !identical(envir, emptyenv())) {
[16:12:56.297]                         if (exists("master", mode = "list", envir = envir, 
[16:12:56.297]                           inherits = FALSE)) {
[16:12:56.297]                           master <- get("master", mode = "list", 
[16:12:56.297]                             envir = envir, inherits = FALSE)
[16:12:56.297]                           if (inherits(master, c("SOCKnode", 
[16:12:56.297]                             "SOCK0node"))) {
[16:12:56.297]                             sendCondition <<- function(cond) {
[16:12:56.297]                               data <- list(type = "VALUE", value = cond, 
[16:12:56.297]                                 success = TRUE)
[16:12:56.297]                               parallel_sendData(master, data)
[16:12:56.297]                             }
[16:12:56.297]                             return(sendCondition)
[16:12:56.297]                           }
[16:12:56.297]                         }
[16:12:56.297]                         frame <- frame + 1L
[16:12:56.297]                         envir <- sys.frame(frame)
[16:12:56.297]                       }
[16:12:56.297]                     }
[16:12:56.297]                     sendCondition <<- function(cond) NULL
[16:12:56.297]                   }
[16:12:56.297]                 })
[16:12:56.297]                 withCallingHandlers({
[16:12:56.297]                   {
[16:12:56.297]                     x <- x + 1
[16:12:56.297]                     x
[16:12:56.297]                   }
[16:12:56.297]                 }, immediateCondition = function(cond) {
[16:12:56.297]                   sendCondition <- ...future.makeSendCondition()
[16:12:56.297]                   sendCondition(cond)
[16:12:56.297]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:56.297]                   {
[16:12:56.297]                     inherits <- base::inherits
[16:12:56.297]                     invokeRestart <- base::invokeRestart
[16:12:56.297]                     is.null <- base::is.null
[16:12:56.297]                     muffled <- FALSE
[16:12:56.297]                     if (inherits(cond, "message")) {
[16:12:56.297]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:56.297]                       if (muffled) 
[16:12:56.297]                         invokeRestart("muffleMessage")
[16:12:56.297]                     }
[16:12:56.297]                     else if (inherits(cond, "warning")) {
[16:12:56.297]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:56.297]                       if (muffled) 
[16:12:56.297]                         invokeRestart("muffleWarning")
[16:12:56.297]                     }
[16:12:56.297]                     else if (inherits(cond, "condition")) {
[16:12:56.297]                       if (!is.null(pattern)) {
[16:12:56.297]                         computeRestarts <- base::computeRestarts
[16:12:56.297]                         grepl <- base::grepl
[16:12:56.297]                         restarts <- computeRestarts(cond)
[16:12:56.297]                         for (restart in restarts) {
[16:12:56.297]                           name <- restart$name
[16:12:56.297]                           if (is.null(name)) 
[16:12:56.297]                             next
[16:12:56.297]                           if (!grepl(pattern, name)) 
[16:12:56.297]                             next
[16:12:56.297]                           invokeRestart(restart)
[16:12:56.297]                           muffled <- TRUE
[16:12:56.297]                           break
[16:12:56.297]                         }
[16:12:56.297]                       }
[16:12:56.297]                     }
[16:12:56.297]                     invisible(muffled)
[16:12:56.297]                   }
[16:12:56.297]                   muffleCondition(cond)
[16:12:56.297]                 })
[16:12:56.297]             }))
[16:12:56.297]             future::FutureResult(value = ...future.value$value, 
[16:12:56.297]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:56.297]                   ...future.rng), globalenv = if (FALSE) 
[16:12:56.297]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:56.297]                     ...future.globalenv.names))
[16:12:56.297]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:56.297]         }, condition = base::local({
[16:12:56.297]             c <- base::c
[16:12:56.297]             inherits <- base::inherits
[16:12:56.297]             invokeRestart <- base::invokeRestart
[16:12:56.297]             length <- base::length
[16:12:56.297]             list <- base::list
[16:12:56.297]             seq.int <- base::seq.int
[16:12:56.297]             signalCondition <- base::signalCondition
[16:12:56.297]             sys.calls <- base::sys.calls
[16:12:56.297]             `[[` <- base::`[[`
[16:12:56.297]             `+` <- base::`+`
[16:12:56.297]             `<<-` <- base::`<<-`
[16:12:56.297]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:56.297]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:56.297]                   3L)]
[16:12:56.297]             }
[16:12:56.297]             function(cond) {
[16:12:56.297]                 is_error <- inherits(cond, "error")
[16:12:56.297]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:56.297]                   NULL)
[16:12:56.297]                 if (is_error) {
[16:12:56.297]                   sessionInformation <- function() {
[16:12:56.297]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:56.297]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:56.297]                       search = base::search(), system = base::Sys.info())
[16:12:56.297]                   }
[16:12:56.297]                   ...future.conditions[[length(...future.conditions) + 
[16:12:56.297]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:56.297]                     cond$call), session = sessionInformation(), 
[16:12:56.297]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:56.297]                   signalCondition(cond)
[16:12:56.297]                 }
[16:12:56.297]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:56.297]                 "immediateCondition"))) {
[16:12:56.297]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:56.297]                   ...future.conditions[[length(...future.conditions) + 
[16:12:56.297]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:56.297]                   if (TRUE && !signal) {
[16:12:56.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:56.297]                     {
[16:12:56.297]                       inherits <- base::inherits
[16:12:56.297]                       invokeRestart <- base::invokeRestart
[16:12:56.297]                       is.null <- base::is.null
[16:12:56.297]                       muffled <- FALSE
[16:12:56.297]                       if (inherits(cond, "message")) {
[16:12:56.297]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:56.297]                         if (muffled) 
[16:12:56.297]                           invokeRestart("muffleMessage")
[16:12:56.297]                       }
[16:12:56.297]                       else if (inherits(cond, "warning")) {
[16:12:56.297]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:56.297]                         if (muffled) 
[16:12:56.297]                           invokeRestart("muffleWarning")
[16:12:56.297]                       }
[16:12:56.297]                       else if (inherits(cond, "condition")) {
[16:12:56.297]                         if (!is.null(pattern)) {
[16:12:56.297]                           computeRestarts <- base::computeRestarts
[16:12:56.297]                           grepl <- base::grepl
[16:12:56.297]                           restarts <- computeRestarts(cond)
[16:12:56.297]                           for (restart in restarts) {
[16:12:56.297]                             name <- restart$name
[16:12:56.297]                             if (is.null(name)) 
[16:12:56.297]                               next
[16:12:56.297]                             if (!grepl(pattern, name)) 
[16:12:56.297]                               next
[16:12:56.297]                             invokeRestart(restart)
[16:12:56.297]                             muffled <- TRUE
[16:12:56.297]                             break
[16:12:56.297]                           }
[16:12:56.297]                         }
[16:12:56.297]                       }
[16:12:56.297]                       invisible(muffled)
[16:12:56.297]                     }
[16:12:56.297]                     muffleCondition(cond, pattern = "^muffle")
[16:12:56.297]                   }
[16:12:56.297]                 }
[16:12:56.297]                 else {
[16:12:56.297]                   if (TRUE) {
[16:12:56.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:56.297]                     {
[16:12:56.297]                       inherits <- base::inherits
[16:12:56.297]                       invokeRestart <- base::invokeRestart
[16:12:56.297]                       is.null <- base::is.null
[16:12:56.297]                       muffled <- FALSE
[16:12:56.297]                       if (inherits(cond, "message")) {
[16:12:56.297]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:56.297]                         if (muffled) 
[16:12:56.297]                           invokeRestart("muffleMessage")
[16:12:56.297]                       }
[16:12:56.297]                       else if (inherits(cond, "warning")) {
[16:12:56.297]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:56.297]                         if (muffled) 
[16:12:56.297]                           invokeRestart("muffleWarning")
[16:12:56.297]                       }
[16:12:56.297]                       else if (inherits(cond, "condition")) {
[16:12:56.297]                         if (!is.null(pattern)) {
[16:12:56.297]                           computeRestarts <- base::computeRestarts
[16:12:56.297]                           grepl <- base::grepl
[16:12:56.297]                           restarts <- computeRestarts(cond)
[16:12:56.297]                           for (restart in restarts) {
[16:12:56.297]                             name <- restart$name
[16:12:56.297]                             if (is.null(name)) 
[16:12:56.297]                               next
[16:12:56.297]                             if (!grepl(pattern, name)) 
[16:12:56.297]                               next
[16:12:56.297]                             invokeRestart(restart)
[16:12:56.297]                             muffled <- TRUE
[16:12:56.297]                             break
[16:12:56.297]                           }
[16:12:56.297]                         }
[16:12:56.297]                       }
[16:12:56.297]                       invisible(muffled)
[16:12:56.297]                     }
[16:12:56.297]                     muffleCondition(cond, pattern = "^muffle")
[16:12:56.297]                   }
[16:12:56.297]                 }
[16:12:56.297]             }
[16:12:56.297]         }))
[16:12:56.297]     }, error = function(ex) {
[16:12:56.297]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:56.297]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:56.297]                 ...future.rng), started = ...future.startTime, 
[16:12:56.297]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:56.297]             version = "1.8"), class = "FutureResult")
[16:12:56.297]     }, finally = {
[16:12:56.297]         if (!identical(...future.workdir, getwd())) 
[16:12:56.297]             setwd(...future.workdir)
[16:12:56.297]         {
[16:12:56.297]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:56.297]                 ...future.oldOptions$nwarnings <- NULL
[16:12:56.297]             }
[16:12:56.297]             base::options(...future.oldOptions)
[16:12:56.297]             if (.Platform$OS.type == "windows") {
[16:12:56.297]                 old_names <- names(...future.oldEnvVars)
[16:12:56.297]                 envs <- base::Sys.getenv()
[16:12:56.297]                 names <- names(envs)
[16:12:56.297]                 common <- intersect(names, old_names)
[16:12:56.297]                 added <- setdiff(names, old_names)
[16:12:56.297]                 removed <- setdiff(old_names, names)
[16:12:56.297]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:56.297]                   envs[common]]
[16:12:56.297]                 NAMES <- toupper(changed)
[16:12:56.297]                 args <- list()
[16:12:56.297]                 for (kk in seq_along(NAMES)) {
[16:12:56.297]                   name <- changed[[kk]]
[16:12:56.297]                   NAME <- NAMES[[kk]]
[16:12:56.297]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:56.297]                     next
[16:12:56.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:56.297]                 }
[16:12:56.297]                 NAMES <- toupper(added)
[16:12:56.297]                 for (kk in seq_along(NAMES)) {
[16:12:56.297]                   name <- added[[kk]]
[16:12:56.297]                   NAME <- NAMES[[kk]]
[16:12:56.297]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:56.297]                     next
[16:12:56.297]                   args[[name]] <- ""
[16:12:56.297]                 }
[16:12:56.297]                 NAMES <- toupper(removed)
[16:12:56.297]                 for (kk in seq_along(NAMES)) {
[16:12:56.297]                   name <- removed[[kk]]
[16:12:56.297]                   NAME <- NAMES[[kk]]
[16:12:56.297]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:56.297]                     next
[16:12:56.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:56.297]                 }
[16:12:56.297]                 if (length(args) > 0) 
[16:12:56.297]                   base::do.call(base::Sys.setenv, args = args)
[16:12:56.297]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:56.297]             }
[16:12:56.297]             else {
[16:12:56.297]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:56.297]             }
[16:12:56.297]             {
[16:12:56.297]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:56.297]                   0L) {
[16:12:56.297]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:56.297]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:56.297]                   base::options(opts)
[16:12:56.297]                 }
[16:12:56.297]                 {
[16:12:56.297]                   {
[16:12:56.297]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:56.297]                     NULL
[16:12:56.297]                   }
[16:12:56.297]                   options(future.plan = NULL)
[16:12:56.297]                   if (is.na(NA_character_)) 
[16:12:56.297]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:56.297]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:56.297]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:56.297]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:56.297]                     envir = parent.frame()) 
[16:12:56.297]                   {
[16:12:56.297]                     if (is.function(workers)) 
[16:12:56.297]                       workers <- workers()
[16:12:56.297]                     workers <- structure(as.integer(workers), 
[16:12:56.297]                       class = class(workers))
[16:12:56.297]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:56.297]                       workers >= 1)
[16:12:56.297]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:56.297]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:56.297]                     }
[16:12:56.297]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:56.297]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:56.297]                       envir = envir)
[16:12:56.297]                     if (!future$lazy) 
[16:12:56.297]                       future <- run(future)
[16:12:56.297]                     invisible(future)
[16:12:56.297]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:56.297]                 }
[16:12:56.297]             }
[16:12:56.297]         }
[16:12:56.297]     })
[16:12:56.297]     if (TRUE) {
[16:12:56.297]         base::sink(type = "output", split = FALSE)
[16:12:56.297]         if (TRUE) {
[16:12:56.297]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:56.297]         }
[16:12:56.297]         else {
[16:12:56.297]             ...future.result["stdout"] <- base::list(NULL)
[16:12:56.297]         }
[16:12:56.297]         base::close(...future.stdout)
[16:12:56.297]         ...future.stdout <- NULL
[16:12:56.297]     }
[16:12:56.297]     ...future.result$conditions <- ...future.conditions
[16:12:56.297]     ...future.result$finished <- base::Sys.time()
[16:12:56.297]     ...future.result
[16:12:56.297] }
[16:12:56.300] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:12:56.300] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[16:12:56.300] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[16:12:56.301] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:12:56.301] MultisessionFuture started
[16:12:56.301] - Launch lazy future ... done
[16:12:56.301] run() for ‘MultisessionFuture’ ... done
[16:12:56.301] result() for ClusterFuture ...
[16:12:56.301] receiveMessageFromWorker() for ClusterFuture ...
[16:12:56.302] - Validating connection of MultisessionFuture
[16:12:56.349] - received message: FutureResult
[16:12:56.349] - Received FutureResult
[16:12:56.349] - Erased future from FutureRegistry
[16:12:56.349] result() for ClusterFuture ...
[16:12:56.349] - result already collected: FutureResult
[16:12:56.349] result() for ClusterFuture ... done
[16:12:56.349] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:56.349] result() for ClusterFuture ... done
[16:12:56.350] result() for ClusterFuture ...
[16:12:56.350] - result already collected: FutureResult
[16:12:56.350] result() for ClusterFuture ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[16:12:56.350] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[16:12:56.350] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[16:12:56.352] - globals found: [3] ‘{’, ‘<-’, ‘x’
[16:12:56.352] Searching for globals ... DONE
[16:12:56.352] Resolving globals: TRUE
[16:12:56.352] Resolving any globals that are futures ...
[16:12:56.352] - globals: [3] ‘{’, ‘<-’, ‘x’
[16:12:56.353] Resolving any globals that are futures ... DONE
[16:12:56.353] Resolving futures part of globals (recursively) ...
[16:12:56.353] resolve() on list ...
[16:12:56.353]  recursive: 99
[16:12:56.353]  length: 1
[16:12:56.353]  elements: ‘x’
[16:12:56.353]  length: 0 (resolved future 1)
[16:12:56.354] resolve() on list ... DONE
[16:12:56.354] - globals: [1] ‘x’
[16:12:56.354] Resolving futures part of globals (recursively) ... DONE
[16:12:56.354] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[16:12:56.354] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[16:12:56.354] - globals: [1] ‘x’
[16:12:56.355] 
[16:12:56.355] getGlobalsAndPackages() ... DONE
[16:12:56.355] run() for ‘Future’ ...
[16:12:56.355] - state: ‘created’
[16:12:56.355] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:56.369] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:56.370] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:56.370]   - Field: ‘node’
[16:12:56.370]   - Field: ‘label’
[16:12:56.370]   - Field: ‘local’
[16:12:56.370]   - Field: ‘owner’
[16:12:56.370]   - Field: ‘envir’
[16:12:56.370]   - Field: ‘workers’
[16:12:56.370]   - Field: ‘packages’
[16:12:56.370]   - Field: ‘gc’
[16:12:56.371]   - Field: ‘conditions’
[16:12:56.371]   - Field: ‘persistent’
[16:12:56.371]   - Field: ‘expr’
[16:12:56.371]   - Field: ‘uuid’
[16:12:56.371]   - Field: ‘seed’
[16:12:56.371]   - Field: ‘version’
[16:12:56.371]   - Field: ‘result’
[16:12:56.371]   - Field: ‘asynchronous’
[16:12:56.371]   - Field: ‘calls’
[16:12:56.371]   - Field: ‘globals’
[16:12:56.371]   - Field: ‘stdout’
[16:12:56.371]   - Field: ‘earlySignal’
[16:12:56.372]   - Field: ‘lazy’
[16:12:56.372]   - Field: ‘state’
[16:12:56.372] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:56.372] - Launch lazy future ...
[16:12:56.372] Packages needed by the future expression (n = 0): <none>
[16:12:56.372] Packages needed by future strategies (n = 0): <none>
[16:12:56.373] {
[16:12:56.373]     {
[16:12:56.373]         {
[16:12:56.373]             ...future.startTime <- base::Sys.time()
[16:12:56.373]             {
[16:12:56.373]                 {
[16:12:56.373]                   {
[16:12:56.373]                     {
[16:12:56.373]                       base::local({
[16:12:56.373]                         has_future <- base::requireNamespace("future", 
[16:12:56.373]                           quietly = TRUE)
[16:12:56.373]                         if (has_future) {
[16:12:56.373]                           ns <- base::getNamespace("future")
[16:12:56.373]                           version <- ns[[".package"]][["version"]]
[16:12:56.373]                           if (is.null(version)) 
[16:12:56.373]                             version <- utils::packageVersion("future")
[16:12:56.373]                         }
[16:12:56.373]                         else {
[16:12:56.373]                           version <- NULL
[16:12:56.373]                         }
[16:12:56.373]                         if (!has_future || version < "1.8.0") {
[16:12:56.373]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:56.373]                             "", base::R.version$version.string), 
[16:12:56.373]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:56.373]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:56.373]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:56.373]                               "release", "version")], collapse = " "), 
[16:12:56.373]                             hostname = base::Sys.info()[["nodename"]])
[16:12:56.373]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:56.373]                             info)
[16:12:56.373]                           info <- base::paste(info, collapse = "; ")
[16:12:56.373]                           if (!has_future) {
[16:12:56.373]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:56.373]                               info)
[16:12:56.373]                           }
[16:12:56.373]                           else {
[16:12:56.373]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:56.373]                               info, version)
[16:12:56.373]                           }
[16:12:56.373]                           base::stop(msg)
[16:12:56.373]                         }
[16:12:56.373]                       })
[16:12:56.373]                     }
[16:12:56.373]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:56.373]                     base::options(mc.cores = 1L)
[16:12:56.373]                   }
[16:12:56.373]                   options(future.plan = NULL)
[16:12:56.373]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:56.373]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:56.373]                 }
[16:12:56.373]                 ...future.workdir <- getwd()
[16:12:56.373]             }
[16:12:56.373]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:56.373]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:56.373]         }
[16:12:56.373]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[16:12:56.373]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[16:12:56.373]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[16:12:56.373]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[16:12:56.373]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:56.373]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:56.373]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:56.373]             base::names(...future.oldOptions))
[16:12:56.373]     }
[16:12:56.373]     if (FALSE) {
[16:12:56.373]     }
[16:12:56.373]     else {
[16:12:56.373]         if (TRUE) {
[16:12:56.373]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:56.373]                 open = "w")
[16:12:56.373]         }
[16:12:56.373]         else {
[16:12:56.373]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:56.373]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:56.373]         }
[16:12:56.373]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:56.373]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:56.373]             base::sink(type = "output", split = FALSE)
[16:12:56.373]             base::close(...future.stdout)
[16:12:56.373]         }, add = TRUE)
[16:12:56.373]     }
[16:12:56.373]     ...future.frame <- base::sys.nframe()
[16:12:56.373]     ...future.conditions <- base::list()
[16:12:56.373]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:56.373]     if (FALSE) {
[16:12:56.373]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:56.373]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:56.373]     }
[16:12:56.373]     ...future.result <- base::tryCatch({
[16:12:56.373]         base::withCallingHandlers({
[16:12:56.373]             ...future.value <- base::withVisible(base::local({
[16:12:56.373]                 ...future.makeSendCondition <- local({
[16:12:56.373]                   sendCondition <- NULL
[16:12:56.373]                   function(frame = 1L) {
[16:12:56.373]                     if (is.function(sendCondition)) 
[16:12:56.373]                       return(sendCondition)
[16:12:56.373]                     ns <- getNamespace("parallel")
[16:12:56.373]                     if (exists("sendData", mode = "function", 
[16:12:56.373]                       envir = ns)) {
[16:12:56.373]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:56.373]                         envir = ns)
[16:12:56.373]                       envir <- sys.frame(frame)
[16:12:56.373]                       master <- NULL
[16:12:56.373]                       while (!identical(envir, .GlobalEnv) && 
[16:12:56.373]                         !identical(envir, emptyenv())) {
[16:12:56.373]                         if (exists("master", mode = "list", envir = envir, 
[16:12:56.373]                           inherits = FALSE)) {
[16:12:56.373]                           master <- get("master", mode = "list", 
[16:12:56.373]                             envir = envir, inherits = FALSE)
[16:12:56.373]                           if (inherits(master, c("SOCKnode", 
[16:12:56.373]                             "SOCK0node"))) {
[16:12:56.373]                             sendCondition <<- function(cond) {
[16:12:56.373]                               data <- list(type = "VALUE", value = cond, 
[16:12:56.373]                                 success = TRUE)
[16:12:56.373]                               parallel_sendData(master, data)
[16:12:56.373]                             }
[16:12:56.373]                             return(sendCondition)
[16:12:56.373]                           }
[16:12:56.373]                         }
[16:12:56.373]                         frame <- frame + 1L
[16:12:56.373]                         envir <- sys.frame(frame)
[16:12:56.373]                       }
[16:12:56.373]                     }
[16:12:56.373]                     sendCondition <<- function(cond) NULL
[16:12:56.373]                   }
[16:12:56.373]                 })
[16:12:56.373]                 withCallingHandlers({
[16:12:56.373]                   {
[16:12:56.373]                     x <- x()
[16:12:56.373]                     x
[16:12:56.373]                   }
[16:12:56.373]                 }, immediateCondition = function(cond) {
[16:12:56.373]                   sendCondition <- ...future.makeSendCondition()
[16:12:56.373]                   sendCondition(cond)
[16:12:56.373]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:56.373]                   {
[16:12:56.373]                     inherits <- base::inherits
[16:12:56.373]                     invokeRestart <- base::invokeRestart
[16:12:56.373]                     is.null <- base::is.null
[16:12:56.373]                     muffled <- FALSE
[16:12:56.373]                     if (inherits(cond, "message")) {
[16:12:56.373]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:56.373]                       if (muffled) 
[16:12:56.373]                         invokeRestart("muffleMessage")
[16:12:56.373]                     }
[16:12:56.373]                     else if (inherits(cond, "warning")) {
[16:12:56.373]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:56.373]                       if (muffled) 
[16:12:56.373]                         invokeRestart("muffleWarning")
[16:12:56.373]                     }
[16:12:56.373]                     else if (inherits(cond, "condition")) {
[16:12:56.373]                       if (!is.null(pattern)) {
[16:12:56.373]                         computeRestarts <- base::computeRestarts
[16:12:56.373]                         grepl <- base::grepl
[16:12:56.373]                         restarts <- computeRestarts(cond)
[16:12:56.373]                         for (restart in restarts) {
[16:12:56.373]                           name <- restart$name
[16:12:56.373]                           if (is.null(name)) 
[16:12:56.373]                             next
[16:12:56.373]                           if (!grepl(pattern, name)) 
[16:12:56.373]                             next
[16:12:56.373]                           invokeRestart(restart)
[16:12:56.373]                           muffled <- TRUE
[16:12:56.373]                           break
[16:12:56.373]                         }
[16:12:56.373]                       }
[16:12:56.373]                     }
[16:12:56.373]                     invisible(muffled)
[16:12:56.373]                   }
[16:12:56.373]                   muffleCondition(cond)
[16:12:56.373]                 })
[16:12:56.373]             }))
[16:12:56.373]             future::FutureResult(value = ...future.value$value, 
[16:12:56.373]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:56.373]                   ...future.rng), globalenv = if (FALSE) 
[16:12:56.373]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:56.373]                     ...future.globalenv.names))
[16:12:56.373]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:56.373]         }, condition = base::local({
[16:12:56.373]             c <- base::c
[16:12:56.373]             inherits <- base::inherits
[16:12:56.373]             invokeRestart <- base::invokeRestart
[16:12:56.373]             length <- base::length
[16:12:56.373]             list <- base::list
[16:12:56.373]             seq.int <- base::seq.int
[16:12:56.373]             signalCondition <- base::signalCondition
[16:12:56.373]             sys.calls <- base::sys.calls
[16:12:56.373]             `[[` <- base::`[[`
[16:12:56.373]             `+` <- base::`+`
[16:12:56.373]             `<<-` <- base::`<<-`
[16:12:56.373]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:56.373]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:56.373]                   3L)]
[16:12:56.373]             }
[16:12:56.373]             function(cond) {
[16:12:56.373]                 is_error <- inherits(cond, "error")
[16:12:56.373]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:56.373]                   NULL)
[16:12:56.373]                 if (is_error) {
[16:12:56.373]                   sessionInformation <- function() {
[16:12:56.373]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:56.373]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:56.373]                       search = base::search(), system = base::Sys.info())
[16:12:56.373]                   }
[16:12:56.373]                   ...future.conditions[[length(...future.conditions) + 
[16:12:56.373]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:56.373]                     cond$call), session = sessionInformation(), 
[16:12:56.373]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:56.373]                   signalCondition(cond)
[16:12:56.373]                 }
[16:12:56.373]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:56.373]                 "immediateCondition"))) {
[16:12:56.373]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:56.373]                   ...future.conditions[[length(...future.conditions) + 
[16:12:56.373]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:56.373]                   if (TRUE && !signal) {
[16:12:56.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:56.373]                     {
[16:12:56.373]                       inherits <- base::inherits
[16:12:56.373]                       invokeRestart <- base::invokeRestart
[16:12:56.373]                       is.null <- base::is.null
[16:12:56.373]                       muffled <- FALSE
[16:12:56.373]                       if (inherits(cond, "message")) {
[16:12:56.373]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:56.373]                         if (muffled) 
[16:12:56.373]                           invokeRestart("muffleMessage")
[16:12:56.373]                       }
[16:12:56.373]                       else if (inherits(cond, "warning")) {
[16:12:56.373]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:56.373]                         if (muffled) 
[16:12:56.373]                           invokeRestart("muffleWarning")
[16:12:56.373]                       }
[16:12:56.373]                       else if (inherits(cond, "condition")) {
[16:12:56.373]                         if (!is.null(pattern)) {
[16:12:56.373]                           computeRestarts <- base::computeRestarts
[16:12:56.373]                           grepl <- base::grepl
[16:12:56.373]                           restarts <- computeRestarts(cond)
[16:12:56.373]                           for (restart in restarts) {
[16:12:56.373]                             name <- restart$name
[16:12:56.373]                             if (is.null(name)) 
[16:12:56.373]                               next
[16:12:56.373]                             if (!grepl(pattern, name)) 
[16:12:56.373]                               next
[16:12:56.373]                             invokeRestart(restart)
[16:12:56.373]                             muffled <- TRUE
[16:12:56.373]                             break
[16:12:56.373]                           }
[16:12:56.373]                         }
[16:12:56.373]                       }
[16:12:56.373]                       invisible(muffled)
[16:12:56.373]                     }
[16:12:56.373]                     muffleCondition(cond, pattern = "^muffle")
[16:12:56.373]                   }
[16:12:56.373]                 }
[16:12:56.373]                 else {
[16:12:56.373]                   if (TRUE) {
[16:12:56.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:56.373]                     {
[16:12:56.373]                       inherits <- base::inherits
[16:12:56.373]                       invokeRestart <- base::invokeRestart
[16:12:56.373]                       is.null <- base::is.null
[16:12:56.373]                       muffled <- FALSE
[16:12:56.373]                       if (inherits(cond, "message")) {
[16:12:56.373]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:56.373]                         if (muffled) 
[16:12:56.373]                           invokeRestart("muffleMessage")
[16:12:56.373]                       }
[16:12:56.373]                       else if (inherits(cond, "warning")) {
[16:12:56.373]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:56.373]                         if (muffled) 
[16:12:56.373]                           invokeRestart("muffleWarning")
[16:12:56.373]                       }
[16:12:56.373]                       else if (inherits(cond, "condition")) {
[16:12:56.373]                         if (!is.null(pattern)) {
[16:12:56.373]                           computeRestarts <- base::computeRestarts
[16:12:56.373]                           grepl <- base::grepl
[16:12:56.373]                           restarts <- computeRestarts(cond)
[16:12:56.373]                           for (restart in restarts) {
[16:12:56.373]                             name <- restart$name
[16:12:56.373]                             if (is.null(name)) 
[16:12:56.373]                               next
[16:12:56.373]                             if (!grepl(pattern, name)) 
[16:12:56.373]                               next
[16:12:56.373]                             invokeRestart(restart)
[16:12:56.373]                             muffled <- TRUE
[16:12:56.373]                             break
[16:12:56.373]                           }
[16:12:56.373]                         }
[16:12:56.373]                       }
[16:12:56.373]                       invisible(muffled)
[16:12:56.373]                     }
[16:12:56.373]                     muffleCondition(cond, pattern = "^muffle")
[16:12:56.373]                   }
[16:12:56.373]                 }
[16:12:56.373]             }
[16:12:56.373]         }))
[16:12:56.373]     }, error = function(ex) {
[16:12:56.373]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:56.373]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:56.373]                 ...future.rng), started = ...future.startTime, 
[16:12:56.373]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:56.373]             version = "1.8"), class = "FutureResult")
[16:12:56.373]     }, finally = {
[16:12:56.373]         if (!identical(...future.workdir, getwd())) 
[16:12:56.373]             setwd(...future.workdir)
[16:12:56.373]         {
[16:12:56.373]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:56.373]                 ...future.oldOptions$nwarnings <- NULL
[16:12:56.373]             }
[16:12:56.373]             base::options(...future.oldOptions)
[16:12:56.373]             if (.Platform$OS.type == "windows") {
[16:12:56.373]                 old_names <- names(...future.oldEnvVars)
[16:12:56.373]                 envs <- base::Sys.getenv()
[16:12:56.373]                 names <- names(envs)
[16:12:56.373]                 common <- intersect(names, old_names)
[16:12:56.373]                 added <- setdiff(names, old_names)
[16:12:56.373]                 removed <- setdiff(old_names, names)
[16:12:56.373]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:56.373]                   envs[common]]
[16:12:56.373]                 NAMES <- toupper(changed)
[16:12:56.373]                 args <- list()
[16:12:56.373]                 for (kk in seq_along(NAMES)) {
[16:12:56.373]                   name <- changed[[kk]]
[16:12:56.373]                   NAME <- NAMES[[kk]]
[16:12:56.373]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:56.373]                     next
[16:12:56.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:56.373]                 }
[16:12:56.373]                 NAMES <- toupper(added)
[16:12:56.373]                 for (kk in seq_along(NAMES)) {
[16:12:56.373]                   name <- added[[kk]]
[16:12:56.373]                   NAME <- NAMES[[kk]]
[16:12:56.373]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:56.373]                     next
[16:12:56.373]                   args[[name]] <- ""
[16:12:56.373]                 }
[16:12:56.373]                 NAMES <- toupper(removed)
[16:12:56.373]                 for (kk in seq_along(NAMES)) {
[16:12:56.373]                   name <- removed[[kk]]
[16:12:56.373]                   NAME <- NAMES[[kk]]
[16:12:56.373]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:56.373]                     next
[16:12:56.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:56.373]                 }
[16:12:56.373]                 if (length(args) > 0) 
[16:12:56.373]                   base::do.call(base::Sys.setenv, args = args)
[16:12:56.373]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:56.373]             }
[16:12:56.373]             else {
[16:12:56.373]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:56.373]             }
[16:12:56.373]             {
[16:12:56.373]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:56.373]                   0L) {
[16:12:56.373]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:56.373]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:56.373]                   base::options(opts)
[16:12:56.373]                 }
[16:12:56.373]                 {
[16:12:56.373]                   {
[16:12:56.373]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:56.373]                     NULL
[16:12:56.373]                   }
[16:12:56.373]                   options(future.plan = NULL)
[16:12:56.373]                   if (is.na(NA_character_)) 
[16:12:56.373]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:56.373]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:56.373]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:56.373]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:56.373]                     envir = parent.frame()) 
[16:12:56.373]                   {
[16:12:56.373]                     if (is.function(workers)) 
[16:12:56.373]                       workers <- workers()
[16:12:56.373]                     workers <- structure(as.integer(workers), 
[16:12:56.373]                       class = class(workers))
[16:12:56.373]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:56.373]                       workers >= 1)
[16:12:56.373]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:56.373]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:56.373]                     }
[16:12:56.373]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:56.373]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:56.373]                       envir = envir)
[16:12:56.373]                     if (!future$lazy) 
[16:12:56.373]                       future <- run(future)
[16:12:56.373]                     invisible(future)
[16:12:56.373]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:56.373]                 }
[16:12:56.373]             }
[16:12:56.373]         }
[16:12:56.373]     })
[16:12:56.373]     if (TRUE) {
[16:12:56.373]         base::sink(type = "output", split = FALSE)
[16:12:56.373]         if (TRUE) {
[16:12:56.373]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:56.373]         }
[16:12:56.373]         else {
[16:12:56.373]             ...future.result["stdout"] <- base::list(NULL)
[16:12:56.373]         }
[16:12:56.373]         base::close(...future.stdout)
[16:12:56.373]         ...future.stdout <- NULL
[16:12:56.373]     }
[16:12:56.373]     ...future.result$conditions <- ...future.conditions
[16:12:56.373]     ...future.result$finished <- base::Sys.time()
[16:12:56.373]     ...future.result
[16:12:56.373] }
[16:12:56.375] Exporting 1 global objects (1.01 KiB) to cluster node #1 ...
[16:12:56.375] Exporting ‘x’ (1.01 KiB) to cluster node #1 ...
[16:12:56.376] Exporting ‘x’ (1.01 KiB) to cluster node #1 ... DONE
[16:12:56.376] Exporting 1 global objects (1.01 KiB) to cluster node #1 ... DONE
[16:12:56.376] MultisessionFuture started
[16:12:56.377] - Launch lazy future ... done
[16:12:56.377] run() for ‘MultisessionFuture’ ... done
[16:12:56.377] result() for ClusterFuture ...
[16:12:56.377] receiveMessageFromWorker() for ClusterFuture ...
[16:12:56.377] - Validating connection of MultisessionFuture
[16:12:56.425] - received message: FutureResult
[16:12:56.425] - Received FutureResult
[16:12:56.425] - Erased future from FutureRegistry
[16:12:56.425] result() for ClusterFuture ...
[16:12:56.425] - result already collected: FutureResult
[16:12:56.425] result() for ClusterFuture ... done
[16:12:56.425] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:56.425] result() for ClusterFuture ... done
[16:12:56.425] result() for ClusterFuture ...
[16:12:56.425] - result already collected: FutureResult
[16:12:56.426] result() for ClusterFuture ... done
value(f) = ‘TRUE’
Testing with 2 cores ... DONE
> 
> message("*** Tricky use cases related to globals ... DONE")
*** Tricky use cases related to globals ... DONE
> 
> source("incl/end.R")
[16:12:56.426] plan(): Setting new future strategy stack:
[16:12:56.427] List of future strategies:
[16:12:56.427] 1. FutureStrategy:
[16:12:56.427]    - args: function (..., envir = parent.frame())
[16:12:56.427]    - tweaked: FALSE
[16:12:56.427]    - call: future::plan(oplan)
[16:12:56.427] plan(): nbrOfWorkers() = 1
> 
