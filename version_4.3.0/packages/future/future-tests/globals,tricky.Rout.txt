
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:20:49.972] plan(): Setting new future strategy stack:
[13:20:49.973] List of future strategies:
[13:20:49.973] 1. sequential:
[13:20:49.973]    - args: function (..., envir = parent.frame())
[13:20:49.973]    - tweaked: FALSE
[13:20:49.973]    - call: future::plan("sequential")
[13:20:49.987] plan(): nbrOfWorkers() = 1
> library("listenv")
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Tricky use cases related to globals ...")
*** Tricky use cases related to globals ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   message("- Local variables with the same name as globals ...")
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     methods <- c("conservative", "ordered")
+     for (method in methods) {
+       options(future.globals.method = method)
+       message(sprintf("Method for identifying globals: '%s' ...", method))
+ 
+       a <- 3
+ 
+       yTruth <- local({
+         b <- a
+         a <- 2
+         a * b
+       })
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       }
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       a <- 3
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       } %lazy% TRUE
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         }
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         } %lazy% TRUE
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Assert that `a` is resolved and turned into a constant future
+       ## at the moment when future `b` is created.
+       ## Requires options(future.globals.resolve = TRUE).
+       a <- future(1)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+ 
+       ## BUG FIX: In future (<= 1.0.0) a global 'pkg' would be
+       ## overwritten by the name of the last package attached
+       ## by the future.
+       pkg <- "foo"
+       f <- sequential({ pkg })
+       v <- value(f)
+       message(sprintf("value(f) = %s", sQuote(v)))
+       stopifnot(pkg == "foo", v == "foo")
+       
+       message(sprintf("Method for identifying globals: '%s' ... DONE", method))
+     }
+ 
+     ## BUG FIX: In globals (<= 0.10.3) a global 'x' in LHS of an assignment
+     ## would be missed.
+     options(future.globals.method = "ordered")
+ 
+     ## A local
+     x <- 1
+     f <- future({ x <- 0; x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 1)
+     
+     ## A global
+     x <- 1
+     f <- future({ x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 2)
+ 
+     ## A global
+     x <- function() TRUE
+     f <- future({ x <- x(); x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == TRUE)
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- Local variables with the same name as globals ...
- plan('sequential') ...
[13:20:50.081] plan(): Setting new future strategy stack:
[13:20:50.081] List of future strategies:
[13:20:50.081] 1. sequential:
[13:20:50.081]    - args: function (..., envir = parent.frame())
[13:20:50.081]    - tweaked: FALSE
[13:20:50.081]    - call: plan(strategy)
[13:20:50.092] plan(): nbrOfWorkers() = 1
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.094] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.094] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.101] - globals found: [3] ‘{’, ‘<-’, ‘*’
[13:20:50.101] Searching for globals ... DONE
[13:20:50.101] Resolving globals: TRUE
[13:20:50.101] Resolving any globals that are futures ...
[13:20:50.102] - globals: [3] ‘{’, ‘<-’, ‘*’
[13:20:50.102] Resolving any globals that are futures ... DONE
[13:20:50.102] 
[13:20:50.102] 
[13:20:50.102] getGlobalsAndPackages() ... DONE
[13:20:50.103] run() for ‘Future’ ...
[13:20:50.103] - state: ‘created’
[13:20:50.104] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.104] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.104] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.104]   - Field: ‘label’
[13:20:50.104]   - Field: ‘local’
[13:20:50.104]   - Field: ‘owner’
[13:20:50.104]   - Field: ‘envir’
[13:20:50.104]   - Field: ‘packages’
[13:20:50.105]   - Field: ‘gc’
[13:20:50.105]   - Field: ‘conditions’
[13:20:50.105]   - Field: ‘expr’
[13:20:50.105]   - Field: ‘uuid’
[13:20:50.105]   - Field: ‘seed’
[13:20:50.107]   - Field: ‘version’
[13:20:50.107]   - Field: ‘result’
[13:20:50.107]   - Field: ‘asynchronous’
[13:20:50.107]   - Field: ‘calls’
[13:20:50.107]   - Field: ‘globals’
[13:20:50.108]   - Field: ‘stdout’
[13:20:50.108]   - Field: ‘earlySignal’
[13:20:50.108]   - Field: ‘lazy’
[13:20:50.108]   - Field: ‘state’
[13:20:50.108] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.108] - Launch lazy future ...
[13:20:50.109] Packages needed by the future expression (n = 0): <none>
[13:20:50.109] Packages needed by future strategies (n = 0): <none>
[13:20:50.110] {
[13:20:50.110]     {
[13:20:50.110]         {
[13:20:50.110]             ...future.startTime <- base::Sys.time()
[13:20:50.110]             {
[13:20:50.110]                 {
[13:20:50.110]                   {
[13:20:50.110]                     base::local({
[13:20:50.110]                       has_future <- base::requireNamespace("future", 
[13:20:50.110]                         quietly = TRUE)
[13:20:50.110]                       if (has_future) {
[13:20:50.110]                         ns <- base::getNamespace("future")
[13:20:50.110]                         version <- ns[[".package"]][["version"]]
[13:20:50.110]                         if (is.null(version)) 
[13:20:50.110]                           version <- utils::packageVersion("future")
[13:20:50.110]                       }
[13:20:50.110]                       else {
[13:20:50.110]                         version <- NULL
[13:20:50.110]                       }
[13:20:50.110]                       if (!has_future || version < "1.8.0") {
[13:20:50.110]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.110]                           "", base::R.version$version.string), 
[13:20:50.110]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.110]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.110]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.110]                             "release", "version")], collapse = " "), 
[13:20:50.110]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.110]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.110]                           info)
[13:20:50.110]                         info <- base::paste(info, collapse = "; ")
[13:20:50.110]                         if (!has_future) {
[13:20:50.110]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.110]                             info)
[13:20:50.110]                         }
[13:20:50.110]                         else {
[13:20:50.110]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.110]                             info, version)
[13:20:50.110]                         }
[13:20:50.110]                         base::stop(msg)
[13:20:50.110]                       }
[13:20:50.110]                     })
[13:20:50.110]                   }
[13:20:50.110]                   options(future.plan = NULL)
[13:20:50.110]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.110]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.110]                 }
[13:20:50.110]                 ...future.workdir <- getwd()
[13:20:50.110]             }
[13:20:50.110]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.110]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.110]         }
[13:20:50.110]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.110]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:50.110]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.110]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.110]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.110]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.110]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.110]             base::names(...future.oldOptions))
[13:20:50.110]     }
[13:20:50.110]     if (FALSE) {
[13:20:50.110]     }
[13:20:50.110]     else {
[13:20:50.110]         if (TRUE) {
[13:20:50.110]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.110]                 open = "w")
[13:20:50.110]         }
[13:20:50.110]         else {
[13:20:50.110]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.110]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.110]         }
[13:20:50.110]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.110]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.110]             base::sink(type = "output", split = FALSE)
[13:20:50.110]             base::close(...future.stdout)
[13:20:50.110]         }, add = TRUE)
[13:20:50.110]     }
[13:20:50.110]     ...future.frame <- base::sys.nframe()
[13:20:50.110]     ...future.conditions <- base::list()
[13:20:50.110]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.110]     if (FALSE) {
[13:20:50.110]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.110]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.110]     }
[13:20:50.110]     ...future.result <- base::tryCatch({
[13:20:50.110]         base::withCallingHandlers({
[13:20:50.110]             ...future.value <- base::withVisible(base::local({
[13:20:50.110]                 b <- a
[13:20:50.110]                 a <- 2
[13:20:50.110]                 a * b
[13:20:50.110]             }))
[13:20:50.110]             future::FutureResult(value = ...future.value$value, 
[13:20:50.110]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.110]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.110]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.110]                     ...future.globalenv.names))
[13:20:50.110]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.110]         }, condition = base::local({
[13:20:50.110]             c <- base::c
[13:20:50.110]             inherits <- base::inherits
[13:20:50.110]             invokeRestart <- base::invokeRestart
[13:20:50.110]             length <- base::length
[13:20:50.110]             list <- base::list
[13:20:50.110]             seq.int <- base::seq.int
[13:20:50.110]             signalCondition <- base::signalCondition
[13:20:50.110]             sys.calls <- base::sys.calls
[13:20:50.110]             `[[` <- base::`[[`
[13:20:50.110]             `+` <- base::`+`
[13:20:50.110]             `<<-` <- base::`<<-`
[13:20:50.110]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.110]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.110]                   3L)]
[13:20:50.110]             }
[13:20:50.110]             function(cond) {
[13:20:50.110]                 is_error <- inherits(cond, "error")
[13:20:50.110]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.110]                   NULL)
[13:20:50.110]                 if (is_error) {
[13:20:50.110]                   sessionInformation <- function() {
[13:20:50.110]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.110]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.110]                       search = base::search(), system = base::Sys.info())
[13:20:50.110]                   }
[13:20:50.110]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.110]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.110]                     cond$call), session = sessionInformation(), 
[13:20:50.110]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.110]                   signalCondition(cond)
[13:20:50.110]                 }
[13:20:50.110]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.110]                 "immediateCondition"))) {
[13:20:50.110]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.110]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.110]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.110]                   if (TRUE && !signal) {
[13:20:50.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.110]                     {
[13:20:50.110]                       inherits <- base::inherits
[13:20:50.110]                       invokeRestart <- base::invokeRestart
[13:20:50.110]                       is.null <- base::is.null
[13:20:50.110]                       muffled <- FALSE
[13:20:50.110]                       if (inherits(cond, "message")) {
[13:20:50.110]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.110]                         if (muffled) 
[13:20:50.110]                           invokeRestart("muffleMessage")
[13:20:50.110]                       }
[13:20:50.110]                       else if (inherits(cond, "warning")) {
[13:20:50.110]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.110]                         if (muffled) 
[13:20:50.110]                           invokeRestart("muffleWarning")
[13:20:50.110]                       }
[13:20:50.110]                       else if (inherits(cond, "condition")) {
[13:20:50.110]                         if (!is.null(pattern)) {
[13:20:50.110]                           computeRestarts <- base::computeRestarts
[13:20:50.110]                           grepl <- base::grepl
[13:20:50.110]                           restarts <- computeRestarts(cond)
[13:20:50.110]                           for (restart in restarts) {
[13:20:50.110]                             name <- restart$name
[13:20:50.110]                             if (is.null(name)) 
[13:20:50.110]                               next
[13:20:50.110]                             if (!grepl(pattern, name)) 
[13:20:50.110]                               next
[13:20:50.110]                             invokeRestart(restart)
[13:20:50.110]                             muffled <- TRUE
[13:20:50.110]                             break
[13:20:50.110]                           }
[13:20:50.110]                         }
[13:20:50.110]                       }
[13:20:50.110]                       invisible(muffled)
[13:20:50.110]                     }
[13:20:50.110]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.110]                   }
[13:20:50.110]                 }
[13:20:50.110]                 else {
[13:20:50.110]                   if (TRUE) {
[13:20:50.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.110]                     {
[13:20:50.110]                       inherits <- base::inherits
[13:20:50.110]                       invokeRestart <- base::invokeRestart
[13:20:50.110]                       is.null <- base::is.null
[13:20:50.110]                       muffled <- FALSE
[13:20:50.110]                       if (inherits(cond, "message")) {
[13:20:50.110]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.110]                         if (muffled) 
[13:20:50.110]                           invokeRestart("muffleMessage")
[13:20:50.110]                       }
[13:20:50.110]                       else if (inherits(cond, "warning")) {
[13:20:50.110]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.110]                         if (muffled) 
[13:20:50.110]                           invokeRestart("muffleWarning")
[13:20:50.110]                       }
[13:20:50.110]                       else if (inherits(cond, "condition")) {
[13:20:50.110]                         if (!is.null(pattern)) {
[13:20:50.110]                           computeRestarts <- base::computeRestarts
[13:20:50.110]                           grepl <- base::grepl
[13:20:50.110]                           restarts <- computeRestarts(cond)
[13:20:50.110]                           for (restart in restarts) {
[13:20:50.110]                             name <- restart$name
[13:20:50.110]                             if (is.null(name)) 
[13:20:50.110]                               next
[13:20:50.110]                             if (!grepl(pattern, name)) 
[13:20:50.110]                               next
[13:20:50.110]                             invokeRestart(restart)
[13:20:50.110]                             muffled <- TRUE
[13:20:50.110]                             break
[13:20:50.110]                           }
[13:20:50.110]                         }
[13:20:50.110]                       }
[13:20:50.110]                       invisible(muffled)
[13:20:50.110]                     }
[13:20:50.110]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.110]                   }
[13:20:50.110]                 }
[13:20:50.110]             }
[13:20:50.110]         }))
[13:20:50.110]     }, error = function(ex) {
[13:20:50.110]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.110]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.110]                 ...future.rng), started = ...future.startTime, 
[13:20:50.110]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.110]             version = "1.8"), class = "FutureResult")
[13:20:50.110]     }, finally = {
[13:20:50.110]         if (!identical(...future.workdir, getwd())) 
[13:20:50.110]             setwd(...future.workdir)
[13:20:50.110]         {
[13:20:50.110]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.110]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.110]             }
[13:20:50.110]             base::options(...future.oldOptions)
[13:20:50.110]             if (.Platform$OS.type == "windows") {
[13:20:50.110]                 old_names <- names(...future.oldEnvVars)
[13:20:50.110]                 envs <- base::Sys.getenv()
[13:20:50.110]                 names <- names(envs)
[13:20:50.110]                 common <- intersect(names, old_names)
[13:20:50.110]                 added <- setdiff(names, old_names)
[13:20:50.110]                 removed <- setdiff(old_names, names)
[13:20:50.110]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.110]                   envs[common]]
[13:20:50.110]                 NAMES <- toupper(changed)
[13:20:50.110]                 args <- list()
[13:20:50.110]                 for (kk in seq_along(NAMES)) {
[13:20:50.110]                   name <- changed[[kk]]
[13:20:50.110]                   NAME <- NAMES[[kk]]
[13:20:50.110]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.110]                     next
[13:20:50.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.110]                 }
[13:20:50.110]                 NAMES <- toupper(added)
[13:20:50.110]                 for (kk in seq_along(NAMES)) {
[13:20:50.110]                   name <- added[[kk]]
[13:20:50.110]                   NAME <- NAMES[[kk]]
[13:20:50.110]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.110]                     next
[13:20:50.110]                   args[[name]] <- ""
[13:20:50.110]                 }
[13:20:50.110]                 NAMES <- toupper(removed)
[13:20:50.110]                 for (kk in seq_along(NAMES)) {
[13:20:50.110]                   name <- removed[[kk]]
[13:20:50.110]                   NAME <- NAMES[[kk]]
[13:20:50.110]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.110]                     next
[13:20:50.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.110]                 }
[13:20:50.110]                 if (length(args) > 0) 
[13:20:50.110]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.110]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.110]             }
[13:20:50.110]             else {
[13:20:50.110]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.110]             }
[13:20:50.110]             {
[13:20:50.110]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.110]                   0L) {
[13:20:50.110]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.110]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.110]                   base::options(opts)
[13:20:50.110]                 }
[13:20:50.110]                 {
[13:20:50.110]                   {
[13:20:50.110]                     NULL
[13:20:50.110]                     RNGkind("Mersenne-Twister")
[13:20:50.110]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.110]                       inherits = FALSE)
[13:20:50.110]                   }
[13:20:50.110]                   options(future.plan = NULL)
[13:20:50.110]                   if (is.na(NA_character_)) 
[13:20:50.110]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.110]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.110]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.110]                   {
[13:20:50.110]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.110]                     if (!future$lazy) 
[13:20:50.110]                       future <- run(future)
[13:20:50.110]                     invisible(future)
[13:20:50.110]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.110]                 }
[13:20:50.110]             }
[13:20:50.110]         }
[13:20:50.110]     })
[13:20:50.110]     if (TRUE) {
[13:20:50.110]         base::sink(type = "output", split = FALSE)
[13:20:50.110]         if (TRUE) {
[13:20:50.110]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.110]         }
[13:20:50.110]         else {
[13:20:50.110]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.110]         }
[13:20:50.110]         base::close(...future.stdout)
[13:20:50.110]         ...future.stdout <- NULL
[13:20:50.110]     }
[13:20:50.110]     ...future.result$conditions <- ...future.conditions
[13:20:50.110]     ...future.result$finished <- base::Sys.time()
[13:20:50.110]     ...future.result
[13:20:50.110] }
[13:20:50.112] plan(): Setting new future strategy stack:
[13:20:50.112] List of future strategies:
[13:20:50.112] 1. sequential:
[13:20:50.112]    - args: function (..., envir = parent.frame())
[13:20:50.112]    - tweaked: FALSE
[13:20:50.112]    - call: NULL
[13:20:50.112] plan(): nbrOfWorkers() = 1
[13:20:50.113] plan(): Setting new future strategy stack:
[13:20:50.114] List of future strategies:
[13:20:50.114] 1. sequential:
[13:20:50.114]    - args: function (..., envir = parent.frame())
[13:20:50.114]    - tweaked: FALSE
[13:20:50.114]    - call: plan(strategy)
[13:20:50.114] plan(): nbrOfWorkers() = 1
[13:20:50.114] SequentialFuture started (and completed)
[13:20:50.115] - Launch lazy future ... done
[13:20:50.115] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.115] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.116] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.117] - globals found: [3] ‘{’, ‘<-’, ‘*’
[13:20:50.117] Searching for globals ... DONE
[13:20:50.117] Resolving globals: TRUE
[13:20:50.117] Resolving any globals that are futures ...
[13:20:50.117] - globals: [3] ‘{’, ‘<-’, ‘*’
[13:20:50.117] Resolving any globals that are futures ... DONE
[13:20:50.118] 
[13:20:50.118] 
[13:20:50.118] getGlobalsAndPackages() ... DONE
[13:20:50.118] run() for ‘Future’ ...
[13:20:50.118] - state: ‘created’
[13:20:50.119] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.119] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.119] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.119]   - Field: ‘label’
[13:20:50.119]   - Field: ‘local’
[13:20:50.119]   - Field: ‘owner’
[13:20:50.119]   - Field: ‘envir’
[13:20:50.120]   - Field: ‘packages’
[13:20:50.120]   - Field: ‘gc’
[13:20:50.120]   - Field: ‘conditions’
[13:20:50.120]   - Field: ‘expr’
[13:20:50.120]   - Field: ‘uuid’
[13:20:50.120]   - Field: ‘seed’
[13:20:50.121]   - Field: ‘version’
[13:20:50.121]   - Field: ‘result’
[13:20:50.121]   - Field: ‘asynchronous’
[13:20:50.121]   - Field: ‘calls’
[13:20:50.121]   - Field: ‘globals’
[13:20:50.122]   - Field: ‘stdout’
[13:20:50.122]   - Field: ‘earlySignal’
[13:20:50.122]   - Field: ‘lazy’
[13:20:50.122]   - Field: ‘state’
[13:20:50.122] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.122] - Launch lazy future ...
[13:20:50.123] Packages needed by the future expression (n = 0): <none>
[13:20:50.123] Packages needed by future strategies (n = 0): <none>
[13:20:50.123] {
[13:20:50.123]     {
[13:20:50.123]         {
[13:20:50.123]             ...future.startTime <- base::Sys.time()
[13:20:50.123]             {
[13:20:50.123]                 {
[13:20:50.123]                   {
[13:20:50.123]                     base::local({
[13:20:50.123]                       has_future <- base::requireNamespace("future", 
[13:20:50.123]                         quietly = TRUE)
[13:20:50.123]                       if (has_future) {
[13:20:50.123]                         ns <- base::getNamespace("future")
[13:20:50.123]                         version <- ns[[".package"]][["version"]]
[13:20:50.123]                         if (is.null(version)) 
[13:20:50.123]                           version <- utils::packageVersion("future")
[13:20:50.123]                       }
[13:20:50.123]                       else {
[13:20:50.123]                         version <- NULL
[13:20:50.123]                       }
[13:20:50.123]                       if (!has_future || version < "1.8.0") {
[13:20:50.123]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.123]                           "", base::R.version$version.string), 
[13:20:50.123]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.123]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.123]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.123]                             "release", "version")], collapse = " "), 
[13:20:50.123]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.123]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.123]                           info)
[13:20:50.123]                         info <- base::paste(info, collapse = "; ")
[13:20:50.123]                         if (!has_future) {
[13:20:50.123]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.123]                             info)
[13:20:50.123]                         }
[13:20:50.123]                         else {
[13:20:50.123]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.123]                             info, version)
[13:20:50.123]                         }
[13:20:50.123]                         base::stop(msg)
[13:20:50.123]                       }
[13:20:50.123]                     })
[13:20:50.123]                   }
[13:20:50.123]                   options(future.plan = NULL)
[13:20:50.123]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.123]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.123]                 }
[13:20:50.123]                 ...future.workdir <- getwd()
[13:20:50.123]             }
[13:20:50.123]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.123]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.123]         }
[13:20:50.123]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.123]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:50.123]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.123]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.123]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.123]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.123]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.123]             base::names(...future.oldOptions))
[13:20:50.123]     }
[13:20:50.123]     if (FALSE) {
[13:20:50.123]     }
[13:20:50.123]     else {
[13:20:50.123]         if (TRUE) {
[13:20:50.123]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.123]                 open = "w")
[13:20:50.123]         }
[13:20:50.123]         else {
[13:20:50.123]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.123]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.123]         }
[13:20:50.123]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.123]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.123]             base::sink(type = "output", split = FALSE)
[13:20:50.123]             base::close(...future.stdout)
[13:20:50.123]         }, add = TRUE)
[13:20:50.123]     }
[13:20:50.123]     ...future.frame <- base::sys.nframe()
[13:20:50.123]     ...future.conditions <- base::list()
[13:20:50.123]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.123]     if (FALSE) {
[13:20:50.123]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.123]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.123]     }
[13:20:50.123]     ...future.result <- base::tryCatch({
[13:20:50.123]         base::withCallingHandlers({
[13:20:50.123]             ...future.value <- base::withVisible(base::local({
[13:20:50.123]                 b <- a
[13:20:50.123]                 a <- 2
[13:20:50.123]                 a * b
[13:20:50.123]             }))
[13:20:50.123]             future::FutureResult(value = ...future.value$value, 
[13:20:50.123]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.123]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.123]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.123]                     ...future.globalenv.names))
[13:20:50.123]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.123]         }, condition = base::local({
[13:20:50.123]             c <- base::c
[13:20:50.123]             inherits <- base::inherits
[13:20:50.123]             invokeRestart <- base::invokeRestart
[13:20:50.123]             length <- base::length
[13:20:50.123]             list <- base::list
[13:20:50.123]             seq.int <- base::seq.int
[13:20:50.123]             signalCondition <- base::signalCondition
[13:20:50.123]             sys.calls <- base::sys.calls
[13:20:50.123]             `[[` <- base::`[[`
[13:20:50.123]             `+` <- base::`+`
[13:20:50.123]             `<<-` <- base::`<<-`
[13:20:50.123]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.123]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.123]                   3L)]
[13:20:50.123]             }
[13:20:50.123]             function(cond) {
[13:20:50.123]                 is_error <- inherits(cond, "error")
[13:20:50.123]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.123]                   NULL)
[13:20:50.123]                 if (is_error) {
[13:20:50.123]                   sessionInformation <- function() {
[13:20:50.123]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.123]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.123]                       search = base::search(), system = base::Sys.info())
[13:20:50.123]                   }
[13:20:50.123]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.123]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.123]                     cond$call), session = sessionInformation(), 
[13:20:50.123]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.123]                   signalCondition(cond)
[13:20:50.123]                 }
[13:20:50.123]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.123]                 "immediateCondition"))) {
[13:20:50.123]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.123]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.123]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.123]                   if (TRUE && !signal) {
[13:20:50.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.123]                     {
[13:20:50.123]                       inherits <- base::inherits
[13:20:50.123]                       invokeRestart <- base::invokeRestart
[13:20:50.123]                       is.null <- base::is.null
[13:20:50.123]                       muffled <- FALSE
[13:20:50.123]                       if (inherits(cond, "message")) {
[13:20:50.123]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.123]                         if (muffled) 
[13:20:50.123]                           invokeRestart("muffleMessage")
[13:20:50.123]                       }
[13:20:50.123]                       else if (inherits(cond, "warning")) {
[13:20:50.123]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.123]                         if (muffled) 
[13:20:50.123]                           invokeRestart("muffleWarning")
[13:20:50.123]                       }
[13:20:50.123]                       else if (inherits(cond, "condition")) {
[13:20:50.123]                         if (!is.null(pattern)) {
[13:20:50.123]                           computeRestarts <- base::computeRestarts
[13:20:50.123]                           grepl <- base::grepl
[13:20:50.123]                           restarts <- computeRestarts(cond)
[13:20:50.123]                           for (restart in restarts) {
[13:20:50.123]                             name <- restart$name
[13:20:50.123]                             if (is.null(name)) 
[13:20:50.123]                               next
[13:20:50.123]                             if (!grepl(pattern, name)) 
[13:20:50.123]                               next
[13:20:50.123]                             invokeRestart(restart)
[13:20:50.123]                             muffled <- TRUE
[13:20:50.123]                             break
[13:20:50.123]                           }
[13:20:50.123]                         }
[13:20:50.123]                       }
[13:20:50.123]                       invisible(muffled)
[13:20:50.123]                     }
[13:20:50.123]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.123]                   }
[13:20:50.123]                 }
[13:20:50.123]                 else {
[13:20:50.123]                   if (TRUE) {
[13:20:50.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.123]                     {
[13:20:50.123]                       inherits <- base::inherits
[13:20:50.123]                       invokeRestart <- base::invokeRestart
[13:20:50.123]                       is.null <- base::is.null
[13:20:50.123]                       muffled <- FALSE
[13:20:50.123]                       if (inherits(cond, "message")) {
[13:20:50.123]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.123]                         if (muffled) 
[13:20:50.123]                           invokeRestart("muffleMessage")
[13:20:50.123]                       }
[13:20:50.123]                       else if (inherits(cond, "warning")) {
[13:20:50.123]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.123]                         if (muffled) 
[13:20:50.123]                           invokeRestart("muffleWarning")
[13:20:50.123]                       }
[13:20:50.123]                       else if (inherits(cond, "condition")) {
[13:20:50.123]                         if (!is.null(pattern)) {
[13:20:50.123]                           computeRestarts <- base::computeRestarts
[13:20:50.123]                           grepl <- base::grepl
[13:20:50.123]                           restarts <- computeRestarts(cond)
[13:20:50.123]                           for (restart in restarts) {
[13:20:50.123]                             name <- restart$name
[13:20:50.123]                             if (is.null(name)) 
[13:20:50.123]                               next
[13:20:50.123]                             if (!grepl(pattern, name)) 
[13:20:50.123]                               next
[13:20:50.123]                             invokeRestart(restart)
[13:20:50.123]                             muffled <- TRUE
[13:20:50.123]                             break
[13:20:50.123]                           }
[13:20:50.123]                         }
[13:20:50.123]                       }
[13:20:50.123]                       invisible(muffled)
[13:20:50.123]                     }
[13:20:50.123]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.123]                   }
[13:20:50.123]                 }
[13:20:50.123]             }
[13:20:50.123]         }))
[13:20:50.123]     }, error = function(ex) {
[13:20:50.123]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.123]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.123]                 ...future.rng), started = ...future.startTime, 
[13:20:50.123]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.123]             version = "1.8"), class = "FutureResult")
[13:20:50.123]     }, finally = {
[13:20:50.123]         if (!identical(...future.workdir, getwd())) 
[13:20:50.123]             setwd(...future.workdir)
[13:20:50.123]         {
[13:20:50.123]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.123]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.123]             }
[13:20:50.123]             base::options(...future.oldOptions)
[13:20:50.123]             if (.Platform$OS.type == "windows") {
[13:20:50.123]                 old_names <- names(...future.oldEnvVars)
[13:20:50.123]                 envs <- base::Sys.getenv()
[13:20:50.123]                 names <- names(envs)
[13:20:50.123]                 common <- intersect(names, old_names)
[13:20:50.123]                 added <- setdiff(names, old_names)
[13:20:50.123]                 removed <- setdiff(old_names, names)
[13:20:50.123]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.123]                   envs[common]]
[13:20:50.123]                 NAMES <- toupper(changed)
[13:20:50.123]                 args <- list()
[13:20:50.123]                 for (kk in seq_along(NAMES)) {
[13:20:50.123]                   name <- changed[[kk]]
[13:20:50.123]                   NAME <- NAMES[[kk]]
[13:20:50.123]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.123]                     next
[13:20:50.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.123]                 }
[13:20:50.123]                 NAMES <- toupper(added)
[13:20:50.123]                 for (kk in seq_along(NAMES)) {
[13:20:50.123]                   name <- added[[kk]]
[13:20:50.123]                   NAME <- NAMES[[kk]]
[13:20:50.123]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.123]                     next
[13:20:50.123]                   args[[name]] <- ""
[13:20:50.123]                 }
[13:20:50.123]                 NAMES <- toupper(removed)
[13:20:50.123]                 for (kk in seq_along(NAMES)) {
[13:20:50.123]                   name <- removed[[kk]]
[13:20:50.123]                   NAME <- NAMES[[kk]]
[13:20:50.123]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.123]                     next
[13:20:50.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.123]                 }
[13:20:50.123]                 if (length(args) > 0) 
[13:20:50.123]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.123]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.123]             }
[13:20:50.123]             else {
[13:20:50.123]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.123]             }
[13:20:50.123]             {
[13:20:50.123]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.123]                   0L) {
[13:20:50.123]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.123]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.123]                   base::options(opts)
[13:20:50.123]                 }
[13:20:50.123]                 {
[13:20:50.123]                   {
[13:20:50.123]                     NULL
[13:20:50.123]                     RNGkind("Mersenne-Twister")
[13:20:50.123]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.123]                       inherits = FALSE)
[13:20:50.123]                   }
[13:20:50.123]                   options(future.plan = NULL)
[13:20:50.123]                   if (is.na(NA_character_)) 
[13:20:50.123]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.123]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.123]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.123]                   {
[13:20:50.123]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.123]                     if (!future$lazy) 
[13:20:50.123]                       future <- run(future)
[13:20:50.123]                     invisible(future)
[13:20:50.123]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.123]                 }
[13:20:50.123]             }
[13:20:50.123]         }
[13:20:50.123]     })
[13:20:50.123]     if (TRUE) {
[13:20:50.123]         base::sink(type = "output", split = FALSE)
[13:20:50.123]         if (TRUE) {
[13:20:50.123]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.123]         }
[13:20:50.123]         else {
[13:20:50.123]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.123]         }
[13:20:50.123]         base::close(...future.stdout)
[13:20:50.123]         ...future.stdout <- NULL
[13:20:50.123]     }
[13:20:50.123]     ...future.result$conditions <- ...future.conditions
[13:20:50.123]     ...future.result$finished <- base::Sys.time()
[13:20:50.123]     ...future.result
[13:20:50.123] }
[13:20:50.126] plan(): Setting new future strategy stack:
[13:20:50.126] List of future strategies:
[13:20:50.126] 1. sequential:
[13:20:50.126]    - args: function (..., envir = parent.frame())
[13:20:50.126]    - tweaked: FALSE
[13:20:50.126]    - call: NULL
[13:20:50.126] plan(): nbrOfWorkers() = 1
[13:20:50.127] plan(): Setting new future strategy stack:
[13:20:50.127] List of future strategies:
[13:20:50.127] 1. sequential:
[13:20:50.127]    - args: function (..., envir = parent.frame())
[13:20:50.127]    - tweaked: FALSE
[13:20:50.127]    - call: plan(strategy)
[13:20:50.127] plan(): nbrOfWorkers() = 1
[13:20:50.128] SequentialFuture started (and completed)
[13:20:50.128] signalConditions() ...
[13:20:50.128]  - include = ‘immediateCondition’
[13:20:50.128]  - exclude = 
[13:20:50.128]  - resignal = FALSE
[13:20:50.128]  - Number of conditions: 1
[13:20:50.128] signalConditions() ... done
[13:20:50.128] - Launch lazy future ... done
[13:20:50.128] run() for ‘SequentialFuture’ ... done
[13:20:50.129] signalConditions() ...
[13:20:50.129]  - include = ‘immediateCondition’
[13:20:50.129]  - exclude = 
[13:20:50.129]  - resignal = FALSE
[13:20:50.129]  - Number of conditions: 1
[13:20:50.129] signalConditions() ... done
[13:20:50.129] Future state: ‘finished’
[13:20:50.129] signalConditions() ...
[13:20:50.129]  - include = ‘condition’
[13:20:50.129]  - exclude = ‘immediateCondition’
[13:20:50.130]  - resignal = TRUE
[13:20:50.130]  - Number of conditions: 1
[13:20:50.130]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:50.130] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "5853cd8d1af0" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:20:50"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.148] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.149] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.150] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.150] Searching for globals ... DONE
[13:20:50.150] Resolving globals: TRUE
[13:20:50.150] Resolving any globals that are futures ...
[13:20:50.150] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.150] Resolving any globals that are futures ... DONE
[13:20:50.151] Resolving futures part of globals (recursively) ...
[13:20:50.152] resolve() on list ...
[13:20:50.152]  recursive: 99
[13:20:50.152]  length: 1
[13:20:50.152]  elements: ‘ii’
[13:20:50.152]  length: 0 (resolved future 1)
[13:20:50.152] resolve() on list ... DONE
[13:20:50.152] - globals: [1] ‘ii’
[13:20:50.153] Resolving futures part of globals (recursively) ... DONE
[13:20:50.153] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:50.154] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:50.154] - globals: [1] ‘ii’
[13:20:50.154] 
[13:20:50.154] getGlobalsAndPackages() ... DONE
[13:20:50.154] run() for ‘Future’ ...
[13:20:50.154] - state: ‘created’
[13:20:50.154] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.155] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.155] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.155]   - Field: ‘label’
[13:20:50.155]   - Field: ‘local’
[13:20:50.155]   - Field: ‘owner’
[13:20:50.155]   - Field: ‘envir’
[13:20:50.155]   - Field: ‘packages’
[13:20:50.155]   - Field: ‘gc’
[13:20:50.155]   - Field: ‘conditions’
[13:20:50.156]   - Field: ‘expr’
[13:20:50.156]   - Field: ‘uuid’
[13:20:50.156]   - Field: ‘seed’
[13:20:50.156]   - Field: ‘version’
[13:20:50.156]   - Field: ‘result’
[13:20:50.156]   - Field: ‘asynchronous’
[13:20:50.156]   - Field: ‘calls’
[13:20:50.156]   - Field: ‘globals’
[13:20:50.156]   - Field: ‘stdout’
[13:20:50.156]   - Field: ‘earlySignal’
[13:20:50.156]   - Field: ‘lazy’
[13:20:50.157]   - Field: ‘state’
[13:20:50.157] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.157] - Launch lazy future ...
[13:20:50.157] Packages needed by the future expression (n = 0): <none>
[13:20:50.157] Packages needed by future strategies (n = 0): <none>
[13:20:50.157] {
[13:20:50.157]     {
[13:20:50.157]         {
[13:20:50.157]             ...future.startTime <- base::Sys.time()
[13:20:50.157]             {
[13:20:50.157]                 {
[13:20:50.157]                   {
[13:20:50.157]                     base::local({
[13:20:50.157]                       has_future <- base::requireNamespace("future", 
[13:20:50.157]                         quietly = TRUE)
[13:20:50.157]                       if (has_future) {
[13:20:50.157]                         ns <- base::getNamespace("future")
[13:20:50.157]                         version <- ns[[".package"]][["version"]]
[13:20:50.157]                         if (is.null(version)) 
[13:20:50.157]                           version <- utils::packageVersion("future")
[13:20:50.157]                       }
[13:20:50.157]                       else {
[13:20:50.157]                         version <- NULL
[13:20:50.157]                       }
[13:20:50.157]                       if (!has_future || version < "1.8.0") {
[13:20:50.157]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.157]                           "", base::R.version$version.string), 
[13:20:50.157]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.157]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.157]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.157]                             "release", "version")], collapse = " "), 
[13:20:50.157]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.157]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.157]                           info)
[13:20:50.157]                         info <- base::paste(info, collapse = "; ")
[13:20:50.157]                         if (!has_future) {
[13:20:50.157]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.157]                             info)
[13:20:50.157]                         }
[13:20:50.157]                         else {
[13:20:50.157]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.157]                             info, version)
[13:20:50.157]                         }
[13:20:50.157]                         base::stop(msg)
[13:20:50.157]                       }
[13:20:50.157]                     })
[13:20:50.157]                   }
[13:20:50.157]                   options(future.plan = NULL)
[13:20:50.157]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.157]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.157]                 }
[13:20:50.157]                 ...future.workdir <- getwd()
[13:20:50.157]             }
[13:20:50.157]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.157]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.157]         }
[13:20:50.157]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.157]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:50.157]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.157]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.157]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.157]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.157]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.157]             base::names(...future.oldOptions))
[13:20:50.157]     }
[13:20:50.157]     if (FALSE) {
[13:20:50.157]     }
[13:20:50.157]     else {
[13:20:50.157]         if (TRUE) {
[13:20:50.157]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.157]                 open = "w")
[13:20:50.157]         }
[13:20:50.157]         else {
[13:20:50.157]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.157]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.157]         }
[13:20:50.157]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.157]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.157]             base::sink(type = "output", split = FALSE)
[13:20:50.157]             base::close(...future.stdout)
[13:20:50.157]         }, add = TRUE)
[13:20:50.157]     }
[13:20:50.157]     ...future.frame <- base::sys.nframe()
[13:20:50.157]     ...future.conditions <- base::list()
[13:20:50.157]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.157]     if (FALSE) {
[13:20:50.157]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.157]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.157]     }
[13:20:50.157]     ...future.result <- base::tryCatch({
[13:20:50.157]         base::withCallingHandlers({
[13:20:50.157]             ...future.value <- base::withVisible(base::local({
[13:20:50.157]                 b <- a * ii
[13:20:50.157]                 a <- 0
[13:20:50.157]                 b
[13:20:50.157]             }))
[13:20:50.157]             future::FutureResult(value = ...future.value$value, 
[13:20:50.157]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.157]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.157]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.157]                     ...future.globalenv.names))
[13:20:50.157]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.157]         }, condition = base::local({
[13:20:50.157]             c <- base::c
[13:20:50.157]             inherits <- base::inherits
[13:20:50.157]             invokeRestart <- base::invokeRestart
[13:20:50.157]             length <- base::length
[13:20:50.157]             list <- base::list
[13:20:50.157]             seq.int <- base::seq.int
[13:20:50.157]             signalCondition <- base::signalCondition
[13:20:50.157]             sys.calls <- base::sys.calls
[13:20:50.157]             `[[` <- base::`[[`
[13:20:50.157]             `+` <- base::`+`
[13:20:50.157]             `<<-` <- base::`<<-`
[13:20:50.157]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.157]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.157]                   3L)]
[13:20:50.157]             }
[13:20:50.157]             function(cond) {
[13:20:50.157]                 is_error <- inherits(cond, "error")
[13:20:50.157]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.157]                   NULL)
[13:20:50.157]                 if (is_error) {
[13:20:50.157]                   sessionInformation <- function() {
[13:20:50.157]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.157]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.157]                       search = base::search(), system = base::Sys.info())
[13:20:50.157]                   }
[13:20:50.157]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.157]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.157]                     cond$call), session = sessionInformation(), 
[13:20:50.157]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.157]                   signalCondition(cond)
[13:20:50.157]                 }
[13:20:50.157]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.157]                 "immediateCondition"))) {
[13:20:50.157]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.157]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.157]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.157]                   if (TRUE && !signal) {
[13:20:50.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.157]                     {
[13:20:50.157]                       inherits <- base::inherits
[13:20:50.157]                       invokeRestart <- base::invokeRestart
[13:20:50.157]                       is.null <- base::is.null
[13:20:50.157]                       muffled <- FALSE
[13:20:50.157]                       if (inherits(cond, "message")) {
[13:20:50.157]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.157]                         if (muffled) 
[13:20:50.157]                           invokeRestart("muffleMessage")
[13:20:50.157]                       }
[13:20:50.157]                       else if (inherits(cond, "warning")) {
[13:20:50.157]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.157]                         if (muffled) 
[13:20:50.157]                           invokeRestart("muffleWarning")
[13:20:50.157]                       }
[13:20:50.157]                       else if (inherits(cond, "condition")) {
[13:20:50.157]                         if (!is.null(pattern)) {
[13:20:50.157]                           computeRestarts <- base::computeRestarts
[13:20:50.157]                           grepl <- base::grepl
[13:20:50.157]                           restarts <- computeRestarts(cond)
[13:20:50.157]                           for (restart in restarts) {
[13:20:50.157]                             name <- restart$name
[13:20:50.157]                             if (is.null(name)) 
[13:20:50.157]                               next
[13:20:50.157]                             if (!grepl(pattern, name)) 
[13:20:50.157]                               next
[13:20:50.157]                             invokeRestart(restart)
[13:20:50.157]                             muffled <- TRUE
[13:20:50.157]                             break
[13:20:50.157]                           }
[13:20:50.157]                         }
[13:20:50.157]                       }
[13:20:50.157]                       invisible(muffled)
[13:20:50.157]                     }
[13:20:50.157]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.157]                   }
[13:20:50.157]                 }
[13:20:50.157]                 else {
[13:20:50.157]                   if (TRUE) {
[13:20:50.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.157]                     {
[13:20:50.157]                       inherits <- base::inherits
[13:20:50.157]                       invokeRestart <- base::invokeRestart
[13:20:50.157]                       is.null <- base::is.null
[13:20:50.157]                       muffled <- FALSE
[13:20:50.157]                       if (inherits(cond, "message")) {
[13:20:50.157]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.157]                         if (muffled) 
[13:20:50.157]                           invokeRestart("muffleMessage")
[13:20:50.157]                       }
[13:20:50.157]                       else if (inherits(cond, "warning")) {
[13:20:50.157]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.157]                         if (muffled) 
[13:20:50.157]                           invokeRestart("muffleWarning")
[13:20:50.157]                       }
[13:20:50.157]                       else if (inherits(cond, "condition")) {
[13:20:50.157]                         if (!is.null(pattern)) {
[13:20:50.157]                           computeRestarts <- base::computeRestarts
[13:20:50.157]                           grepl <- base::grepl
[13:20:50.157]                           restarts <- computeRestarts(cond)
[13:20:50.157]                           for (restart in restarts) {
[13:20:50.157]                             name <- restart$name
[13:20:50.157]                             if (is.null(name)) 
[13:20:50.157]                               next
[13:20:50.157]                             if (!grepl(pattern, name)) 
[13:20:50.157]                               next
[13:20:50.157]                             invokeRestart(restart)
[13:20:50.157]                             muffled <- TRUE
[13:20:50.157]                             break
[13:20:50.157]                           }
[13:20:50.157]                         }
[13:20:50.157]                       }
[13:20:50.157]                       invisible(muffled)
[13:20:50.157]                     }
[13:20:50.157]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.157]                   }
[13:20:50.157]                 }
[13:20:50.157]             }
[13:20:50.157]         }))
[13:20:50.157]     }, error = function(ex) {
[13:20:50.157]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.157]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.157]                 ...future.rng), started = ...future.startTime, 
[13:20:50.157]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.157]             version = "1.8"), class = "FutureResult")
[13:20:50.157]     }, finally = {
[13:20:50.157]         if (!identical(...future.workdir, getwd())) 
[13:20:50.157]             setwd(...future.workdir)
[13:20:50.157]         {
[13:20:50.157]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.157]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.157]             }
[13:20:50.157]             base::options(...future.oldOptions)
[13:20:50.157]             if (.Platform$OS.type == "windows") {
[13:20:50.157]                 old_names <- names(...future.oldEnvVars)
[13:20:50.157]                 envs <- base::Sys.getenv()
[13:20:50.157]                 names <- names(envs)
[13:20:50.157]                 common <- intersect(names, old_names)
[13:20:50.157]                 added <- setdiff(names, old_names)
[13:20:50.157]                 removed <- setdiff(old_names, names)
[13:20:50.157]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.157]                   envs[common]]
[13:20:50.157]                 NAMES <- toupper(changed)
[13:20:50.157]                 args <- list()
[13:20:50.157]                 for (kk in seq_along(NAMES)) {
[13:20:50.157]                   name <- changed[[kk]]
[13:20:50.157]                   NAME <- NAMES[[kk]]
[13:20:50.157]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.157]                     next
[13:20:50.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.157]                 }
[13:20:50.157]                 NAMES <- toupper(added)
[13:20:50.157]                 for (kk in seq_along(NAMES)) {
[13:20:50.157]                   name <- added[[kk]]
[13:20:50.157]                   NAME <- NAMES[[kk]]
[13:20:50.157]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.157]                     next
[13:20:50.157]                   args[[name]] <- ""
[13:20:50.157]                 }
[13:20:50.157]                 NAMES <- toupper(removed)
[13:20:50.157]                 for (kk in seq_along(NAMES)) {
[13:20:50.157]                   name <- removed[[kk]]
[13:20:50.157]                   NAME <- NAMES[[kk]]
[13:20:50.157]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.157]                     next
[13:20:50.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.157]                 }
[13:20:50.157]                 if (length(args) > 0) 
[13:20:50.157]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.157]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.157]             }
[13:20:50.157]             else {
[13:20:50.157]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.157]             }
[13:20:50.157]             {
[13:20:50.157]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.157]                   0L) {
[13:20:50.157]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.157]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.157]                   base::options(opts)
[13:20:50.157]                 }
[13:20:50.157]                 {
[13:20:50.157]                   {
[13:20:50.157]                     NULL
[13:20:50.157]                     RNGkind("Mersenne-Twister")
[13:20:50.157]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.157]                       inherits = FALSE)
[13:20:50.157]                   }
[13:20:50.157]                   options(future.plan = NULL)
[13:20:50.157]                   if (is.na(NA_character_)) 
[13:20:50.157]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.157]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.157]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.157]                   {
[13:20:50.157]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.157]                     if (!future$lazy) 
[13:20:50.157]                       future <- run(future)
[13:20:50.157]                     invisible(future)
[13:20:50.157]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.157]                 }
[13:20:50.157]             }
[13:20:50.157]         }
[13:20:50.157]     })
[13:20:50.157]     if (TRUE) {
[13:20:50.157]         base::sink(type = "output", split = FALSE)
[13:20:50.157]         if (TRUE) {
[13:20:50.157]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.157]         }
[13:20:50.157]         else {
[13:20:50.157]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.157]         }
[13:20:50.157]         base::close(...future.stdout)
[13:20:50.157]         ...future.stdout <- NULL
[13:20:50.157]     }
[13:20:50.157]     ...future.result$conditions <- ...future.conditions
[13:20:50.157]     ...future.result$finished <- base::Sys.time()
[13:20:50.157]     ...future.result
[13:20:50.157] }
[13:20:50.159] assign_globals() ...
[13:20:50.159] List of 1
[13:20:50.159]  $ ii: int 1
[13:20:50.159]  - attr(*, "where")=List of 1
[13:20:50.159]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:50.159]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.159]  - attr(*, "resolved")= logi TRUE
[13:20:50.159]  - attr(*, "total_size")= num 56
[13:20:50.159]  - attr(*, "already-done")= logi TRUE
[13:20:50.162] - copied ‘ii’ to environment
[13:20:50.162] assign_globals() ... done
[13:20:50.162] plan(): Setting new future strategy stack:
[13:20:50.162] List of future strategies:
[13:20:50.162] 1. sequential:
[13:20:50.162]    - args: function (..., envir = parent.frame())
[13:20:50.162]    - tweaked: FALSE
[13:20:50.162]    - call: NULL
[13:20:50.163] plan(): nbrOfWorkers() = 1
[13:20:50.163] plan(): Setting new future strategy stack:
[13:20:50.163] List of future strategies:
[13:20:50.163] 1. sequential:
[13:20:50.163]    - args: function (..., envir = parent.frame())
[13:20:50.163]    - tweaked: FALSE
[13:20:50.163]    - call: plan(strategy)
[13:20:50.164] plan(): nbrOfWorkers() = 1
[13:20:50.164] SequentialFuture started (and completed)
[13:20:50.164] - Launch lazy future ... done
[13:20:50.164] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.165] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.165] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.166] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.166] Searching for globals ... DONE
[13:20:50.166] Resolving globals: TRUE
[13:20:50.166] Resolving any globals that are futures ...
[13:20:50.167] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.167] Resolving any globals that are futures ... DONE
[13:20:50.167] Resolving futures part of globals (recursively) ...
[13:20:50.167] resolve() on list ...
[13:20:50.167]  recursive: 99
[13:20:50.167]  length: 1
[13:20:50.167]  elements: ‘ii’
[13:20:50.168]  length: 0 (resolved future 1)
[13:20:50.168] resolve() on list ... DONE
[13:20:50.168] - globals: [1] ‘ii’
[13:20:50.168] Resolving futures part of globals (recursively) ... DONE
[13:20:50.168] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:50.168] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:50.168] - globals: [1] ‘ii’
[13:20:50.169] 
[13:20:50.169] getGlobalsAndPackages() ... DONE
[13:20:50.169] run() for ‘Future’ ...
[13:20:50.169] - state: ‘created’
[13:20:50.169] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.169] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.170] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.170]   - Field: ‘label’
[13:20:50.170]   - Field: ‘local’
[13:20:50.170]   - Field: ‘owner’
[13:20:50.170]   - Field: ‘envir’
[13:20:50.170]   - Field: ‘packages’
[13:20:50.170]   - Field: ‘gc’
[13:20:50.170]   - Field: ‘conditions’
[13:20:50.170]   - Field: ‘expr’
[13:20:50.170]   - Field: ‘uuid’
[13:20:50.171]   - Field: ‘seed’
[13:20:50.171]   - Field: ‘version’
[13:20:50.171]   - Field: ‘result’
[13:20:50.171]   - Field: ‘asynchronous’
[13:20:50.171]   - Field: ‘calls’
[13:20:50.171]   - Field: ‘globals’
[13:20:50.171]   - Field: ‘stdout’
[13:20:50.171]   - Field: ‘earlySignal’
[13:20:50.173]   - Field: ‘lazy’
[13:20:50.173]   - Field: ‘state’
[13:20:50.173] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.174] - Launch lazy future ...
[13:20:50.174] Packages needed by the future expression (n = 0): <none>
[13:20:50.174] Packages needed by future strategies (n = 0): <none>
[13:20:50.174] {
[13:20:50.174]     {
[13:20:50.174]         {
[13:20:50.174]             ...future.startTime <- base::Sys.time()
[13:20:50.174]             {
[13:20:50.174]                 {
[13:20:50.174]                   {
[13:20:50.174]                     base::local({
[13:20:50.174]                       has_future <- base::requireNamespace("future", 
[13:20:50.174]                         quietly = TRUE)
[13:20:50.174]                       if (has_future) {
[13:20:50.174]                         ns <- base::getNamespace("future")
[13:20:50.174]                         version <- ns[[".package"]][["version"]]
[13:20:50.174]                         if (is.null(version)) 
[13:20:50.174]                           version <- utils::packageVersion("future")
[13:20:50.174]                       }
[13:20:50.174]                       else {
[13:20:50.174]                         version <- NULL
[13:20:50.174]                       }
[13:20:50.174]                       if (!has_future || version < "1.8.0") {
[13:20:50.174]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.174]                           "", base::R.version$version.string), 
[13:20:50.174]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.174]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.174]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.174]                             "release", "version")], collapse = " "), 
[13:20:50.174]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.174]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.174]                           info)
[13:20:50.174]                         info <- base::paste(info, collapse = "; ")
[13:20:50.174]                         if (!has_future) {
[13:20:50.174]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.174]                             info)
[13:20:50.174]                         }
[13:20:50.174]                         else {
[13:20:50.174]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.174]                             info, version)
[13:20:50.174]                         }
[13:20:50.174]                         base::stop(msg)
[13:20:50.174]                       }
[13:20:50.174]                     })
[13:20:50.174]                   }
[13:20:50.174]                   options(future.plan = NULL)
[13:20:50.174]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.174]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.174]                 }
[13:20:50.174]                 ...future.workdir <- getwd()
[13:20:50.174]             }
[13:20:50.174]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.174]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.174]         }
[13:20:50.174]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.174]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:50.174]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.174]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.174]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.174]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.174]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.174]             base::names(...future.oldOptions))
[13:20:50.174]     }
[13:20:50.174]     if (FALSE) {
[13:20:50.174]     }
[13:20:50.174]     else {
[13:20:50.174]         if (TRUE) {
[13:20:50.174]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.174]                 open = "w")
[13:20:50.174]         }
[13:20:50.174]         else {
[13:20:50.174]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.174]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.174]         }
[13:20:50.174]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.174]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.174]             base::sink(type = "output", split = FALSE)
[13:20:50.174]             base::close(...future.stdout)
[13:20:50.174]         }, add = TRUE)
[13:20:50.174]     }
[13:20:50.174]     ...future.frame <- base::sys.nframe()
[13:20:50.174]     ...future.conditions <- base::list()
[13:20:50.174]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.174]     if (FALSE) {
[13:20:50.174]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.174]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.174]     }
[13:20:50.174]     ...future.result <- base::tryCatch({
[13:20:50.174]         base::withCallingHandlers({
[13:20:50.174]             ...future.value <- base::withVisible(base::local({
[13:20:50.174]                 b <- a * ii
[13:20:50.174]                 a <- 0
[13:20:50.174]                 b
[13:20:50.174]             }))
[13:20:50.174]             future::FutureResult(value = ...future.value$value, 
[13:20:50.174]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.174]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.174]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.174]                     ...future.globalenv.names))
[13:20:50.174]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.174]         }, condition = base::local({
[13:20:50.174]             c <- base::c
[13:20:50.174]             inherits <- base::inherits
[13:20:50.174]             invokeRestart <- base::invokeRestart
[13:20:50.174]             length <- base::length
[13:20:50.174]             list <- base::list
[13:20:50.174]             seq.int <- base::seq.int
[13:20:50.174]             signalCondition <- base::signalCondition
[13:20:50.174]             sys.calls <- base::sys.calls
[13:20:50.174]             `[[` <- base::`[[`
[13:20:50.174]             `+` <- base::`+`
[13:20:50.174]             `<<-` <- base::`<<-`
[13:20:50.174]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.174]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.174]                   3L)]
[13:20:50.174]             }
[13:20:50.174]             function(cond) {
[13:20:50.174]                 is_error <- inherits(cond, "error")
[13:20:50.174]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.174]                   NULL)
[13:20:50.174]                 if (is_error) {
[13:20:50.174]                   sessionInformation <- function() {
[13:20:50.174]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.174]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.174]                       search = base::search(), system = base::Sys.info())
[13:20:50.174]                   }
[13:20:50.174]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.174]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.174]                     cond$call), session = sessionInformation(), 
[13:20:50.174]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.174]                   signalCondition(cond)
[13:20:50.174]                 }
[13:20:50.174]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.174]                 "immediateCondition"))) {
[13:20:50.174]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.174]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.174]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.174]                   if (TRUE && !signal) {
[13:20:50.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.174]                     {
[13:20:50.174]                       inherits <- base::inherits
[13:20:50.174]                       invokeRestart <- base::invokeRestart
[13:20:50.174]                       is.null <- base::is.null
[13:20:50.174]                       muffled <- FALSE
[13:20:50.174]                       if (inherits(cond, "message")) {
[13:20:50.174]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.174]                         if (muffled) 
[13:20:50.174]                           invokeRestart("muffleMessage")
[13:20:50.174]                       }
[13:20:50.174]                       else if (inherits(cond, "warning")) {
[13:20:50.174]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.174]                         if (muffled) 
[13:20:50.174]                           invokeRestart("muffleWarning")
[13:20:50.174]                       }
[13:20:50.174]                       else if (inherits(cond, "condition")) {
[13:20:50.174]                         if (!is.null(pattern)) {
[13:20:50.174]                           computeRestarts <- base::computeRestarts
[13:20:50.174]                           grepl <- base::grepl
[13:20:50.174]                           restarts <- computeRestarts(cond)
[13:20:50.174]                           for (restart in restarts) {
[13:20:50.174]                             name <- restart$name
[13:20:50.174]                             if (is.null(name)) 
[13:20:50.174]                               next
[13:20:50.174]                             if (!grepl(pattern, name)) 
[13:20:50.174]                               next
[13:20:50.174]                             invokeRestart(restart)
[13:20:50.174]                             muffled <- TRUE
[13:20:50.174]                             break
[13:20:50.174]                           }
[13:20:50.174]                         }
[13:20:50.174]                       }
[13:20:50.174]                       invisible(muffled)
[13:20:50.174]                     }
[13:20:50.174]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.174]                   }
[13:20:50.174]                 }
[13:20:50.174]                 else {
[13:20:50.174]                   if (TRUE) {
[13:20:50.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.174]                     {
[13:20:50.174]                       inherits <- base::inherits
[13:20:50.174]                       invokeRestart <- base::invokeRestart
[13:20:50.174]                       is.null <- base::is.null
[13:20:50.174]                       muffled <- FALSE
[13:20:50.174]                       if (inherits(cond, "message")) {
[13:20:50.174]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.174]                         if (muffled) 
[13:20:50.174]                           invokeRestart("muffleMessage")
[13:20:50.174]                       }
[13:20:50.174]                       else if (inherits(cond, "warning")) {
[13:20:50.174]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.174]                         if (muffled) 
[13:20:50.174]                           invokeRestart("muffleWarning")
[13:20:50.174]                       }
[13:20:50.174]                       else if (inherits(cond, "condition")) {
[13:20:50.174]                         if (!is.null(pattern)) {
[13:20:50.174]                           computeRestarts <- base::computeRestarts
[13:20:50.174]                           grepl <- base::grepl
[13:20:50.174]                           restarts <- computeRestarts(cond)
[13:20:50.174]                           for (restart in restarts) {
[13:20:50.174]                             name <- restart$name
[13:20:50.174]                             if (is.null(name)) 
[13:20:50.174]                               next
[13:20:50.174]                             if (!grepl(pattern, name)) 
[13:20:50.174]                               next
[13:20:50.174]                             invokeRestart(restart)
[13:20:50.174]                             muffled <- TRUE
[13:20:50.174]                             break
[13:20:50.174]                           }
[13:20:50.174]                         }
[13:20:50.174]                       }
[13:20:50.174]                       invisible(muffled)
[13:20:50.174]                     }
[13:20:50.174]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.174]                   }
[13:20:50.174]                 }
[13:20:50.174]             }
[13:20:50.174]         }))
[13:20:50.174]     }, error = function(ex) {
[13:20:50.174]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.174]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.174]                 ...future.rng), started = ...future.startTime, 
[13:20:50.174]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.174]             version = "1.8"), class = "FutureResult")
[13:20:50.174]     }, finally = {
[13:20:50.174]         if (!identical(...future.workdir, getwd())) 
[13:20:50.174]             setwd(...future.workdir)
[13:20:50.174]         {
[13:20:50.174]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.174]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.174]             }
[13:20:50.174]             base::options(...future.oldOptions)
[13:20:50.174]             if (.Platform$OS.type == "windows") {
[13:20:50.174]                 old_names <- names(...future.oldEnvVars)
[13:20:50.174]                 envs <- base::Sys.getenv()
[13:20:50.174]                 names <- names(envs)
[13:20:50.174]                 common <- intersect(names, old_names)
[13:20:50.174]                 added <- setdiff(names, old_names)
[13:20:50.174]                 removed <- setdiff(old_names, names)
[13:20:50.174]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.174]                   envs[common]]
[13:20:50.174]                 NAMES <- toupper(changed)
[13:20:50.174]                 args <- list()
[13:20:50.174]                 for (kk in seq_along(NAMES)) {
[13:20:50.174]                   name <- changed[[kk]]
[13:20:50.174]                   NAME <- NAMES[[kk]]
[13:20:50.174]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.174]                     next
[13:20:50.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.174]                 }
[13:20:50.174]                 NAMES <- toupper(added)
[13:20:50.174]                 for (kk in seq_along(NAMES)) {
[13:20:50.174]                   name <- added[[kk]]
[13:20:50.174]                   NAME <- NAMES[[kk]]
[13:20:50.174]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.174]                     next
[13:20:50.174]                   args[[name]] <- ""
[13:20:50.174]                 }
[13:20:50.174]                 NAMES <- toupper(removed)
[13:20:50.174]                 for (kk in seq_along(NAMES)) {
[13:20:50.174]                   name <- removed[[kk]]
[13:20:50.174]                   NAME <- NAMES[[kk]]
[13:20:50.174]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.174]                     next
[13:20:50.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.174]                 }
[13:20:50.174]                 if (length(args) > 0) 
[13:20:50.174]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.174]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.174]             }
[13:20:50.174]             else {
[13:20:50.174]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.174]             }
[13:20:50.174]             {
[13:20:50.174]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.174]                   0L) {
[13:20:50.174]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.174]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.174]                   base::options(opts)
[13:20:50.174]                 }
[13:20:50.174]                 {
[13:20:50.174]                   {
[13:20:50.174]                     NULL
[13:20:50.174]                     RNGkind("Mersenne-Twister")
[13:20:50.174]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.174]                       inherits = FALSE)
[13:20:50.174]                   }
[13:20:50.174]                   options(future.plan = NULL)
[13:20:50.174]                   if (is.na(NA_character_)) 
[13:20:50.174]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.174]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.174]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.174]                   {
[13:20:50.174]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.174]                     if (!future$lazy) 
[13:20:50.174]                       future <- run(future)
[13:20:50.174]                     invisible(future)
[13:20:50.174]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.174]                 }
[13:20:50.174]             }
[13:20:50.174]         }
[13:20:50.174]     })
[13:20:50.174]     if (TRUE) {
[13:20:50.174]         base::sink(type = "output", split = FALSE)
[13:20:50.174]         if (TRUE) {
[13:20:50.174]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.174]         }
[13:20:50.174]         else {
[13:20:50.174]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.174]         }
[13:20:50.174]         base::close(...future.stdout)
[13:20:50.174]         ...future.stdout <- NULL
[13:20:50.174]     }
[13:20:50.174]     ...future.result$conditions <- ...future.conditions
[13:20:50.174]     ...future.result$finished <- base::Sys.time()
[13:20:50.174]     ...future.result
[13:20:50.174] }
[13:20:50.176] assign_globals() ...
[13:20:50.176] List of 1
[13:20:50.176]  $ ii: int 2
[13:20:50.176]  - attr(*, "where")=List of 1
[13:20:50.176]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:50.176]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.176]  - attr(*, "resolved")= logi TRUE
[13:20:50.176]  - attr(*, "total_size")= num 56
[13:20:50.176]  - attr(*, "already-done")= logi TRUE
[13:20:50.179] - copied ‘ii’ to environment
[13:20:50.179] assign_globals() ... done
[13:20:50.179] plan(): Setting new future strategy stack:
[13:20:50.179] List of future strategies:
[13:20:50.179] 1. sequential:
[13:20:50.179]    - args: function (..., envir = parent.frame())
[13:20:50.179]    - tweaked: FALSE
[13:20:50.179]    - call: NULL
[13:20:50.179] plan(): nbrOfWorkers() = 1
[13:20:50.180] plan(): Setting new future strategy stack:
[13:20:50.180] List of future strategies:
[13:20:50.180] 1. sequential:
[13:20:50.180]    - args: function (..., envir = parent.frame())
[13:20:50.180]    - tweaked: FALSE
[13:20:50.180]    - call: plan(strategy)
[13:20:50.181] plan(): nbrOfWorkers() = 1
[13:20:50.181] SequentialFuture started (and completed)
[13:20:50.181] - Launch lazy future ... done
[13:20:50.181] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.181] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.182] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.183] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.183] Searching for globals ... DONE
[13:20:50.183] Resolving globals: TRUE
[13:20:50.183] Resolving any globals that are futures ...
[13:20:50.183] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.184] Resolving any globals that are futures ... DONE
[13:20:50.184] Resolving futures part of globals (recursively) ...
[13:20:50.184] resolve() on list ...
[13:20:50.184]  recursive: 99
[13:20:50.184]  length: 1
[13:20:50.184]  elements: ‘ii’
[13:20:50.184]  length: 0 (resolved future 1)
[13:20:50.185] resolve() on list ... DONE
[13:20:50.185] - globals: [1] ‘ii’
[13:20:50.185] Resolving futures part of globals (recursively) ... DONE
[13:20:50.185] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:50.185] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:50.185] - globals: [1] ‘ii’
[13:20:50.185] 
[13:20:50.186] getGlobalsAndPackages() ... DONE
[13:20:50.186] run() for ‘Future’ ...
[13:20:50.186] - state: ‘created’
[13:20:50.186] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.186] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.186] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.186]   - Field: ‘label’
[13:20:50.187]   - Field: ‘local’
[13:20:50.187]   - Field: ‘owner’
[13:20:50.187]   - Field: ‘envir’
[13:20:50.187]   - Field: ‘packages’
[13:20:50.187]   - Field: ‘gc’
[13:20:50.187]   - Field: ‘conditions’
[13:20:50.187]   - Field: ‘expr’
[13:20:50.187]   - Field: ‘uuid’
[13:20:50.187]   - Field: ‘seed’
[13:20:50.187]   - Field: ‘version’
[13:20:50.187]   - Field: ‘result’
[13:20:50.188]   - Field: ‘asynchronous’
[13:20:50.188]   - Field: ‘calls’
[13:20:50.188]   - Field: ‘globals’
[13:20:50.188]   - Field: ‘stdout’
[13:20:50.188]   - Field: ‘earlySignal’
[13:20:50.188]   - Field: ‘lazy’
[13:20:50.188]   - Field: ‘state’
[13:20:50.188] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.188] - Launch lazy future ...
[13:20:50.189] Packages needed by the future expression (n = 0): <none>
[13:20:50.189] Packages needed by future strategies (n = 0): <none>
[13:20:50.189] {
[13:20:50.189]     {
[13:20:50.189]         {
[13:20:50.189]             ...future.startTime <- base::Sys.time()
[13:20:50.189]             {
[13:20:50.189]                 {
[13:20:50.189]                   {
[13:20:50.189]                     base::local({
[13:20:50.189]                       has_future <- base::requireNamespace("future", 
[13:20:50.189]                         quietly = TRUE)
[13:20:50.189]                       if (has_future) {
[13:20:50.189]                         ns <- base::getNamespace("future")
[13:20:50.189]                         version <- ns[[".package"]][["version"]]
[13:20:50.189]                         if (is.null(version)) 
[13:20:50.189]                           version <- utils::packageVersion("future")
[13:20:50.189]                       }
[13:20:50.189]                       else {
[13:20:50.189]                         version <- NULL
[13:20:50.189]                       }
[13:20:50.189]                       if (!has_future || version < "1.8.0") {
[13:20:50.189]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.189]                           "", base::R.version$version.string), 
[13:20:50.189]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.189]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.189]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.189]                             "release", "version")], collapse = " "), 
[13:20:50.189]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.189]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.189]                           info)
[13:20:50.189]                         info <- base::paste(info, collapse = "; ")
[13:20:50.189]                         if (!has_future) {
[13:20:50.189]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.189]                             info)
[13:20:50.189]                         }
[13:20:50.189]                         else {
[13:20:50.189]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.189]                             info, version)
[13:20:50.189]                         }
[13:20:50.189]                         base::stop(msg)
[13:20:50.189]                       }
[13:20:50.189]                     })
[13:20:50.189]                   }
[13:20:50.189]                   options(future.plan = NULL)
[13:20:50.189]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.189]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.189]                 }
[13:20:50.189]                 ...future.workdir <- getwd()
[13:20:50.189]             }
[13:20:50.189]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.189]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.189]         }
[13:20:50.189]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.189]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:50.189]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.189]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.189]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.189]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.189]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.189]             base::names(...future.oldOptions))
[13:20:50.189]     }
[13:20:50.189]     if (FALSE) {
[13:20:50.189]     }
[13:20:50.189]     else {
[13:20:50.189]         if (TRUE) {
[13:20:50.189]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.189]                 open = "w")
[13:20:50.189]         }
[13:20:50.189]         else {
[13:20:50.189]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.189]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.189]         }
[13:20:50.189]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.189]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.189]             base::sink(type = "output", split = FALSE)
[13:20:50.189]             base::close(...future.stdout)
[13:20:50.189]         }, add = TRUE)
[13:20:50.189]     }
[13:20:50.189]     ...future.frame <- base::sys.nframe()
[13:20:50.189]     ...future.conditions <- base::list()
[13:20:50.189]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.189]     if (FALSE) {
[13:20:50.189]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.189]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.189]     }
[13:20:50.189]     ...future.result <- base::tryCatch({
[13:20:50.189]         base::withCallingHandlers({
[13:20:50.189]             ...future.value <- base::withVisible(base::local({
[13:20:50.189]                 b <- a * ii
[13:20:50.189]                 a <- 0
[13:20:50.189]                 b
[13:20:50.189]             }))
[13:20:50.189]             future::FutureResult(value = ...future.value$value, 
[13:20:50.189]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.189]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.189]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.189]                     ...future.globalenv.names))
[13:20:50.189]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.189]         }, condition = base::local({
[13:20:50.189]             c <- base::c
[13:20:50.189]             inherits <- base::inherits
[13:20:50.189]             invokeRestart <- base::invokeRestart
[13:20:50.189]             length <- base::length
[13:20:50.189]             list <- base::list
[13:20:50.189]             seq.int <- base::seq.int
[13:20:50.189]             signalCondition <- base::signalCondition
[13:20:50.189]             sys.calls <- base::sys.calls
[13:20:50.189]             `[[` <- base::`[[`
[13:20:50.189]             `+` <- base::`+`
[13:20:50.189]             `<<-` <- base::`<<-`
[13:20:50.189]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.189]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.189]                   3L)]
[13:20:50.189]             }
[13:20:50.189]             function(cond) {
[13:20:50.189]                 is_error <- inherits(cond, "error")
[13:20:50.189]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.189]                   NULL)
[13:20:50.189]                 if (is_error) {
[13:20:50.189]                   sessionInformation <- function() {
[13:20:50.189]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.189]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.189]                       search = base::search(), system = base::Sys.info())
[13:20:50.189]                   }
[13:20:50.189]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.189]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.189]                     cond$call), session = sessionInformation(), 
[13:20:50.189]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.189]                   signalCondition(cond)
[13:20:50.189]                 }
[13:20:50.189]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.189]                 "immediateCondition"))) {
[13:20:50.189]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.189]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.189]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.189]                   if (TRUE && !signal) {
[13:20:50.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.189]                     {
[13:20:50.189]                       inherits <- base::inherits
[13:20:50.189]                       invokeRestart <- base::invokeRestart
[13:20:50.189]                       is.null <- base::is.null
[13:20:50.189]                       muffled <- FALSE
[13:20:50.189]                       if (inherits(cond, "message")) {
[13:20:50.189]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.189]                         if (muffled) 
[13:20:50.189]                           invokeRestart("muffleMessage")
[13:20:50.189]                       }
[13:20:50.189]                       else if (inherits(cond, "warning")) {
[13:20:50.189]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.189]                         if (muffled) 
[13:20:50.189]                           invokeRestart("muffleWarning")
[13:20:50.189]                       }
[13:20:50.189]                       else if (inherits(cond, "condition")) {
[13:20:50.189]                         if (!is.null(pattern)) {
[13:20:50.189]                           computeRestarts <- base::computeRestarts
[13:20:50.189]                           grepl <- base::grepl
[13:20:50.189]                           restarts <- computeRestarts(cond)
[13:20:50.189]                           for (restart in restarts) {
[13:20:50.189]                             name <- restart$name
[13:20:50.189]                             if (is.null(name)) 
[13:20:50.189]                               next
[13:20:50.189]                             if (!grepl(pattern, name)) 
[13:20:50.189]                               next
[13:20:50.189]                             invokeRestart(restart)
[13:20:50.189]                             muffled <- TRUE
[13:20:50.189]                             break
[13:20:50.189]                           }
[13:20:50.189]                         }
[13:20:50.189]                       }
[13:20:50.189]                       invisible(muffled)
[13:20:50.189]                     }
[13:20:50.189]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.189]                   }
[13:20:50.189]                 }
[13:20:50.189]                 else {
[13:20:50.189]                   if (TRUE) {
[13:20:50.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.189]                     {
[13:20:50.189]                       inherits <- base::inherits
[13:20:50.189]                       invokeRestart <- base::invokeRestart
[13:20:50.189]                       is.null <- base::is.null
[13:20:50.189]                       muffled <- FALSE
[13:20:50.189]                       if (inherits(cond, "message")) {
[13:20:50.189]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.189]                         if (muffled) 
[13:20:50.189]                           invokeRestart("muffleMessage")
[13:20:50.189]                       }
[13:20:50.189]                       else if (inherits(cond, "warning")) {
[13:20:50.189]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.189]                         if (muffled) 
[13:20:50.189]                           invokeRestart("muffleWarning")
[13:20:50.189]                       }
[13:20:50.189]                       else if (inherits(cond, "condition")) {
[13:20:50.189]                         if (!is.null(pattern)) {
[13:20:50.189]                           computeRestarts <- base::computeRestarts
[13:20:50.189]                           grepl <- base::grepl
[13:20:50.189]                           restarts <- computeRestarts(cond)
[13:20:50.189]                           for (restart in restarts) {
[13:20:50.189]                             name <- restart$name
[13:20:50.189]                             if (is.null(name)) 
[13:20:50.189]                               next
[13:20:50.189]                             if (!grepl(pattern, name)) 
[13:20:50.189]                               next
[13:20:50.189]                             invokeRestart(restart)
[13:20:50.189]                             muffled <- TRUE
[13:20:50.189]                             break
[13:20:50.189]                           }
[13:20:50.189]                         }
[13:20:50.189]                       }
[13:20:50.189]                       invisible(muffled)
[13:20:50.189]                     }
[13:20:50.189]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.189]                   }
[13:20:50.189]                 }
[13:20:50.189]             }
[13:20:50.189]         }))
[13:20:50.189]     }, error = function(ex) {
[13:20:50.189]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.189]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.189]                 ...future.rng), started = ...future.startTime, 
[13:20:50.189]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.189]             version = "1.8"), class = "FutureResult")
[13:20:50.189]     }, finally = {
[13:20:50.189]         if (!identical(...future.workdir, getwd())) 
[13:20:50.189]             setwd(...future.workdir)
[13:20:50.189]         {
[13:20:50.189]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.189]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.189]             }
[13:20:50.189]             base::options(...future.oldOptions)
[13:20:50.189]             if (.Platform$OS.type == "windows") {
[13:20:50.189]                 old_names <- names(...future.oldEnvVars)
[13:20:50.189]                 envs <- base::Sys.getenv()
[13:20:50.189]                 names <- names(envs)
[13:20:50.189]                 common <- intersect(names, old_names)
[13:20:50.189]                 added <- setdiff(names, old_names)
[13:20:50.189]                 removed <- setdiff(old_names, names)
[13:20:50.189]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.189]                   envs[common]]
[13:20:50.189]                 NAMES <- toupper(changed)
[13:20:50.189]                 args <- list()
[13:20:50.189]                 for (kk in seq_along(NAMES)) {
[13:20:50.189]                   name <- changed[[kk]]
[13:20:50.189]                   NAME <- NAMES[[kk]]
[13:20:50.189]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.189]                     next
[13:20:50.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.189]                 }
[13:20:50.189]                 NAMES <- toupper(added)
[13:20:50.189]                 for (kk in seq_along(NAMES)) {
[13:20:50.189]                   name <- added[[kk]]
[13:20:50.189]                   NAME <- NAMES[[kk]]
[13:20:50.189]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.189]                     next
[13:20:50.189]                   args[[name]] <- ""
[13:20:50.189]                 }
[13:20:50.189]                 NAMES <- toupper(removed)
[13:20:50.189]                 for (kk in seq_along(NAMES)) {
[13:20:50.189]                   name <- removed[[kk]]
[13:20:50.189]                   NAME <- NAMES[[kk]]
[13:20:50.189]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.189]                     next
[13:20:50.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.189]                 }
[13:20:50.189]                 if (length(args) > 0) 
[13:20:50.189]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.189]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.189]             }
[13:20:50.189]             else {
[13:20:50.189]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.189]             }
[13:20:50.189]             {
[13:20:50.189]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.189]                   0L) {
[13:20:50.189]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.189]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.189]                   base::options(opts)
[13:20:50.189]                 }
[13:20:50.189]                 {
[13:20:50.189]                   {
[13:20:50.189]                     NULL
[13:20:50.189]                     RNGkind("Mersenne-Twister")
[13:20:50.189]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.189]                       inherits = FALSE)
[13:20:50.189]                   }
[13:20:50.189]                   options(future.plan = NULL)
[13:20:50.189]                   if (is.na(NA_character_)) 
[13:20:50.189]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.189]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.189]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.189]                   {
[13:20:50.189]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.189]                     if (!future$lazy) 
[13:20:50.189]                       future <- run(future)
[13:20:50.189]                     invisible(future)
[13:20:50.189]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.189]                 }
[13:20:50.189]             }
[13:20:50.189]         }
[13:20:50.189]     })
[13:20:50.189]     if (TRUE) {
[13:20:50.189]         base::sink(type = "output", split = FALSE)
[13:20:50.189]         if (TRUE) {
[13:20:50.189]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.189]         }
[13:20:50.189]         else {
[13:20:50.189]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.189]         }
[13:20:50.189]         base::close(...future.stdout)
[13:20:50.189]         ...future.stdout <- NULL
[13:20:50.189]     }
[13:20:50.189]     ...future.result$conditions <- ...future.conditions
[13:20:50.189]     ...future.result$finished <- base::Sys.time()
[13:20:50.189]     ...future.result
[13:20:50.189] }
[13:20:50.191] assign_globals() ...
[13:20:50.191] List of 1
[13:20:50.191]  $ ii: int 3
[13:20:50.191]  - attr(*, "where")=List of 1
[13:20:50.191]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:50.191]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.191]  - attr(*, "resolved")= logi TRUE
[13:20:50.191]  - attr(*, "total_size")= num 56
[13:20:50.191]  - attr(*, "already-done")= logi TRUE
[13:20:50.193] - copied ‘ii’ to environment
[13:20:50.193] assign_globals() ... done
[13:20:50.194] plan(): Setting new future strategy stack:
[13:20:50.194] List of future strategies:
[13:20:50.194] 1. sequential:
[13:20:50.194]    - args: function (..., envir = parent.frame())
[13:20:50.194]    - tweaked: FALSE
[13:20:50.194]    - call: NULL
[13:20:50.194] plan(): nbrOfWorkers() = 1
[13:20:50.195] plan(): Setting new future strategy stack:
[13:20:50.195] List of future strategies:
[13:20:50.195] 1. sequential:
[13:20:50.195]    - args: function (..., envir = parent.frame())
[13:20:50.195]    - tweaked: FALSE
[13:20:50.195]    - call: plan(strategy)
[13:20:50.195] plan(): nbrOfWorkers() = 1
[13:20:50.195] SequentialFuture started (and completed)
[13:20:50.195] - Launch lazy future ... done
[13:20:50.196] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.197] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.197] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.198] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.198] Searching for globals ... DONE
[13:20:50.198] Resolving globals: TRUE
[13:20:50.198] Resolving any globals that are futures ...
[13:20:50.198] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.199] Resolving any globals that are futures ... DONE
[13:20:50.199] Resolving futures part of globals (recursively) ...
[13:20:50.199] resolve() on list ...
[13:20:50.199]  recursive: 99
[13:20:50.199]  length: 1
[13:20:50.199]  elements: ‘ii’
[13:20:50.200]  length: 0 (resolved future 1)
[13:20:50.200] resolve() on list ... DONE
[13:20:50.200] - globals: [1] ‘ii’
[13:20:50.200] Resolving futures part of globals (recursively) ... DONE
[13:20:50.202] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:50.202] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:50.202] - globals: [1] ‘ii’
[13:20:50.202] 
[13:20:50.202] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.203] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.203] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.204] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.205] Searching for globals ... DONE
[13:20:50.205] Resolving globals: TRUE
[13:20:50.205] Resolving any globals that are futures ...
[13:20:50.205] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.205] Resolving any globals that are futures ... DONE
[13:20:50.205] Resolving futures part of globals (recursively) ...
[13:20:50.206] resolve() on list ...
[13:20:50.206]  recursive: 99
[13:20:50.206]  length: 1
[13:20:50.206]  elements: ‘ii’
[13:20:50.206]  length: 0 (resolved future 1)
[13:20:50.206] resolve() on list ... DONE
[13:20:50.206] - globals: [1] ‘ii’
[13:20:50.206] Resolving futures part of globals (recursively) ... DONE
[13:20:50.206] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:50.207] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:50.207] - globals: [1] ‘ii’
[13:20:50.207] 
[13:20:50.207] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.208] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.208] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.209] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.209] Searching for globals ... DONE
[13:20:50.209] Resolving globals: TRUE
[13:20:50.209] Resolving any globals that are futures ...
[13:20:50.209] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.210] Resolving any globals that are futures ... DONE
[13:20:50.210] Resolving futures part of globals (recursively) ...
[13:20:50.210] resolve() on list ...
[13:20:50.210]  recursive: 99
[13:20:50.210]  length: 1
[13:20:50.210]  elements: ‘ii’
[13:20:50.210]  length: 0 (resolved future 1)
[13:20:50.210] resolve() on list ... DONE
[13:20:50.211] - globals: [1] ‘ii’
[13:20:50.211] Resolving futures part of globals (recursively) ... DONE
[13:20:50.211] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:50.211] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:50.211] - globals: [1] ‘ii’
[13:20:50.211] 
[13:20:50.211] getGlobalsAndPackages() ... DONE
[13:20:50.212] run() for ‘Future’ ...
[13:20:50.212] - state: ‘created’
[13:20:50.212] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.212] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.212] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.212]   - Field: ‘label’
[13:20:50.213]   - Field: ‘local’
[13:20:50.213]   - Field: ‘owner’
[13:20:50.213]   - Field: ‘envir’
[13:20:50.213]   - Field: ‘packages’
[13:20:50.213]   - Field: ‘gc’
[13:20:50.213]   - Field: ‘conditions’
[13:20:50.213]   - Field: ‘expr’
[13:20:50.213]   - Field: ‘uuid’
[13:20:50.213]   - Field: ‘seed’
[13:20:50.213]   - Field: ‘version’
[13:20:50.214]   - Field: ‘result’
[13:20:50.214]   - Field: ‘asynchronous’
[13:20:50.214]   - Field: ‘calls’
[13:20:50.214]   - Field: ‘globals’
[13:20:50.214]   - Field: ‘stdout’
[13:20:50.214]   - Field: ‘earlySignal’
[13:20:50.214]   - Field: ‘lazy’
[13:20:50.214]   - Field: ‘state’
[13:20:50.214] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.214] - Launch lazy future ...
[13:20:50.215] Packages needed by the future expression (n = 0): <none>
[13:20:50.215] Packages needed by future strategies (n = 0): <none>
[13:20:50.215] {
[13:20:50.215]     {
[13:20:50.215]         {
[13:20:50.215]             ...future.startTime <- base::Sys.time()
[13:20:50.215]             {
[13:20:50.215]                 {
[13:20:50.215]                   {
[13:20:50.215]                     base::local({
[13:20:50.215]                       has_future <- base::requireNamespace("future", 
[13:20:50.215]                         quietly = TRUE)
[13:20:50.215]                       if (has_future) {
[13:20:50.215]                         ns <- base::getNamespace("future")
[13:20:50.215]                         version <- ns[[".package"]][["version"]]
[13:20:50.215]                         if (is.null(version)) 
[13:20:50.215]                           version <- utils::packageVersion("future")
[13:20:50.215]                       }
[13:20:50.215]                       else {
[13:20:50.215]                         version <- NULL
[13:20:50.215]                       }
[13:20:50.215]                       if (!has_future || version < "1.8.0") {
[13:20:50.215]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.215]                           "", base::R.version$version.string), 
[13:20:50.215]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.215]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.215]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.215]                             "release", "version")], collapse = " "), 
[13:20:50.215]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.215]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.215]                           info)
[13:20:50.215]                         info <- base::paste(info, collapse = "; ")
[13:20:50.215]                         if (!has_future) {
[13:20:50.215]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.215]                             info)
[13:20:50.215]                         }
[13:20:50.215]                         else {
[13:20:50.215]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.215]                             info, version)
[13:20:50.215]                         }
[13:20:50.215]                         base::stop(msg)
[13:20:50.215]                       }
[13:20:50.215]                     })
[13:20:50.215]                   }
[13:20:50.215]                   options(future.plan = NULL)
[13:20:50.215]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.215]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.215]                 }
[13:20:50.215]                 ...future.workdir <- getwd()
[13:20:50.215]             }
[13:20:50.215]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.215]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.215]         }
[13:20:50.215]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.215]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:50.215]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.215]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.215]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.215]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.215]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.215]             base::names(...future.oldOptions))
[13:20:50.215]     }
[13:20:50.215]     if (FALSE) {
[13:20:50.215]     }
[13:20:50.215]     else {
[13:20:50.215]         if (TRUE) {
[13:20:50.215]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.215]                 open = "w")
[13:20:50.215]         }
[13:20:50.215]         else {
[13:20:50.215]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.215]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.215]         }
[13:20:50.215]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.215]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.215]             base::sink(type = "output", split = FALSE)
[13:20:50.215]             base::close(...future.stdout)
[13:20:50.215]         }, add = TRUE)
[13:20:50.215]     }
[13:20:50.215]     ...future.frame <- base::sys.nframe()
[13:20:50.215]     ...future.conditions <- base::list()
[13:20:50.215]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.215]     if (FALSE) {
[13:20:50.215]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.215]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.215]     }
[13:20:50.215]     ...future.result <- base::tryCatch({
[13:20:50.215]         base::withCallingHandlers({
[13:20:50.215]             ...future.value <- base::withVisible(base::local({
[13:20:50.215]                 b <- a * ii
[13:20:50.215]                 a <- 0
[13:20:50.215]                 b
[13:20:50.215]             }))
[13:20:50.215]             future::FutureResult(value = ...future.value$value, 
[13:20:50.215]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.215]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.215]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.215]                     ...future.globalenv.names))
[13:20:50.215]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.215]         }, condition = base::local({
[13:20:50.215]             c <- base::c
[13:20:50.215]             inherits <- base::inherits
[13:20:50.215]             invokeRestart <- base::invokeRestart
[13:20:50.215]             length <- base::length
[13:20:50.215]             list <- base::list
[13:20:50.215]             seq.int <- base::seq.int
[13:20:50.215]             signalCondition <- base::signalCondition
[13:20:50.215]             sys.calls <- base::sys.calls
[13:20:50.215]             `[[` <- base::`[[`
[13:20:50.215]             `+` <- base::`+`
[13:20:50.215]             `<<-` <- base::`<<-`
[13:20:50.215]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.215]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.215]                   3L)]
[13:20:50.215]             }
[13:20:50.215]             function(cond) {
[13:20:50.215]                 is_error <- inherits(cond, "error")
[13:20:50.215]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.215]                   NULL)
[13:20:50.215]                 if (is_error) {
[13:20:50.215]                   sessionInformation <- function() {
[13:20:50.215]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.215]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.215]                       search = base::search(), system = base::Sys.info())
[13:20:50.215]                   }
[13:20:50.215]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.215]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.215]                     cond$call), session = sessionInformation(), 
[13:20:50.215]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.215]                   signalCondition(cond)
[13:20:50.215]                 }
[13:20:50.215]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.215]                 "immediateCondition"))) {
[13:20:50.215]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.215]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.215]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.215]                   if (TRUE && !signal) {
[13:20:50.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.215]                     {
[13:20:50.215]                       inherits <- base::inherits
[13:20:50.215]                       invokeRestart <- base::invokeRestart
[13:20:50.215]                       is.null <- base::is.null
[13:20:50.215]                       muffled <- FALSE
[13:20:50.215]                       if (inherits(cond, "message")) {
[13:20:50.215]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.215]                         if (muffled) 
[13:20:50.215]                           invokeRestart("muffleMessage")
[13:20:50.215]                       }
[13:20:50.215]                       else if (inherits(cond, "warning")) {
[13:20:50.215]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.215]                         if (muffled) 
[13:20:50.215]                           invokeRestart("muffleWarning")
[13:20:50.215]                       }
[13:20:50.215]                       else if (inherits(cond, "condition")) {
[13:20:50.215]                         if (!is.null(pattern)) {
[13:20:50.215]                           computeRestarts <- base::computeRestarts
[13:20:50.215]                           grepl <- base::grepl
[13:20:50.215]                           restarts <- computeRestarts(cond)
[13:20:50.215]                           for (restart in restarts) {
[13:20:50.215]                             name <- restart$name
[13:20:50.215]                             if (is.null(name)) 
[13:20:50.215]                               next
[13:20:50.215]                             if (!grepl(pattern, name)) 
[13:20:50.215]                               next
[13:20:50.215]                             invokeRestart(restart)
[13:20:50.215]                             muffled <- TRUE
[13:20:50.215]                             break
[13:20:50.215]                           }
[13:20:50.215]                         }
[13:20:50.215]                       }
[13:20:50.215]                       invisible(muffled)
[13:20:50.215]                     }
[13:20:50.215]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.215]                   }
[13:20:50.215]                 }
[13:20:50.215]                 else {
[13:20:50.215]                   if (TRUE) {
[13:20:50.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.215]                     {
[13:20:50.215]                       inherits <- base::inherits
[13:20:50.215]                       invokeRestart <- base::invokeRestart
[13:20:50.215]                       is.null <- base::is.null
[13:20:50.215]                       muffled <- FALSE
[13:20:50.215]                       if (inherits(cond, "message")) {
[13:20:50.215]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.215]                         if (muffled) 
[13:20:50.215]                           invokeRestart("muffleMessage")
[13:20:50.215]                       }
[13:20:50.215]                       else if (inherits(cond, "warning")) {
[13:20:50.215]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.215]                         if (muffled) 
[13:20:50.215]                           invokeRestart("muffleWarning")
[13:20:50.215]                       }
[13:20:50.215]                       else if (inherits(cond, "condition")) {
[13:20:50.215]                         if (!is.null(pattern)) {
[13:20:50.215]                           computeRestarts <- base::computeRestarts
[13:20:50.215]                           grepl <- base::grepl
[13:20:50.215]                           restarts <- computeRestarts(cond)
[13:20:50.215]                           for (restart in restarts) {
[13:20:50.215]                             name <- restart$name
[13:20:50.215]                             if (is.null(name)) 
[13:20:50.215]                               next
[13:20:50.215]                             if (!grepl(pattern, name)) 
[13:20:50.215]                               next
[13:20:50.215]                             invokeRestart(restart)
[13:20:50.215]                             muffled <- TRUE
[13:20:50.215]                             break
[13:20:50.215]                           }
[13:20:50.215]                         }
[13:20:50.215]                       }
[13:20:50.215]                       invisible(muffled)
[13:20:50.215]                     }
[13:20:50.215]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.215]                   }
[13:20:50.215]                 }
[13:20:50.215]             }
[13:20:50.215]         }))
[13:20:50.215]     }, error = function(ex) {
[13:20:50.215]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.215]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.215]                 ...future.rng), started = ...future.startTime, 
[13:20:50.215]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.215]             version = "1.8"), class = "FutureResult")
[13:20:50.215]     }, finally = {
[13:20:50.215]         if (!identical(...future.workdir, getwd())) 
[13:20:50.215]             setwd(...future.workdir)
[13:20:50.215]         {
[13:20:50.215]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.215]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.215]             }
[13:20:50.215]             base::options(...future.oldOptions)
[13:20:50.215]             if (.Platform$OS.type == "windows") {
[13:20:50.215]                 old_names <- names(...future.oldEnvVars)
[13:20:50.215]                 envs <- base::Sys.getenv()
[13:20:50.215]                 names <- names(envs)
[13:20:50.215]                 common <- intersect(names, old_names)
[13:20:50.215]                 added <- setdiff(names, old_names)
[13:20:50.215]                 removed <- setdiff(old_names, names)
[13:20:50.215]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.215]                   envs[common]]
[13:20:50.215]                 NAMES <- toupper(changed)
[13:20:50.215]                 args <- list()
[13:20:50.215]                 for (kk in seq_along(NAMES)) {
[13:20:50.215]                   name <- changed[[kk]]
[13:20:50.215]                   NAME <- NAMES[[kk]]
[13:20:50.215]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.215]                     next
[13:20:50.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.215]                 }
[13:20:50.215]                 NAMES <- toupper(added)
[13:20:50.215]                 for (kk in seq_along(NAMES)) {
[13:20:50.215]                   name <- added[[kk]]
[13:20:50.215]                   NAME <- NAMES[[kk]]
[13:20:50.215]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.215]                     next
[13:20:50.215]                   args[[name]] <- ""
[13:20:50.215]                 }
[13:20:50.215]                 NAMES <- toupper(removed)
[13:20:50.215]                 for (kk in seq_along(NAMES)) {
[13:20:50.215]                   name <- removed[[kk]]
[13:20:50.215]                   NAME <- NAMES[[kk]]
[13:20:50.215]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.215]                     next
[13:20:50.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.215]                 }
[13:20:50.215]                 if (length(args) > 0) 
[13:20:50.215]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.215]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.215]             }
[13:20:50.215]             else {
[13:20:50.215]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.215]             }
[13:20:50.215]             {
[13:20:50.215]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.215]                   0L) {
[13:20:50.215]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.215]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.215]                   base::options(opts)
[13:20:50.215]                 }
[13:20:50.215]                 {
[13:20:50.215]                   {
[13:20:50.215]                     NULL
[13:20:50.215]                     RNGkind("Mersenne-Twister")
[13:20:50.215]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.215]                       inherits = FALSE)
[13:20:50.215]                   }
[13:20:50.215]                   options(future.plan = NULL)
[13:20:50.215]                   if (is.na(NA_character_)) 
[13:20:50.215]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.215]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.215]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.215]                   {
[13:20:50.215]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.215]                     if (!future$lazy) 
[13:20:50.215]                       future <- run(future)
[13:20:50.215]                     invisible(future)
[13:20:50.215]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.215]                 }
[13:20:50.215]             }
[13:20:50.215]         }
[13:20:50.215]     })
[13:20:50.215]     if (TRUE) {
[13:20:50.215]         base::sink(type = "output", split = FALSE)
[13:20:50.215]         if (TRUE) {
[13:20:50.215]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.215]         }
[13:20:50.215]         else {
[13:20:50.215]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.215]         }
[13:20:50.215]         base::close(...future.stdout)
[13:20:50.215]         ...future.stdout <- NULL
[13:20:50.215]     }
[13:20:50.215]     ...future.result$conditions <- ...future.conditions
[13:20:50.215]     ...future.result$finished <- base::Sys.time()
[13:20:50.215]     ...future.result
[13:20:50.215] }
[13:20:50.217] assign_globals() ...
[13:20:50.217] List of 1
[13:20:50.217]  $ ii: int 1
[13:20:50.217]  - attr(*, "where")=List of 1
[13:20:50.217]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:50.217]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.217]  - attr(*, "resolved")= logi TRUE
[13:20:50.217]  - attr(*, "total_size")= num 56
[13:20:50.217]  - attr(*, "already-done")= logi TRUE
[13:20:50.219] - copied ‘ii’ to environment
[13:20:50.219] assign_globals() ... done
[13:20:50.220] plan(): Setting new future strategy stack:
[13:20:50.220] List of future strategies:
[13:20:50.220] 1. sequential:
[13:20:50.220]    - args: function (..., envir = parent.frame())
[13:20:50.220]    - tweaked: FALSE
[13:20:50.220]    - call: NULL
[13:20:50.220] plan(): nbrOfWorkers() = 1
[13:20:50.221] plan(): Setting new future strategy stack:
[13:20:50.221] List of future strategies:
[13:20:50.221] 1. sequential:
[13:20:50.221]    - args: function (..., envir = parent.frame())
[13:20:50.221]    - tweaked: FALSE
[13:20:50.221]    - call: plan(strategy)
[13:20:50.221] plan(): nbrOfWorkers() = 1
[13:20:50.222] SequentialFuture started (and completed)
[13:20:50.222] signalConditions() ...
[13:20:50.222]  - include = ‘immediateCondition’
[13:20:50.222]  - exclude = 
[13:20:50.222]  - resignal = FALSE
[13:20:50.222]  - Number of conditions: 1
[13:20:50.222] signalConditions() ... done
[13:20:50.222] - Launch lazy future ... done
[13:20:50.222] run() for ‘SequentialFuture’ ... done
[13:20:50.222] signalConditions() ...
[13:20:50.222]  - include = ‘immediateCondition’
[13:20:50.223]  - exclude = 
[13:20:50.223]  - resignal = FALSE
[13:20:50.223]  - Number of conditions: 1
[13:20:50.223] signalConditions() ... done
[13:20:50.223] Future state: ‘finished’
[13:20:50.223] signalConditions() ...
[13:20:50.223]  - include = ‘condition’
[13:20:50.223]  - exclude = ‘immediateCondition’
[13:20:50.223]  - resignal = TRUE
[13:20:50.223]  - Number of conditions: 1
[13:20:50.224]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:50.224] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a * ii ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a * ii ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "5853cd8d1af0" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:20:50"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.239] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.239] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.239] 
[13:20:50.239] Searching for globals ... DONE
[13:20:50.240] - globals: [0] <none>
[13:20:50.240] getGlobalsAndPackages() ... DONE
[13:20:50.240] run() for ‘Future’ ...
[13:20:50.240] - state: ‘created’
[13:20:50.240] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.240] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.241] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.241]   - Field: ‘label’
[13:20:50.241]   - Field: ‘local’
[13:20:50.241]   - Field: ‘owner’
[13:20:50.241]   - Field: ‘envir’
[13:20:50.241]   - Field: ‘packages’
[13:20:50.241]   - Field: ‘gc’
[13:20:50.241]   - Field: ‘conditions’
[13:20:50.241]   - Field: ‘expr’
[13:20:50.241]   - Field: ‘uuid’
[13:20:50.241]   - Field: ‘seed’
[13:20:50.242]   - Field: ‘version’
[13:20:50.242]   - Field: ‘result’
[13:20:50.242]   - Field: ‘asynchronous’
[13:20:50.242]   - Field: ‘calls’
[13:20:50.242]   - Field: ‘globals’
[13:20:50.242]   - Field: ‘stdout’
[13:20:50.242]   - Field: ‘earlySignal’
[13:20:50.242]   - Field: ‘lazy’
[13:20:50.242]   - Field: ‘state’
[13:20:50.242] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.243] - Launch lazy future ...
[13:20:50.243] Packages needed by the future expression (n = 0): <none>
[13:20:50.243] Packages needed by future strategies (n = 0): <none>
[13:20:50.243] {
[13:20:50.243]     {
[13:20:50.243]         {
[13:20:50.243]             ...future.startTime <- base::Sys.time()
[13:20:50.243]             {
[13:20:50.243]                 {
[13:20:50.243]                   {
[13:20:50.243]                     base::local({
[13:20:50.243]                       has_future <- base::requireNamespace("future", 
[13:20:50.243]                         quietly = TRUE)
[13:20:50.243]                       if (has_future) {
[13:20:50.243]                         ns <- base::getNamespace("future")
[13:20:50.243]                         version <- ns[[".package"]][["version"]]
[13:20:50.243]                         if (is.null(version)) 
[13:20:50.243]                           version <- utils::packageVersion("future")
[13:20:50.243]                       }
[13:20:50.243]                       else {
[13:20:50.243]                         version <- NULL
[13:20:50.243]                       }
[13:20:50.243]                       if (!has_future || version < "1.8.0") {
[13:20:50.243]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.243]                           "", base::R.version$version.string), 
[13:20:50.243]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.243]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.243]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.243]                             "release", "version")], collapse = " "), 
[13:20:50.243]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.243]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.243]                           info)
[13:20:50.243]                         info <- base::paste(info, collapse = "; ")
[13:20:50.243]                         if (!has_future) {
[13:20:50.243]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.243]                             info)
[13:20:50.243]                         }
[13:20:50.243]                         else {
[13:20:50.243]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.243]                             info, version)
[13:20:50.243]                         }
[13:20:50.243]                         base::stop(msg)
[13:20:50.243]                       }
[13:20:50.243]                     })
[13:20:50.243]                   }
[13:20:50.243]                   options(future.plan = NULL)
[13:20:50.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.243]                 }
[13:20:50.243]                 ...future.workdir <- getwd()
[13:20:50.243]             }
[13:20:50.243]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.243]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.243]         }
[13:20:50.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.243]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:50.243]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.243]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.243]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.243]             base::names(...future.oldOptions))
[13:20:50.243]     }
[13:20:50.243]     if (FALSE) {
[13:20:50.243]     }
[13:20:50.243]     else {
[13:20:50.243]         if (TRUE) {
[13:20:50.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.243]                 open = "w")
[13:20:50.243]         }
[13:20:50.243]         else {
[13:20:50.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.243]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.243]         }
[13:20:50.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.243]             base::sink(type = "output", split = FALSE)
[13:20:50.243]             base::close(...future.stdout)
[13:20:50.243]         }, add = TRUE)
[13:20:50.243]     }
[13:20:50.243]     ...future.frame <- base::sys.nframe()
[13:20:50.243]     ...future.conditions <- base::list()
[13:20:50.243]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.243]     if (FALSE) {
[13:20:50.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.243]     }
[13:20:50.243]     ...future.result <- base::tryCatch({
[13:20:50.243]         base::withCallingHandlers({
[13:20:50.243]             ...future.value <- base::withVisible(base::local(1))
[13:20:50.243]             future::FutureResult(value = ...future.value$value, 
[13:20:50.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.243]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.243]                     ...future.globalenv.names))
[13:20:50.243]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.243]         }, condition = base::local({
[13:20:50.243]             c <- base::c
[13:20:50.243]             inherits <- base::inherits
[13:20:50.243]             invokeRestart <- base::invokeRestart
[13:20:50.243]             length <- base::length
[13:20:50.243]             list <- base::list
[13:20:50.243]             seq.int <- base::seq.int
[13:20:50.243]             signalCondition <- base::signalCondition
[13:20:50.243]             sys.calls <- base::sys.calls
[13:20:50.243]             `[[` <- base::`[[`
[13:20:50.243]             `+` <- base::`+`
[13:20:50.243]             `<<-` <- base::`<<-`
[13:20:50.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.243]                   3L)]
[13:20:50.243]             }
[13:20:50.243]             function(cond) {
[13:20:50.243]                 is_error <- inherits(cond, "error")
[13:20:50.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.243]                   NULL)
[13:20:50.243]                 if (is_error) {
[13:20:50.243]                   sessionInformation <- function() {
[13:20:50.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.243]                       search = base::search(), system = base::Sys.info())
[13:20:50.243]                   }
[13:20:50.243]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.243]                     cond$call), session = sessionInformation(), 
[13:20:50.243]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.243]                   signalCondition(cond)
[13:20:50.243]                 }
[13:20:50.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.243]                 "immediateCondition"))) {
[13:20:50.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.243]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.243]                   if (TRUE && !signal) {
[13:20:50.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.243]                     {
[13:20:50.243]                       inherits <- base::inherits
[13:20:50.243]                       invokeRestart <- base::invokeRestart
[13:20:50.243]                       is.null <- base::is.null
[13:20:50.243]                       muffled <- FALSE
[13:20:50.243]                       if (inherits(cond, "message")) {
[13:20:50.243]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.243]                         if (muffled) 
[13:20:50.243]                           invokeRestart("muffleMessage")
[13:20:50.243]                       }
[13:20:50.243]                       else if (inherits(cond, "warning")) {
[13:20:50.243]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.243]                         if (muffled) 
[13:20:50.243]                           invokeRestart("muffleWarning")
[13:20:50.243]                       }
[13:20:50.243]                       else if (inherits(cond, "condition")) {
[13:20:50.243]                         if (!is.null(pattern)) {
[13:20:50.243]                           computeRestarts <- base::computeRestarts
[13:20:50.243]                           grepl <- base::grepl
[13:20:50.243]                           restarts <- computeRestarts(cond)
[13:20:50.243]                           for (restart in restarts) {
[13:20:50.243]                             name <- restart$name
[13:20:50.243]                             if (is.null(name)) 
[13:20:50.243]                               next
[13:20:50.243]                             if (!grepl(pattern, name)) 
[13:20:50.243]                               next
[13:20:50.243]                             invokeRestart(restart)
[13:20:50.243]                             muffled <- TRUE
[13:20:50.243]                             break
[13:20:50.243]                           }
[13:20:50.243]                         }
[13:20:50.243]                       }
[13:20:50.243]                       invisible(muffled)
[13:20:50.243]                     }
[13:20:50.243]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.243]                   }
[13:20:50.243]                 }
[13:20:50.243]                 else {
[13:20:50.243]                   if (TRUE) {
[13:20:50.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.243]                     {
[13:20:50.243]                       inherits <- base::inherits
[13:20:50.243]                       invokeRestart <- base::invokeRestart
[13:20:50.243]                       is.null <- base::is.null
[13:20:50.243]                       muffled <- FALSE
[13:20:50.243]                       if (inherits(cond, "message")) {
[13:20:50.243]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.243]                         if (muffled) 
[13:20:50.243]                           invokeRestart("muffleMessage")
[13:20:50.243]                       }
[13:20:50.243]                       else if (inherits(cond, "warning")) {
[13:20:50.243]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.243]                         if (muffled) 
[13:20:50.243]                           invokeRestart("muffleWarning")
[13:20:50.243]                       }
[13:20:50.243]                       else if (inherits(cond, "condition")) {
[13:20:50.243]                         if (!is.null(pattern)) {
[13:20:50.243]                           computeRestarts <- base::computeRestarts
[13:20:50.243]                           grepl <- base::grepl
[13:20:50.243]                           restarts <- computeRestarts(cond)
[13:20:50.243]                           for (restart in restarts) {
[13:20:50.243]                             name <- restart$name
[13:20:50.243]                             if (is.null(name)) 
[13:20:50.243]                               next
[13:20:50.243]                             if (!grepl(pattern, name)) 
[13:20:50.243]                               next
[13:20:50.243]                             invokeRestart(restart)
[13:20:50.243]                             muffled <- TRUE
[13:20:50.243]                             break
[13:20:50.243]                           }
[13:20:50.243]                         }
[13:20:50.243]                       }
[13:20:50.243]                       invisible(muffled)
[13:20:50.243]                     }
[13:20:50.243]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.243]                   }
[13:20:50.243]                 }
[13:20:50.243]             }
[13:20:50.243]         }))
[13:20:50.243]     }, error = function(ex) {
[13:20:50.243]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.243]                 ...future.rng), started = ...future.startTime, 
[13:20:50.243]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.243]             version = "1.8"), class = "FutureResult")
[13:20:50.243]     }, finally = {
[13:20:50.243]         if (!identical(...future.workdir, getwd())) 
[13:20:50.243]             setwd(...future.workdir)
[13:20:50.243]         {
[13:20:50.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.243]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.243]             }
[13:20:50.243]             base::options(...future.oldOptions)
[13:20:50.243]             if (.Platform$OS.type == "windows") {
[13:20:50.243]                 old_names <- names(...future.oldEnvVars)
[13:20:50.243]                 envs <- base::Sys.getenv()
[13:20:50.243]                 names <- names(envs)
[13:20:50.243]                 common <- intersect(names, old_names)
[13:20:50.243]                 added <- setdiff(names, old_names)
[13:20:50.243]                 removed <- setdiff(old_names, names)
[13:20:50.243]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.243]                   envs[common]]
[13:20:50.243]                 NAMES <- toupper(changed)
[13:20:50.243]                 args <- list()
[13:20:50.243]                 for (kk in seq_along(NAMES)) {
[13:20:50.243]                   name <- changed[[kk]]
[13:20:50.243]                   NAME <- NAMES[[kk]]
[13:20:50.243]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.243]                     next
[13:20:50.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.243]                 }
[13:20:50.243]                 NAMES <- toupper(added)
[13:20:50.243]                 for (kk in seq_along(NAMES)) {
[13:20:50.243]                   name <- added[[kk]]
[13:20:50.243]                   NAME <- NAMES[[kk]]
[13:20:50.243]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.243]                     next
[13:20:50.243]                   args[[name]] <- ""
[13:20:50.243]                 }
[13:20:50.243]                 NAMES <- toupper(removed)
[13:20:50.243]                 for (kk in seq_along(NAMES)) {
[13:20:50.243]                   name <- removed[[kk]]
[13:20:50.243]                   NAME <- NAMES[[kk]]
[13:20:50.243]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.243]                     next
[13:20:50.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.243]                 }
[13:20:50.243]                 if (length(args) > 0) 
[13:20:50.243]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.243]             }
[13:20:50.243]             else {
[13:20:50.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.243]             }
[13:20:50.243]             {
[13:20:50.243]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.243]                   0L) {
[13:20:50.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.243]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.243]                   base::options(opts)
[13:20:50.243]                 }
[13:20:50.243]                 {
[13:20:50.243]                   {
[13:20:50.243]                     NULL
[13:20:50.243]                     RNGkind("Mersenne-Twister")
[13:20:50.243]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.243]                       inherits = FALSE)
[13:20:50.243]                   }
[13:20:50.243]                   options(future.plan = NULL)
[13:20:50.243]                   if (is.na(NA_character_)) 
[13:20:50.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.243]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.243]                   {
[13:20:50.243]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.243]                     if (!future$lazy) 
[13:20:50.243]                       future <- run(future)
[13:20:50.243]                     invisible(future)
[13:20:50.243]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.243]                 }
[13:20:50.243]             }
[13:20:50.243]         }
[13:20:50.243]     })
[13:20:50.243]     if (TRUE) {
[13:20:50.243]         base::sink(type = "output", split = FALSE)
[13:20:50.243]         if (TRUE) {
[13:20:50.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.243]         }
[13:20:50.243]         else {
[13:20:50.243]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.243]         }
[13:20:50.243]         base::close(...future.stdout)
[13:20:50.243]         ...future.stdout <- NULL
[13:20:50.243]     }
[13:20:50.243]     ...future.result$conditions <- ...future.conditions
[13:20:50.243]     ...future.result$finished <- base::Sys.time()
[13:20:50.243]     ...future.result
[13:20:50.243] }
[13:20:50.245] plan(): Setting new future strategy stack:
[13:20:50.245] List of future strategies:
[13:20:50.245] 1. sequential:
[13:20:50.245]    - args: function (..., envir = parent.frame())
[13:20:50.245]    - tweaked: FALSE
[13:20:50.245]    - call: NULL
[13:20:50.246] plan(): nbrOfWorkers() = 1
[13:20:50.246] plan(): Setting new future strategy stack:
[13:20:50.246] List of future strategies:
[13:20:50.246] 1. sequential:
[13:20:50.246]    - args: function (..., envir = parent.frame())
[13:20:50.246]    - tweaked: FALSE
[13:20:50.246]    - call: plan(strategy)
[13:20:50.247] plan(): nbrOfWorkers() = 1
[13:20:50.247] SequentialFuture started (and completed)
[13:20:50.247] - Launch lazy future ... done
[13:20:50.247] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.247] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.248] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.249] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:50.249] Searching for globals ... DONE
[13:20:50.249] Resolving globals: TRUE
[13:20:50.249] Resolving any globals that are futures ...
[13:20:50.249] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:50.249] Resolving any globals that are futures ... DONE
[13:20:50.249] Resolving futures part of globals (recursively) ...
[13:20:50.250] resolve() on list ...
[13:20:50.250]  recursive: 99
[13:20:50.250]  length: 1
[13:20:50.250]  elements: ‘a’
[13:20:50.250] resolved() for ‘SequentialFuture’ ...
[13:20:50.250] - state: ‘finished’
[13:20:50.250] - run: TRUE
[13:20:50.250] - result: ‘FutureResult’
[13:20:50.251] resolved() for ‘SequentialFuture’ ... done
[13:20:50.251] Future #1
[13:20:50.251] resolved() for ‘SequentialFuture’ ...
[13:20:50.251] - state: ‘finished’
[13:20:50.251] - run: TRUE
[13:20:50.251] - result: ‘FutureResult’
[13:20:50.251] resolved() for ‘SequentialFuture’ ... done
[13:20:50.251] A SequentialFuture was resolved
[13:20:50.252]  length: 0 (resolved future 1)
[13:20:50.252] resolve() on list ... DONE
[13:20:50.252] - globals: [1] ‘a’
[13:20:50.252] Resolving futures part of globals (recursively) ... DONE
[13:20:50.253] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[13:20:50.255] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[13:20:50.255] - globals: [1] ‘a’
[13:20:50.255] - packages: [1] ‘future’
[13:20:50.255] getGlobalsAndPackages() ... DONE
[13:20:50.255] run() for ‘Future’ ...
[13:20:50.255] - state: ‘created’
[13:20:50.256] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.256] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.256] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.256]   - Field: ‘label’
[13:20:50.256]   - Field: ‘local’
[13:20:50.256]   - Field: ‘owner’
[13:20:50.256]   - Field: ‘envir’
[13:20:50.257]   - Field: ‘packages’
[13:20:50.257]   - Field: ‘gc’
[13:20:50.257]   - Field: ‘conditions’
[13:20:50.257]   - Field: ‘expr’
[13:20:50.257]   - Field: ‘uuid’
[13:20:50.257]   - Field: ‘seed’
[13:20:50.257]   - Field: ‘version’
[13:20:50.257]   - Field: ‘result’
[13:20:50.257]   - Field: ‘asynchronous’
[13:20:50.257]   - Field: ‘calls’
[13:20:50.258]   - Field: ‘globals’
[13:20:50.258]   - Field: ‘stdout’
[13:20:50.258]   - Field: ‘earlySignal’
[13:20:50.258]   - Field: ‘lazy’
[13:20:50.258]   - Field: ‘state’
[13:20:50.258] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.258] - Launch lazy future ...
[13:20:50.258] Packages needed by the future expression (n = 1): ‘future’
[13:20:50.258] Packages needed by future strategies (n = 0): <none>
[13:20:50.259] {
[13:20:50.259]     {
[13:20:50.259]         {
[13:20:50.259]             ...future.startTime <- base::Sys.time()
[13:20:50.259]             {
[13:20:50.259]                 {
[13:20:50.259]                   {
[13:20:50.259]                     {
[13:20:50.259]                       base::local({
[13:20:50.259]                         has_future <- base::requireNamespace("future", 
[13:20:50.259]                           quietly = TRUE)
[13:20:50.259]                         if (has_future) {
[13:20:50.259]                           ns <- base::getNamespace("future")
[13:20:50.259]                           version <- ns[[".package"]][["version"]]
[13:20:50.259]                           if (is.null(version)) 
[13:20:50.259]                             version <- utils::packageVersion("future")
[13:20:50.259]                         }
[13:20:50.259]                         else {
[13:20:50.259]                           version <- NULL
[13:20:50.259]                         }
[13:20:50.259]                         if (!has_future || version < "1.8.0") {
[13:20:50.259]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.259]                             "", base::R.version$version.string), 
[13:20:50.259]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:50.259]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.259]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.259]                               "release", "version")], collapse = " "), 
[13:20:50.259]                             hostname = base::Sys.info()[["nodename"]])
[13:20:50.259]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.259]                             info)
[13:20:50.259]                           info <- base::paste(info, collapse = "; ")
[13:20:50.259]                           if (!has_future) {
[13:20:50.259]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.259]                               info)
[13:20:50.259]                           }
[13:20:50.259]                           else {
[13:20:50.259]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.259]                               info, version)
[13:20:50.259]                           }
[13:20:50.259]                           base::stop(msg)
[13:20:50.259]                         }
[13:20:50.259]                       })
[13:20:50.259]                     }
[13:20:50.259]                     base::local({
[13:20:50.259]                       for (pkg in "future") {
[13:20:50.259]                         base::loadNamespace(pkg)
[13:20:50.259]                         base::library(pkg, character.only = TRUE)
[13:20:50.259]                       }
[13:20:50.259]                     })
[13:20:50.259]                   }
[13:20:50.259]                   options(future.plan = NULL)
[13:20:50.259]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.259]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.259]                 }
[13:20:50.259]                 ...future.workdir <- getwd()
[13:20:50.259]             }
[13:20:50.259]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.259]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.259]         }
[13:20:50.259]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.259]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:50.259]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.259]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.259]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.259]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.259]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.259]             base::names(...future.oldOptions))
[13:20:50.259]     }
[13:20:50.259]     if (FALSE) {
[13:20:50.259]     }
[13:20:50.259]     else {
[13:20:50.259]         if (TRUE) {
[13:20:50.259]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.259]                 open = "w")
[13:20:50.259]         }
[13:20:50.259]         else {
[13:20:50.259]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.259]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.259]         }
[13:20:50.259]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.259]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.259]             base::sink(type = "output", split = FALSE)
[13:20:50.259]             base::close(...future.stdout)
[13:20:50.259]         }, add = TRUE)
[13:20:50.259]     }
[13:20:50.259]     ...future.frame <- base::sys.nframe()
[13:20:50.259]     ...future.conditions <- base::list()
[13:20:50.259]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.259]     if (FALSE) {
[13:20:50.259]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.259]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.259]     }
[13:20:50.259]     ...future.result <- base::tryCatch({
[13:20:50.259]         base::withCallingHandlers({
[13:20:50.259]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:20:50.259]                 1))
[13:20:50.259]             future::FutureResult(value = ...future.value$value, 
[13:20:50.259]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.259]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.259]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.259]                     ...future.globalenv.names))
[13:20:50.259]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.259]         }, condition = base::local({
[13:20:50.259]             c <- base::c
[13:20:50.259]             inherits <- base::inherits
[13:20:50.259]             invokeRestart <- base::invokeRestart
[13:20:50.259]             length <- base::length
[13:20:50.259]             list <- base::list
[13:20:50.259]             seq.int <- base::seq.int
[13:20:50.259]             signalCondition <- base::signalCondition
[13:20:50.259]             sys.calls <- base::sys.calls
[13:20:50.259]             `[[` <- base::`[[`
[13:20:50.259]             `+` <- base::`+`
[13:20:50.259]             `<<-` <- base::`<<-`
[13:20:50.259]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.259]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.259]                   3L)]
[13:20:50.259]             }
[13:20:50.259]             function(cond) {
[13:20:50.259]                 is_error <- inherits(cond, "error")
[13:20:50.259]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.259]                   NULL)
[13:20:50.259]                 if (is_error) {
[13:20:50.259]                   sessionInformation <- function() {
[13:20:50.259]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.259]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.259]                       search = base::search(), system = base::Sys.info())
[13:20:50.259]                   }
[13:20:50.259]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.259]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.259]                     cond$call), session = sessionInformation(), 
[13:20:50.259]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.259]                   signalCondition(cond)
[13:20:50.259]                 }
[13:20:50.259]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.259]                 "immediateCondition"))) {
[13:20:50.259]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.259]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.259]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.259]                   if (TRUE && !signal) {
[13:20:50.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.259]                     {
[13:20:50.259]                       inherits <- base::inherits
[13:20:50.259]                       invokeRestart <- base::invokeRestart
[13:20:50.259]                       is.null <- base::is.null
[13:20:50.259]                       muffled <- FALSE
[13:20:50.259]                       if (inherits(cond, "message")) {
[13:20:50.259]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.259]                         if (muffled) 
[13:20:50.259]                           invokeRestart("muffleMessage")
[13:20:50.259]                       }
[13:20:50.259]                       else if (inherits(cond, "warning")) {
[13:20:50.259]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.259]                         if (muffled) 
[13:20:50.259]                           invokeRestart("muffleWarning")
[13:20:50.259]                       }
[13:20:50.259]                       else if (inherits(cond, "condition")) {
[13:20:50.259]                         if (!is.null(pattern)) {
[13:20:50.259]                           computeRestarts <- base::computeRestarts
[13:20:50.259]                           grepl <- base::grepl
[13:20:50.259]                           restarts <- computeRestarts(cond)
[13:20:50.259]                           for (restart in restarts) {
[13:20:50.259]                             name <- restart$name
[13:20:50.259]                             if (is.null(name)) 
[13:20:50.259]                               next
[13:20:50.259]                             if (!grepl(pattern, name)) 
[13:20:50.259]                               next
[13:20:50.259]                             invokeRestart(restart)
[13:20:50.259]                             muffled <- TRUE
[13:20:50.259]                             break
[13:20:50.259]                           }
[13:20:50.259]                         }
[13:20:50.259]                       }
[13:20:50.259]                       invisible(muffled)
[13:20:50.259]                     }
[13:20:50.259]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.259]                   }
[13:20:50.259]                 }
[13:20:50.259]                 else {
[13:20:50.259]                   if (TRUE) {
[13:20:50.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.259]                     {
[13:20:50.259]                       inherits <- base::inherits
[13:20:50.259]                       invokeRestart <- base::invokeRestart
[13:20:50.259]                       is.null <- base::is.null
[13:20:50.259]                       muffled <- FALSE
[13:20:50.259]                       if (inherits(cond, "message")) {
[13:20:50.259]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.259]                         if (muffled) 
[13:20:50.259]                           invokeRestart("muffleMessage")
[13:20:50.259]                       }
[13:20:50.259]                       else if (inherits(cond, "warning")) {
[13:20:50.259]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.259]                         if (muffled) 
[13:20:50.259]                           invokeRestart("muffleWarning")
[13:20:50.259]                       }
[13:20:50.259]                       else if (inherits(cond, "condition")) {
[13:20:50.259]                         if (!is.null(pattern)) {
[13:20:50.259]                           computeRestarts <- base::computeRestarts
[13:20:50.259]                           grepl <- base::grepl
[13:20:50.259]                           restarts <- computeRestarts(cond)
[13:20:50.259]                           for (restart in restarts) {
[13:20:50.259]                             name <- restart$name
[13:20:50.259]                             if (is.null(name)) 
[13:20:50.259]                               next
[13:20:50.259]                             if (!grepl(pattern, name)) 
[13:20:50.259]                               next
[13:20:50.259]                             invokeRestart(restart)
[13:20:50.259]                             muffled <- TRUE
[13:20:50.259]                             break
[13:20:50.259]                           }
[13:20:50.259]                         }
[13:20:50.259]                       }
[13:20:50.259]                       invisible(muffled)
[13:20:50.259]                     }
[13:20:50.259]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.259]                   }
[13:20:50.259]                 }
[13:20:50.259]             }
[13:20:50.259]         }))
[13:20:50.259]     }, error = function(ex) {
[13:20:50.259]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.259]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.259]                 ...future.rng), started = ...future.startTime, 
[13:20:50.259]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.259]             version = "1.8"), class = "FutureResult")
[13:20:50.259]     }, finally = {
[13:20:50.259]         if (!identical(...future.workdir, getwd())) 
[13:20:50.259]             setwd(...future.workdir)
[13:20:50.259]         {
[13:20:50.259]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.259]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.259]             }
[13:20:50.259]             base::options(...future.oldOptions)
[13:20:50.259]             if (.Platform$OS.type == "windows") {
[13:20:50.259]                 old_names <- names(...future.oldEnvVars)
[13:20:50.259]                 envs <- base::Sys.getenv()
[13:20:50.259]                 names <- names(envs)
[13:20:50.259]                 common <- intersect(names, old_names)
[13:20:50.259]                 added <- setdiff(names, old_names)
[13:20:50.259]                 removed <- setdiff(old_names, names)
[13:20:50.259]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.259]                   envs[common]]
[13:20:50.259]                 NAMES <- toupper(changed)
[13:20:50.259]                 args <- list()
[13:20:50.259]                 for (kk in seq_along(NAMES)) {
[13:20:50.259]                   name <- changed[[kk]]
[13:20:50.259]                   NAME <- NAMES[[kk]]
[13:20:50.259]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.259]                     next
[13:20:50.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.259]                 }
[13:20:50.259]                 NAMES <- toupper(added)
[13:20:50.259]                 for (kk in seq_along(NAMES)) {
[13:20:50.259]                   name <- added[[kk]]
[13:20:50.259]                   NAME <- NAMES[[kk]]
[13:20:50.259]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.259]                     next
[13:20:50.259]                   args[[name]] <- ""
[13:20:50.259]                 }
[13:20:50.259]                 NAMES <- toupper(removed)
[13:20:50.259]                 for (kk in seq_along(NAMES)) {
[13:20:50.259]                   name <- removed[[kk]]
[13:20:50.259]                   NAME <- NAMES[[kk]]
[13:20:50.259]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.259]                     next
[13:20:50.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.259]                 }
[13:20:50.259]                 if (length(args) > 0) 
[13:20:50.259]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.259]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.259]             }
[13:20:50.259]             else {
[13:20:50.259]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.259]             }
[13:20:50.259]             {
[13:20:50.259]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.259]                   0L) {
[13:20:50.259]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.259]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.259]                   base::options(opts)
[13:20:50.259]                 }
[13:20:50.259]                 {
[13:20:50.259]                   {
[13:20:50.259]                     NULL
[13:20:50.259]                     RNGkind("Mersenne-Twister")
[13:20:50.259]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.259]                       inherits = FALSE)
[13:20:50.259]                   }
[13:20:50.259]                   options(future.plan = NULL)
[13:20:50.259]                   if (is.na(NA_character_)) 
[13:20:50.259]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.259]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.259]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.259]                   {
[13:20:50.259]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.259]                     if (!future$lazy) 
[13:20:50.259]                       future <- run(future)
[13:20:50.259]                     invisible(future)
[13:20:50.259]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.259]                 }
[13:20:50.259]             }
[13:20:50.259]         }
[13:20:50.259]     })
[13:20:50.259]     if (TRUE) {
[13:20:50.259]         base::sink(type = "output", split = FALSE)
[13:20:50.259]         if (TRUE) {
[13:20:50.259]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.259]         }
[13:20:50.259]         else {
[13:20:50.259]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.259]         }
[13:20:50.259]         base::close(...future.stdout)
[13:20:50.259]         ...future.stdout <- NULL
[13:20:50.259]     }
[13:20:50.259]     ...future.result$conditions <- ...future.conditions
[13:20:50.259]     ...future.result$finished <- base::Sys.time()
[13:20:50.259]     ...future.result
[13:20:50.259] }
[13:20:50.261] assign_globals() ...
[13:20:50.261] List of 1
[13:20:50.261]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x558ddff55108> 
[13:20:50.261]  - attr(*, "where")=List of 1
[13:20:50.261]   ..$ a:<environment: R_EmptyEnv> 
[13:20:50.261]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.261]  - attr(*, "resolved")= logi TRUE
[13:20:50.261]  - attr(*, "total_size")= num 10424
[13:20:50.261]  - attr(*, "already-done")= logi TRUE
[13:20:50.263] - copied ‘a’ to environment
[13:20:50.263] assign_globals() ... done
[13:20:50.264] plan(): Setting new future strategy stack:
[13:20:50.264] List of future strategies:
[13:20:50.264] 1. sequential:
[13:20:50.264]    - args: function (..., envir = parent.frame())
[13:20:50.264]    - tweaked: FALSE
[13:20:50.264]    - call: NULL
[13:20:50.264] plan(): nbrOfWorkers() = 1
[13:20:50.265] plan(): Setting new future strategy stack:
[13:20:50.265] List of future strategies:
[13:20:50.265] 1. sequential:
[13:20:50.265]    - args: function (..., envir = parent.frame())
[13:20:50.265]    - tweaked: FALSE
[13:20:50.265]    - call: plan(strategy)
[13:20:50.265] plan(): nbrOfWorkers() = 1
[13:20:50.266] SequentialFuture started (and completed)
[13:20:50.266] - Launch lazy future ... done
[13:20:50.266] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.266] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.266] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.267] 
[13:20:50.267] Searching for globals ... DONE
[13:20:50.267] - globals: [0] <none>
[13:20:50.267] getGlobalsAndPackages() ... DONE
[13:20:50.267] run() for ‘Future’ ...
[13:20:50.268] - state: ‘created’
[13:20:50.268] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.268] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.268] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.268]   - Field: ‘label’
[13:20:50.268]   - Field: ‘local’
[13:20:50.268]   - Field: ‘owner’
[13:20:50.268]   - Field: ‘envir’
[13:20:50.269]   - Field: ‘packages’
[13:20:50.269]   - Field: ‘gc’
[13:20:50.269]   - Field: ‘conditions’
[13:20:50.269]   - Field: ‘expr’
[13:20:50.269]   - Field: ‘uuid’
[13:20:50.269]   - Field: ‘seed’
[13:20:50.269]   - Field: ‘version’
[13:20:50.269]   - Field: ‘result’
[13:20:50.269]   - Field: ‘asynchronous’
[13:20:50.269]   - Field: ‘calls’
[13:20:50.270]   - Field: ‘globals’
[13:20:50.270]   - Field: ‘stdout’
[13:20:50.270]   - Field: ‘earlySignal’
[13:20:50.270]   - Field: ‘lazy’
[13:20:50.270]   - Field: ‘state’
[13:20:50.270] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.270] - Launch lazy future ...
[13:20:50.270] Packages needed by the future expression (n = 0): <none>
[13:20:50.270] Packages needed by future strategies (n = 0): <none>
[13:20:50.271] {
[13:20:50.271]     {
[13:20:50.271]         {
[13:20:50.271]             ...future.startTime <- base::Sys.time()
[13:20:50.271]             {
[13:20:50.271]                 {
[13:20:50.271]                   {
[13:20:50.271]                     base::local({
[13:20:50.271]                       has_future <- base::requireNamespace("future", 
[13:20:50.271]                         quietly = TRUE)
[13:20:50.271]                       if (has_future) {
[13:20:50.271]                         ns <- base::getNamespace("future")
[13:20:50.271]                         version <- ns[[".package"]][["version"]]
[13:20:50.271]                         if (is.null(version)) 
[13:20:50.271]                           version <- utils::packageVersion("future")
[13:20:50.271]                       }
[13:20:50.271]                       else {
[13:20:50.271]                         version <- NULL
[13:20:50.271]                       }
[13:20:50.271]                       if (!has_future || version < "1.8.0") {
[13:20:50.271]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.271]                           "", base::R.version$version.string), 
[13:20:50.271]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.271]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.271]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.271]                             "release", "version")], collapse = " "), 
[13:20:50.271]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.271]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.271]                           info)
[13:20:50.271]                         info <- base::paste(info, collapse = "; ")
[13:20:50.271]                         if (!has_future) {
[13:20:50.271]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.271]                             info)
[13:20:50.271]                         }
[13:20:50.271]                         else {
[13:20:50.271]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.271]                             info, version)
[13:20:50.271]                         }
[13:20:50.271]                         base::stop(msg)
[13:20:50.271]                       }
[13:20:50.271]                     })
[13:20:50.271]                   }
[13:20:50.271]                   options(future.plan = NULL)
[13:20:50.271]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.271]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.271]                 }
[13:20:50.271]                 ...future.workdir <- getwd()
[13:20:50.271]             }
[13:20:50.271]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.271]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.271]         }
[13:20:50.271]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.271]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:50.271]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.271]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.271]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.271]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.271]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.271]             base::names(...future.oldOptions))
[13:20:50.271]     }
[13:20:50.271]     if (FALSE) {
[13:20:50.271]     }
[13:20:50.271]     else {
[13:20:50.271]         if (TRUE) {
[13:20:50.271]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.271]                 open = "w")
[13:20:50.271]         }
[13:20:50.271]         else {
[13:20:50.271]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.271]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.271]         }
[13:20:50.271]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.271]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.271]             base::sink(type = "output", split = FALSE)
[13:20:50.271]             base::close(...future.stdout)
[13:20:50.271]         }, add = TRUE)
[13:20:50.271]     }
[13:20:50.271]     ...future.frame <- base::sys.nframe()
[13:20:50.271]     ...future.conditions <- base::list()
[13:20:50.271]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.271]     if (FALSE) {
[13:20:50.271]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.271]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.271]     }
[13:20:50.271]     ...future.result <- base::tryCatch({
[13:20:50.271]         base::withCallingHandlers({
[13:20:50.271]             ...future.value <- base::withVisible(base::local(1))
[13:20:50.271]             future::FutureResult(value = ...future.value$value, 
[13:20:50.271]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.271]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.271]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.271]                     ...future.globalenv.names))
[13:20:50.271]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.271]         }, condition = base::local({
[13:20:50.271]             c <- base::c
[13:20:50.271]             inherits <- base::inherits
[13:20:50.271]             invokeRestart <- base::invokeRestart
[13:20:50.271]             length <- base::length
[13:20:50.271]             list <- base::list
[13:20:50.271]             seq.int <- base::seq.int
[13:20:50.271]             signalCondition <- base::signalCondition
[13:20:50.271]             sys.calls <- base::sys.calls
[13:20:50.271]             `[[` <- base::`[[`
[13:20:50.271]             `+` <- base::`+`
[13:20:50.271]             `<<-` <- base::`<<-`
[13:20:50.271]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.271]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.271]                   3L)]
[13:20:50.271]             }
[13:20:50.271]             function(cond) {
[13:20:50.271]                 is_error <- inherits(cond, "error")
[13:20:50.271]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.271]                   NULL)
[13:20:50.271]                 if (is_error) {
[13:20:50.271]                   sessionInformation <- function() {
[13:20:50.271]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.271]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.271]                       search = base::search(), system = base::Sys.info())
[13:20:50.271]                   }
[13:20:50.271]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.271]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.271]                     cond$call), session = sessionInformation(), 
[13:20:50.271]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.271]                   signalCondition(cond)
[13:20:50.271]                 }
[13:20:50.271]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.271]                 "immediateCondition"))) {
[13:20:50.271]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.271]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.271]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.271]                   if (TRUE && !signal) {
[13:20:50.271]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.271]                     {
[13:20:50.271]                       inherits <- base::inherits
[13:20:50.271]                       invokeRestart <- base::invokeRestart
[13:20:50.271]                       is.null <- base::is.null
[13:20:50.271]                       muffled <- FALSE
[13:20:50.271]                       if (inherits(cond, "message")) {
[13:20:50.271]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.271]                         if (muffled) 
[13:20:50.271]                           invokeRestart("muffleMessage")
[13:20:50.271]                       }
[13:20:50.271]                       else if (inherits(cond, "warning")) {
[13:20:50.271]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.271]                         if (muffled) 
[13:20:50.271]                           invokeRestart("muffleWarning")
[13:20:50.271]                       }
[13:20:50.271]                       else if (inherits(cond, "condition")) {
[13:20:50.271]                         if (!is.null(pattern)) {
[13:20:50.271]                           computeRestarts <- base::computeRestarts
[13:20:50.271]                           grepl <- base::grepl
[13:20:50.271]                           restarts <- computeRestarts(cond)
[13:20:50.271]                           for (restart in restarts) {
[13:20:50.271]                             name <- restart$name
[13:20:50.271]                             if (is.null(name)) 
[13:20:50.271]                               next
[13:20:50.271]                             if (!grepl(pattern, name)) 
[13:20:50.271]                               next
[13:20:50.271]                             invokeRestart(restart)
[13:20:50.271]                             muffled <- TRUE
[13:20:50.271]                             break
[13:20:50.271]                           }
[13:20:50.271]                         }
[13:20:50.271]                       }
[13:20:50.271]                       invisible(muffled)
[13:20:50.271]                     }
[13:20:50.271]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.271]                   }
[13:20:50.271]                 }
[13:20:50.271]                 else {
[13:20:50.271]                   if (TRUE) {
[13:20:50.271]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.271]                     {
[13:20:50.271]                       inherits <- base::inherits
[13:20:50.271]                       invokeRestart <- base::invokeRestart
[13:20:50.271]                       is.null <- base::is.null
[13:20:50.271]                       muffled <- FALSE
[13:20:50.271]                       if (inherits(cond, "message")) {
[13:20:50.271]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.271]                         if (muffled) 
[13:20:50.271]                           invokeRestart("muffleMessage")
[13:20:50.271]                       }
[13:20:50.271]                       else if (inherits(cond, "warning")) {
[13:20:50.271]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.271]                         if (muffled) 
[13:20:50.271]                           invokeRestart("muffleWarning")
[13:20:50.271]                       }
[13:20:50.271]                       else if (inherits(cond, "condition")) {
[13:20:50.271]                         if (!is.null(pattern)) {
[13:20:50.271]                           computeRestarts <- base::computeRestarts
[13:20:50.271]                           grepl <- base::grepl
[13:20:50.271]                           restarts <- computeRestarts(cond)
[13:20:50.271]                           for (restart in restarts) {
[13:20:50.271]                             name <- restart$name
[13:20:50.271]                             if (is.null(name)) 
[13:20:50.271]                               next
[13:20:50.271]                             if (!grepl(pattern, name)) 
[13:20:50.271]                               next
[13:20:50.271]                             invokeRestart(restart)
[13:20:50.271]                             muffled <- TRUE
[13:20:50.271]                             break
[13:20:50.271]                           }
[13:20:50.271]                         }
[13:20:50.271]                       }
[13:20:50.271]                       invisible(muffled)
[13:20:50.271]                     }
[13:20:50.271]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.271]                   }
[13:20:50.271]                 }
[13:20:50.271]             }
[13:20:50.271]         }))
[13:20:50.271]     }, error = function(ex) {
[13:20:50.271]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.271]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.271]                 ...future.rng), started = ...future.startTime, 
[13:20:50.271]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.271]             version = "1.8"), class = "FutureResult")
[13:20:50.271]     }, finally = {
[13:20:50.271]         if (!identical(...future.workdir, getwd())) 
[13:20:50.271]             setwd(...future.workdir)
[13:20:50.271]         {
[13:20:50.271]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.271]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.271]             }
[13:20:50.271]             base::options(...future.oldOptions)
[13:20:50.271]             if (.Platform$OS.type == "windows") {
[13:20:50.271]                 old_names <- names(...future.oldEnvVars)
[13:20:50.271]                 envs <- base::Sys.getenv()
[13:20:50.271]                 names <- names(envs)
[13:20:50.271]                 common <- intersect(names, old_names)
[13:20:50.271]                 added <- setdiff(names, old_names)
[13:20:50.271]                 removed <- setdiff(old_names, names)
[13:20:50.271]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.271]                   envs[common]]
[13:20:50.271]                 NAMES <- toupper(changed)
[13:20:50.271]                 args <- list()
[13:20:50.271]                 for (kk in seq_along(NAMES)) {
[13:20:50.271]                   name <- changed[[kk]]
[13:20:50.271]                   NAME <- NAMES[[kk]]
[13:20:50.271]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.271]                     next
[13:20:50.271]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.271]                 }
[13:20:50.271]                 NAMES <- toupper(added)
[13:20:50.271]                 for (kk in seq_along(NAMES)) {
[13:20:50.271]                   name <- added[[kk]]
[13:20:50.271]                   NAME <- NAMES[[kk]]
[13:20:50.271]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.271]                     next
[13:20:50.271]                   args[[name]] <- ""
[13:20:50.271]                 }
[13:20:50.271]                 NAMES <- toupper(removed)
[13:20:50.271]                 for (kk in seq_along(NAMES)) {
[13:20:50.271]                   name <- removed[[kk]]
[13:20:50.271]                   NAME <- NAMES[[kk]]
[13:20:50.271]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.271]                     next
[13:20:50.271]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.271]                 }
[13:20:50.271]                 if (length(args) > 0) 
[13:20:50.271]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.271]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.271]             }
[13:20:50.271]             else {
[13:20:50.271]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.271]             }
[13:20:50.271]             {
[13:20:50.271]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.271]                   0L) {
[13:20:50.271]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.271]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.271]                   base::options(opts)
[13:20:50.271]                 }
[13:20:50.271]                 {
[13:20:50.271]                   {
[13:20:50.271]                     NULL
[13:20:50.271]                     RNGkind("Mersenne-Twister")
[13:20:50.271]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.271]                       inherits = FALSE)
[13:20:50.271]                   }
[13:20:50.271]                   options(future.plan = NULL)
[13:20:50.271]                   if (is.na(NA_character_)) 
[13:20:50.271]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.271]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.271]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.271]                   {
[13:20:50.271]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.271]                     if (!future$lazy) 
[13:20:50.271]                       future <- run(future)
[13:20:50.271]                     invisible(future)
[13:20:50.271]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.271]                 }
[13:20:50.271]             }
[13:20:50.271]         }
[13:20:50.271]     })
[13:20:50.271]     if (TRUE) {
[13:20:50.271]         base::sink(type = "output", split = FALSE)
[13:20:50.271]         if (TRUE) {
[13:20:50.271]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.271]         }
[13:20:50.271]         else {
[13:20:50.271]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.271]         }
[13:20:50.271]         base::close(...future.stdout)
[13:20:50.271]         ...future.stdout <- NULL
[13:20:50.271]     }
[13:20:50.271]     ...future.result$conditions <- ...future.conditions
[13:20:50.271]     ...future.result$finished <- base::Sys.time()
[13:20:50.271]     ...future.result
[13:20:50.271] }
[13:20:50.273] plan(): Setting new future strategy stack:
[13:20:50.273] List of future strategies:
[13:20:50.273] 1. sequential:
[13:20:50.273]    - args: function (..., envir = parent.frame())
[13:20:50.273]    - tweaked: FALSE
[13:20:50.273]    - call: NULL
[13:20:50.273] plan(): nbrOfWorkers() = 1
[13:20:50.274] plan(): Setting new future strategy stack:
[13:20:50.274] List of future strategies:
[13:20:50.274] 1. sequential:
[13:20:50.274]    - args: function (..., envir = parent.frame())
[13:20:50.274]    - tweaked: FALSE
[13:20:50.274]    - call: plan(strategy)
[13:20:50.274] plan(): nbrOfWorkers() = 1
[13:20:50.274] SequentialFuture started (and completed)
[13:20:50.274] - Launch lazy future ... done
[13:20:50.275] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.275] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.275] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.276] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:50.276] Searching for globals ... DONE
[13:20:50.276] Resolving globals: TRUE
[13:20:50.276] Resolving any globals that are futures ...
[13:20:50.276] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:50.276] Resolving any globals that are futures ... DONE
[13:20:50.277] Resolving futures part of globals (recursively) ...
[13:20:50.277] resolve() on list ...
[13:20:50.277]  recursive: 99
[13:20:50.277]  length: 1
[13:20:50.277]  elements: ‘a’
[13:20:50.277] resolved() for ‘SequentialFuture’ ...
[13:20:50.277] - state: ‘finished’
[13:20:50.278] - run: TRUE
[13:20:50.278] - result: ‘FutureResult’
[13:20:50.278] resolved() for ‘SequentialFuture’ ... done
[13:20:50.278] Future #1
[13:20:50.278] resolved() for ‘SequentialFuture’ ...
[13:20:50.278] - state: ‘finished’
[13:20:50.278] - run: TRUE
[13:20:50.278] - result: ‘FutureResult’
[13:20:50.278] resolved() for ‘SequentialFuture’ ... done
[13:20:50.278] A SequentialFuture was resolved
[13:20:50.279]  length: 0 (resolved future 1)
[13:20:50.279] resolve() on list ... DONE
[13:20:50.279] - globals: [1] ‘a’
[13:20:50.279] Resolving futures part of globals (recursively) ... DONE
[13:20:50.280] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[13:20:50.280] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[13:20:50.280] - globals: [1] ‘a’
[13:20:50.280] - packages: [1] ‘future’
[13:20:50.280] getGlobalsAndPackages() ... DONE
[13:20:50.281] run() for ‘Future’ ...
[13:20:50.281] - state: ‘created’
[13:20:50.281] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.281] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.281] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.281]   - Field: ‘label’
[13:20:50.281]   - Field: ‘local’
[13:20:50.281]   - Field: ‘owner’
[13:20:50.283]   - Field: ‘envir’
[13:20:50.283]   - Field: ‘packages’
[13:20:50.283]   - Field: ‘gc’
[13:20:50.283]   - Field: ‘conditions’
[13:20:50.284]   - Field: ‘expr’
[13:20:50.284]   - Field: ‘uuid’
[13:20:50.284]   - Field: ‘seed’
[13:20:50.284]   - Field: ‘version’
[13:20:50.284]   - Field: ‘result’
[13:20:50.284]   - Field: ‘asynchronous’
[13:20:50.284]   - Field: ‘calls’
[13:20:50.284]   - Field: ‘globals’
[13:20:50.284]   - Field: ‘stdout’
[13:20:50.284]   - Field: ‘earlySignal’
[13:20:50.285]   - Field: ‘lazy’
[13:20:50.285]   - Field: ‘state’
[13:20:50.285] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.285] - Launch lazy future ...
[13:20:50.285] Packages needed by the future expression (n = 1): ‘future’
[13:20:50.285] Packages needed by future strategies (n = 0): <none>
[13:20:50.286] {
[13:20:50.286]     {
[13:20:50.286]         {
[13:20:50.286]             ...future.startTime <- base::Sys.time()
[13:20:50.286]             {
[13:20:50.286]                 {
[13:20:50.286]                   {
[13:20:50.286]                     {
[13:20:50.286]                       base::local({
[13:20:50.286]                         has_future <- base::requireNamespace("future", 
[13:20:50.286]                           quietly = TRUE)
[13:20:50.286]                         if (has_future) {
[13:20:50.286]                           ns <- base::getNamespace("future")
[13:20:50.286]                           version <- ns[[".package"]][["version"]]
[13:20:50.286]                           if (is.null(version)) 
[13:20:50.286]                             version <- utils::packageVersion("future")
[13:20:50.286]                         }
[13:20:50.286]                         else {
[13:20:50.286]                           version <- NULL
[13:20:50.286]                         }
[13:20:50.286]                         if (!has_future || version < "1.8.0") {
[13:20:50.286]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.286]                             "", base::R.version$version.string), 
[13:20:50.286]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:50.286]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.286]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.286]                               "release", "version")], collapse = " "), 
[13:20:50.286]                             hostname = base::Sys.info()[["nodename"]])
[13:20:50.286]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.286]                             info)
[13:20:50.286]                           info <- base::paste(info, collapse = "; ")
[13:20:50.286]                           if (!has_future) {
[13:20:50.286]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.286]                               info)
[13:20:50.286]                           }
[13:20:50.286]                           else {
[13:20:50.286]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.286]                               info, version)
[13:20:50.286]                           }
[13:20:50.286]                           base::stop(msg)
[13:20:50.286]                         }
[13:20:50.286]                       })
[13:20:50.286]                     }
[13:20:50.286]                     base::local({
[13:20:50.286]                       for (pkg in "future") {
[13:20:50.286]                         base::loadNamespace(pkg)
[13:20:50.286]                         base::library(pkg, character.only = TRUE)
[13:20:50.286]                       }
[13:20:50.286]                     })
[13:20:50.286]                   }
[13:20:50.286]                   options(future.plan = NULL)
[13:20:50.286]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.286]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.286]                 }
[13:20:50.286]                 ...future.workdir <- getwd()
[13:20:50.286]             }
[13:20:50.286]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.286]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.286]         }
[13:20:50.286]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.286]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:50.286]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.286]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.286]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.286]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.286]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.286]             base::names(...future.oldOptions))
[13:20:50.286]     }
[13:20:50.286]     if (FALSE) {
[13:20:50.286]     }
[13:20:50.286]     else {
[13:20:50.286]         if (TRUE) {
[13:20:50.286]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.286]                 open = "w")
[13:20:50.286]         }
[13:20:50.286]         else {
[13:20:50.286]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.286]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.286]         }
[13:20:50.286]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.286]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.286]             base::sink(type = "output", split = FALSE)
[13:20:50.286]             base::close(...future.stdout)
[13:20:50.286]         }, add = TRUE)
[13:20:50.286]     }
[13:20:50.286]     ...future.frame <- base::sys.nframe()
[13:20:50.286]     ...future.conditions <- base::list()
[13:20:50.286]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.286]     if (FALSE) {
[13:20:50.286]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.286]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.286]     }
[13:20:50.286]     ...future.result <- base::tryCatch({
[13:20:50.286]         base::withCallingHandlers({
[13:20:50.286]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:20:50.286]                 1))
[13:20:50.286]             future::FutureResult(value = ...future.value$value, 
[13:20:50.286]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.286]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.286]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.286]                     ...future.globalenv.names))
[13:20:50.286]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.286]         }, condition = base::local({
[13:20:50.286]             c <- base::c
[13:20:50.286]             inherits <- base::inherits
[13:20:50.286]             invokeRestart <- base::invokeRestart
[13:20:50.286]             length <- base::length
[13:20:50.286]             list <- base::list
[13:20:50.286]             seq.int <- base::seq.int
[13:20:50.286]             signalCondition <- base::signalCondition
[13:20:50.286]             sys.calls <- base::sys.calls
[13:20:50.286]             `[[` <- base::`[[`
[13:20:50.286]             `+` <- base::`+`
[13:20:50.286]             `<<-` <- base::`<<-`
[13:20:50.286]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.286]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.286]                   3L)]
[13:20:50.286]             }
[13:20:50.286]             function(cond) {
[13:20:50.286]                 is_error <- inherits(cond, "error")
[13:20:50.286]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.286]                   NULL)
[13:20:50.286]                 if (is_error) {
[13:20:50.286]                   sessionInformation <- function() {
[13:20:50.286]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.286]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.286]                       search = base::search(), system = base::Sys.info())
[13:20:50.286]                   }
[13:20:50.286]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.286]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.286]                     cond$call), session = sessionInformation(), 
[13:20:50.286]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.286]                   signalCondition(cond)
[13:20:50.286]                 }
[13:20:50.286]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.286]                 "immediateCondition"))) {
[13:20:50.286]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.286]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.286]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.286]                   if (TRUE && !signal) {
[13:20:50.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.286]                     {
[13:20:50.286]                       inherits <- base::inherits
[13:20:50.286]                       invokeRestart <- base::invokeRestart
[13:20:50.286]                       is.null <- base::is.null
[13:20:50.286]                       muffled <- FALSE
[13:20:50.286]                       if (inherits(cond, "message")) {
[13:20:50.286]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.286]                         if (muffled) 
[13:20:50.286]                           invokeRestart("muffleMessage")
[13:20:50.286]                       }
[13:20:50.286]                       else if (inherits(cond, "warning")) {
[13:20:50.286]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.286]                         if (muffled) 
[13:20:50.286]                           invokeRestart("muffleWarning")
[13:20:50.286]                       }
[13:20:50.286]                       else if (inherits(cond, "condition")) {
[13:20:50.286]                         if (!is.null(pattern)) {
[13:20:50.286]                           computeRestarts <- base::computeRestarts
[13:20:50.286]                           grepl <- base::grepl
[13:20:50.286]                           restarts <- computeRestarts(cond)
[13:20:50.286]                           for (restart in restarts) {
[13:20:50.286]                             name <- restart$name
[13:20:50.286]                             if (is.null(name)) 
[13:20:50.286]                               next
[13:20:50.286]                             if (!grepl(pattern, name)) 
[13:20:50.286]                               next
[13:20:50.286]                             invokeRestart(restart)
[13:20:50.286]                             muffled <- TRUE
[13:20:50.286]                             break
[13:20:50.286]                           }
[13:20:50.286]                         }
[13:20:50.286]                       }
[13:20:50.286]                       invisible(muffled)
[13:20:50.286]                     }
[13:20:50.286]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.286]                   }
[13:20:50.286]                 }
[13:20:50.286]                 else {
[13:20:50.286]                   if (TRUE) {
[13:20:50.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.286]                     {
[13:20:50.286]                       inherits <- base::inherits
[13:20:50.286]                       invokeRestart <- base::invokeRestart
[13:20:50.286]                       is.null <- base::is.null
[13:20:50.286]                       muffled <- FALSE
[13:20:50.286]                       if (inherits(cond, "message")) {
[13:20:50.286]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.286]                         if (muffled) 
[13:20:50.286]                           invokeRestart("muffleMessage")
[13:20:50.286]                       }
[13:20:50.286]                       else if (inherits(cond, "warning")) {
[13:20:50.286]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.286]                         if (muffled) 
[13:20:50.286]                           invokeRestart("muffleWarning")
[13:20:50.286]                       }
[13:20:50.286]                       else if (inherits(cond, "condition")) {
[13:20:50.286]                         if (!is.null(pattern)) {
[13:20:50.286]                           computeRestarts <- base::computeRestarts
[13:20:50.286]                           grepl <- base::grepl
[13:20:50.286]                           restarts <- computeRestarts(cond)
[13:20:50.286]                           for (restart in restarts) {
[13:20:50.286]                             name <- restart$name
[13:20:50.286]                             if (is.null(name)) 
[13:20:50.286]                               next
[13:20:50.286]                             if (!grepl(pattern, name)) 
[13:20:50.286]                               next
[13:20:50.286]                             invokeRestart(restart)
[13:20:50.286]                             muffled <- TRUE
[13:20:50.286]                             break
[13:20:50.286]                           }
[13:20:50.286]                         }
[13:20:50.286]                       }
[13:20:50.286]                       invisible(muffled)
[13:20:50.286]                     }
[13:20:50.286]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.286]                   }
[13:20:50.286]                 }
[13:20:50.286]             }
[13:20:50.286]         }))
[13:20:50.286]     }, error = function(ex) {
[13:20:50.286]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.286]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.286]                 ...future.rng), started = ...future.startTime, 
[13:20:50.286]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.286]             version = "1.8"), class = "FutureResult")
[13:20:50.286]     }, finally = {
[13:20:50.286]         if (!identical(...future.workdir, getwd())) 
[13:20:50.286]             setwd(...future.workdir)
[13:20:50.286]         {
[13:20:50.286]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.286]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.286]             }
[13:20:50.286]             base::options(...future.oldOptions)
[13:20:50.286]             if (.Platform$OS.type == "windows") {
[13:20:50.286]                 old_names <- names(...future.oldEnvVars)
[13:20:50.286]                 envs <- base::Sys.getenv()
[13:20:50.286]                 names <- names(envs)
[13:20:50.286]                 common <- intersect(names, old_names)
[13:20:50.286]                 added <- setdiff(names, old_names)
[13:20:50.286]                 removed <- setdiff(old_names, names)
[13:20:50.286]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.286]                   envs[common]]
[13:20:50.286]                 NAMES <- toupper(changed)
[13:20:50.286]                 args <- list()
[13:20:50.286]                 for (kk in seq_along(NAMES)) {
[13:20:50.286]                   name <- changed[[kk]]
[13:20:50.286]                   NAME <- NAMES[[kk]]
[13:20:50.286]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.286]                     next
[13:20:50.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.286]                 }
[13:20:50.286]                 NAMES <- toupper(added)
[13:20:50.286]                 for (kk in seq_along(NAMES)) {
[13:20:50.286]                   name <- added[[kk]]
[13:20:50.286]                   NAME <- NAMES[[kk]]
[13:20:50.286]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.286]                     next
[13:20:50.286]                   args[[name]] <- ""
[13:20:50.286]                 }
[13:20:50.286]                 NAMES <- toupper(removed)
[13:20:50.286]                 for (kk in seq_along(NAMES)) {
[13:20:50.286]                   name <- removed[[kk]]
[13:20:50.286]                   NAME <- NAMES[[kk]]
[13:20:50.286]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.286]                     next
[13:20:50.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.286]                 }
[13:20:50.286]                 if (length(args) > 0) 
[13:20:50.286]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.286]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.286]             }
[13:20:50.286]             else {
[13:20:50.286]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.286]             }
[13:20:50.286]             {
[13:20:50.286]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.286]                   0L) {
[13:20:50.286]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.286]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.286]                   base::options(opts)
[13:20:50.286]                 }
[13:20:50.286]                 {
[13:20:50.286]                   {
[13:20:50.286]                     NULL
[13:20:50.286]                     RNGkind("Mersenne-Twister")
[13:20:50.286]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.286]                       inherits = FALSE)
[13:20:50.286]                   }
[13:20:50.286]                   options(future.plan = NULL)
[13:20:50.286]                   if (is.na(NA_character_)) 
[13:20:50.286]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.286]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.286]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.286]                   {
[13:20:50.286]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.286]                     if (!future$lazy) 
[13:20:50.286]                       future <- run(future)
[13:20:50.286]                     invisible(future)
[13:20:50.286]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.286]                 }
[13:20:50.286]             }
[13:20:50.286]         }
[13:20:50.286]     })
[13:20:50.286]     if (TRUE) {
[13:20:50.286]         base::sink(type = "output", split = FALSE)
[13:20:50.286]         if (TRUE) {
[13:20:50.286]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.286]         }
[13:20:50.286]         else {
[13:20:50.286]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.286]         }
[13:20:50.286]         base::close(...future.stdout)
[13:20:50.286]         ...future.stdout <- NULL
[13:20:50.286]     }
[13:20:50.286]     ...future.result$conditions <- ...future.conditions
[13:20:50.286]     ...future.result$finished <- base::Sys.time()
[13:20:50.286]     ...future.result
[13:20:50.286] }
[13:20:50.287] assign_globals() ...
[13:20:50.287] List of 1
[13:20:50.287]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x558ddfd0ecb8> 
[13:20:50.287]  - attr(*, "where")=List of 1
[13:20:50.287]   ..$ a:<environment: R_EmptyEnv> 
[13:20:50.287]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.287]  - attr(*, "resolved")= logi TRUE
[13:20:50.287]  - attr(*, "total_size")= num 10424
[13:20:50.287]  - attr(*, "already-done")= logi TRUE
[13:20:50.290] - copied ‘a’ to environment
[13:20:50.290] assign_globals() ... done
[13:20:50.290] plan(): Setting new future strategy stack:
[13:20:50.290] List of future strategies:
[13:20:50.290] 1. sequential:
[13:20:50.290]    - args: function (..., envir = parent.frame())
[13:20:50.290]    - tweaked: FALSE
[13:20:50.290]    - call: NULL
[13:20:50.291] plan(): nbrOfWorkers() = 1
[13:20:50.291] plan(): Setting new future strategy stack:
[13:20:50.291] List of future strategies:
[13:20:50.291] 1. sequential:
[13:20:50.291]    - args: function (..., envir = parent.frame())
[13:20:50.291]    - tweaked: FALSE
[13:20:50.291]    - call: plan(strategy)
[13:20:50.292] plan(): nbrOfWorkers() = 1
[13:20:50.292] SequentialFuture started (and completed)
[13:20:50.292] - Launch lazy future ... done
[13:20:50.292] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.293] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.293] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.293] 
[13:20:50.293] Searching for globals ... DONE
[13:20:50.294] - globals: [0] <none>
[13:20:50.294] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.294] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.294] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.295] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:50.295] Searching for globals ... DONE
[13:20:50.295] Resolving globals: TRUE
[13:20:50.295] Resolving any globals that are futures ...
[13:20:50.295] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:50.295] Resolving any globals that are futures ... DONE
[13:20:50.296] Resolving futures part of globals (recursively) ...
[13:20:50.296] resolve() on list ...
[13:20:50.296]  recursive: 99
[13:20:50.296]  length: 1
[13:20:50.296]  elements: ‘a’
[13:20:50.296] run() for ‘Future’ ...
[13:20:50.296] - state: ‘created’
[13:20:50.297] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.297] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.297] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.297]   - Field: ‘label’
[13:20:50.297]   - Field: ‘local’
[13:20:50.297]   - Field: ‘owner’
[13:20:50.297]   - Field: ‘envir’
[13:20:50.297]   - Field: ‘packages’
[13:20:50.298]   - Field: ‘gc’
[13:20:50.298]   - Field: ‘conditions’
[13:20:50.298]   - Field: ‘expr’
[13:20:50.298]   - Field: ‘uuid’
[13:20:50.298]   - Field: ‘seed’
[13:20:50.298]   - Field: ‘version’
[13:20:50.298]   - Field: ‘result’
[13:20:50.298]   - Field: ‘asynchronous’
[13:20:50.298]   - Field: ‘calls’
[13:20:50.298]   - Field: ‘globals’
[13:20:50.298]   - Field: ‘stdout’
[13:20:50.299]   - Field: ‘earlySignal’
[13:20:50.299]   - Field: ‘lazy’
[13:20:50.299]   - Field: ‘state’
[13:20:50.299] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.299] - Launch lazy future ...
[13:20:50.299] Packages needed by the future expression (n = 0): <none>
[13:20:50.299] Packages needed by future strategies (n = 0): <none>
[13:20:50.300] {
[13:20:50.300]     {
[13:20:50.300]         {
[13:20:50.300]             ...future.startTime <- base::Sys.time()
[13:20:50.300]             {
[13:20:50.300]                 {
[13:20:50.300]                   {
[13:20:50.300]                     base::local({
[13:20:50.300]                       has_future <- base::requireNamespace("future", 
[13:20:50.300]                         quietly = TRUE)
[13:20:50.300]                       if (has_future) {
[13:20:50.300]                         ns <- base::getNamespace("future")
[13:20:50.300]                         version <- ns[[".package"]][["version"]]
[13:20:50.300]                         if (is.null(version)) 
[13:20:50.300]                           version <- utils::packageVersion("future")
[13:20:50.300]                       }
[13:20:50.300]                       else {
[13:20:50.300]                         version <- NULL
[13:20:50.300]                       }
[13:20:50.300]                       if (!has_future || version < "1.8.0") {
[13:20:50.300]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.300]                           "", base::R.version$version.string), 
[13:20:50.300]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.300]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.300]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.300]                             "release", "version")], collapse = " "), 
[13:20:50.300]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.300]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.300]                           info)
[13:20:50.300]                         info <- base::paste(info, collapse = "; ")
[13:20:50.300]                         if (!has_future) {
[13:20:50.300]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.300]                             info)
[13:20:50.300]                         }
[13:20:50.300]                         else {
[13:20:50.300]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.300]                             info, version)
[13:20:50.300]                         }
[13:20:50.300]                         base::stop(msg)
[13:20:50.300]                       }
[13:20:50.300]                     })
[13:20:50.300]                   }
[13:20:50.300]                   options(future.plan = NULL)
[13:20:50.300]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.300]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.300]                 }
[13:20:50.300]                 ...future.workdir <- getwd()
[13:20:50.300]             }
[13:20:50.300]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.300]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.300]         }
[13:20:50.300]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.300]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:50.300]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.300]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.300]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.300]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.300]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.300]             base::names(...future.oldOptions))
[13:20:50.300]     }
[13:20:50.300]     if (FALSE) {
[13:20:50.300]     }
[13:20:50.300]     else {
[13:20:50.300]         if (TRUE) {
[13:20:50.300]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.300]                 open = "w")
[13:20:50.300]         }
[13:20:50.300]         else {
[13:20:50.300]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.300]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.300]         }
[13:20:50.300]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.300]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.300]             base::sink(type = "output", split = FALSE)
[13:20:50.300]             base::close(...future.stdout)
[13:20:50.300]         }, add = TRUE)
[13:20:50.300]     }
[13:20:50.300]     ...future.frame <- base::sys.nframe()
[13:20:50.300]     ...future.conditions <- base::list()
[13:20:50.300]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.300]     if (FALSE) {
[13:20:50.300]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.300]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.300]     }
[13:20:50.300]     ...future.result <- base::tryCatch({
[13:20:50.300]         base::withCallingHandlers({
[13:20:50.300]             ...future.value <- base::withVisible(base::local(1))
[13:20:50.300]             future::FutureResult(value = ...future.value$value, 
[13:20:50.300]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.300]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.300]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.300]                     ...future.globalenv.names))
[13:20:50.300]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.300]         }, condition = base::local({
[13:20:50.300]             c <- base::c
[13:20:50.300]             inherits <- base::inherits
[13:20:50.300]             invokeRestart <- base::invokeRestart
[13:20:50.300]             length <- base::length
[13:20:50.300]             list <- base::list
[13:20:50.300]             seq.int <- base::seq.int
[13:20:50.300]             signalCondition <- base::signalCondition
[13:20:50.300]             sys.calls <- base::sys.calls
[13:20:50.300]             `[[` <- base::`[[`
[13:20:50.300]             `+` <- base::`+`
[13:20:50.300]             `<<-` <- base::`<<-`
[13:20:50.300]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.300]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.300]                   3L)]
[13:20:50.300]             }
[13:20:50.300]             function(cond) {
[13:20:50.300]                 is_error <- inherits(cond, "error")
[13:20:50.300]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.300]                   NULL)
[13:20:50.300]                 if (is_error) {
[13:20:50.300]                   sessionInformation <- function() {
[13:20:50.300]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.300]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.300]                       search = base::search(), system = base::Sys.info())
[13:20:50.300]                   }
[13:20:50.300]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.300]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.300]                     cond$call), session = sessionInformation(), 
[13:20:50.300]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.300]                   signalCondition(cond)
[13:20:50.300]                 }
[13:20:50.300]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.300]                 "immediateCondition"))) {
[13:20:50.300]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.300]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.300]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.300]                   if (TRUE && !signal) {
[13:20:50.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.300]                     {
[13:20:50.300]                       inherits <- base::inherits
[13:20:50.300]                       invokeRestart <- base::invokeRestart
[13:20:50.300]                       is.null <- base::is.null
[13:20:50.300]                       muffled <- FALSE
[13:20:50.300]                       if (inherits(cond, "message")) {
[13:20:50.300]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.300]                         if (muffled) 
[13:20:50.300]                           invokeRestart("muffleMessage")
[13:20:50.300]                       }
[13:20:50.300]                       else if (inherits(cond, "warning")) {
[13:20:50.300]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.300]                         if (muffled) 
[13:20:50.300]                           invokeRestart("muffleWarning")
[13:20:50.300]                       }
[13:20:50.300]                       else if (inherits(cond, "condition")) {
[13:20:50.300]                         if (!is.null(pattern)) {
[13:20:50.300]                           computeRestarts <- base::computeRestarts
[13:20:50.300]                           grepl <- base::grepl
[13:20:50.300]                           restarts <- computeRestarts(cond)
[13:20:50.300]                           for (restart in restarts) {
[13:20:50.300]                             name <- restart$name
[13:20:50.300]                             if (is.null(name)) 
[13:20:50.300]                               next
[13:20:50.300]                             if (!grepl(pattern, name)) 
[13:20:50.300]                               next
[13:20:50.300]                             invokeRestart(restart)
[13:20:50.300]                             muffled <- TRUE
[13:20:50.300]                             break
[13:20:50.300]                           }
[13:20:50.300]                         }
[13:20:50.300]                       }
[13:20:50.300]                       invisible(muffled)
[13:20:50.300]                     }
[13:20:50.300]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.300]                   }
[13:20:50.300]                 }
[13:20:50.300]                 else {
[13:20:50.300]                   if (TRUE) {
[13:20:50.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.300]                     {
[13:20:50.300]                       inherits <- base::inherits
[13:20:50.300]                       invokeRestart <- base::invokeRestart
[13:20:50.300]                       is.null <- base::is.null
[13:20:50.300]                       muffled <- FALSE
[13:20:50.300]                       if (inherits(cond, "message")) {
[13:20:50.300]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.300]                         if (muffled) 
[13:20:50.300]                           invokeRestart("muffleMessage")
[13:20:50.300]                       }
[13:20:50.300]                       else if (inherits(cond, "warning")) {
[13:20:50.300]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.300]                         if (muffled) 
[13:20:50.300]                           invokeRestart("muffleWarning")
[13:20:50.300]                       }
[13:20:50.300]                       else if (inherits(cond, "condition")) {
[13:20:50.300]                         if (!is.null(pattern)) {
[13:20:50.300]                           computeRestarts <- base::computeRestarts
[13:20:50.300]                           grepl <- base::grepl
[13:20:50.300]                           restarts <- computeRestarts(cond)
[13:20:50.300]                           for (restart in restarts) {
[13:20:50.300]                             name <- restart$name
[13:20:50.300]                             if (is.null(name)) 
[13:20:50.300]                               next
[13:20:50.300]                             if (!grepl(pattern, name)) 
[13:20:50.300]                               next
[13:20:50.300]                             invokeRestart(restart)
[13:20:50.300]                             muffled <- TRUE
[13:20:50.300]                             break
[13:20:50.300]                           }
[13:20:50.300]                         }
[13:20:50.300]                       }
[13:20:50.300]                       invisible(muffled)
[13:20:50.300]                     }
[13:20:50.300]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.300]                   }
[13:20:50.300]                 }
[13:20:50.300]             }
[13:20:50.300]         }))
[13:20:50.300]     }, error = function(ex) {
[13:20:50.300]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.300]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.300]                 ...future.rng), started = ...future.startTime, 
[13:20:50.300]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.300]             version = "1.8"), class = "FutureResult")
[13:20:50.300]     }, finally = {
[13:20:50.300]         if (!identical(...future.workdir, getwd())) 
[13:20:50.300]             setwd(...future.workdir)
[13:20:50.300]         {
[13:20:50.300]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.300]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.300]             }
[13:20:50.300]             base::options(...future.oldOptions)
[13:20:50.300]             if (.Platform$OS.type == "windows") {
[13:20:50.300]                 old_names <- names(...future.oldEnvVars)
[13:20:50.300]                 envs <- base::Sys.getenv()
[13:20:50.300]                 names <- names(envs)
[13:20:50.300]                 common <- intersect(names, old_names)
[13:20:50.300]                 added <- setdiff(names, old_names)
[13:20:50.300]                 removed <- setdiff(old_names, names)
[13:20:50.300]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.300]                   envs[common]]
[13:20:50.300]                 NAMES <- toupper(changed)
[13:20:50.300]                 args <- list()
[13:20:50.300]                 for (kk in seq_along(NAMES)) {
[13:20:50.300]                   name <- changed[[kk]]
[13:20:50.300]                   NAME <- NAMES[[kk]]
[13:20:50.300]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.300]                     next
[13:20:50.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.300]                 }
[13:20:50.300]                 NAMES <- toupper(added)
[13:20:50.300]                 for (kk in seq_along(NAMES)) {
[13:20:50.300]                   name <- added[[kk]]
[13:20:50.300]                   NAME <- NAMES[[kk]]
[13:20:50.300]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.300]                     next
[13:20:50.300]                   args[[name]] <- ""
[13:20:50.300]                 }
[13:20:50.300]                 NAMES <- toupper(removed)
[13:20:50.300]                 for (kk in seq_along(NAMES)) {
[13:20:50.300]                   name <- removed[[kk]]
[13:20:50.300]                   NAME <- NAMES[[kk]]
[13:20:50.300]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.300]                     next
[13:20:50.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.300]                 }
[13:20:50.300]                 if (length(args) > 0) 
[13:20:50.300]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.300]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.300]             }
[13:20:50.300]             else {
[13:20:50.300]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.300]             }
[13:20:50.300]             {
[13:20:50.300]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.300]                   0L) {
[13:20:50.300]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.300]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.300]                   base::options(opts)
[13:20:50.300]                 }
[13:20:50.300]                 {
[13:20:50.300]                   {
[13:20:50.300]                     NULL
[13:20:50.300]                     RNGkind("Mersenne-Twister")
[13:20:50.300]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.300]                       inherits = FALSE)
[13:20:50.300]                   }
[13:20:50.300]                   options(future.plan = NULL)
[13:20:50.300]                   if (is.na(NA_character_)) 
[13:20:50.300]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.300]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.300]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.300]                   {
[13:20:50.300]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.300]                     if (!future$lazy) 
[13:20:50.300]                       future <- run(future)
[13:20:50.300]                     invisible(future)
[13:20:50.300]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.300]                 }
[13:20:50.300]             }
[13:20:50.300]         }
[13:20:50.300]     })
[13:20:50.300]     if (TRUE) {
[13:20:50.300]         base::sink(type = "output", split = FALSE)
[13:20:50.300]         if (TRUE) {
[13:20:50.300]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.300]         }
[13:20:50.300]         else {
[13:20:50.300]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.300]         }
[13:20:50.300]         base::close(...future.stdout)
[13:20:50.300]         ...future.stdout <- NULL
[13:20:50.300]     }
[13:20:50.300]     ...future.result$conditions <- ...future.conditions
[13:20:50.300]     ...future.result$finished <- base::Sys.time()
[13:20:50.300]     ...future.result
[13:20:50.300] }
[13:20:50.301] plan(): Setting new future strategy stack:
[13:20:50.301] List of future strategies:
[13:20:50.301] 1. sequential:
[13:20:50.301]    - args: function (..., envir = parent.frame())
[13:20:50.301]    - tweaked: FALSE
[13:20:50.301]    - call: NULL
[13:20:50.302] plan(): nbrOfWorkers() = 1
[13:20:50.302] plan(): Setting new future strategy stack:
[13:20:50.303] List of future strategies:
[13:20:50.303] 1. sequential:
[13:20:50.303]    - args: function (..., envir = parent.frame())
[13:20:50.303]    - tweaked: FALSE
[13:20:50.303]    - call: plan(strategy)
[13:20:50.303] plan(): nbrOfWorkers() = 1
[13:20:50.303] SequentialFuture started (and completed)
[13:20:50.303] - Launch lazy future ... done
[13:20:50.303] run() for ‘SequentialFuture’ ... done
[13:20:50.303] resolved() for ‘SequentialFuture’ ...
[13:20:50.303] - state: ‘finished’
[13:20:50.304] - run: TRUE
[13:20:50.304] - result: ‘FutureResult’
[13:20:50.304] resolved() for ‘SequentialFuture’ ... done
[13:20:50.304] Future #1
[13:20:50.304] resolved() for ‘SequentialFuture’ ...
[13:20:50.304] - state: ‘finished’
[13:20:50.304] - run: TRUE
[13:20:50.304] - result: ‘FutureResult’
[13:20:50.304] resolved() for ‘SequentialFuture’ ... done
[13:20:50.304] A SequentialFuture was resolved
[13:20:50.305]  length: 0 (resolved future 1)
[13:20:50.305] resolve() on list ... DONE
[13:20:50.305] - globals: [1] ‘a’
[13:20:50.305] Resolving futures part of globals (recursively) ... DONE
[13:20:50.306] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[13:20:50.306] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[13:20:50.306] - globals: [1] ‘a’
[13:20:50.306] - packages: [1] ‘future’
[13:20:50.306] getGlobalsAndPackages() ... DONE
[13:20:50.307] run() for ‘Future’ ...
[13:20:50.307] - state: ‘created’
[13:20:50.307] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.307] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.307] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.307]   - Field: ‘label’
[13:20:50.307]   - Field: ‘local’
[13:20:50.307]   - Field: ‘owner’
[13:20:50.308]   - Field: ‘envir’
[13:20:50.308]   - Field: ‘packages’
[13:20:50.308]   - Field: ‘gc’
[13:20:50.308]   - Field: ‘conditions’
[13:20:50.308]   - Field: ‘expr’
[13:20:50.308]   - Field: ‘uuid’
[13:20:50.308]   - Field: ‘seed’
[13:20:50.308]   - Field: ‘version’
[13:20:50.308]   - Field: ‘result’
[13:20:50.308]   - Field: ‘asynchronous’
[13:20:50.308]   - Field: ‘calls’
[13:20:50.309]   - Field: ‘globals’
[13:20:50.309]   - Field: ‘stdout’
[13:20:50.310]   - Field: ‘earlySignal’
[13:20:50.310]   - Field: ‘lazy’
[13:20:50.311]   - Field: ‘state’
[13:20:50.311] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.311] - Launch lazy future ...
[13:20:50.311] Packages needed by the future expression (n = 1): ‘future’
[13:20:50.311] Packages needed by future strategies (n = 0): <none>
[13:20:50.312] {
[13:20:50.312]     {
[13:20:50.312]         {
[13:20:50.312]             ...future.startTime <- base::Sys.time()
[13:20:50.312]             {
[13:20:50.312]                 {
[13:20:50.312]                   {
[13:20:50.312]                     {
[13:20:50.312]                       base::local({
[13:20:50.312]                         has_future <- base::requireNamespace("future", 
[13:20:50.312]                           quietly = TRUE)
[13:20:50.312]                         if (has_future) {
[13:20:50.312]                           ns <- base::getNamespace("future")
[13:20:50.312]                           version <- ns[[".package"]][["version"]]
[13:20:50.312]                           if (is.null(version)) 
[13:20:50.312]                             version <- utils::packageVersion("future")
[13:20:50.312]                         }
[13:20:50.312]                         else {
[13:20:50.312]                           version <- NULL
[13:20:50.312]                         }
[13:20:50.312]                         if (!has_future || version < "1.8.0") {
[13:20:50.312]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.312]                             "", base::R.version$version.string), 
[13:20:50.312]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:50.312]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.312]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.312]                               "release", "version")], collapse = " "), 
[13:20:50.312]                             hostname = base::Sys.info()[["nodename"]])
[13:20:50.312]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.312]                             info)
[13:20:50.312]                           info <- base::paste(info, collapse = "; ")
[13:20:50.312]                           if (!has_future) {
[13:20:50.312]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.312]                               info)
[13:20:50.312]                           }
[13:20:50.312]                           else {
[13:20:50.312]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.312]                               info, version)
[13:20:50.312]                           }
[13:20:50.312]                           base::stop(msg)
[13:20:50.312]                         }
[13:20:50.312]                       })
[13:20:50.312]                     }
[13:20:50.312]                     base::local({
[13:20:50.312]                       for (pkg in "future") {
[13:20:50.312]                         base::loadNamespace(pkg)
[13:20:50.312]                         base::library(pkg, character.only = TRUE)
[13:20:50.312]                       }
[13:20:50.312]                     })
[13:20:50.312]                   }
[13:20:50.312]                   options(future.plan = NULL)
[13:20:50.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.312]                 }
[13:20:50.312]                 ...future.workdir <- getwd()
[13:20:50.312]             }
[13:20:50.312]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.312]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.312]         }
[13:20:50.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.312]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:50.312]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.312]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.312]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.312]             base::names(...future.oldOptions))
[13:20:50.312]     }
[13:20:50.312]     if (FALSE) {
[13:20:50.312]     }
[13:20:50.312]     else {
[13:20:50.312]         if (TRUE) {
[13:20:50.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.312]                 open = "w")
[13:20:50.312]         }
[13:20:50.312]         else {
[13:20:50.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.312]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.312]         }
[13:20:50.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.312]             base::sink(type = "output", split = FALSE)
[13:20:50.312]             base::close(...future.stdout)
[13:20:50.312]         }, add = TRUE)
[13:20:50.312]     }
[13:20:50.312]     ...future.frame <- base::sys.nframe()
[13:20:50.312]     ...future.conditions <- base::list()
[13:20:50.312]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.312]     if (FALSE) {
[13:20:50.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.312]     }
[13:20:50.312]     ...future.result <- base::tryCatch({
[13:20:50.312]         base::withCallingHandlers({
[13:20:50.312]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:20:50.312]                 1))
[13:20:50.312]             future::FutureResult(value = ...future.value$value, 
[13:20:50.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.312]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.312]                     ...future.globalenv.names))
[13:20:50.312]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.312]         }, condition = base::local({
[13:20:50.312]             c <- base::c
[13:20:50.312]             inherits <- base::inherits
[13:20:50.312]             invokeRestart <- base::invokeRestart
[13:20:50.312]             length <- base::length
[13:20:50.312]             list <- base::list
[13:20:50.312]             seq.int <- base::seq.int
[13:20:50.312]             signalCondition <- base::signalCondition
[13:20:50.312]             sys.calls <- base::sys.calls
[13:20:50.312]             `[[` <- base::`[[`
[13:20:50.312]             `+` <- base::`+`
[13:20:50.312]             `<<-` <- base::`<<-`
[13:20:50.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.312]                   3L)]
[13:20:50.312]             }
[13:20:50.312]             function(cond) {
[13:20:50.312]                 is_error <- inherits(cond, "error")
[13:20:50.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.312]                   NULL)
[13:20:50.312]                 if (is_error) {
[13:20:50.312]                   sessionInformation <- function() {
[13:20:50.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.312]                       search = base::search(), system = base::Sys.info())
[13:20:50.312]                   }
[13:20:50.312]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.312]                     cond$call), session = sessionInformation(), 
[13:20:50.312]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.312]                   signalCondition(cond)
[13:20:50.312]                 }
[13:20:50.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.312]                 "immediateCondition"))) {
[13:20:50.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.312]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.312]                   if (TRUE && !signal) {
[13:20:50.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.312]                     {
[13:20:50.312]                       inherits <- base::inherits
[13:20:50.312]                       invokeRestart <- base::invokeRestart
[13:20:50.312]                       is.null <- base::is.null
[13:20:50.312]                       muffled <- FALSE
[13:20:50.312]                       if (inherits(cond, "message")) {
[13:20:50.312]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.312]                         if (muffled) 
[13:20:50.312]                           invokeRestart("muffleMessage")
[13:20:50.312]                       }
[13:20:50.312]                       else if (inherits(cond, "warning")) {
[13:20:50.312]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.312]                         if (muffled) 
[13:20:50.312]                           invokeRestart("muffleWarning")
[13:20:50.312]                       }
[13:20:50.312]                       else if (inherits(cond, "condition")) {
[13:20:50.312]                         if (!is.null(pattern)) {
[13:20:50.312]                           computeRestarts <- base::computeRestarts
[13:20:50.312]                           grepl <- base::grepl
[13:20:50.312]                           restarts <- computeRestarts(cond)
[13:20:50.312]                           for (restart in restarts) {
[13:20:50.312]                             name <- restart$name
[13:20:50.312]                             if (is.null(name)) 
[13:20:50.312]                               next
[13:20:50.312]                             if (!grepl(pattern, name)) 
[13:20:50.312]                               next
[13:20:50.312]                             invokeRestart(restart)
[13:20:50.312]                             muffled <- TRUE
[13:20:50.312]                             break
[13:20:50.312]                           }
[13:20:50.312]                         }
[13:20:50.312]                       }
[13:20:50.312]                       invisible(muffled)
[13:20:50.312]                     }
[13:20:50.312]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.312]                   }
[13:20:50.312]                 }
[13:20:50.312]                 else {
[13:20:50.312]                   if (TRUE) {
[13:20:50.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.312]                     {
[13:20:50.312]                       inherits <- base::inherits
[13:20:50.312]                       invokeRestart <- base::invokeRestart
[13:20:50.312]                       is.null <- base::is.null
[13:20:50.312]                       muffled <- FALSE
[13:20:50.312]                       if (inherits(cond, "message")) {
[13:20:50.312]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.312]                         if (muffled) 
[13:20:50.312]                           invokeRestart("muffleMessage")
[13:20:50.312]                       }
[13:20:50.312]                       else if (inherits(cond, "warning")) {
[13:20:50.312]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.312]                         if (muffled) 
[13:20:50.312]                           invokeRestart("muffleWarning")
[13:20:50.312]                       }
[13:20:50.312]                       else if (inherits(cond, "condition")) {
[13:20:50.312]                         if (!is.null(pattern)) {
[13:20:50.312]                           computeRestarts <- base::computeRestarts
[13:20:50.312]                           grepl <- base::grepl
[13:20:50.312]                           restarts <- computeRestarts(cond)
[13:20:50.312]                           for (restart in restarts) {
[13:20:50.312]                             name <- restart$name
[13:20:50.312]                             if (is.null(name)) 
[13:20:50.312]                               next
[13:20:50.312]                             if (!grepl(pattern, name)) 
[13:20:50.312]                               next
[13:20:50.312]                             invokeRestart(restart)
[13:20:50.312]                             muffled <- TRUE
[13:20:50.312]                             break
[13:20:50.312]                           }
[13:20:50.312]                         }
[13:20:50.312]                       }
[13:20:50.312]                       invisible(muffled)
[13:20:50.312]                     }
[13:20:50.312]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.312]                   }
[13:20:50.312]                 }
[13:20:50.312]             }
[13:20:50.312]         }))
[13:20:50.312]     }, error = function(ex) {
[13:20:50.312]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.312]                 ...future.rng), started = ...future.startTime, 
[13:20:50.312]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.312]             version = "1.8"), class = "FutureResult")
[13:20:50.312]     }, finally = {
[13:20:50.312]         if (!identical(...future.workdir, getwd())) 
[13:20:50.312]             setwd(...future.workdir)
[13:20:50.312]         {
[13:20:50.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.312]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.312]             }
[13:20:50.312]             base::options(...future.oldOptions)
[13:20:50.312]             if (.Platform$OS.type == "windows") {
[13:20:50.312]                 old_names <- names(...future.oldEnvVars)
[13:20:50.312]                 envs <- base::Sys.getenv()
[13:20:50.312]                 names <- names(envs)
[13:20:50.312]                 common <- intersect(names, old_names)
[13:20:50.312]                 added <- setdiff(names, old_names)
[13:20:50.312]                 removed <- setdiff(old_names, names)
[13:20:50.312]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.312]                   envs[common]]
[13:20:50.312]                 NAMES <- toupper(changed)
[13:20:50.312]                 args <- list()
[13:20:50.312]                 for (kk in seq_along(NAMES)) {
[13:20:50.312]                   name <- changed[[kk]]
[13:20:50.312]                   NAME <- NAMES[[kk]]
[13:20:50.312]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.312]                     next
[13:20:50.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.312]                 }
[13:20:50.312]                 NAMES <- toupper(added)
[13:20:50.312]                 for (kk in seq_along(NAMES)) {
[13:20:50.312]                   name <- added[[kk]]
[13:20:50.312]                   NAME <- NAMES[[kk]]
[13:20:50.312]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.312]                     next
[13:20:50.312]                   args[[name]] <- ""
[13:20:50.312]                 }
[13:20:50.312]                 NAMES <- toupper(removed)
[13:20:50.312]                 for (kk in seq_along(NAMES)) {
[13:20:50.312]                   name <- removed[[kk]]
[13:20:50.312]                   NAME <- NAMES[[kk]]
[13:20:50.312]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.312]                     next
[13:20:50.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.312]                 }
[13:20:50.312]                 if (length(args) > 0) 
[13:20:50.312]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.312]             }
[13:20:50.312]             else {
[13:20:50.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.312]             }
[13:20:50.312]             {
[13:20:50.312]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.312]                   0L) {
[13:20:50.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.312]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.312]                   base::options(opts)
[13:20:50.312]                 }
[13:20:50.312]                 {
[13:20:50.312]                   {
[13:20:50.312]                     NULL
[13:20:50.312]                     RNGkind("Mersenne-Twister")
[13:20:50.312]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.312]                       inherits = FALSE)
[13:20:50.312]                   }
[13:20:50.312]                   options(future.plan = NULL)
[13:20:50.312]                   if (is.na(NA_character_)) 
[13:20:50.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.312]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.312]                   {
[13:20:50.312]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.312]                     if (!future$lazy) 
[13:20:50.312]                       future <- run(future)
[13:20:50.312]                     invisible(future)
[13:20:50.312]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.312]                 }
[13:20:50.312]             }
[13:20:50.312]         }
[13:20:50.312]     })
[13:20:50.312]     if (TRUE) {
[13:20:50.312]         base::sink(type = "output", split = FALSE)
[13:20:50.312]         if (TRUE) {
[13:20:50.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.312]         }
[13:20:50.312]         else {
[13:20:50.312]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.312]         }
[13:20:50.312]         base::close(...future.stdout)
[13:20:50.312]         ...future.stdout <- NULL
[13:20:50.312]     }
[13:20:50.312]     ...future.result$conditions <- ...future.conditions
[13:20:50.312]     ...future.result$finished <- base::Sys.time()
[13:20:50.312]     ...future.result
[13:20:50.312] }
[13:20:50.313] assign_globals() ...
[13:20:50.313] List of 1
[13:20:50.313]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x558ddfbfd228> 
[13:20:50.313]  - attr(*, "where")=List of 1
[13:20:50.313]   ..$ a:<environment: R_EmptyEnv> 
[13:20:50.313]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.313]  - attr(*, "resolved")= logi TRUE
[13:20:50.313]  - attr(*, "total_size")= num 10592
[13:20:50.313]  - attr(*, "already-done")= logi TRUE
[13:20:50.316] - copied ‘a’ to environment
[13:20:50.316] assign_globals() ... done
[13:20:50.316] plan(): Setting new future strategy stack:
[13:20:50.316] List of future strategies:
[13:20:50.316] 1. sequential:
[13:20:50.316]    - args: function (..., envir = parent.frame())
[13:20:50.316]    - tweaked: FALSE
[13:20:50.316]    - call: NULL
[13:20:50.317] plan(): nbrOfWorkers() = 1
[13:20:50.317] plan(): Setting new future strategy stack:
[13:20:50.318] List of future strategies:
[13:20:50.318] 1. sequential:
[13:20:50.318]    - args: function (..., envir = parent.frame())
[13:20:50.318]    - tweaked: FALSE
[13:20:50.318]    - call: plan(strategy)
[13:20:50.318] plan(): nbrOfWorkers() = 1
[13:20:50.318] SequentialFuture started (and completed)
[13:20:50.318] - Launch lazy future ... done
[13:20:50.318] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.319] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.319] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.319] 
[13:20:50.320] Searching for globals ... DONE
[13:20:50.320] - globals: [0] <none>
[13:20:50.320] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.320] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.320] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.321] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:50.321] Searching for globals ... DONE
[13:20:50.321] Resolving globals: TRUE
[13:20:50.321] Resolving any globals that are futures ...
[13:20:50.322] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:50.322] Resolving any globals that are futures ... DONE
[13:20:50.322] Resolving futures part of globals (recursively) ...
[13:20:50.322] resolve() on list ...
[13:20:50.322]  recursive: 99
[13:20:50.322]  length: 1
[13:20:50.322]  elements: ‘a’
[13:20:50.323] run() for ‘Future’ ...
[13:20:50.323] - state: ‘created’
[13:20:50.323] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.323] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.323] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.323]   - Field: ‘label’
[13:20:50.323]   - Field: ‘local’
[13:20:50.324]   - Field: ‘owner’
[13:20:50.324]   - Field: ‘envir’
[13:20:50.324]   - Field: ‘packages’
[13:20:50.324]   - Field: ‘gc’
[13:20:50.324]   - Field: ‘conditions’
[13:20:50.324]   - Field: ‘expr’
[13:20:50.324]   - Field: ‘uuid’
[13:20:50.324]   - Field: ‘seed’
[13:20:50.324]   - Field: ‘version’
[13:20:50.324]   - Field: ‘result’
[13:20:50.324]   - Field: ‘asynchronous’
[13:20:50.325]   - Field: ‘calls’
[13:20:50.325]   - Field: ‘globals’
[13:20:50.325]   - Field: ‘stdout’
[13:20:50.325]   - Field: ‘earlySignal’
[13:20:50.325]   - Field: ‘lazy’
[13:20:50.325]   - Field: ‘state’
[13:20:50.325] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.325] - Launch lazy future ...
[13:20:50.325] Packages needed by the future expression (n = 0): <none>
[13:20:50.326] Packages needed by future strategies (n = 0): <none>
[13:20:50.326] {
[13:20:50.326]     {
[13:20:50.326]         {
[13:20:50.326]             ...future.startTime <- base::Sys.time()
[13:20:50.326]             {
[13:20:50.326]                 {
[13:20:50.326]                   {
[13:20:50.326]                     base::local({
[13:20:50.326]                       has_future <- base::requireNamespace("future", 
[13:20:50.326]                         quietly = TRUE)
[13:20:50.326]                       if (has_future) {
[13:20:50.326]                         ns <- base::getNamespace("future")
[13:20:50.326]                         version <- ns[[".package"]][["version"]]
[13:20:50.326]                         if (is.null(version)) 
[13:20:50.326]                           version <- utils::packageVersion("future")
[13:20:50.326]                       }
[13:20:50.326]                       else {
[13:20:50.326]                         version <- NULL
[13:20:50.326]                       }
[13:20:50.326]                       if (!has_future || version < "1.8.0") {
[13:20:50.326]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.326]                           "", base::R.version$version.string), 
[13:20:50.326]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.326]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.326]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.326]                             "release", "version")], collapse = " "), 
[13:20:50.326]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.326]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.326]                           info)
[13:20:50.326]                         info <- base::paste(info, collapse = "; ")
[13:20:50.326]                         if (!has_future) {
[13:20:50.326]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.326]                             info)
[13:20:50.326]                         }
[13:20:50.326]                         else {
[13:20:50.326]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.326]                             info, version)
[13:20:50.326]                         }
[13:20:50.326]                         base::stop(msg)
[13:20:50.326]                       }
[13:20:50.326]                     })
[13:20:50.326]                   }
[13:20:50.326]                   options(future.plan = NULL)
[13:20:50.326]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.326]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.326]                 }
[13:20:50.326]                 ...future.workdir <- getwd()
[13:20:50.326]             }
[13:20:50.326]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.326]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.326]         }
[13:20:50.326]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.326]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:50.326]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.326]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.326]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.326]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.326]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.326]             base::names(...future.oldOptions))
[13:20:50.326]     }
[13:20:50.326]     if (FALSE) {
[13:20:50.326]     }
[13:20:50.326]     else {
[13:20:50.326]         if (TRUE) {
[13:20:50.326]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.326]                 open = "w")
[13:20:50.326]         }
[13:20:50.326]         else {
[13:20:50.326]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.326]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.326]         }
[13:20:50.326]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.326]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.326]             base::sink(type = "output", split = FALSE)
[13:20:50.326]             base::close(...future.stdout)
[13:20:50.326]         }, add = TRUE)
[13:20:50.326]     }
[13:20:50.326]     ...future.frame <- base::sys.nframe()
[13:20:50.326]     ...future.conditions <- base::list()
[13:20:50.326]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.326]     if (FALSE) {
[13:20:50.326]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.326]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.326]     }
[13:20:50.326]     ...future.result <- base::tryCatch({
[13:20:50.326]         base::withCallingHandlers({
[13:20:50.326]             ...future.value <- base::withVisible(base::local(1))
[13:20:50.326]             future::FutureResult(value = ...future.value$value, 
[13:20:50.326]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.326]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.326]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.326]                     ...future.globalenv.names))
[13:20:50.326]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.326]         }, condition = base::local({
[13:20:50.326]             c <- base::c
[13:20:50.326]             inherits <- base::inherits
[13:20:50.326]             invokeRestart <- base::invokeRestart
[13:20:50.326]             length <- base::length
[13:20:50.326]             list <- base::list
[13:20:50.326]             seq.int <- base::seq.int
[13:20:50.326]             signalCondition <- base::signalCondition
[13:20:50.326]             sys.calls <- base::sys.calls
[13:20:50.326]             `[[` <- base::`[[`
[13:20:50.326]             `+` <- base::`+`
[13:20:50.326]             `<<-` <- base::`<<-`
[13:20:50.326]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.326]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.326]                   3L)]
[13:20:50.326]             }
[13:20:50.326]             function(cond) {
[13:20:50.326]                 is_error <- inherits(cond, "error")
[13:20:50.326]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.326]                   NULL)
[13:20:50.326]                 if (is_error) {
[13:20:50.326]                   sessionInformation <- function() {
[13:20:50.326]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.326]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.326]                       search = base::search(), system = base::Sys.info())
[13:20:50.326]                   }
[13:20:50.326]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.326]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.326]                     cond$call), session = sessionInformation(), 
[13:20:50.326]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.326]                   signalCondition(cond)
[13:20:50.326]                 }
[13:20:50.326]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.326]                 "immediateCondition"))) {
[13:20:50.326]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.326]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.326]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.326]                   if (TRUE && !signal) {
[13:20:50.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.326]                     {
[13:20:50.326]                       inherits <- base::inherits
[13:20:50.326]                       invokeRestart <- base::invokeRestart
[13:20:50.326]                       is.null <- base::is.null
[13:20:50.326]                       muffled <- FALSE
[13:20:50.326]                       if (inherits(cond, "message")) {
[13:20:50.326]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.326]                         if (muffled) 
[13:20:50.326]                           invokeRestart("muffleMessage")
[13:20:50.326]                       }
[13:20:50.326]                       else if (inherits(cond, "warning")) {
[13:20:50.326]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.326]                         if (muffled) 
[13:20:50.326]                           invokeRestart("muffleWarning")
[13:20:50.326]                       }
[13:20:50.326]                       else if (inherits(cond, "condition")) {
[13:20:50.326]                         if (!is.null(pattern)) {
[13:20:50.326]                           computeRestarts <- base::computeRestarts
[13:20:50.326]                           grepl <- base::grepl
[13:20:50.326]                           restarts <- computeRestarts(cond)
[13:20:50.326]                           for (restart in restarts) {
[13:20:50.326]                             name <- restart$name
[13:20:50.326]                             if (is.null(name)) 
[13:20:50.326]                               next
[13:20:50.326]                             if (!grepl(pattern, name)) 
[13:20:50.326]                               next
[13:20:50.326]                             invokeRestart(restart)
[13:20:50.326]                             muffled <- TRUE
[13:20:50.326]                             break
[13:20:50.326]                           }
[13:20:50.326]                         }
[13:20:50.326]                       }
[13:20:50.326]                       invisible(muffled)
[13:20:50.326]                     }
[13:20:50.326]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.326]                   }
[13:20:50.326]                 }
[13:20:50.326]                 else {
[13:20:50.326]                   if (TRUE) {
[13:20:50.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.326]                     {
[13:20:50.326]                       inherits <- base::inherits
[13:20:50.326]                       invokeRestart <- base::invokeRestart
[13:20:50.326]                       is.null <- base::is.null
[13:20:50.326]                       muffled <- FALSE
[13:20:50.326]                       if (inherits(cond, "message")) {
[13:20:50.326]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.326]                         if (muffled) 
[13:20:50.326]                           invokeRestart("muffleMessage")
[13:20:50.326]                       }
[13:20:50.326]                       else if (inherits(cond, "warning")) {
[13:20:50.326]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.326]                         if (muffled) 
[13:20:50.326]                           invokeRestart("muffleWarning")
[13:20:50.326]                       }
[13:20:50.326]                       else if (inherits(cond, "condition")) {
[13:20:50.326]                         if (!is.null(pattern)) {
[13:20:50.326]                           computeRestarts <- base::computeRestarts
[13:20:50.326]                           grepl <- base::grepl
[13:20:50.326]                           restarts <- computeRestarts(cond)
[13:20:50.326]                           for (restart in restarts) {
[13:20:50.326]                             name <- restart$name
[13:20:50.326]                             if (is.null(name)) 
[13:20:50.326]                               next
[13:20:50.326]                             if (!grepl(pattern, name)) 
[13:20:50.326]                               next
[13:20:50.326]                             invokeRestart(restart)
[13:20:50.326]                             muffled <- TRUE
[13:20:50.326]                             break
[13:20:50.326]                           }
[13:20:50.326]                         }
[13:20:50.326]                       }
[13:20:50.326]                       invisible(muffled)
[13:20:50.326]                     }
[13:20:50.326]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.326]                   }
[13:20:50.326]                 }
[13:20:50.326]             }
[13:20:50.326]         }))
[13:20:50.326]     }, error = function(ex) {
[13:20:50.326]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.326]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.326]                 ...future.rng), started = ...future.startTime, 
[13:20:50.326]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.326]             version = "1.8"), class = "FutureResult")
[13:20:50.326]     }, finally = {
[13:20:50.326]         if (!identical(...future.workdir, getwd())) 
[13:20:50.326]             setwd(...future.workdir)
[13:20:50.326]         {
[13:20:50.326]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.326]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.326]             }
[13:20:50.326]             base::options(...future.oldOptions)
[13:20:50.326]             if (.Platform$OS.type == "windows") {
[13:20:50.326]                 old_names <- names(...future.oldEnvVars)
[13:20:50.326]                 envs <- base::Sys.getenv()
[13:20:50.326]                 names <- names(envs)
[13:20:50.326]                 common <- intersect(names, old_names)
[13:20:50.326]                 added <- setdiff(names, old_names)
[13:20:50.326]                 removed <- setdiff(old_names, names)
[13:20:50.326]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.326]                   envs[common]]
[13:20:50.326]                 NAMES <- toupper(changed)
[13:20:50.326]                 args <- list()
[13:20:50.326]                 for (kk in seq_along(NAMES)) {
[13:20:50.326]                   name <- changed[[kk]]
[13:20:50.326]                   NAME <- NAMES[[kk]]
[13:20:50.326]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.326]                     next
[13:20:50.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.326]                 }
[13:20:50.326]                 NAMES <- toupper(added)
[13:20:50.326]                 for (kk in seq_along(NAMES)) {
[13:20:50.326]                   name <- added[[kk]]
[13:20:50.326]                   NAME <- NAMES[[kk]]
[13:20:50.326]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.326]                     next
[13:20:50.326]                   args[[name]] <- ""
[13:20:50.326]                 }
[13:20:50.326]                 NAMES <- toupper(removed)
[13:20:50.326]                 for (kk in seq_along(NAMES)) {
[13:20:50.326]                   name <- removed[[kk]]
[13:20:50.326]                   NAME <- NAMES[[kk]]
[13:20:50.326]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.326]                     next
[13:20:50.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.326]                 }
[13:20:50.326]                 if (length(args) > 0) 
[13:20:50.326]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.326]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.326]             }
[13:20:50.326]             else {
[13:20:50.326]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.326]             }
[13:20:50.326]             {
[13:20:50.326]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.326]                   0L) {
[13:20:50.326]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.326]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.326]                   base::options(opts)
[13:20:50.326]                 }
[13:20:50.326]                 {
[13:20:50.326]                   {
[13:20:50.326]                     NULL
[13:20:50.326]                     RNGkind("Mersenne-Twister")
[13:20:50.326]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.326]                       inherits = FALSE)
[13:20:50.326]                   }
[13:20:50.326]                   options(future.plan = NULL)
[13:20:50.326]                   if (is.na(NA_character_)) 
[13:20:50.326]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.326]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.326]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.326]                   {
[13:20:50.326]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.326]                     if (!future$lazy) 
[13:20:50.326]                       future <- run(future)
[13:20:50.326]                     invisible(future)
[13:20:50.326]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.326]                 }
[13:20:50.326]             }
[13:20:50.326]         }
[13:20:50.326]     })
[13:20:50.326]     if (TRUE) {
[13:20:50.326]         base::sink(type = "output", split = FALSE)
[13:20:50.326]         if (TRUE) {
[13:20:50.326]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.326]         }
[13:20:50.326]         else {
[13:20:50.326]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.326]         }
[13:20:50.326]         base::close(...future.stdout)
[13:20:50.326]         ...future.stdout <- NULL
[13:20:50.326]     }
[13:20:50.326]     ...future.result$conditions <- ...future.conditions
[13:20:50.326]     ...future.result$finished <- base::Sys.time()
[13:20:50.326]     ...future.result
[13:20:50.326] }
[13:20:50.328] plan(): Setting new future strategy stack:
[13:20:50.328] List of future strategies:
[13:20:50.328] 1. sequential:
[13:20:50.328]    - args: function (..., envir = parent.frame())
[13:20:50.328]    - tweaked: FALSE
[13:20:50.328]    - call: NULL
[13:20:50.328] plan(): nbrOfWorkers() = 1
[13:20:50.329] plan(): Setting new future strategy stack:
[13:20:50.329] List of future strategies:
[13:20:50.329] 1. sequential:
[13:20:50.329]    - args: function (..., envir = parent.frame())
[13:20:50.329]    - tweaked: FALSE
[13:20:50.329]    - call: plan(strategy)
[13:20:50.330] plan(): nbrOfWorkers() = 1
[13:20:50.330] SequentialFuture started (and completed)
[13:20:50.330] - Launch lazy future ... done
[13:20:50.330] run() for ‘SequentialFuture’ ... done
[13:20:50.330] resolved() for ‘SequentialFuture’ ...
[13:20:50.330] - state: ‘finished’
[13:20:50.330] - run: TRUE
[13:20:50.330] - result: ‘FutureResult’
[13:20:50.331] resolved() for ‘SequentialFuture’ ... done
[13:20:50.331] Future #1
[13:20:50.331] resolved() for ‘SequentialFuture’ ...
[13:20:50.331] - state: ‘finished’
[13:20:50.331] - run: TRUE
[13:20:50.331] - result: ‘FutureResult’
[13:20:50.331] resolved() for ‘SequentialFuture’ ... done
[13:20:50.331] A SequentialFuture was resolved
[13:20:50.331]  length: 0 (resolved future 1)
[13:20:50.332] resolve() on list ... DONE
[13:20:50.332] - globals: [1] ‘a’
[13:20:50.332] Resolving futures part of globals (recursively) ... DONE
[13:20:50.333] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[13:20:50.333] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[13:20:50.333] - globals: [1] ‘a’
[13:20:50.333] - packages: [1] ‘future’
[13:20:50.333] getGlobalsAndPackages() ... DONE
[13:20:50.334] run() for ‘Future’ ...
[13:20:50.334] - state: ‘created’
[13:20:50.334] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.334] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.334] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.334]   - Field: ‘label’
[13:20:50.334]   - Field: ‘local’
[13:20:50.334]   - Field: ‘owner’
[13:20:50.335]   - Field: ‘envir’
[13:20:50.335]   - Field: ‘packages’
[13:20:50.335]   - Field: ‘gc’
[13:20:50.335]   - Field: ‘conditions’
[13:20:50.335]   - Field: ‘expr’
[13:20:50.335]   - Field: ‘uuid’
[13:20:50.335]   - Field: ‘seed’
[13:20:50.335]   - Field: ‘version’
[13:20:50.335]   - Field: ‘result’
[13:20:50.335]   - Field: ‘asynchronous’
[13:20:50.335]   - Field: ‘calls’
[13:20:50.336]   - Field: ‘globals’
[13:20:50.336]   - Field: ‘stdout’
[13:20:50.336]   - Field: ‘earlySignal’
[13:20:50.336]   - Field: ‘lazy’
[13:20:50.336]   - Field: ‘state’
[13:20:50.336] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.336] - Launch lazy future ...
[13:20:50.336] Packages needed by the future expression (n = 1): ‘future’
[13:20:50.336] Packages needed by future strategies (n = 0): <none>
[13:20:50.339] {
[13:20:50.339]     {
[13:20:50.339]         {
[13:20:50.339]             ...future.startTime <- base::Sys.time()
[13:20:50.339]             {
[13:20:50.339]                 {
[13:20:50.339]                   {
[13:20:50.339]                     {
[13:20:50.339]                       base::local({
[13:20:50.339]                         has_future <- base::requireNamespace("future", 
[13:20:50.339]                           quietly = TRUE)
[13:20:50.339]                         if (has_future) {
[13:20:50.339]                           ns <- base::getNamespace("future")
[13:20:50.339]                           version <- ns[[".package"]][["version"]]
[13:20:50.339]                           if (is.null(version)) 
[13:20:50.339]                             version <- utils::packageVersion("future")
[13:20:50.339]                         }
[13:20:50.339]                         else {
[13:20:50.339]                           version <- NULL
[13:20:50.339]                         }
[13:20:50.339]                         if (!has_future || version < "1.8.0") {
[13:20:50.339]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.339]                             "", base::R.version$version.string), 
[13:20:50.339]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:50.339]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.339]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.339]                               "release", "version")], collapse = " "), 
[13:20:50.339]                             hostname = base::Sys.info()[["nodename"]])
[13:20:50.339]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.339]                             info)
[13:20:50.339]                           info <- base::paste(info, collapse = "; ")
[13:20:50.339]                           if (!has_future) {
[13:20:50.339]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.339]                               info)
[13:20:50.339]                           }
[13:20:50.339]                           else {
[13:20:50.339]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.339]                               info, version)
[13:20:50.339]                           }
[13:20:50.339]                           base::stop(msg)
[13:20:50.339]                         }
[13:20:50.339]                       })
[13:20:50.339]                     }
[13:20:50.339]                     base::local({
[13:20:50.339]                       for (pkg in "future") {
[13:20:50.339]                         base::loadNamespace(pkg)
[13:20:50.339]                         base::library(pkg, character.only = TRUE)
[13:20:50.339]                       }
[13:20:50.339]                     })
[13:20:50.339]                   }
[13:20:50.339]                   options(future.plan = NULL)
[13:20:50.339]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.339]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.339]                 }
[13:20:50.339]                 ...future.workdir <- getwd()
[13:20:50.339]             }
[13:20:50.339]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.339]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.339]         }
[13:20:50.339]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.339]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:50.339]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.339]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.339]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.339]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.339]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.339]             base::names(...future.oldOptions))
[13:20:50.339]     }
[13:20:50.339]     if (FALSE) {
[13:20:50.339]     }
[13:20:50.339]     else {
[13:20:50.339]         if (TRUE) {
[13:20:50.339]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.339]                 open = "w")
[13:20:50.339]         }
[13:20:50.339]         else {
[13:20:50.339]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.339]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.339]         }
[13:20:50.339]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.339]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.339]             base::sink(type = "output", split = FALSE)
[13:20:50.339]             base::close(...future.stdout)
[13:20:50.339]         }, add = TRUE)
[13:20:50.339]     }
[13:20:50.339]     ...future.frame <- base::sys.nframe()
[13:20:50.339]     ...future.conditions <- base::list()
[13:20:50.339]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.339]     if (FALSE) {
[13:20:50.339]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.339]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.339]     }
[13:20:50.339]     ...future.result <- base::tryCatch({
[13:20:50.339]         base::withCallingHandlers({
[13:20:50.339]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:20:50.339]                 1))
[13:20:50.339]             future::FutureResult(value = ...future.value$value, 
[13:20:50.339]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.339]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.339]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.339]                     ...future.globalenv.names))
[13:20:50.339]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.339]         }, condition = base::local({
[13:20:50.339]             c <- base::c
[13:20:50.339]             inherits <- base::inherits
[13:20:50.339]             invokeRestart <- base::invokeRestart
[13:20:50.339]             length <- base::length
[13:20:50.339]             list <- base::list
[13:20:50.339]             seq.int <- base::seq.int
[13:20:50.339]             signalCondition <- base::signalCondition
[13:20:50.339]             sys.calls <- base::sys.calls
[13:20:50.339]             `[[` <- base::`[[`
[13:20:50.339]             `+` <- base::`+`
[13:20:50.339]             `<<-` <- base::`<<-`
[13:20:50.339]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.339]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.339]                   3L)]
[13:20:50.339]             }
[13:20:50.339]             function(cond) {
[13:20:50.339]                 is_error <- inherits(cond, "error")
[13:20:50.339]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.339]                   NULL)
[13:20:50.339]                 if (is_error) {
[13:20:50.339]                   sessionInformation <- function() {
[13:20:50.339]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.339]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.339]                       search = base::search(), system = base::Sys.info())
[13:20:50.339]                   }
[13:20:50.339]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.339]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.339]                     cond$call), session = sessionInformation(), 
[13:20:50.339]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.339]                   signalCondition(cond)
[13:20:50.339]                 }
[13:20:50.339]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.339]                 "immediateCondition"))) {
[13:20:50.339]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.339]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.339]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.339]                   if (TRUE && !signal) {
[13:20:50.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.339]                     {
[13:20:50.339]                       inherits <- base::inherits
[13:20:50.339]                       invokeRestart <- base::invokeRestart
[13:20:50.339]                       is.null <- base::is.null
[13:20:50.339]                       muffled <- FALSE
[13:20:50.339]                       if (inherits(cond, "message")) {
[13:20:50.339]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.339]                         if (muffled) 
[13:20:50.339]                           invokeRestart("muffleMessage")
[13:20:50.339]                       }
[13:20:50.339]                       else if (inherits(cond, "warning")) {
[13:20:50.339]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.339]                         if (muffled) 
[13:20:50.339]                           invokeRestart("muffleWarning")
[13:20:50.339]                       }
[13:20:50.339]                       else if (inherits(cond, "condition")) {
[13:20:50.339]                         if (!is.null(pattern)) {
[13:20:50.339]                           computeRestarts <- base::computeRestarts
[13:20:50.339]                           grepl <- base::grepl
[13:20:50.339]                           restarts <- computeRestarts(cond)
[13:20:50.339]                           for (restart in restarts) {
[13:20:50.339]                             name <- restart$name
[13:20:50.339]                             if (is.null(name)) 
[13:20:50.339]                               next
[13:20:50.339]                             if (!grepl(pattern, name)) 
[13:20:50.339]                               next
[13:20:50.339]                             invokeRestart(restart)
[13:20:50.339]                             muffled <- TRUE
[13:20:50.339]                             break
[13:20:50.339]                           }
[13:20:50.339]                         }
[13:20:50.339]                       }
[13:20:50.339]                       invisible(muffled)
[13:20:50.339]                     }
[13:20:50.339]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.339]                   }
[13:20:50.339]                 }
[13:20:50.339]                 else {
[13:20:50.339]                   if (TRUE) {
[13:20:50.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.339]                     {
[13:20:50.339]                       inherits <- base::inherits
[13:20:50.339]                       invokeRestart <- base::invokeRestart
[13:20:50.339]                       is.null <- base::is.null
[13:20:50.339]                       muffled <- FALSE
[13:20:50.339]                       if (inherits(cond, "message")) {
[13:20:50.339]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.339]                         if (muffled) 
[13:20:50.339]                           invokeRestart("muffleMessage")
[13:20:50.339]                       }
[13:20:50.339]                       else if (inherits(cond, "warning")) {
[13:20:50.339]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.339]                         if (muffled) 
[13:20:50.339]                           invokeRestart("muffleWarning")
[13:20:50.339]                       }
[13:20:50.339]                       else if (inherits(cond, "condition")) {
[13:20:50.339]                         if (!is.null(pattern)) {
[13:20:50.339]                           computeRestarts <- base::computeRestarts
[13:20:50.339]                           grepl <- base::grepl
[13:20:50.339]                           restarts <- computeRestarts(cond)
[13:20:50.339]                           for (restart in restarts) {
[13:20:50.339]                             name <- restart$name
[13:20:50.339]                             if (is.null(name)) 
[13:20:50.339]                               next
[13:20:50.339]                             if (!grepl(pattern, name)) 
[13:20:50.339]                               next
[13:20:50.339]                             invokeRestart(restart)
[13:20:50.339]                             muffled <- TRUE
[13:20:50.339]                             break
[13:20:50.339]                           }
[13:20:50.339]                         }
[13:20:50.339]                       }
[13:20:50.339]                       invisible(muffled)
[13:20:50.339]                     }
[13:20:50.339]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.339]                   }
[13:20:50.339]                 }
[13:20:50.339]             }
[13:20:50.339]         }))
[13:20:50.339]     }, error = function(ex) {
[13:20:50.339]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.339]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.339]                 ...future.rng), started = ...future.startTime, 
[13:20:50.339]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.339]             version = "1.8"), class = "FutureResult")
[13:20:50.339]     }, finally = {
[13:20:50.339]         if (!identical(...future.workdir, getwd())) 
[13:20:50.339]             setwd(...future.workdir)
[13:20:50.339]         {
[13:20:50.339]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.339]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.339]             }
[13:20:50.339]             base::options(...future.oldOptions)
[13:20:50.339]             if (.Platform$OS.type == "windows") {
[13:20:50.339]                 old_names <- names(...future.oldEnvVars)
[13:20:50.339]                 envs <- base::Sys.getenv()
[13:20:50.339]                 names <- names(envs)
[13:20:50.339]                 common <- intersect(names, old_names)
[13:20:50.339]                 added <- setdiff(names, old_names)
[13:20:50.339]                 removed <- setdiff(old_names, names)
[13:20:50.339]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.339]                   envs[common]]
[13:20:50.339]                 NAMES <- toupper(changed)
[13:20:50.339]                 args <- list()
[13:20:50.339]                 for (kk in seq_along(NAMES)) {
[13:20:50.339]                   name <- changed[[kk]]
[13:20:50.339]                   NAME <- NAMES[[kk]]
[13:20:50.339]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.339]                     next
[13:20:50.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.339]                 }
[13:20:50.339]                 NAMES <- toupper(added)
[13:20:50.339]                 for (kk in seq_along(NAMES)) {
[13:20:50.339]                   name <- added[[kk]]
[13:20:50.339]                   NAME <- NAMES[[kk]]
[13:20:50.339]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.339]                     next
[13:20:50.339]                   args[[name]] <- ""
[13:20:50.339]                 }
[13:20:50.339]                 NAMES <- toupper(removed)
[13:20:50.339]                 for (kk in seq_along(NAMES)) {
[13:20:50.339]                   name <- removed[[kk]]
[13:20:50.339]                   NAME <- NAMES[[kk]]
[13:20:50.339]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.339]                     next
[13:20:50.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.339]                 }
[13:20:50.339]                 if (length(args) > 0) 
[13:20:50.339]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.339]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.339]             }
[13:20:50.339]             else {
[13:20:50.339]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.339]             }
[13:20:50.339]             {
[13:20:50.339]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.339]                   0L) {
[13:20:50.339]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.339]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.339]                   base::options(opts)
[13:20:50.339]                 }
[13:20:50.339]                 {
[13:20:50.339]                   {
[13:20:50.339]                     NULL
[13:20:50.339]                     RNGkind("Mersenne-Twister")
[13:20:50.339]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.339]                       inherits = FALSE)
[13:20:50.339]                   }
[13:20:50.339]                   options(future.plan = NULL)
[13:20:50.339]                   if (is.na(NA_character_)) 
[13:20:50.339]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.339]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.339]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.339]                   {
[13:20:50.339]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.339]                     if (!future$lazy) 
[13:20:50.339]                       future <- run(future)
[13:20:50.339]                     invisible(future)
[13:20:50.339]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.339]                 }
[13:20:50.339]             }
[13:20:50.339]         }
[13:20:50.339]     })
[13:20:50.339]     if (TRUE) {
[13:20:50.339]         base::sink(type = "output", split = FALSE)
[13:20:50.339]         if (TRUE) {
[13:20:50.339]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.339]         }
[13:20:50.339]         else {
[13:20:50.339]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.339]         }
[13:20:50.339]         base::close(...future.stdout)
[13:20:50.339]         ...future.stdout <- NULL
[13:20:50.339]     }
[13:20:50.339]     ...future.result$conditions <- ...future.conditions
[13:20:50.339]     ...future.result$finished <- base::Sys.time()
[13:20:50.339]     ...future.result
[13:20:50.339] }
[13:20:50.340] assign_globals() ...
[13:20:50.340] List of 1
[13:20:50.340]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x558ddfa9fa20> 
[13:20:50.340]  - attr(*, "where")=List of 1
[13:20:50.340]   ..$ a:<environment: R_EmptyEnv> 
[13:20:50.340]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.340]  - attr(*, "resolved")= logi TRUE
[13:20:50.340]  - attr(*, "total_size")= num 10592
[13:20:50.340]  - attr(*, "already-done")= logi TRUE
[13:20:50.343] - copied ‘a’ to environment
[13:20:50.343] assign_globals() ... done
[13:20:50.344] plan(): Setting new future strategy stack:
[13:20:50.344] List of future strategies:
[13:20:50.344] 1. sequential:
[13:20:50.344]    - args: function (..., envir = parent.frame())
[13:20:50.344]    - tweaked: FALSE
[13:20:50.344]    - call: NULL
[13:20:50.344] plan(): nbrOfWorkers() = 1
[13:20:50.345] plan(): Setting new future strategy stack:
[13:20:50.345] List of future strategies:
[13:20:50.345] 1. sequential:
[13:20:50.345]    - args: function (..., envir = parent.frame())
[13:20:50.345]    - tweaked: FALSE
[13:20:50.345]    - call: plan(strategy)
[13:20:50.345] plan(): nbrOfWorkers() = 1
[13:20:50.345] SequentialFuture started (and completed)
[13:20:50.346] - Launch lazy future ... done
[13:20:50.346] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.346] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.346] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.347] - globals found: [2] ‘{’, ‘pkg’
[13:20:50.347] Searching for globals ... DONE
[13:20:50.347] Resolving globals: TRUE
[13:20:50.347] Resolving any globals that are futures ...
[13:20:50.348] - globals: [2] ‘{’, ‘pkg’
[13:20:50.348] Resolving any globals that are futures ... DONE
[13:20:50.348] Resolving futures part of globals (recursively) ...
[13:20:50.348] resolve() on list ...
[13:20:50.348]  recursive: 99
[13:20:50.348]  length: 1
[13:20:50.348]  elements: ‘pkg’
[13:20:50.349]  length: 0 (resolved future 1)
[13:20:50.349] resolve() on list ... DONE
[13:20:50.349] - globals: [1] ‘pkg’
[13:20:50.349] Resolving futures part of globals (recursively) ... DONE
[13:20:50.349] The total size of the 1 globals is 112 bytes (112 bytes)
[13:20:50.349] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[13:20:50.350] - globals: [1] ‘pkg’
[13:20:50.350] 
[13:20:50.350] getGlobalsAndPackages() ... DONE
[13:20:50.350] Packages needed by the future expression (n = 0): <none>
[13:20:50.350] Packages needed by future strategies (n = 0): <none>
[13:20:50.351] {
[13:20:50.351]     {
[13:20:50.351]         {
[13:20:50.351]             ...future.startTime <- base::Sys.time()
[13:20:50.351]             {
[13:20:50.351]                 {
[13:20:50.351]                   {
[13:20:50.351]                     base::local({
[13:20:50.351]                       has_future <- base::requireNamespace("future", 
[13:20:50.351]                         quietly = TRUE)
[13:20:50.351]                       if (has_future) {
[13:20:50.351]                         ns <- base::getNamespace("future")
[13:20:50.351]                         version <- ns[[".package"]][["version"]]
[13:20:50.351]                         if (is.null(version)) 
[13:20:50.351]                           version <- utils::packageVersion("future")
[13:20:50.351]                       }
[13:20:50.351]                       else {
[13:20:50.351]                         version <- NULL
[13:20:50.351]                       }
[13:20:50.351]                       if (!has_future || version < "1.8.0") {
[13:20:50.351]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.351]                           "", base::R.version$version.string), 
[13:20:50.351]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.351]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.351]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.351]                             "release", "version")], collapse = " "), 
[13:20:50.351]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.351]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.351]                           info)
[13:20:50.351]                         info <- base::paste(info, collapse = "; ")
[13:20:50.351]                         if (!has_future) {
[13:20:50.351]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.351]                             info)
[13:20:50.351]                         }
[13:20:50.351]                         else {
[13:20:50.351]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.351]                             info, version)
[13:20:50.351]                         }
[13:20:50.351]                         base::stop(msg)
[13:20:50.351]                       }
[13:20:50.351]                     })
[13:20:50.351]                   }
[13:20:50.351]                   options(future.plan = NULL)
[13:20:50.351]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.351]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.351]                 }
[13:20:50.351]                 ...future.workdir <- getwd()
[13:20:50.351]             }
[13:20:50.351]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.351]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.351]         }
[13:20:50.351]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.351]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:50.351]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.351]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.351]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.351]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.351]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.351]             base::names(...future.oldOptions))
[13:20:50.351]     }
[13:20:50.351]     if (FALSE) {
[13:20:50.351]     }
[13:20:50.351]     else {
[13:20:50.351]         if (TRUE) {
[13:20:50.351]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.351]                 open = "w")
[13:20:50.351]         }
[13:20:50.351]         else {
[13:20:50.351]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.351]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.351]         }
[13:20:50.351]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.351]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.351]             base::sink(type = "output", split = FALSE)
[13:20:50.351]             base::close(...future.stdout)
[13:20:50.351]         }, add = TRUE)
[13:20:50.351]     }
[13:20:50.351]     ...future.frame <- base::sys.nframe()
[13:20:50.351]     ...future.conditions <- base::list()
[13:20:50.351]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.351]     if (FALSE) {
[13:20:50.351]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.351]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.351]     }
[13:20:50.351]     ...future.result <- base::tryCatch({
[13:20:50.351]         base::withCallingHandlers({
[13:20:50.351]             ...future.value <- base::withVisible(base::local({
[13:20:50.351]                 pkg
[13:20:50.351]             }))
[13:20:50.351]             future::FutureResult(value = ...future.value$value, 
[13:20:50.351]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.351]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.351]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.351]                     ...future.globalenv.names))
[13:20:50.351]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.351]         }, condition = base::local({
[13:20:50.351]             c <- base::c
[13:20:50.351]             inherits <- base::inherits
[13:20:50.351]             invokeRestart <- base::invokeRestart
[13:20:50.351]             length <- base::length
[13:20:50.351]             list <- base::list
[13:20:50.351]             seq.int <- base::seq.int
[13:20:50.351]             signalCondition <- base::signalCondition
[13:20:50.351]             sys.calls <- base::sys.calls
[13:20:50.351]             `[[` <- base::`[[`
[13:20:50.351]             `+` <- base::`+`
[13:20:50.351]             `<<-` <- base::`<<-`
[13:20:50.351]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.351]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.351]                   3L)]
[13:20:50.351]             }
[13:20:50.351]             function(cond) {
[13:20:50.351]                 is_error <- inherits(cond, "error")
[13:20:50.351]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.351]                   NULL)
[13:20:50.351]                 if (is_error) {
[13:20:50.351]                   sessionInformation <- function() {
[13:20:50.351]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.351]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.351]                       search = base::search(), system = base::Sys.info())
[13:20:50.351]                   }
[13:20:50.351]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.351]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.351]                     cond$call), session = sessionInformation(), 
[13:20:50.351]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.351]                   signalCondition(cond)
[13:20:50.351]                 }
[13:20:50.351]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.351]                 "immediateCondition"))) {
[13:20:50.351]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.351]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.351]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.351]                   if (TRUE && !signal) {
[13:20:50.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.351]                     {
[13:20:50.351]                       inherits <- base::inherits
[13:20:50.351]                       invokeRestart <- base::invokeRestart
[13:20:50.351]                       is.null <- base::is.null
[13:20:50.351]                       muffled <- FALSE
[13:20:50.351]                       if (inherits(cond, "message")) {
[13:20:50.351]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.351]                         if (muffled) 
[13:20:50.351]                           invokeRestart("muffleMessage")
[13:20:50.351]                       }
[13:20:50.351]                       else if (inherits(cond, "warning")) {
[13:20:50.351]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.351]                         if (muffled) 
[13:20:50.351]                           invokeRestart("muffleWarning")
[13:20:50.351]                       }
[13:20:50.351]                       else if (inherits(cond, "condition")) {
[13:20:50.351]                         if (!is.null(pattern)) {
[13:20:50.351]                           computeRestarts <- base::computeRestarts
[13:20:50.351]                           grepl <- base::grepl
[13:20:50.351]                           restarts <- computeRestarts(cond)
[13:20:50.351]                           for (restart in restarts) {
[13:20:50.351]                             name <- restart$name
[13:20:50.351]                             if (is.null(name)) 
[13:20:50.351]                               next
[13:20:50.351]                             if (!grepl(pattern, name)) 
[13:20:50.351]                               next
[13:20:50.351]                             invokeRestart(restart)
[13:20:50.351]                             muffled <- TRUE
[13:20:50.351]                             break
[13:20:50.351]                           }
[13:20:50.351]                         }
[13:20:50.351]                       }
[13:20:50.351]                       invisible(muffled)
[13:20:50.351]                     }
[13:20:50.351]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.351]                   }
[13:20:50.351]                 }
[13:20:50.351]                 else {
[13:20:50.351]                   if (TRUE) {
[13:20:50.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.351]                     {
[13:20:50.351]                       inherits <- base::inherits
[13:20:50.351]                       invokeRestart <- base::invokeRestart
[13:20:50.351]                       is.null <- base::is.null
[13:20:50.351]                       muffled <- FALSE
[13:20:50.351]                       if (inherits(cond, "message")) {
[13:20:50.351]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.351]                         if (muffled) 
[13:20:50.351]                           invokeRestart("muffleMessage")
[13:20:50.351]                       }
[13:20:50.351]                       else if (inherits(cond, "warning")) {
[13:20:50.351]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.351]                         if (muffled) 
[13:20:50.351]                           invokeRestart("muffleWarning")
[13:20:50.351]                       }
[13:20:50.351]                       else if (inherits(cond, "condition")) {
[13:20:50.351]                         if (!is.null(pattern)) {
[13:20:50.351]                           computeRestarts <- base::computeRestarts
[13:20:50.351]                           grepl <- base::grepl
[13:20:50.351]                           restarts <- computeRestarts(cond)
[13:20:50.351]                           for (restart in restarts) {
[13:20:50.351]                             name <- restart$name
[13:20:50.351]                             if (is.null(name)) 
[13:20:50.351]                               next
[13:20:50.351]                             if (!grepl(pattern, name)) 
[13:20:50.351]                               next
[13:20:50.351]                             invokeRestart(restart)
[13:20:50.351]                             muffled <- TRUE
[13:20:50.351]                             break
[13:20:50.351]                           }
[13:20:50.351]                         }
[13:20:50.351]                       }
[13:20:50.351]                       invisible(muffled)
[13:20:50.351]                     }
[13:20:50.351]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.351]                   }
[13:20:50.351]                 }
[13:20:50.351]             }
[13:20:50.351]         }))
[13:20:50.351]     }, error = function(ex) {
[13:20:50.351]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.351]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.351]                 ...future.rng), started = ...future.startTime, 
[13:20:50.351]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.351]             version = "1.8"), class = "FutureResult")
[13:20:50.351]     }, finally = {
[13:20:50.351]         if (!identical(...future.workdir, getwd())) 
[13:20:50.351]             setwd(...future.workdir)
[13:20:50.351]         {
[13:20:50.351]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.351]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.351]             }
[13:20:50.351]             base::options(...future.oldOptions)
[13:20:50.351]             if (.Platform$OS.type == "windows") {
[13:20:50.351]                 old_names <- names(...future.oldEnvVars)
[13:20:50.351]                 envs <- base::Sys.getenv()
[13:20:50.351]                 names <- names(envs)
[13:20:50.351]                 common <- intersect(names, old_names)
[13:20:50.351]                 added <- setdiff(names, old_names)
[13:20:50.351]                 removed <- setdiff(old_names, names)
[13:20:50.351]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.351]                   envs[common]]
[13:20:50.351]                 NAMES <- toupper(changed)
[13:20:50.351]                 args <- list()
[13:20:50.351]                 for (kk in seq_along(NAMES)) {
[13:20:50.351]                   name <- changed[[kk]]
[13:20:50.351]                   NAME <- NAMES[[kk]]
[13:20:50.351]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.351]                     next
[13:20:50.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.351]                 }
[13:20:50.351]                 NAMES <- toupper(added)
[13:20:50.351]                 for (kk in seq_along(NAMES)) {
[13:20:50.351]                   name <- added[[kk]]
[13:20:50.351]                   NAME <- NAMES[[kk]]
[13:20:50.351]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.351]                     next
[13:20:50.351]                   args[[name]] <- ""
[13:20:50.351]                 }
[13:20:50.351]                 NAMES <- toupper(removed)
[13:20:50.351]                 for (kk in seq_along(NAMES)) {
[13:20:50.351]                   name <- removed[[kk]]
[13:20:50.351]                   NAME <- NAMES[[kk]]
[13:20:50.351]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.351]                     next
[13:20:50.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.351]                 }
[13:20:50.351]                 if (length(args) > 0) 
[13:20:50.351]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.351]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.351]             }
[13:20:50.351]             else {
[13:20:50.351]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.351]             }
[13:20:50.351]             {
[13:20:50.351]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.351]                   0L) {
[13:20:50.351]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.351]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.351]                   base::options(opts)
[13:20:50.351]                 }
[13:20:50.351]                 {
[13:20:50.351]                   {
[13:20:50.351]                     NULL
[13:20:50.351]                     RNGkind("Mersenne-Twister")
[13:20:50.351]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.351]                       inherits = FALSE)
[13:20:50.351]                   }
[13:20:50.351]                   options(future.plan = NULL)
[13:20:50.351]                   if (is.na(NA_character_)) 
[13:20:50.351]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.351]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.351]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.351]                   {
[13:20:50.351]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.351]                     if (!future$lazy) 
[13:20:50.351]                       future <- run(future)
[13:20:50.351]                     invisible(future)
[13:20:50.351]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.351]                 }
[13:20:50.351]             }
[13:20:50.351]         }
[13:20:50.351]     })
[13:20:50.351]     if (TRUE) {
[13:20:50.351]         base::sink(type = "output", split = FALSE)
[13:20:50.351]         if (TRUE) {
[13:20:50.351]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.351]         }
[13:20:50.351]         else {
[13:20:50.351]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.351]         }
[13:20:50.351]         base::close(...future.stdout)
[13:20:50.351]         ...future.stdout <- NULL
[13:20:50.351]     }
[13:20:50.351]     ...future.result$conditions <- ...future.conditions
[13:20:50.351]     ...future.result$finished <- base::Sys.time()
[13:20:50.351]     ...future.result
[13:20:50.351] }
[13:20:50.352] assign_globals() ...
[13:20:50.353] List of 1
[13:20:50.353]  $ pkg: chr "foo"
[13:20:50.353]  - attr(*, "where")=List of 1
[13:20:50.353]   ..$ pkg:<environment: R_EmptyEnv> 
[13:20:50.353]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.353]  - attr(*, "resolved")= logi TRUE
[13:20:50.353]  - attr(*, "total_size")= num 112
[13:20:50.355] - copied ‘pkg’ to environment
[13:20:50.355] assign_globals() ... done
[13:20:50.355] plan(): Setting new future strategy stack:
[13:20:50.355] List of future strategies:
[13:20:50.355] 1. sequential:
[13:20:50.355]    - args: function (..., envir = parent.frame())
[13:20:50.355]    - tweaked: FALSE
[13:20:50.355]    - call: NULL
[13:20:50.356] plan(): nbrOfWorkers() = 1
[13:20:50.356] plan(): Setting new future strategy stack:
[13:20:50.357] List of future strategies:
[13:20:50.357] 1. sequential:
[13:20:50.357]    - args: function (..., envir = parent.frame())
[13:20:50.357]    - tweaked: FALSE
[13:20:50.357]    - call: plan(strategy)
[13:20:50.357] plan(): nbrOfWorkers() = 1
[13:20:50.357] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.358] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.358] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:50.360] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:20:50.361] Searching for globals ... DONE
[13:20:50.361] Resolving globals: TRUE
[13:20:50.361] Resolving any globals that are futures ...
[13:20:50.361] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:20:50.361] Resolving any globals that are futures ... DONE
[13:20:50.361] Resolving futures part of globals (recursively) ...
[13:20:50.362] resolve() on list ...
[13:20:50.362]  recursive: 99
[13:20:50.362]  length: 1
[13:20:50.362]  elements: ‘a’
[13:20:50.362]  length: 0 (resolved future 1)
[13:20:50.362] resolve() on list ... DONE
[13:20:50.362] - globals: [1] ‘a’
[13:20:50.362] Resolving futures part of globals (recursively) ... DONE
[13:20:50.362] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:50.363] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:20:50.363] - globals: [1] ‘a’
[13:20:50.363] 
[13:20:50.363] getGlobalsAndPackages() ... DONE
[13:20:50.363] run() for ‘Future’ ...
[13:20:50.363] - state: ‘created’
[13:20:50.363] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.364] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.364] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.364]   - Field: ‘label’
[13:20:50.364]   - Field: ‘local’
[13:20:50.364]   - Field: ‘owner’
[13:20:50.364]   - Field: ‘envir’
[13:20:50.364]   - Field: ‘packages’
[13:20:50.364]   - Field: ‘gc’
[13:20:50.365]   - Field: ‘conditions’
[13:20:50.365]   - Field: ‘expr’
[13:20:50.365]   - Field: ‘uuid’
[13:20:50.365]   - Field: ‘seed’
[13:20:50.365]   - Field: ‘version’
[13:20:50.365]   - Field: ‘result’
[13:20:50.365]   - Field: ‘asynchronous’
[13:20:50.365]   - Field: ‘calls’
[13:20:50.365]   - Field: ‘globals’
[13:20:50.365]   - Field: ‘stdout’
[13:20:50.365]   - Field: ‘earlySignal’
[13:20:50.366]   - Field: ‘lazy’
[13:20:50.366]   - Field: ‘state’
[13:20:50.368] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.368] - Launch lazy future ...
[13:20:50.368] Packages needed by the future expression (n = 0): <none>
[13:20:50.368] Packages needed by future strategies (n = 0): <none>
[13:20:50.368] {
[13:20:50.368]     {
[13:20:50.368]         {
[13:20:50.368]             ...future.startTime <- base::Sys.time()
[13:20:50.368]             {
[13:20:50.368]                 {
[13:20:50.368]                   {
[13:20:50.368]                     base::local({
[13:20:50.368]                       has_future <- base::requireNamespace("future", 
[13:20:50.368]                         quietly = TRUE)
[13:20:50.368]                       if (has_future) {
[13:20:50.368]                         ns <- base::getNamespace("future")
[13:20:50.368]                         version <- ns[[".package"]][["version"]]
[13:20:50.368]                         if (is.null(version)) 
[13:20:50.368]                           version <- utils::packageVersion("future")
[13:20:50.368]                       }
[13:20:50.368]                       else {
[13:20:50.368]                         version <- NULL
[13:20:50.368]                       }
[13:20:50.368]                       if (!has_future || version < "1.8.0") {
[13:20:50.368]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.368]                           "", base::R.version$version.string), 
[13:20:50.368]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.368]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.368]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.368]                             "release", "version")], collapse = " "), 
[13:20:50.368]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.368]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.368]                           info)
[13:20:50.368]                         info <- base::paste(info, collapse = "; ")
[13:20:50.368]                         if (!has_future) {
[13:20:50.368]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.368]                             info)
[13:20:50.368]                         }
[13:20:50.368]                         else {
[13:20:50.368]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.368]                             info, version)
[13:20:50.368]                         }
[13:20:50.368]                         base::stop(msg)
[13:20:50.368]                       }
[13:20:50.368]                     })
[13:20:50.368]                   }
[13:20:50.368]                   options(future.plan = NULL)
[13:20:50.368]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.368]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.368]                 }
[13:20:50.368]                 ...future.workdir <- getwd()
[13:20:50.368]             }
[13:20:50.368]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.368]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.368]         }
[13:20:50.368]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.368]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:50.368]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.368]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.368]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.368]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.368]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.368]             base::names(...future.oldOptions))
[13:20:50.368]     }
[13:20:50.368]     if (FALSE) {
[13:20:50.368]     }
[13:20:50.368]     else {
[13:20:50.368]         if (TRUE) {
[13:20:50.368]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.368]                 open = "w")
[13:20:50.368]         }
[13:20:50.368]         else {
[13:20:50.368]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.368]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.368]         }
[13:20:50.368]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.368]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.368]             base::sink(type = "output", split = FALSE)
[13:20:50.368]             base::close(...future.stdout)
[13:20:50.368]         }, add = TRUE)
[13:20:50.368]     }
[13:20:50.368]     ...future.frame <- base::sys.nframe()
[13:20:50.368]     ...future.conditions <- base::list()
[13:20:50.368]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.368]     if (FALSE) {
[13:20:50.368]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.368]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.368]     }
[13:20:50.368]     ...future.result <- base::tryCatch({
[13:20:50.368]         base::withCallingHandlers({
[13:20:50.368]             ...future.value <- base::withVisible(base::local({
[13:20:50.368]                 b <- a
[13:20:50.368]                 a <- 2
[13:20:50.368]                 a * b
[13:20:50.368]             }))
[13:20:50.368]             future::FutureResult(value = ...future.value$value, 
[13:20:50.368]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.368]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.368]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.368]                     ...future.globalenv.names))
[13:20:50.368]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.368]         }, condition = base::local({
[13:20:50.368]             c <- base::c
[13:20:50.368]             inherits <- base::inherits
[13:20:50.368]             invokeRestart <- base::invokeRestart
[13:20:50.368]             length <- base::length
[13:20:50.368]             list <- base::list
[13:20:50.368]             seq.int <- base::seq.int
[13:20:50.368]             signalCondition <- base::signalCondition
[13:20:50.368]             sys.calls <- base::sys.calls
[13:20:50.368]             `[[` <- base::`[[`
[13:20:50.368]             `+` <- base::`+`
[13:20:50.368]             `<<-` <- base::`<<-`
[13:20:50.368]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.368]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.368]                   3L)]
[13:20:50.368]             }
[13:20:50.368]             function(cond) {
[13:20:50.368]                 is_error <- inherits(cond, "error")
[13:20:50.368]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.368]                   NULL)
[13:20:50.368]                 if (is_error) {
[13:20:50.368]                   sessionInformation <- function() {
[13:20:50.368]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.368]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.368]                       search = base::search(), system = base::Sys.info())
[13:20:50.368]                   }
[13:20:50.368]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.368]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.368]                     cond$call), session = sessionInformation(), 
[13:20:50.368]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.368]                   signalCondition(cond)
[13:20:50.368]                 }
[13:20:50.368]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.368]                 "immediateCondition"))) {
[13:20:50.368]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.368]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.368]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.368]                   if (TRUE && !signal) {
[13:20:50.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.368]                     {
[13:20:50.368]                       inherits <- base::inherits
[13:20:50.368]                       invokeRestart <- base::invokeRestart
[13:20:50.368]                       is.null <- base::is.null
[13:20:50.368]                       muffled <- FALSE
[13:20:50.368]                       if (inherits(cond, "message")) {
[13:20:50.368]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.368]                         if (muffled) 
[13:20:50.368]                           invokeRestart("muffleMessage")
[13:20:50.368]                       }
[13:20:50.368]                       else if (inherits(cond, "warning")) {
[13:20:50.368]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.368]                         if (muffled) 
[13:20:50.368]                           invokeRestart("muffleWarning")
[13:20:50.368]                       }
[13:20:50.368]                       else if (inherits(cond, "condition")) {
[13:20:50.368]                         if (!is.null(pattern)) {
[13:20:50.368]                           computeRestarts <- base::computeRestarts
[13:20:50.368]                           grepl <- base::grepl
[13:20:50.368]                           restarts <- computeRestarts(cond)
[13:20:50.368]                           for (restart in restarts) {
[13:20:50.368]                             name <- restart$name
[13:20:50.368]                             if (is.null(name)) 
[13:20:50.368]                               next
[13:20:50.368]                             if (!grepl(pattern, name)) 
[13:20:50.368]                               next
[13:20:50.368]                             invokeRestart(restart)
[13:20:50.368]                             muffled <- TRUE
[13:20:50.368]                             break
[13:20:50.368]                           }
[13:20:50.368]                         }
[13:20:50.368]                       }
[13:20:50.368]                       invisible(muffled)
[13:20:50.368]                     }
[13:20:50.368]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.368]                   }
[13:20:50.368]                 }
[13:20:50.368]                 else {
[13:20:50.368]                   if (TRUE) {
[13:20:50.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.368]                     {
[13:20:50.368]                       inherits <- base::inherits
[13:20:50.368]                       invokeRestart <- base::invokeRestart
[13:20:50.368]                       is.null <- base::is.null
[13:20:50.368]                       muffled <- FALSE
[13:20:50.368]                       if (inherits(cond, "message")) {
[13:20:50.368]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.368]                         if (muffled) 
[13:20:50.368]                           invokeRestart("muffleMessage")
[13:20:50.368]                       }
[13:20:50.368]                       else if (inherits(cond, "warning")) {
[13:20:50.368]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.368]                         if (muffled) 
[13:20:50.368]                           invokeRestart("muffleWarning")
[13:20:50.368]                       }
[13:20:50.368]                       else if (inherits(cond, "condition")) {
[13:20:50.368]                         if (!is.null(pattern)) {
[13:20:50.368]                           computeRestarts <- base::computeRestarts
[13:20:50.368]                           grepl <- base::grepl
[13:20:50.368]                           restarts <- computeRestarts(cond)
[13:20:50.368]                           for (restart in restarts) {
[13:20:50.368]                             name <- restart$name
[13:20:50.368]                             if (is.null(name)) 
[13:20:50.368]                               next
[13:20:50.368]                             if (!grepl(pattern, name)) 
[13:20:50.368]                               next
[13:20:50.368]                             invokeRestart(restart)
[13:20:50.368]                             muffled <- TRUE
[13:20:50.368]                             break
[13:20:50.368]                           }
[13:20:50.368]                         }
[13:20:50.368]                       }
[13:20:50.368]                       invisible(muffled)
[13:20:50.368]                     }
[13:20:50.368]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.368]                   }
[13:20:50.368]                 }
[13:20:50.368]             }
[13:20:50.368]         }))
[13:20:50.368]     }, error = function(ex) {
[13:20:50.368]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.368]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.368]                 ...future.rng), started = ...future.startTime, 
[13:20:50.368]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.368]             version = "1.8"), class = "FutureResult")
[13:20:50.368]     }, finally = {
[13:20:50.368]         if (!identical(...future.workdir, getwd())) 
[13:20:50.368]             setwd(...future.workdir)
[13:20:50.368]         {
[13:20:50.368]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.368]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.368]             }
[13:20:50.368]             base::options(...future.oldOptions)
[13:20:50.368]             if (.Platform$OS.type == "windows") {
[13:20:50.368]                 old_names <- names(...future.oldEnvVars)
[13:20:50.368]                 envs <- base::Sys.getenv()
[13:20:50.368]                 names <- names(envs)
[13:20:50.368]                 common <- intersect(names, old_names)
[13:20:50.368]                 added <- setdiff(names, old_names)
[13:20:50.368]                 removed <- setdiff(old_names, names)
[13:20:50.368]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.368]                   envs[common]]
[13:20:50.368]                 NAMES <- toupper(changed)
[13:20:50.368]                 args <- list()
[13:20:50.368]                 for (kk in seq_along(NAMES)) {
[13:20:50.368]                   name <- changed[[kk]]
[13:20:50.368]                   NAME <- NAMES[[kk]]
[13:20:50.368]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.368]                     next
[13:20:50.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.368]                 }
[13:20:50.368]                 NAMES <- toupper(added)
[13:20:50.368]                 for (kk in seq_along(NAMES)) {
[13:20:50.368]                   name <- added[[kk]]
[13:20:50.368]                   NAME <- NAMES[[kk]]
[13:20:50.368]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.368]                     next
[13:20:50.368]                   args[[name]] <- ""
[13:20:50.368]                 }
[13:20:50.368]                 NAMES <- toupper(removed)
[13:20:50.368]                 for (kk in seq_along(NAMES)) {
[13:20:50.368]                   name <- removed[[kk]]
[13:20:50.368]                   NAME <- NAMES[[kk]]
[13:20:50.368]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.368]                     next
[13:20:50.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.368]                 }
[13:20:50.368]                 if (length(args) > 0) 
[13:20:50.368]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.368]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.368]             }
[13:20:50.368]             else {
[13:20:50.368]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.368]             }
[13:20:50.368]             {
[13:20:50.368]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.368]                   0L) {
[13:20:50.368]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.368]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.368]                   base::options(opts)
[13:20:50.368]                 }
[13:20:50.368]                 {
[13:20:50.368]                   {
[13:20:50.368]                     NULL
[13:20:50.368]                     RNGkind("Mersenne-Twister")
[13:20:50.368]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.368]                       inherits = FALSE)
[13:20:50.368]                   }
[13:20:50.368]                   options(future.plan = NULL)
[13:20:50.368]                   if (is.na(NA_character_)) 
[13:20:50.368]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.368]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.368]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.368]                   {
[13:20:50.368]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.368]                     if (!future$lazy) 
[13:20:50.368]                       future <- run(future)
[13:20:50.368]                     invisible(future)
[13:20:50.368]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.368]                 }
[13:20:50.368]             }
[13:20:50.368]         }
[13:20:50.368]     })
[13:20:50.368]     if (TRUE) {
[13:20:50.368]         base::sink(type = "output", split = FALSE)
[13:20:50.368]         if (TRUE) {
[13:20:50.368]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.368]         }
[13:20:50.368]         else {
[13:20:50.368]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.368]         }
[13:20:50.368]         base::close(...future.stdout)
[13:20:50.368]         ...future.stdout <- NULL
[13:20:50.368]     }
[13:20:50.368]     ...future.result$conditions <- ...future.conditions
[13:20:50.368]     ...future.result$finished <- base::Sys.time()
[13:20:50.368]     ...future.result
[13:20:50.368] }
[13:20:50.370] assign_globals() ...
[13:20:50.370] List of 1
[13:20:50.370]  $ a: num 3
[13:20:50.370]  - attr(*, "where")=List of 1
[13:20:50.370]   ..$ a:<environment: R_EmptyEnv> 
[13:20:50.370]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.370]  - attr(*, "resolved")= logi TRUE
[13:20:50.370]  - attr(*, "total_size")= num 56
[13:20:50.370]  - attr(*, "already-done")= logi TRUE
[13:20:50.373] - copied ‘a’ to environment
[13:20:50.373] assign_globals() ... done
[13:20:50.373] plan(): Setting new future strategy stack:
[13:20:50.373] List of future strategies:
[13:20:50.373] 1. sequential:
[13:20:50.373]    - args: function (..., envir = parent.frame())
[13:20:50.373]    - tweaked: FALSE
[13:20:50.373]    - call: NULL
[13:20:50.373] plan(): nbrOfWorkers() = 1
[13:20:50.374] plan(): Setting new future strategy stack:
[13:20:50.374] List of future strategies:
[13:20:50.374] 1. sequential:
[13:20:50.374]    - args: function (..., envir = parent.frame())
[13:20:50.374]    - tweaked: FALSE
[13:20:50.374]    - call: plan(strategy)
[13:20:50.375] plan(): nbrOfWorkers() = 1
[13:20:50.375] SequentialFuture started (and completed)
[13:20:50.375] - Launch lazy future ... done
[13:20:50.375] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.376] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.376] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:50.377] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:20:50.378] Searching for globals ... DONE
[13:20:50.378] Resolving globals: TRUE
[13:20:50.378] Resolving any globals that are futures ...
[13:20:50.378] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:20:50.378] Resolving any globals that are futures ... DONE
[13:20:50.378] Resolving futures part of globals (recursively) ...
[13:20:50.379] resolve() on list ...
[13:20:50.379]  recursive: 99
[13:20:50.379]  length: 1
[13:20:50.379]  elements: ‘a’
[13:20:50.379]  length: 0 (resolved future 1)
[13:20:50.379] resolve() on list ... DONE
[13:20:50.379] - globals: [1] ‘a’
[13:20:50.379] Resolving futures part of globals (recursively) ... DONE
[13:20:50.379] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:50.380] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:20:50.380] - globals: [1] ‘a’
[13:20:50.380] 
[13:20:50.380] getGlobalsAndPackages() ... DONE
[13:20:50.380] run() for ‘Future’ ...
[13:20:50.380] - state: ‘created’
[13:20:50.381] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.381] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.381] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.381]   - Field: ‘label’
[13:20:50.381]   - Field: ‘local’
[13:20:50.381]   - Field: ‘owner’
[13:20:50.381]   - Field: ‘envir’
[13:20:50.381]   - Field: ‘packages’
[13:20:50.382]   - Field: ‘gc’
[13:20:50.382]   - Field: ‘conditions’
[13:20:50.382]   - Field: ‘expr’
[13:20:50.382]   - Field: ‘uuid’
[13:20:50.382]   - Field: ‘seed’
[13:20:50.382]   - Field: ‘version’
[13:20:50.382]   - Field: ‘result’
[13:20:50.382]   - Field: ‘asynchronous’
[13:20:50.382]   - Field: ‘calls’
[13:20:50.382]   - Field: ‘globals’
[13:20:50.382]   - Field: ‘stdout’
[13:20:50.383]   - Field: ‘earlySignal’
[13:20:50.383]   - Field: ‘lazy’
[13:20:50.383]   - Field: ‘state’
[13:20:50.383] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.383] - Launch lazy future ...
[13:20:50.383] Packages needed by the future expression (n = 0): <none>
[13:20:50.383] Packages needed by future strategies (n = 0): <none>
[13:20:50.384] {
[13:20:50.384]     {
[13:20:50.384]         {
[13:20:50.384]             ...future.startTime <- base::Sys.time()
[13:20:50.384]             {
[13:20:50.384]                 {
[13:20:50.384]                   {
[13:20:50.384]                     base::local({
[13:20:50.384]                       has_future <- base::requireNamespace("future", 
[13:20:50.384]                         quietly = TRUE)
[13:20:50.384]                       if (has_future) {
[13:20:50.384]                         ns <- base::getNamespace("future")
[13:20:50.384]                         version <- ns[[".package"]][["version"]]
[13:20:50.384]                         if (is.null(version)) 
[13:20:50.384]                           version <- utils::packageVersion("future")
[13:20:50.384]                       }
[13:20:50.384]                       else {
[13:20:50.384]                         version <- NULL
[13:20:50.384]                       }
[13:20:50.384]                       if (!has_future || version < "1.8.0") {
[13:20:50.384]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.384]                           "", base::R.version$version.string), 
[13:20:50.384]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.384]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.384]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.384]                             "release", "version")], collapse = " "), 
[13:20:50.384]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.384]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.384]                           info)
[13:20:50.384]                         info <- base::paste(info, collapse = "; ")
[13:20:50.384]                         if (!has_future) {
[13:20:50.384]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.384]                             info)
[13:20:50.384]                         }
[13:20:50.384]                         else {
[13:20:50.384]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.384]                             info, version)
[13:20:50.384]                         }
[13:20:50.384]                         base::stop(msg)
[13:20:50.384]                       }
[13:20:50.384]                     })
[13:20:50.384]                   }
[13:20:50.384]                   options(future.plan = NULL)
[13:20:50.384]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.384]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.384]                 }
[13:20:50.384]                 ...future.workdir <- getwd()
[13:20:50.384]             }
[13:20:50.384]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.384]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.384]         }
[13:20:50.384]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.384]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:50.384]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.384]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.384]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.384]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.384]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.384]             base::names(...future.oldOptions))
[13:20:50.384]     }
[13:20:50.384]     if (FALSE) {
[13:20:50.384]     }
[13:20:50.384]     else {
[13:20:50.384]         if (TRUE) {
[13:20:50.384]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.384]                 open = "w")
[13:20:50.384]         }
[13:20:50.384]         else {
[13:20:50.384]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.384]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.384]         }
[13:20:50.384]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.384]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.384]             base::sink(type = "output", split = FALSE)
[13:20:50.384]             base::close(...future.stdout)
[13:20:50.384]         }, add = TRUE)
[13:20:50.384]     }
[13:20:50.384]     ...future.frame <- base::sys.nframe()
[13:20:50.384]     ...future.conditions <- base::list()
[13:20:50.384]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.384]     if (FALSE) {
[13:20:50.384]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.384]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.384]     }
[13:20:50.384]     ...future.result <- base::tryCatch({
[13:20:50.384]         base::withCallingHandlers({
[13:20:50.384]             ...future.value <- base::withVisible(base::local({
[13:20:50.384]                 b <- a
[13:20:50.384]                 a <- 2
[13:20:50.384]                 a * b
[13:20:50.384]             }))
[13:20:50.384]             future::FutureResult(value = ...future.value$value, 
[13:20:50.384]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.384]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.384]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.384]                     ...future.globalenv.names))
[13:20:50.384]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.384]         }, condition = base::local({
[13:20:50.384]             c <- base::c
[13:20:50.384]             inherits <- base::inherits
[13:20:50.384]             invokeRestart <- base::invokeRestart
[13:20:50.384]             length <- base::length
[13:20:50.384]             list <- base::list
[13:20:50.384]             seq.int <- base::seq.int
[13:20:50.384]             signalCondition <- base::signalCondition
[13:20:50.384]             sys.calls <- base::sys.calls
[13:20:50.384]             `[[` <- base::`[[`
[13:20:50.384]             `+` <- base::`+`
[13:20:50.384]             `<<-` <- base::`<<-`
[13:20:50.384]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.384]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.384]                   3L)]
[13:20:50.384]             }
[13:20:50.384]             function(cond) {
[13:20:50.384]                 is_error <- inherits(cond, "error")
[13:20:50.384]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.384]                   NULL)
[13:20:50.384]                 if (is_error) {
[13:20:50.384]                   sessionInformation <- function() {
[13:20:50.384]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.384]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.384]                       search = base::search(), system = base::Sys.info())
[13:20:50.384]                   }
[13:20:50.384]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.384]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.384]                     cond$call), session = sessionInformation(), 
[13:20:50.384]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.384]                   signalCondition(cond)
[13:20:50.384]                 }
[13:20:50.384]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.384]                 "immediateCondition"))) {
[13:20:50.384]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.384]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.384]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.384]                   if (TRUE && !signal) {
[13:20:50.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.384]                     {
[13:20:50.384]                       inherits <- base::inherits
[13:20:50.384]                       invokeRestart <- base::invokeRestart
[13:20:50.384]                       is.null <- base::is.null
[13:20:50.384]                       muffled <- FALSE
[13:20:50.384]                       if (inherits(cond, "message")) {
[13:20:50.384]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.384]                         if (muffled) 
[13:20:50.384]                           invokeRestart("muffleMessage")
[13:20:50.384]                       }
[13:20:50.384]                       else if (inherits(cond, "warning")) {
[13:20:50.384]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.384]                         if (muffled) 
[13:20:50.384]                           invokeRestart("muffleWarning")
[13:20:50.384]                       }
[13:20:50.384]                       else if (inherits(cond, "condition")) {
[13:20:50.384]                         if (!is.null(pattern)) {
[13:20:50.384]                           computeRestarts <- base::computeRestarts
[13:20:50.384]                           grepl <- base::grepl
[13:20:50.384]                           restarts <- computeRestarts(cond)
[13:20:50.384]                           for (restart in restarts) {
[13:20:50.384]                             name <- restart$name
[13:20:50.384]                             if (is.null(name)) 
[13:20:50.384]                               next
[13:20:50.384]                             if (!grepl(pattern, name)) 
[13:20:50.384]                               next
[13:20:50.384]                             invokeRestart(restart)
[13:20:50.384]                             muffled <- TRUE
[13:20:50.384]                             break
[13:20:50.384]                           }
[13:20:50.384]                         }
[13:20:50.384]                       }
[13:20:50.384]                       invisible(muffled)
[13:20:50.384]                     }
[13:20:50.384]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.384]                   }
[13:20:50.384]                 }
[13:20:50.384]                 else {
[13:20:50.384]                   if (TRUE) {
[13:20:50.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.384]                     {
[13:20:50.384]                       inherits <- base::inherits
[13:20:50.384]                       invokeRestart <- base::invokeRestart
[13:20:50.384]                       is.null <- base::is.null
[13:20:50.384]                       muffled <- FALSE
[13:20:50.384]                       if (inherits(cond, "message")) {
[13:20:50.384]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.384]                         if (muffled) 
[13:20:50.384]                           invokeRestart("muffleMessage")
[13:20:50.384]                       }
[13:20:50.384]                       else if (inherits(cond, "warning")) {
[13:20:50.384]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.384]                         if (muffled) 
[13:20:50.384]                           invokeRestart("muffleWarning")
[13:20:50.384]                       }
[13:20:50.384]                       else if (inherits(cond, "condition")) {
[13:20:50.384]                         if (!is.null(pattern)) {
[13:20:50.384]                           computeRestarts <- base::computeRestarts
[13:20:50.384]                           grepl <- base::grepl
[13:20:50.384]                           restarts <- computeRestarts(cond)
[13:20:50.384]                           for (restart in restarts) {
[13:20:50.384]                             name <- restart$name
[13:20:50.384]                             if (is.null(name)) 
[13:20:50.384]                               next
[13:20:50.384]                             if (!grepl(pattern, name)) 
[13:20:50.384]                               next
[13:20:50.384]                             invokeRestart(restart)
[13:20:50.384]                             muffled <- TRUE
[13:20:50.384]                             break
[13:20:50.384]                           }
[13:20:50.384]                         }
[13:20:50.384]                       }
[13:20:50.384]                       invisible(muffled)
[13:20:50.384]                     }
[13:20:50.384]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.384]                   }
[13:20:50.384]                 }
[13:20:50.384]             }
[13:20:50.384]         }))
[13:20:50.384]     }, error = function(ex) {
[13:20:50.384]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.384]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.384]                 ...future.rng), started = ...future.startTime, 
[13:20:50.384]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.384]             version = "1.8"), class = "FutureResult")
[13:20:50.384]     }, finally = {
[13:20:50.384]         if (!identical(...future.workdir, getwd())) 
[13:20:50.384]             setwd(...future.workdir)
[13:20:50.384]         {
[13:20:50.384]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.384]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.384]             }
[13:20:50.384]             base::options(...future.oldOptions)
[13:20:50.384]             if (.Platform$OS.type == "windows") {
[13:20:50.384]                 old_names <- names(...future.oldEnvVars)
[13:20:50.384]                 envs <- base::Sys.getenv()
[13:20:50.384]                 names <- names(envs)
[13:20:50.384]                 common <- intersect(names, old_names)
[13:20:50.384]                 added <- setdiff(names, old_names)
[13:20:50.384]                 removed <- setdiff(old_names, names)
[13:20:50.384]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.384]                   envs[common]]
[13:20:50.384]                 NAMES <- toupper(changed)
[13:20:50.384]                 args <- list()
[13:20:50.384]                 for (kk in seq_along(NAMES)) {
[13:20:50.384]                   name <- changed[[kk]]
[13:20:50.384]                   NAME <- NAMES[[kk]]
[13:20:50.384]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.384]                     next
[13:20:50.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.384]                 }
[13:20:50.384]                 NAMES <- toupper(added)
[13:20:50.384]                 for (kk in seq_along(NAMES)) {
[13:20:50.384]                   name <- added[[kk]]
[13:20:50.384]                   NAME <- NAMES[[kk]]
[13:20:50.384]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.384]                     next
[13:20:50.384]                   args[[name]] <- ""
[13:20:50.384]                 }
[13:20:50.384]                 NAMES <- toupper(removed)
[13:20:50.384]                 for (kk in seq_along(NAMES)) {
[13:20:50.384]                   name <- removed[[kk]]
[13:20:50.384]                   NAME <- NAMES[[kk]]
[13:20:50.384]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.384]                     next
[13:20:50.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.384]                 }
[13:20:50.384]                 if (length(args) > 0) 
[13:20:50.384]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.384]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.384]             }
[13:20:50.384]             else {
[13:20:50.384]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.384]             }
[13:20:50.384]             {
[13:20:50.384]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.384]                   0L) {
[13:20:50.384]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.384]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.384]                   base::options(opts)
[13:20:50.384]                 }
[13:20:50.384]                 {
[13:20:50.384]                   {
[13:20:50.384]                     NULL
[13:20:50.384]                     RNGkind("Mersenne-Twister")
[13:20:50.384]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.384]                       inherits = FALSE)
[13:20:50.384]                   }
[13:20:50.384]                   options(future.plan = NULL)
[13:20:50.384]                   if (is.na(NA_character_)) 
[13:20:50.384]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.384]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.384]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.384]                   {
[13:20:50.384]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.384]                     if (!future$lazy) 
[13:20:50.384]                       future <- run(future)
[13:20:50.384]                     invisible(future)
[13:20:50.384]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.384]                 }
[13:20:50.384]             }
[13:20:50.384]         }
[13:20:50.384]     })
[13:20:50.384]     if (TRUE) {
[13:20:50.384]         base::sink(type = "output", split = FALSE)
[13:20:50.384]         if (TRUE) {
[13:20:50.384]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.384]         }
[13:20:50.384]         else {
[13:20:50.384]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.384]         }
[13:20:50.384]         base::close(...future.stdout)
[13:20:50.384]         ...future.stdout <- NULL
[13:20:50.384]     }
[13:20:50.384]     ...future.result$conditions <- ...future.conditions
[13:20:50.384]     ...future.result$finished <- base::Sys.time()
[13:20:50.384]     ...future.result
[13:20:50.384] }
[13:20:50.385] assign_globals() ...
[13:20:50.385] List of 1
[13:20:50.385]  $ a: num 3
[13:20:50.385]  - attr(*, "where")=List of 1
[13:20:50.385]   ..$ a:<environment: R_EmptyEnv> 
[13:20:50.385]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.385]  - attr(*, "resolved")= logi TRUE
[13:20:50.385]  - attr(*, "total_size")= num 56
[13:20:50.385]  - attr(*, "already-done")= logi TRUE
[13:20:50.388] - copied ‘a’ to environment
[13:20:50.388] assign_globals() ... done
[13:20:50.388] plan(): Setting new future strategy stack:
[13:20:50.388] List of future strategies:
[13:20:50.388] 1. sequential:
[13:20:50.388]    - args: function (..., envir = parent.frame())
[13:20:50.388]    - tweaked: FALSE
[13:20:50.388]    - call: NULL
[13:20:50.389] plan(): nbrOfWorkers() = 1
[13:20:50.389] plan(): Setting new future strategy stack:
[13:20:50.389] List of future strategies:
[13:20:50.389] 1. sequential:
[13:20:50.389]    - args: function (..., envir = parent.frame())
[13:20:50.389]    - tweaked: FALSE
[13:20:50.389]    - call: plan(strategy)
[13:20:50.390] plan(): nbrOfWorkers() = 1
[13:20:50.390] SequentialFuture started (and completed)
[13:20:50.390] - Launch lazy future ... done
[13:20:50.390] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.391] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.391] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:50.394] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:50.394] Searching for globals ... DONE
[13:20:50.394] Resolving globals: TRUE
[13:20:50.394] Resolving any globals that are futures ...
[13:20:50.395] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:50.395] Resolving any globals that are futures ... DONE
[13:20:50.395] Resolving futures part of globals (recursively) ...
[13:20:50.395] resolve() on list ...
[13:20:50.395]  recursive: 99
[13:20:50.395]  length: 2
[13:20:50.395]  elements: ‘a’, ‘ii’
[13:20:50.396]  length: 1 (resolved future 1)
[13:20:50.396]  length: 0 (resolved future 2)
[13:20:50.396] resolve() on list ... DONE
[13:20:50.396] - globals: [2] ‘a’, ‘ii’
[13:20:50.396] Resolving futures part of globals (recursively) ... DONE
[13:20:50.396] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:50.397] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:20:50.397] - globals: [2] ‘a’, ‘ii’
[13:20:50.397] 
[13:20:50.397] getGlobalsAndPackages() ... DONE
[13:20:50.397] run() for ‘Future’ ...
[13:20:50.397] - state: ‘created’
[13:20:50.397] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.398] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.398] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.398]   - Field: ‘label’
[13:20:50.398]   - Field: ‘local’
[13:20:50.398]   - Field: ‘owner’
[13:20:50.398]   - Field: ‘envir’
[13:20:50.398]   - Field: ‘packages’
[13:20:50.398]   - Field: ‘gc’
[13:20:50.398]   - Field: ‘conditions’
[13:20:50.398]   - Field: ‘expr’
[13:20:50.399]   - Field: ‘uuid’
[13:20:50.399]   - Field: ‘seed’
[13:20:50.399]   - Field: ‘version’
[13:20:50.399]   - Field: ‘result’
[13:20:50.399]   - Field: ‘asynchronous’
[13:20:50.399]   - Field: ‘calls’
[13:20:50.399]   - Field: ‘globals’
[13:20:50.399]   - Field: ‘stdout’
[13:20:50.399]   - Field: ‘earlySignal’
[13:20:50.399]   - Field: ‘lazy’
[13:20:50.399]   - Field: ‘state’
[13:20:50.400] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.400] - Launch lazy future ...
[13:20:50.400] Packages needed by the future expression (n = 0): <none>
[13:20:50.400] Packages needed by future strategies (n = 0): <none>
[13:20:50.400] {
[13:20:50.400]     {
[13:20:50.400]         {
[13:20:50.400]             ...future.startTime <- base::Sys.time()
[13:20:50.400]             {
[13:20:50.400]                 {
[13:20:50.400]                   {
[13:20:50.400]                     base::local({
[13:20:50.400]                       has_future <- base::requireNamespace("future", 
[13:20:50.400]                         quietly = TRUE)
[13:20:50.400]                       if (has_future) {
[13:20:50.400]                         ns <- base::getNamespace("future")
[13:20:50.400]                         version <- ns[[".package"]][["version"]]
[13:20:50.400]                         if (is.null(version)) 
[13:20:50.400]                           version <- utils::packageVersion("future")
[13:20:50.400]                       }
[13:20:50.400]                       else {
[13:20:50.400]                         version <- NULL
[13:20:50.400]                       }
[13:20:50.400]                       if (!has_future || version < "1.8.0") {
[13:20:50.400]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.400]                           "", base::R.version$version.string), 
[13:20:50.400]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.400]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.400]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.400]                             "release", "version")], collapse = " "), 
[13:20:50.400]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.400]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.400]                           info)
[13:20:50.400]                         info <- base::paste(info, collapse = "; ")
[13:20:50.400]                         if (!has_future) {
[13:20:50.400]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.400]                             info)
[13:20:50.400]                         }
[13:20:50.400]                         else {
[13:20:50.400]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.400]                             info, version)
[13:20:50.400]                         }
[13:20:50.400]                         base::stop(msg)
[13:20:50.400]                       }
[13:20:50.400]                     })
[13:20:50.400]                   }
[13:20:50.400]                   options(future.plan = NULL)
[13:20:50.400]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.400]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.400]                 }
[13:20:50.400]                 ...future.workdir <- getwd()
[13:20:50.400]             }
[13:20:50.400]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.400]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.400]         }
[13:20:50.400]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.400]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:50.400]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.400]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.400]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.400]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.400]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.400]             base::names(...future.oldOptions))
[13:20:50.400]     }
[13:20:50.400]     if (FALSE) {
[13:20:50.400]     }
[13:20:50.400]     else {
[13:20:50.400]         if (TRUE) {
[13:20:50.400]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.400]                 open = "w")
[13:20:50.400]         }
[13:20:50.400]         else {
[13:20:50.400]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.400]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.400]         }
[13:20:50.400]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.400]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.400]             base::sink(type = "output", split = FALSE)
[13:20:50.400]             base::close(...future.stdout)
[13:20:50.400]         }, add = TRUE)
[13:20:50.400]     }
[13:20:50.400]     ...future.frame <- base::sys.nframe()
[13:20:50.400]     ...future.conditions <- base::list()
[13:20:50.400]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.400]     if (FALSE) {
[13:20:50.400]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.400]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.400]     }
[13:20:50.400]     ...future.result <- base::tryCatch({
[13:20:50.400]         base::withCallingHandlers({
[13:20:50.400]             ...future.value <- base::withVisible(base::local({
[13:20:50.400]                 b <- a * ii
[13:20:50.400]                 a <- 0
[13:20:50.400]                 b
[13:20:50.400]             }))
[13:20:50.400]             future::FutureResult(value = ...future.value$value, 
[13:20:50.400]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.400]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.400]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.400]                     ...future.globalenv.names))
[13:20:50.400]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.400]         }, condition = base::local({
[13:20:50.400]             c <- base::c
[13:20:50.400]             inherits <- base::inherits
[13:20:50.400]             invokeRestart <- base::invokeRestart
[13:20:50.400]             length <- base::length
[13:20:50.400]             list <- base::list
[13:20:50.400]             seq.int <- base::seq.int
[13:20:50.400]             signalCondition <- base::signalCondition
[13:20:50.400]             sys.calls <- base::sys.calls
[13:20:50.400]             `[[` <- base::`[[`
[13:20:50.400]             `+` <- base::`+`
[13:20:50.400]             `<<-` <- base::`<<-`
[13:20:50.400]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.400]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.400]                   3L)]
[13:20:50.400]             }
[13:20:50.400]             function(cond) {
[13:20:50.400]                 is_error <- inherits(cond, "error")
[13:20:50.400]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.400]                   NULL)
[13:20:50.400]                 if (is_error) {
[13:20:50.400]                   sessionInformation <- function() {
[13:20:50.400]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.400]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.400]                       search = base::search(), system = base::Sys.info())
[13:20:50.400]                   }
[13:20:50.400]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.400]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.400]                     cond$call), session = sessionInformation(), 
[13:20:50.400]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.400]                   signalCondition(cond)
[13:20:50.400]                 }
[13:20:50.400]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.400]                 "immediateCondition"))) {
[13:20:50.400]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.400]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.400]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.400]                   if (TRUE && !signal) {
[13:20:50.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.400]                     {
[13:20:50.400]                       inherits <- base::inherits
[13:20:50.400]                       invokeRestart <- base::invokeRestart
[13:20:50.400]                       is.null <- base::is.null
[13:20:50.400]                       muffled <- FALSE
[13:20:50.400]                       if (inherits(cond, "message")) {
[13:20:50.400]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.400]                         if (muffled) 
[13:20:50.400]                           invokeRestart("muffleMessage")
[13:20:50.400]                       }
[13:20:50.400]                       else if (inherits(cond, "warning")) {
[13:20:50.400]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.400]                         if (muffled) 
[13:20:50.400]                           invokeRestart("muffleWarning")
[13:20:50.400]                       }
[13:20:50.400]                       else if (inherits(cond, "condition")) {
[13:20:50.400]                         if (!is.null(pattern)) {
[13:20:50.400]                           computeRestarts <- base::computeRestarts
[13:20:50.400]                           grepl <- base::grepl
[13:20:50.400]                           restarts <- computeRestarts(cond)
[13:20:50.400]                           for (restart in restarts) {
[13:20:50.400]                             name <- restart$name
[13:20:50.400]                             if (is.null(name)) 
[13:20:50.400]                               next
[13:20:50.400]                             if (!grepl(pattern, name)) 
[13:20:50.400]                               next
[13:20:50.400]                             invokeRestart(restart)
[13:20:50.400]                             muffled <- TRUE
[13:20:50.400]                             break
[13:20:50.400]                           }
[13:20:50.400]                         }
[13:20:50.400]                       }
[13:20:50.400]                       invisible(muffled)
[13:20:50.400]                     }
[13:20:50.400]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.400]                   }
[13:20:50.400]                 }
[13:20:50.400]                 else {
[13:20:50.400]                   if (TRUE) {
[13:20:50.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.400]                     {
[13:20:50.400]                       inherits <- base::inherits
[13:20:50.400]                       invokeRestart <- base::invokeRestart
[13:20:50.400]                       is.null <- base::is.null
[13:20:50.400]                       muffled <- FALSE
[13:20:50.400]                       if (inherits(cond, "message")) {
[13:20:50.400]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.400]                         if (muffled) 
[13:20:50.400]                           invokeRestart("muffleMessage")
[13:20:50.400]                       }
[13:20:50.400]                       else if (inherits(cond, "warning")) {
[13:20:50.400]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.400]                         if (muffled) 
[13:20:50.400]                           invokeRestart("muffleWarning")
[13:20:50.400]                       }
[13:20:50.400]                       else if (inherits(cond, "condition")) {
[13:20:50.400]                         if (!is.null(pattern)) {
[13:20:50.400]                           computeRestarts <- base::computeRestarts
[13:20:50.400]                           grepl <- base::grepl
[13:20:50.400]                           restarts <- computeRestarts(cond)
[13:20:50.400]                           for (restart in restarts) {
[13:20:50.400]                             name <- restart$name
[13:20:50.400]                             if (is.null(name)) 
[13:20:50.400]                               next
[13:20:50.400]                             if (!grepl(pattern, name)) 
[13:20:50.400]                               next
[13:20:50.400]                             invokeRestart(restart)
[13:20:50.400]                             muffled <- TRUE
[13:20:50.400]                             break
[13:20:50.400]                           }
[13:20:50.400]                         }
[13:20:50.400]                       }
[13:20:50.400]                       invisible(muffled)
[13:20:50.400]                     }
[13:20:50.400]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.400]                   }
[13:20:50.400]                 }
[13:20:50.400]             }
[13:20:50.400]         }))
[13:20:50.400]     }, error = function(ex) {
[13:20:50.400]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.400]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.400]                 ...future.rng), started = ...future.startTime, 
[13:20:50.400]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.400]             version = "1.8"), class = "FutureResult")
[13:20:50.400]     }, finally = {
[13:20:50.400]         if (!identical(...future.workdir, getwd())) 
[13:20:50.400]             setwd(...future.workdir)
[13:20:50.400]         {
[13:20:50.400]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.400]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.400]             }
[13:20:50.400]             base::options(...future.oldOptions)
[13:20:50.400]             if (.Platform$OS.type == "windows") {
[13:20:50.400]                 old_names <- names(...future.oldEnvVars)
[13:20:50.400]                 envs <- base::Sys.getenv()
[13:20:50.400]                 names <- names(envs)
[13:20:50.400]                 common <- intersect(names, old_names)
[13:20:50.400]                 added <- setdiff(names, old_names)
[13:20:50.400]                 removed <- setdiff(old_names, names)
[13:20:50.400]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.400]                   envs[common]]
[13:20:50.400]                 NAMES <- toupper(changed)
[13:20:50.400]                 args <- list()
[13:20:50.400]                 for (kk in seq_along(NAMES)) {
[13:20:50.400]                   name <- changed[[kk]]
[13:20:50.400]                   NAME <- NAMES[[kk]]
[13:20:50.400]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.400]                     next
[13:20:50.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.400]                 }
[13:20:50.400]                 NAMES <- toupper(added)
[13:20:50.400]                 for (kk in seq_along(NAMES)) {
[13:20:50.400]                   name <- added[[kk]]
[13:20:50.400]                   NAME <- NAMES[[kk]]
[13:20:50.400]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.400]                     next
[13:20:50.400]                   args[[name]] <- ""
[13:20:50.400]                 }
[13:20:50.400]                 NAMES <- toupper(removed)
[13:20:50.400]                 for (kk in seq_along(NAMES)) {
[13:20:50.400]                   name <- removed[[kk]]
[13:20:50.400]                   NAME <- NAMES[[kk]]
[13:20:50.400]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.400]                     next
[13:20:50.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.400]                 }
[13:20:50.400]                 if (length(args) > 0) 
[13:20:50.400]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.400]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.400]             }
[13:20:50.400]             else {
[13:20:50.400]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.400]             }
[13:20:50.400]             {
[13:20:50.400]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.400]                   0L) {
[13:20:50.400]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.400]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.400]                   base::options(opts)
[13:20:50.400]                 }
[13:20:50.400]                 {
[13:20:50.400]                   {
[13:20:50.400]                     NULL
[13:20:50.400]                     RNGkind("Mersenne-Twister")
[13:20:50.400]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.400]                       inherits = FALSE)
[13:20:50.400]                   }
[13:20:50.400]                   options(future.plan = NULL)
[13:20:50.400]                   if (is.na(NA_character_)) 
[13:20:50.400]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.400]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.400]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.400]                   {
[13:20:50.400]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.400]                     if (!future$lazy) 
[13:20:50.400]                       future <- run(future)
[13:20:50.400]                     invisible(future)
[13:20:50.400]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.400]                 }
[13:20:50.400]             }
[13:20:50.400]         }
[13:20:50.400]     })
[13:20:50.400]     if (TRUE) {
[13:20:50.400]         base::sink(type = "output", split = FALSE)
[13:20:50.400]         if (TRUE) {
[13:20:50.400]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.400]         }
[13:20:50.400]         else {
[13:20:50.400]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.400]         }
[13:20:50.400]         base::close(...future.stdout)
[13:20:50.400]         ...future.stdout <- NULL
[13:20:50.400]     }
[13:20:50.400]     ...future.result$conditions <- ...future.conditions
[13:20:50.400]     ...future.result$finished <- base::Sys.time()
[13:20:50.400]     ...future.result
[13:20:50.400] }
[13:20:50.402] assign_globals() ...
[13:20:50.402] List of 2
[13:20:50.402]  $ a : num 1
[13:20:50.402]  $ ii: int 1
[13:20:50.402]  - attr(*, "where")=List of 2
[13:20:50.402]   ..$ a :<environment: R_EmptyEnv> 
[13:20:50.402]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:50.402]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.402]  - attr(*, "resolved")= logi TRUE
[13:20:50.402]  - attr(*, "total_size")= num 112
[13:20:50.402]  - attr(*, "already-done")= logi TRUE
[13:20:50.405] - copied ‘a’ to environment
[13:20:50.405] - copied ‘ii’ to environment
[13:20:50.405] assign_globals() ... done
[13:20:50.405] plan(): Setting new future strategy stack:
[13:20:50.405] List of future strategies:
[13:20:50.405] 1. sequential:
[13:20:50.405]    - args: function (..., envir = parent.frame())
[13:20:50.405]    - tweaked: FALSE
[13:20:50.405]    - call: NULL
[13:20:50.406] plan(): nbrOfWorkers() = 1
[13:20:50.407] plan(): Setting new future strategy stack:
[13:20:50.407] List of future strategies:
[13:20:50.407] 1. sequential:
[13:20:50.407]    - args: function (..., envir = parent.frame())
[13:20:50.407]    - tweaked: FALSE
[13:20:50.407]    - call: plan(strategy)
[13:20:50.407] plan(): nbrOfWorkers() = 1
[13:20:50.407] SequentialFuture started (and completed)
[13:20:50.407] - Launch lazy future ... done
[13:20:50.407] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.408] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.408] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:50.410] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:50.410] Searching for globals ... DONE
[13:20:50.410] Resolving globals: TRUE
[13:20:50.410] Resolving any globals that are futures ...
[13:20:50.410] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:50.410] Resolving any globals that are futures ... DONE
[13:20:50.411] Resolving futures part of globals (recursively) ...
[13:20:50.411] resolve() on list ...
[13:20:50.411]  recursive: 99
[13:20:50.411]  length: 2
[13:20:50.411]  elements: ‘a’, ‘ii’
[13:20:50.411]  length: 1 (resolved future 1)
[13:20:50.411]  length: 0 (resolved future 2)
[13:20:50.411] resolve() on list ... DONE
[13:20:50.411] - globals: [2] ‘a’, ‘ii’
[13:20:50.412] Resolving futures part of globals (recursively) ... DONE
[13:20:50.412] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:50.412] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:20:50.412] - globals: [2] ‘a’, ‘ii’
[13:20:50.412] 
[13:20:50.412] getGlobalsAndPackages() ... DONE
[13:20:50.413] run() for ‘Future’ ...
[13:20:50.413] - state: ‘created’
[13:20:50.413] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.413] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.413] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.413]   - Field: ‘label’
[13:20:50.413]   - Field: ‘local’
[13:20:50.414]   - Field: ‘owner’
[13:20:50.414]   - Field: ‘envir’
[13:20:50.414]   - Field: ‘packages’
[13:20:50.414]   - Field: ‘gc’
[13:20:50.414]   - Field: ‘conditions’
[13:20:50.414]   - Field: ‘expr’
[13:20:50.414]   - Field: ‘uuid’
[13:20:50.414]   - Field: ‘seed’
[13:20:50.414]   - Field: ‘version’
[13:20:50.414]   - Field: ‘result’
[13:20:50.414]   - Field: ‘asynchronous’
[13:20:50.415]   - Field: ‘calls’
[13:20:50.415]   - Field: ‘globals’
[13:20:50.415]   - Field: ‘stdout’
[13:20:50.415]   - Field: ‘earlySignal’
[13:20:50.415]   - Field: ‘lazy’
[13:20:50.415]   - Field: ‘state’
[13:20:50.415] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.415] - Launch lazy future ...
[13:20:50.415] Packages needed by the future expression (n = 0): <none>
[13:20:50.415] Packages needed by future strategies (n = 0): <none>
[13:20:50.416] {
[13:20:50.416]     {
[13:20:50.416]         {
[13:20:50.416]             ...future.startTime <- base::Sys.time()
[13:20:50.416]             {
[13:20:50.416]                 {
[13:20:50.416]                   {
[13:20:50.416]                     base::local({
[13:20:50.416]                       has_future <- base::requireNamespace("future", 
[13:20:50.416]                         quietly = TRUE)
[13:20:50.416]                       if (has_future) {
[13:20:50.416]                         ns <- base::getNamespace("future")
[13:20:50.416]                         version <- ns[[".package"]][["version"]]
[13:20:50.416]                         if (is.null(version)) 
[13:20:50.416]                           version <- utils::packageVersion("future")
[13:20:50.416]                       }
[13:20:50.416]                       else {
[13:20:50.416]                         version <- NULL
[13:20:50.416]                       }
[13:20:50.416]                       if (!has_future || version < "1.8.0") {
[13:20:50.416]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.416]                           "", base::R.version$version.string), 
[13:20:50.416]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.416]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.416]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.416]                             "release", "version")], collapse = " "), 
[13:20:50.416]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.416]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.416]                           info)
[13:20:50.416]                         info <- base::paste(info, collapse = "; ")
[13:20:50.416]                         if (!has_future) {
[13:20:50.416]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.416]                             info)
[13:20:50.416]                         }
[13:20:50.416]                         else {
[13:20:50.416]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.416]                             info, version)
[13:20:50.416]                         }
[13:20:50.416]                         base::stop(msg)
[13:20:50.416]                       }
[13:20:50.416]                     })
[13:20:50.416]                   }
[13:20:50.416]                   options(future.plan = NULL)
[13:20:50.416]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.416]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.416]                 }
[13:20:50.416]                 ...future.workdir <- getwd()
[13:20:50.416]             }
[13:20:50.416]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.416]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.416]         }
[13:20:50.416]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.416]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:50.416]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.416]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.416]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.416]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.416]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.416]             base::names(...future.oldOptions))
[13:20:50.416]     }
[13:20:50.416]     if (FALSE) {
[13:20:50.416]     }
[13:20:50.416]     else {
[13:20:50.416]         if (TRUE) {
[13:20:50.416]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.416]                 open = "w")
[13:20:50.416]         }
[13:20:50.416]         else {
[13:20:50.416]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.416]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.416]         }
[13:20:50.416]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.416]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.416]             base::sink(type = "output", split = FALSE)
[13:20:50.416]             base::close(...future.stdout)
[13:20:50.416]         }, add = TRUE)
[13:20:50.416]     }
[13:20:50.416]     ...future.frame <- base::sys.nframe()
[13:20:50.416]     ...future.conditions <- base::list()
[13:20:50.416]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.416]     if (FALSE) {
[13:20:50.416]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.416]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.416]     }
[13:20:50.416]     ...future.result <- base::tryCatch({
[13:20:50.416]         base::withCallingHandlers({
[13:20:50.416]             ...future.value <- base::withVisible(base::local({
[13:20:50.416]                 b <- a * ii
[13:20:50.416]                 a <- 0
[13:20:50.416]                 b
[13:20:50.416]             }))
[13:20:50.416]             future::FutureResult(value = ...future.value$value, 
[13:20:50.416]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.416]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.416]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.416]                     ...future.globalenv.names))
[13:20:50.416]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.416]         }, condition = base::local({
[13:20:50.416]             c <- base::c
[13:20:50.416]             inherits <- base::inherits
[13:20:50.416]             invokeRestart <- base::invokeRestart
[13:20:50.416]             length <- base::length
[13:20:50.416]             list <- base::list
[13:20:50.416]             seq.int <- base::seq.int
[13:20:50.416]             signalCondition <- base::signalCondition
[13:20:50.416]             sys.calls <- base::sys.calls
[13:20:50.416]             `[[` <- base::`[[`
[13:20:50.416]             `+` <- base::`+`
[13:20:50.416]             `<<-` <- base::`<<-`
[13:20:50.416]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.416]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.416]                   3L)]
[13:20:50.416]             }
[13:20:50.416]             function(cond) {
[13:20:50.416]                 is_error <- inherits(cond, "error")
[13:20:50.416]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.416]                   NULL)
[13:20:50.416]                 if (is_error) {
[13:20:50.416]                   sessionInformation <- function() {
[13:20:50.416]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.416]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.416]                       search = base::search(), system = base::Sys.info())
[13:20:50.416]                   }
[13:20:50.416]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.416]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.416]                     cond$call), session = sessionInformation(), 
[13:20:50.416]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.416]                   signalCondition(cond)
[13:20:50.416]                 }
[13:20:50.416]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.416]                 "immediateCondition"))) {
[13:20:50.416]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.416]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.416]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.416]                   if (TRUE && !signal) {
[13:20:50.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.416]                     {
[13:20:50.416]                       inherits <- base::inherits
[13:20:50.416]                       invokeRestart <- base::invokeRestart
[13:20:50.416]                       is.null <- base::is.null
[13:20:50.416]                       muffled <- FALSE
[13:20:50.416]                       if (inherits(cond, "message")) {
[13:20:50.416]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.416]                         if (muffled) 
[13:20:50.416]                           invokeRestart("muffleMessage")
[13:20:50.416]                       }
[13:20:50.416]                       else if (inherits(cond, "warning")) {
[13:20:50.416]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.416]                         if (muffled) 
[13:20:50.416]                           invokeRestart("muffleWarning")
[13:20:50.416]                       }
[13:20:50.416]                       else if (inherits(cond, "condition")) {
[13:20:50.416]                         if (!is.null(pattern)) {
[13:20:50.416]                           computeRestarts <- base::computeRestarts
[13:20:50.416]                           grepl <- base::grepl
[13:20:50.416]                           restarts <- computeRestarts(cond)
[13:20:50.416]                           for (restart in restarts) {
[13:20:50.416]                             name <- restart$name
[13:20:50.416]                             if (is.null(name)) 
[13:20:50.416]                               next
[13:20:50.416]                             if (!grepl(pattern, name)) 
[13:20:50.416]                               next
[13:20:50.416]                             invokeRestart(restart)
[13:20:50.416]                             muffled <- TRUE
[13:20:50.416]                             break
[13:20:50.416]                           }
[13:20:50.416]                         }
[13:20:50.416]                       }
[13:20:50.416]                       invisible(muffled)
[13:20:50.416]                     }
[13:20:50.416]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.416]                   }
[13:20:50.416]                 }
[13:20:50.416]                 else {
[13:20:50.416]                   if (TRUE) {
[13:20:50.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.416]                     {
[13:20:50.416]                       inherits <- base::inherits
[13:20:50.416]                       invokeRestart <- base::invokeRestart
[13:20:50.416]                       is.null <- base::is.null
[13:20:50.416]                       muffled <- FALSE
[13:20:50.416]                       if (inherits(cond, "message")) {
[13:20:50.416]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.416]                         if (muffled) 
[13:20:50.416]                           invokeRestart("muffleMessage")
[13:20:50.416]                       }
[13:20:50.416]                       else if (inherits(cond, "warning")) {
[13:20:50.416]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.416]                         if (muffled) 
[13:20:50.416]                           invokeRestart("muffleWarning")
[13:20:50.416]                       }
[13:20:50.416]                       else if (inherits(cond, "condition")) {
[13:20:50.416]                         if (!is.null(pattern)) {
[13:20:50.416]                           computeRestarts <- base::computeRestarts
[13:20:50.416]                           grepl <- base::grepl
[13:20:50.416]                           restarts <- computeRestarts(cond)
[13:20:50.416]                           for (restart in restarts) {
[13:20:50.416]                             name <- restart$name
[13:20:50.416]                             if (is.null(name)) 
[13:20:50.416]                               next
[13:20:50.416]                             if (!grepl(pattern, name)) 
[13:20:50.416]                               next
[13:20:50.416]                             invokeRestart(restart)
[13:20:50.416]                             muffled <- TRUE
[13:20:50.416]                             break
[13:20:50.416]                           }
[13:20:50.416]                         }
[13:20:50.416]                       }
[13:20:50.416]                       invisible(muffled)
[13:20:50.416]                     }
[13:20:50.416]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.416]                   }
[13:20:50.416]                 }
[13:20:50.416]             }
[13:20:50.416]         }))
[13:20:50.416]     }, error = function(ex) {
[13:20:50.416]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.416]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.416]                 ...future.rng), started = ...future.startTime, 
[13:20:50.416]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.416]             version = "1.8"), class = "FutureResult")
[13:20:50.416]     }, finally = {
[13:20:50.416]         if (!identical(...future.workdir, getwd())) 
[13:20:50.416]             setwd(...future.workdir)
[13:20:50.416]         {
[13:20:50.416]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.416]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.416]             }
[13:20:50.416]             base::options(...future.oldOptions)
[13:20:50.416]             if (.Platform$OS.type == "windows") {
[13:20:50.416]                 old_names <- names(...future.oldEnvVars)
[13:20:50.416]                 envs <- base::Sys.getenv()
[13:20:50.416]                 names <- names(envs)
[13:20:50.416]                 common <- intersect(names, old_names)
[13:20:50.416]                 added <- setdiff(names, old_names)
[13:20:50.416]                 removed <- setdiff(old_names, names)
[13:20:50.416]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.416]                   envs[common]]
[13:20:50.416]                 NAMES <- toupper(changed)
[13:20:50.416]                 args <- list()
[13:20:50.416]                 for (kk in seq_along(NAMES)) {
[13:20:50.416]                   name <- changed[[kk]]
[13:20:50.416]                   NAME <- NAMES[[kk]]
[13:20:50.416]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.416]                     next
[13:20:50.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.416]                 }
[13:20:50.416]                 NAMES <- toupper(added)
[13:20:50.416]                 for (kk in seq_along(NAMES)) {
[13:20:50.416]                   name <- added[[kk]]
[13:20:50.416]                   NAME <- NAMES[[kk]]
[13:20:50.416]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.416]                     next
[13:20:50.416]                   args[[name]] <- ""
[13:20:50.416]                 }
[13:20:50.416]                 NAMES <- toupper(removed)
[13:20:50.416]                 for (kk in seq_along(NAMES)) {
[13:20:50.416]                   name <- removed[[kk]]
[13:20:50.416]                   NAME <- NAMES[[kk]]
[13:20:50.416]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.416]                     next
[13:20:50.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.416]                 }
[13:20:50.416]                 if (length(args) > 0) 
[13:20:50.416]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.416]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.416]             }
[13:20:50.416]             else {
[13:20:50.416]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.416]             }
[13:20:50.416]             {
[13:20:50.416]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.416]                   0L) {
[13:20:50.416]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.416]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.416]                   base::options(opts)
[13:20:50.416]                 }
[13:20:50.416]                 {
[13:20:50.416]                   {
[13:20:50.416]                     NULL
[13:20:50.416]                     RNGkind("Mersenne-Twister")
[13:20:50.416]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.416]                       inherits = FALSE)
[13:20:50.416]                   }
[13:20:50.416]                   options(future.plan = NULL)
[13:20:50.416]                   if (is.na(NA_character_)) 
[13:20:50.416]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.416]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.416]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.416]                   {
[13:20:50.416]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.416]                     if (!future$lazy) 
[13:20:50.416]                       future <- run(future)
[13:20:50.416]                     invisible(future)
[13:20:50.416]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.416]                 }
[13:20:50.416]             }
[13:20:50.416]         }
[13:20:50.416]     })
[13:20:50.416]     if (TRUE) {
[13:20:50.416]         base::sink(type = "output", split = FALSE)
[13:20:50.416]         if (TRUE) {
[13:20:50.416]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.416]         }
[13:20:50.416]         else {
[13:20:50.416]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.416]         }
[13:20:50.416]         base::close(...future.stdout)
[13:20:50.416]         ...future.stdout <- NULL
[13:20:50.416]     }
[13:20:50.416]     ...future.result$conditions <- ...future.conditions
[13:20:50.416]     ...future.result$finished <- base::Sys.time()
[13:20:50.416]     ...future.result
[13:20:50.416] }
[13:20:50.419] assign_globals() ...
[13:20:50.419] List of 2
[13:20:50.419]  $ a : num 1
[13:20:50.419]  $ ii: int 2
[13:20:50.419]  - attr(*, "where")=List of 2
[13:20:50.419]   ..$ a :<environment: R_EmptyEnv> 
[13:20:50.419]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:50.419]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.419]  - attr(*, "resolved")= logi TRUE
[13:20:50.419]  - attr(*, "total_size")= num 112
[13:20:50.419]  - attr(*, "already-done")= logi TRUE
[13:20:50.422] - copied ‘a’ to environment
[13:20:50.422] - copied ‘ii’ to environment
[13:20:50.422] assign_globals() ... done
[13:20:50.422] plan(): Setting new future strategy stack:
[13:20:50.422] List of future strategies:
[13:20:50.422] 1. sequential:
[13:20:50.422]    - args: function (..., envir = parent.frame())
[13:20:50.422]    - tweaked: FALSE
[13:20:50.422]    - call: NULL
[13:20:50.423] plan(): nbrOfWorkers() = 1
[13:20:50.423] plan(): Setting new future strategy stack:
[13:20:50.424] List of future strategies:
[13:20:50.424] 1. sequential:
[13:20:50.424]    - args: function (..., envir = parent.frame())
[13:20:50.424]    - tweaked: FALSE
[13:20:50.424]    - call: plan(strategy)
[13:20:50.424] plan(): nbrOfWorkers() = 1
[13:20:50.424] SequentialFuture started (and completed)
[13:20:50.424] - Launch lazy future ... done
[13:20:50.424] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.425] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.425] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:50.427] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:50.427] Searching for globals ... DONE
[13:20:50.427] Resolving globals: TRUE
[13:20:50.427] Resolving any globals that are futures ...
[13:20:50.427] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:50.427] Resolving any globals that are futures ... DONE
[13:20:50.428] Resolving futures part of globals (recursively) ...
[13:20:50.428] resolve() on list ...
[13:20:50.428]  recursive: 99
[13:20:50.428]  length: 2
[13:20:50.428]  elements: ‘a’, ‘ii’
[13:20:50.428]  length: 1 (resolved future 1)
[13:20:50.428]  length: 0 (resolved future 2)
[13:20:50.428] resolve() on list ... DONE
[13:20:50.428] - globals: [2] ‘a’, ‘ii’
[13:20:50.429] Resolving futures part of globals (recursively) ... DONE
[13:20:50.429] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:50.429] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:20:50.429] - globals: [2] ‘a’, ‘ii’
[13:20:50.429] 
[13:20:50.429] getGlobalsAndPackages() ... DONE
[13:20:50.430] run() for ‘Future’ ...
[13:20:50.430] - state: ‘created’
[13:20:50.430] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.430] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.430] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.430]   - Field: ‘label’
[13:20:50.430]   - Field: ‘local’
[13:20:50.430]   - Field: ‘owner’
[13:20:50.431]   - Field: ‘envir’
[13:20:50.431]   - Field: ‘packages’
[13:20:50.431]   - Field: ‘gc’
[13:20:50.431]   - Field: ‘conditions’
[13:20:50.431]   - Field: ‘expr’
[13:20:50.431]   - Field: ‘uuid’
[13:20:50.431]   - Field: ‘seed’
[13:20:50.431]   - Field: ‘version’
[13:20:50.431]   - Field: ‘result’
[13:20:50.431]   - Field: ‘asynchronous’
[13:20:50.431]   - Field: ‘calls’
[13:20:50.432]   - Field: ‘globals’
[13:20:50.432]   - Field: ‘stdout’
[13:20:50.432]   - Field: ‘earlySignal’
[13:20:50.432]   - Field: ‘lazy’
[13:20:50.432]   - Field: ‘state’
[13:20:50.432] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.432] - Launch lazy future ...
[13:20:50.432] Packages needed by the future expression (n = 0): <none>
[13:20:50.432] Packages needed by future strategies (n = 0): <none>
[13:20:50.433] {
[13:20:50.433]     {
[13:20:50.433]         {
[13:20:50.433]             ...future.startTime <- base::Sys.time()
[13:20:50.433]             {
[13:20:50.433]                 {
[13:20:50.433]                   {
[13:20:50.433]                     base::local({
[13:20:50.433]                       has_future <- base::requireNamespace("future", 
[13:20:50.433]                         quietly = TRUE)
[13:20:50.433]                       if (has_future) {
[13:20:50.433]                         ns <- base::getNamespace("future")
[13:20:50.433]                         version <- ns[[".package"]][["version"]]
[13:20:50.433]                         if (is.null(version)) 
[13:20:50.433]                           version <- utils::packageVersion("future")
[13:20:50.433]                       }
[13:20:50.433]                       else {
[13:20:50.433]                         version <- NULL
[13:20:50.433]                       }
[13:20:50.433]                       if (!has_future || version < "1.8.0") {
[13:20:50.433]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.433]                           "", base::R.version$version.string), 
[13:20:50.433]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.433]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.433]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.433]                             "release", "version")], collapse = " "), 
[13:20:50.433]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.433]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.433]                           info)
[13:20:50.433]                         info <- base::paste(info, collapse = "; ")
[13:20:50.433]                         if (!has_future) {
[13:20:50.433]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.433]                             info)
[13:20:50.433]                         }
[13:20:50.433]                         else {
[13:20:50.433]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.433]                             info, version)
[13:20:50.433]                         }
[13:20:50.433]                         base::stop(msg)
[13:20:50.433]                       }
[13:20:50.433]                     })
[13:20:50.433]                   }
[13:20:50.433]                   options(future.plan = NULL)
[13:20:50.433]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.433]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.433]                 }
[13:20:50.433]                 ...future.workdir <- getwd()
[13:20:50.433]             }
[13:20:50.433]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.433]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.433]         }
[13:20:50.433]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.433]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:50.433]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.433]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.433]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.433]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.433]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.433]             base::names(...future.oldOptions))
[13:20:50.433]     }
[13:20:50.433]     if (FALSE) {
[13:20:50.433]     }
[13:20:50.433]     else {
[13:20:50.433]         if (TRUE) {
[13:20:50.433]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.433]                 open = "w")
[13:20:50.433]         }
[13:20:50.433]         else {
[13:20:50.433]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.433]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.433]         }
[13:20:50.433]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.433]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.433]             base::sink(type = "output", split = FALSE)
[13:20:50.433]             base::close(...future.stdout)
[13:20:50.433]         }, add = TRUE)
[13:20:50.433]     }
[13:20:50.433]     ...future.frame <- base::sys.nframe()
[13:20:50.433]     ...future.conditions <- base::list()
[13:20:50.433]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.433]     if (FALSE) {
[13:20:50.433]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.433]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.433]     }
[13:20:50.433]     ...future.result <- base::tryCatch({
[13:20:50.433]         base::withCallingHandlers({
[13:20:50.433]             ...future.value <- base::withVisible(base::local({
[13:20:50.433]                 b <- a * ii
[13:20:50.433]                 a <- 0
[13:20:50.433]                 b
[13:20:50.433]             }))
[13:20:50.433]             future::FutureResult(value = ...future.value$value, 
[13:20:50.433]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.433]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.433]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.433]                     ...future.globalenv.names))
[13:20:50.433]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.433]         }, condition = base::local({
[13:20:50.433]             c <- base::c
[13:20:50.433]             inherits <- base::inherits
[13:20:50.433]             invokeRestart <- base::invokeRestart
[13:20:50.433]             length <- base::length
[13:20:50.433]             list <- base::list
[13:20:50.433]             seq.int <- base::seq.int
[13:20:50.433]             signalCondition <- base::signalCondition
[13:20:50.433]             sys.calls <- base::sys.calls
[13:20:50.433]             `[[` <- base::`[[`
[13:20:50.433]             `+` <- base::`+`
[13:20:50.433]             `<<-` <- base::`<<-`
[13:20:50.433]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.433]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.433]                   3L)]
[13:20:50.433]             }
[13:20:50.433]             function(cond) {
[13:20:50.433]                 is_error <- inherits(cond, "error")
[13:20:50.433]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.433]                   NULL)
[13:20:50.433]                 if (is_error) {
[13:20:50.433]                   sessionInformation <- function() {
[13:20:50.433]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.433]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.433]                       search = base::search(), system = base::Sys.info())
[13:20:50.433]                   }
[13:20:50.433]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.433]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.433]                     cond$call), session = sessionInformation(), 
[13:20:50.433]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.433]                   signalCondition(cond)
[13:20:50.433]                 }
[13:20:50.433]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.433]                 "immediateCondition"))) {
[13:20:50.433]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.433]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.433]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.433]                   if (TRUE && !signal) {
[13:20:50.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.433]                     {
[13:20:50.433]                       inherits <- base::inherits
[13:20:50.433]                       invokeRestart <- base::invokeRestart
[13:20:50.433]                       is.null <- base::is.null
[13:20:50.433]                       muffled <- FALSE
[13:20:50.433]                       if (inherits(cond, "message")) {
[13:20:50.433]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.433]                         if (muffled) 
[13:20:50.433]                           invokeRestart("muffleMessage")
[13:20:50.433]                       }
[13:20:50.433]                       else if (inherits(cond, "warning")) {
[13:20:50.433]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.433]                         if (muffled) 
[13:20:50.433]                           invokeRestart("muffleWarning")
[13:20:50.433]                       }
[13:20:50.433]                       else if (inherits(cond, "condition")) {
[13:20:50.433]                         if (!is.null(pattern)) {
[13:20:50.433]                           computeRestarts <- base::computeRestarts
[13:20:50.433]                           grepl <- base::grepl
[13:20:50.433]                           restarts <- computeRestarts(cond)
[13:20:50.433]                           for (restart in restarts) {
[13:20:50.433]                             name <- restart$name
[13:20:50.433]                             if (is.null(name)) 
[13:20:50.433]                               next
[13:20:50.433]                             if (!grepl(pattern, name)) 
[13:20:50.433]                               next
[13:20:50.433]                             invokeRestart(restart)
[13:20:50.433]                             muffled <- TRUE
[13:20:50.433]                             break
[13:20:50.433]                           }
[13:20:50.433]                         }
[13:20:50.433]                       }
[13:20:50.433]                       invisible(muffled)
[13:20:50.433]                     }
[13:20:50.433]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.433]                   }
[13:20:50.433]                 }
[13:20:50.433]                 else {
[13:20:50.433]                   if (TRUE) {
[13:20:50.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.433]                     {
[13:20:50.433]                       inherits <- base::inherits
[13:20:50.433]                       invokeRestart <- base::invokeRestart
[13:20:50.433]                       is.null <- base::is.null
[13:20:50.433]                       muffled <- FALSE
[13:20:50.433]                       if (inherits(cond, "message")) {
[13:20:50.433]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.433]                         if (muffled) 
[13:20:50.433]                           invokeRestart("muffleMessage")
[13:20:50.433]                       }
[13:20:50.433]                       else if (inherits(cond, "warning")) {
[13:20:50.433]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.433]                         if (muffled) 
[13:20:50.433]                           invokeRestart("muffleWarning")
[13:20:50.433]                       }
[13:20:50.433]                       else if (inherits(cond, "condition")) {
[13:20:50.433]                         if (!is.null(pattern)) {
[13:20:50.433]                           computeRestarts <- base::computeRestarts
[13:20:50.433]                           grepl <- base::grepl
[13:20:50.433]                           restarts <- computeRestarts(cond)
[13:20:50.433]                           for (restart in restarts) {
[13:20:50.433]                             name <- restart$name
[13:20:50.433]                             if (is.null(name)) 
[13:20:50.433]                               next
[13:20:50.433]                             if (!grepl(pattern, name)) 
[13:20:50.433]                               next
[13:20:50.433]                             invokeRestart(restart)
[13:20:50.433]                             muffled <- TRUE
[13:20:50.433]                             break
[13:20:50.433]                           }
[13:20:50.433]                         }
[13:20:50.433]                       }
[13:20:50.433]                       invisible(muffled)
[13:20:50.433]                     }
[13:20:50.433]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.433]                   }
[13:20:50.433]                 }
[13:20:50.433]             }
[13:20:50.433]         }))
[13:20:50.433]     }, error = function(ex) {
[13:20:50.433]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.433]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.433]                 ...future.rng), started = ...future.startTime, 
[13:20:50.433]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.433]             version = "1.8"), class = "FutureResult")
[13:20:50.433]     }, finally = {
[13:20:50.433]         if (!identical(...future.workdir, getwd())) 
[13:20:50.433]             setwd(...future.workdir)
[13:20:50.433]         {
[13:20:50.433]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.433]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.433]             }
[13:20:50.433]             base::options(...future.oldOptions)
[13:20:50.433]             if (.Platform$OS.type == "windows") {
[13:20:50.433]                 old_names <- names(...future.oldEnvVars)
[13:20:50.433]                 envs <- base::Sys.getenv()
[13:20:50.433]                 names <- names(envs)
[13:20:50.433]                 common <- intersect(names, old_names)
[13:20:50.433]                 added <- setdiff(names, old_names)
[13:20:50.433]                 removed <- setdiff(old_names, names)
[13:20:50.433]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.433]                   envs[common]]
[13:20:50.433]                 NAMES <- toupper(changed)
[13:20:50.433]                 args <- list()
[13:20:50.433]                 for (kk in seq_along(NAMES)) {
[13:20:50.433]                   name <- changed[[kk]]
[13:20:50.433]                   NAME <- NAMES[[kk]]
[13:20:50.433]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.433]                     next
[13:20:50.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.433]                 }
[13:20:50.433]                 NAMES <- toupper(added)
[13:20:50.433]                 for (kk in seq_along(NAMES)) {
[13:20:50.433]                   name <- added[[kk]]
[13:20:50.433]                   NAME <- NAMES[[kk]]
[13:20:50.433]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.433]                     next
[13:20:50.433]                   args[[name]] <- ""
[13:20:50.433]                 }
[13:20:50.433]                 NAMES <- toupper(removed)
[13:20:50.433]                 for (kk in seq_along(NAMES)) {
[13:20:50.433]                   name <- removed[[kk]]
[13:20:50.433]                   NAME <- NAMES[[kk]]
[13:20:50.433]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.433]                     next
[13:20:50.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.433]                 }
[13:20:50.433]                 if (length(args) > 0) 
[13:20:50.433]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.433]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.433]             }
[13:20:50.433]             else {
[13:20:50.433]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.433]             }
[13:20:50.433]             {
[13:20:50.433]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.433]                   0L) {
[13:20:50.433]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.433]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.433]                   base::options(opts)
[13:20:50.433]                 }
[13:20:50.433]                 {
[13:20:50.433]                   {
[13:20:50.433]                     NULL
[13:20:50.433]                     RNGkind("Mersenne-Twister")
[13:20:50.433]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.433]                       inherits = FALSE)
[13:20:50.433]                   }
[13:20:50.433]                   options(future.plan = NULL)
[13:20:50.433]                   if (is.na(NA_character_)) 
[13:20:50.433]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.433]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.433]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.433]                   {
[13:20:50.433]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.433]                     if (!future$lazy) 
[13:20:50.433]                       future <- run(future)
[13:20:50.433]                     invisible(future)
[13:20:50.433]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.433]                 }
[13:20:50.433]             }
[13:20:50.433]         }
[13:20:50.433]     })
[13:20:50.433]     if (TRUE) {
[13:20:50.433]         base::sink(type = "output", split = FALSE)
[13:20:50.433]         if (TRUE) {
[13:20:50.433]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.433]         }
[13:20:50.433]         else {
[13:20:50.433]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.433]         }
[13:20:50.433]         base::close(...future.stdout)
[13:20:50.433]         ...future.stdout <- NULL
[13:20:50.433]     }
[13:20:50.433]     ...future.result$conditions <- ...future.conditions
[13:20:50.433]     ...future.result$finished <- base::Sys.time()
[13:20:50.433]     ...future.result
[13:20:50.433] }
[13:20:50.434] assign_globals() ...
[13:20:50.434] List of 2
[13:20:50.434]  $ a : num 1
[13:20:50.434]  $ ii: int 3
[13:20:50.434]  - attr(*, "where")=List of 2
[13:20:50.434]   ..$ a :<environment: R_EmptyEnv> 
[13:20:50.434]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:50.434]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.434]  - attr(*, "resolved")= logi TRUE
[13:20:50.434]  - attr(*, "total_size")= num 112
[13:20:50.434]  - attr(*, "already-done")= logi TRUE
[13:20:50.437] - copied ‘a’ to environment
[13:20:50.437] - copied ‘ii’ to environment
[13:20:50.437] assign_globals() ... done
[13:20:50.438] plan(): Setting new future strategy stack:
[13:20:50.438] List of future strategies:
[13:20:50.438] 1. sequential:
[13:20:50.438]    - args: function (..., envir = parent.frame())
[13:20:50.438]    - tweaked: FALSE
[13:20:50.438]    - call: NULL
[13:20:50.438] plan(): nbrOfWorkers() = 1
[13:20:50.439] plan(): Setting new future strategy stack:
[13:20:50.439] List of future strategies:
[13:20:50.439] 1. sequential:
[13:20:50.439]    - args: function (..., envir = parent.frame())
[13:20:50.439]    - tweaked: FALSE
[13:20:50.439]    - call: plan(strategy)
[13:20:50.439] plan(): nbrOfWorkers() = 1
[13:20:50.439] SequentialFuture started (and completed)
[13:20:50.440] - Launch lazy future ... done
[13:20:50.440] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.440] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.441] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:50.444] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:50.444] Searching for globals ... DONE
[13:20:50.444] Resolving globals: TRUE
[13:20:50.444] Resolving any globals that are futures ...
[13:20:50.444] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:50.444] Resolving any globals that are futures ... DONE
[13:20:50.445] Resolving futures part of globals (recursively) ...
[13:20:50.445] resolve() on list ...
[13:20:50.445]  recursive: 99
[13:20:50.445]  length: 2
[13:20:50.445]  elements: ‘a’, ‘ii’
[13:20:50.445]  length: 1 (resolved future 1)
[13:20:50.445]  length: 0 (resolved future 2)
[13:20:50.445] resolve() on list ... DONE
[13:20:50.446] - globals: [2] ‘a’, ‘ii’
[13:20:50.446] Resolving futures part of globals (recursively) ... DONE
[13:20:50.446] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:50.446] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:20:50.446] - globals: [2] ‘a’, ‘ii’
[13:20:50.446] 
[13:20:50.446] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.447] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.447] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:50.449] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:50.449] Searching for globals ... DONE
[13:20:50.449] Resolving globals: TRUE
[13:20:50.449] Resolving any globals that are futures ...
[13:20:50.449] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:50.449] Resolving any globals that are futures ... DONE
[13:20:50.450] Resolving futures part of globals (recursively) ...
[13:20:50.450] resolve() on list ...
[13:20:50.450]  recursive: 99
[13:20:50.450]  length: 2
[13:20:50.450]  elements: ‘a’, ‘ii’
[13:20:50.450]  length: 1 (resolved future 1)
[13:20:50.450]  length: 0 (resolved future 2)
[13:20:50.450] resolve() on list ... DONE
[13:20:50.451] - globals: [2] ‘a’, ‘ii’
[13:20:50.451] Resolving futures part of globals (recursively) ... DONE
[13:20:50.451] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:50.451] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:20:50.451] - globals: [2] ‘a’, ‘ii’
[13:20:50.451] 
[13:20:50.451] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.452] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.452] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:50.454] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:50.454] Searching for globals ... DONE
[13:20:50.454] Resolving globals: TRUE
[13:20:50.454] Resolving any globals that are futures ...
[13:20:50.454] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:50.454] Resolving any globals that are futures ... DONE
[13:20:50.455] Resolving futures part of globals (recursively) ...
[13:20:50.455] resolve() on list ...
[13:20:50.455]  recursive: 99
[13:20:50.455]  length: 2
[13:20:50.455]  elements: ‘a’, ‘ii’
[13:20:50.455]  length: 1 (resolved future 1)
[13:20:50.455]  length: 0 (resolved future 2)
[13:20:50.456] resolve() on list ... DONE
[13:20:50.456] - globals: [2] ‘a’, ‘ii’
[13:20:50.456] Resolving futures part of globals (recursively) ... DONE
[13:20:50.456] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:50.456] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:20:50.456] - globals: [2] ‘a’, ‘ii’
[13:20:50.456] 
[13:20:50.457] getGlobalsAndPackages() ... DONE
[13:20:50.457] run() for ‘Future’ ...
[13:20:50.457] - state: ‘created’
[13:20:50.457] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.457] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.457] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.458]   - Field: ‘label’
[13:20:50.458]   - Field: ‘local’
[13:20:50.458]   - Field: ‘owner’
[13:20:50.458]   - Field: ‘envir’
[13:20:50.458]   - Field: ‘packages’
[13:20:50.458]   - Field: ‘gc’
[13:20:50.458]   - Field: ‘conditions’
[13:20:50.458]   - Field: ‘expr’
[13:20:50.458]   - Field: ‘uuid’
[13:20:50.458]   - Field: ‘seed’
[13:20:50.458]   - Field: ‘version’
[13:20:50.459]   - Field: ‘result’
[13:20:50.459]   - Field: ‘asynchronous’
[13:20:50.459]   - Field: ‘calls’
[13:20:50.459]   - Field: ‘globals’
[13:20:50.459]   - Field: ‘stdout’
[13:20:50.459]   - Field: ‘earlySignal’
[13:20:50.459]   - Field: ‘lazy’
[13:20:50.459]   - Field: ‘state’
[13:20:50.459] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.459] - Launch lazy future ...
[13:20:50.460] Packages needed by the future expression (n = 0): <none>
[13:20:50.460] Packages needed by future strategies (n = 0): <none>
[13:20:50.460] {
[13:20:50.460]     {
[13:20:50.460]         {
[13:20:50.460]             ...future.startTime <- base::Sys.time()
[13:20:50.460]             {
[13:20:50.460]                 {
[13:20:50.460]                   {
[13:20:50.460]                     base::local({
[13:20:50.460]                       has_future <- base::requireNamespace("future", 
[13:20:50.460]                         quietly = TRUE)
[13:20:50.460]                       if (has_future) {
[13:20:50.460]                         ns <- base::getNamespace("future")
[13:20:50.460]                         version <- ns[[".package"]][["version"]]
[13:20:50.460]                         if (is.null(version)) 
[13:20:50.460]                           version <- utils::packageVersion("future")
[13:20:50.460]                       }
[13:20:50.460]                       else {
[13:20:50.460]                         version <- NULL
[13:20:50.460]                       }
[13:20:50.460]                       if (!has_future || version < "1.8.0") {
[13:20:50.460]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.460]                           "", base::R.version$version.string), 
[13:20:50.460]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.460]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.460]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.460]                             "release", "version")], collapse = " "), 
[13:20:50.460]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.460]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.460]                           info)
[13:20:50.460]                         info <- base::paste(info, collapse = "; ")
[13:20:50.460]                         if (!has_future) {
[13:20:50.460]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.460]                             info)
[13:20:50.460]                         }
[13:20:50.460]                         else {
[13:20:50.460]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.460]                             info, version)
[13:20:50.460]                         }
[13:20:50.460]                         base::stop(msg)
[13:20:50.460]                       }
[13:20:50.460]                     })
[13:20:50.460]                   }
[13:20:50.460]                   options(future.plan = NULL)
[13:20:50.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.460]                 }
[13:20:50.460]                 ...future.workdir <- getwd()
[13:20:50.460]             }
[13:20:50.460]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.460]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.460]         }
[13:20:50.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.460]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:50.460]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.460]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.460]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.460]             base::names(...future.oldOptions))
[13:20:50.460]     }
[13:20:50.460]     if (FALSE) {
[13:20:50.460]     }
[13:20:50.460]     else {
[13:20:50.460]         if (TRUE) {
[13:20:50.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.460]                 open = "w")
[13:20:50.460]         }
[13:20:50.460]         else {
[13:20:50.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.460]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.460]         }
[13:20:50.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.460]             base::sink(type = "output", split = FALSE)
[13:20:50.460]             base::close(...future.stdout)
[13:20:50.460]         }, add = TRUE)
[13:20:50.460]     }
[13:20:50.460]     ...future.frame <- base::sys.nframe()
[13:20:50.460]     ...future.conditions <- base::list()
[13:20:50.460]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.460]     if (FALSE) {
[13:20:50.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.460]     }
[13:20:50.460]     ...future.result <- base::tryCatch({
[13:20:50.460]         base::withCallingHandlers({
[13:20:50.460]             ...future.value <- base::withVisible(base::local({
[13:20:50.460]                 b <- a * ii
[13:20:50.460]                 a <- 0
[13:20:50.460]                 b
[13:20:50.460]             }))
[13:20:50.460]             future::FutureResult(value = ...future.value$value, 
[13:20:50.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.460]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.460]                     ...future.globalenv.names))
[13:20:50.460]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.460]         }, condition = base::local({
[13:20:50.460]             c <- base::c
[13:20:50.460]             inherits <- base::inherits
[13:20:50.460]             invokeRestart <- base::invokeRestart
[13:20:50.460]             length <- base::length
[13:20:50.460]             list <- base::list
[13:20:50.460]             seq.int <- base::seq.int
[13:20:50.460]             signalCondition <- base::signalCondition
[13:20:50.460]             sys.calls <- base::sys.calls
[13:20:50.460]             `[[` <- base::`[[`
[13:20:50.460]             `+` <- base::`+`
[13:20:50.460]             `<<-` <- base::`<<-`
[13:20:50.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.460]                   3L)]
[13:20:50.460]             }
[13:20:50.460]             function(cond) {
[13:20:50.460]                 is_error <- inherits(cond, "error")
[13:20:50.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.460]                   NULL)
[13:20:50.460]                 if (is_error) {
[13:20:50.460]                   sessionInformation <- function() {
[13:20:50.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.460]                       search = base::search(), system = base::Sys.info())
[13:20:50.460]                   }
[13:20:50.460]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.460]                     cond$call), session = sessionInformation(), 
[13:20:50.460]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.460]                   signalCondition(cond)
[13:20:50.460]                 }
[13:20:50.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.460]                 "immediateCondition"))) {
[13:20:50.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.460]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.460]                   if (TRUE && !signal) {
[13:20:50.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.460]                     {
[13:20:50.460]                       inherits <- base::inherits
[13:20:50.460]                       invokeRestart <- base::invokeRestart
[13:20:50.460]                       is.null <- base::is.null
[13:20:50.460]                       muffled <- FALSE
[13:20:50.460]                       if (inherits(cond, "message")) {
[13:20:50.460]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.460]                         if (muffled) 
[13:20:50.460]                           invokeRestart("muffleMessage")
[13:20:50.460]                       }
[13:20:50.460]                       else if (inherits(cond, "warning")) {
[13:20:50.460]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.460]                         if (muffled) 
[13:20:50.460]                           invokeRestart("muffleWarning")
[13:20:50.460]                       }
[13:20:50.460]                       else if (inherits(cond, "condition")) {
[13:20:50.460]                         if (!is.null(pattern)) {
[13:20:50.460]                           computeRestarts <- base::computeRestarts
[13:20:50.460]                           grepl <- base::grepl
[13:20:50.460]                           restarts <- computeRestarts(cond)
[13:20:50.460]                           for (restart in restarts) {
[13:20:50.460]                             name <- restart$name
[13:20:50.460]                             if (is.null(name)) 
[13:20:50.460]                               next
[13:20:50.460]                             if (!grepl(pattern, name)) 
[13:20:50.460]                               next
[13:20:50.460]                             invokeRestart(restart)
[13:20:50.460]                             muffled <- TRUE
[13:20:50.460]                             break
[13:20:50.460]                           }
[13:20:50.460]                         }
[13:20:50.460]                       }
[13:20:50.460]                       invisible(muffled)
[13:20:50.460]                     }
[13:20:50.460]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.460]                   }
[13:20:50.460]                 }
[13:20:50.460]                 else {
[13:20:50.460]                   if (TRUE) {
[13:20:50.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.460]                     {
[13:20:50.460]                       inherits <- base::inherits
[13:20:50.460]                       invokeRestart <- base::invokeRestart
[13:20:50.460]                       is.null <- base::is.null
[13:20:50.460]                       muffled <- FALSE
[13:20:50.460]                       if (inherits(cond, "message")) {
[13:20:50.460]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.460]                         if (muffled) 
[13:20:50.460]                           invokeRestart("muffleMessage")
[13:20:50.460]                       }
[13:20:50.460]                       else if (inherits(cond, "warning")) {
[13:20:50.460]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.460]                         if (muffled) 
[13:20:50.460]                           invokeRestart("muffleWarning")
[13:20:50.460]                       }
[13:20:50.460]                       else if (inherits(cond, "condition")) {
[13:20:50.460]                         if (!is.null(pattern)) {
[13:20:50.460]                           computeRestarts <- base::computeRestarts
[13:20:50.460]                           grepl <- base::grepl
[13:20:50.460]                           restarts <- computeRestarts(cond)
[13:20:50.460]                           for (restart in restarts) {
[13:20:50.460]                             name <- restart$name
[13:20:50.460]                             if (is.null(name)) 
[13:20:50.460]                               next
[13:20:50.460]                             if (!grepl(pattern, name)) 
[13:20:50.460]                               next
[13:20:50.460]                             invokeRestart(restart)
[13:20:50.460]                             muffled <- TRUE
[13:20:50.460]                             break
[13:20:50.460]                           }
[13:20:50.460]                         }
[13:20:50.460]                       }
[13:20:50.460]                       invisible(muffled)
[13:20:50.460]                     }
[13:20:50.460]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.460]                   }
[13:20:50.460]                 }
[13:20:50.460]             }
[13:20:50.460]         }))
[13:20:50.460]     }, error = function(ex) {
[13:20:50.460]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.460]                 ...future.rng), started = ...future.startTime, 
[13:20:50.460]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.460]             version = "1.8"), class = "FutureResult")
[13:20:50.460]     }, finally = {
[13:20:50.460]         if (!identical(...future.workdir, getwd())) 
[13:20:50.460]             setwd(...future.workdir)
[13:20:50.460]         {
[13:20:50.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.460]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.460]             }
[13:20:50.460]             base::options(...future.oldOptions)
[13:20:50.460]             if (.Platform$OS.type == "windows") {
[13:20:50.460]                 old_names <- names(...future.oldEnvVars)
[13:20:50.460]                 envs <- base::Sys.getenv()
[13:20:50.460]                 names <- names(envs)
[13:20:50.460]                 common <- intersect(names, old_names)
[13:20:50.460]                 added <- setdiff(names, old_names)
[13:20:50.460]                 removed <- setdiff(old_names, names)
[13:20:50.460]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.460]                   envs[common]]
[13:20:50.460]                 NAMES <- toupper(changed)
[13:20:50.460]                 args <- list()
[13:20:50.460]                 for (kk in seq_along(NAMES)) {
[13:20:50.460]                   name <- changed[[kk]]
[13:20:50.460]                   NAME <- NAMES[[kk]]
[13:20:50.460]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.460]                     next
[13:20:50.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.460]                 }
[13:20:50.460]                 NAMES <- toupper(added)
[13:20:50.460]                 for (kk in seq_along(NAMES)) {
[13:20:50.460]                   name <- added[[kk]]
[13:20:50.460]                   NAME <- NAMES[[kk]]
[13:20:50.460]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.460]                     next
[13:20:50.460]                   args[[name]] <- ""
[13:20:50.460]                 }
[13:20:50.460]                 NAMES <- toupper(removed)
[13:20:50.460]                 for (kk in seq_along(NAMES)) {
[13:20:50.460]                   name <- removed[[kk]]
[13:20:50.460]                   NAME <- NAMES[[kk]]
[13:20:50.460]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.460]                     next
[13:20:50.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.460]                 }
[13:20:50.460]                 if (length(args) > 0) 
[13:20:50.460]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.460]             }
[13:20:50.460]             else {
[13:20:50.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.460]             }
[13:20:50.460]             {
[13:20:50.460]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.460]                   0L) {
[13:20:50.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.460]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.460]                   base::options(opts)
[13:20:50.460]                 }
[13:20:50.460]                 {
[13:20:50.460]                   {
[13:20:50.460]                     NULL
[13:20:50.460]                     RNGkind("Mersenne-Twister")
[13:20:50.460]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.460]                       inherits = FALSE)
[13:20:50.460]                   }
[13:20:50.460]                   options(future.plan = NULL)
[13:20:50.460]                   if (is.na(NA_character_)) 
[13:20:50.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.460]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.460]                   {
[13:20:50.460]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.460]                     if (!future$lazy) 
[13:20:50.460]                       future <- run(future)
[13:20:50.460]                     invisible(future)
[13:20:50.460]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.460]                 }
[13:20:50.460]             }
[13:20:50.460]         }
[13:20:50.460]     })
[13:20:50.460]     if (TRUE) {
[13:20:50.460]         base::sink(type = "output", split = FALSE)
[13:20:50.460]         if (TRUE) {
[13:20:50.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.460]         }
[13:20:50.460]         else {
[13:20:50.460]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.460]         }
[13:20:50.460]         base::close(...future.stdout)
[13:20:50.460]         ...future.stdout <- NULL
[13:20:50.460]     }
[13:20:50.460]     ...future.result$conditions <- ...future.conditions
[13:20:50.460]     ...future.result$finished <- base::Sys.time()
[13:20:50.460]     ...future.result
[13:20:50.460] }
[13:20:50.462] assign_globals() ...
[13:20:50.462] List of 2
[13:20:50.462]  $ a : num 1
[13:20:50.462]  $ ii: int 1
[13:20:50.462]  - attr(*, "where")=List of 2
[13:20:50.462]   ..$ a :<environment: R_EmptyEnv> 
[13:20:50.462]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:50.462]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.462]  - attr(*, "resolved")= logi TRUE
[13:20:50.462]  - attr(*, "total_size")= num 112
[13:20:50.462]  - attr(*, "already-done")= logi TRUE
[13:20:50.467] - copied ‘a’ to environment
[13:20:50.467] - copied ‘ii’ to environment
[13:20:50.467] assign_globals() ... done
[13:20:50.467] plan(): Setting new future strategy stack:
[13:20:50.467] List of future strategies:
[13:20:50.467] 1. sequential:
[13:20:50.467]    - args: function (..., envir = parent.frame())
[13:20:50.467]    - tweaked: FALSE
[13:20:50.467]    - call: NULL
[13:20:50.468] plan(): nbrOfWorkers() = 1
[13:20:50.469] plan(): Setting new future strategy stack:
[13:20:50.469] List of future strategies:
[13:20:50.469] 1. sequential:
[13:20:50.469]    - args: function (..., envir = parent.frame())
[13:20:50.469]    - tweaked: FALSE
[13:20:50.469]    - call: plan(strategy)
[13:20:50.469] plan(): nbrOfWorkers() = 1
[13:20:50.469] SequentialFuture started (and completed)
[13:20:50.469] - Launch lazy future ... done
[13:20:50.469] run() for ‘SequentialFuture’ ... done
[13:20:50.470] run() for ‘Future’ ...
[13:20:50.470] - state: ‘created’
[13:20:50.470] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.470] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.470] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.470]   - Field: ‘label’
[13:20:50.471]   - Field: ‘local’
[13:20:50.471]   - Field: ‘owner’
[13:20:50.471]   - Field: ‘envir’
[13:20:50.471]   - Field: ‘packages’
[13:20:50.471]   - Field: ‘gc’
[13:20:50.471]   - Field: ‘conditions’
[13:20:50.471]   - Field: ‘expr’
[13:20:50.471]   - Field: ‘uuid’
[13:20:50.471]   - Field: ‘seed’
[13:20:50.471]   - Field: ‘version’
[13:20:50.471]   - Field: ‘result’
[13:20:50.472]   - Field: ‘asynchronous’
[13:20:50.472]   - Field: ‘calls’
[13:20:50.472]   - Field: ‘globals’
[13:20:50.472]   - Field: ‘stdout’
[13:20:50.472]   - Field: ‘earlySignal’
[13:20:50.472]   - Field: ‘lazy’
[13:20:50.472]   - Field: ‘state’
[13:20:50.472] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.472] - Launch lazy future ...
[13:20:50.472] Packages needed by the future expression (n = 0): <none>
[13:20:50.473] Packages needed by future strategies (n = 0): <none>
[13:20:50.473] {
[13:20:50.473]     {
[13:20:50.473]         {
[13:20:50.473]             ...future.startTime <- base::Sys.time()
[13:20:50.473]             {
[13:20:50.473]                 {
[13:20:50.473]                   {
[13:20:50.473]                     base::local({
[13:20:50.473]                       has_future <- base::requireNamespace("future", 
[13:20:50.473]                         quietly = TRUE)
[13:20:50.473]                       if (has_future) {
[13:20:50.473]                         ns <- base::getNamespace("future")
[13:20:50.473]                         version <- ns[[".package"]][["version"]]
[13:20:50.473]                         if (is.null(version)) 
[13:20:50.473]                           version <- utils::packageVersion("future")
[13:20:50.473]                       }
[13:20:50.473]                       else {
[13:20:50.473]                         version <- NULL
[13:20:50.473]                       }
[13:20:50.473]                       if (!has_future || version < "1.8.0") {
[13:20:50.473]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.473]                           "", base::R.version$version.string), 
[13:20:50.473]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.473]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.473]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.473]                             "release", "version")], collapse = " "), 
[13:20:50.473]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.473]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.473]                           info)
[13:20:50.473]                         info <- base::paste(info, collapse = "; ")
[13:20:50.473]                         if (!has_future) {
[13:20:50.473]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.473]                             info)
[13:20:50.473]                         }
[13:20:50.473]                         else {
[13:20:50.473]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.473]                             info, version)
[13:20:50.473]                         }
[13:20:50.473]                         base::stop(msg)
[13:20:50.473]                       }
[13:20:50.473]                     })
[13:20:50.473]                   }
[13:20:50.473]                   options(future.plan = NULL)
[13:20:50.473]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.473]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.473]                 }
[13:20:50.473]                 ...future.workdir <- getwd()
[13:20:50.473]             }
[13:20:50.473]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.473]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.473]         }
[13:20:50.473]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.473]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:50.473]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.473]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.473]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.473]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.473]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.473]             base::names(...future.oldOptions))
[13:20:50.473]     }
[13:20:50.473]     if (FALSE) {
[13:20:50.473]     }
[13:20:50.473]     else {
[13:20:50.473]         if (TRUE) {
[13:20:50.473]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.473]                 open = "w")
[13:20:50.473]         }
[13:20:50.473]         else {
[13:20:50.473]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.473]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.473]         }
[13:20:50.473]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.473]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.473]             base::sink(type = "output", split = FALSE)
[13:20:50.473]             base::close(...future.stdout)
[13:20:50.473]         }, add = TRUE)
[13:20:50.473]     }
[13:20:50.473]     ...future.frame <- base::sys.nframe()
[13:20:50.473]     ...future.conditions <- base::list()
[13:20:50.473]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.473]     if (FALSE) {
[13:20:50.473]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.473]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.473]     }
[13:20:50.473]     ...future.result <- base::tryCatch({
[13:20:50.473]         base::withCallingHandlers({
[13:20:50.473]             ...future.value <- base::withVisible(base::local({
[13:20:50.473]                 b <- a * ii
[13:20:50.473]                 a <- 0
[13:20:50.473]                 b
[13:20:50.473]             }))
[13:20:50.473]             future::FutureResult(value = ...future.value$value, 
[13:20:50.473]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.473]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.473]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.473]                     ...future.globalenv.names))
[13:20:50.473]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.473]         }, condition = base::local({
[13:20:50.473]             c <- base::c
[13:20:50.473]             inherits <- base::inherits
[13:20:50.473]             invokeRestart <- base::invokeRestart
[13:20:50.473]             length <- base::length
[13:20:50.473]             list <- base::list
[13:20:50.473]             seq.int <- base::seq.int
[13:20:50.473]             signalCondition <- base::signalCondition
[13:20:50.473]             sys.calls <- base::sys.calls
[13:20:50.473]             `[[` <- base::`[[`
[13:20:50.473]             `+` <- base::`+`
[13:20:50.473]             `<<-` <- base::`<<-`
[13:20:50.473]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.473]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.473]                   3L)]
[13:20:50.473]             }
[13:20:50.473]             function(cond) {
[13:20:50.473]                 is_error <- inherits(cond, "error")
[13:20:50.473]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.473]                   NULL)
[13:20:50.473]                 if (is_error) {
[13:20:50.473]                   sessionInformation <- function() {
[13:20:50.473]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.473]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.473]                       search = base::search(), system = base::Sys.info())
[13:20:50.473]                   }
[13:20:50.473]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.473]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.473]                     cond$call), session = sessionInformation(), 
[13:20:50.473]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.473]                   signalCondition(cond)
[13:20:50.473]                 }
[13:20:50.473]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.473]                 "immediateCondition"))) {
[13:20:50.473]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.473]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.473]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.473]                   if (TRUE && !signal) {
[13:20:50.473]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.473]                     {
[13:20:50.473]                       inherits <- base::inherits
[13:20:50.473]                       invokeRestart <- base::invokeRestart
[13:20:50.473]                       is.null <- base::is.null
[13:20:50.473]                       muffled <- FALSE
[13:20:50.473]                       if (inherits(cond, "message")) {
[13:20:50.473]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.473]                         if (muffled) 
[13:20:50.473]                           invokeRestart("muffleMessage")
[13:20:50.473]                       }
[13:20:50.473]                       else if (inherits(cond, "warning")) {
[13:20:50.473]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.473]                         if (muffled) 
[13:20:50.473]                           invokeRestart("muffleWarning")
[13:20:50.473]                       }
[13:20:50.473]                       else if (inherits(cond, "condition")) {
[13:20:50.473]                         if (!is.null(pattern)) {
[13:20:50.473]                           computeRestarts <- base::computeRestarts
[13:20:50.473]                           grepl <- base::grepl
[13:20:50.473]                           restarts <- computeRestarts(cond)
[13:20:50.473]                           for (restart in restarts) {
[13:20:50.473]                             name <- restart$name
[13:20:50.473]                             if (is.null(name)) 
[13:20:50.473]                               next
[13:20:50.473]                             if (!grepl(pattern, name)) 
[13:20:50.473]                               next
[13:20:50.473]                             invokeRestart(restart)
[13:20:50.473]                             muffled <- TRUE
[13:20:50.473]                             break
[13:20:50.473]                           }
[13:20:50.473]                         }
[13:20:50.473]                       }
[13:20:50.473]                       invisible(muffled)
[13:20:50.473]                     }
[13:20:50.473]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.473]                   }
[13:20:50.473]                 }
[13:20:50.473]                 else {
[13:20:50.473]                   if (TRUE) {
[13:20:50.473]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.473]                     {
[13:20:50.473]                       inherits <- base::inherits
[13:20:50.473]                       invokeRestart <- base::invokeRestart
[13:20:50.473]                       is.null <- base::is.null
[13:20:50.473]                       muffled <- FALSE
[13:20:50.473]                       if (inherits(cond, "message")) {
[13:20:50.473]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.473]                         if (muffled) 
[13:20:50.473]                           invokeRestart("muffleMessage")
[13:20:50.473]                       }
[13:20:50.473]                       else if (inherits(cond, "warning")) {
[13:20:50.473]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.473]                         if (muffled) 
[13:20:50.473]                           invokeRestart("muffleWarning")
[13:20:50.473]                       }
[13:20:50.473]                       else if (inherits(cond, "condition")) {
[13:20:50.473]                         if (!is.null(pattern)) {
[13:20:50.473]                           computeRestarts <- base::computeRestarts
[13:20:50.473]                           grepl <- base::grepl
[13:20:50.473]                           restarts <- computeRestarts(cond)
[13:20:50.473]                           for (restart in restarts) {
[13:20:50.473]                             name <- restart$name
[13:20:50.473]                             if (is.null(name)) 
[13:20:50.473]                               next
[13:20:50.473]                             if (!grepl(pattern, name)) 
[13:20:50.473]                               next
[13:20:50.473]                             invokeRestart(restart)
[13:20:50.473]                             muffled <- TRUE
[13:20:50.473]                             break
[13:20:50.473]                           }
[13:20:50.473]                         }
[13:20:50.473]                       }
[13:20:50.473]                       invisible(muffled)
[13:20:50.473]                     }
[13:20:50.473]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.473]                   }
[13:20:50.473]                 }
[13:20:50.473]             }
[13:20:50.473]         }))
[13:20:50.473]     }, error = function(ex) {
[13:20:50.473]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.473]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.473]                 ...future.rng), started = ...future.startTime, 
[13:20:50.473]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.473]             version = "1.8"), class = "FutureResult")
[13:20:50.473]     }, finally = {
[13:20:50.473]         if (!identical(...future.workdir, getwd())) 
[13:20:50.473]             setwd(...future.workdir)
[13:20:50.473]         {
[13:20:50.473]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.473]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.473]             }
[13:20:50.473]             base::options(...future.oldOptions)
[13:20:50.473]             if (.Platform$OS.type == "windows") {
[13:20:50.473]                 old_names <- names(...future.oldEnvVars)
[13:20:50.473]                 envs <- base::Sys.getenv()
[13:20:50.473]                 names <- names(envs)
[13:20:50.473]                 common <- intersect(names, old_names)
[13:20:50.473]                 added <- setdiff(names, old_names)
[13:20:50.473]                 removed <- setdiff(old_names, names)
[13:20:50.473]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.473]                   envs[common]]
[13:20:50.473]                 NAMES <- toupper(changed)
[13:20:50.473]                 args <- list()
[13:20:50.473]                 for (kk in seq_along(NAMES)) {
[13:20:50.473]                   name <- changed[[kk]]
[13:20:50.473]                   NAME <- NAMES[[kk]]
[13:20:50.473]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.473]                     next
[13:20:50.473]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.473]                 }
[13:20:50.473]                 NAMES <- toupper(added)
[13:20:50.473]                 for (kk in seq_along(NAMES)) {
[13:20:50.473]                   name <- added[[kk]]
[13:20:50.473]                   NAME <- NAMES[[kk]]
[13:20:50.473]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.473]                     next
[13:20:50.473]                   args[[name]] <- ""
[13:20:50.473]                 }
[13:20:50.473]                 NAMES <- toupper(removed)
[13:20:50.473]                 for (kk in seq_along(NAMES)) {
[13:20:50.473]                   name <- removed[[kk]]
[13:20:50.473]                   NAME <- NAMES[[kk]]
[13:20:50.473]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.473]                     next
[13:20:50.473]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.473]                 }
[13:20:50.473]                 if (length(args) > 0) 
[13:20:50.473]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.473]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.473]             }
[13:20:50.473]             else {
[13:20:50.473]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.473]             }
[13:20:50.473]             {
[13:20:50.473]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.473]                   0L) {
[13:20:50.473]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.473]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.473]                   base::options(opts)
[13:20:50.473]                 }
[13:20:50.473]                 {
[13:20:50.473]                   {
[13:20:50.473]                     NULL
[13:20:50.473]                     RNGkind("Mersenne-Twister")
[13:20:50.473]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.473]                       inherits = FALSE)
[13:20:50.473]                   }
[13:20:50.473]                   options(future.plan = NULL)
[13:20:50.473]                   if (is.na(NA_character_)) 
[13:20:50.473]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.473]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.473]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.473]                   {
[13:20:50.473]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.473]                     if (!future$lazy) 
[13:20:50.473]                       future <- run(future)
[13:20:50.473]                     invisible(future)
[13:20:50.473]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.473]                 }
[13:20:50.473]             }
[13:20:50.473]         }
[13:20:50.473]     })
[13:20:50.473]     if (TRUE) {
[13:20:50.473]         base::sink(type = "output", split = FALSE)
[13:20:50.473]         if (TRUE) {
[13:20:50.473]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.473]         }
[13:20:50.473]         else {
[13:20:50.473]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.473]         }
[13:20:50.473]         base::close(...future.stdout)
[13:20:50.473]         ...future.stdout <- NULL
[13:20:50.473]     }
[13:20:50.473]     ...future.result$conditions <- ...future.conditions
[13:20:50.473]     ...future.result$finished <- base::Sys.time()
[13:20:50.473]     ...future.result
[13:20:50.473] }
[13:20:50.475] assign_globals() ...
[13:20:50.475] List of 2
[13:20:50.475]  $ a : num 1
[13:20:50.475]  $ ii: int 2
[13:20:50.475]  - attr(*, "where")=List of 2
[13:20:50.475]   ..$ a :<environment: R_EmptyEnv> 
[13:20:50.475]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:50.475]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.475]  - attr(*, "resolved")= logi TRUE
[13:20:50.475]  - attr(*, "total_size")= num 112
[13:20:50.475]  - attr(*, "already-done")= logi TRUE
[13:20:50.478] - copied ‘a’ to environment
[13:20:50.478] - copied ‘ii’ to environment
[13:20:50.478] assign_globals() ... done
[13:20:50.478] plan(): Setting new future strategy stack:
[13:20:50.478] List of future strategies:
[13:20:50.478] 1. sequential:
[13:20:50.478]    - args: function (..., envir = parent.frame())
[13:20:50.478]    - tweaked: FALSE
[13:20:50.478]    - call: NULL
[13:20:50.479] plan(): nbrOfWorkers() = 1
[13:20:50.479] plan(): Setting new future strategy stack:
[13:20:50.479] List of future strategies:
[13:20:50.479] 1. sequential:
[13:20:50.479]    - args: function (..., envir = parent.frame())
[13:20:50.479]    - tweaked: FALSE
[13:20:50.479]    - call: plan(strategy)
[13:20:50.480] plan(): nbrOfWorkers() = 1
[13:20:50.480] SequentialFuture started (and completed)
[13:20:50.480] - Launch lazy future ... done
[13:20:50.480] run() for ‘SequentialFuture’ ... done
[13:20:50.480] run() for ‘Future’ ...
[13:20:50.481] - state: ‘created’
[13:20:50.481] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.481] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.481] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.481]   - Field: ‘label’
[13:20:50.481]   - Field: ‘local’
[13:20:50.481]   - Field: ‘owner’
[13:20:50.481]   - Field: ‘envir’
[13:20:50.482]   - Field: ‘packages’
[13:20:50.482]   - Field: ‘gc’
[13:20:50.482]   - Field: ‘conditions’
[13:20:50.482]   - Field: ‘expr’
[13:20:50.482]   - Field: ‘uuid’
[13:20:50.482]   - Field: ‘seed’
[13:20:50.482]   - Field: ‘version’
[13:20:50.482]   - Field: ‘result’
[13:20:50.482]   - Field: ‘asynchronous’
[13:20:50.482]   - Field: ‘calls’
[13:20:50.483]   - Field: ‘globals’
[13:20:50.483]   - Field: ‘stdout’
[13:20:50.483]   - Field: ‘earlySignal’
[13:20:50.483]   - Field: ‘lazy’
[13:20:50.483]   - Field: ‘state’
[13:20:50.483] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.483] - Launch lazy future ...
[13:20:50.483] Packages needed by the future expression (n = 0): <none>
[13:20:50.483] Packages needed by future strategies (n = 0): <none>
[13:20:50.484] {
[13:20:50.484]     {
[13:20:50.484]         {
[13:20:50.484]             ...future.startTime <- base::Sys.time()
[13:20:50.484]             {
[13:20:50.484]                 {
[13:20:50.484]                   {
[13:20:50.484]                     base::local({
[13:20:50.484]                       has_future <- base::requireNamespace("future", 
[13:20:50.484]                         quietly = TRUE)
[13:20:50.484]                       if (has_future) {
[13:20:50.484]                         ns <- base::getNamespace("future")
[13:20:50.484]                         version <- ns[[".package"]][["version"]]
[13:20:50.484]                         if (is.null(version)) 
[13:20:50.484]                           version <- utils::packageVersion("future")
[13:20:50.484]                       }
[13:20:50.484]                       else {
[13:20:50.484]                         version <- NULL
[13:20:50.484]                       }
[13:20:50.484]                       if (!has_future || version < "1.8.0") {
[13:20:50.484]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.484]                           "", base::R.version$version.string), 
[13:20:50.484]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.484]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.484]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.484]                             "release", "version")], collapse = " "), 
[13:20:50.484]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.484]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.484]                           info)
[13:20:50.484]                         info <- base::paste(info, collapse = "; ")
[13:20:50.484]                         if (!has_future) {
[13:20:50.484]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.484]                             info)
[13:20:50.484]                         }
[13:20:50.484]                         else {
[13:20:50.484]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.484]                             info, version)
[13:20:50.484]                         }
[13:20:50.484]                         base::stop(msg)
[13:20:50.484]                       }
[13:20:50.484]                     })
[13:20:50.484]                   }
[13:20:50.484]                   options(future.plan = NULL)
[13:20:50.484]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.484]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.484]                 }
[13:20:50.484]                 ...future.workdir <- getwd()
[13:20:50.484]             }
[13:20:50.484]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.484]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.484]         }
[13:20:50.484]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.484]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:50.484]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.484]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.484]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.484]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.484]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.484]             base::names(...future.oldOptions))
[13:20:50.484]     }
[13:20:50.484]     if (FALSE) {
[13:20:50.484]     }
[13:20:50.484]     else {
[13:20:50.484]         if (TRUE) {
[13:20:50.484]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.484]                 open = "w")
[13:20:50.484]         }
[13:20:50.484]         else {
[13:20:50.484]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.484]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.484]         }
[13:20:50.484]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.484]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.484]             base::sink(type = "output", split = FALSE)
[13:20:50.484]             base::close(...future.stdout)
[13:20:50.484]         }, add = TRUE)
[13:20:50.484]     }
[13:20:50.484]     ...future.frame <- base::sys.nframe()
[13:20:50.484]     ...future.conditions <- base::list()
[13:20:50.484]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.484]     if (FALSE) {
[13:20:50.484]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.484]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.484]     }
[13:20:50.484]     ...future.result <- base::tryCatch({
[13:20:50.484]         base::withCallingHandlers({
[13:20:50.484]             ...future.value <- base::withVisible(base::local({
[13:20:50.484]                 b <- a * ii
[13:20:50.484]                 a <- 0
[13:20:50.484]                 b
[13:20:50.484]             }))
[13:20:50.484]             future::FutureResult(value = ...future.value$value, 
[13:20:50.484]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.484]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.484]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.484]                     ...future.globalenv.names))
[13:20:50.484]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.484]         }, condition = base::local({
[13:20:50.484]             c <- base::c
[13:20:50.484]             inherits <- base::inherits
[13:20:50.484]             invokeRestart <- base::invokeRestart
[13:20:50.484]             length <- base::length
[13:20:50.484]             list <- base::list
[13:20:50.484]             seq.int <- base::seq.int
[13:20:50.484]             signalCondition <- base::signalCondition
[13:20:50.484]             sys.calls <- base::sys.calls
[13:20:50.484]             `[[` <- base::`[[`
[13:20:50.484]             `+` <- base::`+`
[13:20:50.484]             `<<-` <- base::`<<-`
[13:20:50.484]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.484]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.484]                   3L)]
[13:20:50.484]             }
[13:20:50.484]             function(cond) {
[13:20:50.484]                 is_error <- inherits(cond, "error")
[13:20:50.484]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.484]                   NULL)
[13:20:50.484]                 if (is_error) {
[13:20:50.484]                   sessionInformation <- function() {
[13:20:50.484]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.484]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.484]                       search = base::search(), system = base::Sys.info())
[13:20:50.484]                   }
[13:20:50.484]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.484]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.484]                     cond$call), session = sessionInformation(), 
[13:20:50.484]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.484]                   signalCondition(cond)
[13:20:50.484]                 }
[13:20:50.484]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.484]                 "immediateCondition"))) {
[13:20:50.484]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.484]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.484]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.484]                   if (TRUE && !signal) {
[13:20:50.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.484]                     {
[13:20:50.484]                       inherits <- base::inherits
[13:20:50.484]                       invokeRestart <- base::invokeRestart
[13:20:50.484]                       is.null <- base::is.null
[13:20:50.484]                       muffled <- FALSE
[13:20:50.484]                       if (inherits(cond, "message")) {
[13:20:50.484]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.484]                         if (muffled) 
[13:20:50.484]                           invokeRestart("muffleMessage")
[13:20:50.484]                       }
[13:20:50.484]                       else if (inherits(cond, "warning")) {
[13:20:50.484]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.484]                         if (muffled) 
[13:20:50.484]                           invokeRestart("muffleWarning")
[13:20:50.484]                       }
[13:20:50.484]                       else if (inherits(cond, "condition")) {
[13:20:50.484]                         if (!is.null(pattern)) {
[13:20:50.484]                           computeRestarts <- base::computeRestarts
[13:20:50.484]                           grepl <- base::grepl
[13:20:50.484]                           restarts <- computeRestarts(cond)
[13:20:50.484]                           for (restart in restarts) {
[13:20:50.484]                             name <- restart$name
[13:20:50.484]                             if (is.null(name)) 
[13:20:50.484]                               next
[13:20:50.484]                             if (!grepl(pattern, name)) 
[13:20:50.484]                               next
[13:20:50.484]                             invokeRestart(restart)
[13:20:50.484]                             muffled <- TRUE
[13:20:50.484]                             break
[13:20:50.484]                           }
[13:20:50.484]                         }
[13:20:50.484]                       }
[13:20:50.484]                       invisible(muffled)
[13:20:50.484]                     }
[13:20:50.484]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.484]                   }
[13:20:50.484]                 }
[13:20:50.484]                 else {
[13:20:50.484]                   if (TRUE) {
[13:20:50.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.484]                     {
[13:20:50.484]                       inherits <- base::inherits
[13:20:50.484]                       invokeRestart <- base::invokeRestart
[13:20:50.484]                       is.null <- base::is.null
[13:20:50.484]                       muffled <- FALSE
[13:20:50.484]                       if (inherits(cond, "message")) {
[13:20:50.484]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.484]                         if (muffled) 
[13:20:50.484]                           invokeRestart("muffleMessage")
[13:20:50.484]                       }
[13:20:50.484]                       else if (inherits(cond, "warning")) {
[13:20:50.484]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.484]                         if (muffled) 
[13:20:50.484]                           invokeRestart("muffleWarning")
[13:20:50.484]                       }
[13:20:50.484]                       else if (inherits(cond, "condition")) {
[13:20:50.484]                         if (!is.null(pattern)) {
[13:20:50.484]                           computeRestarts <- base::computeRestarts
[13:20:50.484]                           grepl <- base::grepl
[13:20:50.484]                           restarts <- computeRestarts(cond)
[13:20:50.484]                           for (restart in restarts) {
[13:20:50.484]                             name <- restart$name
[13:20:50.484]                             if (is.null(name)) 
[13:20:50.484]                               next
[13:20:50.484]                             if (!grepl(pattern, name)) 
[13:20:50.484]                               next
[13:20:50.484]                             invokeRestart(restart)
[13:20:50.484]                             muffled <- TRUE
[13:20:50.484]                             break
[13:20:50.484]                           }
[13:20:50.484]                         }
[13:20:50.484]                       }
[13:20:50.484]                       invisible(muffled)
[13:20:50.484]                     }
[13:20:50.484]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.484]                   }
[13:20:50.484]                 }
[13:20:50.484]             }
[13:20:50.484]         }))
[13:20:50.484]     }, error = function(ex) {
[13:20:50.484]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.484]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.484]                 ...future.rng), started = ...future.startTime, 
[13:20:50.484]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.484]             version = "1.8"), class = "FutureResult")
[13:20:50.484]     }, finally = {
[13:20:50.484]         if (!identical(...future.workdir, getwd())) 
[13:20:50.484]             setwd(...future.workdir)
[13:20:50.484]         {
[13:20:50.484]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.484]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.484]             }
[13:20:50.484]             base::options(...future.oldOptions)
[13:20:50.484]             if (.Platform$OS.type == "windows") {
[13:20:50.484]                 old_names <- names(...future.oldEnvVars)
[13:20:50.484]                 envs <- base::Sys.getenv()
[13:20:50.484]                 names <- names(envs)
[13:20:50.484]                 common <- intersect(names, old_names)
[13:20:50.484]                 added <- setdiff(names, old_names)
[13:20:50.484]                 removed <- setdiff(old_names, names)
[13:20:50.484]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.484]                   envs[common]]
[13:20:50.484]                 NAMES <- toupper(changed)
[13:20:50.484]                 args <- list()
[13:20:50.484]                 for (kk in seq_along(NAMES)) {
[13:20:50.484]                   name <- changed[[kk]]
[13:20:50.484]                   NAME <- NAMES[[kk]]
[13:20:50.484]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.484]                     next
[13:20:50.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.484]                 }
[13:20:50.484]                 NAMES <- toupper(added)
[13:20:50.484]                 for (kk in seq_along(NAMES)) {
[13:20:50.484]                   name <- added[[kk]]
[13:20:50.484]                   NAME <- NAMES[[kk]]
[13:20:50.484]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.484]                     next
[13:20:50.484]                   args[[name]] <- ""
[13:20:50.484]                 }
[13:20:50.484]                 NAMES <- toupper(removed)
[13:20:50.484]                 for (kk in seq_along(NAMES)) {
[13:20:50.484]                   name <- removed[[kk]]
[13:20:50.484]                   NAME <- NAMES[[kk]]
[13:20:50.484]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.484]                     next
[13:20:50.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.484]                 }
[13:20:50.484]                 if (length(args) > 0) 
[13:20:50.484]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.484]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.484]             }
[13:20:50.484]             else {
[13:20:50.484]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.484]             }
[13:20:50.484]             {
[13:20:50.484]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.484]                   0L) {
[13:20:50.484]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.484]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.484]                   base::options(opts)
[13:20:50.484]                 }
[13:20:50.484]                 {
[13:20:50.484]                   {
[13:20:50.484]                     NULL
[13:20:50.484]                     RNGkind("Mersenne-Twister")
[13:20:50.484]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.484]                       inherits = FALSE)
[13:20:50.484]                   }
[13:20:50.484]                   options(future.plan = NULL)
[13:20:50.484]                   if (is.na(NA_character_)) 
[13:20:50.484]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.484]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.484]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.484]                   {
[13:20:50.484]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.484]                     if (!future$lazy) 
[13:20:50.484]                       future <- run(future)
[13:20:50.484]                     invisible(future)
[13:20:50.484]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.484]                 }
[13:20:50.484]             }
[13:20:50.484]         }
[13:20:50.484]     })
[13:20:50.484]     if (TRUE) {
[13:20:50.484]         base::sink(type = "output", split = FALSE)
[13:20:50.484]         if (TRUE) {
[13:20:50.484]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.484]         }
[13:20:50.484]         else {
[13:20:50.484]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.484]         }
[13:20:50.484]         base::close(...future.stdout)
[13:20:50.484]         ...future.stdout <- NULL
[13:20:50.484]     }
[13:20:50.484]     ...future.result$conditions <- ...future.conditions
[13:20:50.484]     ...future.result$finished <- base::Sys.time()
[13:20:50.484]     ...future.result
[13:20:50.484] }
[13:20:50.485] assign_globals() ...
[13:20:50.486] List of 2
[13:20:50.486]  $ a : num 1
[13:20:50.486]  $ ii: int 3
[13:20:50.486]  - attr(*, "where")=List of 2
[13:20:50.486]   ..$ a :<environment: R_EmptyEnv> 
[13:20:50.486]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:50.486]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.486]  - attr(*, "resolved")= logi TRUE
[13:20:50.486]  - attr(*, "total_size")= num 112
[13:20:50.486]  - attr(*, "already-done")= logi TRUE
[13:20:50.489] - copied ‘a’ to environment
[13:20:50.489] - copied ‘ii’ to environment
[13:20:50.489] assign_globals() ... done
[13:20:50.489] plan(): Setting new future strategy stack:
[13:20:50.489] List of future strategies:
[13:20:50.489] 1. sequential:
[13:20:50.489]    - args: function (..., envir = parent.frame())
[13:20:50.489]    - tweaked: FALSE
[13:20:50.489]    - call: NULL
[13:20:50.490] plan(): nbrOfWorkers() = 1
[13:20:50.492] plan(): Setting new future strategy stack:
[13:20:50.492] List of future strategies:
[13:20:50.492] 1. sequential:
[13:20:50.492]    - args: function (..., envir = parent.frame())
[13:20:50.492]    - tweaked: FALSE
[13:20:50.492]    - call: plan(strategy)
[13:20:50.493] plan(): nbrOfWorkers() = 1
[13:20:50.493] SequentialFuture started (and completed)
[13:20:50.493] - Launch lazy future ... done
[13:20:50.493] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.493] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.494] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:50.494] 
[13:20:50.494] Searching for globals ... DONE
[13:20:50.494] - globals: [0] <none>
[13:20:50.494] getGlobalsAndPackages() ... DONE
[13:20:50.495] run() for ‘Future’ ...
[13:20:50.495] - state: ‘created’
[13:20:50.495] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.495] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.495] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.495]   - Field: ‘label’
[13:20:50.495]   - Field: ‘local’
[13:20:50.496]   - Field: ‘owner’
[13:20:50.496]   - Field: ‘envir’
[13:20:50.496]   - Field: ‘packages’
[13:20:50.496]   - Field: ‘gc’
[13:20:50.496]   - Field: ‘conditions’
[13:20:50.496]   - Field: ‘expr’
[13:20:50.496]   - Field: ‘uuid’
[13:20:50.496]   - Field: ‘seed’
[13:20:50.496]   - Field: ‘version’
[13:20:50.496]   - Field: ‘result’
[13:20:50.497]   - Field: ‘asynchronous’
[13:20:50.497]   - Field: ‘calls’
[13:20:50.497]   - Field: ‘globals’
[13:20:50.497]   - Field: ‘stdout’
[13:20:50.497]   - Field: ‘earlySignal’
[13:20:50.497]   - Field: ‘lazy’
[13:20:50.497]   - Field: ‘state’
[13:20:50.497] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.497] - Launch lazy future ...
[13:20:50.498] Packages needed by the future expression (n = 0): <none>
[13:20:50.498] Packages needed by future strategies (n = 0): <none>
[13:20:50.498] {
[13:20:50.498]     {
[13:20:50.498]         {
[13:20:50.498]             ...future.startTime <- base::Sys.time()
[13:20:50.498]             {
[13:20:50.498]                 {
[13:20:50.498]                   {
[13:20:50.498]                     base::local({
[13:20:50.498]                       has_future <- base::requireNamespace("future", 
[13:20:50.498]                         quietly = TRUE)
[13:20:50.498]                       if (has_future) {
[13:20:50.498]                         ns <- base::getNamespace("future")
[13:20:50.498]                         version <- ns[[".package"]][["version"]]
[13:20:50.498]                         if (is.null(version)) 
[13:20:50.498]                           version <- utils::packageVersion("future")
[13:20:50.498]                       }
[13:20:50.498]                       else {
[13:20:50.498]                         version <- NULL
[13:20:50.498]                       }
[13:20:50.498]                       if (!has_future || version < "1.8.0") {
[13:20:50.498]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.498]                           "", base::R.version$version.string), 
[13:20:50.498]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.498]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.498]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.498]                             "release", "version")], collapse = " "), 
[13:20:50.498]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.498]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.498]                           info)
[13:20:50.498]                         info <- base::paste(info, collapse = "; ")
[13:20:50.498]                         if (!has_future) {
[13:20:50.498]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.498]                             info)
[13:20:50.498]                         }
[13:20:50.498]                         else {
[13:20:50.498]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.498]                             info, version)
[13:20:50.498]                         }
[13:20:50.498]                         base::stop(msg)
[13:20:50.498]                       }
[13:20:50.498]                     })
[13:20:50.498]                   }
[13:20:50.498]                   options(future.plan = NULL)
[13:20:50.498]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.498]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.498]                 }
[13:20:50.498]                 ...future.workdir <- getwd()
[13:20:50.498]             }
[13:20:50.498]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.498]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.498]         }
[13:20:50.498]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.498]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:50.498]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.498]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.498]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.498]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.498]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.498]             base::names(...future.oldOptions))
[13:20:50.498]     }
[13:20:50.498]     if (FALSE) {
[13:20:50.498]     }
[13:20:50.498]     else {
[13:20:50.498]         if (TRUE) {
[13:20:50.498]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.498]                 open = "w")
[13:20:50.498]         }
[13:20:50.498]         else {
[13:20:50.498]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.498]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.498]         }
[13:20:50.498]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.498]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.498]             base::sink(type = "output", split = FALSE)
[13:20:50.498]             base::close(...future.stdout)
[13:20:50.498]         }, add = TRUE)
[13:20:50.498]     }
[13:20:50.498]     ...future.frame <- base::sys.nframe()
[13:20:50.498]     ...future.conditions <- base::list()
[13:20:50.498]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.498]     if (FALSE) {
[13:20:50.498]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.498]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.498]     }
[13:20:50.498]     ...future.result <- base::tryCatch({
[13:20:50.498]         base::withCallingHandlers({
[13:20:50.498]             ...future.value <- base::withVisible(base::local(1))
[13:20:50.498]             future::FutureResult(value = ...future.value$value, 
[13:20:50.498]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.498]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.498]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.498]                     ...future.globalenv.names))
[13:20:50.498]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.498]         }, condition = base::local({
[13:20:50.498]             c <- base::c
[13:20:50.498]             inherits <- base::inherits
[13:20:50.498]             invokeRestart <- base::invokeRestart
[13:20:50.498]             length <- base::length
[13:20:50.498]             list <- base::list
[13:20:50.498]             seq.int <- base::seq.int
[13:20:50.498]             signalCondition <- base::signalCondition
[13:20:50.498]             sys.calls <- base::sys.calls
[13:20:50.498]             `[[` <- base::`[[`
[13:20:50.498]             `+` <- base::`+`
[13:20:50.498]             `<<-` <- base::`<<-`
[13:20:50.498]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.498]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.498]                   3L)]
[13:20:50.498]             }
[13:20:50.498]             function(cond) {
[13:20:50.498]                 is_error <- inherits(cond, "error")
[13:20:50.498]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.498]                   NULL)
[13:20:50.498]                 if (is_error) {
[13:20:50.498]                   sessionInformation <- function() {
[13:20:50.498]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.498]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.498]                       search = base::search(), system = base::Sys.info())
[13:20:50.498]                   }
[13:20:50.498]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.498]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.498]                     cond$call), session = sessionInformation(), 
[13:20:50.498]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.498]                   signalCondition(cond)
[13:20:50.498]                 }
[13:20:50.498]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.498]                 "immediateCondition"))) {
[13:20:50.498]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.498]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.498]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.498]                   if (TRUE && !signal) {
[13:20:50.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.498]                     {
[13:20:50.498]                       inherits <- base::inherits
[13:20:50.498]                       invokeRestart <- base::invokeRestart
[13:20:50.498]                       is.null <- base::is.null
[13:20:50.498]                       muffled <- FALSE
[13:20:50.498]                       if (inherits(cond, "message")) {
[13:20:50.498]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.498]                         if (muffled) 
[13:20:50.498]                           invokeRestart("muffleMessage")
[13:20:50.498]                       }
[13:20:50.498]                       else if (inherits(cond, "warning")) {
[13:20:50.498]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.498]                         if (muffled) 
[13:20:50.498]                           invokeRestart("muffleWarning")
[13:20:50.498]                       }
[13:20:50.498]                       else if (inherits(cond, "condition")) {
[13:20:50.498]                         if (!is.null(pattern)) {
[13:20:50.498]                           computeRestarts <- base::computeRestarts
[13:20:50.498]                           grepl <- base::grepl
[13:20:50.498]                           restarts <- computeRestarts(cond)
[13:20:50.498]                           for (restart in restarts) {
[13:20:50.498]                             name <- restart$name
[13:20:50.498]                             if (is.null(name)) 
[13:20:50.498]                               next
[13:20:50.498]                             if (!grepl(pattern, name)) 
[13:20:50.498]                               next
[13:20:50.498]                             invokeRestart(restart)
[13:20:50.498]                             muffled <- TRUE
[13:20:50.498]                             break
[13:20:50.498]                           }
[13:20:50.498]                         }
[13:20:50.498]                       }
[13:20:50.498]                       invisible(muffled)
[13:20:50.498]                     }
[13:20:50.498]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.498]                   }
[13:20:50.498]                 }
[13:20:50.498]                 else {
[13:20:50.498]                   if (TRUE) {
[13:20:50.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.498]                     {
[13:20:50.498]                       inherits <- base::inherits
[13:20:50.498]                       invokeRestart <- base::invokeRestart
[13:20:50.498]                       is.null <- base::is.null
[13:20:50.498]                       muffled <- FALSE
[13:20:50.498]                       if (inherits(cond, "message")) {
[13:20:50.498]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.498]                         if (muffled) 
[13:20:50.498]                           invokeRestart("muffleMessage")
[13:20:50.498]                       }
[13:20:50.498]                       else if (inherits(cond, "warning")) {
[13:20:50.498]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.498]                         if (muffled) 
[13:20:50.498]                           invokeRestart("muffleWarning")
[13:20:50.498]                       }
[13:20:50.498]                       else if (inherits(cond, "condition")) {
[13:20:50.498]                         if (!is.null(pattern)) {
[13:20:50.498]                           computeRestarts <- base::computeRestarts
[13:20:50.498]                           grepl <- base::grepl
[13:20:50.498]                           restarts <- computeRestarts(cond)
[13:20:50.498]                           for (restart in restarts) {
[13:20:50.498]                             name <- restart$name
[13:20:50.498]                             if (is.null(name)) 
[13:20:50.498]                               next
[13:20:50.498]                             if (!grepl(pattern, name)) 
[13:20:50.498]                               next
[13:20:50.498]                             invokeRestart(restart)
[13:20:50.498]                             muffled <- TRUE
[13:20:50.498]                             break
[13:20:50.498]                           }
[13:20:50.498]                         }
[13:20:50.498]                       }
[13:20:50.498]                       invisible(muffled)
[13:20:50.498]                     }
[13:20:50.498]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.498]                   }
[13:20:50.498]                 }
[13:20:50.498]             }
[13:20:50.498]         }))
[13:20:50.498]     }, error = function(ex) {
[13:20:50.498]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.498]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.498]                 ...future.rng), started = ...future.startTime, 
[13:20:50.498]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.498]             version = "1.8"), class = "FutureResult")
[13:20:50.498]     }, finally = {
[13:20:50.498]         if (!identical(...future.workdir, getwd())) 
[13:20:50.498]             setwd(...future.workdir)
[13:20:50.498]         {
[13:20:50.498]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.498]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.498]             }
[13:20:50.498]             base::options(...future.oldOptions)
[13:20:50.498]             if (.Platform$OS.type == "windows") {
[13:20:50.498]                 old_names <- names(...future.oldEnvVars)
[13:20:50.498]                 envs <- base::Sys.getenv()
[13:20:50.498]                 names <- names(envs)
[13:20:50.498]                 common <- intersect(names, old_names)
[13:20:50.498]                 added <- setdiff(names, old_names)
[13:20:50.498]                 removed <- setdiff(old_names, names)
[13:20:50.498]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.498]                   envs[common]]
[13:20:50.498]                 NAMES <- toupper(changed)
[13:20:50.498]                 args <- list()
[13:20:50.498]                 for (kk in seq_along(NAMES)) {
[13:20:50.498]                   name <- changed[[kk]]
[13:20:50.498]                   NAME <- NAMES[[kk]]
[13:20:50.498]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.498]                     next
[13:20:50.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.498]                 }
[13:20:50.498]                 NAMES <- toupper(added)
[13:20:50.498]                 for (kk in seq_along(NAMES)) {
[13:20:50.498]                   name <- added[[kk]]
[13:20:50.498]                   NAME <- NAMES[[kk]]
[13:20:50.498]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.498]                     next
[13:20:50.498]                   args[[name]] <- ""
[13:20:50.498]                 }
[13:20:50.498]                 NAMES <- toupper(removed)
[13:20:50.498]                 for (kk in seq_along(NAMES)) {
[13:20:50.498]                   name <- removed[[kk]]
[13:20:50.498]                   NAME <- NAMES[[kk]]
[13:20:50.498]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.498]                     next
[13:20:50.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.498]                 }
[13:20:50.498]                 if (length(args) > 0) 
[13:20:50.498]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.498]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.498]             }
[13:20:50.498]             else {
[13:20:50.498]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.498]             }
[13:20:50.498]             {
[13:20:50.498]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.498]                   0L) {
[13:20:50.498]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.498]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.498]                   base::options(opts)
[13:20:50.498]                 }
[13:20:50.498]                 {
[13:20:50.498]                   {
[13:20:50.498]                     NULL
[13:20:50.498]                     RNGkind("Mersenne-Twister")
[13:20:50.498]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.498]                       inherits = FALSE)
[13:20:50.498]                   }
[13:20:50.498]                   options(future.plan = NULL)
[13:20:50.498]                   if (is.na(NA_character_)) 
[13:20:50.498]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.498]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.498]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.498]                   {
[13:20:50.498]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.498]                     if (!future$lazy) 
[13:20:50.498]                       future <- run(future)
[13:20:50.498]                     invisible(future)
[13:20:50.498]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.498]                 }
[13:20:50.498]             }
[13:20:50.498]         }
[13:20:50.498]     })
[13:20:50.498]     if (TRUE) {
[13:20:50.498]         base::sink(type = "output", split = FALSE)
[13:20:50.498]         if (TRUE) {
[13:20:50.498]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.498]         }
[13:20:50.498]         else {
[13:20:50.498]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.498]         }
[13:20:50.498]         base::close(...future.stdout)
[13:20:50.498]         ...future.stdout <- NULL
[13:20:50.498]     }
[13:20:50.498]     ...future.result$conditions <- ...future.conditions
[13:20:50.498]     ...future.result$finished <- base::Sys.time()
[13:20:50.498]     ...future.result
[13:20:50.498] }
[13:20:50.500] plan(): Setting new future strategy stack:
[13:20:50.500] List of future strategies:
[13:20:50.500] 1. sequential:
[13:20:50.500]    - args: function (..., envir = parent.frame())
[13:20:50.500]    - tweaked: FALSE
[13:20:50.500]    - call: NULL
[13:20:50.500] plan(): nbrOfWorkers() = 1
[13:20:50.501] plan(): Setting new future strategy stack:
[13:20:50.501] List of future strategies:
[13:20:50.501] 1. sequential:
[13:20:50.501]    - args: function (..., envir = parent.frame())
[13:20:50.501]    - tweaked: FALSE
[13:20:50.501]    - call: plan(strategy)
[13:20:50.502] plan(): nbrOfWorkers() = 1
[13:20:50.502] SequentialFuture started (and completed)
[13:20:50.502] - Launch lazy future ... done
[13:20:50.502] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.502] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.503] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:50.503] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:50.503] Searching for globals ... DONE
[13:20:50.504] Resolving globals: TRUE
[13:20:50.504] Resolving any globals that are futures ...
[13:20:50.504] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:50.504] Resolving any globals that are futures ... DONE
[13:20:50.504] Resolving futures part of globals (recursively) ...
[13:20:50.504] resolve() on list ...
[13:20:50.505]  recursive: 99
[13:20:50.505]  length: 1
[13:20:50.505]  elements: ‘a’
[13:20:50.505] resolved() for ‘SequentialFuture’ ...
[13:20:50.505] - state: ‘finished’
[13:20:50.505] - run: TRUE
[13:20:50.505] - result: ‘FutureResult’
[13:20:50.505] resolved() for ‘SequentialFuture’ ... done
[13:20:50.505] Future #1
[13:20:50.506] resolved() for ‘SequentialFuture’ ...
[13:20:50.506] - state: ‘finished’
[13:20:50.506] - run: TRUE
[13:20:50.506] - result: ‘FutureResult’
[13:20:50.506] resolved() for ‘SequentialFuture’ ... done
[13:20:50.506] A SequentialFuture was resolved
[13:20:50.506]  length: 0 (resolved future 1)
[13:20:50.506] resolve() on list ... DONE
[13:20:50.506] - globals: [1] ‘a’
[13:20:50.506] Resolving futures part of globals (recursively) ... DONE
[13:20:50.508] The total size of the 1 globals is 1.52 MiB (1596048 bytes)
[13:20:50.509] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.52 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.52 MiB of class ‘environment’)
[13:20:50.509] - globals: [1] ‘a’
[13:20:50.509] - packages: [1] ‘future’
[13:20:50.509] getGlobalsAndPackages() ... DONE
[13:20:50.509] run() for ‘Future’ ...
[13:20:50.509] - state: ‘created’
[13:20:50.509] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.510] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.510] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.510]   - Field: ‘label’
[13:20:50.510]   - Field: ‘local’
[13:20:50.510]   - Field: ‘owner’
[13:20:50.510]   - Field: ‘envir’
[13:20:50.510]   - Field: ‘packages’
[13:20:50.510]   - Field: ‘gc’
[13:20:50.510]   - Field: ‘conditions’
[13:20:50.511]   - Field: ‘expr’
[13:20:50.511]   - Field: ‘uuid’
[13:20:50.511]   - Field: ‘seed’
[13:20:50.511]   - Field: ‘version’
[13:20:50.511]   - Field: ‘result’
[13:20:50.511]   - Field: ‘asynchronous’
[13:20:50.511]   - Field: ‘calls’
[13:20:50.511]   - Field: ‘globals’
[13:20:50.511]   - Field: ‘stdout’
[13:20:50.511]   - Field: ‘earlySignal’
[13:20:50.511]   - Field: ‘lazy’
[13:20:50.512]   - Field: ‘state’
[13:20:50.512] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.512] - Launch lazy future ...
[13:20:50.512] Packages needed by the future expression (n = 1): ‘future’
[13:20:50.512] Packages needed by future strategies (n = 0): <none>
[13:20:50.513] {
[13:20:50.513]     {
[13:20:50.513]         {
[13:20:50.513]             ...future.startTime <- base::Sys.time()
[13:20:50.513]             {
[13:20:50.513]                 {
[13:20:50.513]                   {
[13:20:50.513]                     {
[13:20:50.513]                       base::local({
[13:20:50.513]                         has_future <- base::requireNamespace("future", 
[13:20:50.513]                           quietly = TRUE)
[13:20:50.513]                         if (has_future) {
[13:20:50.513]                           ns <- base::getNamespace("future")
[13:20:50.513]                           version <- ns[[".package"]][["version"]]
[13:20:50.513]                           if (is.null(version)) 
[13:20:50.513]                             version <- utils::packageVersion("future")
[13:20:50.513]                         }
[13:20:50.513]                         else {
[13:20:50.513]                           version <- NULL
[13:20:50.513]                         }
[13:20:50.513]                         if (!has_future || version < "1.8.0") {
[13:20:50.513]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.513]                             "", base::R.version$version.string), 
[13:20:50.513]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:50.513]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.513]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.513]                               "release", "version")], collapse = " "), 
[13:20:50.513]                             hostname = base::Sys.info()[["nodename"]])
[13:20:50.513]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.513]                             info)
[13:20:50.513]                           info <- base::paste(info, collapse = "; ")
[13:20:50.513]                           if (!has_future) {
[13:20:50.513]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.513]                               info)
[13:20:50.513]                           }
[13:20:50.513]                           else {
[13:20:50.513]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.513]                               info, version)
[13:20:50.513]                           }
[13:20:50.513]                           base::stop(msg)
[13:20:50.513]                         }
[13:20:50.513]                       })
[13:20:50.513]                     }
[13:20:50.513]                     base::local({
[13:20:50.513]                       for (pkg in "future") {
[13:20:50.513]                         base::loadNamespace(pkg)
[13:20:50.513]                         base::library(pkg, character.only = TRUE)
[13:20:50.513]                       }
[13:20:50.513]                     })
[13:20:50.513]                   }
[13:20:50.513]                   options(future.plan = NULL)
[13:20:50.513]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.513]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.513]                 }
[13:20:50.513]                 ...future.workdir <- getwd()
[13:20:50.513]             }
[13:20:50.513]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.513]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.513]         }
[13:20:50.513]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.513]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:50.513]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.513]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.513]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.513]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.513]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.513]             base::names(...future.oldOptions))
[13:20:50.513]     }
[13:20:50.513]     if (FALSE) {
[13:20:50.513]     }
[13:20:50.513]     else {
[13:20:50.513]         if (TRUE) {
[13:20:50.513]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.513]                 open = "w")
[13:20:50.513]         }
[13:20:50.513]         else {
[13:20:50.513]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.513]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.513]         }
[13:20:50.513]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.513]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.513]             base::sink(type = "output", split = FALSE)
[13:20:50.513]             base::close(...future.stdout)
[13:20:50.513]         }, add = TRUE)
[13:20:50.513]     }
[13:20:50.513]     ...future.frame <- base::sys.nframe()
[13:20:50.513]     ...future.conditions <- base::list()
[13:20:50.513]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.513]     if (FALSE) {
[13:20:50.513]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.513]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.513]     }
[13:20:50.513]     ...future.result <- base::tryCatch({
[13:20:50.513]         base::withCallingHandlers({
[13:20:50.513]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:20:50.513]                 1))
[13:20:50.513]             future::FutureResult(value = ...future.value$value, 
[13:20:50.513]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.513]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.513]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.513]                     ...future.globalenv.names))
[13:20:50.513]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.513]         }, condition = base::local({
[13:20:50.513]             c <- base::c
[13:20:50.513]             inherits <- base::inherits
[13:20:50.513]             invokeRestart <- base::invokeRestart
[13:20:50.513]             length <- base::length
[13:20:50.513]             list <- base::list
[13:20:50.513]             seq.int <- base::seq.int
[13:20:50.513]             signalCondition <- base::signalCondition
[13:20:50.513]             sys.calls <- base::sys.calls
[13:20:50.513]             `[[` <- base::`[[`
[13:20:50.513]             `+` <- base::`+`
[13:20:50.513]             `<<-` <- base::`<<-`
[13:20:50.513]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.513]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.513]                   3L)]
[13:20:50.513]             }
[13:20:50.513]             function(cond) {
[13:20:50.513]                 is_error <- inherits(cond, "error")
[13:20:50.513]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.513]                   NULL)
[13:20:50.513]                 if (is_error) {
[13:20:50.513]                   sessionInformation <- function() {
[13:20:50.513]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.513]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.513]                       search = base::search(), system = base::Sys.info())
[13:20:50.513]                   }
[13:20:50.513]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.513]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.513]                     cond$call), session = sessionInformation(), 
[13:20:50.513]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.513]                   signalCondition(cond)
[13:20:50.513]                 }
[13:20:50.513]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.513]                 "immediateCondition"))) {
[13:20:50.513]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.513]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.513]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.513]                   if (TRUE && !signal) {
[13:20:50.513]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.513]                     {
[13:20:50.513]                       inherits <- base::inherits
[13:20:50.513]                       invokeRestart <- base::invokeRestart
[13:20:50.513]                       is.null <- base::is.null
[13:20:50.513]                       muffled <- FALSE
[13:20:50.513]                       if (inherits(cond, "message")) {
[13:20:50.513]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.513]                         if (muffled) 
[13:20:50.513]                           invokeRestart("muffleMessage")
[13:20:50.513]                       }
[13:20:50.513]                       else if (inherits(cond, "warning")) {
[13:20:50.513]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.513]                         if (muffled) 
[13:20:50.513]                           invokeRestart("muffleWarning")
[13:20:50.513]                       }
[13:20:50.513]                       else if (inherits(cond, "condition")) {
[13:20:50.513]                         if (!is.null(pattern)) {
[13:20:50.513]                           computeRestarts <- base::computeRestarts
[13:20:50.513]                           grepl <- base::grepl
[13:20:50.513]                           restarts <- computeRestarts(cond)
[13:20:50.513]                           for (restart in restarts) {
[13:20:50.513]                             name <- restart$name
[13:20:50.513]                             if (is.null(name)) 
[13:20:50.513]                               next
[13:20:50.513]                             if (!grepl(pattern, name)) 
[13:20:50.513]                               next
[13:20:50.513]                             invokeRestart(restart)
[13:20:50.513]                             muffled <- TRUE
[13:20:50.513]                             break
[13:20:50.513]                           }
[13:20:50.513]                         }
[13:20:50.513]                       }
[13:20:50.513]                       invisible(muffled)
[13:20:50.513]                     }
[13:20:50.513]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.513]                   }
[13:20:50.513]                 }
[13:20:50.513]                 else {
[13:20:50.513]                   if (TRUE) {
[13:20:50.513]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.513]                     {
[13:20:50.513]                       inherits <- base::inherits
[13:20:50.513]                       invokeRestart <- base::invokeRestart
[13:20:50.513]                       is.null <- base::is.null
[13:20:50.513]                       muffled <- FALSE
[13:20:50.513]                       if (inherits(cond, "message")) {
[13:20:50.513]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.513]                         if (muffled) 
[13:20:50.513]                           invokeRestart("muffleMessage")
[13:20:50.513]                       }
[13:20:50.513]                       else if (inherits(cond, "warning")) {
[13:20:50.513]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.513]                         if (muffled) 
[13:20:50.513]                           invokeRestart("muffleWarning")
[13:20:50.513]                       }
[13:20:50.513]                       else if (inherits(cond, "condition")) {
[13:20:50.513]                         if (!is.null(pattern)) {
[13:20:50.513]                           computeRestarts <- base::computeRestarts
[13:20:50.513]                           grepl <- base::grepl
[13:20:50.513]                           restarts <- computeRestarts(cond)
[13:20:50.513]                           for (restart in restarts) {
[13:20:50.513]                             name <- restart$name
[13:20:50.513]                             if (is.null(name)) 
[13:20:50.513]                               next
[13:20:50.513]                             if (!grepl(pattern, name)) 
[13:20:50.513]                               next
[13:20:50.513]                             invokeRestart(restart)
[13:20:50.513]                             muffled <- TRUE
[13:20:50.513]                             break
[13:20:50.513]                           }
[13:20:50.513]                         }
[13:20:50.513]                       }
[13:20:50.513]                       invisible(muffled)
[13:20:50.513]                     }
[13:20:50.513]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.513]                   }
[13:20:50.513]                 }
[13:20:50.513]             }
[13:20:50.513]         }))
[13:20:50.513]     }, error = function(ex) {
[13:20:50.513]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.513]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.513]                 ...future.rng), started = ...future.startTime, 
[13:20:50.513]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.513]             version = "1.8"), class = "FutureResult")
[13:20:50.513]     }, finally = {
[13:20:50.513]         if (!identical(...future.workdir, getwd())) 
[13:20:50.513]             setwd(...future.workdir)
[13:20:50.513]         {
[13:20:50.513]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.513]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.513]             }
[13:20:50.513]             base::options(...future.oldOptions)
[13:20:50.513]             if (.Platform$OS.type == "windows") {
[13:20:50.513]                 old_names <- names(...future.oldEnvVars)
[13:20:50.513]                 envs <- base::Sys.getenv()
[13:20:50.513]                 names <- names(envs)
[13:20:50.513]                 common <- intersect(names, old_names)
[13:20:50.513]                 added <- setdiff(names, old_names)
[13:20:50.513]                 removed <- setdiff(old_names, names)
[13:20:50.513]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.513]                   envs[common]]
[13:20:50.513]                 NAMES <- toupper(changed)
[13:20:50.513]                 args <- list()
[13:20:50.513]                 for (kk in seq_along(NAMES)) {
[13:20:50.513]                   name <- changed[[kk]]
[13:20:50.513]                   NAME <- NAMES[[kk]]
[13:20:50.513]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.513]                     next
[13:20:50.513]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.513]                 }
[13:20:50.513]                 NAMES <- toupper(added)
[13:20:50.513]                 for (kk in seq_along(NAMES)) {
[13:20:50.513]                   name <- added[[kk]]
[13:20:50.513]                   NAME <- NAMES[[kk]]
[13:20:50.513]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.513]                     next
[13:20:50.513]                   args[[name]] <- ""
[13:20:50.513]                 }
[13:20:50.513]                 NAMES <- toupper(removed)
[13:20:50.513]                 for (kk in seq_along(NAMES)) {
[13:20:50.513]                   name <- removed[[kk]]
[13:20:50.513]                   NAME <- NAMES[[kk]]
[13:20:50.513]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.513]                     next
[13:20:50.513]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.513]                 }
[13:20:50.513]                 if (length(args) > 0) 
[13:20:50.513]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.513]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.513]             }
[13:20:50.513]             else {
[13:20:50.513]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.513]             }
[13:20:50.513]             {
[13:20:50.513]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.513]                   0L) {
[13:20:50.513]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.513]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.513]                   base::options(opts)
[13:20:50.513]                 }
[13:20:50.513]                 {
[13:20:50.513]                   {
[13:20:50.513]                     NULL
[13:20:50.513]                     RNGkind("Mersenne-Twister")
[13:20:50.513]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.513]                       inherits = FALSE)
[13:20:50.513]                   }
[13:20:50.513]                   options(future.plan = NULL)
[13:20:50.513]                   if (is.na(NA_character_)) 
[13:20:50.513]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.513]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.513]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.513]                   {
[13:20:50.513]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.513]                     if (!future$lazy) 
[13:20:50.513]                       future <- run(future)
[13:20:50.513]                     invisible(future)
[13:20:50.513]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.513]                 }
[13:20:50.513]             }
[13:20:50.513]         }
[13:20:50.513]     })
[13:20:50.513]     if (TRUE) {
[13:20:50.513]         base::sink(type = "output", split = FALSE)
[13:20:50.513]         if (TRUE) {
[13:20:50.513]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.513]         }
[13:20:50.513]         else {
[13:20:50.513]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.513]         }
[13:20:50.513]         base::close(...future.stdout)
[13:20:50.513]         ...future.stdout <- NULL
[13:20:50.513]     }
[13:20:50.513]     ...future.result$conditions <- ...future.conditions
[13:20:50.513]     ...future.result$finished <- base::Sys.time()
[13:20:50.513]     ...future.result
[13:20:50.513] }
[13:20:50.514] assign_globals() ...
[13:20:50.514] List of 1
[13:20:50.514]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x558ddea81178> 
[13:20:50.514]  - attr(*, "where")=List of 1
[13:20:50.514]   ..$ a:<environment: R_EmptyEnv> 
[13:20:50.514]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.514]  - attr(*, "resolved")= logi TRUE
[13:20:50.514]  - attr(*, "total_size")= num 1596048
[13:20:50.514]  - attr(*, "already-done")= logi TRUE
[13:20:50.543] - copied ‘a’ to environment
[13:20:50.543] assign_globals() ... done
[13:20:50.544] plan(): Setting new future strategy stack:
[13:20:50.544] List of future strategies:
[13:20:50.544] 1. sequential:
[13:20:50.544]    - args: function (..., envir = parent.frame())
[13:20:50.544]    - tweaked: FALSE
[13:20:50.544]    - call: NULL
[13:20:50.544] plan(): nbrOfWorkers() = 1
[13:20:50.545] plan(): Setting new future strategy stack:
[13:20:50.545] List of future strategies:
[13:20:50.545] 1. sequential:
[13:20:50.545]    - args: function (..., envir = parent.frame())
[13:20:50.545]    - tweaked: FALSE
[13:20:50.545]    - call: plan(strategy)
[13:20:50.546] plan(): nbrOfWorkers() = 1
[13:20:50.546] SequentialFuture started (and completed)
[13:20:50.546] - Launch lazy future ... done
[13:20:50.546] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.547] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.547] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:50.547] 
[13:20:50.547] Searching for globals ... DONE
[13:20:50.547] - globals: [0] <none>
[13:20:50.547] getGlobalsAndPackages() ... DONE
[13:20:50.548] run() for ‘Future’ ...
[13:20:50.548] - state: ‘created’
[13:20:50.548] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.548] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.548] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.548]   - Field: ‘label’
[13:20:50.549]   - Field: ‘local’
[13:20:50.549]   - Field: ‘owner’
[13:20:50.549]   - Field: ‘envir’
[13:20:50.549]   - Field: ‘packages’
[13:20:50.549]   - Field: ‘gc’
[13:20:50.549]   - Field: ‘conditions’
[13:20:50.549]   - Field: ‘expr’
[13:20:50.549]   - Field: ‘uuid’
[13:20:50.549]   - Field: ‘seed’
[13:20:50.549]   - Field: ‘version’
[13:20:50.549]   - Field: ‘result’
[13:20:50.550]   - Field: ‘asynchronous’
[13:20:50.550]   - Field: ‘calls’
[13:20:50.550]   - Field: ‘globals’
[13:20:50.550]   - Field: ‘stdout’
[13:20:50.550]   - Field: ‘earlySignal’
[13:20:50.550]   - Field: ‘lazy’
[13:20:50.550]   - Field: ‘state’
[13:20:50.550] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.550] - Launch lazy future ...
[13:20:50.550] Packages needed by the future expression (n = 0): <none>
[13:20:50.551] Packages needed by future strategies (n = 0): <none>
[13:20:50.551] {
[13:20:50.551]     {
[13:20:50.551]         {
[13:20:50.551]             ...future.startTime <- base::Sys.time()
[13:20:50.551]             {
[13:20:50.551]                 {
[13:20:50.551]                   {
[13:20:50.551]                     base::local({
[13:20:50.551]                       has_future <- base::requireNamespace("future", 
[13:20:50.551]                         quietly = TRUE)
[13:20:50.551]                       if (has_future) {
[13:20:50.551]                         ns <- base::getNamespace("future")
[13:20:50.551]                         version <- ns[[".package"]][["version"]]
[13:20:50.551]                         if (is.null(version)) 
[13:20:50.551]                           version <- utils::packageVersion("future")
[13:20:50.551]                       }
[13:20:50.551]                       else {
[13:20:50.551]                         version <- NULL
[13:20:50.551]                       }
[13:20:50.551]                       if (!has_future || version < "1.8.0") {
[13:20:50.551]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.551]                           "", base::R.version$version.string), 
[13:20:50.551]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.551]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.551]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.551]                             "release", "version")], collapse = " "), 
[13:20:50.551]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.551]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.551]                           info)
[13:20:50.551]                         info <- base::paste(info, collapse = "; ")
[13:20:50.551]                         if (!has_future) {
[13:20:50.551]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.551]                             info)
[13:20:50.551]                         }
[13:20:50.551]                         else {
[13:20:50.551]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.551]                             info, version)
[13:20:50.551]                         }
[13:20:50.551]                         base::stop(msg)
[13:20:50.551]                       }
[13:20:50.551]                     })
[13:20:50.551]                   }
[13:20:50.551]                   options(future.plan = NULL)
[13:20:50.551]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.551]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.551]                 }
[13:20:50.551]                 ...future.workdir <- getwd()
[13:20:50.551]             }
[13:20:50.551]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.551]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.551]         }
[13:20:50.551]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.551]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:50.551]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.551]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.551]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.551]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.551]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.551]             base::names(...future.oldOptions))
[13:20:50.551]     }
[13:20:50.551]     if (FALSE) {
[13:20:50.551]     }
[13:20:50.551]     else {
[13:20:50.551]         if (TRUE) {
[13:20:50.551]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.551]                 open = "w")
[13:20:50.551]         }
[13:20:50.551]         else {
[13:20:50.551]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.551]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.551]         }
[13:20:50.551]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.551]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.551]             base::sink(type = "output", split = FALSE)
[13:20:50.551]             base::close(...future.stdout)
[13:20:50.551]         }, add = TRUE)
[13:20:50.551]     }
[13:20:50.551]     ...future.frame <- base::sys.nframe()
[13:20:50.551]     ...future.conditions <- base::list()
[13:20:50.551]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.551]     if (FALSE) {
[13:20:50.551]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.551]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.551]     }
[13:20:50.551]     ...future.result <- base::tryCatch({
[13:20:50.551]         base::withCallingHandlers({
[13:20:50.551]             ...future.value <- base::withVisible(base::local(1))
[13:20:50.551]             future::FutureResult(value = ...future.value$value, 
[13:20:50.551]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.551]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.551]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.551]                     ...future.globalenv.names))
[13:20:50.551]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.551]         }, condition = base::local({
[13:20:50.551]             c <- base::c
[13:20:50.551]             inherits <- base::inherits
[13:20:50.551]             invokeRestart <- base::invokeRestart
[13:20:50.551]             length <- base::length
[13:20:50.551]             list <- base::list
[13:20:50.551]             seq.int <- base::seq.int
[13:20:50.551]             signalCondition <- base::signalCondition
[13:20:50.551]             sys.calls <- base::sys.calls
[13:20:50.551]             `[[` <- base::`[[`
[13:20:50.551]             `+` <- base::`+`
[13:20:50.551]             `<<-` <- base::`<<-`
[13:20:50.551]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.551]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.551]                   3L)]
[13:20:50.551]             }
[13:20:50.551]             function(cond) {
[13:20:50.551]                 is_error <- inherits(cond, "error")
[13:20:50.551]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.551]                   NULL)
[13:20:50.551]                 if (is_error) {
[13:20:50.551]                   sessionInformation <- function() {
[13:20:50.551]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.551]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.551]                       search = base::search(), system = base::Sys.info())
[13:20:50.551]                   }
[13:20:50.551]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.551]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.551]                     cond$call), session = sessionInformation(), 
[13:20:50.551]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.551]                   signalCondition(cond)
[13:20:50.551]                 }
[13:20:50.551]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.551]                 "immediateCondition"))) {
[13:20:50.551]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.551]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.551]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.551]                   if (TRUE && !signal) {
[13:20:50.551]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.551]                     {
[13:20:50.551]                       inherits <- base::inherits
[13:20:50.551]                       invokeRestart <- base::invokeRestart
[13:20:50.551]                       is.null <- base::is.null
[13:20:50.551]                       muffled <- FALSE
[13:20:50.551]                       if (inherits(cond, "message")) {
[13:20:50.551]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.551]                         if (muffled) 
[13:20:50.551]                           invokeRestart("muffleMessage")
[13:20:50.551]                       }
[13:20:50.551]                       else if (inherits(cond, "warning")) {
[13:20:50.551]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.551]                         if (muffled) 
[13:20:50.551]                           invokeRestart("muffleWarning")
[13:20:50.551]                       }
[13:20:50.551]                       else if (inherits(cond, "condition")) {
[13:20:50.551]                         if (!is.null(pattern)) {
[13:20:50.551]                           computeRestarts <- base::computeRestarts
[13:20:50.551]                           grepl <- base::grepl
[13:20:50.551]                           restarts <- computeRestarts(cond)
[13:20:50.551]                           for (restart in restarts) {
[13:20:50.551]                             name <- restart$name
[13:20:50.551]                             if (is.null(name)) 
[13:20:50.551]                               next
[13:20:50.551]                             if (!grepl(pattern, name)) 
[13:20:50.551]                               next
[13:20:50.551]                             invokeRestart(restart)
[13:20:50.551]                             muffled <- TRUE
[13:20:50.551]                             break
[13:20:50.551]                           }
[13:20:50.551]                         }
[13:20:50.551]                       }
[13:20:50.551]                       invisible(muffled)
[13:20:50.551]                     }
[13:20:50.551]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.551]                   }
[13:20:50.551]                 }
[13:20:50.551]                 else {
[13:20:50.551]                   if (TRUE) {
[13:20:50.551]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.551]                     {
[13:20:50.551]                       inherits <- base::inherits
[13:20:50.551]                       invokeRestart <- base::invokeRestart
[13:20:50.551]                       is.null <- base::is.null
[13:20:50.551]                       muffled <- FALSE
[13:20:50.551]                       if (inherits(cond, "message")) {
[13:20:50.551]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.551]                         if (muffled) 
[13:20:50.551]                           invokeRestart("muffleMessage")
[13:20:50.551]                       }
[13:20:50.551]                       else if (inherits(cond, "warning")) {
[13:20:50.551]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.551]                         if (muffled) 
[13:20:50.551]                           invokeRestart("muffleWarning")
[13:20:50.551]                       }
[13:20:50.551]                       else if (inherits(cond, "condition")) {
[13:20:50.551]                         if (!is.null(pattern)) {
[13:20:50.551]                           computeRestarts <- base::computeRestarts
[13:20:50.551]                           grepl <- base::grepl
[13:20:50.551]                           restarts <- computeRestarts(cond)
[13:20:50.551]                           for (restart in restarts) {
[13:20:50.551]                             name <- restart$name
[13:20:50.551]                             if (is.null(name)) 
[13:20:50.551]                               next
[13:20:50.551]                             if (!grepl(pattern, name)) 
[13:20:50.551]                               next
[13:20:50.551]                             invokeRestart(restart)
[13:20:50.551]                             muffled <- TRUE
[13:20:50.551]                             break
[13:20:50.551]                           }
[13:20:50.551]                         }
[13:20:50.551]                       }
[13:20:50.551]                       invisible(muffled)
[13:20:50.551]                     }
[13:20:50.551]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.551]                   }
[13:20:50.551]                 }
[13:20:50.551]             }
[13:20:50.551]         }))
[13:20:50.551]     }, error = function(ex) {
[13:20:50.551]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.551]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.551]                 ...future.rng), started = ...future.startTime, 
[13:20:50.551]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.551]             version = "1.8"), class = "FutureResult")
[13:20:50.551]     }, finally = {
[13:20:50.551]         if (!identical(...future.workdir, getwd())) 
[13:20:50.551]             setwd(...future.workdir)
[13:20:50.551]         {
[13:20:50.551]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.551]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.551]             }
[13:20:50.551]             base::options(...future.oldOptions)
[13:20:50.551]             if (.Platform$OS.type == "windows") {
[13:20:50.551]                 old_names <- names(...future.oldEnvVars)
[13:20:50.551]                 envs <- base::Sys.getenv()
[13:20:50.551]                 names <- names(envs)
[13:20:50.551]                 common <- intersect(names, old_names)
[13:20:50.551]                 added <- setdiff(names, old_names)
[13:20:50.551]                 removed <- setdiff(old_names, names)
[13:20:50.551]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.551]                   envs[common]]
[13:20:50.551]                 NAMES <- toupper(changed)
[13:20:50.551]                 args <- list()
[13:20:50.551]                 for (kk in seq_along(NAMES)) {
[13:20:50.551]                   name <- changed[[kk]]
[13:20:50.551]                   NAME <- NAMES[[kk]]
[13:20:50.551]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.551]                     next
[13:20:50.551]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.551]                 }
[13:20:50.551]                 NAMES <- toupper(added)
[13:20:50.551]                 for (kk in seq_along(NAMES)) {
[13:20:50.551]                   name <- added[[kk]]
[13:20:50.551]                   NAME <- NAMES[[kk]]
[13:20:50.551]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.551]                     next
[13:20:50.551]                   args[[name]] <- ""
[13:20:50.551]                 }
[13:20:50.551]                 NAMES <- toupper(removed)
[13:20:50.551]                 for (kk in seq_along(NAMES)) {
[13:20:50.551]                   name <- removed[[kk]]
[13:20:50.551]                   NAME <- NAMES[[kk]]
[13:20:50.551]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.551]                     next
[13:20:50.551]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.551]                 }
[13:20:50.551]                 if (length(args) > 0) 
[13:20:50.551]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.551]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.551]             }
[13:20:50.551]             else {
[13:20:50.551]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.551]             }
[13:20:50.551]             {
[13:20:50.551]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.551]                   0L) {
[13:20:50.551]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.551]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.551]                   base::options(opts)
[13:20:50.551]                 }
[13:20:50.551]                 {
[13:20:50.551]                   {
[13:20:50.551]                     NULL
[13:20:50.551]                     RNGkind("Mersenne-Twister")
[13:20:50.551]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.551]                       inherits = FALSE)
[13:20:50.551]                   }
[13:20:50.551]                   options(future.plan = NULL)
[13:20:50.551]                   if (is.na(NA_character_)) 
[13:20:50.551]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.551]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.551]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.551]                   {
[13:20:50.551]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.551]                     if (!future$lazy) 
[13:20:50.551]                       future <- run(future)
[13:20:50.551]                     invisible(future)
[13:20:50.551]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.551]                 }
[13:20:50.551]             }
[13:20:50.551]         }
[13:20:50.551]     })
[13:20:50.551]     if (TRUE) {
[13:20:50.551]         base::sink(type = "output", split = FALSE)
[13:20:50.551]         if (TRUE) {
[13:20:50.551]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.551]         }
[13:20:50.551]         else {
[13:20:50.551]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.551]         }
[13:20:50.551]         base::close(...future.stdout)
[13:20:50.551]         ...future.stdout <- NULL
[13:20:50.551]     }
[13:20:50.551]     ...future.result$conditions <- ...future.conditions
[13:20:50.551]     ...future.result$finished <- base::Sys.time()
[13:20:50.551]     ...future.result
[13:20:50.551] }
[13:20:50.553] plan(): Setting new future strategy stack:
[13:20:50.553] List of future strategies:
[13:20:50.553] 1. sequential:
[13:20:50.553]    - args: function (..., envir = parent.frame())
[13:20:50.553]    - tweaked: FALSE
[13:20:50.553]    - call: NULL
[13:20:50.553] plan(): nbrOfWorkers() = 1
[13:20:50.554] plan(): Setting new future strategy stack:
[13:20:50.554] List of future strategies:
[13:20:50.554] 1. sequential:
[13:20:50.554]    - args: function (..., envir = parent.frame())
[13:20:50.554]    - tweaked: FALSE
[13:20:50.554]    - call: plan(strategy)
[13:20:50.554] plan(): nbrOfWorkers() = 1
[13:20:50.555] SequentialFuture started (and completed)
[13:20:50.555] - Launch lazy future ... done
[13:20:50.555] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.555] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.555] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:50.556] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:50.556] Searching for globals ... DONE
[13:20:50.556] Resolving globals: TRUE
[13:20:50.556] Resolving any globals that are futures ...
[13:20:50.556] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:50.556] Resolving any globals that are futures ... DONE
[13:20:50.557] Resolving futures part of globals (recursively) ...
[13:20:50.557] resolve() on list ...
[13:20:50.557]  recursive: 99
[13:20:50.557]  length: 1
[13:20:50.557]  elements: ‘a’
[13:20:50.557] resolved() for ‘SequentialFuture’ ...
[13:20:50.557] - state: ‘finished’
[13:20:50.558] - run: TRUE
[13:20:50.558] - result: ‘FutureResult’
[13:20:50.558] resolved() for ‘SequentialFuture’ ... done
[13:20:50.558] Future #1
[13:20:50.558] resolved() for ‘SequentialFuture’ ...
[13:20:50.558] - state: ‘finished’
[13:20:50.558] - run: TRUE
[13:20:50.558] - result: ‘FutureResult’
[13:20:50.558] resolved() for ‘SequentialFuture’ ... done
[13:20:50.558] A SequentialFuture was resolved
[13:20:50.559]  length: 0 (resolved future 1)
[13:20:50.559] resolve() on list ... DONE
[13:20:50.559] - globals: [1] ‘a’
[13:20:50.559] Resolving futures part of globals (recursively) ... DONE
[13:20:50.561] The total size of the 1 globals is 1.52 MiB (1596048 bytes)
[13:20:50.561] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.52 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.52 MiB of class ‘environment’)
[13:20:50.561] - globals: [1] ‘a’
[13:20:50.561] - packages: [1] ‘future’
[13:20:50.561] getGlobalsAndPackages() ... DONE
[13:20:50.562] run() for ‘Future’ ...
[13:20:50.562] - state: ‘created’
[13:20:50.562] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.562] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.562] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.562]   - Field: ‘label’
[13:20:50.562]   - Field: ‘local’
[13:20:50.563]   - Field: ‘owner’
[13:20:50.563]   - Field: ‘envir’
[13:20:50.563]   - Field: ‘packages’
[13:20:50.563]   - Field: ‘gc’
[13:20:50.563]   - Field: ‘conditions’
[13:20:50.563]   - Field: ‘expr’
[13:20:50.563]   - Field: ‘uuid’
[13:20:50.563]   - Field: ‘seed’
[13:20:50.563]   - Field: ‘version’
[13:20:50.563]   - Field: ‘result’
[13:20:50.563]   - Field: ‘asynchronous’
[13:20:50.564]   - Field: ‘calls’
[13:20:50.564]   - Field: ‘globals’
[13:20:50.564]   - Field: ‘stdout’
[13:20:50.564]   - Field: ‘earlySignal’
[13:20:50.564]   - Field: ‘lazy’
[13:20:50.564]   - Field: ‘state’
[13:20:50.564] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.564] - Launch lazy future ...
[13:20:50.564] Packages needed by the future expression (n = 1): ‘future’
[13:20:50.564] Packages needed by future strategies (n = 0): <none>
[13:20:50.565] {
[13:20:50.565]     {
[13:20:50.565]         {
[13:20:50.565]             ...future.startTime <- base::Sys.time()
[13:20:50.565]             {
[13:20:50.565]                 {
[13:20:50.565]                   {
[13:20:50.565]                     {
[13:20:50.565]                       base::local({
[13:20:50.565]                         has_future <- base::requireNamespace("future", 
[13:20:50.565]                           quietly = TRUE)
[13:20:50.565]                         if (has_future) {
[13:20:50.565]                           ns <- base::getNamespace("future")
[13:20:50.565]                           version <- ns[[".package"]][["version"]]
[13:20:50.565]                           if (is.null(version)) 
[13:20:50.565]                             version <- utils::packageVersion("future")
[13:20:50.565]                         }
[13:20:50.565]                         else {
[13:20:50.565]                           version <- NULL
[13:20:50.565]                         }
[13:20:50.565]                         if (!has_future || version < "1.8.0") {
[13:20:50.565]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.565]                             "", base::R.version$version.string), 
[13:20:50.565]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:50.565]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.565]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.565]                               "release", "version")], collapse = " "), 
[13:20:50.565]                             hostname = base::Sys.info()[["nodename"]])
[13:20:50.565]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.565]                             info)
[13:20:50.565]                           info <- base::paste(info, collapse = "; ")
[13:20:50.565]                           if (!has_future) {
[13:20:50.565]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.565]                               info)
[13:20:50.565]                           }
[13:20:50.565]                           else {
[13:20:50.565]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.565]                               info, version)
[13:20:50.565]                           }
[13:20:50.565]                           base::stop(msg)
[13:20:50.565]                         }
[13:20:50.565]                       })
[13:20:50.565]                     }
[13:20:50.565]                     base::local({
[13:20:50.565]                       for (pkg in "future") {
[13:20:50.565]                         base::loadNamespace(pkg)
[13:20:50.565]                         base::library(pkg, character.only = TRUE)
[13:20:50.565]                       }
[13:20:50.565]                     })
[13:20:50.565]                   }
[13:20:50.565]                   options(future.plan = NULL)
[13:20:50.565]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.565]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.565]                 }
[13:20:50.565]                 ...future.workdir <- getwd()
[13:20:50.565]             }
[13:20:50.565]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.565]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.565]         }
[13:20:50.565]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.565]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:50.565]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.565]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.565]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.565]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.565]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.565]             base::names(...future.oldOptions))
[13:20:50.565]     }
[13:20:50.565]     if (FALSE) {
[13:20:50.565]     }
[13:20:50.565]     else {
[13:20:50.565]         if (TRUE) {
[13:20:50.565]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.565]                 open = "w")
[13:20:50.565]         }
[13:20:50.565]         else {
[13:20:50.565]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.565]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.565]         }
[13:20:50.565]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.565]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.565]             base::sink(type = "output", split = FALSE)
[13:20:50.565]             base::close(...future.stdout)
[13:20:50.565]         }, add = TRUE)
[13:20:50.565]     }
[13:20:50.565]     ...future.frame <- base::sys.nframe()
[13:20:50.565]     ...future.conditions <- base::list()
[13:20:50.565]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.565]     if (FALSE) {
[13:20:50.565]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.565]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.565]     }
[13:20:50.565]     ...future.result <- base::tryCatch({
[13:20:50.565]         base::withCallingHandlers({
[13:20:50.565]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:20:50.565]                 1))
[13:20:50.565]             future::FutureResult(value = ...future.value$value, 
[13:20:50.565]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.565]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.565]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.565]                     ...future.globalenv.names))
[13:20:50.565]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.565]         }, condition = base::local({
[13:20:50.565]             c <- base::c
[13:20:50.565]             inherits <- base::inherits
[13:20:50.565]             invokeRestart <- base::invokeRestart
[13:20:50.565]             length <- base::length
[13:20:50.565]             list <- base::list
[13:20:50.565]             seq.int <- base::seq.int
[13:20:50.565]             signalCondition <- base::signalCondition
[13:20:50.565]             sys.calls <- base::sys.calls
[13:20:50.565]             `[[` <- base::`[[`
[13:20:50.565]             `+` <- base::`+`
[13:20:50.565]             `<<-` <- base::`<<-`
[13:20:50.565]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.565]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.565]                   3L)]
[13:20:50.565]             }
[13:20:50.565]             function(cond) {
[13:20:50.565]                 is_error <- inherits(cond, "error")
[13:20:50.565]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.565]                   NULL)
[13:20:50.565]                 if (is_error) {
[13:20:50.565]                   sessionInformation <- function() {
[13:20:50.565]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.565]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.565]                       search = base::search(), system = base::Sys.info())
[13:20:50.565]                   }
[13:20:50.565]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.565]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.565]                     cond$call), session = sessionInformation(), 
[13:20:50.565]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.565]                   signalCondition(cond)
[13:20:50.565]                 }
[13:20:50.565]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.565]                 "immediateCondition"))) {
[13:20:50.565]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.565]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.565]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.565]                   if (TRUE && !signal) {
[13:20:50.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.565]                     {
[13:20:50.565]                       inherits <- base::inherits
[13:20:50.565]                       invokeRestart <- base::invokeRestart
[13:20:50.565]                       is.null <- base::is.null
[13:20:50.565]                       muffled <- FALSE
[13:20:50.565]                       if (inherits(cond, "message")) {
[13:20:50.565]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.565]                         if (muffled) 
[13:20:50.565]                           invokeRestart("muffleMessage")
[13:20:50.565]                       }
[13:20:50.565]                       else if (inherits(cond, "warning")) {
[13:20:50.565]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.565]                         if (muffled) 
[13:20:50.565]                           invokeRestart("muffleWarning")
[13:20:50.565]                       }
[13:20:50.565]                       else if (inherits(cond, "condition")) {
[13:20:50.565]                         if (!is.null(pattern)) {
[13:20:50.565]                           computeRestarts <- base::computeRestarts
[13:20:50.565]                           grepl <- base::grepl
[13:20:50.565]                           restarts <- computeRestarts(cond)
[13:20:50.565]                           for (restart in restarts) {
[13:20:50.565]                             name <- restart$name
[13:20:50.565]                             if (is.null(name)) 
[13:20:50.565]                               next
[13:20:50.565]                             if (!grepl(pattern, name)) 
[13:20:50.565]                               next
[13:20:50.565]                             invokeRestart(restart)
[13:20:50.565]                             muffled <- TRUE
[13:20:50.565]                             break
[13:20:50.565]                           }
[13:20:50.565]                         }
[13:20:50.565]                       }
[13:20:50.565]                       invisible(muffled)
[13:20:50.565]                     }
[13:20:50.565]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.565]                   }
[13:20:50.565]                 }
[13:20:50.565]                 else {
[13:20:50.565]                   if (TRUE) {
[13:20:50.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.565]                     {
[13:20:50.565]                       inherits <- base::inherits
[13:20:50.565]                       invokeRestart <- base::invokeRestart
[13:20:50.565]                       is.null <- base::is.null
[13:20:50.565]                       muffled <- FALSE
[13:20:50.565]                       if (inherits(cond, "message")) {
[13:20:50.565]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.565]                         if (muffled) 
[13:20:50.565]                           invokeRestart("muffleMessage")
[13:20:50.565]                       }
[13:20:50.565]                       else if (inherits(cond, "warning")) {
[13:20:50.565]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.565]                         if (muffled) 
[13:20:50.565]                           invokeRestart("muffleWarning")
[13:20:50.565]                       }
[13:20:50.565]                       else if (inherits(cond, "condition")) {
[13:20:50.565]                         if (!is.null(pattern)) {
[13:20:50.565]                           computeRestarts <- base::computeRestarts
[13:20:50.565]                           grepl <- base::grepl
[13:20:50.565]                           restarts <- computeRestarts(cond)
[13:20:50.565]                           for (restart in restarts) {
[13:20:50.565]                             name <- restart$name
[13:20:50.565]                             if (is.null(name)) 
[13:20:50.565]                               next
[13:20:50.565]                             if (!grepl(pattern, name)) 
[13:20:50.565]                               next
[13:20:50.565]                             invokeRestart(restart)
[13:20:50.565]                             muffled <- TRUE
[13:20:50.565]                             break
[13:20:50.565]                           }
[13:20:50.565]                         }
[13:20:50.565]                       }
[13:20:50.565]                       invisible(muffled)
[13:20:50.565]                     }
[13:20:50.565]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.565]                   }
[13:20:50.565]                 }
[13:20:50.565]             }
[13:20:50.565]         }))
[13:20:50.565]     }, error = function(ex) {
[13:20:50.565]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.565]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.565]                 ...future.rng), started = ...future.startTime, 
[13:20:50.565]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.565]             version = "1.8"), class = "FutureResult")
[13:20:50.565]     }, finally = {
[13:20:50.565]         if (!identical(...future.workdir, getwd())) 
[13:20:50.565]             setwd(...future.workdir)
[13:20:50.565]         {
[13:20:50.565]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.565]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.565]             }
[13:20:50.565]             base::options(...future.oldOptions)
[13:20:50.565]             if (.Platform$OS.type == "windows") {
[13:20:50.565]                 old_names <- names(...future.oldEnvVars)
[13:20:50.565]                 envs <- base::Sys.getenv()
[13:20:50.565]                 names <- names(envs)
[13:20:50.565]                 common <- intersect(names, old_names)
[13:20:50.565]                 added <- setdiff(names, old_names)
[13:20:50.565]                 removed <- setdiff(old_names, names)
[13:20:50.565]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.565]                   envs[common]]
[13:20:50.565]                 NAMES <- toupper(changed)
[13:20:50.565]                 args <- list()
[13:20:50.565]                 for (kk in seq_along(NAMES)) {
[13:20:50.565]                   name <- changed[[kk]]
[13:20:50.565]                   NAME <- NAMES[[kk]]
[13:20:50.565]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.565]                     next
[13:20:50.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.565]                 }
[13:20:50.565]                 NAMES <- toupper(added)
[13:20:50.565]                 for (kk in seq_along(NAMES)) {
[13:20:50.565]                   name <- added[[kk]]
[13:20:50.565]                   NAME <- NAMES[[kk]]
[13:20:50.565]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.565]                     next
[13:20:50.565]                   args[[name]] <- ""
[13:20:50.565]                 }
[13:20:50.565]                 NAMES <- toupper(removed)
[13:20:50.565]                 for (kk in seq_along(NAMES)) {
[13:20:50.565]                   name <- removed[[kk]]
[13:20:50.565]                   NAME <- NAMES[[kk]]
[13:20:50.565]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.565]                     next
[13:20:50.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.565]                 }
[13:20:50.565]                 if (length(args) > 0) 
[13:20:50.565]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.565]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.565]             }
[13:20:50.565]             else {
[13:20:50.565]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.565]             }
[13:20:50.565]             {
[13:20:50.565]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.565]                   0L) {
[13:20:50.565]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.565]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.565]                   base::options(opts)
[13:20:50.565]                 }
[13:20:50.565]                 {
[13:20:50.565]                   {
[13:20:50.565]                     NULL
[13:20:50.565]                     RNGkind("Mersenne-Twister")
[13:20:50.565]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.565]                       inherits = FALSE)
[13:20:50.565]                   }
[13:20:50.565]                   options(future.plan = NULL)
[13:20:50.565]                   if (is.na(NA_character_)) 
[13:20:50.565]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.565]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.565]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.565]                   {
[13:20:50.565]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.565]                     if (!future$lazy) 
[13:20:50.565]                       future <- run(future)
[13:20:50.565]                     invisible(future)
[13:20:50.565]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.565]                 }
[13:20:50.565]             }
[13:20:50.565]         }
[13:20:50.565]     })
[13:20:50.565]     if (TRUE) {
[13:20:50.565]         base::sink(type = "output", split = FALSE)
[13:20:50.565]         if (TRUE) {
[13:20:50.565]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.565]         }
[13:20:50.565]         else {
[13:20:50.565]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.565]         }
[13:20:50.565]         base::close(...future.stdout)
[13:20:50.565]         ...future.stdout <- NULL
[13:20:50.565]     }
[13:20:50.565]     ...future.result$conditions <- ...future.conditions
[13:20:50.565]     ...future.result$finished <- base::Sys.time()
[13:20:50.565]     ...future.result
[13:20:50.565] }
[13:20:50.567] assign_globals() ...
[13:20:50.567] List of 1
[13:20:50.567]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x558ddec98940> 
[13:20:50.567]  - attr(*, "where")=List of 1
[13:20:50.567]   ..$ a:<environment: R_EmptyEnv> 
[13:20:50.567]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.567]  - attr(*, "resolved")= logi TRUE
[13:20:50.567]  - attr(*, "total_size")= num 1596048
[13:20:50.567]  - attr(*, "already-done")= logi TRUE
[13:20:50.569] - copied ‘a’ to environment
[13:20:50.569] assign_globals() ... done
[13:20:50.570] plan(): Setting new future strategy stack:
[13:20:50.570] List of future strategies:
[13:20:50.570] 1. sequential:
[13:20:50.570]    - args: function (..., envir = parent.frame())
[13:20:50.570]    - tweaked: FALSE
[13:20:50.570]    - call: NULL
[13:20:50.570] plan(): nbrOfWorkers() = 1
[13:20:50.571] plan(): Setting new future strategy stack:
[13:20:50.571] List of future strategies:
[13:20:50.571] 1. sequential:
[13:20:50.571]    - args: function (..., envir = parent.frame())
[13:20:50.571]    - tweaked: FALSE
[13:20:50.571]    - call: plan(strategy)
[13:20:50.573] plan(): nbrOfWorkers() = 1
[13:20:50.573] SequentialFuture started (and completed)
[13:20:50.573] - Launch lazy future ... done
[13:20:50.573] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.574] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.574] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:50.574] 
[13:20:50.574] Searching for globals ... DONE
[13:20:50.575] - globals: [0] <none>
[13:20:50.575] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.575] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.575] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:50.576] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:50.576] Searching for globals ... DONE
[13:20:50.576] Resolving globals: TRUE
[13:20:50.576] Resolving any globals that are futures ...
[13:20:50.576] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:50.576] Resolving any globals that are futures ... DONE
[13:20:50.577] Resolving futures part of globals (recursively) ...
[13:20:50.577] resolve() on list ...
[13:20:50.577]  recursive: 99
[13:20:50.577]  length: 1
[13:20:50.577]  elements: ‘a’
[13:20:50.577] run() for ‘Future’ ...
[13:20:50.577] - state: ‘created’
[13:20:50.578] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.578] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.578] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.578]   - Field: ‘label’
[13:20:50.578]   - Field: ‘local’
[13:20:50.578]   - Field: ‘owner’
[13:20:50.578]   - Field: ‘envir’
[13:20:50.578]   - Field: ‘packages’
[13:20:50.579]   - Field: ‘gc’
[13:20:50.579]   - Field: ‘conditions’
[13:20:50.579]   - Field: ‘expr’
[13:20:50.579]   - Field: ‘uuid’
[13:20:50.579]   - Field: ‘seed’
[13:20:50.579]   - Field: ‘version’
[13:20:50.579]   - Field: ‘result’
[13:20:50.579]   - Field: ‘asynchronous’
[13:20:50.579]   - Field: ‘calls’
[13:20:50.579]   - Field: ‘globals’
[13:20:50.580]   - Field: ‘stdout’
[13:20:50.580]   - Field: ‘earlySignal’
[13:20:50.580]   - Field: ‘lazy’
[13:20:50.580]   - Field: ‘state’
[13:20:50.580] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.580] - Launch lazy future ...
[13:20:50.580] Packages needed by the future expression (n = 0): <none>
[13:20:50.580] Packages needed by future strategies (n = 0): <none>
[13:20:50.581] {
[13:20:50.581]     {
[13:20:50.581]         {
[13:20:50.581]             ...future.startTime <- base::Sys.time()
[13:20:50.581]             {
[13:20:50.581]                 {
[13:20:50.581]                   {
[13:20:50.581]                     base::local({
[13:20:50.581]                       has_future <- base::requireNamespace("future", 
[13:20:50.581]                         quietly = TRUE)
[13:20:50.581]                       if (has_future) {
[13:20:50.581]                         ns <- base::getNamespace("future")
[13:20:50.581]                         version <- ns[[".package"]][["version"]]
[13:20:50.581]                         if (is.null(version)) 
[13:20:50.581]                           version <- utils::packageVersion("future")
[13:20:50.581]                       }
[13:20:50.581]                       else {
[13:20:50.581]                         version <- NULL
[13:20:50.581]                       }
[13:20:50.581]                       if (!has_future || version < "1.8.0") {
[13:20:50.581]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.581]                           "", base::R.version$version.string), 
[13:20:50.581]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.581]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.581]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.581]                             "release", "version")], collapse = " "), 
[13:20:50.581]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.581]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.581]                           info)
[13:20:50.581]                         info <- base::paste(info, collapse = "; ")
[13:20:50.581]                         if (!has_future) {
[13:20:50.581]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.581]                             info)
[13:20:50.581]                         }
[13:20:50.581]                         else {
[13:20:50.581]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.581]                             info, version)
[13:20:50.581]                         }
[13:20:50.581]                         base::stop(msg)
[13:20:50.581]                       }
[13:20:50.581]                     })
[13:20:50.581]                   }
[13:20:50.581]                   options(future.plan = NULL)
[13:20:50.581]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.581]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.581]                 }
[13:20:50.581]                 ...future.workdir <- getwd()
[13:20:50.581]             }
[13:20:50.581]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.581]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.581]         }
[13:20:50.581]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.581]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:50.581]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.581]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.581]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.581]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.581]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.581]             base::names(...future.oldOptions))
[13:20:50.581]     }
[13:20:50.581]     if (FALSE) {
[13:20:50.581]     }
[13:20:50.581]     else {
[13:20:50.581]         if (TRUE) {
[13:20:50.581]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.581]                 open = "w")
[13:20:50.581]         }
[13:20:50.581]         else {
[13:20:50.581]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.581]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.581]         }
[13:20:50.581]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.581]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.581]             base::sink(type = "output", split = FALSE)
[13:20:50.581]             base::close(...future.stdout)
[13:20:50.581]         }, add = TRUE)
[13:20:50.581]     }
[13:20:50.581]     ...future.frame <- base::sys.nframe()
[13:20:50.581]     ...future.conditions <- base::list()
[13:20:50.581]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.581]     if (FALSE) {
[13:20:50.581]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.581]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.581]     }
[13:20:50.581]     ...future.result <- base::tryCatch({
[13:20:50.581]         base::withCallingHandlers({
[13:20:50.581]             ...future.value <- base::withVisible(base::local(1))
[13:20:50.581]             future::FutureResult(value = ...future.value$value, 
[13:20:50.581]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.581]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.581]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.581]                     ...future.globalenv.names))
[13:20:50.581]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.581]         }, condition = base::local({
[13:20:50.581]             c <- base::c
[13:20:50.581]             inherits <- base::inherits
[13:20:50.581]             invokeRestart <- base::invokeRestart
[13:20:50.581]             length <- base::length
[13:20:50.581]             list <- base::list
[13:20:50.581]             seq.int <- base::seq.int
[13:20:50.581]             signalCondition <- base::signalCondition
[13:20:50.581]             sys.calls <- base::sys.calls
[13:20:50.581]             `[[` <- base::`[[`
[13:20:50.581]             `+` <- base::`+`
[13:20:50.581]             `<<-` <- base::`<<-`
[13:20:50.581]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.581]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.581]                   3L)]
[13:20:50.581]             }
[13:20:50.581]             function(cond) {
[13:20:50.581]                 is_error <- inherits(cond, "error")
[13:20:50.581]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.581]                   NULL)
[13:20:50.581]                 if (is_error) {
[13:20:50.581]                   sessionInformation <- function() {
[13:20:50.581]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.581]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.581]                       search = base::search(), system = base::Sys.info())
[13:20:50.581]                   }
[13:20:50.581]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.581]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.581]                     cond$call), session = sessionInformation(), 
[13:20:50.581]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.581]                   signalCondition(cond)
[13:20:50.581]                 }
[13:20:50.581]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.581]                 "immediateCondition"))) {
[13:20:50.581]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.581]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.581]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.581]                   if (TRUE && !signal) {
[13:20:50.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.581]                     {
[13:20:50.581]                       inherits <- base::inherits
[13:20:50.581]                       invokeRestart <- base::invokeRestart
[13:20:50.581]                       is.null <- base::is.null
[13:20:50.581]                       muffled <- FALSE
[13:20:50.581]                       if (inherits(cond, "message")) {
[13:20:50.581]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.581]                         if (muffled) 
[13:20:50.581]                           invokeRestart("muffleMessage")
[13:20:50.581]                       }
[13:20:50.581]                       else if (inherits(cond, "warning")) {
[13:20:50.581]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.581]                         if (muffled) 
[13:20:50.581]                           invokeRestart("muffleWarning")
[13:20:50.581]                       }
[13:20:50.581]                       else if (inherits(cond, "condition")) {
[13:20:50.581]                         if (!is.null(pattern)) {
[13:20:50.581]                           computeRestarts <- base::computeRestarts
[13:20:50.581]                           grepl <- base::grepl
[13:20:50.581]                           restarts <- computeRestarts(cond)
[13:20:50.581]                           for (restart in restarts) {
[13:20:50.581]                             name <- restart$name
[13:20:50.581]                             if (is.null(name)) 
[13:20:50.581]                               next
[13:20:50.581]                             if (!grepl(pattern, name)) 
[13:20:50.581]                               next
[13:20:50.581]                             invokeRestart(restart)
[13:20:50.581]                             muffled <- TRUE
[13:20:50.581]                             break
[13:20:50.581]                           }
[13:20:50.581]                         }
[13:20:50.581]                       }
[13:20:50.581]                       invisible(muffled)
[13:20:50.581]                     }
[13:20:50.581]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.581]                   }
[13:20:50.581]                 }
[13:20:50.581]                 else {
[13:20:50.581]                   if (TRUE) {
[13:20:50.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.581]                     {
[13:20:50.581]                       inherits <- base::inherits
[13:20:50.581]                       invokeRestart <- base::invokeRestart
[13:20:50.581]                       is.null <- base::is.null
[13:20:50.581]                       muffled <- FALSE
[13:20:50.581]                       if (inherits(cond, "message")) {
[13:20:50.581]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.581]                         if (muffled) 
[13:20:50.581]                           invokeRestart("muffleMessage")
[13:20:50.581]                       }
[13:20:50.581]                       else if (inherits(cond, "warning")) {
[13:20:50.581]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.581]                         if (muffled) 
[13:20:50.581]                           invokeRestart("muffleWarning")
[13:20:50.581]                       }
[13:20:50.581]                       else if (inherits(cond, "condition")) {
[13:20:50.581]                         if (!is.null(pattern)) {
[13:20:50.581]                           computeRestarts <- base::computeRestarts
[13:20:50.581]                           grepl <- base::grepl
[13:20:50.581]                           restarts <- computeRestarts(cond)
[13:20:50.581]                           for (restart in restarts) {
[13:20:50.581]                             name <- restart$name
[13:20:50.581]                             if (is.null(name)) 
[13:20:50.581]                               next
[13:20:50.581]                             if (!grepl(pattern, name)) 
[13:20:50.581]                               next
[13:20:50.581]                             invokeRestart(restart)
[13:20:50.581]                             muffled <- TRUE
[13:20:50.581]                             break
[13:20:50.581]                           }
[13:20:50.581]                         }
[13:20:50.581]                       }
[13:20:50.581]                       invisible(muffled)
[13:20:50.581]                     }
[13:20:50.581]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.581]                   }
[13:20:50.581]                 }
[13:20:50.581]             }
[13:20:50.581]         }))
[13:20:50.581]     }, error = function(ex) {
[13:20:50.581]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.581]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.581]                 ...future.rng), started = ...future.startTime, 
[13:20:50.581]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.581]             version = "1.8"), class = "FutureResult")
[13:20:50.581]     }, finally = {
[13:20:50.581]         if (!identical(...future.workdir, getwd())) 
[13:20:50.581]             setwd(...future.workdir)
[13:20:50.581]         {
[13:20:50.581]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.581]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.581]             }
[13:20:50.581]             base::options(...future.oldOptions)
[13:20:50.581]             if (.Platform$OS.type == "windows") {
[13:20:50.581]                 old_names <- names(...future.oldEnvVars)
[13:20:50.581]                 envs <- base::Sys.getenv()
[13:20:50.581]                 names <- names(envs)
[13:20:50.581]                 common <- intersect(names, old_names)
[13:20:50.581]                 added <- setdiff(names, old_names)
[13:20:50.581]                 removed <- setdiff(old_names, names)
[13:20:50.581]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.581]                   envs[common]]
[13:20:50.581]                 NAMES <- toupper(changed)
[13:20:50.581]                 args <- list()
[13:20:50.581]                 for (kk in seq_along(NAMES)) {
[13:20:50.581]                   name <- changed[[kk]]
[13:20:50.581]                   NAME <- NAMES[[kk]]
[13:20:50.581]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.581]                     next
[13:20:50.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.581]                 }
[13:20:50.581]                 NAMES <- toupper(added)
[13:20:50.581]                 for (kk in seq_along(NAMES)) {
[13:20:50.581]                   name <- added[[kk]]
[13:20:50.581]                   NAME <- NAMES[[kk]]
[13:20:50.581]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.581]                     next
[13:20:50.581]                   args[[name]] <- ""
[13:20:50.581]                 }
[13:20:50.581]                 NAMES <- toupper(removed)
[13:20:50.581]                 for (kk in seq_along(NAMES)) {
[13:20:50.581]                   name <- removed[[kk]]
[13:20:50.581]                   NAME <- NAMES[[kk]]
[13:20:50.581]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.581]                     next
[13:20:50.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.581]                 }
[13:20:50.581]                 if (length(args) > 0) 
[13:20:50.581]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.581]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.581]             }
[13:20:50.581]             else {
[13:20:50.581]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.581]             }
[13:20:50.581]             {
[13:20:50.581]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.581]                   0L) {
[13:20:50.581]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.581]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.581]                   base::options(opts)
[13:20:50.581]                 }
[13:20:50.581]                 {
[13:20:50.581]                   {
[13:20:50.581]                     NULL
[13:20:50.581]                     RNGkind("Mersenne-Twister")
[13:20:50.581]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.581]                       inherits = FALSE)
[13:20:50.581]                   }
[13:20:50.581]                   options(future.plan = NULL)
[13:20:50.581]                   if (is.na(NA_character_)) 
[13:20:50.581]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.581]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.581]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.581]                   {
[13:20:50.581]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.581]                     if (!future$lazy) 
[13:20:50.581]                       future <- run(future)
[13:20:50.581]                     invisible(future)
[13:20:50.581]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.581]                 }
[13:20:50.581]             }
[13:20:50.581]         }
[13:20:50.581]     })
[13:20:50.581]     if (TRUE) {
[13:20:50.581]         base::sink(type = "output", split = FALSE)
[13:20:50.581]         if (TRUE) {
[13:20:50.581]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.581]         }
[13:20:50.581]         else {
[13:20:50.581]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.581]         }
[13:20:50.581]         base::close(...future.stdout)
[13:20:50.581]         ...future.stdout <- NULL
[13:20:50.581]     }
[13:20:50.581]     ...future.result$conditions <- ...future.conditions
[13:20:50.581]     ...future.result$finished <- base::Sys.time()
[13:20:50.581]     ...future.result
[13:20:50.581] }
[13:20:50.582] plan(): Setting new future strategy stack:
[13:20:50.583] List of future strategies:
[13:20:50.583] 1. sequential:
[13:20:50.583]    - args: function (..., envir = parent.frame())
[13:20:50.583]    - tweaked: FALSE
[13:20:50.583]    - call: NULL
[13:20:50.583] plan(): nbrOfWorkers() = 1
[13:20:50.584] plan(): Setting new future strategy stack:
[13:20:50.584] List of future strategies:
[13:20:50.584] 1. sequential:
[13:20:50.584]    - args: function (..., envir = parent.frame())
[13:20:50.584]    - tweaked: FALSE
[13:20:50.584]    - call: plan(strategy)
[13:20:50.584] plan(): nbrOfWorkers() = 1
[13:20:50.584] SequentialFuture started (and completed)
[13:20:50.584] - Launch lazy future ... done
[13:20:50.584] run() for ‘SequentialFuture’ ... done
[13:20:50.585] resolved() for ‘SequentialFuture’ ...
[13:20:50.585] - state: ‘finished’
[13:20:50.585] - run: TRUE
[13:20:50.585] - result: ‘FutureResult’
[13:20:50.585] resolved() for ‘SequentialFuture’ ... done
[13:20:50.585] Future #1
[13:20:50.585] resolved() for ‘SequentialFuture’ ...
[13:20:50.585] - state: ‘finished’
[13:20:50.585] - run: TRUE
[13:20:50.585] - result: ‘FutureResult’
[13:20:50.586] resolved() for ‘SequentialFuture’ ... done
[13:20:50.586] A SequentialFuture was resolved
[13:20:50.586]  length: 0 (resolved future 1)
[13:20:50.586] resolve() on list ... DONE
[13:20:50.586] - globals: [1] ‘a’
[13:20:50.586] Resolving futures part of globals (recursively) ... DONE
[13:20:50.588] The total size of the 1 globals is 1.52 MiB (1596216 bytes)
[13:20:50.588] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.52 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.52 MiB of class ‘environment’)
[13:20:50.588] - globals: [1] ‘a’
[13:20:50.588] - packages: [1] ‘future’
[13:20:50.589] getGlobalsAndPackages() ... DONE
[13:20:50.589] run() for ‘Future’ ...
[13:20:50.589] - state: ‘created’
[13:20:50.589] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.589] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.589] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.590]   - Field: ‘label’
[13:20:50.590]   - Field: ‘local’
[13:20:50.590]   - Field: ‘owner’
[13:20:50.590]   - Field: ‘envir’
[13:20:50.590]   - Field: ‘packages’
[13:20:50.590]   - Field: ‘gc’
[13:20:50.590]   - Field: ‘conditions’
[13:20:50.590]   - Field: ‘expr’
[13:20:50.590]   - Field: ‘uuid’
[13:20:50.590]   - Field: ‘seed’
[13:20:50.591]   - Field: ‘version’
[13:20:50.591]   - Field: ‘result’
[13:20:50.591]   - Field: ‘asynchronous’
[13:20:50.591]   - Field: ‘calls’
[13:20:50.591]   - Field: ‘globals’
[13:20:50.591]   - Field: ‘stdout’
[13:20:50.591]   - Field: ‘earlySignal’
[13:20:50.591]   - Field: ‘lazy’
[13:20:50.591]   - Field: ‘state’
[13:20:50.591] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.591] - Launch lazy future ...
[13:20:50.592] Packages needed by the future expression (n = 1): ‘future’
[13:20:50.592] Packages needed by future strategies (n = 0): <none>
[13:20:50.592] {
[13:20:50.592]     {
[13:20:50.592]         {
[13:20:50.592]             ...future.startTime <- base::Sys.time()
[13:20:50.592]             {
[13:20:50.592]                 {
[13:20:50.592]                   {
[13:20:50.592]                     {
[13:20:50.592]                       base::local({
[13:20:50.592]                         has_future <- base::requireNamespace("future", 
[13:20:50.592]                           quietly = TRUE)
[13:20:50.592]                         if (has_future) {
[13:20:50.592]                           ns <- base::getNamespace("future")
[13:20:50.592]                           version <- ns[[".package"]][["version"]]
[13:20:50.592]                           if (is.null(version)) 
[13:20:50.592]                             version <- utils::packageVersion("future")
[13:20:50.592]                         }
[13:20:50.592]                         else {
[13:20:50.592]                           version <- NULL
[13:20:50.592]                         }
[13:20:50.592]                         if (!has_future || version < "1.8.0") {
[13:20:50.592]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.592]                             "", base::R.version$version.string), 
[13:20:50.592]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:50.592]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.592]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.592]                               "release", "version")], collapse = " "), 
[13:20:50.592]                             hostname = base::Sys.info()[["nodename"]])
[13:20:50.592]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.592]                             info)
[13:20:50.592]                           info <- base::paste(info, collapse = "; ")
[13:20:50.592]                           if (!has_future) {
[13:20:50.592]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.592]                               info)
[13:20:50.592]                           }
[13:20:50.592]                           else {
[13:20:50.592]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.592]                               info, version)
[13:20:50.592]                           }
[13:20:50.592]                           base::stop(msg)
[13:20:50.592]                         }
[13:20:50.592]                       })
[13:20:50.592]                     }
[13:20:50.592]                     base::local({
[13:20:50.592]                       for (pkg in "future") {
[13:20:50.592]                         base::loadNamespace(pkg)
[13:20:50.592]                         base::library(pkg, character.only = TRUE)
[13:20:50.592]                       }
[13:20:50.592]                     })
[13:20:50.592]                   }
[13:20:50.592]                   options(future.plan = NULL)
[13:20:50.592]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.592]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.592]                 }
[13:20:50.592]                 ...future.workdir <- getwd()
[13:20:50.592]             }
[13:20:50.592]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.592]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.592]         }
[13:20:50.592]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.592]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:50.592]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.592]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.592]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.592]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.592]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.592]             base::names(...future.oldOptions))
[13:20:50.592]     }
[13:20:50.592]     if (FALSE) {
[13:20:50.592]     }
[13:20:50.592]     else {
[13:20:50.592]         if (TRUE) {
[13:20:50.592]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.592]                 open = "w")
[13:20:50.592]         }
[13:20:50.592]         else {
[13:20:50.592]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.592]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.592]         }
[13:20:50.592]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.592]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.592]             base::sink(type = "output", split = FALSE)
[13:20:50.592]             base::close(...future.stdout)
[13:20:50.592]         }, add = TRUE)
[13:20:50.592]     }
[13:20:50.592]     ...future.frame <- base::sys.nframe()
[13:20:50.592]     ...future.conditions <- base::list()
[13:20:50.592]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.592]     if (FALSE) {
[13:20:50.592]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.592]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.592]     }
[13:20:50.592]     ...future.result <- base::tryCatch({
[13:20:50.592]         base::withCallingHandlers({
[13:20:50.592]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:20:50.592]                 1))
[13:20:50.592]             future::FutureResult(value = ...future.value$value, 
[13:20:50.592]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.592]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.592]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.592]                     ...future.globalenv.names))
[13:20:50.592]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.592]         }, condition = base::local({
[13:20:50.592]             c <- base::c
[13:20:50.592]             inherits <- base::inherits
[13:20:50.592]             invokeRestart <- base::invokeRestart
[13:20:50.592]             length <- base::length
[13:20:50.592]             list <- base::list
[13:20:50.592]             seq.int <- base::seq.int
[13:20:50.592]             signalCondition <- base::signalCondition
[13:20:50.592]             sys.calls <- base::sys.calls
[13:20:50.592]             `[[` <- base::`[[`
[13:20:50.592]             `+` <- base::`+`
[13:20:50.592]             `<<-` <- base::`<<-`
[13:20:50.592]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.592]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.592]                   3L)]
[13:20:50.592]             }
[13:20:50.592]             function(cond) {
[13:20:50.592]                 is_error <- inherits(cond, "error")
[13:20:50.592]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.592]                   NULL)
[13:20:50.592]                 if (is_error) {
[13:20:50.592]                   sessionInformation <- function() {
[13:20:50.592]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.592]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.592]                       search = base::search(), system = base::Sys.info())
[13:20:50.592]                   }
[13:20:50.592]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.592]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.592]                     cond$call), session = sessionInformation(), 
[13:20:50.592]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.592]                   signalCondition(cond)
[13:20:50.592]                 }
[13:20:50.592]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.592]                 "immediateCondition"))) {
[13:20:50.592]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.592]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.592]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.592]                   if (TRUE && !signal) {
[13:20:50.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.592]                     {
[13:20:50.592]                       inherits <- base::inherits
[13:20:50.592]                       invokeRestart <- base::invokeRestart
[13:20:50.592]                       is.null <- base::is.null
[13:20:50.592]                       muffled <- FALSE
[13:20:50.592]                       if (inherits(cond, "message")) {
[13:20:50.592]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.592]                         if (muffled) 
[13:20:50.592]                           invokeRestart("muffleMessage")
[13:20:50.592]                       }
[13:20:50.592]                       else if (inherits(cond, "warning")) {
[13:20:50.592]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.592]                         if (muffled) 
[13:20:50.592]                           invokeRestart("muffleWarning")
[13:20:50.592]                       }
[13:20:50.592]                       else if (inherits(cond, "condition")) {
[13:20:50.592]                         if (!is.null(pattern)) {
[13:20:50.592]                           computeRestarts <- base::computeRestarts
[13:20:50.592]                           grepl <- base::grepl
[13:20:50.592]                           restarts <- computeRestarts(cond)
[13:20:50.592]                           for (restart in restarts) {
[13:20:50.592]                             name <- restart$name
[13:20:50.592]                             if (is.null(name)) 
[13:20:50.592]                               next
[13:20:50.592]                             if (!grepl(pattern, name)) 
[13:20:50.592]                               next
[13:20:50.592]                             invokeRestart(restart)
[13:20:50.592]                             muffled <- TRUE
[13:20:50.592]                             break
[13:20:50.592]                           }
[13:20:50.592]                         }
[13:20:50.592]                       }
[13:20:50.592]                       invisible(muffled)
[13:20:50.592]                     }
[13:20:50.592]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.592]                   }
[13:20:50.592]                 }
[13:20:50.592]                 else {
[13:20:50.592]                   if (TRUE) {
[13:20:50.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.592]                     {
[13:20:50.592]                       inherits <- base::inherits
[13:20:50.592]                       invokeRestart <- base::invokeRestart
[13:20:50.592]                       is.null <- base::is.null
[13:20:50.592]                       muffled <- FALSE
[13:20:50.592]                       if (inherits(cond, "message")) {
[13:20:50.592]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.592]                         if (muffled) 
[13:20:50.592]                           invokeRestart("muffleMessage")
[13:20:50.592]                       }
[13:20:50.592]                       else if (inherits(cond, "warning")) {
[13:20:50.592]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.592]                         if (muffled) 
[13:20:50.592]                           invokeRestart("muffleWarning")
[13:20:50.592]                       }
[13:20:50.592]                       else if (inherits(cond, "condition")) {
[13:20:50.592]                         if (!is.null(pattern)) {
[13:20:50.592]                           computeRestarts <- base::computeRestarts
[13:20:50.592]                           grepl <- base::grepl
[13:20:50.592]                           restarts <- computeRestarts(cond)
[13:20:50.592]                           for (restart in restarts) {
[13:20:50.592]                             name <- restart$name
[13:20:50.592]                             if (is.null(name)) 
[13:20:50.592]                               next
[13:20:50.592]                             if (!grepl(pattern, name)) 
[13:20:50.592]                               next
[13:20:50.592]                             invokeRestart(restart)
[13:20:50.592]                             muffled <- TRUE
[13:20:50.592]                             break
[13:20:50.592]                           }
[13:20:50.592]                         }
[13:20:50.592]                       }
[13:20:50.592]                       invisible(muffled)
[13:20:50.592]                     }
[13:20:50.592]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.592]                   }
[13:20:50.592]                 }
[13:20:50.592]             }
[13:20:50.592]         }))
[13:20:50.592]     }, error = function(ex) {
[13:20:50.592]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.592]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.592]                 ...future.rng), started = ...future.startTime, 
[13:20:50.592]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.592]             version = "1.8"), class = "FutureResult")
[13:20:50.592]     }, finally = {
[13:20:50.592]         if (!identical(...future.workdir, getwd())) 
[13:20:50.592]             setwd(...future.workdir)
[13:20:50.592]         {
[13:20:50.592]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.592]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.592]             }
[13:20:50.592]             base::options(...future.oldOptions)
[13:20:50.592]             if (.Platform$OS.type == "windows") {
[13:20:50.592]                 old_names <- names(...future.oldEnvVars)
[13:20:50.592]                 envs <- base::Sys.getenv()
[13:20:50.592]                 names <- names(envs)
[13:20:50.592]                 common <- intersect(names, old_names)
[13:20:50.592]                 added <- setdiff(names, old_names)
[13:20:50.592]                 removed <- setdiff(old_names, names)
[13:20:50.592]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.592]                   envs[common]]
[13:20:50.592]                 NAMES <- toupper(changed)
[13:20:50.592]                 args <- list()
[13:20:50.592]                 for (kk in seq_along(NAMES)) {
[13:20:50.592]                   name <- changed[[kk]]
[13:20:50.592]                   NAME <- NAMES[[kk]]
[13:20:50.592]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.592]                     next
[13:20:50.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.592]                 }
[13:20:50.592]                 NAMES <- toupper(added)
[13:20:50.592]                 for (kk in seq_along(NAMES)) {
[13:20:50.592]                   name <- added[[kk]]
[13:20:50.592]                   NAME <- NAMES[[kk]]
[13:20:50.592]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.592]                     next
[13:20:50.592]                   args[[name]] <- ""
[13:20:50.592]                 }
[13:20:50.592]                 NAMES <- toupper(removed)
[13:20:50.592]                 for (kk in seq_along(NAMES)) {
[13:20:50.592]                   name <- removed[[kk]]
[13:20:50.592]                   NAME <- NAMES[[kk]]
[13:20:50.592]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.592]                     next
[13:20:50.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.592]                 }
[13:20:50.592]                 if (length(args) > 0) 
[13:20:50.592]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.592]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.592]             }
[13:20:50.592]             else {
[13:20:50.592]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.592]             }
[13:20:50.592]             {
[13:20:50.592]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.592]                   0L) {
[13:20:50.592]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.592]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.592]                   base::options(opts)
[13:20:50.592]                 }
[13:20:50.592]                 {
[13:20:50.592]                   {
[13:20:50.592]                     NULL
[13:20:50.592]                     RNGkind("Mersenne-Twister")
[13:20:50.592]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.592]                       inherits = FALSE)
[13:20:50.592]                   }
[13:20:50.592]                   options(future.plan = NULL)
[13:20:50.592]                   if (is.na(NA_character_)) 
[13:20:50.592]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.592]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.592]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.592]                   {
[13:20:50.592]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.592]                     if (!future$lazy) 
[13:20:50.592]                       future <- run(future)
[13:20:50.592]                     invisible(future)
[13:20:50.592]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.592]                 }
[13:20:50.592]             }
[13:20:50.592]         }
[13:20:50.592]     })
[13:20:50.592]     if (TRUE) {
[13:20:50.592]         base::sink(type = "output", split = FALSE)
[13:20:50.592]         if (TRUE) {
[13:20:50.592]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.592]         }
[13:20:50.592]         else {
[13:20:50.592]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.592]         }
[13:20:50.592]         base::close(...future.stdout)
[13:20:50.592]         ...future.stdout <- NULL
[13:20:50.592]     }
[13:20:50.592]     ...future.result$conditions <- ...future.conditions
[13:20:50.592]     ...future.result$finished <- base::Sys.time()
[13:20:50.592]     ...future.result
[13:20:50.592] }
[13:20:50.594] assign_globals() ...
[13:20:50.594] List of 1
[13:20:50.594]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x558de06f9400> 
[13:20:50.594]  - attr(*, "where")=List of 1
[13:20:50.594]   ..$ a:<environment: R_EmptyEnv> 
[13:20:50.594]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.594]  - attr(*, "resolved")= logi TRUE
[13:20:50.594]  - attr(*, "total_size")= num 1596216
[13:20:50.594]  - attr(*, "already-done")= logi TRUE
[13:20:50.596] - copied ‘a’ to environment
[13:20:50.596] assign_globals() ... done
[13:20:50.597] plan(): Setting new future strategy stack:
[13:20:50.597] List of future strategies:
[13:20:50.597] 1. sequential:
[13:20:50.597]    - args: function (..., envir = parent.frame())
[13:20:50.597]    - tweaked: FALSE
[13:20:50.597]    - call: NULL
[13:20:50.597] plan(): nbrOfWorkers() = 1
[13:20:50.598] plan(): Setting new future strategy stack:
[13:20:50.598] List of future strategies:
[13:20:50.598] 1. sequential:
[13:20:50.598]    - args: function (..., envir = parent.frame())
[13:20:50.598]    - tweaked: FALSE
[13:20:50.598]    - call: plan(strategy)
[13:20:50.599] plan(): nbrOfWorkers() = 1
[13:20:50.599] SequentialFuture started (and completed)
[13:20:50.599] - Launch lazy future ... done
[13:20:50.599] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.599] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.600] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:50.600] 
[13:20:50.600] Searching for globals ... DONE
[13:20:50.600] - globals: [0] <none>
[13:20:50.600] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.602] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.602] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:50.603] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:50.603] Searching for globals ... DONE
[13:20:50.603] Resolving globals: TRUE
[13:20:50.603] Resolving any globals that are futures ...
[13:20:50.603] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:50.603] Resolving any globals that are futures ... DONE
[13:20:50.604] Resolving futures part of globals (recursively) ...
[13:20:50.604] resolve() on list ...
[13:20:50.604]  recursive: 99
[13:20:50.604]  length: 1
[13:20:50.604]  elements: ‘a’
[13:20:50.604] run() for ‘Future’ ...
[13:20:50.604] - state: ‘created’
[13:20:50.604] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.605] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.605] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.605]   - Field: ‘label’
[13:20:50.605]   - Field: ‘local’
[13:20:50.605]   - Field: ‘owner’
[13:20:50.605]   - Field: ‘envir’
[13:20:50.605]   - Field: ‘packages’
[13:20:50.605]   - Field: ‘gc’
[13:20:50.606]   - Field: ‘conditions’
[13:20:50.606]   - Field: ‘expr’
[13:20:50.606]   - Field: ‘uuid’
[13:20:50.606]   - Field: ‘seed’
[13:20:50.606]   - Field: ‘version’
[13:20:50.606]   - Field: ‘result’
[13:20:50.606]   - Field: ‘asynchronous’
[13:20:50.606]   - Field: ‘calls’
[13:20:50.606]   - Field: ‘globals’
[13:20:50.606]   - Field: ‘stdout’
[13:20:50.606]   - Field: ‘earlySignal’
[13:20:50.607]   - Field: ‘lazy’
[13:20:50.607]   - Field: ‘state’
[13:20:50.607] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.607] - Launch lazy future ...
[13:20:50.607] Packages needed by the future expression (n = 0): <none>
[13:20:50.607] Packages needed by future strategies (n = 0): <none>
[13:20:50.608] {
[13:20:50.608]     {
[13:20:50.608]         {
[13:20:50.608]             ...future.startTime <- base::Sys.time()
[13:20:50.608]             {
[13:20:50.608]                 {
[13:20:50.608]                   {
[13:20:50.608]                     base::local({
[13:20:50.608]                       has_future <- base::requireNamespace("future", 
[13:20:50.608]                         quietly = TRUE)
[13:20:50.608]                       if (has_future) {
[13:20:50.608]                         ns <- base::getNamespace("future")
[13:20:50.608]                         version <- ns[[".package"]][["version"]]
[13:20:50.608]                         if (is.null(version)) 
[13:20:50.608]                           version <- utils::packageVersion("future")
[13:20:50.608]                       }
[13:20:50.608]                       else {
[13:20:50.608]                         version <- NULL
[13:20:50.608]                       }
[13:20:50.608]                       if (!has_future || version < "1.8.0") {
[13:20:50.608]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.608]                           "", base::R.version$version.string), 
[13:20:50.608]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.608]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.608]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.608]                             "release", "version")], collapse = " "), 
[13:20:50.608]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.608]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.608]                           info)
[13:20:50.608]                         info <- base::paste(info, collapse = "; ")
[13:20:50.608]                         if (!has_future) {
[13:20:50.608]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.608]                             info)
[13:20:50.608]                         }
[13:20:50.608]                         else {
[13:20:50.608]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.608]                             info, version)
[13:20:50.608]                         }
[13:20:50.608]                         base::stop(msg)
[13:20:50.608]                       }
[13:20:50.608]                     })
[13:20:50.608]                   }
[13:20:50.608]                   options(future.plan = NULL)
[13:20:50.608]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.608]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.608]                 }
[13:20:50.608]                 ...future.workdir <- getwd()
[13:20:50.608]             }
[13:20:50.608]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.608]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.608]         }
[13:20:50.608]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.608]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:50.608]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.608]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.608]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.608]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.608]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.608]             base::names(...future.oldOptions))
[13:20:50.608]     }
[13:20:50.608]     if (FALSE) {
[13:20:50.608]     }
[13:20:50.608]     else {
[13:20:50.608]         if (TRUE) {
[13:20:50.608]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.608]                 open = "w")
[13:20:50.608]         }
[13:20:50.608]         else {
[13:20:50.608]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.608]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.608]         }
[13:20:50.608]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.608]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.608]             base::sink(type = "output", split = FALSE)
[13:20:50.608]             base::close(...future.stdout)
[13:20:50.608]         }, add = TRUE)
[13:20:50.608]     }
[13:20:50.608]     ...future.frame <- base::sys.nframe()
[13:20:50.608]     ...future.conditions <- base::list()
[13:20:50.608]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.608]     if (FALSE) {
[13:20:50.608]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.608]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.608]     }
[13:20:50.608]     ...future.result <- base::tryCatch({
[13:20:50.608]         base::withCallingHandlers({
[13:20:50.608]             ...future.value <- base::withVisible(base::local(1))
[13:20:50.608]             future::FutureResult(value = ...future.value$value, 
[13:20:50.608]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.608]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.608]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.608]                     ...future.globalenv.names))
[13:20:50.608]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.608]         }, condition = base::local({
[13:20:50.608]             c <- base::c
[13:20:50.608]             inherits <- base::inherits
[13:20:50.608]             invokeRestart <- base::invokeRestart
[13:20:50.608]             length <- base::length
[13:20:50.608]             list <- base::list
[13:20:50.608]             seq.int <- base::seq.int
[13:20:50.608]             signalCondition <- base::signalCondition
[13:20:50.608]             sys.calls <- base::sys.calls
[13:20:50.608]             `[[` <- base::`[[`
[13:20:50.608]             `+` <- base::`+`
[13:20:50.608]             `<<-` <- base::`<<-`
[13:20:50.608]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.608]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.608]                   3L)]
[13:20:50.608]             }
[13:20:50.608]             function(cond) {
[13:20:50.608]                 is_error <- inherits(cond, "error")
[13:20:50.608]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.608]                   NULL)
[13:20:50.608]                 if (is_error) {
[13:20:50.608]                   sessionInformation <- function() {
[13:20:50.608]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.608]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.608]                       search = base::search(), system = base::Sys.info())
[13:20:50.608]                   }
[13:20:50.608]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.608]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.608]                     cond$call), session = sessionInformation(), 
[13:20:50.608]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.608]                   signalCondition(cond)
[13:20:50.608]                 }
[13:20:50.608]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.608]                 "immediateCondition"))) {
[13:20:50.608]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.608]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.608]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.608]                   if (TRUE && !signal) {
[13:20:50.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.608]                     {
[13:20:50.608]                       inherits <- base::inherits
[13:20:50.608]                       invokeRestart <- base::invokeRestart
[13:20:50.608]                       is.null <- base::is.null
[13:20:50.608]                       muffled <- FALSE
[13:20:50.608]                       if (inherits(cond, "message")) {
[13:20:50.608]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.608]                         if (muffled) 
[13:20:50.608]                           invokeRestart("muffleMessage")
[13:20:50.608]                       }
[13:20:50.608]                       else if (inherits(cond, "warning")) {
[13:20:50.608]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.608]                         if (muffled) 
[13:20:50.608]                           invokeRestart("muffleWarning")
[13:20:50.608]                       }
[13:20:50.608]                       else if (inherits(cond, "condition")) {
[13:20:50.608]                         if (!is.null(pattern)) {
[13:20:50.608]                           computeRestarts <- base::computeRestarts
[13:20:50.608]                           grepl <- base::grepl
[13:20:50.608]                           restarts <- computeRestarts(cond)
[13:20:50.608]                           for (restart in restarts) {
[13:20:50.608]                             name <- restart$name
[13:20:50.608]                             if (is.null(name)) 
[13:20:50.608]                               next
[13:20:50.608]                             if (!grepl(pattern, name)) 
[13:20:50.608]                               next
[13:20:50.608]                             invokeRestart(restart)
[13:20:50.608]                             muffled <- TRUE
[13:20:50.608]                             break
[13:20:50.608]                           }
[13:20:50.608]                         }
[13:20:50.608]                       }
[13:20:50.608]                       invisible(muffled)
[13:20:50.608]                     }
[13:20:50.608]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.608]                   }
[13:20:50.608]                 }
[13:20:50.608]                 else {
[13:20:50.608]                   if (TRUE) {
[13:20:50.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.608]                     {
[13:20:50.608]                       inherits <- base::inherits
[13:20:50.608]                       invokeRestart <- base::invokeRestart
[13:20:50.608]                       is.null <- base::is.null
[13:20:50.608]                       muffled <- FALSE
[13:20:50.608]                       if (inherits(cond, "message")) {
[13:20:50.608]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.608]                         if (muffled) 
[13:20:50.608]                           invokeRestart("muffleMessage")
[13:20:50.608]                       }
[13:20:50.608]                       else if (inherits(cond, "warning")) {
[13:20:50.608]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.608]                         if (muffled) 
[13:20:50.608]                           invokeRestart("muffleWarning")
[13:20:50.608]                       }
[13:20:50.608]                       else if (inherits(cond, "condition")) {
[13:20:50.608]                         if (!is.null(pattern)) {
[13:20:50.608]                           computeRestarts <- base::computeRestarts
[13:20:50.608]                           grepl <- base::grepl
[13:20:50.608]                           restarts <- computeRestarts(cond)
[13:20:50.608]                           for (restart in restarts) {
[13:20:50.608]                             name <- restart$name
[13:20:50.608]                             if (is.null(name)) 
[13:20:50.608]                               next
[13:20:50.608]                             if (!grepl(pattern, name)) 
[13:20:50.608]                               next
[13:20:50.608]                             invokeRestart(restart)
[13:20:50.608]                             muffled <- TRUE
[13:20:50.608]                             break
[13:20:50.608]                           }
[13:20:50.608]                         }
[13:20:50.608]                       }
[13:20:50.608]                       invisible(muffled)
[13:20:50.608]                     }
[13:20:50.608]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.608]                   }
[13:20:50.608]                 }
[13:20:50.608]             }
[13:20:50.608]         }))
[13:20:50.608]     }, error = function(ex) {
[13:20:50.608]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.608]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.608]                 ...future.rng), started = ...future.startTime, 
[13:20:50.608]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.608]             version = "1.8"), class = "FutureResult")
[13:20:50.608]     }, finally = {
[13:20:50.608]         if (!identical(...future.workdir, getwd())) 
[13:20:50.608]             setwd(...future.workdir)
[13:20:50.608]         {
[13:20:50.608]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.608]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.608]             }
[13:20:50.608]             base::options(...future.oldOptions)
[13:20:50.608]             if (.Platform$OS.type == "windows") {
[13:20:50.608]                 old_names <- names(...future.oldEnvVars)
[13:20:50.608]                 envs <- base::Sys.getenv()
[13:20:50.608]                 names <- names(envs)
[13:20:50.608]                 common <- intersect(names, old_names)
[13:20:50.608]                 added <- setdiff(names, old_names)
[13:20:50.608]                 removed <- setdiff(old_names, names)
[13:20:50.608]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.608]                   envs[common]]
[13:20:50.608]                 NAMES <- toupper(changed)
[13:20:50.608]                 args <- list()
[13:20:50.608]                 for (kk in seq_along(NAMES)) {
[13:20:50.608]                   name <- changed[[kk]]
[13:20:50.608]                   NAME <- NAMES[[kk]]
[13:20:50.608]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.608]                     next
[13:20:50.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.608]                 }
[13:20:50.608]                 NAMES <- toupper(added)
[13:20:50.608]                 for (kk in seq_along(NAMES)) {
[13:20:50.608]                   name <- added[[kk]]
[13:20:50.608]                   NAME <- NAMES[[kk]]
[13:20:50.608]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.608]                     next
[13:20:50.608]                   args[[name]] <- ""
[13:20:50.608]                 }
[13:20:50.608]                 NAMES <- toupper(removed)
[13:20:50.608]                 for (kk in seq_along(NAMES)) {
[13:20:50.608]                   name <- removed[[kk]]
[13:20:50.608]                   NAME <- NAMES[[kk]]
[13:20:50.608]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.608]                     next
[13:20:50.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.608]                 }
[13:20:50.608]                 if (length(args) > 0) 
[13:20:50.608]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.608]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.608]             }
[13:20:50.608]             else {
[13:20:50.608]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.608]             }
[13:20:50.608]             {
[13:20:50.608]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.608]                   0L) {
[13:20:50.608]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.608]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.608]                   base::options(opts)
[13:20:50.608]                 }
[13:20:50.608]                 {
[13:20:50.608]                   {
[13:20:50.608]                     NULL
[13:20:50.608]                     RNGkind("Mersenne-Twister")
[13:20:50.608]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.608]                       inherits = FALSE)
[13:20:50.608]                   }
[13:20:50.608]                   options(future.plan = NULL)
[13:20:50.608]                   if (is.na(NA_character_)) 
[13:20:50.608]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.608]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.608]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.608]                   {
[13:20:50.608]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.608]                     if (!future$lazy) 
[13:20:50.608]                       future <- run(future)
[13:20:50.608]                     invisible(future)
[13:20:50.608]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.608]                 }
[13:20:50.608]             }
[13:20:50.608]         }
[13:20:50.608]     })
[13:20:50.608]     if (TRUE) {
[13:20:50.608]         base::sink(type = "output", split = FALSE)
[13:20:50.608]         if (TRUE) {
[13:20:50.608]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.608]         }
[13:20:50.608]         else {
[13:20:50.608]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.608]         }
[13:20:50.608]         base::close(...future.stdout)
[13:20:50.608]         ...future.stdout <- NULL
[13:20:50.608]     }
[13:20:50.608]     ...future.result$conditions <- ...future.conditions
[13:20:50.608]     ...future.result$finished <- base::Sys.time()
[13:20:50.608]     ...future.result
[13:20:50.608] }
[13:20:50.609] plan(): Setting new future strategy stack:
[13:20:50.609] List of future strategies:
[13:20:50.609] 1. sequential:
[13:20:50.609]    - args: function (..., envir = parent.frame())
[13:20:50.609]    - tweaked: FALSE
[13:20:50.609]    - call: NULL
[13:20:50.610] plan(): nbrOfWorkers() = 1
[13:20:50.610] plan(): Setting new future strategy stack:
[13:20:50.610] List of future strategies:
[13:20:50.610] 1. sequential:
[13:20:50.610]    - args: function (..., envir = parent.frame())
[13:20:50.610]    - tweaked: FALSE
[13:20:50.610]    - call: plan(strategy)
[13:20:50.611] plan(): nbrOfWorkers() = 1
[13:20:50.611] SequentialFuture started (and completed)
[13:20:50.611] - Launch lazy future ... done
[13:20:50.611] run() for ‘SequentialFuture’ ... done
[13:20:50.611] resolved() for ‘SequentialFuture’ ...
[13:20:50.611] - state: ‘finished’
[13:20:50.612] - run: TRUE
[13:20:50.612] - result: ‘FutureResult’
[13:20:50.612] resolved() for ‘SequentialFuture’ ... done
[13:20:50.612] Future #1
[13:20:50.612] resolved() for ‘SequentialFuture’ ...
[13:20:50.612] - state: ‘finished’
[13:20:50.612] - run: TRUE
[13:20:50.612] - result: ‘FutureResult’
[13:20:50.612] resolved() for ‘SequentialFuture’ ... done
[13:20:50.612] A SequentialFuture was resolved
[13:20:50.613]  length: 0 (resolved future 1)
[13:20:50.613] resolve() on list ... DONE
[13:20:50.613] - globals: [1] ‘a’
[13:20:50.613] Resolving futures part of globals (recursively) ... DONE
[13:20:50.615] The total size of the 1 globals is 1.52 MiB (1596216 bytes)
[13:20:50.615] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.52 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.52 MiB of class ‘environment’)
[13:20:50.615] - globals: [1] ‘a’
[13:20:50.615] - packages: [1] ‘future’
[13:20:50.615] getGlobalsAndPackages() ... DONE
[13:20:50.616] run() for ‘Future’ ...
[13:20:50.616] - state: ‘created’
[13:20:50.616] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.616] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.616] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.616]   - Field: ‘label’
[13:20:50.616]   - Field: ‘local’
[13:20:50.616]   - Field: ‘owner’
[13:20:50.617]   - Field: ‘envir’
[13:20:50.617]   - Field: ‘packages’
[13:20:50.617]   - Field: ‘gc’
[13:20:50.617]   - Field: ‘conditions’
[13:20:50.617]   - Field: ‘expr’
[13:20:50.617]   - Field: ‘uuid’
[13:20:50.617]   - Field: ‘seed’
[13:20:50.617]   - Field: ‘version’
[13:20:50.617]   - Field: ‘result’
[13:20:50.617]   - Field: ‘asynchronous’
[13:20:50.617]   - Field: ‘calls’
[13:20:50.618]   - Field: ‘globals’
[13:20:50.618]   - Field: ‘stdout’
[13:20:50.618]   - Field: ‘earlySignal’
[13:20:50.618]   - Field: ‘lazy’
[13:20:50.618]   - Field: ‘state’
[13:20:50.618] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.618] - Launch lazy future ...
[13:20:50.618] Packages needed by the future expression (n = 1): ‘future’
[13:20:50.618] Packages needed by future strategies (n = 0): <none>
[13:20:50.619] {
[13:20:50.619]     {
[13:20:50.619]         {
[13:20:50.619]             ...future.startTime <- base::Sys.time()
[13:20:50.619]             {
[13:20:50.619]                 {
[13:20:50.619]                   {
[13:20:50.619]                     {
[13:20:50.619]                       base::local({
[13:20:50.619]                         has_future <- base::requireNamespace("future", 
[13:20:50.619]                           quietly = TRUE)
[13:20:50.619]                         if (has_future) {
[13:20:50.619]                           ns <- base::getNamespace("future")
[13:20:50.619]                           version <- ns[[".package"]][["version"]]
[13:20:50.619]                           if (is.null(version)) 
[13:20:50.619]                             version <- utils::packageVersion("future")
[13:20:50.619]                         }
[13:20:50.619]                         else {
[13:20:50.619]                           version <- NULL
[13:20:50.619]                         }
[13:20:50.619]                         if (!has_future || version < "1.8.0") {
[13:20:50.619]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.619]                             "", base::R.version$version.string), 
[13:20:50.619]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:50.619]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.619]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.619]                               "release", "version")], collapse = " "), 
[13:20:50.619]                             hostname = base::Sys.info()[["nodename"]])
[13:20:50.619]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.619]                             info)
[13:20:50.619]                           info <- base::paste(info, collapse = "; ")
[13:20:50.619]                           if (!has_future) {
[13:20:50.619]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.619]                               info)
[13:20:50.619]                           }
[13:20:50.619]                           else {
[13:20:50.619]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.619]                               info, version)
[13:20:50.619]                           }
[13:20:50.619]                           base::stop(msg)
[13:20:50.619]                         }
[13:20:50.619]                       })
[13:20:50.619]                     }
[13:20:50.619]                     base::local({
[13:20:50.619]                       for (pkg in "future") {
[13:20:50.619]                         base::loadNamespace(pkg)
[13:20:50.619]                         base::library(pkg, character.only = TRUE)
[13:20:50.619]                       }
[13:20:50.619]                     })
[13:20:50.619]                   }
[13:20:50.619]                   options(future.plan = NULL)
[13:20:50.619]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.619]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.619]                 }
[13:20:50.619]                 ...future.workdir <- getwd()
[13:20:50.619]             }
[13:20:50.619]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.619]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.619]         }
[13:20:50.619]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.619]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:50.619]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.619]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.619]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.619]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.619]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.619]             base::names(...future.oldOptions))
[13:20:50.619]     }
[13:20:50.619]     if (FALSE) {
[13:20:50.619]     }
[13:20:50.619]     else {
[13:20:50.619]         if (TRUE) {
[13:20:50.619]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.619]                 open = "w")
[13:20:50.619]         }
[13:20:50.619]         else {
[13:20:50.619]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.619]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.619]         }
[13:20:50.619]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.619]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.619]             base::sink(type = "output", split = FALSE)
[13:20:50.619]             base::close(...future.stdout)
[13:20:50.619]         }, add = TRUE)
[13:20:50.619]     }
[13:20:50.619]     ...future.frame <- base::sys.nframe()
[13:20:50.619]     ...future.conditions <- base::list()
[13:20:50.619]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.619]     if (FALSE) {
[13:20:50.619]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.619]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.619]     }
[13:20:50.619]     ...future.result <- base::tryCatch({
[13:20:50.619]         base::withCallingHandlers({
[13:20:50.619]             ...future.value <- base::withVisible(base::local(value(a) + 
[13:20:50.619]                 1))
[13:20:50.619]             future::FutureResult(value = ...future.value$value, 
[13:20:50.619]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.619]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.619]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.619]                     ...future.globalenv.names))
[13:20:50.619]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.619]         }, condition = base::local({
[13:20:50.619]             c <- base::c
[13:20:50.619]             inherits <- base::inherits
[13:20:50.619]             invokeRestart <- base::invokeRestart
[13:20:50.619]             length <- base::length
[13:20:50.619]             list <- base::list
[13:20:50.619]             seq.int <- base::seq.int
[13:20:50.619]             signalCondition <- base::signalCondition
[13:20:50.619]             sys.calls <- base::sys.calls
[13:20:50.619]             `[[` <- base::`[[`
[13:20:50.619]             `+` <- base::`+`
[13:20:50.619]             `<<-` <- base::`<<-`
[13:20:50.619]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.619]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.619]                   3L)]
[13:20:50.619]             }
[13:20:50.619]             function(cond) {
[13:20:50.619]                 is_error <- inherits(cond, "error")
[13:20:50.619]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.619]                   NULL)
[13:20:50.619]                 if (is_error) {
[13:20:50.619]                   sessionInformation <- function() {
[13:20:50.619]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.619]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.619]                       search = base::search(), system = base::Sys.info())
[13:20:50.619]                   }
[13:20:50.619]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.619]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.619]                     cond$call), session = sessionInformation(), 
[13:20:50.619]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.619]                   signalCondition(cond)
[13:20:50.619]                 }
[13:20:50.619]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.619]                 "immediateCondition"))) {
[13:20:50.619]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.619]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.619]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.619]                   if (TRUE && !signal) {
[13:20:50.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.619]                     {
[13:20:50.619]                       inherits <- base::inherits
[13:20:50.619]                       invokeRestart <- base::invokeRestart
[13:20:50.619]                       is.null <- base::is.null
[13:20:50.619]                       muffled <- FALSE
[13:20:50.619]                       if (inherits(cond, "message")) {
[13:20:50.619]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.619]                         if (muffled) 
[13:20:50.619]                           invokeRestart("muffleMessage")
[13:20:50.619]                       }
[13:20:50.619]                       else if (inherits(cond, "warning")) {
[13:20:50.619]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.619]                         if (muffled) 
[13:20:50.619]                           invokeRestart("muffleWarning")
[13:20:50.619]                       }
[13:20:50.619]                       else if (inherits(cond, "condition")) {
[13:20:50.619]                         if (!is.null(pattern)) {
[13:20:50.619]                           computeRestarts <- base::computeRestarts
[13:20:50.619]                           grepl <- base::grepl
[13:20:50.619]                           restarts <- computeRestarts(cond)
[13:20:50.619]                           for (restart in restarts) {
[13:20:50.619]                             name <- restart$name
[13:20:50.619]                             if (is.null(name)) 
[13:20:50.619]                               next
[13:20:50.619]                             if (!grepl(pattern, name)) 
[13:20:50.619]                               next
[13:20:50.619]                             invokeRestart(restart)
[13:20:50.619]                             muffled <- TRUE
[13:20:50.619]                             break
[13:20:50.619]                           }
[13:20:50.619]                         }
[13:20:50.619]                       }
[13:20:50.619]                       invisible(muffled)
[13:20:50.619]                     }
[13:20:50.619]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.619]                   }
[13:20:50.619]                 }
[13:20:50.619]                 else {
[13:20:50.619]                   if (TRUE) {
[13:20:50.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.619]                     {
[13:20:50.619]                       inherits <- base::inherits
[13:20:50.619]                       invokeRestart <- base::invokeRestart
[13:20:50.619]                       is.null <- base::is.null
[13:20:50.619]                       muffled <- FALSE
[13:20:50.619]                       if (inherits(cond, "message")) {
[13:20:50.619]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.619]                         if (muffled) 
[13:20:50.619]                           invokeRestart("muffleMessage")
[13:20:50.619]                       }
[13:20:50.619]                       else if (inherits(cond, "warning")) {
[13:20:50.619]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.619]                         if (muffled) 
[13:20:50.619]                           invokeRestart("muffleWarning")
[13:20:50.619]                       }
[13:20:50.619]                       else if (inherits(cond, "condition")) {
[13:20:50.619]                         if (!is.null(pattern)) {
[13:20:50.619]                           computeRestarts <- base::computeRestarts
[13:20:50.619]                           grepl <- base::grepl
[13:20:50.619]                           restarts <- computeRestarts(cond)
[13:20:50.619]                           for (restart in restarts) {
[13:20:50.619]                             name <- restart$name
[13:20:50.619]                             if (is.null(name)) 
[13:20:50.619]                               next
[13:20:50.619]                             if (!grepl(pattern, name)) 
[13:20:50.619]                               next
[13:20:50.619]                             invokeRestart(restart)
[13:20:50.619]                             muffled <- TRUE
[13:20:50.619]                             break
[13:20:50.619]                           }
[13:20:50.619]                         }
[13:20:50.619]                       }
[13:20:50.619]                       invisible(muffled)
[13:20:50.619]                     }
[13:20:50.619]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.619]                   }
[13:20:50.619]                 }
[13:20:50.619]             }
[13:20:50.619]         }))
[13:20:50.619]     }, error = function(ex) {
[13:20:50.619]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.619]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.619]                 ...future.rng), started = ...future.startTime, 
[13:20:50.619]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.619]             version = "1.8"), class = "FutureResult")
[13:20:50.619]     }, finally = {
[13:20:50.619]         if (!identical(...future.workdir, getwd())) 
[13:20:50.619]             setwd(...future.workdir)
[13:20:50.619]         {
[13:20:50.619]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.619]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.619]             }
[13:20:50.619]             base::options(...future.oldOptions)
[13:20:50.619]             if (.Platform$OS.type == "windows") {
[13:20:50.619]                 old_names <- names(...future.oldEnvVars)
[13:20:50.619]                 envs <- base::Sys.getenv()
[13:20:50.619]                 names <- names(envs)
[13:20:50.619]                 common <- intersect(names, old_names)
[13:20:50.619]                 added <- setdiff(names, old_names)
[13:20:50.619]                 removed <- setdiff(old_names, names)
[13:20:50.619]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.619]                   envs[common]]
[13:20:50.619]                 NAMES <- toupper(changed)
[13:20:50.619]                 args <- list()
[13:20:50.619]                 for (kk in seq_along(NAMES)) {
[13:20:50.619]                   name <- changed[[kk]]
[13:20:50.619]                   NAME <- NAMES[[kk]]
[13:20:50.619]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.619]                     next
[13:20:50.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.619]                 }
[13:20:50.619]                 NAMES <- toupper(added)
[13:20:50.619]                 for (kk in seq_along(NAMES)) {
[13:20:50.619]                   name <- added[[kk]]
[13:20:50.619]                   NAME <- NAMES[[kk]]
[13:20:50.619]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.619]                     next
[13:20:50.619]                   args[[name]] <- ""
[13:20:50.619]                 }
[13:20:50.619]                 NAMES <- toupper(removed)
[13:20:50.619]                 for (kk in seq_along(NAMES)) {
[13:20:50.619]                   name <- removed[[kk]]
[13:20:50.619]                   NAME <- NAMES[[kk]]
[13:20:50.619]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.619]                     next
[13:20:50.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.619]                 }
[13:20:50.619]                 if (length(args) > 0) 
[13:20:50.619]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.619]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.619]             }
[13:20:50.619]             else {
[13:20:50.619]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.619]             }
[13:20:50.619]             {
[13:20:50.619]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.619]                   0L) {
[13:20:50.619]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.619]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.619]                   base::options(opts)
[13:20:50.619]                 }
[13:20:50.619]                 {
[13:20:50.619]                   {
[13:20:50.619]                     NULL
[13:20:50.619]                     RNGkind("Mersenne-Twister")
[13:20:50.619]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.619]                       inherits = FALSE)
[13:20:50.619]                   }
[13:20:50.619]                   options(future.plan = NULL)
[13:20:50.619]                   if (is.na(NA_character_)) 
[13:20:50.619]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.619]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.619]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.619]                   {
[13:20:50.619]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.619]                     if (!future$lazy) 
[13:20:50.619]                       future <- run(future)
[13:20:50.619]                     invisible(future)
[13:20:50.619]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.619]                 }
[13:20:50.619]             }
[13:20:50.619]         }
[13:20:50.619]     })
[13:20:50.619]     if (TRUE) {
[13:20:50.619]         base::sink(type = "output", split = FALSE)
[13:20:50.619]         if (TRUE) {
[13:20:50.619]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.619]         }
[13:20:50.619]         else {
[13:20:50.619]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.619]         }
[13:20:50.619]         base::close(...future.stdout)
[13:20:50.619]         ...future.stdout <- NULL
[13:20:50.619]     }
[13:20:50.619]     ...future.result$conditions <- ...future.conditions
[13:20:50.619]     ...future.result$finished <- base::Sys.time()
[13:20:50.619]     ...future.result
[13:20:50.619] }
[13:20:50.620] assign_globals() ...
[13:20:50.621] List of 1
[13:20:50.621]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x558ddedf6c00> 
[13:20:50.621]  - attr(*, "where")=List of 1
[13:20:50.621]   ..$ a:<environment: R_EmptyEnv> 
[13:20:50.621]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.621]  - attr(*, "resolved")= logi TRUE
[13:20:50.621]  - attr(*, "total_size")= num 1596216
[13:20:50.621]  - attr(*, "already-done")= logi TRUE
[13:20:50.623] - copied ‘a’ to environment
[13:20:50.623] assign_globals() ... done
[13:20:50.623] plan(): Setting new future strategy stack:
[13:20:50.624] List of future strategies:
[13:20:50.624] 1. sequential:
[13:20:50.624]    - args: function (..., envir = parent.frame())
[13:20:50.624]    - tweaked: FALSE
[13:20:50.624]    - call: NULL
[13:20:50.624] plan(): nbrOfWorkers() = 1
[13:20:50.625] plan(): Setting new future strategy stack:
[13:20:50.625] List of future strategies:
[13:20:50.625] 1. sequential:
[13:20:50.625]    - args: function (..., envir = parent.frame())
[13:20:50.625]    - tweaked: FALSE
[13:20:50.625]    - call: plan(strategy)
[13:20:50.625] plan(): nbrOfWorkers() = 1
[13:20:50.625] SequentialFuture started (and completed)
[13:20:50.625] - Launch lazy future ... done
[13:20:50.626] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.626] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.626] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:50.627] - globals found: [2] ‘{’, ‘pkg’
[13:20:50.627] Searching for globals ... DONE
[13:20:50.627] Resolving globals: TRUE
[13:20:50.627] Resolving any globals that are futures ...
[13:20:50.627] - globals: [2] ‘{’, ‘pkg’
[13:20:50.627] Resolving any globals that are futures ... DONE
[13:20:50.628] Resolving futures part of globals (recursively) ...
[13:20:50.628] resolve() on list ...
[13:20:50.628]  recursive: 99
[13:20:50.628]  length: 1
[13:20:50.628]  elements: ‘pkg’
[13:20:50.628]  length: 0 (resolved future 1)
[13:20:50.628] resolve() on list ... DONE
[13:20:50.630] - globals: [1] ‘pkg’
[13:20:50.630] Resolving futures part of globals (recursively) ... DONE
[13:20:50.630] The total size of the 1 globals is 112 bytes (112 bytes)
[13:20:50.630] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[13:20:50.630] - globals: [1] ‘pkg’
[13:20:50.631] 
[13:20:50.631] getGlobalsAndPackages() ... DONE
[13:20:50.631] Packages needed by the future expression (n = 0): <none>
[13:20:50.631] Packages needed by future strategies (n = 0): <none>
[13:20:50.632] {
[13:20:50.632]     {
[13:20:50.632]         {
[13:20:50.632]             ...future.startTime <- base::Sys.time()
[13:20:50.632]             {
[13:20:50.632]                 {
[13:20:50.632]                   {
[13:20:50.632]                     base::local({
[13:20:50.632]                       has_future <- base::requireNamespace("future", 
[13:20:50.632]                         quietly = TRUE)
[13:20:50.632]                       if (has_future) {
[13:20:50.632]                         ns <- base::getNamespace("future")
[13:20:50.632]                         version <- ns[[".package"]][["version"]]
[13:20:50.632]                         if (is.null(version)) 
[13:20:50.632]                           version <- utils::packageVersion("future")
[13:20:50.632]                       }
[13:20:50.632]                       else {
[13:20:50.632]                         version <- NULL
[13:20:50.632]                       }
[13:20:50.632]                       if (!has_future || version < "1.8.0") {
[13:20:50.632]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.632]                           "", base::R.version$version.string), 
[13:20:50.632]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.632]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.632]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.632]                             "release", "version")], collapse = " "), 
[13:20:50.632]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.632]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.632]                           info)
[13:20:50.632]                         info <- base::paste(info, collapse = "; ")
[13:20:50.632]                         if (!has_future) {
[13:20:50.632]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.632]                             info)
[13:20:50.632]                         }
[13:20:50.632]                         else {
[13:20:50.632]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.632]                             info, version)
[13:20:50.632]                         }
[13:20:50.632]                         base::stop(msg)
[13:20:50.632]                       }
[13:20:50.632]                     })
[13:20:50.632]                   }
[13:20:50.632]                   options(future.plan = NULL)
[13:20:50.632]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.632]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.632]                 }
[13:20:50.632]                 ...future.workdir <- getwd()
[13:20:50.632]             }
[13:20:50.632]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.632]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.632]         }
[13:20:50.632]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.632]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:50.632]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.632]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.632]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.632]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.632]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.632]             base::names(...future.oldOptions))
[13:20:50.632]     }
[13:20:50.632]     if (FALSE) {
[13:20:50.632]     }
[13:20:50.632]     else {
[13:20:50.632]         if (TRUE) {
[13:20:50.632]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.632]                 open = "w")
[13:20:50.632]         }
[13:20:50.632]         else {
[13:20:50.632]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.632]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.632]         }
[13:20:50.632]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.632]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.632]             base::sink(type = "output", split = FALSE)
[13:20:50.632]             base::close(...future.stdout)
[13:20:50.632]         }, add = TRUE)
[13:20:50.632]     }
[13:20:50.632]     ...future.frame <- base::sys.nframe()
[13:20:50.632]     ...future.conditions <- base::list()
[13:20:50.632]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.632]     if (FALSE) {
[13:20:50.632]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.632]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.632]     }
[13:20:50.632]     ...future.result <- base::tryCatch({
[13:20:50.632]         base::withCallingHandlers({
[13:20:50.632]             ...future.value <- base::withVisible(base::local({
[13:20:50.632]                 pkg
[13:20:50.632]             }))
[13:20:50.632]             future::FutureResult(value = ...future.value$value, 
[13:20:50.632]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.632]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.632]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.632]                     ...future.globalenv.names))
[13:20:50.632]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.632]         }, condition = base::local({
[13:20:50.632]             c <- base::c
[13:20:50.632]             inherits <- base::inherits
[13:20:50.632]             invokeRestart <- base::invokeRestart
[13:20:50.632]             length <- base::length
[13:20:50.632]             list <- base::list
[13:20:50.632]             seq.int <- base::seq.int
[13:20:50.632]             signalCondition <- base::signalCondition
[13:20:50.632]             sys.calls <- base::sys.calls
[13:20:50.632]             `[[` <- base::`[[`
[13:20:50.632]             `+` <- base::`+`
[13:20:50.632]             `<<-` <- base::`<<-`
[13:20:50.632]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.632]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.632]                   3L)]
[13:20:50.632]             }
[13:20:50.632]             function(cond) {
[13:20:50.632]                 is_error <- inherits(cond, "error")
[13:20:50.632]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.632]                   NULL)
[13:20:50.632]                 if (is_error) {
[13:20:50.632]                   sessionInformation <- function() {
[13:20:50.632]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.632]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.632]                       search = base::search(), system = base::Sys.info())
[13:20:50.632]                   }
[13:20:50.632]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.632]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.632]                     cond$call), session = sessionInformation(), 
[13:20:50.632]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.632]                   signalCondition(cond)
[13:20:50.632]                 }
[13:20:50.632]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.632]                 "immediateCondition"))) {
[13:20:50.632]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.632]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.632]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.632]                   if (TRUE && !signal) {
[13:20:50.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.632]                     {
[13:20:50.632]                       inherits <- base::inherits
[13:20:50.632]                       invokeRestart <- base::invokeRestart
[13:20:50.632]                       is.null <- base::is.null
[13:20:50.632]                       muffled <- FALSE
[13:20:50.632]                       if (inherits(cond, "message")) {
[13:20:50.632]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.632]                         if (muffled) 
[13:20:50.632]                           invokeRestart("muffleMessage")
[13:20:50.632]                       }
[13:20:50.632]                       else if (inherits(cond, "warning")) {
[13:20:50.632]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.632]                         if (muffled) 
[13:20:50.632]                           invokeRestart("muffleWarning")
[13:20:50.632]                       }
[13:20:50.632]                       else if (inherits(cond, "condition")) {
[13:20:50.632]                         if (!is.null(pattern)) {
[13:20:50.632]                           computeRestarts <- base::computeRestarts
[13:20:50.632]                           grepl <- base::grepl
[13:20:50.632]                           restarts <- computeRestarts(cond)
[13:20:50.632]                           for (restart in restarts) {
[13:20:50.632]                             name <- restart$name
[13:20:50.632]                             if (is.null(name)) 
[13:20:50.632]                               next
[13:20:50.632]                             if (!grepl(pattern, name)) 
[13:20:50.632]                               next
[13:20:50.632]                             invokeRestart(restart)
[13:20:50.632]                             muffled <- TRUE
[13:20:50.632]                             break
[13:20:50.632]                           }
[13:20:50.632]                         }
[13:20:50.632]                       }
[13:20:50.632]                       invisible(muffled)
[13:20:50.632]                     }
[13:20:50.632]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.632]                   }
[13:20:50.632]                 }
[13:20:50.632]                 else {
[13:20:50.632]                   if (TRUE) {
[13:20:50.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.632]                     {
[13:20:50.632]                       inherits <- base::inherits
[13:20:50.632]                       invokeRestart <- base::invokeRestart
[13:20:50.632]                       is.null <- base::is.null
[13:20:50.632]                       muffled <- FALSE
[13:20:50.632]                       if (inherits(cond, "message")) {
[13:20:50.632]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.632]                         if (muffled) 
[13:20:50.632]                           invokeRestart("muffleMessage")
[13:20:50.632]                       }
[13:20:50.632]                       else if (inherits(cond, "warning")) {
[13:20:50.632]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.632]                         if (muffled) 
[13:20:50.632]                           invokeRestart("muffleWarning")
[13:20:50.632]                       }
[13:20:50.632]                       else if (inherits(cond, "condition")) {
[13:20:50.632]                         if (!is.null(pattern)) {
[13:20:50.632]                           computeRestarts <- base::computeRestarts
[13:20:50.632]                           grepl <- base::grepl
[13:20:50.632]                           restarts <- computeRestarts(cond)
[13:20:50.632]                           for (restart in restarts) {
[13:20:50.632]                             name <- restart$name
[13:20:50.632]                             if (is.null(name)) 
[13:20:50.632]                               next
[13:20:50.632]                             if (!grepl(pattern, name)) 
[13:20:50.632]                               next
[13:20:50.632]                             invokeRestart(restart)
[13:20:50.632]                             muffled <- TRUE
[13:20:50.632]                             break
[13:20:50.632]                           }
[13:20:50.632]                         }
[13:20:50.632]                       }
[13:20:50.632]                       invisible(muffled)
[13:20:50.632]                     }
[13:20:50.632]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.632]                   }
[13:20:50.632]                 }
[13:20:50.632]             }
[13:20:50.632]         }))
[13:20:50.632]     }, error = function(ex) {
[13:20:50.632]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.632]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.632]                 ...future.rng), started = ...future.startTime, 
[13:20:50.632]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.632]             version = "1.8"), class = "FutureResult")
[13:20:50.632]     }, finally = {
[13:20:50.632]         if (!identical(...future.workdir, getwd())) 
[13:20:50.632]             setwd(...future.workdir)
[13:20:50.632]         {
[13:20:50.632]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.632]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.632]             }
[13:20:50.632]             base::options(...future.oldOptions)
[13:20:50.632]             if (.Platform$OS.type == "windows") {
[13:20:50.632]                 old_names <- names(...future.oldEnvVars)
[13:20:50.632]                 envs <- base::Sys.getenv()
[13:20:50.632]                 names <- names(envs)
[13:20:50.632]                 common <- intersect(names, old_names)
[13:20:50.632]                 added <- setdiff(names, old_names)
[13:20:50.632]                 removed <- setdiff(old_names, names)
[13:20:50.632]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.632]                   envs[common]]
[13:20:50.632]                 NAMES <- toupper(changed)
[13:20:50.632]                 args <- list()
[13:20:50.632]                 for (kk in seq_along(NAMES)) {
[13:20:50.632]                   name <- changed[[kk]]
[13:20:50.632]                   NAME <- NAMES[[kk]]
[13:20:50.632]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.632]                     next
[13:20:50.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.632]                 }
[13:20:50.632]                 NAMES <- toupper(added)
[13:20:50.632]                 for (kk in seq_along(NAMES)) {
[13:20:50.632]                   name <- added[[kk]]
[13:20:50.632]                   NAME <- NAMES[[kk]]
[13:20:50.632]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.632]                     next
[13:20:50.632]                   args[[name]] <- ""
[13:20:50.632]                 }
[13:20:50.632]                 NAMES <- toupper(removed)
[13:20:50.632]                 for (kk in seq_along(NAMES)) {
[13:20:50.632]                   name <- removed[[kk]]
[13:20:50.632]                   NAME <- NAMES[[kk]]
[13:20:50.632]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.632]                     next
[13:20:50.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.632]                 }
[13:20:50.632]                 if (length(args) > 0) 
[13:20:50.632]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.632]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.632]             }
[13:20:50.632]             else {
[13:20:50.632]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.632]             }
[13:20:50.632]             {
[13:20:50.632]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.632]                   0L) {
[13:20:50.632]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.632]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.632]                   base::options(opts)
[13:20:50.632]                 }
[13:20:50.632]                 {
[13:20:50.632]                   {
[13:20:50.632]                     NULL
[13:20:50.632]                     RNGkind("Mersenne-Twister")
[13:20:50.632]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.632]                       inherits = FALSE)
[13:20:50.632]                   }
[13:20:50.632]                   options(future.plan = NULL)
[13:20:50.632]                   if (is.na(NA_character_)) 
[13:20:50.632]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.632]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.632]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.632]                   {
[13:20:50.632]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.632]                     if (!future$lazy) 
[13:20:50.632]                       future <- run(future)
[13:20:50.632]                     invisible(future)
[13:20:50.632]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.632]                 }
[13:20:50.632]             }
[13:20:50.632]         }
[13:20:50.632]     })
[13:20:50.632]     if (TRUE) {
[13:20:50.632]         base::sink(type = "output", split = FALSE)
[13:20:50.632]         if (TRUE) {
[13:20:50.632]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.632]         }
[13:20:50.632]         else {
[13:20:50.632]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.632]         }
[13:20:50.632]         base::close(...future.stdout)
[13:20:50.632]         ...future.stdout <- NULL
[13:20:50.632]     }
[13:20:50.632]     ...future.result$conditions <- ...future.conditions
[13:20:50.632]     ...future.result$finished <- base::Sys.time()
[13:20:50.632]     ...future.result
[13:20:50.632] }
[13:20:50.633] assign_globals() ...
[13:20:50.633] List of 1
[13:20:50.633]  $ pkg: chr "foo"
[13:20:50.633]  - attr(*, "where")=List of 1
[13:20:50.633]   ..$ pkg:<environment: R_EmptyEnv> 
[13:20:50.633]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.633]  - attr(*, "resolved")= logi TRUE
[13:20:50.633]  - attr(*, "total_size")= num 112
[13:20:50.635] - copied ‘pkg’ to environment
[13:20:50.635] assign_globals() ... done
[13:20:50.636] plan(): Setting new future strategy stack:
[13:20:50.636] List of future strategies:
[13:20:50.636] 1. sequential:
[13:20:50.636]    - args: function (..., envir = parent.frame())
[13:20:50.636]    - tweaked: FALSE
[13:20:50.636]    - call: NULL
[13:20:50.636] plan(): nbrOfWorkers() = 1
[13:20:50.637] plan(): Setting new future strategy stack:
[13:20:50.637] List of future strategies:
[13:20:50.637] 1. sequential:
[13:20:50.637]    - args: function (..., envir = parent.frame())
[13:20:50.637]    - tweaked: FALSE
[13:20:50.637]    - call: plan(strategy)
[13:20:50.637] plan(): nbrOfWorkers() = 1
[13:20:50.637] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.638] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.638] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:50.640] - globals found: [3] ‘{’, ‘<-’, ‘+’
[13:20:50.640] Searching for globals ... DONE
[13:20:50.640] Resolving globals: TRUE
[13:20:50.640] Resolving any globals that are futures ...
[13:20:50.640] - globals: [3] ‘{’, ‘<-’, ‘+’
[13:20:50.640] Resolving any globals that are futures ... DONE
[13:20:50.640] 
[13:20:50.641] 
[13:20:50.641] getGlobalsAndPackages() ... DONE
[13:20:50.641] run() for ‘Future’ ...
[13:20:50.641] - state: ‘created’
[13:20:50.641] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.641] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.641] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.642]   - Field: ‘label’
[13:20:50.642]   - Field: ‘local’
[13:20:50.642]   - Field: ‘owner’
[13:20:50.642]   - Field: ‘envir’
[13:20:50.642]   - Field: ‘packages’
[13:20:50.642]   - Field: ‘gc’
[13:20:50.642]   - Field: ‘conditions’
[13:20:50.642]   - Field: ‘expr’
[13:20:50.642]   - Field: ‘uuid’
[13:20:50.642]   - Field: ‘seed’
[13:20:50.643]   - Field: ‘version’
[13:20:50.643]   - Field: ‘result’
[13:20:50.643]   - Field: ‘asynchronous’
[13:20:50.643]   - Field: ‘calls’
[13:20:50.643]   - Field: ‘globals’
[13:20:50.643]   - Field: ‘stdout’
[13:20:50.643]   - Field: ‘earlySignal’
[13:20:50.643]   - Field: ‘lazy’
[13:20:50.643]   - Field: ‘state’
[13:20:50.643] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.643] - Launch lazy future ...
[13:20:50.644] Packages needed by the future expression (n = 0): <none>
[13:20:50.644] Packages needed by future strategies (n = 0): <none>
[13:20:50.644] {
[13:20:50.644]     {
[13:20:50.644]         {
[13:20:50.644]             ...future.startTime <- base::Sys.time()
[13:20:50.644]             {
[13:20:50.644]                 {
[13:20:50.644]                   {
[13:20:50.644]                     base::local({
[13:20:50.644]                       has_future <- base::requireNamespace("future", 
[13:20:50.644]                         quietly = TRUE)
[13:20:50.644]                       if (has_future) {
[13:20:50.644]                         ns <- base::getNamespace("future")
[13:20:50.644]                         version <- ns[[".package"]][["version"]]
[13:20:50.644]                         if (is.null(version)) 
[13:20:50.644]                           version <- utils::packageVersion("future")
[13:20:50.644]                       }
[13:20:50.644]                       else {
[13:20:50.644]                         version <- NULL
[13:20:50.644]                       }
[13:20:50.644]                       if (!has_future || version < "1.8.0") {
[13:20:50.644]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.644]                           "", base::R.version$version.string), 
[13:20:50.644]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.644]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.644]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.644]                             "release", "version")], collapse = " "), 
[13:20:50.644]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.644]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.644]                           info)
[13:20:50.644]                         info <- base::paste(info, collapse = "; ")
[13:20:50.644]                         if (!has_future) {
[13:20:50.644]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.644]                             info)
[13:20:50.644]                         }
[13:20:50.644]                         else {
[13:20:50.644]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.644]                             info, version)
[13:20:50.644]                         }
[13:20:50.644]                         base::stop(msg)
[13:20:50.644]                       }
[13:20:50.644]                     })
[13:20:50.644]                   }
[13:20:50.644]                   options(future.plan = NULL)
[13:20:50.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.644]                 }
[13:20:50.644]                 ...future.workdir <- getwd()
[13:20:50.644]             }
[13:20:50.644]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.644]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.644]         }
[13:20:50.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.644]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:50.644]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.644]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.644]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.644]             base::names(...future.oldOptions))
[13:20:50.644]     }
[13:20:50.644]     if (FALSE) {
[13:20:50.644]     }
[13:20:50.644]     else {
[13:20:50.644]         if (TRUE) {
[13:20:50.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.644]                 open = "w")
[13:20:50.644]         }
[13:20:50.644]         else {
[13:20:50.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.644]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.644]         }
[13:20:50.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.644]             base::sink(type = "output", split = FALSE)
[13:20:50.644]             base::close(...future.stdout)
[13:20:50.644]         }, add = TRUE)
[13:20:50.644]     }
[13:20:50.644]     ...future.frame <- base::sys.nframe()
[13:20:50.644]     ...future.conditions <- base::list()
[13:20:50.644]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.644]     if (FALSE) {
[13:20:50.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.644]     }
[13:20:50.644]     ...future.result <- base::tryCatch({
[13:20:50.644]         base::withCallingHandlers({
[13:20:50.644]             ...future.value <- base::withVisible(base::local({
[13:20:50.644]                 x <- 0
[13:20:50.644]                 x <- x + 1
[13:20:50.644]                 x
[13:20:50.644]             }))
[13:20:50.644]             future::FutureResult(value = ...future.value$value, 
[13:20:50.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.644]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.644]                     ...future.globalenv.names))
[13:20:50.644]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.644]         }, condition = base::local({
[13:20:50.644]             c <- base::c
[13:20:50.644]             inherits <- base::inherits
[13:20:50.644]             invokeRestart <- base::invokeRestart
[13:20:50.644]             length <- base::length
[13:20:50.644]             list <- base::list
[13:20:50.644]             seq.int <- base::seq.int
[13:20:50.644]             signalCondition <- base::signalCondition
[13:20:50.644]             sys.calls <- base::sys.calls
[13:20:50.644]             `[[` <- base::`[[`
[13:20:50.644]             `+` <- base::`+`
[13:20:50.644]             `<<-` <- base::`<<-`
[13:20:50.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.644]                   3L)]
[13:20:50.644]             }
[13:20:50.644]             function(cond) {
[13:20:50.644]                 is_error <- inherits(cond, "error")
[13:20:50.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.644]                   NULL)
[13:20:50.644]                 if (is_error) {
[13:20:50.644]                   sessionInformation <- function() {
[13:20:50.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.644]                       search = base::search(), system = base::Sys.info())
[13:20:50.644]                   }
[13:20:50.644]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.644]                     cond$call), session = sessionInformation(), 
[13:20:50.644]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.644]                   signalCondition(cond)
[13:20:50.644]                 }
[13:20:50.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.644]                 "immediateCondition"))) {
[13:20:50.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.644]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.644]                   if (TRUE && !signal) {
[13:20:50.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.644]                     {
[13:20:50.644]                       inherits <- base::inherits
[13:20:50.644]                       invokeRestart <- base::invokeRestart
[13:20:50.644]                       is.null <- base::is.null
[13:20:50.644]                       muffled <- FALSE
[13:20:50.644]                       if (inherits(cond, "message")) {
[13:20:50.644]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.644]                         if (muffled) 
[13:20:50.644]                           invokeRestart("muffleMessage")
[13:20:50.644]                       }
[13:20:50.644]                       else if (inherits(cond, "warning")) {
[13:20:50.644]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.644]                         if (muffled) 
[13:20:50.644]                           invokeRestart("muffleWarning")
[13:20:50.644]                       }
[13:20:50.644]                       else if (inherits(cond, "condition")) {
[13:20:50.644]                         if (!is.null(pattern)) {
[13:20:50.644]                           computeRestarts <- base::computeRestarts
[13:20:50.644]                           grepl <- base::grepl
[13:20:50.644]                           restarts <- computeRestarts(cond)
[13:20:50.644]                           for (restart in restarts) {
[13:20:50.644]                             name <- restart$name
[13:20:50.644]                             if (is.null(name)) 
[13:20:50.644]                               next
[13:20:50.644]                             if (!grepl(pattern, name)) 
[13:20:50.644]                               next
[13:20:50.644]                             invokeRestart(restart)
[13:20:50.644]                             muffled <- TRUE
[13:20:50.644]                             break
[13:20:50.644]                           }
[13:20:50.644]                         }
[13:20:50.644]                       }
[13:20:50.644]                       invisible(muffled)
[13:20:50.644]                     }
[13:20:50.644]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.644]                   }
[13:20:50.644]                 }
[13:20:50.644]                 else {
[13:20:50.644]                   if (TRUE) {
[13:20:50.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.644]                     {
[13:20:50.644]                       inherits <- base::inherits
[13:20:50.644]                       invokeRestart <- base::invokeRestart
[13:20:50.644]                       is.null <- base::is.null
[13:20:50.644]                       muffled <- FALSE
[13:20:50.644]                       if (inherits(cond, "message")) {
[13:20:50.644]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.644]                         if (muffled) 
[13:20:50.644]                           invokeRestart("muffleMessage")
[13:20:50.644]                       }
[13:20:50.644]                       else if (inherits(cond, "warning")) {
[13:20:50.644]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.644]                         if (muffled) 
[13:20:50.644]                           invokeRestart("muffleWarning")
[13:20:50.644]                       }
[13:20:50.644]                       else if (inherits(cond, "condition")) {
[13:20:50.644]                         if (!is.null(pattern)) {
[13:20:50.644]                           computeRestarts <- base::computeRestarts
[13:20:50.644]                           grepl <- base::grepl
[13:20:50.644]                           restarts <- computeRestarts(cond)
[13:20:50.644]                           for (restart in restarts) {
[13:20:50.644]                             name <- restart$name
[13:20:50.644]                             if (is.null(name)) 
[13:20:50.644]                               next
[13:20:50.644]                             if (!grepl(pattern, name)) 
[13:20:50.644]                               next
[13:20:50.644]                             invokeRestart(restart)
[13:20:50.644]                             muffled <- TRUE
[13:20:50.644]                             break
[13:20:50.644]                           }
[13:20:50.644]                         }
[13:20:50.644]                       }
[13:20:50.644]                       invisible(muffled)
[13:20:50.644]                     }
[13:20:50.644]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.644]                   }
[13:20:50.644]                 }
[13:20:50.644]             }
[13:20:50.644]         }))
[13:20:50.644]     }, error = function(ex) {
[13:20:50.644]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.644]                 ...future.rng), started = ...future.startTime, 
[13:20:50.644]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.644]             version = "1.8"), class = "FutureResult")
[13:20:50.644]     }, finally = {
[13:20:50.644]         if (!identical(...future.workdir, getwd())) 
[13:20:50.644]             setwd(...future.workdir)
[13:20:50.644]         {
[13:20:50.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.644]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.644]             }
[13:20:50.644]             base::options(...future.oldOptions)
[13:20:50.644]             if (.Platform$OS.type == "windows") {
[13:20:50.644]                 old_names <- names(...future.oldEnvVars)
[13:20:50.644]                 envs <- base::Sys.getenv()
[13:20:50.644]                 names <- names(envs)
[13:20:50.644]                 common <- intersect(names, old_names)
[13:20:50.644]                 added <- setdiff(names, old_names)
[13:20:50.644]                 removed <- setdiff(old_names, names)
[13:20:50.644]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.644]                   envs[common]]
[13:20:50.644]                 NAMES <- toupper(changed)
[13:20:50.644]                 args <- list()
[13:20:50.644]                 for (kk in seq_along(NAMES)) {
[13:20:50.644]                   name <- changed[[kk]]
[13:20:50.644]                   NAME <- NAMES[[kk]]
[13:20:50.644]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.644]                     next
[13:20:50.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.644]                 }
[13:20:50.644]                 NAMES <- toupper(added)
[13:20:50.644]                 for (kk in seq_along(NAMES)) {
[13:20:50.644]                   name <- added[[kk]]
[13:20:50.644]                   NAME <- NAMES[[kk]]
[13:20:50.644]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.644]                     next
[13:20:50.644]                   args[[name]] <- ""
[13:20:50.644]                 }
[13:20:50.644]                 NAMES <- toupper(removed)
[13:20:50.644]                 for (kk in seq_along(NAMES)) {
[13:20:50.644]                   name <- removed[[kk]]
[13:20:50.644]                   NAME <- NAMES[[kk]]
[13:20:50.644]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.644]                     next
[13:20:50.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.644]                 }
[13:20:50.644]                 if (length(args) > 0) 
[13:20:50.644]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.644]             }
[13:20:50.644]             else {
[13:20:50.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.644]             }
[13:20:50.644]             {
[13:20:50.644]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.644]                   0L) {
[13:20:50.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.644]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.644]                   base::options(opts)
[13:20:50.644]                 }
[13:20:50.644]                 {
[13:20:50.644]                   {
[13:20:50.644]                     NULL
[13:20:50.644]                     RNGkind("Mersenne-Twister")
[13:20:50.644]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.644]                       inherits = FALSE)
[13:20:50.644]                   }
[13:20:50.644]                   options(future.plan = NULL)
[13:20:50.644]                   if (is.na(NA_character_)) 
[13:20:50.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.644]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.644]                   {
[13:20:50.644]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.644]                     if (!future$lazy) 
[13:20:50.644]                       future <- run(future)
[13:20:50.644]                     invisible(future)
[13:20:50.644]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.644]                 }
[13:20:50.644]             }
[13:20:50.644]         }
[13:20:50.644]     })
[13:20:50.644]     if (TRUE) {
[13:20:50.644]         base::sink(type = "output", split = FALSE)
[13:20:50.644]         if (TRUE) {
[13:20:50.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.644]         }
[13:20:50.644]         else {
[13:20:50.644]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.644]         }
[13:20:50.644]         base::close(...future.stdout)
[13:20:50.644]         ...future.stdout <- NULL
[13:20:50.644]     }
[13:20:50.644]     ...future.result$conditions <- ...future.conditions
[13:20:50.644]     ...future.result$finished <- base::Sys.time()
[13:20:50.644]     ...future.result
[13:20:50.644] }
[13:20:50.646] plan(): Setting new future strategy stack:
[13:20:50.646] List of future strategies:
[13:20:50.646] 1. sequential:
[13:20:50.646]    - args: function (..., envir = parent.frame())
[13:20:50.646]    - tweaked: FALSE
[13:20:50.646]    - call: NULL
[13:20:50.646] plan(): nbrOfWorkers() = 1
[13:20:50.647] plan(): Setting new future strategy stack:
[13:20:50.647] List of future strategies:
[13:20:50.647] 1. sequential:
[13:20:50.647]    - args: function (..., envir = parent.frame())
[13:20:50.647]    - tweaked: FALSE
[13:20:50.647]    - call: plan(strategy)
[13:20:50.647] plan(): nbrOfWorkers() = 1
[13:20:50.648] SequentialFuture started (and completed)
[13:20:50.648] - Launch lazy future ... done
[13:20:50.648] run() for ‘SequentialFuture’ ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.648] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.648] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:50.650] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[13:20:50.650] Searching for globals ... DONE
[13:20:50.650] Resolving globals: TRUE
[13:20:50.650] Resolving any globals that are futures ...
[13:20:50.650] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[13:20:50.650] Resolving any globals that are futures ... DONE
[13:20:50.651] Resolving futures part of globals (recursively) ...
[13:20:50.651] resolve() on list ...
[13:20:50.651]  recursive: 99
[13:20:50.651]  length: 1
[13:20:50.651]  elements: ‘x’
[13:20:50.651]  length: 0 (resolved future 1)
[13:20:50.651] resolve() on list ... DONE
[13:20:50.651] - globals: [1] ‘x’
[13:20:50.651] Resolving futures part of globals (recursively) ... DONE
[13:20:50.652] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:50.652] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[13:20:50.652] - globals: [1] ‘x’
[13:20:50.652] 
[13:20:50.652] getGlobalsAndPackages() ... DONE
[13:20:50.652] run() for ‘Future’ ...
[13:20:50.653] - state: ‘created’
[13:20:50.653] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.653] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.653] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.653]   - Field: ‘label’
[13:20:50.653]   - Field: ‘local’
[13:20:50.653]   - Field: ‘owner’
[13:20:50.653]   - Field: ‘envir’
[13:20:50.654]   - Field: ‘packages’
[13:20:50.654]   - Field: ‘gc’
[13:20:50.654]   - Field: ‘conditions’
[13:20:50.654]   - Field: ‘expr’
[13:20:50.654]   - Field: ‘uuid’
[13:20:50.654]   - Field: ‘seed’
[13:20:50.654]   - Field: ‘version’
[13:20:50.654]   - Field: ‘result’
[13:20:50.654]   - Field: ‘asynchronous’
[13:20:50.654]   - Field: ‘calls’
[13:20:50.654]   - Field: ‘globals’
[13:20:50.655]   - Field: ‘stdout’
[13:20:50.655]   - Field: ‘earlySignal’
[13:20:50.655]   - Field: ‘lazy’
[13:20:50.655]   - Field: ‘state’
[13:20:50.655] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.655] - Launch lazy future ...
[13:20:50.655] Packages needed by the future expression (n = 0): <none>
[13:20:50.655] Packages needed by future strategies (n = 0): <none>
[13:20:50.656] {
[13:20:50.656]     {
[13:20:50.656]         {
[13:20:50.656]             ...future.startTime <- base::Sys.time()
[13:20:50.656]             {
[13:20:50.656]                 {
[13:20:50.656]                   {
[13:20:50.656]                     base::local({
[13:20:50.656]                       has_future <- base::requireNamespace("future", 
[13:20:50.656]                         quietly = TRUE)
[13:20:50.656]                       if (has_future) {
[13:20:50.656]                         ns <- base::getNamespace("future")
[13:20:50.656]                         version <- ns[[".package"]][["version"]]
[13:20:50.656]                         if (is.null(version)) 
[13:20:50.656]                           version <- utils::packageVersion("future")
[13:20:50.656]                       }
[13:20:50.656]                       else {
[13:20:50.656]                         version <- NULL
[13:20:50.656]                       }
[13:20:50.656]                       if (!has_future || version < "1.8.0") {
[13:20:50.656]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.656]                           "", base::R.version$version.string), 
[13:20:50.656]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.656]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.656]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.656]                             "release", "version")], collapse = " "), 
[13:20:50.656]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.656]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.656]                           info)
[13:20:50.656]                         info <- base::paste(info, collapse = "; ")
[13:20:50.656]                         if (!has_future) {
[13:20:50.656]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.656]                             info)
[13:20:50.656]                         }
[13:20:50.656]                         else {
[13:20:50.656]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.656]                             info, version)
[13:20:50.656]                         }
[13:20:50.656]                         base::stop(msg)
[13:20:50.656]                       }
[13:20:50.656]                     })
[13:20:50.656]                   }
[13:20:50.656]                   options(future.plan = NULL)
[13:20:50.656]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.656]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.656]                 }
[13:20:50.656]                 ...future.workdir <- getwd()
[13:20:50.656]             }
[13:20:50.656]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.656]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.656]         }
[13:20:50.656]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.656]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:50.656]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.656]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.656]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.656]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.656]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.656]             base::names(...future.oldOptions))
[13:20:50.656]     }
[13:20:50.656]     if (FALSE) {
[13:20:50.656]     }
[13:20:50.656]     else {
[13:20:50.656]         if (TRUE) {
[13:20:50.656]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.656]                 open = "w")
[13:20:50.656]         }
[13:20:50.656]         else {
[13:20:50.656]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.656]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.656]         }
[13:20:50.656]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.656]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.656]             base::sink(type = "output", split = FALSE)
[13:20:50.656]             base::close(...future.stdout)
[13:20:50.656]         }, add = TRUE)
[13:20:50.656]     }
[13:20:50.656]     ...future.frame <- base::sys.nframe()
[13:20:50.656]     ...future.conditions <- base::list()
[13:20:50.656]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.656]     if (FALSE) {
[13:20:50.656]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.656]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.656]     }
[13:20:50.656]     ...future.result <- base::tryCatch({
[13:20:50.656]         base::withCallingHandlers({
[13:20:50.656]             ...future.value <- base::withVisible(base::local({
[13:20:50.656]                 x <- x + 1
[13:20:50.656]                 x
[13:20:50.656]             }))
[13:20:50.656]             future::FutureResult(value = ...future.value$value, 
[13:20:50.656]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.656]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.656]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.656]                     ...future.globalenv.names))
[13:20:50.656]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.656]         }, condition = base::local({
[13:20:50.656]             c <- base::c
[13:20:50.656]             inherits <- base::inherits
[13:20:50.656]             invokeRestart <- base::invokeRestart
[13:20:50.656]             length <- base::length
[13:20:50.656]             list <- base::list
[13:20:50.656]             seq.int <- base::seq.int
[13:20:50.656]             signalCondition <- base::signalCondition
[13:20:50.656]             sys.calls <- base::sys.calls
[13:20:50.656]             `[[` <- base::`[[`
[13:20:50.656]             `+` <- base::`+`
[13:20:50.656]             `<<-` <- base::`<<-`
[13:20:50.656]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.656]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.656]                   3L)]
[13:20:50.656]             }
[13:20:50.656]             function(cond) {
[13:20:50.656]                 is_error <- inherits(cond, "error")
[13:20:50.656]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.656]                   NULL)
[13:20:50.656]                 if (is_error) {
[13:20:50.656]                   sessionInformation <- function() {
[13:20:50.656]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.656]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.656]                       search = base::search(), system = base::Sys.info())
[13:20:50.656]                   }
[13:20:50.656]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.656]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.656]                     cond$call), session = sessionInformation(), 
[13:20:50.656]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.656]                   signalCondition(cond)
[13:20:50.656]                 }
[13:20:50.656]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.656]                 "immediateCondition"))) {
[13:20:50.656]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.656]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.656]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.656]                   if (TRUE && !signal) {
[13:20:50.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.656]                     {
[13:20:50.656]                       inherits <- base::inherits
[13:20:50.656]                       invokeRestart <- base::invokeRestart
[13:20:50.656]                       is.null <- base::is.null
[13:20:50.656]                       muffled <- FALSE
[13:20:50.656]                       if (inherits(cond, "message")) {
[13:20:50.656]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.656]                         if (muffled) 
[13:20:50.656]                           invokeRestart("muffleMessage")
[13:20:50.656]                       }
[13:20:50.656]                       else if (inherits(cond, "warning")) {
[13:20:50.656]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.656]                         if (muffled) 
[13:20:50.656]                           invokeRestart("muffleWarning")
[13:20:50.656]                       }
[13:20:50.656]                       else if (inherits(cond, "condition")) {
[13:20:50.656]                         if (!is.null(pattern)) {
[13:20:50.656]                           computeRestarts <- base::computeRestarts
[13:20:50.656]                           grepl <- base::grepl
[13:20:50.656]                           restarts <- computeRestarts(cond)
[13:20:50.656]                           for (restart in restarts) {
[13:20:50.656]                             name <- restart$name
[13:20:50.656]                             if (is.null(name)) 
[13:20:50.656]                               next
[13:20:50.656]                             if (!grepl(pattern, name)) 
[13:20:50.656]                               next
[13:20:50.656]                             invokeRestart(restart)
[13:20:50.656]                             muffled <- TRUE
[13:20:50.656]                             break
[13:20:50.656]                           }
[13:20:50.656]                         }
[13:20:50.656]                       }
[13:20:50.656]                       invisible(muffled)
[13:20:50.656]                     }
[13:20:50.656]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.656]                   }
[13:20:50.656]                 }
[13:20:50.656]                 else {
[13:20:50.656]                   if (TRUE) {
[13:20:50.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.656]                     {
[13:20:50.656]                       inherits <- base::inherits
[13:20:50.656]                       invokeRestart <- base::invokeRestart
[13:20:50.656]                       is.null <- base::is.null
[13:20:50.656]                       muffled <- FALSE
[13:20:50.656]                       if (inherits(cond, "message")) {
[13:20:50.656]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.656]                         if (muffled) 
[13:20:50.656]                           invokeRestart("muffleMessage")
[13:20:50.656]                       }
[13:20:50.656]                       else if (inherits(cond, "warning")) {
[13:20:50.656]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.656]                         if (muffled) 
[13:20:50.656]                           invokeRestart("muffleWarning")
[13:20:50.656]                       }
[13:20:50.656]                       else if (inherits(cond, "condition")) {
[13:20:50.656]                         if (!is.null(pattern)) {
[13:20:50.656]                           computeRestarts <- base::computeRestarts
[13:20:50.656]                           grepl <- base::grepl
[13:20:50.656]                           restarts <- computeRestarts(cond)
[13:20:50.656]                           for (restart in restarts) {
[13:20:50.656]                             name <- restart$name
[13:20:50.656]                             if (is.null(name)) 
[13:20:50.656]                               next
[13:20:50.656]                             if (!grepl(pattern, name)) 
[13:20:50.656]                               next
[13:20:50.656]                             invokeRestart(restart)
[13:20:50.656]                             muffled <- TRUE
[13:20:50.656]                             break
[13:20:50.656]                           }
[13:20:50.656]                         }
[13:20:50.656]                       }
[13:20:50.656]                       invisible(muffled)
[13:20:50.656]                     }
[13:20:50.656]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.656]                   }
[13:20:50.656]                 }
[13:20:50.656]             }
[13:20:50.656]         }))
[13:20:50.656]     }, error = function(ex) {
[13:20:50.656]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.656]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.656]                 ...future.rng), started = ...future.startTime, 
[13:20:50.656]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.656]             version = "1.8"), class = "FutureResult")
[13:20:50.656]     }, finally = {
[13:20:50.656]         if (!identical(...future.workdir, getwd())) 
[13:20:50.656]             setwd(...future.workdir)
[13:20:50.656]         {
[13:20:50.656]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.656]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.656]             }
[13:20:50.656]             base::options(...future.oldOptions)
[13:20:50.656]             if (.Platform$OS.type == "windows") {
[13:20:50.656]                 old_names <- names(...future.oldEnvVars)
[13:20:50.656]                 envs <- base::Sys.getenv()
[13:20:50.656]                 names <- names(envs)
[13:20:50.656]                 common <- intersect(names, old_names)
[13:20:50.656]                 added <- setdiff(names, old_names)
[13:20:50.656]                 removed <- setdiff(old_names, names)
[13:20:50.656]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.656]                   envs[common]]
[13:20:50.656]                 NAMES <- toupper(changed)
[13:20:50.656]                 args <- list()
[13:20:50.656]                 for (kk in seq_along(NAMES)) {
[13:20:50.656]                   name <- changed[[kk]]
[13:20:50.656]                   NAME <- NAMES[[kk]]
[13:20:50.656]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.656]                     next
[13:20:50.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.656]                 }
[13:20:50.656]                 NAMES <- toupper(added)
[13:20:50.656]                 for (kk in seq_along(NAMES)) {
[13:20:50.656]                   name <- added[[kk]]
[13:20:50.656]                   NAME <- NAMES[[kk]]
[13:20:50.656]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.656]                     next
[13:20:50.656]                   args[[name]] <- ""
[13:20:50.656]                 }
[13:20:50.656]                 NAMES <- toupper(removed)
[13:20:50.656]                 for (kk in seq_along(NAMES)) {
[13:20:50.656]                   name <- removed[[kk]]
[13:20:50.656]                   NAME <- NAMES[[kk]]
[13:20:50.656]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.656]                     next
[13:20:50.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.656]                 }
[13:20:50.656]                 if (length(args) > 0) 
[13:20:50.656]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.656]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.656]             }
[13:20:50.656]             else {
[13:20:50.656]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.656]             }
[13:20:50.656]             {
[13:20:50.656]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.656]                   0L) {
[13:20:50.656]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.656]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.656]                   base::options(opts)
[13:20:50.656]                 }
[13:20:50.656]                 {
[13:20:50.656]                   {
[13:20:50.656]                     NULL
[13:20:50.656]                     RNGkind("Mersenne-Twister")
[13:20:50.656]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.656]                       inherits = FALSE)
[13:20:50.656]                   }
[13:20:50.656]                   options(future.plan = NULL)
[13:20:50.656]                   if (is.na(NA_character_)) 
[13:20:50.656]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.656]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.656]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.656]                   {
[13:20:50.656]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.656]                     if (!future$lazy) 
[13:20:50.656]                       future <- run(future)
[13:20:50.656]                     invisible(future)
[13:20:50.656]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.656]                 }
[13:20:50.656]             }
[13:20:50.656]         }
[13:20:50.656]     })
[13:20:50.656]     if (TRUE) {
[13:20:50.656]         base::sink(type = "output", split = FALSE)
[13:20:50.656]         if (TRUE) {
[13:20:50.656]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.656]         }
[13:20:50.656]         else {
[13:20:50.656]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.656]         }
[13:20:50.656]         base::close(...future.stdout)
[13:20:50.656]         ...future.stdout <- NULL
[13:20:50.656]     }
[13:20:50.656]     ...future.result$conditions <- ...future.conditions
[13:20:50.656]     ...future.result$finished <- base::Sys.time()
[13:20:50.656]     ...future.result
[13:20:50.656] }
[13:20:50.657] assign_globals() ...
[13:20:50.659] List of 1
[13:20:50.659]  $ x: num 1
[13:20:50.659]  - attr(*, "where")=List of 1
[13:20:50.659]   ..$ x:<environment: R_EmptyEnv> 
[13:20:50.659]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.659]  - attr(*, "resolved")= logi TRUE
[13:20:50.659]  - attr(*, "total_size")= num 56
[13:20:50.659]  - attr(*, "already-done")= logi TRUE
[13:20:50.661] - copied ‘x’ to environment
[13:20:50.661] assign_globals() ... done
[13:20:50.662] plan(): Setting new future strategy stack:
[13:20:50.662] List of future strategies:
[13:20:50.662] 1. sequential:
[13:20:50.662]    - args: function (..., envir = parent.frame())
[13:20:50.662]    - tweaked: FALSE
[13:20:50.662]    - call: NULL
[13:20:50.662] plan(): nbrOfWorkers() = 1
[13:20:50.663] plan(): Setting new future strategy stack:
[13:20:50.663] List of future strategies:
[13:20:50.663] 1. sequential:
[13:20:50.663]    - args: function (..., envir = parent.frame())
[13:20:50.663]    - tweaked: FALSE
[13:20:50.663]    - call: plan(strategy)
[13:20:50.663] plan(): nbrOfWorkers() = 1
[13:20:50.663] SequentialFuture started (and completed)
[13:20:50.664] - Launch lazy future ... done
[13:20:50.664] run() for ‘SequentialFuture’ ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.664] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.664] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:50.666] - globals found: [3] ‘{’, ‘<-’, ‘x’
[13:20:50.666] Searching for globals ... DONE
[13:20:50.666] Resolving globals: TRUE
[13:20:50.666] Resolving any globals that are futures ...
[13:20:50.666] - globals: [3] ‘{’, ‘<-’, ‘x’
[13:20:50.666] Resolving any globals that are futures ... DONE
[13:20:50.667] Resolving futures part of globals (recursively) ...
[13:20:50.667] resolve() on list ...
[13:20:50.667]  recursive: 99
[13:20:50.667]  length: 1
[13:20:50.667]  elements: ‘x’
[13:20:50.667]  length: 0 (resolved future 1)
[13:20:50.667] resolve() on list ... DONE
[13:20:50.668] - globals: [1] ‘x’
[13:20:50.668] Resolving futures part of globals (recursively) ... DONE
[13:20:50.668] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[13:20:50.668] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[13:20:50.668] - globals: [1] ‘x’
[13:20:50.668] 
[13:20:50.668] getGlobalsAndPackages() ... DONE
[13:20:50.669] run() for ‘Future’ ...
[13:20:50.669] - state: ‘created’
[13:20:50.669] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:20:50.669] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:20:50.669] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:20:50.669]   - Field: ‘label’
[13:20:50.669]   - Field: ‘local’
[13:20:50.670]   - Field: ‘owner’
[13:20:50.670]   - Field: ‘envir’
[13:20:50.670]   - Field: ‘packages’
[13:20:50.670]   - Field: ‘gc’
[13:20:50.670]   - Field: ‘conditions’
[13:20:50.670]   - Field: ‘expr’
[13:20:50.670]   - Field: ‘uuid’
[13:20:50.670]   - Field: ‘seed’
[13:20:50.670]   - Field: ‘version’
[13:20:50.670]   - Field: ‘result’
[13:20:50.671]   - Field: ‘asynchronous’
[13:20:50.671]   - Field: ‘calls’
[13:20:50.671]   - Field: ‘globals’
[13:20:50.671]   - Field: ‘stdout’
[13:20:50.671]   - Field: ‘earlySignal’
[13:20:50.671]   - Field: ‘lazy’
[13:20:50.671]   - Field: ‘state’
[13:20:50.671] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:20:50.671] - Launch lazy future ...
[13:20:50.671] Packages needed by the future expression (n = 0): <none>
[13:20:50.672] Packages needed by future strategies (n = 0): <none>
[13:20:50.672] {
[13:20:50.672]     {
[13:20:50.672]         {
[13:20:50.672]             ...future.startTime <- base::Sys.time()
[13:20:50.672]             {
[13:20:50.672]                 {
[13:20:50.672]                   {
[13:20:50.672]                     base::local({
[13:20:50.672]                       has_future <- base::requireNamespace("future", 
[13:20:50.672]                         quietly = TRUE)
[13:20:50.672]                       if (has_future) {
[13:20:50.672]                         ns <- base::getNamespace("future")
[13:20:50.672]                         version <- ns[[".package"]][["version"]]
[13:20:50.672]                         if (is.null(version)) 
[13:20:50.672]                           version <- utils::packageVersion("future")
[13:20:50.672]                       }
[13:20:50.672]                       else {
[13:20:50.672]                         version <- NULL
[13:20:50.672]                       }
[13:20:50.672]                       if (!has_future || version < "1.8.0") {
[13:20:50.672]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.672]                           "", base::R.version$version.string), 
[13:20:50.672]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:50.672]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.672]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.672]                             "release", "version")], collapse = " "), 
[13:20:50.672]                           hostname = base::Sys.info()[["nodename"]])
[13:20:50.672]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.672]                           info)
[13:20:50.672]                         info <- base::paste(info, collapse = "; ")
[13:20:50.672]                         if (!has_future) {
[13:20:50.672]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.672]                             info)
[13:20:50.672]                         }
[13:20:50.672]                         else {
[13:20:50.672]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.672]                             info, version)
[13:20:50.672]                         }
[13:20:50.672]                         base::stop(msg)
[13:20:50.672]                       }
[13:20:50.672]                     })
[13:20:50.672]                   }
[13:20:50.672]                   options(future.plan = NULL)
[13:20:50.672]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.672]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.672]                 }
[13:20:50.672]                 ...future.workdir <- getwd()
[13:20:50.672]             }
[13:20:50.672]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.672]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.672]         }
[13:20:50.672]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.672]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:50.672]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.672]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.672]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.672]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.672]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.672]             base::names(...future.oldOptions))
[13:20:50.672]     }
[13:20:50.672]     if (FALSE) {
[13:20:50.672]     }
[13:20:50.672]     else {
[13:20:50.672]         if (TRUE) {
[13:20:50.672]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.672]                 open = "w")
[13:20:50.672]         }
[13:20:50.672]         else {
[13:20:50.672]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.672]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.672]         }
[13:20:50.672]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.672]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.672]             base::sink(type = "output", split = FALSE)
[13:20:50.672]             base::close(...future.stdout)
[13:20:50.672]         }, add = TRUE)
[13:20:50.672]     }
[13:20:50.672]     ...future.frame <- base::sys.nframe()
[13:20:50.672]     ...future.conditions <- base::list()
[13:20:50.672]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.672]     if (FALSE) {
[13:20:50.672]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.672]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.672]     }
[13:20:50.672]     ...future.result <- base::tryCatch({
[13:20:50.672]         base::withCallingHandlers({
[13:20:50.672]             ...future.value <- base::withVisible(base::local({
[13:20:50.672]                 x <- x()
[13:20:50.672]                 x
[13:20:50.672]             }))
[13:20:50.672]             future::FutureResult(value = ...future.value$value, 
[13:20:50.672]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.672]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.672]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.672]                     ...future.globalenv.names))
[13:20:50.672]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.672]         }, condition = base::local({
[13:20:50.672]             c <- base::c
[13:20:50.672]             inherits <- base::inherits
[13:20:50.672]             invokeRestart <- base::invokeRestart
[13:20:50.672]             length <- base::length
[13:20:50.672]             list <- base::list
[13:20:50.672]             seq.int <- base::seq.int
[13:20:50.672]             signalCondition <- base::signalCondition
[13:20:50.672]             sys.calls <- base::sys.calls
[13:20:50.672]             `[[` <- base::`[[`
[13:20:50.672]             `+` <- base::`+`
[13:20:50.672]             `<<-` <- base::`<<-`
[13:20:50.672]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.672]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.672]                   3L)]
[13:20:50.672]             }
[13:20:50.672]             function(cond) {
[13:20:50.672]                 is_error <- inherits(cond, "error")
[13:20:50.672]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.672]                   NULL)
[13:20:50.672]                 if (is_error) {
[13:20:50.672]                   sessionInformation <- function() {
[13:20:50.672]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.672]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.672]                       search = base::search(), system = base::Sys.info())
[13:20:50.672]                   }
[13:20:50.672]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.672]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.672]                     cond$call), session = sessionInformation(), 
[13:20:50.672]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.672]                   signalCondition(cond)
[13:20:50.672]                 }
[13:20:50.672]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.672]                 "immediateCondition"))) {
[13:20:50.672]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.672]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.672]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.672]                   if (TRUE && !signal) {
[13:20:50.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.672]                     {
[13:20:50.672]                       inherits <- base::inherits
[13:20:50.672]                       invokeRestart <- base::invokeRestart
[13:20:50.672]                       is.null <- base::is.null
[13:20:50.672]                       muffled <- FALSE
[13:20:50.672]                       if (inherits(cond, "message")) {
[13:20:50.672]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.672]                         if (muffled) 
[13:20:50.672]                           invokeRestart("muffleMessage")
[13:20:50.672]                       }
[13:20:50.672]                       else if (inherits(cond, "warning")) {
[13:20:50.672]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.672]                         if (muffled) 
[13:20:50.672]                           invokeRestart("muffleWarning")
[13:20:50.672]                       }
[13:20:50.672]                       else if (inherits(cond, "condition")) {
[13:20:50.672]                         if (!is.null(pattern)) {
[13:20:50.672]                           computeRestarts <- base::computeRestarts
[13:20:50.672]                           grepl <- base::grepl
[13:20:50.672]                           restarts <- computeRestarts(cond)
[13:20:50.672]                           for (restart in restarts) {
[13:20:50.672]                             name <- restart$name
[13:20:50.672]                             if (is.null(name)) 
[13:20:50.672]                               next
[13:20:50.672]                             if (!grepl(pattern, name)) 
[13:20:50.672]                               next
[13:20:50.672]                             invokeRestart(restart)
[13:20:50.672]                             muffled <- TRUE
[13:20:50.672]                             break
[13:20:50.672]                           }
[13:20:50.672]                         }
[13:20:50.672]                       }
[13:20:50.672]                       invisible(muffled)
[13:20:50.672]                     }
[13:20:50.672]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.672]                   }
[13:20:50.672]                 }
[13:20:50.672]                 else {
[13:20:50.672]                   if (TRUE) {
[13:20:50.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.672]                     {
[13:20:50.672]                       inherits <- base::inherits
[13:20:50.672]                       invokeRestart <- base::invokeRestart
[13:20:50.672]                       is.null <- base::is.null
[13:20:50.672]                       muffled <- FALSE
[13:20:50.672]                       if (inherits(cond, "message")) {
[13:20:50.672]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.672]                         if (muffled) 
[13:20:50.672]                           invokeRestart("muffleMessage")
[13:20:50.672]                       }
[13:20:50.672]                       else if (inherits(cond, "warning")) {
[13:20:50.672]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.672]                         if (muffled) 
[13:20:50.672]                           invokeRestart("muffleWarning")
[13:20:50.672]                       }
[13:20:50.672]                       else if (inherits(cond, "condition")) {
[13:20:50.672]                         if (!is.null(pattern)) {
[13:20:50.672]                           computeRestarts <- base::computeRestarts
[13:20:50.672]                           grepl <- base::grepl
[13:20:50.672]                           restarts <- computeRestarts(cond)
[13:20:50.672]                           for (restart in restarts) {
[13:20:50.672]                             name <- restart$name
[13:20:50.672]                             if (is.null(name)) 
[13:20:50.672]                               next
[13:20:50.672]                             if (!grepl(pattern, name)) 
[13:20:50.672]                               next
[13:20:50.672]                             invokeRestart(restart)
[13:20:50.672]                             muffled <- TRUE
[13:20:50.672]                             break
[13:20:50.672]                           }
[13:20:50.672]                         }
[13:20:50.672]                       }
[13:20:50.672]                       invisible(muffled)
[13:20:50.672]                     }
[13:20:50.672]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.672]                   }
[13:20:50.672]                 }
[13:20:50.672]             }
[13:20:50.672]         }))
[13:20:50.672]     }, error = function(ex) {
[13:20:50.672]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.672]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.672]                 ...future.rng), started = ...future.startTime, 
[13:20:50.672]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.672]             version = "1.8"), class = "FutureResult")
[13:20:50.672]     }, finally = {
[13:20:50.672]         if (!identical(...future.workdir, getwd())) 
[13:20:50.672]             setwd(...future.workdir)
[13:20:50.672]         {
[13:20:50.672]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.672]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.672]             }
[13:20:50.672]             base::options(...future.oldOptions)
[13:20:50.672]             if (.Platform$OS.type == "windows") {
[13:20:50.672]                 old_names <- names(...future.oldEnvVars)
[13:20:50.672]                 envs <- base::Sys.getenv()
[13:20:50.672]                 names <- names(envs)
[13:20:50.672]                 common <- intersect(names, old_names)
[13:20:50.672]                 added <- setdiff(names, old_names)
[13:20:50.672]                 removed <- setdiff(old_names, names)
[13:20:50.672]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.672]                   envs[common]]
[13:20:50.672]                 NAMES <- toupper(changed)
[13:20:50.672]                 args <- list()
[13:20:50.672]                 for (kk in seq_along(NAMES)) {
[13:20:50.672]                   name <- changed[[kk]]
[13:20:50.672]                   NAME <- NAMES[[kk]]
[13:20:50.672]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.672]                     next
[13:20:50.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.672]                 }
[13:20:50.672]                 NAMES <- toupper(added)
[13:20:50.672]                 for (kk in seq_along(NAMES)) {
[13:20:50.672]                   name <- added[[kk]]
[13:20:50.672]                   NAME <- NAMES[[kk]]
[13:20:50.672]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.672]                     next
[13:20:50.672]                   args[[name]] <- ""
[13:20:50.672]                 }
[13:20:50.672]                 NAMES <- toupper(removed)
[13:20:50.672]                 for (kk in seq_along(NAMES)) {
[13:20:50.672]                   name <- removed[[kk]]
[13:20:50.672]                   NAME <- NAMES[[kk]]
[13:20:50.672]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.672]                     next
[13:20:50.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.672]                 }
[13:20:50.672]                 if (length(args) > 0) 
[13:20:50.672]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.672]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.672]             }
[13:20:50.672]             else {
[13:20:50.672]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.672]             }
[13:20:50.672]             {
[13:20:50.672]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.672]                   0L) {
[13:20:50.672]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.672]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.672]                   base::options(opts)
[13:20:50.672]                 }
[13:20:50.672]                 {
[13:20:50.672]                   {
[13:20:50.672]                     NULL
[13:20:50.672]                     RNGkind("Mersenne-Twister")
[13:20:50.672]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:50.672]                       inherits = FALSE)
[13:20:50.672]                   }
[13:20:50.672]                   options(future.plan = NULL)
[13:20:50.672]                   if (is.na(NA_character_)) 
[13:20:50.672]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.672]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.672]                   future::plan(list(function (..., envir = parent.frame()) 
[13:20:50.672]                   {
[13:20:50.672]                     future <- SequentialFuture(..., envir = envir)
[13:20:50.672]                     if (!future$lazy) 
[13:20:50.672]                       future <- run(future)
[13:20:50.672]                     invisible(future)
[13:20:50.672]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.672]                 }
[13:20:50.672]             }
[13:20:50.672]         }
[13:20:50.672]     })
[13:20:50.672]     if (TRUE) {
[13:20:50.672]         base::sink(type = "output", split = FALSE)
[13:20:50.672]         if (TRUE) {
[13:20:50.672]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.672]         }
[13:20:50.672]         else {
[13:20:50.672]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.672]         }
[13:20:50.672]         base::close(...future.stdout)
[13:20:50.672]         ...future.stdout <- NULL
[13:20:50.672]     }
[13:20:50.672]     ...future.result$conditions <- ...future.conditions
[13:20:50.672]     ...future.result$finished <- base::Sys.time()
[13:20:50.672]     ...future.result
[13:20:50.672] }
[13:20:50.674] assign_globals() ...
[13:20:50.674] List of 1
[13:20:50.674]  $ x:function ()  
[13:20:50.674]  - attr(*, "where")=List of 1
[13:20:50.674]   ..$ x:<environment: R_EmptyEnv> 
[13:20:50.674]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.674]  - attr(*, "resolved")= logi TRUE
[13:20:50.674]  - attr(*, "total_size")= num 1032
[13:20:50.674]  - attr(*, "already-done")= logi TRUE
[13:20:50.676] - reassign environment for ‘x’
[13:20:50.676] - copied ‘x’ to environment
[13:20:50.676] assign_globals() ... done
[13:20:50.676] plan(): Setting new future strategy stack:
[13:20:50.676] List of future strategies:
[13:20:50.676] 1. sequential:
[13:20:50.676]    - args: function (..., envir = parent.frame())
[13:20:50.676]    - tweaked: FALSE
[13:20:50.676]    - call: NULL
[13:20:50.677] plan(): nbrOfWorkers() = 1
[13:20:50.677] plan(): Setting new future strategy stack:
[13:20:50.678] List of future strategies:
[13:20:50.678] 1. sequential:
[13:20:50.678]    - args: function (..., envir = parent.frame())
[13:20:50.678]    - tweaked: FALSE
[13:20:50.678]    - call: plan(strategy)
[13:20:50.678] plan(): nbrOfWorkers() = 1
[13:20:50.678] SequentialFuture started (and completed)
[13:20:50.678] - Launch lazy future ... done
[13:20:50.678] run() for ‘SequentialFuture’ ... done
value(f) = ‘TRUE’
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- Local variables with the same name as globals ...
- plan('multicore') ...
[13:20:50.689] plan(): Setting new future strategy stack:
[13:20:50.689] List of future strategies:
[13:20:50.689] 1. multicore:
[13:20:50.689]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:50.689]    - tweaked: FALSE
[13:20:50.689]    - call: plan(strategy)
[13:20:50.693] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.693] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.694] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.695] - globals found: [3] ‘{’, ‘<-’, ‘*’
[13:20:50.695] Searching for globals ... DONE
[13:20:50.695] Resolving globals: TRUE
[13:20:50.695] Resolving any globals that are futures ...
[13:20:50.695] - globals: [3] ‘{’, ‘<-’, ‘*’
[13:20:50.695] Resolving any globals that are futures ... DONE
[13:20:50.696] 
[13:20:50.696] 
[13:20:50.696] getGlobalsAndPackages() ... DONE
[13:20:50.696] run() for ‘Future’ ...
[13:20:50.696] - state: ‘created’
[13:20:50.696] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:50.700] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:50.700] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:50.700]   - Field: ‘label’
[13:20:50.700]   - Field: ‘local’
[13:20:50.700]   - Field: ‘owner’
[13:20:50.700]   - Field: ‘envir’
[13:20:50.700]   - Field: ‘workers’
[13:20:50.701]   - Field: ‘packages’
[13:20:50.701]   - Field: ‘gc’
[13:20:50.701]   - Field: ‘job’
[13:20:50.701]   - Field: ‘conditions’
[13:20:50.701]   - Field: ‘expr’
[13:20:50.701]   - Field: ‘uuid’
[13:20:50.701]   - Field: ‘seed’
[13:20:50.701]   - Field: ‘version’
[13:20:50.701]   - Field: ‘result’
[13:20:50.701]   - Field: ‘asynchronous’
[13:20:50.701]   - Field: ‘calls’
[13:20:50.702]   - Field: ‘globals’
[13:20:50.702]   - Field: ‘stdout’
[13:20:50.702]   - Field: ‘earlySignal’
[13:20:50.702]   - Field: ‘lazy’
[13:20:50.702]   - Field: ‘state’
[13:20:50.702] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:50.702] - Launch lazy future ...
[13:20:50.703] Packages needed by the future expression (n = 0): <none>
[13:20:50.703] Packages needed by future strategies (n = 0): <none>
[13:20:50.704] {
[13:20:50.704]     {
[13:20:50.704]         {
[13:20:50.704]             ...future.startTime <- base::Sys.time()
[13:20:50.704]             {
[13:20:50.704]                 {
[13:20:50.704]                   {
[13:20:50.704]                     {
[13:20:50.704]                       base::local({
[13:20:50.704]                         has_future <- base::requireNamespace("future", 
[13:20:50.704]                           quietly = TRUE)
[13:20:50.704]                         if (has_future) {
[13:20:50.704]                           ns <- base::getNamespace("future")
[13:20:50.704]                           version <- ns[[".package"]][["version"]]
[13:20:50.704]                           if (is.null(version)) 
[13:20:50.704]                             version <- utils::packageVersion("future")
[13:20:50.704]                         }
[13:20:50.704]                         else {
[13:20:50.704]                           version <- NULL
[13:20:50.704]                         }
[13:20:50.704]                         if (!has_future || version < "1.8.0") {
[13:20:50.704]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.704]                             "", base::R.version$version.string), 
[13:20:50.704]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:50.704]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.704]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.704]                               "release", "version")], collapse = " "), 
[13:20:50.704]                             hostname = base::Sys.info()[["nodename"]])
[13:20:50.704]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.704]                             info)
[13:20:50.704]                           info <- base::paste(info, collapse = "; ")
[13:20:50.704]                           if (!has_future) {
[13:20:50.704]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.704]                               info)
[13:20:50.704]                           }
[13:20:50.704]                           else {
[13:20:50.704]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.704]                               info, version)
[13:20:50.704]                           }
[13:20:50.704]                           base::stop(msg)
[13:20:50.704]                         }
[13:20:50.704]                       })
[13:20:50.704]                     }
[13:20:50.704]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:50.704]                     base::options(mc.cores = 1L)
[13:20:50.704]                   }
[13:20:50.704]                   options(future.plan = NULL)
[13:20:50.704]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.704]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.704]                 }
[13:20:50.704]                 ...future.workdir <- getwd()
[13:20:50.704]             }
[13:20:50.704]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.704]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.704]         }
[13:20:50.704]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.704]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:50.704]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.704]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.704]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.704]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.704]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.704]             base::names(...future.oldOptions))
[13:20:50.704]     }
[13:20:50.704]     if (FALSE) {
[13:20:50.704]     }
[13:20:50.704]     else {
[13:20:50.704]         if (TRUE) {
[13:20:50.704]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.704]                 open = "w")
[13:20:50.704]         }
[13:20:50.704]         else {
[13:20:50.704]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.704]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.704]         }
[13:20:50.704]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.704]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.704]             base::sink(type = "output", split = FALSE)
[13:20:50.704]             base::close(...future.stdout)
[13:20:50.704]         }, add = TRUE)
[13:20:50.704]     }
[13:20:50.704]     ...future.frame <- base::sys.nframe()
[13:20:50.704]     ...future.conditions <- base::list()
[13:20:50.704]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.704]     if (FALSE) {
[13:20:50.704]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.704]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.704]     }
[13:20:50.704]     ...future.result <- base::tryCatch({
[13:20:50.704]         base::withCallingHandlers({
[13:20:50.704]             ...future.value <- base::withVisible(base::local({
[13:20:50.704]                 withCallingHandlers({
[13:20:50.704]                   {
[13:20:50.704]                     b <- a
[13:20:50.704]                     a <- 2
[13:20:50.704]                     a * b
[13:20:50.704]                   }
[13:20:50.704]                 }, immediateCondition = function(cond) {
[13:20:50.704]                   save_rds <- function (object, pathname, ...) 
[13:20:50.704]                   {
[13:20:50.704]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:50.704]                     if (file_test("-f", pathname_tmp)) {
[13:20:50.704]                       fi_tmp <- file.info(pathname_tmp)
[13:20:50.704]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:50.704]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:50.704]                         fi_tmp[["mtime"]])
[13:20:50.704]                     }
[13:20:50.704]                     tryCatch({
[13:20:50.704]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:50.704]                     }, error = function(ex) {
[13:20:50.704]                       msg <- conditionMessage(ex)
[13:20:50.704]                       fi_tmp <- file.info(pathname_tmp)
[13:20:50.704]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:50.704]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:50.704]                         fi_tmp[["mtime"]], msg)
[13:20:50.704]                       ex$message <- msg
[13:20:50.704]                       stop(ex)
[13:20:50.704]                     })
[13:20:50.704]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:50.704]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:50.704]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:50.704]                       fi_tmp <- file.info(pathname_tmp)
[13:20:50.704]                       fi <- file.info(pathname)
[13:20:50.704]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:50.704]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:50.704]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:50.704]                         fi[["size"]], fi[["mtime"]])
[13:20:50.704]                       stop(msg)
[13:20:50.704]                     }
[13:20:50.704]                     invisible(pathname)
[13:20:50.704]                   }
[13:20:50.704]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:50.704]                     rootPath = tempdir()) 
[13:20:50.704]                   {
[13:20:50.704]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:50.704]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:50.704]                       tmpdir = path, fileext = ".rds")
[13:20:50.704]                     save_rds(obj, file)
[13:20:50.704]                   }
[13:20:50.704]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:50.704]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.704]                   {
[13:20:50.704]                     inherits <- base::inherits
[13:20:50.704]                     invokeRestart <- base::invokeRestart
[13:20:50.704]                     is.null <- base::is.null
[13:20:50.704]                     muffled <- FALSE
[13:20:50.704]                     if (inherits(cond, "message")) {
[13:20:50.704]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:50.704]                       if (muffled) 
[13:20:50.704]                         invokeRestart("muffleMessage")
[13:20:50.704]                     }
[13:20:50.704]                     else if (inherits(cond, "warning")) {
[13:20:50.704]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:50.704]                       if (muffled) 
[13:20:50.704]                         invokeRestart("muffleWarning")
[13:20:50.704]                     }
[13:20:50.704]                     else if (inherits(cond, "condition")) {
[13:20:50.704]                       if (!is.null(pattern)) {
[13:20:50.704]                         computeRestarts <- base::computeRestarts
[13:20:50.704]                         grepl <- base::grepl
[13:20:50.704]                         restarts <- computeRestarts(cond)
[13:20:50.704]                         for (restart in restarts) {
[13:20:50.704]                           name <- restart$name
[13:20:50.704]                           if (is.null(name)) 
[13:20:50.704]                             next
[13:20:50.704]                           if (!grepl(pattern, name)) 
[13:20:50.704]                             next
[13:20:50.704]                           invokeRestart(restart)
[13:20:50.704]                           muffled <- TRUE
[13:20:50.704]                           break
[13:20:50.704]                         }
[13:20:50.704]                       }
[13:20:50.704]                     }
[13:20:50.704]                     invisible(muffled)
[13:20:50.704]                   }
[13:20:50.704]                   muffleCondition(cond)
[13:20:50.704]                 })
[13:20:50.704]             }))
[13:20:50.704]             future::FutureResult(value = ...future.value$value, 
[13:20:50.704]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.704]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.704]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.704]                     ...future.globalenv.names))
[13:20:50.704]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.704]         }, condition = base::local({
[13:20:50.704]             c <- base::c
[13:20:50.704]             inherits <- base::inherits
[13:20:50.704]             invokeRestart <- base::invokeRestart
[13:20:50.704]             length <- base::length
[13:20:50.704]             list <- base::list
[13:20:50.704]             seq.int <- base::seq.int
[13:20:50.704]             signalCondition <- base::signalCondition
[13:20:50.704]             sys.calls <- base::sys.calls
[13:20:50.704]             `[[` <- base::`[[`
[13:20:50.704]             `+` <- base::`+`
[13:20:50.704]             `<<-` <- base::`<<-`
[13:20:50.704]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.704]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.704]                   3L)]
[13:20:50.704]             }
[13:20:50.704]             function(cond) {
[13:20:50.704]                 is_error <- inherits(cond, "error")
[13:20:50.704]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.704]                   NULL)
[13:20:50.704]                 if (is_error) {
[13:20:50.704]                   sessionInformation <- function() {
[13:20:50.704]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.704]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.704]                       search = base::search(), system = base::Sys.info())
[13:20:50.704]                   }
[13:20:50.704]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.704]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.704]                     cond$call), session = sessionInformation(), 
[13:20:50.704]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.704]                   signalCondition(cond)
[13:20:50.704]                 }
[13:20:50.704]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.704]                 "immediateCondition"))) {
[13:20:50.704]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.704]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.704]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.704]                   if (TRUE && !signal) {
[13:20:50.704]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.704]                     {
[13:20:50.704]                       inherits <- base::inherits
[13:20:50.704]                       invokeRestart <- base::invokeRestart
[13:20:50.704]                       is.null <- base::is.null
[13:20:50.704]                       muffled <- FALSE
[13:20:50.704]                       if (inherits(cond, "message")) {
[13:20:50.704]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.704]                         if (muffled) 
[13:20:50.704]                           invokeRestart("muffleMessage")
[13:20:50.704]                       }
[13:20:50.704]                       else if (inherits(cond, "warning")) {
[13:20:50.704]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.704]                         if (muffled) 
[13:20:50.704]                           invokeRestart("muffleWarning")
[13:20:50.704]                       }
[13:20:50.704]                       else if (inherits(cond, "condition")) {
[13:20:50.704]                         if (!is.null(pattern)) {
[13:20:50.704]                           computeRestarts <- base::computeRestarts
[13:20:50.704]                           grepl <- base::grepl
[13:20:50.704]                           restarts <- computeRestarts(cond)
[13:20:50.704]                           for (restart in restarts) {
[13:20:50.704]                             name <- restart$name
[13:20:50.704]                             if (is.null(name)) 
[13:20:50.704]                               next
[13:20:50.704]                             if (!grepl(pattern, name)) 
[13:20:50.704]                               next
[13:20:50.704]                             invokeRestart(restart)
[13:20:50.704]                             muffled <- TRUE
[13:20:50.704]                             break
[13:20:50.704]                           }
[13:20:50.704]                         }
[13:20:50.704]                       }
[13:20:50.704]                       invisible(muffled)
[13:20:50.704]                     }
[13:20:50.704]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.704]                   }
[13:20:50.704]                 }
[13:20:50.704]                 else {
[13:20:50.704]                   if (TRUE) {
[13:20:50.704]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.704]                     {
[13:20:50.704]                       inherits <- base::inherits
[13:20:50.704]                       invokeRestart <- base::invokeRestart
[13:20:50.704]                       is.null <- base::is.null
[13:20:50.704]                       muffled <- FALSE
[13:20:50.704]                       if (inherits(cond, "message")) {
[13:20:50.704]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.704]                         if (muffled) 
[13:20:50.704]                           invokeRestart("muffleMessage")
[13:20:50.704]                       }
[13:20:50.704]                       else if (inherits(cond, "warning")) {
[13:20:50.704]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.704]                         if (muffled) 
[13:20:50.704]                           invokeRestart("muffleWarning")
[13:20:50.704]                       }
[13:20:50.704]                       else if (inherits(cond, "condition")) {
[13:20:50.704]                         if (!is.null(pattern)) {
[13:20:50.704]                           computeRestarts <- base::computeRestarts
[13:20:50.704]                           grepl <- base::grepl
[13:20:50.704]                           restarts <- computeRestarts(cond)
[13:20:50.704]                           for (restart in restarts) {
[13:20:50.704]                             name <- restart$name
[13:20:50.704]                             if (is.null(name)) 
[13:20:50.704]                               next
[13:20:50.704]                             if (!grepl(pattern, name)) 
[13:20:50.704]                               next
[13:20:50.704]                             invokeRestart(restart)
[13:20:50.704]                             muffled <- TRUE
[13:20:50.704]                             break
[13:20:50.704]                           }
[13:20:50.704]                         }
[13:20:50.704]                       }
[13:20:50.704]                       invisible(muffled)
[13:20:50.704]                     }
[13:20:50.704]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.704]                   }
[13:20:50.704]                 }
[13:20:50.704]             }
[13:20:50.704]         }))
[13:20:50.704]     }, error = function(ex) {
[13:20:50.704]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.704]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.704]                 ...future.rng), started = ...future.startTime, 
[13:20:50.704]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.704]             version = "1.8"), class = "FutureResult")
[13:20:50.704]     }, finally = {
[13:20:50.704]         if (!identical(...future.workdir, getwd())) 
[13:20:50.704]             setwd(...future.workdir)
[13:20:50.704]         {
[13:20:50.704]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.704]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.704]             }
[13:20:50.704]             base::options(...future.oldOptions)
[13:20:50.704]             if (.Platform$OS.type == "windows") {
[13:20:50.704]                 old_names <- names(...future.oldEnvVars)
[13:20:50.704]                 envs <- base::Sys.getenv()
[13:20:50.704]                 names <- names(envs)
[13:20:50.704]                 common <- intersect(names, old_names)
[13:20:50.704]                 added <- setdiff(names, old_names)
[13:20:50.704]                 removed <- setdiff(old_names, names)
[13:20:50.704]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.704]                   envs[common]]
[13:20:50.704]                 NAMES <- toupper(changed)
[13:20:50.704]                 args <- list()
[13:20:50.704]                 for (kk in seq_along(NAMES)) {
[13:20:50.704]                   name <- changed[[kk]]
[13:20:50.704]                   NAME <- NAMES[[kk]]
[13:20:50.704]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.704]                     next
[13:20:50.704]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.704]                 }
[13:20:50.704]                 NAMES <- toupper(added)
[13:20:50.704]                 for (kk in seq_along(NAMES)) {
[13:20:50.704]                   name <- added[[kk]]
[13:20:50.704]                   NAME <- NAMES[[kk]]
[13:20:50.704]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.704]                     next
[13:20:50.704]                   args[[name]] <- ""
[13:20:50.704]                 }
[13:20:50.704]                 NAMES <- toupper(removed)
[13:20:50.704]                 for (kk in seq_along(NAMES)) {
[13:20:50.704]                   name <- removed[[kk]]
[13:20:50.704]                   NAME <- NAMES[[kk]]
[13:20:50.704]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.704]                     next
[13:20:50.704]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.704]                 }
[13:20:50.704]                 if (length(args) > 0) 
[13:20:50.704]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.704]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.704]             }
[13:20:50.704]             else {
[13:20:50.704]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.704]             }
[13:20:50.704]             {
[13:20:50.704]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.704]                   0L) {
[13:20:50.704]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.704]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.704]                   base::options(opts)
[13:20:50.704]                 }
[13:20:50.704]                 {
[13:20:50.704]                   {
[13:20:50.704]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:50.704]                     NULL
[13:20:50.704]                   }
[13:20:50.704]                   options(future.plan = NULL)
[13:20:50.704]                   if (is.na(NA_character_)) 
[13:20:50.704]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.704]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.704]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:50.704]                     envir = parent.frame()) 
[13:20:50.704]                   {
[13:20:50.704]                     default_workers <- missing(workers)
[13:20:50.704]                     if (is.function(workers)) 
[13:20:50.704]                       workers <- workers()
[13:20:50.704]                     workers <- structure(as.integer(workers), 
[13:20:50.704]                       class = class(workers))
[13:20:50.704]                     stop_if_not(is.finite(workers), workers >= 
[13:20:50.704]                       1L)
[13:20:50.704]                     if ((workers == 1L && !inherits(workers, 
[13:20:50.704]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:50.704]                       if (default_workers) 
[13:20:50.704]                         supportsMulticore(warn = TRUE)
[13:20:50.704]                       return(sequential(..., envir = envir))
[13:20:50.704]                     }
[13:20:50.704]                     oopts <- options(mc.cores = workers)
[13:20:50.704]                     on.exit(options(oopts))
[13:20:50.704]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:50.704]                       envir = envir)
[13:20:50.704]                     if (!future$lazy) 
[13:20:50.704]                       future <- run(future)
[13:20:50.704]                     invisible(future)
[13:20:50.704]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.704]                 }
[13:20:50.704]             }
[13:20:50.704]         }
[13:20:50.704]     })
[13:20:50.704]     if (TRUE) {
[13:20:50.704]         base::sink(type = "output", split = FALSE)
[13:20:50.704]         if (TRUE) {
[13:20:50.704]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.704]         }
[13:20:50.704]         else {
[13:20:50.704]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.704]         }
[13:20:50.704]         base::close(...future.stdout)
[13:20:50.704]         ...future.stdout <- NULL
[13:20:50.704]     }
[13:20:50.704]     ...future.result$conditions <- ...future.conditions
[13:20:50.704]     ...future.result$finished <- base::Sys.time()
[13:20:50.704]     ...future.result
[13:20:50.704] }
[13:20:50.706] requestCore(): workers = 2
[13:20:50.709] MulticoreFuture started
[13:20:50.709] - Launch lazy future ... done
[13:20:50.710] run() for ‘MulticoreFuture’ ... done
[13:20:50.710] plan(): Setting new future strategy stack:
[13:20:50.710] List of future strategies:
[13:20:50.710] 1. sequential:
[13:20:50.710]    - args: function (..., envir = parent.frame())
[13:20:50.710]    - tweaked: FALSE
[13:20:50.710]    - call: NULL
[13:20:50.711] plan(): nbrOfWorkers() = 1
[13:20:50.713] plan(): Setting new future strategy stack:
[13:20:50.713] List of future strategies:
[13:20:50.713] 1. multicore:
[13:20:50.713]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:50.713]    - tweaked: FALSE
[13:20:50.713]    - call: plan(strategy)
[13:20:50.718] plan(): nbrOfWorkers() = 2
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.724] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.724] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.726] - globals found: [3] ‘{’, ‘<-’, ‘*’
[13:20:50.726] Searching for globals ... DONE
[13:20:50.726] Resolving globals: TRUE
[13:20:50.726] Resolving any globals that are futures ...
[13:20:50.726] - globals: [3] ‘{’, ‘<-’, ‘*’
[13:20:50.727] Resolving any globals that are futures ... DONE
[13:20:50.727] 
[13:20:50.727] 
[13:20:50.727] getGlobalsAndPackages() ... DONE
[13:20:50.728] run() for ‘Future’ ...
[13:20:50.728] - state: ‘created’
[13:20:50.728] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:50.732] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:50.732] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:50.732]   - Field: ‘label’
[13:20:50.732]   - Field: ‘local’
[13:20:50.733]   - Field: ‘owner’
[13:20:50.733]   - Field: ‘envir’
[13:20:50.733]   - Field: ‘workers’
[13:20:50.733]   - Field: ‘packages’
[13:20:50.733]   - Field: ‘gc’
[13:20:50.733]   - Field: ‘job’
[13:20:50.733]   - Field: ‘conditions’
[13:20:50.734]   - Field: ‘expr’
[13:20:50.736]   - Field: ‘uuid’
[13:20:50.736]   - Field: ‘seed’
[13:20:50.736]   - Field: ‘version’
[13:20:50.737]   - Field: ‘result’
[13:20:50.737]   - Field: ‘asynchronous’
[13:20:50.737]   - Field: ‘calls’
[13:20:50.737]   - Field: ‘globals’
[13:20:50.737]   - Field: ‘stdout’
[13:20:50.737]   - Field: ‘earlySignal’
[13:20:50.738]   - Field: ‘lazy’
[13:20:50.738]   - Field: ‘state’
[13:20:50.738] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:50.738] - Launch lazy future ...
[13:20:50.738] Packages needed by the future expression (n = 0): <none>
[13:20:50.739] Packages needed by future strategies (n = 0): <none>
[13:20:50.739] {
[13:20:50.739]     {
[13:20:50.739]         {
[13:20:50.739]             ...future.startTime <- base::Sys.time()
[13:20:50.739]             {
[13:20:50.739]                 {
[13:20:50.739]                   {
[13:20:50.739]                     {
[13:20:50.739]                       base::local({
[13:20:50.739]                         has_future <- base::requireNamespace("future", 
[13:20:50.739]                           quietly = TRUE)
[13:20:50.739]                         if (has_future) {
[13:20:50.739]                           ns <- base::getNamespace("future")
[13:20:50.739]                           version <- ns[[".package"]][["version"]]
[13:20:50.739]                           if (is.null(version)) 
[13:20:50.739]                             version <- utils::packageVersion("future")
[13:20:50.739]                         }
[13:20:50.739]                         else {
[13:20:50.739]                           version <- NULL
[13:20:50.739]                         }
[13:20:50.739]                         if (!has_future || version < "1.8.0") {
[13:20:50.739]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.739]                             "", base::R.version$version.string), 
[13:20:50.739]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:50.739]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.739]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.739]                               "release", "version")], collapse = " "), 
[13:20:50.739]                             hostname = base::Sys.info()[["nodename"]])
[13:20:50.739]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.739]                             info)
[13:20:50.739]                           info <- base::paste(info, collapse = "; ")
[13:20:50.739]                           if (!has_future) {
[13:20:50.739]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.739]                               info)
[13:20:50.739]                           }
[13:20:50.739]                           else {
[13:20:50.739]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.739]                               info, version)
[13:20:50.739]                           }
[13:20:50.739]                           base::stop(msg)
[13:20:50.739]                         }
[13:20:50.739]                       })
[13:20:50.739]                     }
[13:20:50.739]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:50.739]                     base::options(mc.cores = 1L)
[13:20:50.739]                   }
[13:20:50.739]                   options(future.plan = NULL)
[13:20:50.739]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.739]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.739]                 }
[13:20:50.739]                 ...future.workdir <- getwd()
[13:20:50.739]             }
[13:20:50.739]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.739]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.739]         }
[13:20:50.739]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.739]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:50.739]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.739]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.739]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.739]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.739]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.739]             base::names(...future.oldOptions))
[13:20:50.739]     }
[13:20:50.739]     if (FALSE) {
[13:20:50.739]     }
[13:20:50.739]     else {
[13:20:50.739]         if (TRUE) {
[13:20:50.739]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.739]                 open = "w")
[13:20:50.739]         }
[13:20:50.739]         else {
[13:20:50.739]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.739]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.739]         }
[13:20:50.739]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.739]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.739]             base::sink(type = "output", split = FALSE)
[13:20:50.739]             base::close(...future.stdout)
[13:20:50.739]         }, add = TRUE)
[13:20:50.739]     }
[13:20:50.739]     ...future.frame <- base::sys.nframe()
[13:20:50.739]     ...future.conditions <- base::list()
[13:20:50.739]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.739]     if (FALSE) {
[13:20:50.739]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.739]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.739]     }
[13:20:50.739]     ...future.result <- base::tryCatch({
[13:20:50.739]         base::withCallingHandlers({
[13:20:50.739]             ...future.value <- base::withVisible(base::local({
[13:20:50.739]                 withCallingHandlers({
[13:20:50.739]                   {
[13:20:50.739]                     b <- a
[13:20:50.739]                     a <- 2
[13:20:50.739]                     a * b
[13:20:50.739]                   }
[13:20:50.739]                 }, immediateCondition = function(cond) {
[13:20:50.739]                   save_rds <- function (object, pathname, ...) 
[13:20:50.739]                   {
[13:20:50.739]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:50.739]                     if (file_test("-f", pathname_tmp)) {
[13:20:50.739]                       fi_tmp <- file.info(pathname_tmp)
[13:20:50.739]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:50.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:50.739]                         fi_tmp[["mtime"]])
[13:20:50.739]                     }
[13:20:50.739]                     tryCatch({
[13:20:50.739]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:50.739]                     }, error = function(ex) {
[13:20:50.739]                       msg <- conditionMessage(ex)
[13:20:50.739]                       fi_tmp <- file.info(pathname_tmp)
[13:20:50.739]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:50.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:50.739]                         fi_tmp[["mtime"]], msg)
[13:20:50.739]                       ex$message <- msg
[13:20:50.739]                       stop(ex)
[13:20:50.739]                     })
[13:20:50.739]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:50.739]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:50.739]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:50.739]                       fi_tmp <- file.info(pathname_tmp)
[13:20:50.739]                       fi <- file.info(pathname)
[13:20:50.739]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:50.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:50.739]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:50.739]                         fi[["size"]], fi[["mtime"]])
[13:20:50.739]                       stop(msg)
[13:20:50.739]                     }
[13:20:50.739]                     invisible(pathname)
[13:20:50.739]                   }
[13:20:50.739]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:50.739]                     rootPath = tempdir()) 
[13:20:50.739]                   {
[13:20:50.739]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:50.739]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:50.739]                       tmpdir = path, fileext = ".rds")
[13:20:50.739]                     save_rds(obj, file)
[13:20:50.739]                   }
[13:20:50.739]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:50.739]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.739]                   {
[13:20:50.739]                     inherits <- base::inherits
[13:20:50.739]                     invokeRestart <- base::invokeRestart
[13:20:50.739]                     is.null <- base::is.null
[13:20:50.739]                     muffled <- FALSE
[13:20:50.739]                     if (inherits(cond, "message")) {
[13:20:50.739]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:50.739]                       if (muffled) 
[13:20:50.739]                         invokeRestart("muffleMessage")
[13:20:50.739]                     }
[13:20:50.739]                     else if (inherits(cond, "warning")) {
[13:20:50.739]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:50.739]                       if (muffled) 
[13:20:50.739]                         invokeRestart("muffleWarning")
[13:20:50.739]                     }
[13:20:50.739]                     else if (inherits(cond, "condition")) {
[13:20:50.739]                       if (!is.null(pattern)) {
[13:20:50.739]                         computeRestarts <- base::computeRestarts
[13:20:50.739]                         grepl <- base::grepl
[13:20:50.739]                         restarts <- computeRestarts(cond)
[13:20:50.739]                         for (restart in restarts) {
[13:20:50.739]                           name <- restart$name
[13:20:50.739]                           if (is.null(name)) 
[13:20:50.739]                             next
[13:20:50.739]                           if (!grepl(pattern, name)) 
[13:20:50.739]                             next
[13:20:50.739]                           invokeRestart(restart)
[13:20:50.739]                           muffled <- TRUE
[13:20:50.739]                           break
[13:20:50.739]                         }
[13:20:50.739]                       }
[13:20:50.739]                     }
[13:20:50.739]                     invisible(muffled)
[13:20:50.739]                   }
[13:20:50.739]                   muffleCondition(cond)
[13:20:50.739]                 })
[13:20:50.739]             }))
[13:20:50.739]             future::FutureResult(value = ...future.value$value, 
[13:20:50.739]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.739]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.739]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.739]                     ...future.globalenv.names))
[13:20:50.739]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.739]         }, condition = base::local({
[13:20:50.739]             c <- base::c
[13:20:50.739]             inherits <- base::inherits
[13:20:50.739]             invokeRestart <- base::invokeRestart
[13:20:50.739]             length <- base::length
[13:20:50.739]             list <- base::list
[13:20:50.739]             seq.int <- base::seq.int
[13:20:50.739]             signalCondition <- base::signalCondition
[13:20:50.739]             sys.calls <- base::sys.calls
[13:20:50.739]             `[[` <- base::`[[`
[13:20:50.739]             `+` <- base::`+`
[13:20:50.739]             `<<-` <- base::`<<-`
[13:20:50.739]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.739]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.739]                   3L)]
[13:20:50.739]             }
[13:20:50.739]             function(cond) {
[13:20:50.739]                 is_error <- inherits(cond, "error")
[13:20:50.739]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.739]                   NULL)
[13:20:50.739]                 if (is_error) {
[13:20:50.739]                   sessionInformation <- function() {
[13:20:50.739]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.739]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.739]                       search = base::search(), system = base::Sys.info())
[13:20:50.739]                   }
[13:20:50.739]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.739]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.739]                     cond$call), session = sessionInformation(), 
[13:20:50.739]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.739]                   signalCondition(cond)
[13:20:50.739]                 }
[13:20:50.739]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.739]                 "immediateCondition"))) {
[13:20:50.739]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.739]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.739]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.739]                   if (TRUE && !signal) {
[13:20:50.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.739]                     {
[13:20:50.739]                       inherits <- base::inherits
[13:20:50.739]                       invokeRestart <- base::invokeRestart
[13:20:50.739]                       is.null <- base::is.null
[13:20:50.739]                       muffled <- FALSE
[13:20:50.739]                       if (inherits(cond, "message")) {
[13:20:50.739]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.739]                         if (muffled) 
[13:20:50.739]                           invokeRestart("muffleMessage")
[13:20:50.739]                       }
[13:20:50.739]                       else if (inherits(cond, "warning")) {
[13:20:50.739]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.739]                         if (muffled) 
[13:20:50.739]                           invokeRestart("muffleWarning")
[13:20:50.739]                       }
[13:20:50.739]                       else if (inherits(cond, "condition")) {
[13:20:50.739]                         if (!is.null(pattern)) {
[13:20:50.739]                           computeRestarts <- base::computeRestarts
[13:20:50.739]                           grepl <- base::grepl
[13:20:50.739]                           restarts <- computeRestarts(cond)
[13:20:50.739]                           for (restart in restarts) {
[13:20:50.739]                             name <- restart$name
[13:20:50.739]                             if (is.null(name)) 
[13:20:50.739]                               next
[13:20:50.739]                             if (!grepl(pattern, name)) 
[13:20:50.739]                               next
[13:20:50.739]                             invokeRestart(restart)
[13:20:50.739]                             muffled <- TRUE
[13:20:50.739]                             break
[13:20:50.739]                           }
[13:20:50.739]                         }
[13:20:50.739]                       }
[13:20:50.739]                       invisible(muffled)
[13:20:50.739]                     }
[13:20:50.739]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.739]                   }
[13:20:50.739]                 }
[13:20:50.739]                 else {
[13:20:50.739]                   if (TRUE) {
[13:20:50.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.739]                     {
[13:20:50.739]                       inherits <- base::inherits
[13:20:50.739]                       invokeRestart <- base::invokeRestart
[13:20:50.739]                       is.null <- base::is.null
[13:20:50.739]                       muffled <- FALSE
[13:20:50.739]                       if (inherits(cond, "message")) {
[13:20:50.739]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.739]                         if (muffled) 
[13:20:50.739]                           invokeRestart("muffleMessage")
[13:20:50.739]                       }
[13:20:50.739]                       else if (inherits(cond, "warning")) {
[13:20:50.739]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.739]                         if (muffled) 
[13:20:50.739]                           invokeRestart("muffleWarning")
[13:20:50.739]                       }
[13:20:50.739]                       else if (inherits(cond, "condition")) {
[13:20:50.739]                         if (!is.null(pattern)) {
[13:20:50.739]                           computeRestarts <- base::computeRestarts
[13:20:50.739]                           grepl <- base::grepl
[13:20:50.739]                           restarts <- computeRestarts(cond)
[13:20:50.739]                           for (restart in restarts) {
[13:20:50.739]                             name <- restart$name
[13:20:50.739]                             if (is.null(name)) 
[13:20:50.739]                               next
[13:20:50.739]                             if (!grepl(pattern, name)) 
[13:20:50.739]                               next
[13:20:50.739]                             invokeRestart(restart)
[13:20:50.739]                             muffled <- TRUE
[13:20:50.739]                             break
[13:20:50.739]                           }
[13:20:50.739]                         }
[13:20:50.739]                       }
[13:20:50.739]                       invisible(muffled)
[13:20:50.739]                     }
[13:20:50.739]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.739]                   }
[13:20:50.739]                 }
[13:20:50.739]             }
[13:20:50.739]         }))
[13:20:50.739]     }, error = function(ex) {
[13:20:50.739]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.739]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.739]                 ...future.rng), started = ...future.startTime, 
[13:20:50.739]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.739]             version = "1.8"), class = "FutureResult")
[13:20:50.739]     }, finally = {
[13:20:50.739]         if (!identical(...future.workdir, getwd())) 
[13:20:50.739]             setwd(...future.workdir)
[13:20:50.739]         {
[13:20:50.739]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.739]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.739]             }
[13:20:50.739]             base::options(...future.oldOptions)
[13:20:50.739]             if (.Platform$OS.type == "windows") {
[13:20:50.739]                 old_names <- names(...future.oldEnvVars)
[13:20:50.739]                 envs <- base::Sys.getenv()
[13:20:50.739]                 names <- names(envs)
[13:20:50.739]                 common <- intersect(names, old_names)
[13:20:50.739]                 added <- setdiff(names, old_names)
[13:20:50.739]                 removed <- setdiff(old_names, names)
[13:20:50.739]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.739]                   envs[common]]
[13:20:50.739]                 NAMES <- toupper(changed)
[13:20:50.739]                 args <- list()
[13:20:50.739]                 for (kk in seq_along(NAMES)) {
[13:20:50.739]                   name <- changed[[kk]]
[13:20:50.739]                   NAME <- NAMES[[kk]]
[13:20:50.739]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.739]                     next
[13:20:50.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.739]                 }
[13:20:50.739]                 NAMES <- toupper(added)
[13:20:50.739]                 for (kk in seq_along(NAMES)) {
[13:20:50.739]                   name <- added[[kk]]
[13:20:50.739]                   NAME <- NAMES[[kk]]
[13:20:50.739]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.739]                     next
[13:20:50.739]                   args[[name]] <- ""
[13:20:50.739]                 }
[13:20:50.739]                 NAMES <- toupper(removed)
[13:20:50.739]                 for (kk in seq_along(NAMES)) {
[13:20:50.739]                   name <- removed[[kk]]
[13:20:50.739]                   NAME <- NAMES[[kk]]
[13:20:50.739]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.739]                     next
[13:20:50.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.739]                 }
[13:20:50.739]                 if (length(args) > 0) 
[13:20:50.739]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.739]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.739]             }
[13:20:50.739]             else {
[13:20:50.739]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.739]             }
[13:20:50.739]             {
[13:20:50.739]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.739]                   0L) {
[13:20:50.739]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.739]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.739]                   base::options(opts)
[13:20:50.739]                 }
[13:20:50.739]                 {
[13:20:50.739]                   {
[13:20:50.739]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:50.739]                     NULL
[13:20:50.739]                   }
[13:20:50.739]                   options(future.plan = NULL)
[13:20:50.739]                   if (is.na(NA_character_)) 
[13:20:50.739]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.739]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.739]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:50.739]                     envir = parent.frame()) 
[13:20:50.739]                   {
[13:20:50.739]                     default_workers <- missing(workers)
[13:20:50.739]                     if (is.function(workers)) 
[13:20:50.739]                       workers <- workers()
[13:20:50.739]                     workers <- structure(as.integer(workers), 
[13:20:50.739]                       class = class(workers))
[13:20:50.739]                     stop_if_not(is.finite(workers), workers >= 
[13:20:50.739]                       1L)
[13:20:50.739]                     if ((workers == 1L && !inherits(workers, 
[13:20:50.739]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:50.739]                       if (default_workers) 
[13:20:50.739]                         supportsMulticore(warn = TRUE)
[13:20:50.739]                       return(sequential(..., envir = envir))
[13:20:50.739]                     }
[13:20:50.739]                     oopts <- options(mc.cores = workers)
[13:20:50.739]                     on.exit(options(oopts))
[13:20:50.739]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:50.739]                       envir = envir)
[13:20:50.739]                     if (!future$lazy) 
[13:20:50.739]                       future <- run(future)
[13:20:50.739]                     invisible(future)
[13:20:50.739]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.739]                 }
[13:20:50.739]             }
[13:20:50.739]         }
[13:20:50.739]     })
[13:20:50.739]     if (TRUE) {
[13:20:50.739]         base::sink(type = "output", split = FALSE)
[13:20:50.739]         if (TRUE) {
[13:20:50.739]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.739]         }
[13:20:50.739]         else {
[13:20:50.739]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.739]         }
[13:20:50.739]         base::close(...future.stdout)
[13:20:50.739]         ...future.stdout <- NULL
[13:20:50.739]     }
[13:20:50.739]     ...future.result$conditions <- ...future.conditions
[13:20:50.739]     ...future.result$finished <- base::Sys.time()
[13:20:50.739]     ...future.result
[13:20:50.739] }
[13:20:50.742] requestCore(): workers = 2
[13:20:50.744] MulticoreFuture started
[13:20:50.744] - Launch lazy future ... done
[13:20:50.745] run() for ‘MulticoreFuture’ ... done
[13:20:50.745] plan(): Setting new future strategy stack:
[13:20:50.745] List of future strategies:
[13:20:50.745] 1. sequential:
[13:20:50.745]    - args: function (..., envir = parent.frame())
[13:20:50.745]    - tweaked: FALSE
[13:20:50.745]    - call: NULL
[13:20:50.746] plan(): nbrOfWorkers() = 1
[13:20:50.749] plan(): Setting new future strategy stack:
[13:20:50.749] List of future strategies:
[13:20:50.749] 1. multicore:
[13:20:50.749]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:50.749]    - tweaked: FALSE
[13:20:50.749]    - call: plan(strategy)
[13:20:50.755] plan(): nbrOfWorkers() = 2
[13:20:50.762] signalConditions() ...
[13:20:50.762]  - include = ‘immediateCondition’
[13:20:50.762]  - exclude = 
[13:20:50.763]  - resignal = FALSE
[13:20:50.763]  - Number of conditions: 1
[13:20:50.763] signalConditions() ... done
[13:20:50.763] signalConditions() ...
[13:20:50.763]  - include = ‘immediateCondition’
[13:20:50.763]  - exclude = 
[13:20:50.763]  - resignal = FALSE
[13:20:50.764]  - Number of conditions: 1
[13:20:50.764] signalConditions() ... done
[13:20:50.764] Future state: ‘finished’
[13:20:50.764] signalConditions() ...
[13:20:50.764]  - include = ‘condition’
[13:20:50.764]  - exclude = ‘immediateCondition’
[13:20:50.765]  - resignal = TRUE
[13:20:50.765]  - Number of conditions: 1
[13:20:50.765]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:50.765] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 39
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "5853cd8d1af0" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:20:50"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.794] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.795] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.796] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.796] Searching for globals ... DONE
[13:20:50.796] Resolving globals: TRUE
[13:20:50.796] Resolving any globals that are futures ...
[13:20:50.796] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.797] Resolving any globals that are futures ... DONE
[13:20:50.797] Resolving futures part of globals (recursively) ...
[13:20:50.797] resolve() on list ...
[13:20:50.797]  recursive: 99
[13:20:50.797]  length: 1
[13:20:50.797]  elements: ‘ii’
[13:20:50.798]  length: 0 (resolved future 1)
[13:20:50.798] resolve() on list ... DONE
[13:20:50.798] - globals: [1] ‘ii’
[13:20:50.798] Resolving futures part of globals (recursively) ... DONE
[13:20:50.798] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:50.798] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:50.799] - globals: [1] ‘ii’
[13:20:50.799] 
[13:20:50.799] getGlobalsAndPackages() ... DONE
[13:20:50.799] run() for ‘Future’ ...
[13:20:50.799] - state: ‘created’
[13:20:50.799] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:50.803] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:50.803] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:50.804]   - Field: ‘label’
[13:20:50.804]   - Field: ‘local’
[13:20:50.804]   - Field: ‘owner’
[13:20:50.804]   - Field: ‘envir’
[13:20:50.804]   - Field: ‘workers’
[13:20:50.804]   - Field: ‘packages’
[13:20:50.804]   - Field: ‘gc’
[13:20:50.805]   - Field: ‘job’
[13:20:50.805]   - Field: ‘conditions’
[13:20:50.805]   - Field: ‘expr’
[13:20:50.805]   - Field: ‘uuid’
[13:20:50.805]   - Field: ‘seed’
[13:20:50.805]   - Field: ‘version’
[13:20:50.805]   - Field: ‘result’
[13:20:50.805]   - Field: ‘asynchronous’
[13:20:50.806]   - Field: ‘calls’
[13:20:50.806]   - Field: ‘globals’
[13:20:50.806]   - Field: ‘stdout’
[13:20:50.806]   - Field: ‘earlySignal’
[13:20:50.806]   - Field: ‘lazy’
[13:20:50.806]   - Field: ‘state’
[13:20:50.806] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:50.806] - Launch lazy future ...
[13:20:50.807] Packages needed by the future expression (n = 0): <none>
[13:20:50.807] Packages needed by future strategies (n = 0): <none>
[13:20:50.807] {
[13:20:50.807]     {
[13:20:50.807]         {
[13:20:50.807]             ...future.startTime <- base::Sys.time()
[13:20:50.807]             {
[13:20:50.807]                 {
[13:20:50.807]                   {
[13:20:50.807]                     {
[13:20:50.807]                       base::local({
[13:20:50.807]                         has_future <- base::requireNamespace("future", 
[13:20:50.807]                           quietly = TRUE)
[13:20:50.807]                         if (has_future) {
[13:20:50.807]                           ns <- base::getNamespace("future")
[13:20:50.807]                           version <- ns[[".package"]][["version"]]
[13:20:50.807]                           if (is.null(version)) 
[13:20:50.807]                             version <- utils::packageVersion("future")
[13:20:50.807]                         }
[13:20:50.807]                         else {
[13:20:50.807]                           version <- NULL
[13:20:50.807]                         }
[13:20:50.807]                         if (!has_future || version < "1.8.0") {
[13:20:50.807]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.807]                             "", base::R.version$version.string), 
[13:20:50.807]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:50.807]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.807]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.807]                               "release", "version")], collapse = " "), 
[13:20:50.807]                             hostname = base::Sys.info()[["nodename"]])
[13:20:50.807]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.807]                             info)
[13:20:50.807]                           info <- base::paste(info, collapse = "; ")
[13:20:50.807]                           if (!has_future) {
[13:20:50.807]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.807]                               info)
[13:20:50.807]                           }
[13:20:50.807]                           else {
[13:20:50.807]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.807]                               info, version)
[13:20:50.807]                           }
[13:20:50.807]                           base::stop(msg)
[13:20:50.807]                         }
[13:20:50.807]                       })
[13:20:50.807]                     }
[13:20:50.807]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:50.807]                     base::options(mc.cores = 1L)
[13:20:50.807]                   }
[13:20:50.807]                   options(future.plan = NULL)
[13:20:50.807]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.807]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.807]                 }
[13:20:50.807]                 ...future.workdir <- getwd()
[13:20:50.807]             }
[13:20:50.807]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.807]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.807]         }
[13:20:50.807]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.807]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:50.807]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.807]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.807]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.807]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.807]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.807]             base::names(...future.oldOptions))
[13:20:50.807]     }
[13:20:50.807]     if (FALSE) {
[13:20:50.807]     }
[13:20:50.807]     else {
[13:20:50.807]         if (TRUE) {
[13:20:50.807]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.807]                 open = "w")
[13:20:50.807]         }
[13:20:50.807]         else {
[13:20:50.807]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.807]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.807]         }
[13:20:50.807]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.807]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.807]             base::sink(type = "output", split = FALSE)
[13:20:50.807]             base::close(...future.stdout)
[13:20:50.807]         }, add = TRUE)
[13:20:50.807]     }
[13:20:50.807]     ...future.frame <- base::sys.nframe()
[13:20:50.807]     ...future.conditions <- base::list()
[13:20:50.807]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.807]     if (FALSE) {
[13:20:50.807]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.807]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.807]     }
[13:20:50.807]     ...future.result <- base::tryCatch({
[13:20:50.807]         base::withCallingHandlers({
[13:20:50.807]             ...future.value <- base::withVisible(base::local({
[13:20:50.807]                 withCallingHandlers({
[13:20:50.807]                   {
[13:20:50.807]                     b <- a * ii
[13:20:50.807]                     a <- 0
[13:20:50.807]                     b
[13:20:50.807]                   }
[13:20:50.807]                 }, immediateCondition = function(cond) {
[13:20:50.807]                   save_rds <- function (object, pathname, ...) 
[13:20:50.807]                   {
[13:20:50.807]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:50.807]                     if (file_test("-f", pathname_tmp)) {
[13:20:50.807]                       fi_tmp <- file.info(pathname_tmp)
[13:20:50.807]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:50.807]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:50.807]                         fi_tmp[["mtime"]])
[13:20:50.807]                     }
[13:20:50.807]                     tryCatch({
[13:20:50.807]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:50.807]                     }, error = function(ex) {
[13:20:50.807]                       msg <- conditionMessage(ex)
[13:20:50.807]                       fi_tmp <- file.info(pathname_tmp)
[13:20:50.807]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:50.807]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:50.807]                         fi_tmp[["mtime"]], msg)
[13:20:50.807]                       ex$message <- msg
[13:20:50.807]                       stop(ex)
[13:20:50.807]                     })
[13:20:50.807]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:50.807]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:50.807]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:50.807]                       fi_tmp <- file.info(pathname_tmp)
[13:20:50.807]                       fi <- file.info(pathname)
[13:20:50.807]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:50.807]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:50.807]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:50.807]                         fi[["size"]], fi[["mtime"]])
[13:20:50.807]                       stop(msg)
[13:20:50.807]                     }
[13:20:50.807]                     invisible(pathname)
[13:20:50.807]                   }
[13:20:50.807]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:50.807]                     rootPath = tempdir()) 
[13:20:50.807]                   {
[13:20:50.807]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:50.807]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:50.807]                       tmpdir = path, fileext = ".rds")
[13:20:50.807]                     save_rds(obj, file)
[13:20:50.807]                   }
[13:20:50.807]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:50.807]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.807]                   {
[13:20:50.807]                     inherits <- base::inherits
[13:20:50.807]                     invokeRestart <- base::invokeRestart
[13:20:50.807]                     is.null <- base::is.null
[13:20:50.807]                     muffled <- FALSE
[13:20:50.807]                     if (inherits(cond, "message")) {
[13:20:50.807]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:50.807]                       if (muffled) 
[13:20:50.807]                         invokeRestart("muffleMessage")
[13:20:50.807]                     }
[13:20:50.807]                     else if (inherits(cond, "warning")) {
[13:20:50.807]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:50.807]                       if (muffled) 
[13:20:50.807]                         invokeRestart("muffleWarning")
[13:20:50.807]                     }
[13:20:50.807]                     else if (inherits(cond, "condition")) {
[13:20:50.807]                       if (!is.null(pattern)) {
[13:20:50.807]                         computeRestarts <- base::computeRestarts
[13:20:50.807]                         grepl <- base::grepl
[13:20:50.807]                         restarts <- computeRestarts(cond)
[13:20:50.807]                         for (restart in restarts) {
[13:20:50.807]                           name <- restart$name
[13:20:50.807]                           if (is.null(name)) 
[13:20:50.807]                             next
[13:20:50.807]                           if (!grepl(pattern, name)) 
[13:20:50.807]                             next
[13:20:50.807]                           invokeRestart(restart)
[13:20:50.807]                           muffled <- TRUE
[13:20:50.807]                           break
[13:20:50.807]                         }
[13:20:50.807]                       }
[13:20:50.807]                     }
[13:20:50.807]                     invisible(muffled)
[13:20:50.807]                   }
[13:20:50.807]                   muffleCondition(cond)
[13:20:50.807]                 })
[13:20:50.807]             }))
[13:20:50.807]             future::FutureResult(value = ...future.value$value, 
[13:20:50.807]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.807]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.807]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.807]                     ...future.globalenv.names))
[13:20:50.807]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.807]         }, condition = base::local({
[13:20:50.807]             c <- base::c
[13:20:50.807]             inherits <- base::inherits
[13:20:50.807]             invokeRestart <- base::invokeRestart
[13:20:50.807]             length <- base::length
[13:20:50.807]             list <- base::list
[13:20:50.807]             seq.int <- base::seq.int
[13:20:50.807]             signalCondition <- base::signalCondition
[13:20:50.807]             sys.calls <- base::sys.calls
[13:20:50.807]             `[[` <- base::`[[`
[13:20:50.807]             `+` <- base::`+`
[13:20:50.807]             `<<-` <- base::`<<-`
[13:20:50.807]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.807]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.807]                   3L)]
[13:20:50.807]             }
[13:20:50.807]             function(cond) {
[13:20:50.807]                 is_error <- inherits(cond, "error")
[13:20:50.807]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.807]                   NULL)
[13:20:50.807]                 if (is_error) {
[13:20:50.807]                   sessionInformation <- function() {
[13:20:50.807]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.807]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.807]                       search = base::search(), system = base::Sys.info())
[13:20:50.807]                   }
[13:20:50.807]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.807]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.807]                     cond$call), session = sessionInformation(), 
[13:20:50.807]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.807]                   signalCondition(cond)
[13:20:50.807]                 }
[13:20:50.807]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.807]                 "immediateCondition"))) {
[13:20:50.807]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.807]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.807]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.807]                   if (TRUE && !signal) {
[13:20:50.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.807]                     {
[13:20:50.807]                       inherits <- base::inherits
[13:20:50.807]                       invokeRestart <- base::invokeRestart
[13:20:50.807]                       is.null <- base::is.null
[13:20:50.807]                       muffled <- FALSE
[13:20:50.807]                       if (inherits(cond, "message")) {
[13:20:50.807]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.807]                         if (muffled) 
[13:20:50.807]                           invokeRestart("muffleMessage")
[13:20:50.807]                       }
[13:20:50.807]                       else if (inherits(cond, "warning")) {
[13:20:50.807]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.807]                         if (muffled) 
[13:20:50.807]                           invokeRestart("muffleWarning")
[13:20:50.807]                       }
[13:20:50.807]                       else if (inherits(cond, "condition")) {
[13:20:50.807]                         if (!is.null(pattern)) {
[13:20:50.807]                           computeRestarts <- base::computeRestarts
[13:20:50.807]                           grepl <- base::grepl
[13:20:50.807]                           restarts <- computeRestarts(cond)
[13:20:50.807]                           for (restart in restarts) {
[13:20:50.807]                             name <- restart$name
[13:20:50.807]                             if (is.null(name)) 
[13:20:50.807]                               next
[13:20:50.807]                             if (!grepl(pattern, name)) 
[13:20:50.807]                               next
[13:20:50.807]                             invokeRestart(restart)
[13:20:50.807]                             muffled <- TRUE
[13:20:50.807]                             break
[13:20:50.807]                           }
[13:20:50.807]                         }
[13:20:50.807]                       }
[13:20:50.807]                       invisible(muffled)
[13:20:50.807]                     }
[13:20:50.807]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.807]                   }
[13:20:50.807]                 }
[13:20:50.807]                 else {
[13:20:50.807]                   if (TRUE) {
[13:20:50.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.807]                     {
[13:20:50.807]                       inherits <- base::inherits
[13:20:50.807]                       invokeRestart <- base::invokeRestart
[13:20:50.807]                       is.null <- base::is.null
[13:20:50.807]                       muffled <- FALSE
[13:20:50.807]                       if (inherits(cond, "message")) {
[13:20:50.807]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.807]                         if (muffled) 
[13:20:50.807]                           invokeRestart("muffleMessage")
[13:20:50.807]                       }
[13:20:50.807]                       else if (inherits(cond, "warning")) {
[13:20:50.807]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.807]                         if (muffled) 
[13:20:50.807]                           invokeRestart("muffleWarning")
[13:20:50.807]                       }
[13:20:50.807]                       else if (inherits(cond, "condition")) {
[13:20:50.807]                         if (!is.null(pattern)) {
[13:20:50.807]                           computeRestarts <- base::computeRestarts
[13:20:50.807]                           grepl <- base::grepl
[13:20:50.807]                           restarts <- computeRestarts(cond)
[13:20:50.807]                           for (restart in restarts) {
[13:20:50.807]                             name <- restart$name
[13:20:50.807]                             if (is.null(name)) 
[13:20:50.807]                               next
[13:20:50.807]                             if (!grepl(pattern, name)) 
[13:20:50.807]                               next
[13:20:50.807]                             invokeRestart(restart)
[13:20:50.807]                             muffled <- TRUE
[13:20:50.807]                             break
[13:20:50.807]                           }
[13:20:50.807]                         }
[13:20:50.807]                       }
[13:20:50.807]                       invisible(muffled)
[13:20:50.807]                     }
[13:20:50.807]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.807]                   }
[13:20:50.807]                 }
[13:20:50.807]             }
[13:20:50.807]         }))
[13:20:50.807]     }, error = function(ex) {
[13:20:50.807]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.807]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.807]                 ...future.rng), started = ...future.startTime, 
[13:20:50.807]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.807]             version = "1.8"), class = "FutureResult")
[13:20:50.807]     }, finally = {
[13:20:50.807]         if (!identical(...future.workdir, getwd())) 
[13:20:50.807]             setwd(...future.workdir)
[13:20:50.807]         {
[13:20:50.807]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.807]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.807]             }
[13:20:50.807]             base::options(...future.oldOptions)
[13:20:50.807]             if (.Platform$OS.type == "windows") {
[13:20:50.807]                 old_names <- names(...future.oldEnvVars)
[13:20:50.807]                 envs <- base::Sys.getenv()
[13:20:50.807]                 names <- names(envs)
[13:20:50.807]                 common <- intersect(names, old_names)
[13:20:50.807]                 added <- setdiff(names, old_names)
[13:20:50.807]                 removed <- setdiff(old_names, names)
[13:20:50.807]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.807]                   envs[common]]
[13:20:50.807]                 NAMES <- toupper(changed)
[13:20:50.807]                 args <- list()
[13:20:50.807]                 for (kk in seq_along(NAMES)) {
[13:20:50.807]                   name <- changed[[kk]]
[13:20:50.807]                   NAME <- NAMES[[kk]]
[13:20:50.807]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.807]                     next
[13:20:50.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.807]                 }
[13:20:50.807]                 NAMES <- toupper(added)
[13:20:50.807]                 for (kk in seq_along(NAMES)) {
[13:20:50.807]                   name <- added[[kk]]
[13:20:50.807]                   NAME <- NAMES[[kk]]
[13:20:50.807]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.807]                     next
[13:20:50.807]                   args[[name]] <- ""
[13:20:50.807]                 }
[13:20:50.807]                 NAMES <- toupper(removed)
[13:20:50.807]                 for (kk in seq_along(NAMES)) {
[13:20:50.807]                   name <- removed[[kk]]
[13:20:50.807]                   NAME <- NAMES[[kk]]
[13:20:50.807]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.807]                     next
[13:20:50.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.807]                 }
[13:20:50.807]                 if (length(args) > 0) 
[13:20:50.807]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.807]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.807]             }
[13:20:50.807]             else {
[13:20:50.807]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.807]             }
[13:20:50.807]             {
[13:20:50.807]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.807]                   0L) {
[13:20:50.807]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.807]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.807]                   base::options(opts)
[13:20:50.807]                 }
[13:20:50.807]                 {
[13:20:50.807]                   {
[13:20:50.807]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:50.807]                     NULL
[13:20:50.807]                   }
[13:20:50.807]                   options(future.plan = NULL)
[13:20:50.807]                   if (is.na(NA_character_)) 
[13:20:50.807]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.807]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.807]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:50.807]                     envir = parent.frame()) 
[13:20:50.807]                   {
[13:20:50.807]                     default_workers <- missing(workers)
[13:20:50.807]                     if (is.function(workers)) 
[13:20:50.807]                       workers <- workers()
[13:20:50.807]                     workers <- structure(as.integer(workers), 
[13:20:50.807]                       class = class(workers))
[13:20:50.807]                     stop_if_not(is.finite(workers), workers >= 
[13:20:50.807]                       1L)
[13:20:50.807]                     if ((workers == 1L && !inherits(workers, 
[13:20:50.807]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:50.807]                       if (default_workers) 
[13:20:50.807]                         supportsMulticore(warn = TRUE)
[13:20:50.807]                       return(sequential(..., envir = envir))
[13:20:50.807]                     }
[13:20:50.807]                     oopts <- options(mc.cores = workers)
[13:20:50.807]                     on.exit(options(oopts))
[13:20:50.807]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:50.807]                       envir = envir)
[13:20:50.807]                     if (!future$lazy) 
[13:20:50.807]                       future <- run(future)
[13:20:50.807]                     invisible(future)
[13:20:50.807]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.807]                 }
[13:20:50.807]             }
[13:20:50.807]         }
[13:20:50.807]     })
[13:20:50.807]     if (TRUE) {
[13:20:50.807]         base::sink(type = "output", split = FALSE)
[13:20:50.807]         if (TRUE) {
[13:20:50.807]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.807]         }
[13:20:50.807]         else {
[13:20:50.807]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.807]         }
[13:20:50.807]         base::close(...future.stdout)
[13:20:50.807]         ...future.stdout <- NULL
[13:20:50.807]     }
[13:20:50.807]     ...future.result$conditions <- ...future.conditions
[13:20:50.807]     ...future.result$finished <- base::Sys.time()
[13:20:50.807]     ...future.result
[13:20:50.807] }
[13:20:50.810] assign_globals() ...
[13:20:50.810] List of 1
[13:20:50.810]  $ ii: int 1
[13:20:50.810]  - attr(*, "where")=List of 1
[13:20:50.810]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:50.810]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.810]  - attr(*, "resolved")= logi TRUE
[13:20:50.810]  - attr(*, "total_size")= num 56
[13:20:50.810]  - attr(*, "already-done")= logi TRUE
[13:20:50.812] - copied ‘ii’ to environment
[13:20:50.812] assign_globals() ... done
[13:20:50.813] requestCore(): workers = 2
[13:20:50.815] MulticoreFuture started
[13:20:50.815] - Launch lazy future ... done
[13:20:50.816] plan(): Setting new future strategy stack:
[13:20:50.815] run() for ‘MulticoreFuture’ ... done
[13:20:50.816] List of future strategies:
[13:20:50.816] 1. sequential:
[13:20:50.816]    - args: function (..., envir = parent.frame())
[13:20:50.816]    - tweaked: FALSE
[13:20:50.816]    - call: NULL
[13:20:50.820] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.821] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.822] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.823] plan(): Setting new future strategy stack:
[13:20:50.823] List of future strategies:
[13:20:50.823] 1. multicore:
[13:20:50.823]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:50.823]    - tweaked: FALSE
[13:20:50.823]    - call: plan(strategy)
[13:20:50.826] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.827] Searching for globals ... DONE
[13:20:50.827] Resolving globals: TRUE
[13:20:50.827] Resolving any globals that are futures ...
[13:20:50.827] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.828] Resolving any globals that are futures ... DONE
[13:20:50.828] Resolving futures part of globals (recursively) ...
[13:20:50.828] plan(): nbrOfWorkers() = 2
[13:20:50.829] resolve() on list ...
[13:20:50.829]  recursive: 99
[13:20:50.829]  length: 1
[13:20:50.830]  elements: ‘ii’
[13:20:50.830]  length: 0 (resolved future 1)
[13:20:50.830] resolve() on list ... DONE
[13:20:50.830] - globals: [1] ‘ii’
[13:20:50.830] Resolving futures part of globals (recursively) ... DONE
[13:20:50.831] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:50.831] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:50.832] - globals: [1] ‘ii’
[13:20:50.832] 
[13:20:50.832] getGlobalsAndPackages() ... DONE
[13:20:50.832] run() for ‘Future’ ...
[13:20:50.832] - state: ‘created’
[13:20:50.833] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:50.837] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:50.837] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:50.837]   - Field: ‘label’
[13:20:50.837]   - Field: ‘local’
[13:20:50.838]   - Field: ‘owner’
[13:20:50.838]   - Field: ‘envir’
[13:20:50.838]   - Field: ‘workers’
[13:20:50.838]   - Field: ‘packages’
[13:20:50.838]   - Field: ‘gc’
[13:20:50.838]   - Field: ‘job’
[13:20:50.838]   - Field: ‘conditions’
[13:20:50.839]   - Field: ‘expr’
[13:20:50.839]   - Field: ‘uuid’
[13:20:50.839]   - Field: ‘seed’
[13:20:50.839]   - Field: ‘version’
[13:20:50.839]   - Field: ‘result’
[13:20:50.839]   - Field: ‘asynchronous’
[13:20:50.839]   - Field: ‘calls’
[13:20:50.839]   - Field: ‘globals’
[13:20:50.840]   - Field: ‘stdout’
[13:20:50.840]   - Field: ‘earlySignal’
[13:20:50.840]   - Field: ‘lazy’
[13:20:50.840]   - Field: ‘state’
[13:20:50.840] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:50.840] - Launch lazy future ...
[13:20:50.841] Packages needed by the future expression (n = 0): <none>
[13:20:50.841] Packages needed by future strategies (n = 0): <none>
[13:20:50.842] {
[13:20:50.842]     {
[13:20:50.842]         {
[13:20:50.842]             ...future.startTime <- base::Sys.time()
[13:20:50.842]             {
[13:20:50.842]                 {
[13:20:50.842]                   {
[13:20:50.842]                     {
[13:20:50.842]                       base::local({
[13:20:50.842]                         has_future <- base::requireNamespace("future", 
[13:20:50.842]                           quietly = TRUE)
[13:20:50.842]                         if (has_future) {
[13:20:50.842]                           ns <- base::getNamespace("future")
[13:20:50.842]                           version <- ns[[".package"]][["version"]]
[13:20:50.842]                           if (is.null(version)) 
[13:20:50.842]                             version <- utils::packageVersion("future")
[13:20:50.842]                         }
[13:20:50.842]                         else {
[13:20:50.842]                           version <- NULL
[13:20:50.842]                         }
[13:20:50.842]                         if (!has_future || version < "1.8.0") {
[13:20:50.842]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.842]                             "", base::R.version$version.string), 
[13:20:50.842]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:50.842]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.842]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.842]                               "release", "version")], collapse = " "), 
[13:20:50.842]                             hostname = base::Sys.info()[["nodename"]])
[13:20:50.842]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.842]                             info)
[13:20:50.842]                           info <- base::paste(info, collapse = "; ")
[13:20:50.842]                           if (!has_future) {
[13:20:50.842]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.842]                               info)
[13:20:50.842]                           }
[13:20:50.842]                           else {
[13:20:50.842]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.842]                               info, version)
[13:20:50.842]                           }
[13:20:50.842]                           base::stop(msg)
[13:20:50.842]                         }
[13:20:50.842]                       })
[13:20:50.842]                     }
[13:20:50.842]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:50.842]                     base::options(mc.cores = 1L)
[13:20:50.842]                   }
[13:20:50.842]                   options(future.plan = NULL)
[13:20:50.842]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.842]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.842]                 }
[13:20:50.842]                 ...future.workdir <- getwd()
[13:20:50.842]             }
[13:20:50.842]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.842]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.842]         }
[13:20:50.842]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.842]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:50.842]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.842]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.842]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.842]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.842]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.842]             base::names(...future.oldOptions))
[13:20:50.842]     }
[13:20:50.842]     if (FALSE) {
[13:20:50.842]     }
[13:20:50.842]     else {
[13:20:50.842]         if (TRUE) {
[13:20:50.842]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.842]                 open = "w")
[13:20:50.842]         }
[13:20:50.842]         else {
[13:20:50.842]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.842]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.842]         }
[13:20:50.842]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.842]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.842]             base::sink(type = "output", split = FALSE)
[13:20:50.842]             base::close(...future.stdout)
[13:20:50.842]         }, add = TRUE)
[13:20:50.842]     }
[13:20:50.842]     ...future.frame <- base::sys.nframe()
[13:20:50.842]     ...future.conditions <- base::list()
[13:20:50.842]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.842]     if (FALSE) {
[13:20:50.842]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.842]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.842]     }
[13:20:50.842]     ...future.result <- base::tryCatch({
[13:20:50.842]         base::withCallingHandlers({
[13:20:50.842]             ...future.value <- base::withVisible(base::local({
[13:20:50.842]                 withCallingHandlers({
[13:20:50.842]                   {
[13:20:50.842]                     b <- a * ii
[13:20:50.842]                     a <- 0
[13:20:50.842]                     b
[13:20:50.842]                   }
[13:20:50.842]                 }, immediateCondition = function(cond) {
[13:20:50.842]                   save_rds <- function (object, pathname, ...) 
[13:20:50.842]                   {
[13:20:50.842]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:50.842]                     if (file_test("-f", pathname_tmp)) {
[13:20:50.842]                       fi_tmp <- file.info(pathname_tmp)
[13:20:50.842]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:50.842]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:50.842]                         fi_tmp[["mtime"]])
[13:20:50.842]                     }
[13:20:50.842]                     tryCatch({
[13:20:50.842]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:50.842]                     }, error = function(ex) {
[13:20:50.842]                       msg <- conditionMessage(ex)
[13:20:50.842]                       fi_tmp <- file.info(pathname_tmp)
[13:20:50.842]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:50.842]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:50.842]                         fi_tmp[["mtime"]], msg)
[13:20:50.842]                       ex$message <- msg
[13:20:50.842]                       stop(ex)
[13:20:50.842]                     })
[13:20:50.842]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:50.842]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:50.842]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:50.842]                       fi_tmp <- file.info(pathname_tmp)
[13:20:50.842]                       fi <- file.info(pathname)
[13:20:50.842]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:50.842]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:50.842]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:50.842]                         fi[["size"]], fi[["mtime"]])
[13:20:50.842]                       stop(msg)
[13:20:50.842]                     }
[13:20:50.842]                     invisible(pathname)
[13:20:50.842]                   }
[13:20:50.842]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:50.842]                     rootPath = tempdir()) 
[13:20:50.842]                   {
[13:20:50.842]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:50.842]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:50.842]                       tmpdir = path, fileext = ".rds")
[13:20:50.842]                     save_rds(obj, file)
[13:20:50.842]                   }
[13:20:50.842]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:50.842]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.842]                   {
[13:20:50.842]                     inherits <- base::inherits
[13:20:50.842]                     invokeRestart <- base::invokeRestart
[13:20:50.842]                     is.null <- base::is.null
[13:20:50.842]                     muffled <- FALSE
[13:20:50.842]                     if (inherits(cond, "message")) {
[13:20:50.842]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:50.842]                       if (muffled) 
[13:20:50.842]                         invokeRestart("muffleMessage")
[13:20:50.842]                     }
[13:20:50.842]                     else if (inherits(cond, "warning")) {
[13:20:50.842]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:50.842]                       if (muffled) 
[13:20:50.842]                         invokeRestart("muffleWarning")
[13:20:50.842]                     }
[13:20:50.842]                     else if (inherits(cond, "condition")) {
[13:20:50.842]                       if (!is.null(pattern)) {
[13:20:50.842]                         computeRestarts <- base::computeRestarts
[13:20:50.842]                         grepl <- base::grepl
[13:20:50.842]                         restarts <- computeRestarts(cond)
[13:20:50.842]                         for (restart in restarts) {
[13:20:50.842]                           name <- restart$name
[13:20:50.842]                           if (is.null(name)) 
[13:20:50.842]                             next
[13:20:50.842]                           if (!grepl(pattern, name)) 
[13:20:50.842]                             next
[13:20:50.842]                           invokeRestart(restart)
[13:20:50.842]                           muffled <- TRUE
[13:20:50.842]                           break
[13:20:50.842]                         }
[13:20:50.842]                       }
[13:20:50.842]                     }
[13:20:50.842]                     invisible(muffled)
[13:20:50.842]                   }
[13:20:50.842]                   muffleCondition(cond)
[13:20:50.842]                 })
[13:20:50.842]             }))
[13:20:50.842]             future::FutureResult(value = ...future.value$value, 
[13:20:50.842]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.842]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.842]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.842]                     ...future.globalenv.names))
[13:20:50.842]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.842]         }, condition = base::local({
[13:20:50.842]             c <- base::c
[13:20:50.842]             inherits <- base::inherits
[13:20:50.842]             invokeRestart <- base::invokeRestart
[13:20:50.842]             length <- base::length
[13:20:50.842]             list <- base::list
[13:20:50.842]             seq.int <- base::seq.int
[13:20:50.842]             signalCondition <- base::signalCondition
[13:20:50.842]             sys.calls <- base::sys.calls
[13:20:50.842]             `[[` <- base::`[[`
[13:20:50.842]             `+` <- base::`+`
[13:20:50.842]             `<<-` <- base::`<<-`
[13:20:50.842]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.842]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.842]                   3L)]
[13:20:50.842]             }
[13:20:50.842]             function(cond) {
[13:20:50.842]                 is_error <- inherits(cond, "error")
[13:20:50.842]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.842]                   NULL)
[13:20:50.842]                 if (is_error) {
[13:20:50.842]                   sessionInformation <- function() {
[13:20:50.842]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.842]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.842]                       search = base::search(), system = base::Sys.info())
[13:20:50.842]                   }
[13:20:50.842]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.842]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.842]                     cond$call), session = sessionInformation(), 
[13:20:50.842]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.842]                   signalCondition(cond)
[13:20:50.842]                 }
[13:20:50.842]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.842]                 "immediateCondition"))) {
[13:20:50.842]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.842]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.842]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.842]                   if (TRUE && !signal) {
[13:20:50.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.842]                     {
[13:20:50.842]                       inherits <- base::inherits
[13:20:50.842]                       invokeRestart <- base::invokeRestart
[13:20:50.842]                       is.null <- base::is.null
[13:20:50.842]                       muffled <- FALSE
[13:20:50.842]                       if (inherits(cond, "message")) {
[13:20:50.842]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.842]                         if (muffled) 
[13:20:50.842]                           invokeRestart("muffleMessage")
[13:20:50.842]                       }
[13:20:50.842]                       else if (inherits(cond, "warning")) {
[13:20:50.842]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.842]                         if (muffled) 
[13:20:50.842]                           invokeRestart("muffleWarning")
[13:20:50.842]                       }
[13:20:50.842]                       else if (inherits(cond, "condition")) {
[13:20:50.842]                         if (!is.null(pattern)) {
[13:20:50.842]                           computeRestarts <- base::computeRestarts
[13:20:50.842]                           grepl <- base::grepl
[13:20:50.842]                           restarts <- computeRestarts(cond)
[13:20:50.842]                           for (restart in restarts) {
[13:20:50.842]                             name <- restart$name
[13:20:50.842]                             if (is.null(name)) 
[13:20:50.842]                               next
[13:20:50.842]                             if (!grepl(pattern, name)) 
[13:20:50.842]                               next
[13:20:50.842]                             invokeRestart(restart)
[13:20:50.842]                             muffled <- TRUE
[13:20:50.842]                             break
[13:20:50.842]                           }
[13:20:50.842]                         }
[13:20:50.842]                       }
[13:20:50.842]                       invisible(muffled)
[13:20:50.842]                     }
[13:20:50.842]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.842]                   }
[13:20:50.842]                 }
[13:20:50.842]                 else {
[13:20:50.842]                   if (TRUE) {
[13:20:50.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.842]                     {
[13:20:50.842]                       inherits <- base::inherits
[13:20:50.842]                       invokeRestart <- base::invokeRestart
[13:20:50.842]                       is.null <- base::is.null
[13:20:50.842]                       muffled <- FALSE
[13:20:50.842]                       if (inherits(cond, "message")) {
[13:20:50.842]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.842]                         if (muffled) 
[13:20:50.842]                           invokeRestart("muffleMessage")
[13:20:50.842]                       }
[13:20:50.842]                       else if (inherits(cond, "warning")) {
[13:20:50.842]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.842]                         if (muffled) 
[13:20:50.842]                           invokeRestart("muffleWarning")
[13:20:50.842]                       }
[13:20:50.842]                       else if (inherits(cond, "condition")) {
[13:20:50.842]                         if (!is.null(pattern)) {
[13:20:50.842]                           computeRestarts <- base::computeRestarts
[13:20:50.842]                           grepl <- base::grepl
[13:20:50.842]                           restarts <- computeRestarts(cond)
[13:20:50.842]                           for (restart in restarts) {
[13:20:50.842]                             name <- restart$name
[13:20:50.842]                             if (is.null(name)) 
[13:20:50.842]                               next
[13:20:50.842]                             if (!grepl(pattern, name)) 
[13:20:50.842]                               next
[13:20:50.842]                             invokeRestart(restart)
[13:20:50.842]                             muffled <- TRUE
[13:20:50.842]                             break
[13:20:50.842]                           }
[13:20:50.842]                         }
[13:20:50.842]                       }
[13:20:50.842]                       invisible(muffled)
[13:20:50.842]                     }
[13:20:50.842]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.842]                   }
[13:20:50.842]                 }
[13:20:50.842]             }
[13:20:50.842]         }))
[13:20:50.842]     }, error = function(ex) {
[13:20:50.842]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.842]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.842]                 ...future.rng), started = ...future.startTime, 
[13:20:50.842]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.842]             version = "1.8"), class = "FutureResult")
[13:20:50.842]     }, finally = {
[13:20:50.842]         if (!identical(...future.workdir, getwd())) 
[13:20:50.842]             setwd(...future.workdir)
[13:20:50.842]         {
[13:20:50.842]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.842]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.842]             }
[13:20:50.842]             base::options(...future.oldOptions)
[13:20:50.842]             if (.Platform$OS.type == "windows") {
[13:20:50.842]                 old_names <- names(...future.oldEnvVars)
[13:20:50.842]                 envs <- base::Sys.getenv()
[13:20:50.842]                 names <- names(envs)
[13:20:50.842]                 common <- intersect(names, old_names)
[13:20:50.842]                 added <- setdiff(names, old_names)
[13:20:50.842]                 removed <- setdiff(old_names, names)
[13:20:50.842]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.842]                   envs[common]]
[13:20:50.842]                 NAMES <- toupper(changed)
[13:20:50.842]                 args <- list()
[13:20:50.842]                 for (kk in seq_along(NAMES)) {
[13:20:50.842]                   name <- changed[[kk]]
[13:20:50.842]                   NAME <- NAMES[[kk]]
[13:20:50.842]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.842]                     next
[13:20:50.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.842]                 }
[13:20:50.842]                 NAMES <- toupper(added)
[13:20:50.842]                 for (kk in seq_along(NAMES)) {
[13:20:50.842]                   name <- added[[kk]]
[13:20:50.842]                   NAME <- NAMES[[kk]]
[13:20:50.842]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.842]                     next
[13:20:50.842]                   args[[name]] <- ""
[13:20:50.842]                 }
[13:20:50.842]                 NAMES <- toupper(removed)
[13:20:50.842]                 for (kk in seq_along(NAMES)) {
[13:20:50.842]                   name <- removed[[kk]]
[13:20:50.842]                   NAME <- NAMES[[kk]]
[13:20:50.842]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.842]                     next
[13:20:50.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.842]                 }
[13:20:50.842]                 if (length(args) > 0) 
[13:20:50.842]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.842]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.842]             }
[13:20:50.842]             else {
[13:20:50.842]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.842]             }
[13:20:50.842]             {
[13:20:50.842]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.842]                   0L) {
[13:20:50.842]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.842]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.842]                   base::options(opts)
[13:20:50.842]                 }
[13:20:50.842]                 {
[13:20:50.842]                   {
[13:20:50.842]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:50.842]                     NULL
[13:20:50.842]                   }
[13:20:50.842]                   options(future.plan = NULL)
[13:20:50.842]                   if (is.na(NA_character_)) 
[13:20:50.842]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.842]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.842]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:50.842]                     envir = parent.frame()) 
[13:20:50.842]                   {
[13:20:50.842]                     default_workers <- missing(workers)
[13:20:50.842]                     if (is.function(workers)) 
[13:20:50.842]                       workers <- workers()
[13:20:50.842]                     workers <- structure(as.integer(workers), 
[13:20:50.842]                       class = class(workers))
[13:20:50.842]                     stop_if_not(is.finite(workers), workers >= 
[13:20:50.842]                       1L)
[13:20:50.842]                     if ((workers == 1L && !inherits(workers, 
[13:20:50.842]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:50.842]                       if (default_workers) 
[13:20:50.842]                         supportsMulticore(warn = TRUE)
[13:20:50.842]                       return(sequential(..., envir = envir))
[13:20:50.842]                     }
[13:20:50.842]                     oopts <- options(mc.cores = workers)
[13:20:50.842]                     on.exit(options(oopts))
[13:20:50.842]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:50.842]                       envir = envir)
[13:20:50.842]                     if (!future$lazy) 
[13:20:50.842]                       future <- run(future)
[13:20:50.842]                     invisible(future)
[13:20:50.842]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.842]                 }
[13:20:50.842]             }
[13:20:50.842]         }
[13:20:50.842]     })
[13:20:50.842]     if (TRUE) {
[13:20:50.842]         base::sink(type = "output", split = FALSE)
[13:20:50.842]         if (TRUE) {
[13:20:50.842]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.842]         }
[13:20:50.842]         else {
[13:20:50.842]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.842]         }
[13:20:50.842]         base::close(...future.stdout)
[13:20:50.842]         ...future.stdout <- NULL
[13:20:50.842]     }
[13:20:50.842]     ...future.result$conditions <- ...future.conditions
[13:20:50.842]     ...future.result$finished <- base::Sys.time()
[13:20:50.842]     ...future.result
[13:20:50.842] }
[13:20:50.844] assign_globals() ...
[13:20:50.844] List of 1
[13:20:50.844]  $ ii: int 2
[13:20:50.844]  - attr(*, "where")=List of 1
[13:20:50.844]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:50.844]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.844]  - attr(*, "resolved")= logi TRUE
[13:20:50.844]  - attr(*, "total_size")= num 56
[13:20:50.844]  - attr(*, "already-done")= logi TRUE
[13:20:50.848] - copied ‘ii’ to environment
[13:20:50.848] assign_globals() ... done
[13:20:50.848] requestCore(): workers = 2
[13:20:50.850] MulticoreFuture started
[13:20:50.851] - Launch lazy future ... done
[13:20:50.851] run() for ‘MulticoreFuture’ ... done
[13:20:50.851] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.852] List of future strategies:
[13:20:50.852] 1. sequential:
[13:20:50.852]    - args: function (..., envir = parent.frame())
[13:20:50.852]    - tweaked: FALSE
[13:20:50.852]    - call: NULL
[13:20:50.852] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.852] plan(): nbrOfWorkers() = 1
[13:20:50.853] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.854] plan(): Setting new future strategy stack:
[13:20:50.855] List of future strategies:
[13:20:50.855] 1. multicore:
[13:20:50.855]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:50.855]    - tweaked: FALSE
[13:20:50.855]    - call: plan(strategy)
[13:20:50.855] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.855] Searching for globals ... DONE
[13:20:50.856] Resolving globals: TRUE
[13:20:50.856] Resolving any globals that are futures ...
[13:20:50.856] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.856] Resolving any globals that are futures ... DONE
[13:20:50.857] Resolving futures part of globals (recursively) ...
[13:20:50.857] resolve() on list ...
[13:20:50.858]  recursive: 99
[13:20:50.858]  length: 1
[13:20:50.858]  elements: ‘ii’
[13:20:50.858]  length: 0 (resolved future 1)
[13:20:50.858] resolve() on list ... DONE
[13:20:50.859] - globals: [1] ‘ii’
[13:20:50.859] Resolving futures part of globals (recursively) ... DONE
[13:20:50.859] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:50.860] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:50.860] plan(): nbrOfWorkers() = 2
[13:20:50.860] - globals: [1] ‘ii’
[13:20:50.861] 
[13:20:50.861] getGlobalsAndPackages() ... DONE
[13:20:50.861] run() for ‘Future’ ...
[13:20:50.861] - state: ‘created’
[13:20:50.862] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:50.866] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:50.866] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:50.866]   - Field: ‘label’
[13:20:50.867]   - Field: ‘local’
[13:20:50.867]   - Field: ‘owner’
[13:20:50.867]   - Field: ‘envir’
[13:20:50.867]   - Field: ‘workers’
[13:20:50.870]   - Field: ‘packages’
[13:20:50.870]   - Field: ‘gc’
[13:20:50.871]   - Field: ‘job’
[13:20:50.871]   - Field: ‘conditions’
[13:20:50.871]   - Field: ‘expr’
[13:20:50.872]   - Field: ‘uuid’
[13:20:50.872]   - Field: ‘seed’
[13:20:50.872]   - Field: ‘version’
[13:20:50.872]   - Field: ‘result’
[13:20:50.873]   - Field: ‘asynchronous’
[13:20:50.873]   - Field: ‘calls’
[13:20:50.873]   - Field: ‘globals’
[13:20:50.873]   - Field: ‘stdout’
[13:20:50.873]   - Field: ‘earlySignal’
[13:20:50.874]   - Field: ‘lazy’
[13:20:50.874]   - Field: ‘state’
[13:20:50.874] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:50.874] - Launch lazy future ...
[13:20:50.875] Packages needed by the future expression (n = 0): <none>
[13:20:50.875] Packages needed by future strategies (n = 0): <none>
[13:20:50.876] {
[13:20:50.876]     {
[13:20:50.876]         {
[13:20:50.876]             ...future.startTime <- base::Sys.time()
[13:20:50.876]             {
[13:20:50.876]                 {
[13:20:50.876]                   {
[13:20:50.876]                     {
[13:20:50.876]                       base::local({
[13:20:50.876]                         has_future <- base::requireNamespace("future", 
[13:20:50.876]                           quietly = TRUE)
[13:20:50.876]                         if (has_future) {
[13:20:50.876]                           ns <- base::getNamespace("future")
[13:20:50.876]                           version <- ns[[".package"]][["version"]]
[13:20:50.876]                           if (is.null(version)) 
[13:20:50.876]                             version <- utils::packageVersion("future")
[13:20:50.876]                         }
[13:20:50.876]                         else {
[13:20:50.876]                           version <- NULL
[13:20:50.876]                         }
[13:20:50.876]                         if (!has_future || version < "1.8.0") {
[13:20:50.876]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.876]                             "", base::R.version$version.string), 
[13:20:50.876]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:50.876]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.876]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.876]                               "release", "version")], collapse = " "), 
[13:20:50.876]                             hostname = base::Sys.info()[["nodename"]])
[13:20:50.876]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.876]                             info)
[13:20:50.876]                           info <- base::paste(info, collapse = "; ")
[13:20:50.876]                           if (!has_future) {
[13:20:50.876]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.876]                               info)
[13:20:50.876]                           }
[13:20:50.876]                           else {
[13:20:50.876]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.876]                               info, version)
[13:20:50.876]                           }
[13:20:50.876]                           base::stop(msg)
[13:20:50.876]                         }
[13:20:50.876]                       })
[13:20:50.876]                     }
[13:20:50.876]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:50.876]                     base::options(mc.cores = 1L)
[13:20:50.876]                   }
[13:20:50.876]                   options(future.plan = NULL)
[13:20:50.876]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.876]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.876]                 }
[13:20:50.876]                 ...future.workdir <- getwd()
[13:20:50.876]             }
[13:20:50.876]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.876]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.876]         }
[13:20:50.876]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.876]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:50.876]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.876]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.876]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.876]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.876]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.876]             base::names(...future.oldOptions))
[13:20:50.876]     }
[13:20:50.876]     if (FALSE) {
[13:20:50.876]     }
[13:20:50.876]     else {
[13:20:50.876]         if (TRUE) {
[13:20:50.876]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.876]                 open = "w")
[13:20:50.876]         }
[13:20:50.876]         else {
[13:20:50.876]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.876]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.876]         }
[13:20:50.876]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.876]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.876]             base::sink(type = "output", split = FALSE)
[13:20:50.876]             base::close(...future.stdout)
[13:20:50.876]         }, add = TRUE)
[13:20:50.876]     }
[13:20:50.876]     ...future.frame <- base::sys.nframe()
[13:20:50.876]     ...future.conditions <- base::list()
[13:20:50.876]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.876]     if (FALSE) {
[13:20:50.876]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.876]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.876]     }
[13:20:50.876]     ...future.result <- base::tryCatch({
[13:20:50.876]         base::withCallingHandlers({
[13:20:50.876]             ...future.value <- base::withVisible(base::local({
[13:20:50.876]                 withCallingHandlers({
[13:20:50.876]                   {
[13:20:50.876]                     b <- a * ii
[13:20:50.876]                     a <- 0
[13:20:50.876]                     b
[13:20:50.876]                   }
[13:20:50.876]                 }, immediateCondition = function(cond) {
[13:20:50.876]                   save_rds <- function (object, pathname, ...) 
[13:20:50.876]                   {
[13:20:50.876]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:50.876]                     if (file_test("-f", pathname_tmp)) {
[13:20:50.876]                       fi_tmp <- file.info(pathname_tmp)
[13:20:50.876]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:50.876]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:50.876]                         fi_tmp[["mtime"]])
[13:20:50.876]                     }
[13:20:50.876]                     tryCatch({
[13:20:50.876]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:50.876]                     }, error = function(ex) {
[13:20:50.876]                       msg <- conditionMessage(ex)
[13:20:50.876]                       fi_tmp <- file.info(pathname_tmp)
[13:20:50.876]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:50.876]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:50.876]                         fi_tmp[["mtime"]], msg)
[13:20:50.876]                       ex$message <- msg
[13:20:50.876]                       stop(ex)
[13:20:50.876]                     })
[13:20:50.876]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:50.876]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:50.876]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:50.876]                       fi_tmp <- file.info(pathname_tmp)
[13:20:50.876]                       fi <- file.info(pathname)
[13:20:50.876]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:50.876]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:50.876]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:50.876]                         fi[["size"]], fi[["mtime"]])
[13:20:50.876]                       stop(msg)
[13:20:50.876]                     }
[13:20:50.876]                     invisible(pathname)
[13:20:50.876]                   }
[13:20:50.876]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:50.876]                     rootPath = tempdir()) 
[13:20:50.876]                   {
[13:20:50.876]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:50.876]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:50.876]                       tmpdir = path, fileext = ".rds")
[13:20:50.876]                     save_rds(obj, file)
[13:20:50.876]                   }
[13:20:50.876]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:50.876]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.876]                   {
[13:20:50.876]                     inherits <- base::inherits
[13:20:50.876]                     invokeRestart <- base::invokeRestart
[13:20:50.876]                     is.null <- base::is.null
[13:20:50.876]                     muffled <- FALSE
[13:20:50.876]                     if (inherits(cond, "message")) {
[13:20:50.876]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:50.876]                       if (muffled) 
[13:20:50.876]                         invokeRestart("muffleMessage")
[13:20:50.876]                     }
[13:20:50.876]                     else if (inherits(cond, "warning")) {
[13:20:50.876]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:50.876]                       if (muffled) 
[13:20:50.876]                         invokeRestart("muffleWarning")
[13:20:50.876]                     }
[13:20:50.876]                     else if (inherits(cond, "condition")) {
[13:20:50.876]                       if (!is.null(pattern)) {
[13:20:50.876]                         computeRestarts <- base::computeRestarts
[13:20:50.876]                         grepl <- base::grepl
[13:20:50.876]                         restarts <- computeRestarts(cond)
[13:20:50.876]                         for (restart in restarts) {
[13:20:50.876]                           name <- restart$name
[13:20:50.876]                           if (is.null(name)) 
[13:20:50.876]                             next
[13:20:50.876]                           if (!grepl(pattern, name)) 
[13:20:50.876]                             next
[13:20:50.876]                           invokeRestart(restart)
[13:20:50.876]                           muffled <- TRUE
[13:20:50.876]                           break
[13:20:50.876]                         }
[13:20:50.876]                       }
[13:20:50.876]                     }
[13:20:50.876]                     invisible(muffled)
[13:20:50.876]                   }
[13:20:50.876]                   muffleCondition(cond)
[13:20:50.876]                 })
[13:20:50.876]             }))
[13:20:50.876]             future::FutureResult(value = ...future.value$value, 
[13:20:50.876]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.876]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.876]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.876]                     ...future.globalenv.names))
[13:20:50.876]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.876]         }, condition = base::local({
[13:20:50.876]             c <- base::c
[13:20:50.876]             inherits <- base::inherits
[13:20:50.876]             invokeRestart <- base::invokeRestart
[13:20:50.876]             length <- base::length
[13:20:50.876]             list <- base::list
[13:20:50.876]             seq.int <- base::seq.int
[13:20:50.876]             signalCondition <- base::signalCondition
[13:20:50.876]             sys.calls <- base::sys.calls
[13:20:50.876]             `[[` <- base::`[[`
[13:20:50.876]             `+` <- base::`+`
[13:20:50.876]             `<<-` <- base::`<<-`
[13:20:50.876]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.876]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.876]                   3L)]
[13:20:50.876]             }
[13:20:50.876]             function(cond) {
[13:20:50.876]                 is_error <- inherits(cond, "error")
[13:20:50.876]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.876]                   NULL)
[13:20:50.876]                 if (is_error) {
[13:20:50.876]                   sessionInformation <- function() {
[13:20:50.876]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.876]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.876]                       search = base::search(), system = base::Sys.info())
[13:20:50.876]                   }
[13:20:50.876]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.876]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.876]                     cond$call), session = sessionInformation(), 
[13:20:50.876]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.876]                   signalCondition(cond)
[13:20:50.876]                 }
[13:20:50.876]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.876]                 "immediateCondition"))) {
[13:20:50.876]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.876]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.876]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.876]                   if (TRUE && !signal) {
[13:20:50.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.876]                     {
[13:20:50.876]                       inherits <- base::inherits
[13:20:50.876]                       invokeRestart <- base::invokeRestart
[13:20:50.876]                       is.null <- base::is.null
[13:20:50.876]                       muffled <- FALSE
[13:20:50.876]                       if (inherits(cond, "message")) {
[13:20:50.876]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.876]                         if (muffled) 
[13:20:50.876]                           invokeRestart("muffleMessage")
[13:20:50.876]                       }
[13:20:50.876]                       else if (inherits(cond, "warning")) {
[13:20:50.876]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.876]                         if (muffled) 
[13:20:50.876]                           invokeRestart("muffleWarning")
[13:20:50.876]                       }
[13:20:50.876]                       else if (inherits(cond, "condition")) {
[13:20:50.876]                         if (!is.null(pattern)) {
[13:20:50.876]                           computeRestarts <- base::computeRestarts
[13:20:50.876]                           grepl <- base::grepl
[13:20:50.876]                           restarts <- computeRestarts(cond)
[13:20:50.876]                           for (restart in restarts) {
[13:20:50.876]                             name <- restart$name
[13:20:50.876]                             if (is.null(name)) 
[13:20:50.876]                               next
[13:20:50.876]                             if (!grepl(pattern, name)) 
[13:20:50.876]                               next
[13:20:50.876]                             invokeRestart(restart)
[13:20:50.876]                             muffled <- TRUE
[13:20:50.876]                             break
[13:20:50.876]                           }
[13:20:50.876]                         }
[13:20:50.876]                       }
[13:20:50.876]                       invisible(muffled)
[13:20:50.876]                     }
[13:20:50.876]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.876]                   }
[13:20:50.876]                 }
[13:20:50.876]                 else {
[13:20:50.876]                   if (TRUE) {
[13:20:50.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.876]                     {
[13:20:50.876]                       inherits <- base::inherits
[13:20:50.876]                       invokeRestart <- base::invokeRestart
[13:20:50.876]                       is.null <- base::is.null
[13:20:50.876]                       muffled <- FALSE
[13:20:50.876]                       if (inherits(cond, "message")) {
[13:20:50.876]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.876]                         if (muffled) 
[13:20:50.876]                           invokeRestart("muffleMessage")
[13:20:50.876]                       }
[13:20:50.876]                       else if (inherits(cond, "warning")) {
[13:20:50.876]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.876]                         if (muffled) 
[13:20:50.876]                           invokeRestart("muffleWarning")
[13:20:50.876]                       }
[13:20:50.876]                       else if (inherits(cond, "condition")) {
[13:20:50.876]                         if (!is.null(pattern)) {
[13:20:50.876]                           computeRestarts <- base::computeRestarts
[13:20:50.876]                           grepl <- base::grepl
[13:20:50.876]                           restarts <- computeRestarts(cond)
[13:20:50.876]                           for (restart in restarts) {
[13:20:50.876]                             name <- restart$name
[13:20:50.876]                             if (is.null(name)) 
[13:20:50.876]                               next
[13:20:50.876]                             if (!grepl(pattern, name)) 
[13:20:50.876]                               next
[13:20:50.876]                             invokeRestart(restart)
[13:20:50.876]                             muffled <- TRUE
[13:20:50.876]                             break
[13:20:50.876]                           }
[13:20:50.876]                         }
[13:20:50.876]                       }
[13:20:50.876]                       invisible(muffled)
[13:20:50.876]                     }
[13:20:50.876]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.876]                   }
[13:20:50.876]                 }
[13:20:50.876]             }
[13:20:50.876]         }))
[13:20:50.876]     }, error = function(ex) {
[13:20:50.876]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.876]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.876]                 ...future.rng), started = ...future.startTime, 
[13:20:50.876]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.876]             version = "1.8"), class = "FutureResult")
[13:20:50.876]     }, finally = {
[13:20:50.876]         if (!identical(...future.workdir, getwd())) 
[13:20:50.876]             setwd(...future.workdir)
[13:20:50.876]         {
[13:20:50.876]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.876]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.876]             }
[13:20:50.876]             base::options(...future.oldOptions)
[13:20:50.876]             if (.Platform$OS.type == "windows") {
[13:20:50.876]                 old_names <- names(...future.oldEnvVars)
[13:20:50.876]                 envs <- base::Sys.getenv()
[13:20:50.876]                 names <- names(envs)
[13:20:50.876]                 common <- intersect(names, old_names)
[13:20:50.876]                 added <- setdiff(names, old_names)
[13:20:50.876]                 removed <- setdiff(old_names, names)
[13:20:50.876]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.876]                   envs[common]]
[13:20:50.876]                 NAMES <- toupper(changed)
[13:20:50.876]                 args <- list()
[13:20:50.876]                 for (kk in seq_along(NAMES)) {
[13:20:50.876]                   name <- changed[[kk]]
[13:20:50.876]                   NAME <- NAMES[[kk]]
[13:20:50.876]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.876]                     next
[13:20:50.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.876]                 }
[13:20:50.876]                 NAMES <- toupper(added)
[13:20:50.876]                 for (kk in seq_along(NAMES)) {
[13:20:50.876]                   name <- added[[kk]]
[13:20:50.876]                   NAME <- NAMES[[kk]]
[13:20:50.876]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.876]                     next
[13:20:50.876]                   args[[name]] <- ""
[13:20:50.876]                 }
[13:20:50.876]                 NAMES <- toupper(removed)
[13:20:50.876]                 for (kk in seq_along(NAMES)) {
[13:20:50.876]                   name <- removed[[kk]]
[13:20:50.876]                   NAME <- NAMES[[kk]]
[13:20:50.876]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.876]                     next
[13:20:50.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.876]                 }
[13:20:50.876]                 if (length(args) > 0) 
[13:20:50.876]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.876]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.876]             }
[13:20:50.876]             else {
[13:20:50.876]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.876]             }
[13:20:50.876]             {
[13:20:50.876]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.876]                   0L) {
[13:20:50.876]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.876]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.876]                   base::options(opts)
[13:20:50.876]                 }
[13:20:50.876]                 {
[13:20:50.876]                   {
[13:20:50.876]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:50.876]                     NULL
[13:20:50.876]                   }
[13:20:50.876]                   options(future.plan = NULL)
[13:20:50.876]                   if (is.na(NA_character_)) 
[13:20:50.876]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.876]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.876]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:50.876]                     envir = parent.frame()) 
[13:20:50.876]                   {
[13:20:50.876]                     default_workers <- missing(workers)
[13:20:50.876]                     if (is.function(workers)) 
[13:20:50.876]                       workers <- workers()
[13:20:50.876]                     workers <- structure(as.integer(workers), 
[13:20:50.876]                       class = class(workers))
[13:20:50.876]                     stop_if_not(is.finite(workers), workers >= 
[13:20:50.876]                       1L)
[13:20:50.876]                     if ((workers == 1L && !inherits(workers, 
[13:20:50.876]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:50.876]                       if (default_workers) 
[13:20:50.876]                         supportsMulticore(warn = TRUE)
[13:20:50.876]                       return(sequential(..., envir = envir))
[13:20:50.876]                     }
[13:20:50.876]                     oopts <- options(mc.cores = workers)
[13:20:50.876]                     on.exit(options(oopts))
[13:20:50.876]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:50.876]                       envir = envir)
[13:20:50.876]                     if (!future$lazy) 
[13:20:50.876]                       future <- run(future)
[13:20:50.876]                     invisible(future)
[13:20:50.876]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.876]                 }
[13:20:50.876]             }
[13:20:50.876]         }
[13:20:50.876]     })
[13:20:50.876]     if (TRUE) {
[13:20:50.876]         base::sink(type = "output", split = FALSE)
[13:20:50.876]         if (TRUE) {
[13:20:50.876]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.876]         }
[13:20:50.876]         else {
[13:20:50.876]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.876]         }
[13:20:50.876]         base::close(...future.stdout)
[13:20:50.876]         ...future.stdout <- NULL
[13:20:50.876]     }
[13:20:50.876]     ...future.result$conditions <- ...future.conditions
[13:20:50.876]     ...future.result$finished <- base::Sys.time()
[13:20:50.876]     ...future.result
[13:20:50.876] }
[13:20:50.879] assign_globals() ...
[13:20:50.879] List of 1
[13:20:50.879]  $ ii: int 3
[13:20:50.879]  - attr(*, "where")=List of 1
[13:20:50.879]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:50.879]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.879]  - attr(*, "resolved")= logi TRUE
[13:20:50.879]  - attr(*, "total_size")= num 56
[13:20:50.879]  - attr(*, "already-done")= logi TRUE
[13:20:50.883] - copied ‘ii’ to environment
[13:20:50.883] assign_globals() ... done
[13:20:50.883] requestCore(): workers = 2
[13:20:50.883] Poll #1 (0): usedCores() = 2, workers = 2
[13:20:50.898] MulticoreFuture started
[13:20:50.899] - Launch lazy future ... done
[13:20:50.899] run() for ‘MulticoreFuture’ ... done
[13:20:50.899] plan(): Setting new future strategy stack:
[13:20:50.900] List of future strategies:
[13:20:50.900] 1. sequential:
[13:20:50.900]    - args: function (..., envir = parent.frame())
[13:20:50.900]    - tweaked: FALSE
[13:20:50.900]    - call: NULL
[13:20:50.901] plan(): nbrOfWorkers() = 1
[13:20:50.903] plan(): Setting new future strategy stack:
[13:20:50.903] List of future strategies:
[13:20:50.903] 1. multicore:
[13:20:50.903]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:50.903]    - tweaked: FALSE
[13:20:50.903]    - call: plan(strategy)
[13:20:50.908] plan(): nbrOfWorkers() = 2
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.910] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.910] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.912] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.912] Searching for globals ... DONE
[13:20:50.912] Resolving globals: TRUE
[13:20:50.913] Resolving any globals that are futures ...
[13:20:50.913] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.913] Resolving any globals that are futures ... DONE
[13:20:50.913] Resolving futures part of globals (recursively) ...
[13:20:50.914] resolve() on list ...
[13:20:50.914]  recursive: 99
[13:20:50.914]  length: 1
[13:20:50.914]  elements: ‘ii’
[13:20:50.914]  length: 0 (resolved future 1)
[13:20:50.914] resolve() on list ... DONE
[13:20:50.914] - globals: [1] ‘ii’
[13:20:50.915] Resolving futures part of globals (recursively) ... DONE
[13:20:50.915] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:50.915] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:50.915] - globals: [1] ‘ii’
[13:20:50.915] 
[13:20:50.916] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.916] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.917] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.918] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.918] Searching for globals ... DONE
[13:20:50.918] Resolving globals: TRUE
[13:20:50.918] Resolving any globals that are futures ...
[13:20:50.919] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.919] Resolving any globals that are futures ... DONE
[13:20:50.919] Resolving futures part of globals (recursively) ...
[13:20:50.919] resolve() on list ...
[13:20:50.919]  recursive: 99
[13:20:50.920]  length: 1
[13:20:50.920]  elements: ‘ii’
[13:20:50.920]  length: 0 (resolved future 1)
[13:20:50.920] resolve() on list ... DONE
[13:20:50.920] - globals: [1] ‘ii’
[13:20:50.920] Resolving futures part of globals (recursively) ... DONE
[13:20:50.920] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:50.921] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:50.921] - globals: [1] ‘ii’
[13:20:50.921] 
[13:20:50.921] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.922] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.922] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.926] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.926] Searching for globals ... DONE
[13:20:50.926] Resolving globals: TRUE
[13:20:50.926] Resolving any globals that are futures ...
[13:20:50.926] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:50.927] Resolving any globals that are futures ... DONE
[13:20:50.927] Resolving futures part of globals (recursively) ...
[13:20:50.928] resolve() on list ...
[13:20:50.928]  recursive: 99
[13:20:50.928]  length: 1
[13:20:50.928]  elements: ‘ii’
[13:20:50.928]  length: 0 (resolved future 1)
[13:20:50.928] resolve() on list ... DONE
[13:20:50.928] - globals: [1] ‘ii’
[13:20:50.928] Resolving futures part of globals (recursively) ... DONE
[13:20:50.929] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:50.929] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:50.929] - globals: [1] ‘ii’
[13:20:50.929] 
[13:20:50.930] getGlobalsAndPackages() ... DONE
[13:20:50.930] run() for ‘Future’ ...
[13:20:50.930] - state: ‘created’
[13:20:50.930] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:50.934] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:50.934] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:50.934]   - Field: ‘label’
[13:20:50.935]   - Field: ‘local’
[13:20:50.935]   - Field: ‘owner’
[13:20:50.935]   - Field: ‘envir’
[13:20:50.935]   - Field: ‘workers’
[13:20:50.935]   - Field: ‘packages’
[13:20:50.935]   - Field: ‘gc’
[13:20:50.935]   - Field: ‘job’
[13:20:50.935]   - Field: ‘conditions’
[13:20:50.936]   - Field: ‘expr’
[13:20:50.936]   - Field: ‘uuid’
[13:20:50.936]   - Field: ‘seed’
[13:20:50.936]   - Field: ‘version’
[13:20:50.936]   - Field: ‘result’
[13:20:50.936]   - Field: ‘asynchronous’
[13:20:50.936]   - Field: ‘calls’
[13:20:50.936]   - Field: ‘globals’
[13:20:50.936]   - Field: ‘stdout’
[13:20:50.936]   - Field: ‘earlySignal’
[13:20:50.937]   - Field: ‘lazy’
[13:20:50.937]   - Field: ‘state’
[13:20:50.937] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:50.937] - Launch lazy future ...
[13:20:50.937] Packages needed by the future expression (n = 0): <none>
[13:20:50.937] Packages needed by future strategies (n = 0): <none>
[13:20:50.938] {
[13:20:50.938]     {
[13:20:50.938]         {
[13:20:50.938]             ...future.startTime <- base::Sys.time()
[13:20:50.938]             {
[13:20:50.938]                 {
[13:20:50.938]                   {
[13:20:50.938]                     {
[13:20:50.938]                       base::local({
[13:20:50.938]                         has_future <- base::requireNamespace("future", 
[13:20:50.938]                           quietly = TRUE)
[13:20:50.938]                         if (has_future) {
[13:20:50.938]                           ns <- base::getNamespace("future")
[13:20:50.938]                           version <- ns[[".package"]][["version"]]
[13:20:50.938]                           if (is.null(version)) 
[13:20:50.938]                             version <- utils::packageVersion("future")
[13:20:50.938]                         }
[13:20:50.938]                         else {
[13:20:50.938]                           version <- NULL
[13:20:50.938]                         }
[13:20:50.938]                         if (!has_future || version < "1.8.0") {
[13:20:50.938]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:50.938]                             "", base::R.version$version.string), 
[13:20:50.938]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:50.938]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:50.938]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:50.938]                               "release", "version")], collapse = " "), 
[13:20:50.938]                             hostname = base::Sys.info()[["nodename"]])
[13:20:50.938]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:50.938]                             info)
[13:20:50.938]                           info <- base::paste(info, collapse = "; ")
[13:20:50.938]                           if (!has_future) {
[13:20:50.938]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:50.938]                               info)
[13:20:50.938]                           }
[13:20:50.938]                           else {
[13:20:50.938]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:50.938]                               info, version)
[13:20:50.938]                           }
[13:20:50.938]                           base::stop(msg)
[13:20:50.938]                         }
[13:20:50.938]                       })
[13:20:50.938]                     }
[13:20:50.938]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:50.938]                     base::options(mc.cores = 1L)
[13:20:50.938]                   }
[13:20:50.938]                   options(future.plan = NULL)
[13:20:50.938]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.938]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:50.938]                 }
[13:20:50.938]                 ...future.workdir <- getwd()
[13:20:50.938]             }
[13:20:50.938]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:50.938]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:50.938]         }
[13:20:50.938]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:50.938]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:50.938]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:50.938]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:50.938]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:50.938]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:50.938]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:50.938]             base::names(...future.oldOptions))
[13:20:50.938]     }
[13:20:50.938]     if (FALSE) {
[13:20:50.938]     }
[13:20:50.938]     else {
[13:20:50.938]         if (TRUE) {
[13:20:50.938]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:50.938]                 open = "w")
[13:20:50.938]         }
[13:20:50.938]         else {
[13:20:50.938]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:50.938]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:50.938]         }
[13:20:50.938]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:50.938]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:50.938]             base::sink(type = "output", split = FALSE)
[13:20:50.938]             base::close(...future.stdout)
[13:20:50.938]         }, add = TRUE)
[13:20:50.938]     }
[13:20:50.938]     ...future.frame <- base::sys.nframe()
[13:20:50.938]     ...future.conditions <- base::list()
[13:20:50.938]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:50.938]     if (FALSE) {
[13:20:50.938]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:50.938]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:50.938]     }
[13:20:50.938]     ...future.result <- base::tryCatch({
[13:20:50.938]         base::withCallingHandlers({
[13:20:50.938]             ...future.value <- base::withVisible(base::local({
[13:20:50.938]                 withCallingHandlers({
[13:20:50.938]                   {
[13:20:50.938]                     b <- a * ii
[13:20:50.938]                     a <- 0
[13:20:50.938]                     b
[13:20:50.938]                   }
[13:20:50.938]                 }, immediateCondition = function(cond) {
[13:20:50.938]                   save_rds <- function (object, pathname, ...) 
[13:20:50.938]                   {
[13:20:50.938]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:50.938]                     if (file_test("-f", pathname_tmp)) {
[13:20:50.938]                       fi_tmp <- file.info(pathname_tmp)
[13:20:50.938]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:50.938]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:50.938]                         fi_tmp[["mtime"]])
[13:20:50.938]                     }
[13:20:50.938]                     tryCatch({
[13:20:50.938]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:50.938]                     }, error = function(ex) {
[13:20:50.938]                       msg <- conditionMessage(ex)
[13:20:50.938]                       fi_tmp <- file.info(pathname_tmp)
[13:20:50.938]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:50.938]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:50.938]                         fi_tmp[["mtime"]], msg)
[13:20:50.938]                       ex$message <- msg
[13:20:50.938]                       stop(ex)
[13:20:50.938]                     })
[13:20:50.938]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:50.938]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:50.938]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:50.938]                       fi_tmp <- file.info(pathname_tmp)
[13:20:50.938]                       fi <- file.info(pathname)
[13:20:50.938]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:50.938]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:50.938]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:50.938]                         fi[["size"]], fi[["mtime"]])
[13:20:50.938]                       stop(msg)
[13:20:50.938]                     }
[13:20:50.938]                     invisible(pathname)
[13:20:50.938]                   }
[13:20:50.938]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:50.938]                     rootPath = tempdir()) 
[13:20:50.938]                   {
[13:20:50.938]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:50.938]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:50.938]                       tmpdir = path, fileext = ".rds")
[13:20:50.938]                     save_rds(obj, file)
[13:20:50.938]                   }
[13:20:50.938]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:50.938]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.938]                   {
[13:20:50.938]                     inherits <- base::inherits
[13:20:50.938]                     invokeRestart <- base::invokeRestart
[13:20:50.938]                     is.null <- base::is.null
[13:20:50.938]                     muffled <- FALSE
[13:20:50.938]                     if (inherits(cond, "message")) {
[13:20:50.938]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:50.938]                       if (muffled) 
[13:20:50.938]                         invokeRestart("muffleMessage")
[13:20:50.938]                     }
[13:20:50.938]                     else if (inherits(cond, "warning")) {
[13:20:50.938]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:50.938]                       if (muffled) 
[13:20:50.938]                         invokeRestart("muffleWarning")
[13:20:50.938]                     }
[13:20:50.938]                     else if (inherits(cond, "condition")) {
[13:20:50.938]                       if (!is.null(pattern)) {
[13:20:50.938]                         computeRestarts <- base::computeRestarts
[13:20:50.938]                         grepl <- base::grepl
[13:20:50.938]                         restarts <- computeRestarts(cond)
[13:20:50.938]                         for (restart in restarts) {
[13:20:50.938]                           name <- restart$name
[13:20:50.938]                           if (is.null(name)) 
[13:20:50.938]                             next
[13:20:50.938]                           if (!grepl(pattern, name)) 
[13:20:50.938]                             next
[13:20:50.938]                           invokeRestart(restart)
[13:20:50.938]                           muffled <- TRUE
[13:20:50.938]                           break
[13:20:50.938]                         }
[13:20:50.938]                       }
[13:20:50.938]                     }
[13:20:50.938]                     invisible(muffled)
[13:20:50.938]                   }
[13:20:50.938]                   muffleCondition(cond)
[13:20:50.938]                 })
[13:20:50.938]             }))
[13:20:50.938]             future::FutureResult(value = ...future.value$value, 
[13:20:50.938]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.938]                   ...future.rng), globalenv = if (FALSE) 
[13:20:50.938]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:50.938]                     ...future.globalenv.names))
[13:20:50.938]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:50.938]         }, condition = base::local({
[13:20:50.938]             c <- base::c
[13:20:50.938]             inherits <- base::inherits
[13:20:50.938]             invokeRestart <- base::invokeRestart
[13:20:50.938]             length <- base::length
[13:20:50.938]             list <- base::list
[13:20:50.938]             seq.int <- base::seq.int
[13:20:50.938]             signalCondition <- base::signalCondition
[13:20:50.938]             sys.calls <- base::sys.calls
[13:20:50.938]             `[[` <- base::`[[`
[13:20:50.938]             `+` <- base::`+`
[13:20:50.938]             `<<-` <- base::`<<-`
[13:20:50.938]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:50.938]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:50.938]                   3L)]
[13:20:50.938]             }
[13:20:50.938]             function(cond) {
[13:20:50.938]                 is_error <- inherits(cond, "error")
[13:20:50.938]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:50.938]                   NULL)
[13:20:50.938]                 if (is_error) {
[13:20:50.938]                   sessionInformation <- function() {
[13:20:50.938]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:50.938]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:50.938]                       search = base::search(), system = base::Sys.info())
[13:20:50.938]                   }
[13:20:50.938]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.938]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:50.938]                     cond$call), session = sessionInformation(), 
[13:20:50.938]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:50.938]                   signalCondition(cond)
[13:20:50.938]                 }
[13:20:50.938]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:50.938]                 "immediateCondition"))) {
[13:20:50.938]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:50.938]                   ...future.conditions[[length(...future.conditions) + 
[13:20:50.938]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:50.938]                   if (TRUE && !signal) {
[13:20:50.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.938]                     {
[13:20:50.938]                       inherits <- base::inherits
[13:20:50.938]                       invokeRestart <- base::invokeRestart
[13:20:50.938]                       is.null <- base::is.null
[13:20:50.938]                       muffled <- FALSE
[13:20:50.938]                       if (inherits(cond, "message")) {
[13:20:50.938]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.938]                         if (muffled) 
[13:20:50.938]                           invokeRestart("muffleMessage")
[13:20:50.938]                       }
[13:20:50.938]                       else if (inherits(cond, "warning")) {
[13:20:50.938]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.938]                         if (muffled) 
[13:20:50.938]                           invokeRestart("muffleWarning")
[13:20:50.938]                       }
[13:20:50.938]                       else if (inherits(cond, "condition")) {
[13:20:50.938]                         if (!is.null(pattern)) {
[13:20:50.938]                           computeRestarts <- base::computeRestarts
[13:20:50.938]                           grepl <- base::grepl
[13:20:50.938]                           restarts <- computeRestarts(cond)
[13:20:50.938]                           for (restart in restarts) {
[13:20:50.938]                             name <- restart$name
[13:20:50.938]                             if (is.null(name)) 
[13:20:50.938]                               next
[13:20:50.938]                             if (!grepl(pattern, name)) 
[13:20:50.938]                               next
[13:20:50.938]                             invokeRestart(restart)
[13:20:50.938]                             muffled <- TRUE
[13:20:50.938]                             break
[13:20:50.938]                           }
[13:20:50.938]                         }
[13:20:50.938]                       }
[13:20:50.938]                       invisible(muffled)
[13:20:50.938]                     }
[13:20:50.938]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.938]                   }
[13:20:50.938]                 }
[13:20:50.938]                 else {
[13:20:50.938]                   if (TRUE) {
[13:20:50.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:50.938]                     {
[13:20:50.938]                       inherits <- base::inherits
[13:20:50.938]                       invokeRestart <- base::invokeRestart
[13:20:50.938]                       is.null <- base::is.null
[13:20:50.938]                       muffled <- FALSE
[13:20:50.938]                       if (inherits(cond, "message")) {
[13:20:50.938]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:50.938]                         if (muffled) 
[13:20:50.938]                           invokeRestart("muffleMessage")
[13:20:50.938]                       }
[13:20:50.938]                       else if (inherits(cond, "warning")) {
[13:20:50.938]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:50.938]                         if (muffled) 
[13:20:50.938]                           invokeRestart("muffleWarning")
[13:20:50.938]                       }
[13:20:50.938]                       else if (inherits(cond, "condition")) {
[13:20:50.938]                         if (!is.null(pattern)) {
[13:20:50.938]                           computeRestarts <- base::computeRestarts
[13:20:50.938]                           grepl <- base::grepl
[13:20:50.938]                           restarts <- computeRestarts(cond)
[13:20:50.938]                           for (restart in restarts) {
[13:20:50.938]                             name <- restart$name
[13:20:50.938]                             if (is.null(name)) 
[13:20:50.938]                               next
[13:20:50.938]                             if (!grepl(pattern, name)) 
[13:20:50.938]                               next
[13:20:50.938]                             invokeRestart(restart)
[13:20:50.938]                             muffled <- TRUE
[13:20:50.938]                             break
[13:20:50.938]                           }
[13:20:50.938]                         }
[13:20:50.938]                       }
[13:20:50.938]                       invisible(muffled)
[13:20:50.938]                     }
[13:20:50.938]                     muffleCondition(cond, pattern = "^muffle")
[13:20:50.938]                   }
[13:20:50.938]                 }
[13:20:50.938]             }
[13:20:50.938]         }))
[13:20:50.938]     }, error = function(ex) {
[13:20:50.938]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:50.938]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:50.938]                 ...future.rng), started = ...future.startTime, 
[13:20:50.938]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:50.938]             version = "1.8"), class = "FutureResult")
[13:20:50.938]     }, finally = {
[13:20:50.938]         if (!identical(...future.workdir, getwd())) 
[13:20:50.938]             setwd(...future.workdir)
[13:20:50.938]         {
[13:20:50.938]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:50.938]                 ...future.oldOptions$nwarnings <- NULL
[13:20:50.938]             }
[13:20:50.938]             base::options(...future.oldOptions)
[13:20:50.938]             if (.Platform$OS.type == "windows") {
[13:20:50.938]                 old_names <- names(...future.oldEnvVars)
[13:20:50.938]                 envs <- base::Sys.getenv()
[13:20:50.938]                 names <- names(envs)
[13:20:50.938]                 common <- intersect(names, old_names)
[13:20:50.938]                 added <- setdiff(names, old_names)
[13:20:50.938]                 removed <- setdiff(old_names, names)
[13:20:50.938]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:50.938]                   envs[common]]
[13:20:50.938]                 NAMES <- toupper(changed)
[13:20:50.938]                 args <- list()
[13:20:50.938]                 for (kk in seq_along(NAMES)) {
[13:20:50.938]                   name <- changed[[kk]]
[13:20:50.938]                   NAME <- NAMES[[kk]]
[13:20:50.938]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.938]                     next
[13:20:50.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.938]                 }
[13:20:50.938]                 NAMES <- toupper(added)
[13:20:50.938]                 for (kk in seq_along(NAMES)) {
[13:20:50.938]                   name <- added[[kk]]
[13:20:50.938]                   NAME <- NAMES[[kk]]
[13:20:50.938]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.938]                     next
[13:20:50.938]                   args[[name]] <- ""
[13:20:50.938]                 }
[13:20:50.938]                 NAMES <- toupper(removed)
[13:20:50.938]                 for (kk in seq_along(NAMES)) {
[13:20:50.938]                   name <- removed[[kk]]
[13:20:50.938]                   NAME <- NAMES[[kk]]
[13:20:50.938]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:50.938]                     next
[13:20:50.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:50.938]                 }
[13:20:50.938]                 if (length(args) > 0) 
[13:20:50.938]                   base::do.call(base::Sys.setenv, args = args)
[13:20:50.938]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:50.938]             }
[13:20:50.938]             else {
[13:20:50.938]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:50.938]             }
[13:20:50.938]             {
[13:20:50.938]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:50.938]                   0L) {
[13:20:50.938]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:50.938]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:50.938]                   base::options(opts)
[13:20:50.938]                 }
[13:20:50.938]                 {
[13:20:50.938]                   {
[13:20:50.938]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:50.938]                     NULL
[13:20:50.938]                   }
[13:20:50.938]                   options(future.plan = NULL)
[13:20:50.938]                   if (is.na(NA_character_)) 
[13:20:50.938]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:50.938]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:50.938]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:50.938]                     envir = parent.frame()) 
[13:20:50.938]                   {
[13:20:50.938]                     default_workers <- missing(workers)
[13:20:50.938]                     if (is.function(workers)) 
[13:20:50.938]                       workers <- workers()
[13:20:50.938]                     workers <- structure(as.integer(workers), 
[13:20:50.938]                       class = class(workers))
[13:20:50.938]                     stop_if_not(is.finite(workers), workers >= 
[13:20:50.938]                       1L)
[13:20:50.938]                     if ((workers == 1L && !inherits(workers, 
[13:20:50.938]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:50.938]                       if (default_workers) 
[13:20:50.938]                         supportsMulticore(warn = TRUE)
[13:20:50.938]                       return(sequential(..., envir = envir))
[13:20:50.938]                     }
[13:20:50.938]                     oopts <- options(mc.cores = workers)
[13:20:50.938]                     on.exit(options(oopts))
[13:20:50.938]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:50.938]                       envir = envir)
[13:20:50.938]                     if (!future$lazy) 
[13:20:50.938]                       future <- run(future)
[13:20:50.938]                     invisible(future)
[13:20:50.938]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:50.938]                 }
[13:20:50.938]             }
[13:20:50.938]         }
[13:20:50.938]     })
[13:20:50.938]     if (TRUE) {
[13:20:50.938]         base::sink(type = "output", split = FALSE)
[13:20:50.938]         if (TRUE) {
[13:20:50.938]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:50.938]         }
[13:20:50.938]         else {
[13:20:50.938]             ...future.result["stdout"] <- base::list(NULL)
[13:20:50.938]         }
[13:20:50.938]         base::close(...future.stdout)
[13:20:50.938]         ...future.stdout <- NULL
[13:20:50.938]     }
[13:20:50.938]     ...future.result$conditions <- ...future.conditions
[13:20:50.938]     ...future.result$finished <- base::Sys.time()
[13:20:50.938]     ...future.result
[13:20:50.938] }
[13:20:50.940] assign_globals() ...
[13:20:50.940] List of 1
[13:20:50.940]  $ ii: int 1
[13:20:50.940]  - attr(*, "where")=List of 1
[13:20:50.940]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:50.940]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:50.940]  - attr(*, "resolved")= logi TRUE
[13:20:50.940]  - attr(*, "total_size")= num 56
[13:20:50.940]  - attr(*, "already-done")= logi TRUE
[13:20:50.943] - copied ‘ii’ to environment
[13:20:50.943] assign_globals() ... done
[13:20:50.943] requestCore(): workers = 2
[13:20:50.945] MulticoreFuture started
[13:20:50.946] - Launch lazy future ... done
[13:20:50.946] run() for ‘MulticoreFuture’ ... done
[13:20:50.946] plan(): Setting new future strategy stack:
[13:20:50.947] List of future strategies:
[13:20:50.947] 1. sequential:
[13:20:50.947]    - args: function (..., envir = parent.frame())
[13:20:50.947]    - tweaked: FALSE
[13:20:50.947]    - call: NULL
[13:20:50.947] plan(): nbrOfWorkers() = 1
[13:20:50.950] plan(): Setting new future strategy stack:
[13:20:50.950] List of future strategies:
[13:20:50.950] 1. multicore:
[13:20:50.950]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:50.950]    - tweaked: FALSE
[13:20:50.950]    - call: plan(strategy)
[13:20:50.955] plan(): nbrOfWorkers() = 2
[13:20:50.961] signalConditions() ...
[13:20:50.961]  - include = ‘immediateCondition’
[13:20:50.961]  - exclude = 
[13:20:50.961]  - resignal = FALSE
[13:20:50.961]  - Number of conditions: 1
[13:20:50.961] signalConditions() ... done
[13:20:50.961] signalConditions() ...
[13:20:50.962]  - include = ‘immediateCondition’
[13:20:50.962]  - exclude = 
[13:20:50.962]  - resignal = FALSE
[13:20:50.962]  - Number of conditions: 1
[13:20:50.962] signalConditions() ... done
[13:20:50.962] Future state: ‘finished’
[13:20:50.962] signalConditions() ...
[13:20:50.963]  - include = ‘condition’
[13:20:50.963]  - exclude = ‘immediateCondition’
[13:20:50.963]  - resignal = TRUE
[13:20:50.963]  - Number of conditions: 1
[13:20:50.963]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:50.963] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 45
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language local({     value <- value(future) ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "5853cd8d1af0" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:20:50"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:50.994] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:50.994] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:50.994] 
[13:20:50.995] Searching for globals ... DONE
[13:20:50.995] - globals: [0] <none>
[13:20:50.995] getGlobalsAndPackages() ... DONE
[13:20:50.995] run() for ‘Future’ ...
[13:20:50.995] - state: ‘created’
[13:20:50.995] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:50.999] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:50.999] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:50.999]   - Field: ‘label’
[13:20:51.000]   - Field: ‘local’
[13:20:51.000]   - Field: ‘owner’
[13:20:51.000]   - Field: ‘envir’
[13:20:51.000]   - Field: ‘workers’
[13:20:51.000]   - Field: ‘packages’
[13:20:51.000]   - Field: ‘gc’
[13:20:51.000]   - Field: ‘job’
[13:20:51.000]   - Field: ‘conditions’
[13:20:51.000]   - Field: ‘expr’
[13:20:51.000]   - Field: ‘uuid’
[13:20:51.001]   - Field: ‘seed’
[13:20:51.001]   - Field: ‘version’
[13:20:51.001]   - Field: ‘result’
[13:20:51.001]   - Field: ‘asynchronous’
[13:20:51.001]   - Field: ‘calls’
[13:20:51.001]   - Field: ‘globals’
[13:20:51.001]   - Field: ‘stdout’
[13:20:51.001]   - Field: ‘earlySignal’
[13:20:51.001]   - Field: ‘lazy’
[13:20:51.001]   - Field: ‘state’
[13:20:51.002] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.002] - Launch lazy future ...
[13:20:51.002] Packages needed by the future expression (n = 0): <none>
[13:20:51.002] Packages needed by future strategies (n = 0): <none>
[13:20:51.003] {
[13:20:51.003]     {
[13:20:51.003]         {
[13:20:51.003]             ...future.startTime <- base::Sys.time()
[13:20:51.003]             {
[13:20:51.003]                 {
[13:20:51.003]                   {
[13:20:51.003]                     {
[13:20:51.003]                       base::local({
[13:20:51.003]                         has_future <- base::requireNamespace("future", 
[13:20:51.003]                           quietly = TRUE)
[13:20:51.003]                         if (has_future) {
[13:20:51.003]                           ns <- base::getNamespace("future")
[13:20:51.003]                           version <- ns[[".package"]][["version"]]
[13:20:51.003]                           if (is.null(version)) 
[13:20:51.003]                             version <- utils::packageVersion("future")
[13:20:51.003]                         }
[13:20:51.003]                         else {
[13:20:51.003]                           version <- NULL
[13:20:51.003]                         }
[13:20:51.003]                         if (!has_future || version < "1.8.0") {
[13:20:51.003]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.003]                             "", base::R.version$version.string), 
[13:20:51.003]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:51.003]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:51.003]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.003]                               "release", "version")], collapse = " "), 
[13:20:51.003]                             hostname = base::Sys.info()[["nodename"]])
[13:20:51.003]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.003]                             info)
[13:20:51.003]                           info <- base::paste(info, collapse = "; ")
[13:20:51.003]                           if (!has_future) {
[13:20:51.003]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.003]                               info)
[13:20:51.003]                           }
[13:20:51.003]                           else {
[13:20:51.003]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.003]                               info, version)
[13:20:51.003]                           }
[13:20:51.003]                           base::stop(msg)
[13:20:51.003]                         }
[13:20:51.003]                       })
[13:20:51.003]                     }
[13:20:51.003]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.003]                     base::options(mc.cores = 1L)
[13:20:51.003]                   }
[13:20:51.003]                   options(future.plan = NULL)
[13:20:51.003]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.003]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.003]                 }
[13:20:51.003]                 ...future.workdir <- getwd()
[13:20:51.003]             }
[13:20:51.003]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.003]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.003]         }
[13:20:51.003]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.003]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:51.003]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.003]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.003]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.003]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.003]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.003]             base::names(...future.oldOptions))
[13:20:51.003]     }
[13:20:51.003]     if (FALSE) {
[13:20:51.003]     }
[13:20:51.003]     else {
[13:20:51.003]         if (TRUE) {
[13:20:51.003]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.003]                 open = "w")
[13:20:51.003]         }
[13:20:51.003]         else {
[13:20:51.003]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.003]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.003]         }
[13:20:51.003]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.003]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.003]             base::sink(type = "output", split = FALSE)
[13:20:51.003]             base::close(...future.stdout)
[13:20:51.003]         }, add = TRUE)
[13:20:51.003]     }
[13:20:51.003]     ...future.frame <- base::sys.nframe()
[13:20:51.003]     ...future.conditions <- base::list()
[13:20:51.003]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.003]     if (FALSE) {
[13:20:51.003]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.003]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.003]     }
[13:20:51.003]     ...future.result <- base::tryCatch({
[13:20:51.003]         base::withCallingHandlers({
[13:20:51.003]             ...future.value <- base::withVisible(base::local({
[13:20:51.003]                 withCallingHandlers({
[13:20:51.003]                   1
[13:20:51.003]                 }, immediateCondition = function(cond) {
[13:20:51.003]                   save_rds <- function (object, pathname, ...) 
[13:20:51.003]                   {
[13:20:51.003]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.003]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.003]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.003]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.003]                         fi_tmp[["mtime"]])
[13:20:51.003]                     }
[13:20:51.003]                     tryCatch({
[13:20:51.003]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.003]                     }, error = function(ex) {
[13:20:51.003]                       msg <- conditionMessage(ex)
[13:20:51.003]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.003]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.003]                         fi_tmp[["mtime"]], msg)
[13:20:51.003]                       ex$message <- msg
[13:20:51.003]                       stop(ex)
[13:20:51.003]                     })
[13:20:51.003]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.003]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.003]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.003]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.003]                       fi <- file.info(pathname)
[13:20:51.003]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.003]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.003]                         fi[["size"]], fi[["mtime"]])
[13:20:51.003]                       stop(msg)
[13:20:51.003]                     }
[13:20:51.003]                     invisible(pathname)
[13:20:51.003]                   }
[13:20:51.003]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.003]                     rootPath = tempdir()) 
[13:20:51.003]                   {
[13:20:51.003]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.003]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.003]                       tmpdir = path, fileext = ".rds")
[13:20:51.003]                     save_rds(obj, file)
[13:20:51.003]                   }
[13:20:51.003]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.003]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.003]                   {
[13:20:51.003]                     inherits <- base::inherits
[13:20:51.003]                     invokeRestart <- base::invokeRestart
[13:20:51.003]                     is.null <- base::is.null
[13:20:51.003]                     muffled <- FALSE
[13:20:51.003]                     if (inherits(cond, "message")) {
[13:20:51.003]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.003]                       if (muffled) 
[13:20:51.003]                         invokeRestart("muffleMessage")
[13:20:51.003]                     }
[13:20:51.003]                     else if (inherits(cond, "warning")) {
[13:20:51.003]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.003]                       if (muffled) 
[13:20:51.003]                         invokeRestart("muffleWarning")
[13:20:51.003]                     }
[13:20:51.003]                     else if (inherits(cond, "condition")) {
[13:20:51.003]                       if (!is.null(pattern)) {
[13:20:51.003]                         computeRestarts <- base::computeRestarts
[13:20:51.003]                         grepl <- base::grepl
[13:20:51.003]                         restarts <- computeRestarts(cond)
[13:20:51.003]                         for (restart in restarts) {
[13:20:51.003]                           name <- restart$name
[13:20:51.003]                           if (is.null(name)) 
[13:20:51.003]                             next
[13:20:51.003]                           if (!grepl(pattern, name)) 
[13:20:51.003]                             next
[13:20:51.003]                           invokeRestart(restart)
[13:20:51.003]                           muffled <- TRUE
[13:20:51.003]                           break
[13:20:51.003]                         }
[13:20:51.003]                       }
[13:20:51.003]                     }
[13:20:51.003]                     invisible(muffled)
[13:20:51.003]                   }
[13:20:51.003]                   muffleCondition(cond)
[13:20:51.003]                 })
[13:20:51.003]             }))
[13:20:51.003]             future::FutureResult(value = ...future.value$value, 
[13:20:51.003]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.003]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.003]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.003]                     ...future.globalenv.names))
[13:20:51.003]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.003]         }, condition = base::local({
[13:20:51.003]             c <- base::c
[13:20:51.003]             inherits <- base::inherits
[13:20:51.003]             invokeRestart <- base::invokeRestart
[13:20:51.003]             length <- base::length
[13:20:51.003]             list <- base::list
[13:20:51.003]             seq.int <- base::seq.int
[13:20:51.003]             signalCondition <- base::signalCondition
[13:20:51.003]             sys.calls <- base::sys.calls
[13:20:51.003]             `[[` <- base::`[[`
[13:20:51.003]             `+` <- base::`+`
[13:20:51.003]             `<<-` <- base::`<<-`
[13:20:51.003]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.003]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.003]                   3L)]
[13:20:51.003]             }
[13:20:51.003]             function(cond) {
[13:20:51.003]                 is_error <- inherits(cond, "error")
[13:20:51.003]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.003]                   NULL)
[13:20:51.003]                 if (is_error) {
[13:20:51.003]                   sessionInformation <- function() {
[13:20:51.003]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.003]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.003]                       search = base::search(), system = base::Sys.info())
[13:20:51.003]                   }
[13:20:51.003]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.003]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.003]                     cond$call), session = sessionInformation(), 
[13:20:51.003]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.003]                   signalCondition(cond)
[13:20:51.003]                 }
[13:20:51.003]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.003]                 "immediateCondition"))) {
[13:20:51.003]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.003]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.003]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.003]                   if (TRUE && !signal) {
[13:20:51.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.003]                     {
[13:20:51.003]                       inherits <- base::inherits
[13:20:51.003]                       invokeRestart <- base::invokeRestart
[13:20:51.003]                       is.null <- base::is.null
[13:20:51.003]                       muffled <- FALSE
[13:20:51.003]                       if (inherits(cond, "message")) {
[13:20:51.003]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.003]                         if (muffled) 
[13:20:51.003]                           invokeRestart("muffleMessage")
[13:20:51.003]                       }
[13:20:51.003]                       else if (inherits(cond, "warning")) {
[13:20:51.003]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.003]                         if (muffled) 
[13:20:51.003]                           invokeRestart("muffleWarning")
[13:20:51.003]                       }
[13:20:51.003]                       else if (inherits(cond, "condition")) {
[13:20:51.003]                         if (!is.null(pattern)) {
[13:20:51.003]                           computeRestarts <- base::computeRestarts
[13:20:51.003]                           grepl <- base::grepl
[13:20:51.003]                           restarts <- computeRestarts(cond)
[13:20:51.003]                           for (restart in restarts) {
[13:20:51.003]                             name <- restart$name
[13:20:51.003]                             if (is.null(name)) 
[13:20:51.003]                               next
[13:20:51.003]                             if (!grepl(pattern, name)) 
[13:20:51.003]                               next
[13:20:51.003]                             invokeRestart(restart)
[13:20:51.003]                             muffled <- TRUE
[13:20:51.003]                             break
[13:20:51.003]                           }
[13:20:51.003]                         }
[13:20:51.003]                       }
[13:20:51.003]                       invisible(muffled)
[13:20:51.003]                     }
[13:20:51.003]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.003]                   }
[13:20:51.003]                 }
[13:20:51.003]                 else {
[13:20:51.003]                   if (TRUE) {
[13:20:51.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.003]                     {
[13:20:51.003]                       inherits <- base::inherits
[13:20:51.003]                       invokeRestart <- base::invokeRestart
[13:20:51.003]                       is.null <- base::is.null
[13:20:51.003]                       muffled <- FALSE
[13:20:51.003]                       if (inherits(cond, "message")) {
[13:20:51.003]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.003]                         if (muffled) 
[13:20:51.003]                           invokeRestart("muffleMessage")
[13:20:51.003]                       }
[13:20:51.003]                       else if (inherits(cond, "warning")) {
[13:20:51.003]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.003]                         if (muffled) 
[13:20:51.003]                           invokeRestart("muffleWarning")
[13:20:51.003]                       }
[13:20:51.003]                       else if (inherits(cond, "condition")) {
[13:20:51.003]                         if (!is.null(pattern)) {
[13:20:51.003]                           computeRestarts <- base::computeRestarts
[13:20:51.003]                           grepl <- base::grepl
[13:20:51.003]                           restarts <- computeRestarts(cond)
[13:20:51.003]                           for (restart in restarts) {
[13:20:51.003]                             name <- restart$name
[13:20:51.003]                             if (is.null(name)) 
[13:20:51.003]                               next
[13:20:51.003]                             if (!grepl(pattern, name)) 
[13:20:51.003]                               next
[13:20:51.003]                             invokeRestart(restart)
[13:20:51.003]                             muffled <- TRUE
[13:20:51.003]                             break
[13:20:51.003]                           }
[13:20:51.003]                         }
[13:20:51.003]                       }
[13:20:51.003]                       invisible(muffled)
[13:20:51.003]                     }
[13:20:51.003]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.003]                   }
[13:20:51.003]                 }
[13:20:51.003]             }
[13:20:51.003]         }))
[13:20:51.003]     }, error = function(ex) {
[13:20:51.003]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.003]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.003]                 ...future.rng), started = ...future.startTime, 
[13:20:51.003]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.003]             version = "1.8"), class = "FutureResult")
[13:20:51.003]     }, finally = {
[13:20:51.003]         if (!identical(...future.workdir, getwd())) 
[13:20:51.003]             setwd(...future.workdir)
[13:20:51.003]         {
[13:20:51.003]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.003]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.003]             }
[13:20:51.003]             base::options(...future.oldOptions)
[13:20:51.003]             if (.Platform$OS.type == "windows") {
[13:20:51.003]                 old_names <- names(...future.oldEnvVars)
[13:20:51.003]                 envs <- base::Sys.getenv()
[13:20:51.003]                 names <- names(envs)
[13:20:51.003]                 common <- intersect(names, old_names)
[13:20:51.003]                 added <- setdiff(names, old_names)
[13:20:51.003]                 removed <- setdiff(old_names, names)
[13:20:51.003]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.003]                   envs[common]]
[13:20:51.003]                 NAMES <- toupper(changed)
[13:20:51.003]                 args <- list()
[13:20:51.003]                 for (kk in seq_along(NAMES)) {
[13:20:51.003]                   name <- changed[[kk]]
[13:20:51.003]                   NAME <- NAMES[[kk]]
[13:20:51.003]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.003]                     next
[13:20:51.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.003]                 }
[13:20:51.003]                 NAMES <- toupper(added)
[13:20:51.003]                 for (kk in seq_along(NAMES)) {
[13:20:51.003]                   name <- added[[kk]]
[13:20:51.003]                   NAME <- NAMES[[kk]]
[13:20:51.003]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.003]                     next
[13:20:51.003]                   args[[name]] <- ""
[13:20:51.003]                 }
[13:20:51.003]                 NAMES <- toupper(removed)
[13:20:51.003]                 for (kk in seq_along(NAMES)) {
[13:20:51.003]                   name <- removed[[kk]]
[13:20:51.003]                   NAME <- NAMES[[kk]]
[13:20:51.003]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.003]                     next
[13:20:51.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.003]                 }
[13:20:51.003]                 if (length(args) > 0) 
[13:20:51.003]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.003]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.003]             }
[13:20:51.003]             else {
[13:20:51.003]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.003]             }
[13:20:51.003]             {
[13:20:51.003]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.003]                   0L) {
[13:20:51.003]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.003]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.003]                   base::options(opts)
[13:20:51.003]                 }
[13:20:51.003]                 {
[13:20:51.003]                   {
[13:20:51.003]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.003]                     NULL
[13:20:51.003]                   }
[13:20:51.003]                   options(future.plan = NULL)
[13:20:51.003]                   if (is.na(NA_character_)) 
[13:20:51.003]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.003]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.003]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.003]                     envir = parent.frame()) 
[13:20:51.003]                   {
[13:20:51.003]                     default_workers <- missing(workers)
[13:20:51.003]                     if (is.function(workers)) 
[13:20:51.003]                       workers <- workers()
[13:20:51.003]                     workers <- structure(as.integer(workers), 
[13:20:51.003]                       class = class(workers))
[13:20:51.003]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.003]                       1L)
[13:20:51.003]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.003]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.003]                       if (default_workers) 
[13:20:51.003]                         supportsMulticore(warn = TRUE)
[13:20:51.003]                       return(sequential(..., envir = envir))
[13:20:51.003]                     }
[13:20:51.003]                     oopts <- options(mc.cores = workers)
[13:20:51.003]                     on.exit(options(oopts))
[13:20:51.003]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.003]                       envir = envir)
[13:20:51.003]                     if (!future$lazy) 
[13:20:51.003]                       future <- run(future)
[13:20:51.003]                     invisible(future)
[13:20:51.003]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.003]                 }
[13:20:51.003]             }
[13:20:51.003]         }
[13:20:51.003]     })
[13:20:51.003]     if (TRUE) {
[13:20:51.003]         base::sink(type = "output", split = FALSE)
[13:20:51.003]         if (TRUE) {
[13:20:51.003]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.003]         }
[13:20:51.003]         else {
[13:20:51.003]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.003]         }
[13:20:51.003]         base::close(...future.stdout)
[13:20:51.003]         ...future.stdout <- NULL
[13:20:51.003]     }
[13:20:51.003]     ...future.result$conditions <- ...future.conditions
[13:20:51.003]     ...future.result$finished <- base::Sys.time()
[13:20:51.003]     ...future.result
[13:20:51.003] }
[13:20:51.005] requestCore(): workers = 2
[13:20:51.007] MulticoreFuture started
[13:20:51.007] - Launch lazy future ... done
[13:20:51.008] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.008] getGlobalsAndPackages() ...
[13:20:51.008] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.009] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:51.008] List of future strategies:
[13:20:51.008] 1. sequential:
[13:20:51.008]    - args: function (..., envir = parent.frame())
[13:20:51.008]    - tweaked: FALSE
[13:20:51.008]    - call: NULL
[13:20:51.009] plan(): nbrOfWorkers() = 1
[13:20:51.011] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:51.011] Searching for globals ... DONE
[13:20:51.011] Resolving globals: TRUE
[13:20:51.011] Resolving any globals that are futures ...
[13:20:51.011] plan(): Setting new future strategy stack:
[13:20:51.011] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:51.011] Resolving any globals that are futures ... DONE
[13:20:51.011] List of future strategies:
[13:20:51.011] 1. multicore:
[13:20:51.011]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.011]    - tweaked: FALSE
[13:20:51.011]    - call: plan(strategy)
[13:20:51.012] Resolving futures part of globals (recursively) ...
[13:20:51.013] resolve() on list ...
[13:20:51.013]  recursive: 99
[13:20:51.013]  length: 1
[13:20:51.013]  elements: ‘a’
[13:20:51.017] plan(): nbrOfWorkers() = 2
[13:20:51.017] Future #1
[13:20:51.019] A MulticoreFuture was resolved
[13:20:51.019]  length: 0 (resolved future 1)
[13:20:51.019] resolve() on list ... DONE
[13:20:51.019] - globals: [1] ‘a’
[13:20:51.019] Resolving futures part of globals (recursively) ... DONE
[13:20:51.021] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[13:20:51.021] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[13:20:51.021] - globals: [1] ‘a’
[13:20:51.022] - packages: [1] ‘future’
[13:20:51.022] getGlobalsAndPackages() ... DONE
[13:20:51.022] run() for ‘Future’ ...
[13:20:51.022] - state: ‘created’
[13:20:51.022] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.027] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.027] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.027]   - Field: ‘label’
[13:20:51.027]   - Field: ‘local’
[13:20:51.027]   - Field: ‘owner’
[13:20:51.027]   - Field: ‘envir’
[13:20:51.027]   - Field: ‘workers’
[13:20:51.028]   - Field: ‘packages’
[13:20:51.028]   - Field: ‘gc’
[13:20:51.030]   - Field: ‘job’
[13:20:51.030]   - Field: ‘conditions’
[13:20:51.031]   - Field: ‘expr’
[13:20:51.031]   - Field: ‘uuid’
[13:20:51.031]   - Field: ‘seed’
[13:20:51.031]   - Field: ‘version’
[13:20:51.031]   - Field: ‘result’
[13:20:51.031]   - Field: ‘asynchronous’
[13:20:51.032]   - Field: ‘calls’
[13:20:51.032]   - Field: ‘globals’
[13:20:51.032]   - Field: ‘stdout’
[13:20:51.032]   - Field: ‘earlySignal’
[13:20:51.032]   - Field: ‘lazy’
[13:20:51.032]   - Field: ‘state’
[13:20:51.033] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.033] - Launch lazy future ...
[13:20:51.033] Packages needed by the future expression (n = 1): ‘future’
[13:20:51.033] Packages needed by future strategies (n = 0): <none>
[13:20:51.034] {
[13:20:51.034]     {
[13:20:51.034]         {
[13:20:51.034]             ...future.startTime <- base::Sys.time()
[13:20:51.034]             {
[13:20:51.034]                 {
[13:20:51.034]                   {
[13:20:51.034]                     {
[13:20:51.034]                       {
[13:20:51.034]                         base::local({
[13:20:51.034]                           has_future <- base::requireNamespace("future", 
[13:20:51.034]                             quietly = TRUE)
[13:20:51.034]                           if (has_future) {
[13:20:51.034]                             ns <- base::getNamespace("future")
[13:20:51.034]                             version <- ns[[".package"]][["version"]]
[13:20:51.034]                             if (is.null(version)) 
[13:20:51.034]                               version <- utils::packageVersion("future")
[13:20:51.034]                           }
[13:20:51.034]                           else {
[13:20:51.034]                             version <- NULL
[13:20:51.034]                           }
[13:20:51.034]                           if (!has_future || version < "1.8.0") {
[13:20:51.034]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.034]                               "", base::R.version$version.string), 
[13:20:51.034]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:51.034]                                 base::R.version$platform, 8 * 
[13:20:51.034]                                   base::.Machine$sizeof.pointer), 
[13:20:51.034]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.034]                                 "release", "version")], collapse = " "), 
[13:20:51.034]                               hostname = base::Sys.info()[["nodename"]])
[13:20:51.034]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.034]                               info)
[13:20:51.034]                             info <- base::paste(info, collapse = "; ")
[13:20:51.034]                             if (!has_future) {
[13:20:51.034]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.034]                                 info)
[13:20:51.034]                             }
[13:20:51.034]                             else {
[13:20:51.034]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.034]                                 info, version)
[13:20:51.034]                             }
[13:20:51.034]                             base::stop(msg)
[13:20:51.034]                           }
[13:20:51.034]                         })
[13:20:51.034]                       }
[13:20:51.034]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.034]                       base::options(mc.cores = 1L)
[13:20:51.034]                     }
[13:20:51.034]                     base::local({
[13:20:51.034]                       for (pkg in "future") {
[13:20:51.034]                         base::loadNamespace(pkg)
[13:20:51.034]                         base::library(pkg, character.only = TRUE)
[13:20:51.034]                       }
[13:20:51.034]                     })
[13:20:51.034]                   }
[13:20:51.034]                   options(future.plan = NULL)
[13:20:51.034]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.034]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.034]                 }
[13:20:51.034]                 ...future.workdir <- getwd()
[13:20:51.034]             }
[13:20:51.034]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.034]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.034]         }
[13:20:51.034]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.034]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:51.034]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.034]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.034]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.034]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.034]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.034]             base::names(...future.oldOptions))
[13:20:51.034]     }
[13:20:51.034]     if (FALSE) {
[13:20:51.034]     }
[13:20:51.034]     else {
[13:20:51.034]         if (TRUE) {
[13:20:51.034]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.034]                 open = "w")
[13:20:51.034]         }
[13:20:51.034]         else {
[13:20:51.034]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.034]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.034]         }
[13:20:51.034]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.034]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.034]             base::sink(type = "output", split = FALSE)
[13:20:51.034]             base::close(...future.stdout)
[13:20:51.034]         }, add = TRUE)
[13:20:51.034]     }
[13:20:51.034]     ...future.frame <- base::sys.nframe()
[13:20:51.034]     ...future.conditions <- base::list()
[13:20:51.034]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.034]     if (FALSE) {
[13:20:51.034]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.034]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.034]     }
[13:20:51.034]     ...future.result <- base::tryCatch({
[13:20:51.034]         base::withCallingHandlers({
[13:20:51.034]             ...future.value <- base::withVisible(base::local({
[13:20:51.034]                 withCallingHandlers({
[13:20:51.034]                   value(a) + 1
[13:20:51.034]                 }, immediateCondition = function(cond) {
[13:20:51.034]                   save_rds <- function (object, pathname, ...) 
[13:20:51.034]                   {
[13:20:51.034]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.034]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.034]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.034]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.034]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.034]                         fi_tmp[["mtime"]])
[13:20:51.034]                     }
[13:20:51.034]                     tryCatch({
[13:20:51.034]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.034]                     }, error = function(ex) {
[13:20:51.034]                       msg <- conditionMessage(ex)
[13:20:51.034]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.034]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.034]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.034]                         fi_tmp[["mtime"]], msg)
[13:20:51.034]                       ex$message <- msg
[13:20:51.034]                       stop(ex)
[13:20:51.034]                     })
[13:20:51.034]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.034]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.034]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.034]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.034]                       fi <- file.info(pathname)
[13:20:51.034]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.034]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.034]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.034]                         fi[["size"]], fi[["mtime"]])
[13:20:51.034]                       stop(msg)
[13:20:51.034]                     }
[13:20:51.034]                     invisible(pathname)
[13:20:51.034]                   }
[13:20:51.034]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.034]                     rootPath = tempdir()) 
[13:20:51.034]                   {
[13:20:51.034]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.034]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.034]                       tmpdir = path, fileext = ".rds")
[13:20:51.034]                     save_rds(obj, file)
[13:20:51.034]                   }
[13:20:51.034]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.034]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.034]                   {
[13:20:51.034]                     inherits <- base::inherits
[13:20:51.034]                     invokeRestart <- base::invokeRestart
[13:20:51.034]                     is.null <- base::is.null
[13:20:51.034]                     muffled <- FALSE
[13:20:51.034]                     if (inherits(cond, "message")) {
[13:20:51.034]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.034]                       if (muffled) 
[13:20:51.034]                         invokeRestart("muffleMessage")
[13:20:51.034]                     }
[13:20:51.034]                     else if (inherits(cond, "warning")) {
[13:20:51.034]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.034]                       if (muffled) 
[13:20:51.034]                         invokeRestart("muffleWarning")
[13:20:51.034]                     }
[13:20:51.034]                     else if (inherits(cond, "condition")) {
[13:20:51.034]                       if (!is.null(pattern)) {
[13:20:51.034]                         computeRestarts <- base::computeRestarts
[13:20:51.034]                         grepl <- base::grepl
[13:20:51.034]                         restarts <- computeRestarts(cond)
[13:20:51.034]                         for (restart in restarts) {
[13:20:51.034]                           name <- restart$name
[13:20:51.034]                           if (is.null(name)) 
[13:20:51.034]                             next
[13:20:51.034]                           if (!grepl(pattern, name)) 
[13:20:51.034]                             next
[13:20:51.034]                           invokeRestart(restart)
[13:20:51.034]                           muffled <- TRUE
[13:20:51.034]                           break
[13:20:51.034]                         }
[13:20:51.034]                       }
[13:20:51.034]                     }
[13:20:51.034]                     invisible(muffled)
[13:20:51.034]                   }
[13:20:51.034]                   muffleCondition(cond)
[13:20:51.034]                 })
[13:20:51.034]             }))
[13:20:51.034]             future::FutureResult(value = ...future.value$value, 
[13:20:51.034]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.034]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.034]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.034]                     ...future.globalenv.names))
[13:20:51.034]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.034]         }, condition = base::local({
[13:20:51.034]             c <- base::c
[13:20:51.034]             inherits <- base::inherits
[13:20:51.034]             invokeRestart <- base::invokeRestart
[13:20:51.034]             length <- base::length
[13:20:51.034]             list <- base::list
[13:20:51.034]             seq.int <- base::seq.int
[13:20:51.034]             signalCondition <- base::signalCondition
[13:20:51.034]             sys.calls <- base::sys.calls
[13:20:51.034]             `[[` <- base::`[[`
[13:20:51.034]             `+` <- base::`+`
[13:20:51.034]             `<<-` <- base::`<<-`
[13:20:51.034]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.034]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.034]                   3L)]
[13:20:51.034]             }
[13:20:51.034]             function(cond) {
[13:20:51.034]                 is_error <- inherits(cond, "error")
[13:20:51.034]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.034]                   NULL)
[13:20:51.034]                 if (is_error) {
[13:20:51.034]                   sessionInformation <- function() {
[13:20:51.034]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.034]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.034]                       search = base::search(), system = base::Sys.info())
[13:20:51.034]                   }
[13:20:51.034]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.034]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.034]                     cond$call), session = sessionInformation(), 
[13:20:51.034]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.034]                   signalCondition(cond)
[13:20:51.034]                 }
[13:20:51.034]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.034]                 "immediateCondition"))) {
[13:20:51.034]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.034]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.034]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.034]                   if (TRUE && !signal) {
[13:20:51.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.034]                     {
[13:20:51.034]                       inherits <- base::inherits
[13:20:51.034]                       invokeRestart <- base::invokeRestart
[13:20:51.034]                       is.null <- base::is.null
[13:20:51.034]                       muffled <- FALSE
[13:20:51.034]                       if (inherits(cond, "message")) {
[13:20:51.034]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.034]                         if (muffled) 
[13:20:51.034]                           invokeRestart("muffleMessage")
[13:20:51.034]                       }
[13:20:51.034]                       else if (inherits(cond, "warning")) {
[13:20:51.034]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.034]                         if (muffled) 
[13:20:51.034]                           invokeRestart("muffleWarning")
[13:20:51.034]                       }
[13:20:51.034]                       else if (inherits(cond, "condition")) {
[13:20:51.034]                         if (!is.null(pattern)) {
[13:20:51.034]                           computeRestarts <- base::computeRestarts
[13:20:51.034]                           grepl <- base::grepl
[13:20:51.034]                           restarts <- computeRestarts(cond)
[13:20:51.034]                           for (restart in restarts) {
[13:20:51.034]                             name <- restart$name
[13:20:51.034]                             if (is.null(name)) 
[13:20:51.034]                               next
[13:20:51.034]                             if (!grepl(pattern, name)) 
[13:20:51.034]                               next
[13:20:51.034]                             invokeRestart(restart)
[13:20:51.034]                             muffled <- TRUE
[13:20:51.034]                             break
[13:20:51.034]                           }
[13:20:51.034]                         }
[13:20:51.034]                       }
[13:20:51.034]                       invisible(muffled)
[13:20:51.034]                     }
[13:20:51.034]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.034]                   }
[13:20:51.034]                 }
[13:20:51.034]                 else {
[13:20:51.034]                   if (TRUE) {
[13:20:51.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.034]                     {
[13:20:51.034]                       inherits <- base::inherits
[13:20:51.034]                       invokeRestart <- base::invokeRestart
[13:20:51.034]                       is.null <- base::is.null
[13:20:51.034]                       muffled <- FALSE
[13:20:51.034]                       if (inherits(cond, "message")) {
[13:20:51.034]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.034]                         if (muffled) 
[13:20:51.034]                           invokeRestart("muffleMessage")
[13:20:51.034]                       }
[13:20:51.034]                       else if (inherits(cond, "warning")) {
[13:20:51.034]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.034]                         if (muffled) 
[13:20:51.034]                           invokeRestart("muffleWarning")
[13:20:51.034]                       }
[13:20:51.034]                       else if (inherits(cond, "condition")) {
[13:20:51.034]                         if (!is.null(pattern)) {
[13:20:51.034]                           computeRestarts <- base::computeRestarts
[13:20:51.034]                           grepl <- base::grepl
[13:20:51.034]                           restarts <- computeRestarts(cond)
[13:20:51.034]                           for (restart in restarts) {
[13:20:51.034]                             name <- restart$name
[13:20:51.034]                             if (is.null(name)) 
[13:20:51.034]                               next
[13:20:51.034]                             if (!grepl(pattern, name)) 
[13:20:51.034]                               next
[13:20:51.034]                             invokeRestart(restart)
[13:20:51.034]                             muffled <- TRUE
[13:20:51.034]                             break
[13:20:51.034]                           }
[13:20:51.034]                         }
[13:20:51.034]                       }
[13:20:51.034]                       invisible(muffled)
[13:20:51.034]                     }
[13:20:51.034]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.034]                   }
[13:20:51.034]                 }
[13:20:51.034]             }
[13:20:51.034]         }))
[13:20:51.034]     }, error = function(ex) {
[13:20:51.034]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.034]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.034]                 ...future.rng), started = ...future.startTime, 
[13:20:51.034]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.034]             version = "1.8"), class = "FutureResult")
[13:20:51.034]     }, finally = {
[13:20:51.034]         if (!identical(...future.workdir, getwd())) 
[13:20:51.034]             setwd(...future.workdir)
[13:20:51.034]         {
[13:20:51.034]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.034]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.034]             }
[13:20:51.034]             base::options(...future.oldOptions)
[13:20:51.034]             if (.Platform$OS.type == "windows") {
[13:20:51.034]                 old_names <- names(...future.oldEnvVars)
[13:20:51.034]                 envs <- base::Sys.getenv()
[13:20:51.034]                 names <- names(envs)
[13:20:51.034]                 common <- intersect(names, old_names)
[13:20:51.034]                 added <- setdiff(names, old_names)
[13:20:51.034]                 removed <- setdiff(old_names, names)
[13:20:51.034]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.034]                   envs[common]]
[13:20:51.034]                 NAMES <- toupper(changed)
[13:20:51.034]                 args <- list()
[13:20:51.034]                 for (kk in seq_along(NAMES)) {
[13:20:51.034]                   name <- changed[[kk]]
[13:20:51.034]                   NAME <- NAMES[[kk]]
[13:20:51.034]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.034]                     next
[13:20:51.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.034]                 }
[13:20:51.034]                 NAMES <- toupper(added)
[13:20:51.034]                 for (kk in seq_along(NAMES)) {
[13:20:51.034]                   name <- added[[kk]]
[13:20:51.034]                   NAME <- NAMES[[kk]]
[13:20:51.034]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.034]                     next
[13:20:51.034]                   args[[name]] <- ""
[13:20:51.034]                 }
[13:20:51.034]                 NAMES <- toupper(removed)
[13:20:51.034]                 for (kk in seq_along(NAMES)) {
[13:20:51.034]                   name <- removed[[kk]]
[13:20:51.034]                   NAME <- NAMES[[kk]]
[13:20:51.034]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.034]                     next
[13:20:51.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.034]                 }
[13:20:51.034]                 if (length(args) > 0) 
[13:20:51.034]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.034]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.034]             }
[13:20:51.034]             else {
[13:20:51.034]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.034]             }
[13:20:51.034]             {
[13:20:51.034]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.034]                   0L) {
[13:20:51.034]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.034]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.034]                   base::options(opts)
[13:20:51.034]                 }
[13:20:51.034]                 {
[13:20:51.034]                   {
[13:20:51.034]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.034]                     NULL
[13:20:51.034]                   }
[13:20:51.034]                   options(future.plan = NULL)
[13:20:51.034]                   if (is.na(NA_character_)) 
[13:20:51.034]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.034]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.034]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.034]                     envir = parent.frame()) 
[13:20:51.034]                   {
[13:20:51.034]                     default_workers <- missing(workers)
[13:20:51.034]                     if (is.function(workers)) 
[13:20:51.034]                       workers <- workers()
[13:20:51.034]                     workers <- structure(as.integer(workers), 
[13:20:51.034]                       class = class(workers))
[13:20:51.034]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.034]                       1L)
[13:20:51.034]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.034]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.034]                       if (default_workers) 
[13:20:51.034]                         supportsMulticore(warn = TRUE)
[13:20:51.034]                       return(sequential(..., envir = envir))
[13:20:51.034]                     }
[13:20:51.034]                     oopts <- options(mc.cores = workers)
[13:20:51.034]                     on.exit(options(oopts))
[13:20:51.034]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.034]                       envir = envir)
[13:20:51.034]                     if (!future$lazy) 
[13:20:51.034]                       future <- run(future)
[13:20:51.034]                     invisible(future)
[13:20:51.034]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.034]                 }
[13:20:51.034]             }
[13:20:51.034]         }
[13:20:51.034]     })
[13:20:51.034]     if (TRUE) {
[13:20:51.034]         base::sink(type = "output", split = FALSE)
[13:20:51.034]         if (TRUE) {
[13:20:51.034]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.034]         }
[13:20:51.034]         else {
[13:20:51.034]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.034]         }
[13:20:51.034]         base::close(...future.stdout)
[13:20:51.034]         ...future.stdout <- NULL
[13:20:51.034]     }
[13:20:51.034]     ...future.result$conditions <- ...future.conditions
[13:20:51.034]     ...future.result$finished <- base::Sys.time()
[13:20:51.034]     ...future.result
[13:20:51.034] }
[13:20:51.037] assign_globals() ...
[13:20:51.037] List of 1
[13:20:51.037]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x558dde494e10> 
[13:20:51.037]  - attr(*, "where")=List of 1
[13:20:51.037]   ..$ a:<environment: R_EmptyEnv> 
[13:20:51.037]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:51.037]  - attr(*, "resolved")= logi TRUE
[13:20:51.037]  - attr(*, "total_size")= num 10816
[13:20:51.037]  - attr(*, "already-done")= logi TRUE
[13:20:51.040] - copied ‘a’ to environment
[13:20:51.040] assign_globals() ... done
[13:20:51.041] requestCore(): workers = 2
[13:20:51.043] MulticoreFuture started
[13:20:51.043] - Launch lazy future ... done
[13:20:51.043] run() for ‘MulticoreFuture’ ... done
[13:20:51.044] plan(): Setting new future strategy stack:
[13:20:51.044] List of future strategies:
[13:20:51.044] 1. sequential:
[13:20:51.044]    - args: function (..., envir = parent.frame())
[13:20:51.044]    - tweaked: FALSE
[13:20:51.044]    - call: NULL
[13:20:51.045] plan(): nbrOfWorkers() = 1
[13:20:51.048] plan(): Setting new future strategy stack:
[13:20:51.048] List of future strategies:
[13:20:51.048] 1. multicore:
[13:20:51.048]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.048]    - tweaked: FALSE
[13:20:51.048]    - call: plan(strategy)
[13:20:51.054] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.055] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.055] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:51.056] 
[13:20:51.057] Searching for globals ... DONE
[13:20:51.057] - globals: [0] <none>
[13:20:51.057] getGlobalsAndPackages() ... DONE
[13:20:51.057] run() for ‘Future’ ...
[13:20:51.057] - state: ‘created’
[13:20:51.058] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.062] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.062] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.062]   - Field: ‘label’
[13:20:51.062]   - Field: ‘local’
[13:20:51.062]   - Field: ‘owner’
[13:20:51.062]   - Field: ‘envir’
[13:20:51.063]   - Field: ‘workers’
[13:20:51.063]   - Field: ‘packages’
[13:20:51.063]   - Field: ‘gc’
[13:20:51.063]   - Field: ‘job’
[13:20:51.063]   - Field: ‘conditions’
[13:20:51.063]   - Field: ‘expr’
[13:20:51.063]   - Field: ‘uuid’
[13:20:51.063]   - Field: ‘seed’
[13:20:51.064]   - Field: ‘version’
[13:20:51.064]   - Field: ‘result’
[13:20:51.064]   - Field: ‘asynchronous’
[13:20:51.064]   - Field: ‘calls’
[13:20:51.064]   - Field: ‘globals’
[13:20:51.064]   - Field: ‘stdout’
[13:20:51.064]   - Field: ‘earlySignal’
[13:20:51.064]   - Field: ‘lazy’
[13:20:51.065]   - Field: ‘state’
[13:20:51.065] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.065] - Launch lazy future ...
[13:20:51.065] Packages needed by the future expression (n = 0): <none>
[13:20:51.065] Packages needed by future strategies (n = 0): <none>
[13:20:51.066] {
[13:20:51.066]     {
[13:20:51.066]         {
[13:20:51.066]             ...future.startTime <- base::Sys.time()
[13:20:51.066]             {
[13:20:51.066]                 {
[13:20:51.066]                   {
[13:20:51.066]                     {
[13:20:51.066]                       base::local({
[13:20:51.066]                         has_future <- base::requireNamespace("future", 
[13:20:51.066]                           quietly = TRUE)
[13:20:51.066]                         if (has_future) {
[13:20:51.066]                           ns <- base::getNamespace("future")
[13:20:51.066]                           version <- ns[[".package"]][["version"]]
[13:20:51.066]                           if (is.null(version)) 
[13:20:51.066]                             version <- utils::packageVersion("future")
[13:20:51.066]                         }
[13:20:51.066]                         else {
[13:20:51.066]                           version <- NULL
[13:20:51.066]                         }
[13:20:51.066]                         if (!has_future || version < "1.8.0") {
[13:20:51.066]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.066]                             "", base::R.version$version.string), 
[13:20:51.066]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:51.066]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:51.066]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.066]                               "release", "version")], collapse = " "), 
[13:20:51.066]                             hostname = base::Sys.info()[["nodename"]])
[13:20:51.066]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.066]                             info)
[13:20:51.066]                           info <- base::paste(info, collapse = "; ")
[13:20:51.066]                           if (!has_future) {
[13:20:51.066]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.066]                               info)
[13:20:51.066]                           }
[13:20:51.066]                           else {
[13:20:51.066]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.066]                               info, version)
[13:20:51.066]                           }
[13:20:51.066]                           base::stop(msg)
[13:20:51.066]                         }
[13:20:51.066]                       })
[13:20:51.066]                     }
[13:20:51.066]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.066]                     base::options(mc.cores = 1L)
[13:20:51.066]                   }
[13:20:51.066]                   options(future.plan = NULL)
[13:20:51.066]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.066]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.066]                 }
[13:20:51.066]                 ...future.workdir <- getwd()
[13:20:51.066]             }
[13:20:51.066]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.066]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.066]         }
[13:20:51.066]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.066]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:51.066]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.066]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.066]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.066]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.066]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.066]             base::names(...future.oldOptions))
[13:20:51.066]     }
[13:20:51.066]     if (FALSE) {
[13:20:51.066]     }
[13:20:51.066]     else {
[13:20:51.066]         if (TRUE) {
[13:20:51.066]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.066]                 open = "w")
[13:20:51.066]         }
[13:20:51.066]         else {
[13:20:51.066]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.066]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.066]         }
[13:20:51.066]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.066]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.066]             base::sink(type = "output", split = FALSE)
[13:20:51.066]             base::close(...future.stdout)
[13:20:51.066]         }, add = TRUE)
[13:20:51.066]     }
[13:20:51.066]     ...future.frame <- base::sys.nframe()
[13:20:51.066]     ...future.conditions <- base::list()
[13:20:51.066]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.066]     if (FALSE) {
[13:20:51.066]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.066]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.066]     }
[13:20:51.066]     ...future.result <- base::tryCatch({
[13:20:51.066]         base::withCallingHandlers({
[13:20:51.066]             ...future.value <- base::withVisible(base::local({
[13:20:51.066]                 withCallingHandlers({
[13:20:51.066]                   1
[13:20:51.066]                 }, immediateCondition = function(cond) {
[13:20:51.066]                   save_rds <- function (object, pathname, ...) 
[13:20:51.066]                   {
[13:20:51.066]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.066]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.066]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.066]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.066]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.066]                         fi_tmp[["mtime"]])
[13:20:51.066]                     }
[13:20:51.066]                     tryCatch({
[13:20:51.066]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.066]                     }, error = function(ex) {
[13:20:51.066]                       msg <- conditionMessage(ex)
[13:20:51.066]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.066]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.066]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.066]                         fi_tmp[["mtime"]], msg)
[13:20:51.066]                       ex$message <- msg
[13:20:51.066]                       stop(ex)
[13:20:51.066]                     })
[13:20:51.066]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.066]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.066]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.066]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.066]                       fi <- file.info(pathname)
[13:20:51.066]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.066]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.066]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.066]                         fi[["size"]], fi[["mtime"]])
[13:20:51.066]                       stop(msg)
[13:20:51.066]                     }
[13:20:51.066]                     invisible(pathname)
[13:20:51.066]                   }
[13:20:51.066]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.066]                     rootPath = tempdir()) 
[13:20:51.066]                   {
[13:20:51.066]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.066]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.066]                       tmpdir = path, fileext = ".rds")
[13:20:51.066]                     save_rds(obj, file)
[13:20:51.066]                   }
[13:20:51.066]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.066]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.066]                   {
[13:20:51.066]                     inherits <- base::inherits
[13:20:51.066]                     invokeRestart <- base::invokeRestart
[13:20:51.066]                     is.null <- base::is.null
[13:20:51.066]                     muffled <- FALSE
[13:20:51.066]                     if (inherits(cond, "message")) {
[13:20:51.066]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.066]                       if (muffled) 
[13:20:51.066]                         invokeRestart("muffleMessage")
[13:20:51.066]                     }
[13:20:51.066]                     else if (inherits(cond, "warning")) {
[13:20:51.066]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.066]                       if (muffled) 
[13:20:51.066]                         invokeRestart("muffleWarning")
[13:20:51.066]                     }
[13:20:51.066]                     else if (inherits(cond, "condition")) {
[13:20:51.066]                       if (!is.null(pattern)) {
[13:20:51.066]                         computeRestarts <- base::computeRestarts
[13:20:51.066]                         grepl <- base::grepl
[13:20:51.066]                         restarts <- computeRestarts(cond)
[13:20:51.066]                         for (restart in restarts) {
[13:20:51.066]                           name <- restart$name
[13:20:51.066]                           if (is.null(name)) 
[13:20:51.066]                             next
[13:20:51.066]                           if (!grepl(pattern, name)) 
[13:20:51.066]                             next
[13:20:51.066]                           invokeRestart(restart)
[13:20:51.066]                           muffled <- TRUE
[13:20:51.066]                           break
[13:20:51.066]                         }
[13:20:51.066]                       }
[13:20:51.066]                     }
[13:20:51.066]                     invisible(muffled)
[13:20:51.066]                   }
[13:20:51.066]                   muffleCondition(cond)
[13:20:51.066]                 })
[13:20:51.066]             }))
[13:20:51.066]             future::FutureResult(value = ...future.value$value, 
[13:20:51.066]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.066]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.066]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.066]                     ...future.globalenv.names))
[13:20:51.066]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.066]         }, condition = base::local({
[13:20:51.066]             c <- base::c
[13:20:51.066]             inherits <- base::inherits
[13:20:51.066]             invokeRestart <- base::invokeRestart
[13:20:51.066]             length <- base::length
[13:20:51.066]             list <- base::list
[13:20:51.066]             seq.int <- base::seq.int
[13:20:51.066]             signalCondition <- base::signalCondition
[13:20:51.066]             sys.calls <- base::sys.calls
[13:20:51.066]             `[[` <- base::`[[`
[13:20:51.066]             `+` <- base::`+`
[13:20:51.066]             `<<-` <- base::`<<-`
[13:20:51.066]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.066]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.066]                   3L)]
[13:20:51.066]             }
[13:20:51.066]             function(cond) {
[13:20:51.066]                 is_error <- inherits(cond, "error")
[13:20:51.066]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.066]                   NULL)
[13:20:51.066]                 if (is_error) {
[13:20:51.066]                   sessionInformation <- function() {
[13:20:51.066]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.066]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.066]                       search = base::search(), system = base::Sys.info())
[13:20:51.066]                   }
[13:20:51.066]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.066]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.066]                     cond$call), session = sessionInformation(), 
[13:20:51.066]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.066]                   signalCondition(cond)
[13:20:51.066]                 }
[13:20:51.066]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.066]                 "immediateCondition"))) {
[13:20:51.066]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.066]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.066]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.066]                   if (TRUE && !signal) {
[13:20:51.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.066]                     {
[13:20:51.066]                       inherits <- base::inherits
[13:20:51.066]                       invokeRestart <- base::invokeRestart
[13:20:51.066]                       is.null <- base::is.null
[13:20:51.066]                       muffled <- FALSE
[13:20:51.066]                       if (inherits(cond, "message")) {
[13:20:51.066]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.066]                         if (muffled) 
[13:20:51.066]                           invokeRestart("muffleMessage")
[13:20:51.066]                       }
[13:20:51.066]                       else if (inherits(cond, "warning")) {
[13:20:51.066]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.066]                         if (muffled) 
[13:20:51.066]                           invokeRestart("muffleWarning")
[13:20:51.066]                       }
[13:20:51.066]                       else if (inherits(cond, "condition")) {
[13:20:51.066]                         if (!is.null(pattern)) {
[13:20:51.066]                           computeRestarts <- base::computeRestarts
[13:20:51.066]                           grepl <- base::grepl
[13:20:51.066]                           restarts <- computeRestarts(cond)
[13:20:51.066]                           for (restart in restarts) {
[13:20:51.066]                             name <- restart$name
[13:20:51.066]                             if (is.null(name)) 
[13:20:51.066]                               next
[13:20:51.066]                             if (!grepl(pattern, name)) 
[13:20:51.066]                               next
[13:20:51.066]                             invokeRestart(restart)
[13:20:51.066]                             muffled <- TRUE
[13:20:51.066]                             break
[13:20:51.066]                           }
[13:20:51.066]                         }
[13:20:51.066]                       }
[13:20:51.066]                       invisible(muffled)
[13:20:51.066]                     }
[13:20:51.066]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.066]                   }
[13:20:51.066]                 }
[13:20:51.066]                 else {
[13:20:51.066]                   if (TRUE) {
[13:20:51.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.066]                     {
[13:20:51.066]                       inherits <- base::inherits
[13:20:51.066]                       invokeRestart <- base::invokeRestart
[13:20:51.066]                       is.null <- base::is.null
[13:20:51.066]                       muffled <- FALSE
[13:20:51.066]                       if (inherits(cond, "message")) {
[13:20:51.066]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.066]                         if (muffled) 
[13:20:51.066]                           invokeRestart("muffleMessage")
[13:20:51.066]                       }
[13:20:51.066]                       else if (inherits(cond, "warning")) {
[13:20:51.066]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.066]                         if (muffled) 
[13:20:51.066]                           invokeRestart("muffleWarning")
[13:20:51.066]                       }
[13:20:51.066]                       else if (inherits(cond, "condition")) {
[13:20:51.066]                         if (!is.null(pattern)) {
[13:20:51.066]                           computeRestarts <- base::computeRestarts
[13:20:51.066]                           grepl <- base::grepl
[13:20:51.066]                           restarts <- computeRestarts(cond)
[13:20:51.066]                           for (restart in restarts) {
[13:20:51.066]                             name <- restart$name
[13:20:51.066]                             if (is.null(name)) 
[13:20:51.066]                               next
[13:20:51.066]                             if (!grepl(pattern, name)) 
[13:20:51.066]                               next
[13:20:51.066]                             invokeRestart(restart)
[13:20:51.066]                             muffled <- TRUE
[13:20:51.066]                             break
[13:20:51.066]                           }
[13:20:51.066]                         }
[13:20:51.066]                       }
[13:20:51.066]                       invisible(muffled)
[13:20:51.066]                     }
[13:20:51.066]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.066]                   }
[13:20:51.066]                 }
[13:20:51.066]             }
[13:20:51.066]         }))
[13:20:51.066]     }, error = function(ex) {
[13:20:51.066]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.066]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.066]                 ...future.rng), started = ...future.startTime, 
[13:20:51.066]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.066]             version = "1.8"), class = "FutureResult")
[13:20:51.066]     }, finally = {
[13:20:51.066]         if (!identical(...future.workdir, getwd())) 
[13:20:51.066]             setwd(...future.workdir)
[13:20:51.066]         {
[13:20:51.066]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.066]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.066]             }
[13:20:51.066]             base::options(...future.oldOptions)
[13:20:51.066]             if (.Platform$OS.type == "windows") {
[13:20:51.066]                 old_names <- names(...future.oldEnvVars)
[13:20:51.066]                 envs <- base::Sys.getenv()
[13:20:51.066]                 names <- names(envs)
[13:20:51.066]                 common <- intersect(names, old_names)
[13:20:51.066]                 added <- setdiff(names, old_names)
[13:20:51.066]                 removed <- setdiff(old_names, names)
[13:20:51.066]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.066]                   envs[common]]
[13:20:51.066]                 NAMES <- toupper(changed)
[13:20:51.066]                 args <- list()
[13:20:51.066]                 for (kk in seq_along(NAMES)) {
[13:20:51.066]                   name <- changed[[kk]]
[13:20:51.066]                   NAME <- NAMES[[kk]]
[13:20:51.066]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.066]                     next
[13:20:51.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.066]                 }
[13:20:51.066]                 NAMES <- toupper(added)
[13:20:51.066]                 for (kk in seq_along(NAMES)) {
[13:20:51.066]                   name <- added[[kk]]
[13:20:51.066]                   NAME <- NAMES[[kk]]
[13:20:51.066]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.066]                     next
[13:20:51.066]                   args[[name]] <- ""
[13:20:51.066]                 }
[13:20:51.066]                 NAMES <- toupper(removed)
[13:20:51.066]                 for (kk in seq_along(NAMES)) {
[13:20:51.066]                   name <- removed[[kk]]
[13:20:51.066]                   NAME <- NAMES[[kk]]
[13:20:51.066]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.066]                     next
[13:20:51.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.066]                 }
[13:20:51.066]                 if (length(args) > 0) 
[13:20:51.066]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.066]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.066]             }
[13:20:51.066]             else {
[13:20:51.066]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.066]             }
[13:20:51.066]             {
[13:20:51.066]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.066]                   0L) {
[13:20:51.066]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.066]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.066]                   base::options(opts)
[13:20:51.066]                 }
[13:20:51.066]                 {
[13:20:51.066]                   {
[13:20:51.066]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.066]                     NULL
[13:20:51.066]                   }
[13:20:51.066]                   options(future.plan = NULL)
[13:20:51.066]                   if (is.na(NA_character_)) 
[13:20:51.066]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.066]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.066]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.066]                     envir = parent.frame()) 
[13:20:51.066]                   {
[13:20:51.066]                     default_workers <- missing(workers)
[13:20:51.066]                     if (is.function(workers)) 
[13:20:51.066]                       workers <- workers()
[13:20:51.066]                     workers <- structure(as.integer(workers), 
[13:20:51.066]                       class = class(workers))
[13:20:51.066]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.066]                       1L)
[13:20:51.066]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.066]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.066]                       if (default_workers) 
[13:20:51.066]                         supportsMulticore(warn = TRUE)
[13:20:51.066]                       return(sequential(..., envir = envir))
[13:20:51.066]                     }
[13:20:51.066]                     oopts <- options(mc.cores = workers)
[13:20:51.066]                     on.exit(options(oopts))
[13:20:51.066]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.066]                       envir = envir)
[13:20:51.066]                     if (!future$lazy) 
[13:20:51.066]                       future <- run(future)
[13:20:51.066]                     invisible(future)
[13:20:51.066]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.066]                 }
[13:20:51.066]             }
[13:20:51.066]         }
[13:20:51.066]     })
[13:20:51.066]     if (TRUE) {
[13:20:51.066]         base::sink(type = "output", split = FALSE)
[13:20:51.066]         if (TRUE) {
[13:20:51.066]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.066]         }
[13:20:51.066]         else {
[13:20:51.066]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.066]         }
[13:20:51.066]         base::close(...future.stdout)
[13:20:51.066]         ...future.stdout <- NULL
[13:20:51.066]     }
[13:20:51.066]     ...future.result$conditions <- ...future.conditions
[13:20:51.066]     ...future.result$finished <- base::Sys.time()
[13:20:51.066]     ...future.result
[13:20:51.066] }
[13:20:51.069] requestCore(): workers = 2
[13:20:51.071] MulticoreFuture started
[13:20:51.072] - Launch lazy future ... done
[13:20:51.072] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.072] getGlobalsAndPackages() ...
[13:20:51.072] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.073] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:51.073] List of future strategies:
[13:20:51.073] 1. sequential:
[13:20:51.073]    - args: function (..., envir = parent.frame())
[13:20:51.073]    - tweaked: FALSE
[13:20:51.073]    - call: NULL
[13:20:51.074] plan(): nbrOfWorkers() = 1
[13:20:51.075] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:51.075] Searching for globals ... DONE
[13:20:51.075] Resolving globals: TRUE
[13:20:51.075] Resolving any globals that are futures ...
[13:20:51.076] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:51.076] plan(): Setting new future strategy stack:
[13:20:51.076] Resolving any globals that are futures ... DONE
[13:20:51.076] List of future strategies:
[13:20:51.076] 1. multicore:
[13:20:51.076]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.076]    - tweaked: FALSE
[13:20:51.076]    - call: plan(strategy)
[13:20:51.076] Resolving futures part of globals (recursively) ...
[13:20:51.077] resolve() on list ...
[13:20:51.077]  recursive: 99
[13:20:51.077]  length: 1
[13:20:51.077]  elements: ‘a’
[13:20:51.081] plan(): nbrOfWorkers() = 2
[13:20:51.081] Future #1
[13:20:51.082] A MulticoreFuture was resolved
[13:20:51.083]  length: 0 (resolved future 1)
[13:20:51.083] resolve() on list ... DONE
[13:20:51.083] - globals: [1] ‘a’
[13:20:51.083] Resolving futures part of globals (recursively) ... DONE
[13:20:51.088] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[13:20:51.088] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[13:20:51.089] - globals: [1] ‘a’
[13:20:51.089] - packages: [1] ‘future’
[13:20:51.089] getGlobalsAndPackages() ... DONE
[13:20:51.090] run() for ‘Future’ ...
[13:20:51.090] - state: ‘created’
[13:20:51.090] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.094] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.094] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.095]   - Field: ‘label’
[13:20:51.095]   - Field: ‘local’
[13:20:51.095]   - Field: ‘owner’
[13:20:51.095]   - Field: ‘envir’
[13:20:51.095]   - Field: ‘workers’
[13:20:51.095]   - Field: ‘packages’
[13:20:51.095]   - Field: ‘gc’
[13:20:51.095]   - Field: ‘job’
[13:20:51.096]   - Field: ‘conditions’
[13:20:51.096]   - Field: ‘expr’
[13:20:51.096]   - Field: ‘uuid’
[13:20:51.096]   - Field: ‘seed’
[13:20:51.096]   - Field: ‘version’
[13:20:51.096]   - Field: ‘result’
[13:20:51.096]   - Field: ‘asynchronous’
[13:20:51.096]   - Field: ‘calls’
[13:20:51.097]   - Field: ‘globals’
[13:20:51.097]   - Field: ‘stdout’
[13:20:51.097]   - Field: ‘earlySignal’
[13:20:51.097]   - Field: ‘lazy’
[13:20:51.097]   - Field: ‘state’
[13:20:51.097] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.097] - Launch lazy future ...
[13:20:51.098] Packages needed by the future expression (n = 1): ‘future’
[13:20:51.098] Packages needed by future strategies (n = 0): <none>
[13:20:51.098] {
[13:20:51.098]     {
[13:20:51.098]         {
[13:20:51.098]             ...future.startTime <- base::Sys.time()
[13:20:51.098]             {
[13:20:51.098]                 {
[13:20:51.098]                   {
[13:20:51.098]                     {
[13:20:51.098]                       {
[13:20:51.098]                         base::local({
[13:20:51.098]                           has_future <- base::requireNamespace("future", 
[13:20:51.098]                             quietly = TRUE)
[13:20:51.098]                           if (has_future) {
[13:20:51.098]                             ns <- base::getNamespace("future")
[13:20:51.098]                             version <- ns[[".package"]][["version"]]
[13:20:51.098]                             if (is.null(version)) 
[13:20:51.098]                               version <- utils::packageVersion("future")
[13:20:51.098]                           }
[13:20:51.098]                           else {
[13:20:51.098]                             version <- NULL
[13:20:51.098]                           }
[13:20:51.098]                           if (!has_future || version < "1.8.0") {
[13:20:51.098]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.098]                               "", base::R.version$version.string), 
[13:20:51.098]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:51.098]                                 base::R.version$platform, 8 * 
[13:20:51.098]                                   base::.Machine$sizeof.pointer), 
[13:20:51.098]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.098]                                 "release", "version")], collapse = " "), 
[13:20:51.098]                               hostname = base::Sys.info()[["nodename"]])
[13:20:51.098]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.098]                               info)
[13:20:51.098]                             info <- base::paste(info, collapse = "; ")
[13:20:51.098]                             if (!has_future) {
[13:20:51.098]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.098]                                 info)
[13:20:51.098]                             }
[13:20:51.098]                             else {
[13:20:51.098]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.098]                                 info, version)
[13:20:51.098]                             }
[13:20:51.098]                             base::stop(msg)
[13:20:51.098]                           }
[13:20:51.098]                         })
[13:20:51.098]                       }
[13:20:51.098]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.098]                       base::options(mc.cores = 1L)
[13:20:51.098]                     }
[13:20:51.098]                     base::local({
[13:20:51.098]                       for (pkg in "future") {
[13:20:51.098]                         base::loadNamespace(pkg)
[13:20:51.098]                         base::library(pkg, character.only = TRUE)
[13:20:51.098]                       }
[13:20:51.098]                     })
[13:20:51.098]                   }
[13:20:51.098]                   options(future.plan = NULL)
[13:20:51.098]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.098]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.098]                 }
[13:20:51.098]                 ...future.workdir <- getwd()
[13:20:51.098]             }
[13:20:51.098]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.098]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.098]         }
[13:20:51.098]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.098]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:51.098]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.098]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.098]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.098]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.098]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.098]             base::names(...future.oldOptions))
[13:20:51.098]     }
[13:20:51.098]     if (FALSE) {
[13:20:51.098]     }
[13:20:51.098]     else {
[13:20:51.098]         if (TRUE) {
[13:20:51.098]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.098]                 open = "w")
[13:20:51.098]         }
[13:20:51.098]         else {
[13:20:51.098]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.098]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.098]         }
[13:20:51.098]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.098]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.098]             base::sink(type = "output", split = FALSE)
[13:20:51.098]             base::close(...future.stdout)
[13:20:51.098]         }, add = TRUE)
[13:20:51.098]     }
[13:20:51.098]     ...future.frame <- base::sys.nframe()
[13:20:51.098]     ...future.conditions <- base::list()
[13:20:51.098]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.098]     if (FALSE) {
[13:20:51.098]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.098]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.098]     }
[13:20:51.098]     ...future.result <- base::tryCatch({
[13:20:51.098]         base::withCallingHandlers({
[13:20:51.098]             ...future.value <- base::withVisible(base::local({
[13:20:51.098]                 withCallingHandlers({
[13:20:51.098]                   value(a) + 1
[13:20:51.098]                 }, immediateCondition = function(cond) {
[13:20:51.098]                   save_rds <- function (object, pathname, ...) 
[13:20:51.098]                   {
[13:20:51.098]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.098]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.098]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.098]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.098]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.098]                         fi_tmp[["mtime"]])
[13:20:51.098]                     }
[13:20:51.098]                     tryCatch({
[13:20:51.098]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.098]                     }, error = function(ex) {
[13:20:51.098]                       msg <- conditionMessage(ex)
[13:20:51.098]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.098]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.098]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.098]                         fi_tmp[["mtime"]], msg)
[13:20:51.098]                       ex$message <- msg
[13:20:51.098]                       stop(ex)
[13:20:51.098]                     })
[13:20:51.098]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.098]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.098]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.098]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.098]                       fi <- file.info(pathname)
[13:20:51.098]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.098]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.098]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.098]                         fi[["size"]], fi[["mtime"]])
[13:20:51.098]                       stop(msg)
[13:20:51.098]                     }
[13:20:51.098]                     invisible(pathname)
[13:20:51.098]                   }
[13:20:51.098]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.098]                     rootPath = tempdir()) 
[13:20:51.098]                   {
[13:20:51.098]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.098]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.098]                       tmpdir = path, fileext = ".rds")
[13:20:51.098]                     save_rds(obj, file)
[13:20:51.098]                   }
[13:20:51.098]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.098]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.098]                   {
[13:20:51.098]                     inherits <- base::inherits
[13:20:51.098]                     invokeRestart <- base::invokeRestart
[13:20:51.098]                     is.null <- base::is.null
[13:20:51.098]                     muffled <- FALSE
[13:20:51.098]                     if (inherits(cond, "message")) {
[13:20:51.098]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.098]                       if (muffled) 
[13:20:51.098]                         invokeRestart("muffleMessage")
[13:20:51.098]                     }
[13:20:51.098]                     else if (inherits(cond, "warning")) {
[13:20:51.098]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.098]                       if (muffled) 
[13:20:51.098]                         invokeRestart("muffleWarning")
[13:20:51.098]                     }
[13:20:51.098]                     else if (inherits(cond, "condition")) {
[13:20:51.098]                       if (!is.null(pattern)) {
[13:20:51.098]                         computeRestarts <- base::computeRestarts
[13:20:51.098]                         grepl <- base::grepl
[13:20:51.098]                         restarts <- computeRestarts(cond)
[13:20:51.098]                         for (restart in restarts) {
[13:20:51.098]                           name <- restart$name
[13:20:51.098]                           if (is.null(name)) 
[13:20:51.098]                             next
[13:20:51.098]                           if (!grepl(pattern, name)) 
[13:20:51.098]                             next
[13:20:51.098]                           invokeRestart(restart)
[13:20:51.098]                           muffled <- TRUE
[13:20:51.098]                           break
[13:20:51.098]                         }
[13:20:51.098]                       }
[13:20:51.098]                     }
[13:20:51.098]                     invisible(muffled)
[13:20:51.098]                   }
[13:20:51.098]                   muffleCondition(cond)
[13:20:51.098]                 })
[13:20:51.098]             }))
[13:20:51.098]             future::FutureResult(value = ...future.value$value, 
[13:20:51.098]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.098]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.098]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.098]                     ...future.globalenv.names))
[13:20:51.098]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.098]         }, condition = base::local({
[13:20:51.098]             c <- base::c
[13:20:51.098]             inherits <- base::inherits
[13:20:51.098]             invokeRestart <- base::invokeRestart
[13:20:51.098]             length <- base::length
[13:20:51.098]             list <- base::list
[13:20:51.098]             seq.int <- base::seq.int
[13:20:51.098]             signalCondition <- base::signalCondition
[13:20:51.098]             sys.calls <- base::sys.calls
[13:20:51.098]             `[[` <- base::`[[`
[13:20:51.098]             `+` <- base::`+`
[13:20:51.098]             `<<-` <- base::`<<-`
[13:20:51.098]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.098]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.098]                   3L)]
[13:20:51.098]             }
[13:20:51.098]             function(cond) {
[13:20:51.098]                 is_error <- inherits(cond, "error")
[13:20:51.098]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.098]                   NULL)
[13:20:51.098]                 if (is_error) {
[13:20:51.098]                   sessionInformation <- function() {
[13:20:51.098]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.098]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.098]                       search = base::search(), system = base::Sys.info())
[13:20:51.098]                   }
[13:20:51.098]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.098]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.098]                     cond$call), session = sessionInformation(), 
[13:20:51.098]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.098]                   signalCondition(cond)
[13:20:51.098]                 }
[13:20:51.098]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.098]                 "immediateCondition"))) {
[13:20:51.098]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.098]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.098]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.098]                   if (TRUE && !signal) {
[13:20:51.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.098]                     {
[13:20:51.098]                       inherits <- base::inherits
[13:20:51.098]                       invokeRestart <- base::invokeRestart
[13:20:51.098]                       is.null <- base::is.null
[13:20:51.098]                       muffled <- FALSE
[13:20:51.098]                       if (inherits(cond, "message")) {
[13:20:51.098]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.098]                         if (muffled) 
[13:20:51.098]                           invokeRestart("muffleMessage")
[13:20:51.098]                       }
[13:20:51.098]                       else if (inherits(cond, "warning")) {
[13:20:51.098]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.098]                         if (muffled) 
[13:20:51.098]                           invokeRestart("muffleWarning")
[13:20:51.098]                       }
[13:20:51.098]                       else if (inherits(cond, "condition")) {
[13:20:51.098]                         if (!is.null(pattern)) {
[13:20:51.098]                           computeRestarts <- base::computeRestarts
[13:20:51.098]                           grepl <- base::grepl
[13:20:51.098]                           restarts <- computeRestarts(cond)
[13:20:51.098]                           for (restart in restarts) {
[13:20:51.098]                             name <- restart$name
[13:20:51.098]                             if (is.null(name)) 
[13:20:51.098]                               next
[13:20:51.098]                             if (!grepl(pattern, name)) 
[13:20:51.098]                               next
[13:20:51.098]                             invokeRestart(restart)
[13:20:51.098]                             muffled <- TRUE
[13:20:51.098]                             break
[13:20:51.098]                           }
[13:20:51.098]                         }
[13:20:51.098]                       }
[13:20:51.098]                       invisible(muffled)
[13:20:51.098]                     }
[13:20:51.098]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.098]                   }
[13:20:51.098]                 }
[13:20:51.098]                 else {
[13:20:51.098]                   if (TRUE) {
[13:20:51.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.098]                     {
[13:20:51.098]                       inherits <- base::inherits
[13:20:51.098]                       invokeRestart <- base::invokeRestart
[13:20:51.098]                       is.null <- base::is.null
[13:20:51.098]                       muffled <- FALSE
[13:20:51.098]                       if (inherits(cond, "message")) {
[13:20:51.098]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.098]                         if (muffled) 
[13:20:51.098]                           invokeRestart("muffleMessage")
[13:20:51.098]                       }
[13:20:51.098]                       else if (inherits(cond, "warning")) {
[13:20:51.098]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.098]                         if (muffled) 
[13:20:51.098]                           invokeRestart("muffleWarning")
[13:20:51.098]                       }
[13:20:51.098]                       else if (inherits(cond, "condition")) {
[13:20:51.098]                         if (!is.null(pattern)) {
[13:20:51.098]                           computeRestarts <- base::computeRestarts
[13:20:51.098]                           grepl <- base::grepl
[13:20:51.098]                           restarts <- computeRestarts(cond)
[13:20:51.098]                           for (restart in restarts) {
[13:20:51.098]                             name <- restart$name
[13:20:51.098]                             if (is.null(name)) 
[13:20:51.098]                               next
[13:20:51.098]                             if (!grepl(pattern, name)) 
[13:20:51.098]                               next
[13:20:51.098]                             invokeRestart(restart)
[13:20:51.098]                             muffled <- TRUE
[13:20:51.098]                             break
[13:20:51.098]                           }
[13:20:51.098]                         }
[13:20:51.098]                       }
[13:20:51.098]                       invisible(muffled)
[13:20:51.098]                     }
[13:20:51.098]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.098]                   }
[13:20:51.098]                 }
[13:20:51.098]             }
[13:20:51.098]         }))
[13:20:51.098]     }, error = function(ex) {
[13:20:51.098]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.098]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.098]                 ...future.rng), started = ...future.startTime, 
[13:20:51.098]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.098]             version = "1.8"), class = "FutureResult")
[13:20:51.098]     }, finally = {
[13:20:51.098]         if (!identical(...future.workdir, getwd())) 
[13:20:51.098]             setwd(...future.workdir)
[13:20:51.098]         {
[13:20:51.098]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.098]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.098]             }
[13:20:51.098]             base::options(...future.oldOptions)
[13:20:51.098]             if (.Platform$OS.type == "windows") {
[13:20:51.098]                 old_names <- names(...future.oldEnvVars)
[13:20:51.098]                 envs <- base::Sys.getenv()
[13:20:51.098]                 names <- names(envs)
[13:20:51.098]                 common <- intersect(names, old_names)
[13:20:51.098]                 added <- setdiff(names, old_names)
[13:20:51.098]                 removed <- setdiff(old_names, names)
[13:20:51.098]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.098]                   envs[common]]
[13:20:51.098]                 NAMES <- toupper(changed)
[13:20:51.098]                 args <- list()
[13:20:51.098]                 for (kk in seq_along(NAMES)) {
[13:20:51.098]                   name <- changed[[kk]]
[13:20:51.098]                   NAME <- NAMES[[kk]]
[13:20:51.098]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.098]                     next
[13:20:51.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.098]                 }
[13:20:51.098]                 NAMES <- toupper(added)
[13:20:51.098]                 for (kk in seq_along(NAMES)) {
[13:20:51.098]                   name <- added[[kk]]
[13:20:51.098]                   NAME <- NAMES[[kk]]
[13:20:51.098]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.098]                     next
[13:20:51.098]                   args[[name]] <- ""
[13:20:51.098]                 }
[13:20:51.098]                 NAMES <- toupper(removed)
[13:20:51.098]                 for (kk in seq_along(NAMES)) {
[13:20:51.098]                   name <- removed[[kk]]
[13:20:51.098]                   NAME <- NAMES[[kk]]
[13:20:51.098]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.098]                     next
[13:20:51.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.098]                 }
[13:20:51.098]                 if (length(args) > 0) 
[13:20:51.098]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.098]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.098]             }
[13:20:51.098]             else {
[13:20:51.098]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.098]             }
[13:20:51.098]             {
[13:20:51.098]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.098]                   0L) {
[13:20:51.098]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.098]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.098]                   base::options(opts)
[13:20:51.098]                 }
[13:20:51.098]                 {
[13:20:51.098]                   {
[13:20:51.098]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.098]                     NULL
[13:20:51.098]                   }
[13:20:51.098]                   options(future.plan = NULL)
[13:20:51.098]                   if (is.na(NA_character_)) 
[13:20:51.098]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.098]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.098]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.098]                     envir = parent.frame()) 
[13:20:51.098]                   {
[13:20:51.098]                     default_workers <- missing(workers)
[13:20:51.098]                     if (is.function(workers)) 
[13:20:51.098]                       workers <- workers()
[13:20:51.098]                     workers <- structure(as.integer(workers), 
[13:20:51.098]                       class = class(workers))
[13:20:51.098]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.098]                       1L)
[13:20:51.098]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.098]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.098]                       if (default_workers) 
[13:20:51.098]                         supportsMulticore(warn = TRUE)
[13:20:51.098]                       return(sequential(..., envir = envir))
[13:20:51.098]                     }
[13:20:51.098]                     oopts <- options(mc.cores = workers)
[13:20:51.098]                     on.exit(options(oopts))
[13:20:51.098]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.098]                       envir = envir)
[13:20:51.098]                     if (!future$lazy) 
[13:20:51.098]                       future <- run(future)
[13:20:51.098]                     invisible(future)
[13:20:51.098]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.098]                 }
[13:20:51.098]             }
[13:20:51.098]         }
[13:20:51.098]     })
[13:20:51.098]     if (TRUE) {
[13:20:51.098]         base::sink(type = "output", split = FALSE)
[13:20:51.098]         if (TRUE) {
[13:20:51.098]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.098]         }
[13:20:51.098]         else {
[13:20:51.098]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.098]         }
[13:20:51.098]         base::close(...future.stdout)
[13:20:51.098]         ...future.stdout <- NULL
[13:20:51.098]     }
[13:20:51.098]     ...future.result$conditions <- ...future.conditions
[13:20:51.098]     ...future.result$finished <- base::Sys.time()
[13:20:51.098]     ...future.result
[13:20:51.098] }
[13:20:51.101] assign_globals() ...
[13:20:51.101] List of 1
[13:20:51.101]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x558ddfb704d8> 
[13:20:51.101]  - attr(*, "where")=List of 1
[13:20:51.101]   ..$ a:<environment: R_EmptyEnv> 
[13:20:51.101]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:51.101]  - attr(*, "resolved")= logi TRUE
[13:20:51.101]  - attr(*, "total_size")= num 10816
[13:20:51.101]  - attr(*, "already-done")= logi TRUE
[13:20:51.104] - copied ‘a’ to environment
[13:20:51.104] assign_globals() ... done
[13:20:51.104] requestCore(): workers = 2
[13:20:51.106] MulticoreFuture started
[13:20:51.107] - Launch lazy future ... done
[13:20:51.107] run() for ‘MulticoreFuture’ ... done
[13:20:51.108] plan(): Setting new future strategy stack:
[13:20:51.108] List of future strategies:
[13:20:51.108] 1. sequential:
[13:20:51.108]    - args: function (..., envir = parent.frame())
[13:20:51.108]    - tweaked: FALSE
[13:20:51.108]    - call: NULL
[13:20:51.109] plan(): nbrOfWorkers() = 1
[13:20:51.112] plan(): Setting new future strategy stack:
[13:20:51.112] List of future strategies:
[13:20:51.112] 1. multicore:
[13:20:51.112]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.112]    - tweaked: FALSE
[13:20:51.112]    - call: plan(strategy)
[13:20:51.117] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.118] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.119] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:51.120] 
[13:20:51.120] Searching for globals ... DONE
[13:20:51.120] - globals: [0] <none>
[13:20:51.120] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.120] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.121] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:51.122] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:51.122] Searching for globals ... DONE
[13:20:51.122] Resolving globals: TRUE
[13:20:51.122] Resolving any globals that are futures ...
[13:20:51.123] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:51.123] Resolving any globals that are futures ... DONE
[13:20:51.123] Resolving futures part of globals (recursively) ...
[13:20:51.124] resolve() on list ...
[13:20:51.124]  recursive: 99
[13:20:51.124]  length: 1
[13:20:51.124]  elements: ‘a’
[13:20:51.124] run() for ‘Future’ ...
[13:20:51.124] - state: ‘created’
[13:20:51.124] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.129] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.129] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.129]   - Field: ‘label’
[13:20:51.129]   - Field: ‘local’
[13:20:51.129]   - Field: ‘owner’
[13:20:51.130]   - Field: ‘envir’
[13:20:51.130]   - Field: ‘workers’
[13:20:51.130]   - Field: ‘packages’
[13:20:51.130]   - Field: ‘gc’
[13:20:51.130]   - Field: ‘job’
[13:20:51.130]   - Field: ‘conditions’
[13:20:51.130]   - Field: ‘expr’
[13:20:51.130]   - Field: ‘uuid’
[13:20:51.133]   - Field: ‘seed’
[13:20:51.133]   - Field: ‘version’
[13:20:51.133]   - Field: ‘result’
[13:20:51.134]   - Field: ‘asynchronous’
[13:20:51.134]   - Field: ‘calls’
[13:20:51.134]   - Field: ‘globals’
[13:20:51.134]   - Field: ‘stdout’
[13:20:51.134]   - Field: ‘earlySignal’
[13:20:51.135]   - Field: ‘lazy’
[13:20:51.135]   - Field: ‘state’
[13:20:51.135] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.135] - Launch lazy future ...
[13:20:51.136] Packages needed by the future expression (n = 0): <none>
[13:20:51.136] Packages needed by future strategies (n = 0): <none>
[13:20:51.137] {
[13:20:51.137]     {
[13:20:51.137]         {
[13:20:51.137]             ...future.startTime <- base::Sys.time()
[13:20:51.137]             {
[13:20:51.137]                 {
[13:20:51.137]                   {
[13:20:51.137]                     {
[13:20:51.137]                       base::local({
[13:20:51.137]                         has_future <- base::requireNamespace("future", 
[13:20:51.137]                           quietly = TRUE)
[13:20:51.137]                         if (has_future) {
[13:20:51.137]                           ns <- base::getNamespace("future")
[13:20:51.137]                           version <- ns[[".package"]][["version"]]
[13:20:51.137]                           if (is.null(version)) 
[13:20:51.137]                             version <- utils::packageVersion("future")
[13:20:51.137]                         }
[13:20:51.137]                         else {
[13:20:51.137]                           version <- NULL
[13:20:51.137]                         }
[13:20:51.137]                         if (!has_future || version < "1.8.0") {
[13:20:51.137]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.137]                             "", base::R.version$version.string), 
[13:20:51.137]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:51.137]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:51.137]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.137]                               "release", "version")], collapse = " "), 
[13:20:51.137]                             hostname = base::Sys.info()[["nodename"]])
[13:20:51.137]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.137]                             info)
[13:20:51.137]                           info <- base::paste(info, collapse = "; ")
[13:20:51.137]                           if (!has_future) {
[13:20:51.137]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.137]                               info)
[13:20:51.137]                           }
[13:20:51.137]                           else {
[13:20:51.137]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.137]                               info, version)
[13:20:51.137]                           }
[13:20:51.137]                           base::stop(msg)
[13:20:51.137]                         }
[13:20:51.137]                       })
[13:20:51.137]                     }
[13:20:51.137]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.137]                     base::options(mc.cores = 1L)
[13:20:51.137]                   }
[13:20:51.137]                   options(future.plan = NULL)
[13:20:51.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.137]                 }
[13:20:51.137]                 ...future.workdir <- getwd()
[13:20:51.137]             }
[13:20:51.137]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.137]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.137]         }
[13:20:51.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.137]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:51.137]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.137]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.137]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.137]             base::names(...future.oldOptions))
[13:20:51.137]     }
[13:20:51.137]     if (FALSE) {
[13:20:51.137]     }
[13:20:51.137]     else {
[13:20:51.137]         if (TRUE) {
[13:20:51.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.137]                 open = "w")
[13:20:51.137]         }
[13:20:51.137]         else {
[13:20:51.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.137]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.137]         }
[13:20:51.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.137]             base::sink(type = "output", split = FALSE)
[13:20:51.137]             base::close(...future.stdout)
[13:20:51.137]         }, add = TRUE)
[13:20:51.137]     }
[13:20:51.137]     ...future.frame <- base::sys.nframe()
[13:20:51.137]     ...future.conditions <- base::list()
[13:20:51.137]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.137]     if (FALSE) {
[13:20:51.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.137]     }
[13:20:51.137]     ...future.result <- base::tryCatch({
[13:20:51.137]         base::withCallingHandlers({
[13:20:51.137]             ...future.value <- base::withVisible(base::local({
[13:20:51.137]                 withCallingHandlers({
[13:20:51.137]                   1
[13:20:51.137]                 }, immediateCondition = function(cond) {
[13:20:51.137]                   save_rds <- function (object, pathname, ...) 
[13:20:51.137]                   {
[13:20:51.137]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.137]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.137]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.137]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.137]                         fi_tmp[["mtime"]])
[13:20:51.137]                     }
[13:20:51.137]                     tryCatch({
[13:20:51.137]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.137]                     }, error = function(ex) {
[13:20:51.137]                       msg <- conditionMessage(ex)
[13:20:51.137]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.137]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.137]                         fi_tmp[["mtime"]], msg)
[13:20:51.137]                       ex$message <- msg
[13:20:51.137]                       stop(ex)
[13:20:51.137]                     })
[13:20:51.137]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.137]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.137]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.137]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.137]                       fi <- file.info(pathname)
[13:20:51.137]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.137]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.137]                         fi[["size"]], fi[["mtime"]])
[13:20:51.137]                       stop(msg)
[13:20:51.137]                     }
[13:20:51.137]                     invisible(pathname)
[13:20:51.137]                   }
[13:20:51.137]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.137]                     rootPath = tempdir()) 
[13:20:51.137]                   {
[13:20:51.137]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.137]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.137]                       tmpdir = path, fileext = ".rds")
[13:20:51.137]                     save_rds(obj, file)
[13:20:51.137]                   }
[13:20:51.137]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.137]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.137]                   {
[13:20:51.137]                     inherits <- base::inherits
[13:20:51.137]                     invokeRestart <- base::invokeRestart
[13:20:51.137]                     is.null <- base::is.null
[13:20:51.137]                     muffled <- FALSE
[13:20:51.137]                     if (inherits(cond, "message")) {
[13:20:51.137]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.137]                       if (muffled) 
[13:20:51.137]                         invokeRestart("muffleMessage")
[13:20:51.137]                     }
[13:20:51.137]                     else if (inherits(cond, "warning")) {
[13:20:51.137]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.137]                       if (muffled) 
[13:20:51.137]                         invokeRestart("muffleWarning")
[13:20:51.137]                     }
[13:20:51.137]                     else if (inherits(cond, "condition")) {
[13:20:51.137]                       if (!is.null(pattern)) {
[13:20:51.137]                         computeRestarts <- base::computeRestarts
[13:20:51.137]                         grepl <- base::grepl
[13:20:51.137]                         restarts <- computeRestarts(cond)
[13:20:51.137]                         for (restart in restarts) {
[13:20:51.137]                           name <- restart$name
[13:20:51.137]                           if (is.null(name)) 
[13:20:51.137]                             next
[13:20:51.137]                           if (!grepl(pattern, name)) 
[13:20:51.137]                             next
[13:20:51.137]                           invokeRestart(restart)
[13:20:51.137]                           muffled <- TRUE
[13:20:51.137]                           break
[13:20:51.137]                         }
[13:20:51.137]                       }
[13:20:51.137]                     }
[13:20:51.137]                     invisible(muffled)
[13:20:51.137]                   }
[13:20:51.137]                   muffleCondition(cond)
[13:20:51.137]                 })
[13:20:51.137]             }))
[13:20:51.137]             future::FutureResult(value = ...future.value$value, 
[13:20:51.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.137]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.137]                     ...future.globalenv.names))
[13:20:51.137]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.137]         }, condition = base::local({
[13:20:51.137]             c <- base::c
[13:20:51.137]             inherits <- base::inherits
[13:20:51.137]             invokeRestart <- base::invokeRestart
[13:20:51.137]             length <- base::length
[13:20:51.137]             list <- base::list
[13:20:51.137]             seq.int <- base::seq.int
[13:20:51.137]             signalCondition <- base::signalCondition
[13:20:51.137]             sys.calls <- base::sys.calls
[13:20:51.137]             `[[` <- base::`[[`
[13:20:51.137]             `+` <- base::`+`
[13:20:51.137]             `<<-` <- base::`<<-`
[13:20:51.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.137]                   3L)]
[13:20:51.137]             }
[13:20:51.137]             function(cond) {
[13:20:51.137]                 is_error <- inherits(cond, "error")
[13:20:51.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.137]                   NULL)
[13:20:51.137]                 if (is_error) {
[13:20:51.137]                   sessionInformation <- function() {
[13:20:51.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.137]                       search = base::search(), system = base::Sys.info())
[13:20:51.137]                   }
[13:20:51.137]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.137]                     cond$call), session = sessionInformation(), 
[13:20:51.137]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.137]                   signalCondition(cond)
[13:20:51.137]                 }
[13:20:51.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.137]                 "immediateCondition"))) {
[13:20:51.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.137]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.137]                   if (TRUE && !signal) {
[13:20:51.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.137]                     {
[13:20:51.137]                       inherits <- base::inherits
[13:20:51.137]                       invokeRestart <- base::invokeRestart
[13:20:51.137]                       is.null <- base::is.null
[13:20:51.137]                       muffled <- FALSE
[13:20:51.137]                       if (inherits(cond, "message")) {
[13:20:51.137]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.137]                         if (muffled) 
[13:20:51.137]                           invokeRestart("muffleMessage")
[13:20:51.137]                       }
[13:20:51.137]                       else if (inherits(cond, "warning")) {
[13:20:51.137]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.137]                         if (muffled) 
[13:20:51.137]                           invokeRestart("muffleWarning")
[13:20:51.137]                       }
[13:20:51.137]                       else if (inherits(cond, "condition")) {
[13:20:51.137]                         if (!is.null(pattern)) {
[13:20:51.137]                           computeRestarts <- base::computeRestarts
[13:20:51.137]                           grepl <- base::grepl
[13:20:51.137]                           restarts <- computeRestarts(cond)
[13:20:51.137]                           for (restart in restarts) {
[13:20:51.137]                             name <- restart$name
[13:20:51.137]                             if (is.null(name)) 
[13:20:51.137]                               next
[13:20:51.137]                             if (!grepl(pattern, name)) 
[13:20:51.137]                               next
[13:20:51.137]                             invokeRestart(restart)
[13:20:51.137]                             muffled <- TRUE
[13:20:51.137]                             break
[13:20:51.137]                           }
[13:20:51.137]                         }
[13:20:51.137]                       }
[13:20:51.137]                       invisible(muffled)
[13:20:51.137]                     }
[13:20:51.137]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.137]                   }
[13:20:51.137]                 }
[13:20:51.137]                 else {
[13:20:51.137]                   if (TRUE) {
[13:20:51.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.137]                     {
[13:20:51.137]                       inherits <- base::inherits
[13:20:51.137]                       invokeRestart <- base::invokeRestart
[13:20:51.137]                       is.null <- base::is.null
[13:20:51.137]                       muffled <- FALSE
[13:20:51.137]                       if (inherits(cond, "message")) {
[13:20:51.137]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.137]                         if (muffled) 
[13:20:51.137]                           invokeRestart("muffleMessage")
[13:20:51.137]                       }
[13:20:51.137]                       else if (inherits(cond, "warning")) {
[13:20:51.137]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.137]                         if (muffled) 
[13:20:51.137]                           invokeRestart("muffleWarning")
[13:20:51.137]                       }
[13:20:51.137]                       else if (inherits(cond, "condition")) {
[13:20:51.137]                         if (!is.null(pattern)) {
[13:20:51.137]                           computeRestarts <- base::computeRestarts
[13:20:51.137]                           grepl <- base::grepl
[13:20:51.137]                           restarts <- computeRestarts(cond)
[13:20:51.137]                           for (restart in restarts) {
[13:20:51.137]                             name <- restart$name
[13:20:51.137]                             if (is.null(name)) 
[13:20:51.137]                               next
[13:20:51.137]                             if (!grepl(pattern, name)) 
[13:20:51.137]                               next
[13:20:51.137]                             invokeRestart(restart)
[13:20:51.137]                             muffled <- TRUE
[13:20:51.137]                             break
[13:20:51.137]                           }
[13:20:51.137]                         }
[13:20:51.137]                       }
[13:20:51.137]                       invisible(muffled)
[13:20:51.137]                     }
[13:20:51.137]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.137]                   }
[13:20:51.137]                 }
[13:20:51.137]             }
[13:20:51.137]         }))
[13:20:51.137]     }, error = function(ex) {
[13:20:51.137]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.137]                 ...future.rng), started = ...future.startTime, 
[13:20:51.137]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.137]             version = "1.8"), class = "FutureResult")
[13:20:51.137]     }, finally = {
[13:20:51.137]         if (!identical(...future.workdir, getwd())) 
[13:20:51.137]             setwd(...future.workdir)
[13:20:51.137]         {
[13:20:51.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.137]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.137]             }
[13:20:51.137]             base::options(...future.oldOptions)
[13:20:51.137]             if (.Platform$OS.type == "windows") {
[13:20:51.137]                 old_names <- names(...future.oldEnvVars)
[13:20:51.137]                 envs <- base::Sys.getenv()
[13:20:51.137]                 names <- names(envs)
[13:20:51.137]                 common <- intersect(names, old_names)
[13:20:51.137]                 added <- setdiff(names, old_names)
[13:20:51.137]                 removed <- setdiff(old_names, names)
[13:20:51.137]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.137]                   envs[common]]
[13:20:51.137]                 NAMES <- toupper(changed)
[13:20:51.137]                 args <- list()
[13:20:51.137]                 for (kk in seq_along(NAMES)) {
[13:20:51.137]                   name <- changed[[kk]]
[13:20:51.137]                   NAME <- NAMES[[kk]]
[13:20:51.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.137]                     next
[13:20:51.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.137]                 }
[13:20:51.137]                 NAMES <- toupper(added)
[13:20:51.137]                 for (kk in seq_along(NAMES)) {
[13:20:51.137]                   name <- added[[kk]]
[13:20:51.137]                   NAME <- NAMES[[kk]]
[13:20:51.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.137]                     next
[13:20:51.137]                   args[[name]] <- ""
[13:20:51.137]                 }
[13:20:51.137]                 NAMES <- toupper(removed)
[13:20:51.137]                 for (kk in seq_along(NAMES)) {
[13:20:51.137]                   name <- removed[[kk]]
[13:20:51.137]                   NAME <- NAMES[[kk]]
[13:20:51.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.137]                     next
[13:20:51.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.137]                 }
[13:20:51.137]                 if (length(args) > 0) 
[13:20:51.137]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.137]             }
[13:20:51.137]             else {
[13:20:51.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.137]             }
[13:20:51.137]             {
[13:20:51.137]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.137]                   0L) {
[13:20:51.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.137]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.137]                   base::options(opts)
[13:20:51.137]                 }
[13:20:51.137]                 {
[13:20:51.137]                   {
[13:20:51.137]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.137]                     NULL
[13:20:51.137]                   }
[13:20:51.137]                   options(future.plan = NULL)
[13:20:51.137]                   if (is.na(NA_character_)) 
[13:20:51.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.137]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.137]                     envir = parent.frame()) 
[13:20:51.137]                   {
[13:20:51.137]                     default_workers <- missing(workers)
[13:20:51.137]                     if (is.function(workers)) 
[13:20:51.137]                       workers <- workers()
[13:20:51.137]                     workers <- structure(as.integer(workers), 
[13:20:51.137]                       class = class(workers))
[13:20:51.137]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.137]                       1L)
[13:20:51.137]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.137]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.137]                       if (default_workers) 
[13:20:51.137]                         supportsMulticore(warn = TRUE)
[13:20:51.137]                       return(sequential(..., envir = envir))
[13:20:51.137]                     }
[13:20:51.137]                     oopts <- options(mc.cores = workers)
[13:20:51.137]                     on.exit(options(oopts))
[13:20:51.137]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.137]                       envir = envir)
[13:20:51.137]                     if (!future$lazy) 
[13:20:51.137]                       future <- run(future)
[13:20:51.137]                     invisible(future)
[13:20:51.137]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.137]                 }
[13:20:51.137]             }
[13:20:51.137]         }
[13:20:51.137]     })
[13:20:51.137]     if (TRUE) {
[13:20:51.137]         base::sink(type = "output", split = FALSE)
[13:20:51.137]         if (TRUE) {
[13:20:51.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.137]         }
[13:20:51.137]         else {
[13:20:51.137]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.137]         }
[13:20:51.137]         base::close(...future.stdout)
[13:20:51.137]         ...future.stdout <- NULL
[13:20:51.137]     }
[13:20:51.137]     ...future.result$conditions <- ...future.conditions
[13:20:51.137]     ...future.result$finished <- base::Sys.time()
[13:20:51.137]     ...future.result
[13:20:51.137] }
[13:20:51.139] requestCore(): workers = 2
[13:20:51.142] MulticoreFuture started
[13:20:51.142] - Launch lazy future ... done
[13:20:51.142] run() for ‘MulticoreFuture’ ... done
[13:20:51.143] plan(): Setting new future strategy stack:
[13:20:51.143] List of future strategies:
[13:20:51.143] 1. sequential:
[13:20:51.143]    - args: function (..., envir = parent.frame())
[13:20:51.143]    - tweaked: FALSE
[13:20:51.143]    - call: NULL
[13:20:51.144] plan(): nbrOfWorkers() = 1
[13:20:51.147] plan(): Setting new future strategy stack:
[13:20:51.147] List of future strategies:
[13:20:51.147] 1. multicore:
[13:20:51.147]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.147]    - tweaked: FALSE
[13:20:51.147]    - call: plan(strategy)
[13:20:51.152] plan(): nbrOfWorkers() = 2
[13:20:51.153] Future #1
[13:20:51.154] A MulticoreFuture was resolved
[13:20:51.155]  length: 0 (resolved future 1)
[13:20:51.155] resolve() on list ... DONE
[13:20:51.155] - globals: [1] ‘a’
[13:20:51.155] Resolving futures part of globals (recursively) ... DONE
[13:20:51.157] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[13:20:51.158] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[13:20:51.158] - globals: [1] ‘a’
[13:20:51.158] - packages: [1] ‘future’
[13:20:51.158] getGlobalsAndPackages() ... DONE
[13:20:51.159] run() for ‘Future’ ...
[13:20:51.159] - state: ‘created’
[13:20:51.159] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.163] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.164] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.164]   - Field: ‘label’
[13:20:51.164]   - Field: ‘local’
[13:20:51.164]   - Field: ‘owner’
[13:20:51.164]   - Field: ‘envir’
[13:20:51.164]   - Field: ‘workers’
[13:20:51.164]   - Field: ‘packages’
[13:20:51.165]   - Field: ‘gc’
[13:20:51.165]   - Field: ‘job’
[13:20:51.165]   - Field: ‘conditions’
[13:20:51.165]   - Field: ‘expr’
[13:20:51.165]   - Field: ‘uuid’
[13:20:51.165]   - Field: ‘seed’
[13:20:51.165]   - Field: ‘version’
[13:20:51.165]   - Field: ‘result’
[13:20:51.166]   - Field: ‘asynchronous’
[13:20:51.166]   - Field: ‘calls’
[13:20:51.166]   - Field: ‘globals’
[13:20:51.166]   - Field: ‘stdout’
[13:20:51.166]   - Field: ‘earlySignal’
[13:20:51.166]   - Field: ‘lazy’
[13:20:51.166]   - Field: ‘state’
[13:20:51.166] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.166] - Launch lazy future ...
[13:20:51.167] Packages needed by the future expression (n = 1): ‘future’
[13:20:51.167] Packages needed by future strategies (n = 0): <none>
[13:20:51.168] {
[13:20:51.168]     {
[13:20:51.168]         {
[13:20:51.168]             ...future.startTime <- base::Sys.time()
[13:20:51.168]             {
[13:20:51.168]                 {
[13:20:51.168]                   {
[13:20:51.168]                     {
[13:20:51.168]                       {
[13:20:51.168]                         base::local({
[13:20:51.168]                           has_future <- base::requireNamespace("future", 
[13:20:51.168]                             quietly = TRUE)
[13:20:51.168]                           if (has_future) {
[13:20:51.168]                             ns <- base::getNamespace("future")
[13:20:51.168]                             version <- ns[[".package"]][["version"]]
[13:20:51.168]                             if (is.null(version)) 
[13:20:51.168]                               version <- utils::packageVersion("future")
[13:20:51.168]                           }
[13:20:51.168]                           else {
[13:20:51.168]                             version <- NULL
[13:20:51.168]                           }
[13:20:51.168]                           if (!has_future || version < "1.8.0") {
[13:20:51.168]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.168]                               "", base::R.version$version.string), 
[13:20:51.168]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:51.168]                                 base::R.version$platform, 8 * 
[13:20:51.168]                                   base::.Machine$sizeof.pointer), 
[13:20:51.168]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.168]                                 "release", "version")], collapse = " "), 
[13:20:51.168]                               hostname = base::Sys.info()[["nodename"]])
[13:20:51.168]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.168]                               info)
[13:20:51.168]                             info <- base::paste(info, collapse = "; ")
[13:20:51.168]                             if (!has_future) {
[13:20:51.168]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.168]                                 info)
[13:20:51.168]                             }
[13:20:51.168]                             else {
[13:20:51.168]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.168]                                 info, version)
[13:20:51.168]                             }
[13:20:51.168]                             base::stop(msg)
[13:20:51.168]                           }
[13:20:51.168]                         })
[13:20:51.168]                       }
[13:20:51.168]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.168]                       base::options(mc.cores = 1L)
[13:20:51.168]                     }
[13:20:51.168]                     base::local({
[13:20:51.168]                       for (pkg in "future") {
[13:20:51.168]                         base::loadNamespace(pkg)
[13:20:51.168]                         base::library(pkg, character.only = TRUE)
[13:20:51.168]                       }
[13:20:51.168]                     })
[13:20:51.168]                   }
[13:20:51.168]                   options(future.plan = NULL)
[13:20:51.168]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.168]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.168]                 }
[13:20:51.168]                 ...future.workdir <- getwd()
[13:20:51.168]             }
[13:20:51.168]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.168]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.168]         }
[13:20:51.168]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.168]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:51.168]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.168]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.168]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.168]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.168]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.168]             base::names(...future.oldOptions))
[13:20:51.168]     }
[13:20:51.168]     if (FALSE) {
[13:20:51.168]     }
[13:20:51.168]     else {
[13:20:51.168]         if (TRUE) {
[13:20:51.168]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.168]                 open = "w")
[13:20:51.168]         }
[13:20:51.168]         else {
[13:20:51.168]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.168]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.168]         }
[13:20:51.168]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.168]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.168]             base::sink(type = "output", split = FALSE)
[13:20:51.168]             base::close(...future.stdout)
[13:20:51.168]         }, add = TRUE)
[13:20:51.168]     }
[13:20:51.168]     ...future.frame <- base::sys.nframe()
[13:20:51.168]     ...future.conditions <- base::list()
[13:20:51.168]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.168]     if (FALSE) {
[13:20:51.168]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.168]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.168]     }
[13:20:51.168]     ...future.result <- base::tryCatch({
[13:20:51.168]         base::withCallingHandlers({
[13:20:51.168]             ...future.value <- base::withVisible(base::local({
[13:20:51.168]                 withCallingHandlers({
[13:20:51.168]                   value(a) + 1
[13:20:51.168]                 }, immediateCondition = function(cond) {
[13:20:51.168]                   save_rds <- function (object, pathname, ...) 
[13:20:51.168]                   {
[13:20:51.168]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.168]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.168]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.168]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.168]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.168]                         fi_tmp[["mtime"]])
[13:20:51.168]                     }
[13:20:51.168]                     tryCatch({
[13:20:51.168]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.168]                     }, error = function(ex) {
[13:20:51.168]                       msg <- conditionMessage(ex)
[13:20:51.168]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.168]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.168]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.168]                         fi_tmp[["mtime"]], msg)
[13:20:51.168]                       ex$message <- msg
[13:20:51.168]                       stop(ex)
[13:20:51.168]                     })
[13:20:51.168]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.168]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.168]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.168]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.168]                       fi <- file.info(pathname)
[13:20:51.168]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.168]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.168]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.168]                         fi[["size"]], fi[["mtime"]])
[13:20:51.168]                       stop(msg)
[13:20:51.168]                     }
[13:20:51.168]                     invisible(pathname)
[13:20:51.168]                   }
[13:20:51.168]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.168]                     rootPath = tempdir()) 
[13:20:51.168]                   {
[13:20:51.168]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.168]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.168]                       tmpdir = path, fileext = ".rds")
[13:20:51.168]                     save_rds(obj, file)
[13:20:51.168]                   }
[13:20:51.168]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.168]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.168]                   {
[13:20:51.168]                     inherits <- base::inherits
[13:20:51.168]                     invokeRestart <- base::invokeRestart
[13:20:51.168]                     is.null <- base::is.null
[13:20:51.168]                     muffled <- FALSE
[13:20:51.168]                     if (inherits(cond, "message")) {
[13:20:51.168]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.168]                       if (muffled) 
[13:20:51.168]                         invokeRestart("muffleMessage")
[13:20:51.168]                     }
[13:20:51.168]                     else if (inherits(cond, "warning")) {
[13:20:51.168]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.168]                       if (muffled) 
[13:20:51.168]                         invokeRestart("muffleWarning")
[13:20:51.168]                     }
[13:20:51.168]                     else if (inherits(cond, "condition")) {
[13:20:51.168]                       if (!is.null(pattern)) {
[13:20:51.168]                         computeRestarts <- base::computeRestarts
[13:20:51.168]                         grepl <- base::grepl
[13:20:51.168]                         restarts <- computeRestarts(cond)
[13:20:51.168]                         for (restart in restarts) {
[13:20:51.168]                           name <- restart$name
[13:20:51.168]                           if (is.null(name)) 
[13:20:51.168]                             next
[13:20:51.168]                           if (!grepl(pattern, name)) 
[13:20:51.168]                             next
[13:20:51.168]                           invokeRestart(restart)
[13:20:51.168]                           muffled <- TRUE
[13:20:51.168]                           break
[13:20:51.168]                         }
[13:20:51.168]                       }
[13:20:51.168]                     }
[13:20:51.168]                     invisible(muffled)
[13:20:51.168]                   }
[13:20:51.168]                   muffleCondition(cond)
[13:20:51.168]                 })
[13:20:51.168]             }))
[13:20:51.168]             future::FutureResult(value = ...future.value$value, 
[13:20:51.168]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.168]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.168]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.168]                     ...future.globalenv.names))
[13:20:51.168]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.168]         }, condition = base::local({
[13:20:51.168]             c <- base::c
[13:20:51.168]             inherits <- base::inherits
[13:20:51.168]             invokeRestart <- base::invokeRestart
[13:20:51.168]             length <- base::length
[13:20:51.168]             list <- base::list
[13:20:51.168]             seq.int <- base::seq.int
[13:20:51.168]             signalCondition <- base::signalCondition
[13:20:51.168]             sys.calls <- base::sys.calls
[13:20:51.168]             `[[` <- base::`[[`
[13:20:51.168]             `+` <- base::`+`
[13:20:51.168]             `<<-` <- base::`<<-`
[13:20:51.168]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.168]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.168]                   3L)]
[13:20:51.168]             }
[13:20:51.168]             function(cond) {
[13:20:51.168]                 is_error <- inherits(cond, "error")
[13:20:51.168]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.168]                   NULL)
[13:20:51.168]                 if (is_error) {
[13:20:51.168]                   sessionInformation <- function() {
[13:20:51.168]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.168]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.168]                       search = base::search(), system = base::Sys.info())
[13:20:51.168]                   }
[13:20:51.168]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.168]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.168]                     cond$call), session = sessionInformation(), 
[13:20:51.168]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.168]                   signalCondition(cond)
[13:20:51.168]                 }
[13:20:51.168]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.168]                 "immediateCondition"))) {
[13:20:51.168]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.168]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.168]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.168]                   if (TRUE && !signal) {
[13:20:51.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.168]                     {
[13:20:51.168]                       inherits <- base::inherits
[13:20:51.168]                       invokeRestart <- base::invokeRestart
[13:20:51.168]                       is.null <- base::is.null
[13:20:51.168]                       muffled <- FALSE
[13:20:51.168]                       if (inherits(cond, "message")) {
[13:20:51.168]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.168]                         if (muffled) 
[13:20:51.168]                           invokeRestart("muffleMessage")
[13:20:51.168]                       }
[13:20:51.168]                       else if (inherits(cond, "warning")) {
[13:20:51.168]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.168]                         if (muffled) 
[13:20:51.168]                           invokeRestart("muffleWarning")
[13:20:51.168]                       }
[13:20:51.168]                       else if (inherits(cond, "condition")) {
[13:20:51.168]                         if (!is.null(pattern)) {
[13:20:51.168]                           computeRestarts <- base::computeRestarts
[13:20:51.168]                           grepl <- base::grepl
[13:20:51.168]                           restarts <- computeRestarts(cond)
[13:20:51.168]                           for (restart in restarts) {
[13:20:51.168]                             name <- restart$name
[13:20:51.168]                             if (is.null(name)) 
[13:20:51.168]                               next
[13:20:51.168]                             if (!grepl(pattern, name)) 
[13:20:51.168]                               next
[13:20:51.168]                             invokeRestart(restart)
[13:20:51.168]                             muffled <- TRUE
[13:20:51.168]                             break
[13:20:51.168]                           }
[13:20:51.168]                         }
[13:20:51.168]                       }
[13:20:51.168]                       invisible(muffled)
[13:20:51.168]                     }
[13:20:51.168]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.168]                   }
[13:20:51.168]                 }
[13:20:51.168]                 else {
[13:20:51.168]                   if (TRUE) {
[13:20:51.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.168]                     {
[13:20:51.168]                       inherits <- base::inherits
[13:20:51.168]                       invokeRestart <- base::invokeRestart
[13:20:51.168]                       is.null <- base::is.null
[13:20:51.168]                       muffled <- FALSE
[13:20:51.168]                       if (inherits(cond, "message")) {
[13:20:51.168]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.168]                         if (muffled) 
[13:20:51.168]                           invokeRestart("muffleMessage")
[13:20:51.168]                       }
[13:20:51.168]                       else if (inherits(cond, "warning")) {
[13:20:51.168]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.168]                         if (muffled) 
[13:20:51.168]                           invokeRestart("muffleWarning")
[13:20:51.168]                       }
[13:20:51.168]                       else if (inherits(cond, "condition")) {
[13:20:51.168]                         if (!is.null(pattern)) {
[13:20:51.168]                           computeRestarts <- base::computeRestarts
[13:20:51.168]                           grepl <- base::grepl
[13:20:51.168]                           restarts <- computeRestarts(cond)
[13:20:51.168]                           for (restart in restarts) {
[13:20:51.168]                             name <- restart$name
[13:20:51.168]                             if (is.null(name)) 
[13:20:51.168]                               next
[13:20:51.168]                             if (!grepl(pattern, name)) 
[13:20:51.168]                               next
[13:20:51.168]                             invokeRestart(restart)
[13:20:51.168]                             muffled <- TRUE
[13:20:51.168]                             break
[13:20:51.168]                           }
[13:20:51.168]                         }
[13:20:51.168]                       }
[13:20:51.168]                       invisible(muffled)
[13:20:51.168]                     }
[13:20:51.168]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.168]                   }
[13:20:51.168]                 }
[13:20:51.168]             }
[13:20:51.168]         }))
[13:20:51.168]     }, error = function(ex) {
[13:20:51.168]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.168]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.168]                 ...future.rng), started = ...future.startTime, 
[13:20:51.168]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.168]             version = "1.8"), class = "FutureResult")
[13:20:51.168]     }, finally = {
[13:20:51.168]         if (!identical(...future.workdir, getwd())) 
[13:20:51.168]             setwd(...future.workdir)
[13:20:51.168]         {
[13:20:51.168]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.168]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.168]             }
[13:20:51.168]             base::options(...future.oldOptions)
[13:20:51.168]             if (.Platform$OS.type == "windows") {
[13:20:51.168]                 old_names <- names(...future.oldEnvVars)
[13:20:51.168]                 envs <- base::Sys.getenv()
[13:20:51.168]                 names <- names(envs)
[13:20:51.168]                 common <- intersect(names, old_names)
[13:20:51.168]                 added <- setdiff(names, old_names)
[13:20:51.168]                 removed <- setdiff(old_names, names)
[13:20:51.168]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.168]                   envs[common]]
[13:20:51.168]                 NAMES <- toupper(changed)
[13:20:51.168]                 args <- list()
[13:20:51.168]                 for (kk in seq_along(NAMES)) {
[13:20:51.168]                   name <- changed[[kk]]
[13:20:51.168]                   NAME <- NAMES[[kk]]
[13:20:51.168]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.168]                     next
[13:20:51.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.168]                 }
[13:20:51.168]                 NAMES <- toupper(added)
[13:20:51.168]                 for (kk in seq_along(NAMES)) {
[13:20:51.168]                   name <- added[[kk]]
[13:20:51.168]                   NAME <- NAMES[[kk]]
[13:20:51.168]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.168]                     next
[13:20:51.168]                   args[[name]] <- ""
[13:20:51.168]                 }
[13:20:51.168]                 NAMES <- toupper(removed)
[13:20:51.168]                 for (kk in seq_along(NAMES)) {
[13:20:51.168]                   name <- removed[[kk]]
[13:20:51.168]                   NAME <- NAMES[[kk]]
[13:20:51.168]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.168]                     next
[13:20:51.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.168]                 }
[13:20:51.168]                 if (length(args) > 0) 
[13:20:51.168]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.168]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.168]             }
[13:20:51.168]             else {
[13:20:51.168]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.168]             }
[13:20:51.168]             {
[13:20:51.168]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.168]                   0L) {
[13:20:51.168]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.168]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.168]                   base::options(opts)
[13:20:51.168]                 }
[13:20:51.168]                 {
[13:20:51.168]                   {
[13:20:51.168]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.168]                     NULL
[13:20:51.168]                   }
[13:20:51.168]                   options(future.plan = NULL)
[13:20:51.168]                   if (is.na(NA_character_)) 
[13:20:51.168]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.168]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.168]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.168]                     envir = parent.frame()) 
[13:20:51.168]                   {
[13:20:51.168]                     default_workers <- missing(workers)
[13:20:51.168]                     if (is.function(workers)) 
[13:20:51.168]                       workers <- workers()
[13:20:51.168]                     workers <- structure(as.integer(workers), 
[13:20:51.168]                       class = class(workers))
[13:20:51.168]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.168]                       1L)
[13:20:51.168]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.168]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.168]                       if (default_workers) 
[13:20:51.168]                         supportsMulticore(warn = TRUE)
[13:20:51.168]                       return(sequential(..., envir = envir))
[13:20:51.168]                     }
[13:20:51.168]                     oopts <- options(mc.cores = workers)
[13:20:51.168]                     on.exit(options(oopts))
[13:20:51.168]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.168]                       envir = envir)
[13:20:51.168]                     if (!future$lazy) 
[13:20:51.168]                       future <- run(future)
[13:20:51.168]                     invisible(future)
[13:20:51.168]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.168]                 }
[13:20:51.168]             }
[13:20:51.168]         }
[13:20:51.168]     })
[13:20:51.168]     if (TRUE) {
[13:20:51.168]         base::sink(type = "output", split = FALSE)
[13:20:51.168]         if (TRUE) {
[13:20:51.168]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.168]         }
[13:20:51.168]         else {
[13:20:51.168]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.168]         }
[13:20:51.168]         base::close(...future.stdout)
[13:20:51.168]         ...future.stdout <- NULL
[13:20:51.168]     }
[13:20:51.168]     ...future.result$conditions <- ...future.conditions
[13:20:51.168]     ...future.result$finished <- base::Sys.time()
[13:20:51.168]     ...future.result
[13:20:51.168] }
[13:20:51.171] assign_globals() ...
[13:20:51.171] List of 1
[13:20:51.171]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x558de00c2c80> 
[13:20:51.171]  - attr(*, "where")=List of 1
[13:20:51.171]   ..$ a:<environment: R_EmptyEnv> 
[13:20:51.171]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:51.171]  - attr(*, "resolved")= logi TRUE
[13:20:51.171]  - attr(*, "total_size")= num 10984
[13:20:51.171]  - attr(*, "already-done")= logi TRUE
[13:20:51.174] - copied ‘a’ to environment
[13:20:51.174] assign_globals() ... done
[13:20:51.174] requestCore(): workers = 2
[13:20:51.176] MulticoreFuture started
[13:20:51.176] - Launch lazy future ... done
[13:20:51.177] run() for ‘MulticoreFuture’ ... done
[13:20:51.178] plan(): Setting new future strategy stack:
[13:20:51.178] List of future strategies:
[13:20:51.178] 1. sequential:
[13:20:51.178]    - args: function (..., envir = parent.frame())
[13:20:51.178]    - tweaked: FALSE
[13:20:51.178]    - call: NULL
[13:20:51.179] plan(): nbrOfWorkers() = 1
[13:20:51.181] plan(): Setting new future strategy stack:
[13:20:51.181] List of future strategies:
[13:20:51.181] 1. multicore:
[13:20:51.181]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.181]    - tweaked: FALSE
[13:20:51.181]    - call: plan(strategy)
[13:20:51.186] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.188] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.188] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:51.189] 
[13:20:51.189] Searching for globals ... DONE
[13:20:51.189] - globals: [0] <none>
[13:20:51.189] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.190] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.190] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:51.194] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:51.194] Searching for globals ... DONE
[13:20:51.194] Resolving globals: TRUE
[13:20:51.195] Resolving any globals that are futures ...
[13:20:51.195] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:51.195] Resolving any globals that are futures ... DONE
[13:20:51.196] Resolving futures part of globals (recursively) ...
[13:20:51.196] resolve() on list ...
[13:20:51.196]  recursive: 99
[13:20:51.196]  length: 1
[13:20:51.197]  elements: ‘a’
[13:20:51.197] run() for ‘Future’ ...
[13:20:51.197] - state: ‘created’
[13:20:51.197] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.201] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.202] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.202]   - Field: ‘label’
[13:20:51.202]   - Field: ‘local’
[13:20:51.202]   - Field: ‘owner’
[13:20:51.202]   - Field: ‘envir’
[13:20:51.202]   - Field: ‘workers’
[13:20:51.202]   - Field: ‘packages’
[13:20:51.203]   - Field: ‘gc’
[13:20:51.203]   - Field: ‘job’
[13:20:51.203]   - Field: ‘conditions’
[13:20:51.203]   - Field: ‘expr’
[13:20:51.203]   - Field: ‘uuid’
[13:20:51.203]   - Field: ‘seed’
[13:20:51.203]   - Field: ‘version’
[13:20:51.203]   - Field: ‘result’
[13:20:51.204]   - Field: ‘asynchronous’
[13:20:51.204]   - Field: ‘calls’
[13:20:51.204]   - Field: ‘globals’
[13:20:51.204]   - Field: ‘stdout’
[13:20:51.204]   - Field: ‘earlySignal’
[13:20:51.204]   - Field: ‘lazy’
[13:20:51.204]   - Field: ‘state’
[13:20:51.204] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.204] - Launch lazy future ...
[13:20:51.205] Packages needed by the future expression (n = 0): <none>
[13:20:51.205] Packages needed by future strategies (n = 0): <none>
[13:20:51.205] {
[13:20:51.205]     {
[13:20:51.205]         {
[13:20:51.205]             ...future.startTime <- base::Sys.time()
[13:20:51.205]             {
[13:20:51.205]                 {
[13:20:51.205]                   {
[13:20:51.205]                     {
[13:20:51.205]                       base::local({
[13:20:51.205]                         has_future <- base::requireNamespace("future", 
[13:20:51.205]                           quietly = TRUE)
[13:20:51.205]                         if (has_future) {
[13:20:51.205]                           ns <- base::getNamespace("future")
[13:20:51.205]                           version <- ns[[".package"]][["version"]]
[13:20:51.205]                           if (is.null(version)) 
[13:20:51.205]                             version <- utils::packageVersion("future")
[13:20:51.205]                         }
[13:20:51.205]                         else {
[13:20:51.205]                           version <- NULL
[13:20:51.205]                         }
[13:20:51.205]                         if (!has_future || version < "1.8.0") {
[13:20:51.205]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.205]                             "", base::R.version$version.string), 
[13:20:51.205]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:51.205]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:51.205]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.205]                               "release", "version")], collapse = " "), 
[13:20:51.205]                             hostname = base::Sys.info()[["nodename"]])
[13:20:51.205]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.205]                             info)
[13:20:51.205]                           info <- base::paste(info, collapse = "; ")
[13:20:51.205]                           if (!has_future) {
[13:20:51.205]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.205]                               info)
[13:20:51.205]                           }
[13:20:51.205]                           else {
[13:20:51.205]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.205]                               info, version)
[13:20:51.205]                           }
[13:20:51.205]                           base::stop(msg)
[13:20:51.205]                         }
[13:20:51.205]                       })
[13:20:51.205]                     }
[13:20:51.205]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.205]                     base::options(mc.cores = 1L)
[13:20:51.205]                   }
[13:20:51.205]                   options(future.plan = NULL)
[13:20:51.205]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.205]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.205]                 }
[13:20:51.205]                 ...future.workdir <- getwd()
[13:20:51.205]             }
[13:20:51.205]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.205]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.205]         }
[13:20:51.205]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.205]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:51.205]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.205]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.205]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.205]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.205]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.205]             base::names(...future.oldOptions))
[13:20:51.205]     }
[13:20:51.205]     if (FALSE) {
[13:20:51.205]     }
[13:20:51.205]     else {
[13:20:51.205]         if (TRUE) {
[13:20:51.205]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.205]                 open = "w")
[13:20:51.205]         }
[13:20:51.205]         else {
[13:20:51.205]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.205]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.205]         }
[13:20:51.205]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.205]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.205]             base::sink(type = "output", split = FALSE)
[13:20:51.205]             base::close(...future.stdout)
[13:20:51.205]         }, add = TRUE)
[13:20:51.205]     }
[13:20:51.205]     ...future.frame <- base::sys.nframe()
[13:20:51.205]     ...future.conditions <- base::list()
[13:20:51.205]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.205]     if (FALSE) {
[13:20:51.205]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.205]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.205]     }
[13:20:51.205]     ...future.result <- base::tryCatch({
[13:20:51.205]         base::withCallingHandlers({
[13:20:51.205]             ...future.value <- base::withVisible(base::local({
[13:20:51.205]                 withCallingHandlers({
[13:20:51.205]                   1
[13:20:51.205]                 }, immediateCondition = function(cond) {
[13:20:51.205]                   save_rds <- function (object, pathname, ...) 
[13:20:51.205]                   {
[13:20:51.205]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.205]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.205]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.205]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.205]                         fi_tmp[["mtime"]])
[13:20:51.205]                     }
[13:20:51.205]                     tryCatch({
[13:20:51.205]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.205]                     }, error = function(ex) {
[13:20:51.205]                       msg <- conditionMessage(ex)
[13:20:51.205]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.205]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.205]                         fi_tmp[["mtime"]], msg)
[13:20:51.205]                       ex$message <- msg
[13:20:51.205]                       stop(ex)
[13:20:51.205]                     })
[13:20:51.205]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.205]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.205]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.205]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.205]                       fi <- file.info(pathname)
[13:20:51.205]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.205]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.205]                         fi[["size"]], fi[["mtime"]])
[13:20:51.205]                       stop(msg)
[13:20:51.205]                     }
[13:20:51.205]                     invisible(pathname)
[13:20:51.205]                   }
[13:20:51.205]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.205]                     rootPath = tempdir()) 
[13:20:51.205]                   {
[13:20:51.205]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.205]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.205]                       tmpdir = path, fileext = ".rds")
[13:20:51.205]                     save_rds(obj, file)
[13:20:51.205]                   }
[13:20:51.205]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.205]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.205]                   {
[13:20:51.205]                     inherits <- base::inherits
[13:20:51.205]                     invokeRestart <- base::invokeRestart
[13:20:51.205]                     is.null <- base::is.null
[13:20:51.205]                     muffled <- FALSE
[13:20:51.205]                     if (inherits(cond, "message")) {
[13:20:51.205]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.205]                       if (muffled) 
[13:20:51.205]                         invokeRestart("muffleMessage")
[13:20:51.205]                     }
[13:20:51.205]                     else if (inherits(cond, "warning")) {
[13:20:51.205]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.205]                       if (muffled) 
[13:20:51.205]                         invokeRestart("muffleWarning")
[13:20:51.205]                     }
[13:20:51.205]                     else if (inherits(cond, "condition")) {
[13:20:51.205]                       if (!is.null(pattern)) {
[13:20:51.205]                         computeRestarts <- base::computeRestarts
[13:20:51.205]                         grepl <- base::grepl
[13:20:51.205]                         restarts <- computeRestarts(cond)
[13:20:51.205]                         for (restart in restarts) {
[13:20:51.205]                           name <- restart$name
[13:20:51.205]                           if (is.null(name)) 
[13:20:51.205]                             next
[13:20:51.205]                           if (!grepl(pattern, name)) 
[13:20:51.205]                             next
[13:20:51.205]                           invokeRestart(restart)
[13:20:51.205]                           muffled <- TRUE
[13:20:51.205]                           break
[13:20:51.205]                         }
[13:20:51.205]                       }
[13:20:51.205]                     }
[13:20:51.205]                     invisible(muffled)
[13:20:51.205]                   }
[13:20:51.205]                   muffleCondition(cond)
[13:20:51.205]                 })
[13:20:51.205]             }))
[13:20:51.205]             future::FutureResult(value = ...future.value$value, 
[13:20:51.205]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.205]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.205]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.205]                     ...future.globalenv.names))
[13:20:51.205]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.205]         }, condition = base::local({
[13:20:51.205]             c <- base::c
[13:20:51.205]             inherits <- base::inherits
[13:20:51.205]             invokeRestart <- base::invokeRestart
[13:20:51.205]             length <- base::length
[13:20:51.205]             list <- base::list
[13:20:51.205]             seq.int <- base::seq.int
[13:20:51.205]             signalCondition <- base::signalCondition
[13:20:51.205]             sys.calls <- base::sys.calls
[13:20:51.205]             `[[` <- base::`[[`
[13:20:51.205]             `+` <- base::`+`
[13:20:51.205]             `<<-` <- base::`<<-`
[13:20:51.205]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.205]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.205]                   3L)]
[13:20:51.205]             }
[13:20:51.205]             function(cond) {
[13:20:51.205]                 is_error <- inherits(cond, "error")
[13:20:51.205]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.205]                   NULL)
[13:20:51.205]                 if (is_error) {
[13:20:51.205]                   sessionInformation <- function() {
[13:20:51.205]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.205]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.205]                       search = base::search(), system = base::Sys.info())
[13:20:51.205]                   }
[13:20:51.205]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.205]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.205]                     cond$call), session = sessionInformation(), 
[13:20:51.205]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.205]                   signalCondition(cond)
[13:20:51.205]                 }
[13:20:51.205]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.205]                 "immediateCondition"))) {
[13:20:51.205]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.205]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.205]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.205]                   if (TRUE && !signal) {
[13:20:51.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.205]                     {
[13:20:51.205]                       inherits <- base::inherits
[13:20:51.205]                       invokeRestart <- base::invokeRestart
[13:20:51.205]                       is.null <- base::is.null
[13:20:51.205]                       muffled <- FALSE
[13:20:51.205]                       if (inherits(cond, "message")) {
[13:20:51.205]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.205]                         if (muffled) 
[13:20:51.205]                           invokeRestart("muffleMessage")
[13:20:51.205]                       }
[13:20:51.205]                       else if (inherits(cond, "warning")) {
[13:20:51.205]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.205]                         if (muffled) 
[13:20:51.205]                           invokeRestart("muffleWarning")
[13:20:51.205]                       }
[13:20:51.205]                       else if (inherits(cond, "condition")) {
[13:20:51.205]                         if (!is.null(pattern)) {
[13:20:51.205]                           computeRestarts <- base::computeRestarts
[13:20:51.205]                           grepl <- base::grepl
[13:20:51.205]                           restarts <- computeRestarts(cond)
[13:20:51.205]                           for (restart in restarts) {
[13:20:51.205]                             name <- restart$name
[13:20:51.205]                             if (is.null(name)) 
[13:20:51.205]                               next
[13:20:51.205]                             if (!grepl(pattern, name)) 
[13:20:51.205]                               next
[13:20:51.205]                             invokeRestart(restart)
[13:20:51.205]                             muffled <- TRUE
[13:20:51.205]                             break
[13:20:51.205]                           }
[13:20:51.205]                         }
[13:20:51.205]                       }
[13:20:51.205]                       invisible(muffled)
[13:20:51.205]                     }
[13:20:51.205]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.205]                   }
[13:20:51.205]                 }
[13:20:51.205]                 else {
[13:20:51.205]                   if (TRUE) {
[13:20:51.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.205]                     {
[13:20:51.205]                       inherits <- base::inherits
[13:20:51.205]                       invokeRestart <- base::invokeRestart
[13:20:51.205]                       is.null <- base::is.null
[13:20:51.205]                       muffled <- FALSE
[13:20:51.205]                       if (inherits(cond, "message")) {
[13:20:51.205]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.205]                         if (muffled) 
[13:20:51.205]                           invokeRestart("muffleMessage")
[13:20:51.205]                       }
[13:20:51.205]                       else if (inherits(cond, "warning")) {
[13:20:51.205]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.205]                         if (muffled) 
[13:20:51.205]                           invokeRestart("muffleWarning")
[13:20:51.205]                       }
[13:20:51.205]                       else if (inherits(cond, "condition")) {
[13:20:51.205]                         if (!is.null(pattern)) {
[13:20:51.205]                           computeRestarts <- base::computeRestarts
[13:20:51.205]                           grepl <- base::grepl
[13:20:51.205]                           restarts <- computeRestarts(cond)
[13:20:51.205]                           for (restart in restarts) {
[13:20:51.205]                             name <- restart$name
[13:20:51.205]                             if (is.null(name)) 
[13:20:51.205]                               next
[13:20:51.205]                             if (!grepl(pattern, name)) 
[13:20:51.205]                               next
[13:20:51.205]                             invokeRestart(restart)
[13:20:51.205]                             muffled <- TRUE
[13:20:51.205]                             break
[13:20:51.205]                           }
[13:20:51.205]                         }
[13:20:51.205]                       }
[13:20:51.205]                       invisible(muffled)
[13:20:51.205]                     }
[13:20:51.205]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.205]                   }
[13:20:51.205]                 }
[13:20:51.205]             }
[13:20:51.205]         }))
[13:20:51.205]     }, error = function(ex) {
[13:20:51.205]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.205]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.205]                 ...future.rng), started = ...future.startTime, 
[13:20:51.205]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.205]             version = "1.8"), class = "FutureResult")
[13:20:51.205]     }, finally = {
[13:20:51.205]         if (!identical(...future.workdir, getwd())) 
[13:20:51.205]             setwd(...future.workdir)
[13:20:51.205]         {
[13:20:51.205]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.205]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.205]             }
[13:20:51.205]             base::options(...future.oldOptions)
[13:20:51.205]             if (.Platform$OS.type == "windows") {
[13:20:51.205]                 old_names <- names(...future.oldEnvVars)
[13:20:51.205]                 envs <- base::Sys.getenv()
[13:20:51.205]                 names <- names(envs)
[13:20:51.205]                 common <- intersect(names, old_names)
[13:20:51.205]                 added <- setdiff(names, old_names)
[13:20:51.205]                 removed <- setdiff(old_names, names)
[13:20:51.205]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.205]                   envs[common]]
[13:20:51.205]                 NAMES <- toupper(changed)
[13:20:51.205]                 args <- list()
[13:20:51.205]                 for (kk in seq_along(NAMES)) {
[13:20:51.205]                   name <- changed[[kk]]
[13:20:51.205]                   NAME <- NAMES[[kk]]
[13:20:51.205]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.205]                     next
[13:20:51.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.205]                 }
[13:20:51.205]                 NAMES <- toupper(added)
[13:20:51.205]                 for (kk in seq_along(NAMES)) {
[13:20:51.205]                   name <- added[[kk]]
[13:20:51.205]                   NAME <- NAMES[[kk]]
[13:20:51.205]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.205]                     next
[13:20:51.205]                   args[[name]] <- ""
[13:20:51.205]                 }
[13:20:51.205]                 NAMES <- toupper(removed)
[13:20:51.205]                 for (kk in seq_along(NAMES)) {
[13:20:51.205]                   name <- removed[[kk]]
[13:20:51.205]                   NAME <- NAMES[[kk]]
[13:20:51.205]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.205]                     next
[13:20:51.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.205]                 }
[13:20:51.205]                 if (length(args) > 0) 
[13:20:51.205]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.205]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.205]             }
[13:20:51.205]             else {
[13:20:51.205]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.205]             }
[13:20:51.205]             {
[13:20:51.205]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.205]                   0L) {
[13:20:51.205]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.205]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.205]                   base::options(opts)
[13:20:51.205]                 }
[13:20:51.205]                 {
[13:20:51.205]                   {
[13:20:51.205]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.205]                     NULL
[13:20:51.205]                   }
[13:20:51.205]                   options(future.plan = NULL)
[13:20:51.205]                   if (is.na(NA_character_)) 
[13:20:51.205]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.205]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.205]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.205]                     envir = parent.frame()) 
[13:20:51.205]                   {
[13:20:51.205]                     default_workers <- missing(workers)
[13:20:51.205]                     if (is.function(workers)) 
[13:20:51.205]                       workers <- workers()
[13:20:51.205]                     workers <- structure(as.integer(workers), 
[13:20:51.205]                       class = class(workers))
[13:20:51.205]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.205]                       1L)
[13:20:51.205]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.205]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.205]                       if (default_workers) 
[13:20:51.205]                         supportsMulticore(warn = TRUE)
[13:20:51.205]                       return(sequential(..., envir = envir))
[13:20:51.205]                     }
[13:20:51.205]                     oopts <- options(mc.cores = workers)
[13:20:51.205]                     on.exit(options(oopts))
[13:20:51.205]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.205]                       envir = envir)
[13:20:51.205]                     if (!future$lazy) 
[13:20:51.205]                       future <- run(future)
[13:20:51.205]                     invisible(future)
[13:20:51.205]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.205]                 }
[13:20:51.205]             }
[13:20:51.205]         }
[13:20:51.205]     })
[13:20:51.205]     if (TRUE) {
[13:20:51.205]         base::sink(type = "output", split = FALSE)
[13:20:51.205]         if (TRUE) {
[13:20:51.205]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.205]         }
[13:20:51.205]         else {
[13:20:51.205]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.205]         }
[13:20:51.205]         base::close(...future.stdout)
[13:20:51.205]         ...future.stdout <- NULL
[13:20:51.205]     }
[13:20:51.205]     ...future.result$conditions <- ...future.conditions
[13:20:51.205]     ...future.result$finished <- base::Sys.time()
[13:20:51.205]     ...future.result
[13:20:51.205] }
[13:20:51.208] requestCore(): workers = 2
[13:20:51.210] MulticoreFuture started
[13:20:51.210] - Launch lazy future ... done
[13:20:51.210] run() for ‘MulticoreFuture’ ... done
[13:20:51.211] plan(): Setting new future strategy stack:
[13:20:51.211] List of future strategies:
[13:20:51.211] 1. sequential:
[13:20:51.211]    - args: function (..., envir = parent.frame())
[13:20:51.211]    - tweaked: FALSE
[13:20:51.211]    - call: NULL
[13:20:51.212] plan(): nbrOfWorkers() = 1
[13:20:51.214] plan(): Setting new future strategy stack:
[13:20:51.214] List of future strategies:
[13:20:51.214] 1. multicore:
[13:20:51.214]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.214]    - tweaked: FALSE
[13:20:51.214]    - call: plan(strategy)
[13:20:51.219] plan(): nbrOfWorkers() = 2
[13:20:51.219] Future #1
[13:20:51.221] A MulticoreFuture was resolved
[13:20:51.221]  length: 0 (resolved future 1)
[13:20:51.221] resolve() on list ... DONE
[13:20:51.221] - globals: [1] ‘a’
[13:20:51.221] Resolving futures part of globals (recursively) ... DONE
[13:20:51.223] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[13:20:51.223] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[13:20:51.223] - globals: [1] ‘a’
[13:20:51.223] - packages: [1] ‘future’
[13:20:51.223] getGlobalsAndPackages() ... DONE
[13:20:51.224] run() for ‘Future’ ...
[13:20:51.224] - state: ‘created’
[13:20:51.224] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.228] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.228] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.229]   - Field: ‘label’
[13:20:51.229]   - Field: ‘local’
[13:20:51.229]   - Field: ‘owner’
[13:20:51.229]   - Field: ‘envir’
[13:20:51.229]   - Field: ‘workers’
[13:20:51.229]   - Field: ‘packages’
[13:20:51.229]   - Field: ‘gc’
[13:20:51.229]   - Field: ‘job’
[13:20:51.230]   - Field: ‘conditions’
[13:20:51.230]   - Field: ‘expr’
[13:20:51.230]   - Field: ‘uuid’
[13:20:51.230]   - Field: ‘seed’
[13:20:51.230]   - Field: ‘version’
[13:20:51.230]   - Field: ‘result’
[13:20:51.230]   - Field: ‘asynchronous’
[13:20:51.230]   - Field: ‘calls’
[13:20:51.230]   - Field: ‘globals’
[13:20:51.231]   - Field: ‘stdout’
[13:20:51.231]   - Field: ‘earlySignal’
[13:20:51.231]   - Field: ‘lazy’
[13:20:51.231]   - Field: ‘state’
[13:20:51.231] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.231] - Launch lazy future ...
[13:20:51.231] Packages needed by the future expression (n = 1): ‘future’
[13:20:51.232] Packages needed by future strategies (n = 0): <none>
[13:20:51.232] {
[13:20:51.232]     {
[13:20:51.232]         {
[13:20:51.232]             ...future.startTime <- base::Sys.time()
[13:20:51.232]             {
[13:20:51.232]                 {
[13:20:51.232]                   {
[13:20:51.232]                     {
[13:20:51.232]                       {
[13:20:51.232]                         base::local({
[13:20:51.232]                           has_future <- base::requireNamespace("future", 
[13:20:51.232]                             quietly = TRUE)
[13:20:51.232]                           if (has_future) {
[13:20:51.232]                             ns <- base::getNamespace("future")
[13:20:51.232]                             version <- ns[[".package"]][["version"]]
[13:20:51.232]                             if (is.null(version)) 
[13:20:51.232]                               version <- utils::packageVersion("future")
[13:20:51.232]                           }
[13:20:51.232]                           else {
[13:20:51.232]                             version <- NULL
[13:20:51.232]                           }
[13:20:51.232]                           if (!has_future || version < "1.8.0") {
[13:20:51.232]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.232]                               "", base::R.version$version.string), 
[13:20:51.232]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:51.232]                                 base::R.version$platform, 8 * 
[13:20:51.232]                                   base::.Machine$sizeof.pointer), 
[13:20:51.232]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.232]                                 "release", "version")], collapse = " "), 
[13:20:51.232]                               hostname = base::Sys.info()[["nodename"]])
[13:20:51.232]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.232]                               info)
[13:20:51.232]                             info <- base::paste(info, collapse = "; ")
[13:20:51.232]                             if (!has_future) {
[13:20:51.232]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.232]                                 info)
[13:20:51.232]                             }
[13:20:51.232]                             else {
[13:20:51.232]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.232]                                 info, version)
[13:20:51.232]                             }
[13:20:51.232]                             base::stop(msg)
[13:20:51.232]                           }
[13:20:51.232]                         })
[13:20:51.232]                       }
[13:20:51.232]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.232]                       base::options(mc.cores = 1L)
[13:20:51.232]                     }
[13:20:51.232]                     base::local({
[13:20:51.232]                       for (pkg in "future") {
[13:20:51.232]                         base::loadNamespace(pkg)
[13:20:51.232]                         base::library(pkg, character.only = TRUE)
[13:20:51.232]                       }
[13:20:51.232]                     })
[13:20:51.232]                   }
[13:20:51.232]                   options(future.plan = NULL)
[13:20:51.232]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.232]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.232]                 }
[13:20:51.232]                 ...future.workdir <- getwd()
[13:20:51.232]             }
[13:20:51.232]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.232]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.232]         }
[13:20:51.232]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.232]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:51.232]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.232]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.232]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.232]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.232]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.232]             base::names(...future.oldOptions))
[13:20:51.232]     }
[13:20:51.232]     if (FALSE) {
[13:20:51.232]     }
[13:20:51.232]     else {
[13:20:51.232]         if (TRUE) {
[13:20:51.232]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.232]                 open = "w")
[13:20:51.232]         }
[13:20:51.232]         else {
[13:20:51.232]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.232]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.232]         }
[13:20:51.232]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.232]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.232]             base::sink(type = "output", split = FALSE)
[13:20:51.232]             base::close(...future.stdout)
[13:20:51.232]         }, add = TRUE)
[13:20:51.232]     }
[13:20:51.232]     ...future.frame <- base::sys.nframe()
[13:20:51.232]     ...future.conditions <- base::list()
[13:20:51.232]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.232]     if (FALSE) {
[13:20:51.232]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.232]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.232]     }
[13:20:51.232]     ...future.result <- base::tryCatch({
[13:20:51.232]         base::withCallingHandlers({
[13:20:51.232]             ...future.value <- base::withVisible(base::local({
[13:20:51.232]                 withCallingHandlers({
[13:20:51.232]                   value(a) + 1
[13:20:51.232]                 }, immediateCondition = function(cond) {
[13:20:51.232]                   save_rds <- function (object, pathname, ...) 
[13:20:51.232]                   {
[13:20:51.232]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.232]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.232]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.232]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.232]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.232]                         fi_tmp[["mtime"]])
[13:20:51.232]                     }
[13:20:51.232]                     tryCatch({
[13:20:51.232]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.232]                     }, error = function(ex) {
[13:20:51.232]                       msg <- conditionMessage(ex)
[13:20:51.232]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.232]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.232]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.232]                         fi_tmp[["mtime"]], msg)
[13:20:51.232]                       ex$message <- msg
[13:20:51.232]                       stop(ex)
[13:20:51.232]                     })
[13:20:51.232]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.232]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.232]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.232]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.232]                       fi <- file.info(pathname)
[13:20:51.232]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.232]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.232]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.232]                         fi[["size"]], fi[["mtime"]])
[13:20:51.232]                       stop(msg)
[13:20:51.232]                     }
[13:20:51.232]                     invisible(pathname)
[13:20:51.232]                   }
[13:20:51.232]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.232]                     rootPath = tempdir()) 
[13:20:51.232]                   {
[13:20:51.232]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.232]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.232]                       tmpdir = path, fileext = ".rds")
[13:20:51.232]                     save_rds(obj, file)
[13:20:51.232]                   }
[13:20:51.232]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.232]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.232]                   {
[13:20:51.232]                     inherits <- base::inherits
[13:20:51.232]                     invokeRestart <- base::invokeRestart
[13:20:51.232]                     is.null <- base::is.null
[13:20:51.232]                     muffled <- FALSE
[13:20:51.232]                     if (inherits(cond, "message")) {
[13:20:51.232]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.232]                       if (muffled) 
[13:20:51.232]                         invokeRestart("muffleMessage")
[13:20:51.232]                     }
[13:20:51.232]                     else if (inherits(cond, "warning")) {
[13:20:51.232]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.232]                       if (muffled) 
[13:20:51.232]                         invokeRestart("muffleWarning")
[13:20:51.232]                     }
[13:20:51.232]                     else if (inherits(cond, "condition")) {
[13:20:51.232]                       if (!is.null(pattern)) {
[13:20:51.232]                         computeRestarts <- base::computeRestarts
[13:20:51.232]                         grepl <- base::grepl
[13:20:51.232]                         restarts <- computeRestarts(cond)
[13:20:51.232]                         for (restart in restarts) {
[13:20:51.232]                           name <- restart$name
[13:20:51.232]                           if (is.null(name)) 
[13:20:51.232]                             next
[13:20:51.232]                           if (!grepl(pattern, name)) 
[13:20:51.232]                             next
[13:20:51.232]                           invokeRestart(restart)
[13:20:51.232]                           muffled <- TRUE
[13:20:51.232]                           break
[13:20:51.232]                         }
[13:20:51.232]                       }
[13:20:51.232]                     }
[13:20:51.232]                     invisible(muffled)
[13:20:51.232]                   }
[13:20:51.232]                   muffleCondition(cond)
[13:20:51.232]                 })
[13:20:51.232]             }))
[13:20:51.232]             future::FutureResult(value = ...future.value$value, 
[13:20:51.232]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.232]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.232]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.232]                     ...future.globalenv.names))
[13:20:51.232]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.232]         }, condition = base::local({
[13:20:51.232]             c <- base::c
[13:20:51.232]             inherits <- base::inherits
[13:20:51.232]             invokeRestart <- base::invokeRestart
[13:20:51.232]             length <- base::length
[13:20:51.232]             list <- base::list
[13:20:51.232]             seq.int <- base::seq.int
[13:20:51.232]             signalCondition <- base::signalCondition
[13:20:51.232]             sys.calls <- base::sys.calls
[13:20:51.232]             `[[` <- base::`[[`
[13:20:51.232]             `+` <- base::`+`
[13:20:51.232]             `<<-` <- base::`<<-`
[13:20:51.232]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.232]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.232]                   3L)]
[13:20:51.232]             }
[13:20:51.232]             function(cond) {
[13:20:51.232]                 is_error <- inherits(cond, "error")
[13:20:51.232]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.232]                   NULL)
[13:20:51.232]                 if (is_error) {
[13:20:51.232]                   sessionInformation <- function() {
[13:20:51.232]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.232]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.232]                       search = base::search(), system = base::Sys.info())
[13:20:51.232]                   }
[13:20:51.232]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.232]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.232]                     cond$call), session = sessionInformation(), 
[13:20:51.232]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.232]                   signalCondition(cond)
[13:20:51.232]                 }
[13:20:51.232]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.232]                 "immediateCondition"))) {
[13:20:51.232]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.232]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.232]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.232]                   if (TRUE && !signal) {
[13:20:51.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.232]                     {
[13:20:51.232]                       inherits <- base::inherits
[13:20:51.232]                       invokeRestart <- base::invokeRestart
[13:20:51.232]                       is.null <- base::is.null
[13:20:51.232]                       muffled <- FALSE
[13:20:51.232]                       if (inherits(cond, "message")) {
[13:20:51.232]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.232]                         if (muffled) 
[13:20:51.232]                           invokeRestart("muffleMessage")
[13:20:51.232]                       }
[13:20:51.232]                       else if (inherits(cond, "warning")) {
[13:20:51.232]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.232]                         if (muffled) 
[13:20:51.232]                           invokeRestart("muffleWarning")
[13:20:51.232]                       }
[13:20:51.232]                       else if (inherits(cond, "condition")) {
[13:20:51.232]                         if (!is.null(pattern)) {
[13:20:51.232]                           computeRestarts <- base::computeRestarts
[13:20:51.232]                           grepl <- base::grepl
[13:20:51.232]                           restarts <- computeRestarts(cond)
[13:20:51.232]                           for (restart in restarts) {
[13:20:51.232]                             name <- restart$name
[13:20:51.232]                             if (is.null(name)) 
[13:20:51.232]                               next
[13:20:51.232]                             if (!grepl(pattern, name)) 
[13:20:51.232]                               next
[13:20:51.232]                             invokeRestart(restart)
[13:20:51.232]                             muffled <- TRUE
[13:20:51.232]                             break
[13:20:51.232]                           }
[13:20:51.232]                         }
[13:20:51.232]                       }
[13:20:51.232]                       invisible(muffled)
[13:20:51.232]                     }
[13:20:51.232]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.232]                   }
[13:20:51.232]                 }
[13:20:51.232]                 else {
[13:20:51.232]                   if (TRUE) {
[13:20:51.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.232]                     {
[13:20:51.232]                       inherits <- base::inherits
[13:20:51.232]                       invokeRestart <- base::invokeRestart
[13:20:51.232]                       is.null <- base::is.null
[13:20:51.232]                       muffled <- FALSE
[13:20:51.232]                       if (inherits(cond, "message")) {
[13:20:51.232]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.232]                         if (muffled) 
[13:20:51.232]                           invokeRestart("muffleMessage")
[13:20:51.232]                       }
[13:20:51.232]                       else if (inherits(cond, "warning")) {
[13:20:51.232]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.232]                         if (muffled) 
[13:20:51.232]                           invokeRestart("muffleWarning")
[13:20:51.232]                       }
[13:20:51.232]                       else if (inherits(cond, "condition")) {
[13:20:51.232]                         if (!is.null(pattern)) {
[13:20:51.232]                           computeRestarts <- base::computeRestarts
[13:20:51.232]                           grepl <- base::grepl
[13:20:51.232]                           restarts <- computeRestarts(cond)
[13:20:51.232]                           for (restart in restarts) {
[13:20:51.232]                             name <- restart$name
[13:20:51.232]                             if (is.null(name)) 
[13:20:51.232]                               next
[13:20:51.232]                             if (!grepl(pattern, name)) 
[13:20:51.232]                               next
[13:20:51.232]                             invokeRestart(restart)
[13:20:51.232]                             muffled <- TRUE
[13:20:51.232]                             break
[13:20:51.232]                           }
[13:20:51.232]                         }
[13:20:51.232]                       }
[13:20:51.232]                       invisible(muffled)
[13:20:51.232]                     }
[13:20:51.232]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.232]                   }
[13:20:51.232]                 }
[13:20:51.232]             }
[13:20:51.232]         }))
[13:20:51.232]     }, error = function(ex) {
[13:20:51.232]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.232]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.232]                 ...future.rng), started = ...future.startTime, 
[13:20:51.232]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.232]             version = "1.8"), class = "FutureResult")
[13:20:51.232]     }, finally = {
[13:20:51.232]         if (!identical(...future.workdir, getwd())) 
[13:20:51.232]             setwd(...future.workdir)
[13:20:51.232]         {
[13:20:51.232]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.232]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.232]             }
[13:20:51.232]             base::options(...future.oldOptions)
[13:20:51.232]             if (.Platform$OS.type == "windows") {
[13:20:51.232]                 old_names <- names(...future.oldEnvVars)
[13:20:51.232]                 envs <- base::Sys.getenv()
[13:20:51.232]                 names <- names(envs)
[13:20:51.232]                 common <- intersect(names, old_names)
[13:20:51.232]                 added <- setdiff(names, old_names)
[13:20:51.232]                 removed <- setdiff(old_names, names)
[13:20:51.232]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.232]                   envs[common]]
[13:20:51.232]                 NAMES <- toupper(changed)
[13:20:51.232]                 args <- list()
[13:20:51.232]                 for (kk in seq_along(NAMES)) {
[13:20:51.232]                   name <- changed[[kk]]
[13:20:51.232]                   NAME <- NAMES[[kk]]
[13:20:51.232]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.232]                     next
[13:20:51.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.232]                 }
[13:20:51.232]                 NAMES <- toupper(added)
[13:20:51.232]                 for (kk in seq_along(NAMES)) {
[13:20:51.232]                   name <- added[[kk]]
[13:20:51.232]                   NAME <- NAMES[[kk]]
[13:20:51.232]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.232]                     next
[13:20:51.232]                   args[[name]] <- ""
[13:20:51.232]                 }
[13:20:51.232]                 NAMES <- toupper(removed)
[13:20:51.232]                 for (kk in seq_along(NAMES)) {
[13:20:51.232]                   name <- removed[[kk]]
[13:20:51.232]                   NAME <- NAMES[[kk]]
[13:20:51.232]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.232]                     next
[13:20:51.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.232]                 }
[13:20:51.232]                 if (length(args) > 0) 
[13:20:51.232]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.232]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.232]             }
[13:20:51.232]             else {
[13:20:51.232]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.232]             }
[13:20:51.232]             {
[13:20:51.232]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.232]                   0L) {
[13:20:51.232]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.232]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.232]                   base::options(opts)
[13:20:51.232]                 }
[13:20:51.232]                 {
[13:20:51.232]                   {
[13:20:51.232]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.232]                     NULL
[13:20:51.232]                   }
[13:20:51.232]                   options(future.plan = NULL)
[13:20:51.232]                   if (is.na(NA_character_)) 
[13:20:51.232]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.232]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.232]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.232]                     envir = parent.frame()) 
[13:20:51.232]                   {
[13:20:51.232]                     default_workers <- missing(workers)
[13:20:51.232]                     if (is.function(workers)) 
[13:20:51.232]                       workers <- workers()
[13:20:51.232]                     workers <- structure(as.integer(workers), 
[13:20:51.232]                       class = class(workers))
[13:20:51.232]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.232]                       1L)
[13:20:51.232]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.232]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.232]                       if (default_workers) 
[13:20:51.232]                         supportsMulticore(warn = TRUE)
[13:20:51.232]                       return(sequential(..., envir = envir))
[13:20:51.232]                     }
[13:20:51.232]                     oopts <- options(mc.cores = workers)
[13:20:51.232]                     on.exit(options(oopts))
[13:20:51.232]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.232]                       envir = envir)
[13:20:51.232]                     if (!future$lazy) 
[13:20:51.232]                       future <- run(future)
[13:20:51.232]                     invisible(future)
[13:20:51.232]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.232]                 }
[13:20:51.232]             }
[13:20:51.232]         }
[13:20:51.232]     })
[13:20:51.232]     if (TRUE) {
[13:20:51.232]         base::sink(type = "output", split = FALSE)
[13:20:51.232]         if (TRUE) {
[13:20:51.232]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.232]         }
[13:20:51.232]         else {
[13:20:51.232]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.232]         }
[13:20:51.232]         base::close(...future.stdout)
[13:20:51.232]         ...future.stdout <- NULL
[13:20:51.232]     }
[13:20:51.232]     ...future.result$conditions <- ...future.conditions
[13:20:51.232]     ...future.result$finished <- base::Sys.time()
[13:20:51.232]     ...future.result
[13:20:51.232] }
[13:20:51.235] assign_globals() ...
[13:20:51.235] List of 1
[13:20:51.235]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x558de04a1b78> 
[13:20:51.235]  - attr(*, "where")=List of 1
[13:20:51.235]   ..$ a:<environment: R_EmptyEnv> 
[13:20:51.235]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:51.235]  - attr(*, "resolved")= logi TRUE
[13:20:51.235]  - attr(*, "total_size")= num 10984
[13:20:51.235]  - attr(*, "already-done")= logi TRUE
[13:20:51.241] - copied ‘a’ to environment
[13:20:51.241] assign_globals() ... done
[13:20:51.241] requestCore(): workers = 2
[13:20:51.243] MulticoreFuture started
[13:20:51.244] - Launch lazy future ... done
[13:20:51.244] run() for ‘MulticoreFuture’ ... done
[13:20:51.245] plan(): Setting new future strategy stack:
[13:20:51.246] List of future strategies:
[13:20:51.246] 1. sequential:
[13:20:51.246]    - args: function (..., envir = parent.frame())
[13:20:51.246]    - tweaked: FALSE
[13:20:51.246]    - call: NULL
[13:20:51.247] plan(): nbrOfWorkers() = 1
[13:20:51.250] plan(): Setting new future strategy stack:
[13:20:51.250] List of future strategies:
[13:20:51.250] 1. multicore:
[13:20:51.250]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.250]    - tweaked: FALSE
[13:20:51.250]    - call: plan(strategy)
[13:20:51.256] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.258] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.258] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:51.260] - globals found: [2] ‘{’, ‘pkg’
[13:20:51.260] Searching for globals ... DONE
[13:20:51.260] Resolving globals: TRUE
[13:20:51.260] Resolving any globals that are futures ...
[13:20:51.260] - globals: [2] ‘{’, ‘pkg’
[13:20:51.261] Resolving any globals that are futures ... DONE
[13:20:51.261] Resolving futures part of globals (recursively) ...
[13:20:51.261] resolve() on list ...
[13:20:51.262]  recursive: 99
[13:20:51.262]  length: 1
[13:20:51.262]  elements: ‘pkg’
[13:20:51.262]  length: 0 (resolved future 1)
[13:20:51.262] resolve() on list ... DONE
[13:20:51.262] - globals: [1] ‘pkg’
[13:20:51.262] Resolving futures part of globals (recursively) ... DONE
[13:20:51.263] The total size of the 1 globals is 112 bytes (112 bytes)
[13:20:51.263] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[13:20:51.263] - globals: [1] ‘pkg’
[13:20:51.263] 
[13:20:51.263] getGlobalsAndPackages() ... DONE
[13:20:51.264] Packages needed by the future expression (n = 0): <none>
[13:20:51.264] Packages needed by future strategies (n = 0): <none>
[13:20:51.265] {
[13:20:51.265]     {
[13:20:51.265]         {
[13:20:51.265]             ...future.startTime <- base::Sys.time()
[13:20:51.265]             {
[13:20:51.265]                 {
[13:20:51.265]                   {
[13:20:51.265]                     base::local({
[13:20:51.265]                       has_future <- base::requireNamespace("future", 
[13:20:51.265]                         quietly = TRUE)
[13:20:51.265]                       if (has_future) {
[13:20:51.265]                         ns <- base::getNamespace("future")
[13:20:51.265]                         version <- ns[[".package"]][["version"]]
[13:20:51.265]                         if (is.null(version)) 
[13:20:51.265]                           version <- utils::packageVersion("future")
[13:20:51.265]                       }
[13:20:51.265]                       else {
[13:20:51.265]                         version <- NULL
[13:20:51.265]                       }
[13:20:51.265]                       if (!has_future || version < "1.8.0") {
[13:20:51.265]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.265]                           "", base::R.version$version.string), 
[13:20:51.265]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:51.265]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:51.265]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.265]                             "release", "version")], collapse = " "), 
[13:20:51.265]                           hostname = base::Sys.info()[["nodename"]])
[13:20:51.265]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.265]                           info)
[13:20:51.265]                         info <- base::paste(info, collapse = "; ")
[13:20:51.265]                         if (!has_future) {
[13:20:51.265]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.265]                             info)
[13:20:51.265]                         }
[13:20:51.265]                         else {
[13:20:51.265]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.265]                             info, version)
[13:20:51.265]                         }
[13:20:51.265]                         base::stop(msg)
[13:20:51.265]                       }
[13:20:51.265]                     })
[13:20:51.265]                   }
[13:20:51.265]                   options(future.plan = NULL)
[13:20:51.265]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.265]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.265]                 }
[13:20:51.265]                 ...future.workdir <- getwd()
[13:20:51.265]             }
[13:20:51.265]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.265]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.265]         }
[13:20:51.265]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.265]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:51.265]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.265]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.265]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.265]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.265]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.265]             base::names(...future.oldOptions))
[13:20:51.265]     }
[13:20:51.265]     if (FALSE) {
[13:20:51.265]     }
[13:20:51.265]     else {
[13:20:51.265]         if (TRUE) {
[13:20:51.265]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.265]                 open = "w")
[13:20:51.265]         }
[13:20:51.265]         else {
[13:20:51.265]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.265]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.265]         }
[13:20:51.265]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.265]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.265]             base::sink(type = "output", split = FALSE)
[13:20:51.265]             base::close(...future.stdout)
[13:20:51.265]         }, add = TRUE)
[13:20:51.265]     }
[13:20:51.265]     ...future.frame <- base::sys.nframe()
[13:20:51.265]     ...future.conditions <- base::list()
[13:20:51.265]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.265]     if (FALSE) {
[13:20:51.265]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.265]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.265]     }
[13:20:51.265]     ...future.result <- base::tryCatch({
[13:20:51.265]         base::withCallingHandlers({
[13:20:51.265]             ...future.value <- base::withVisible(base::local({
[13:20:51.265]                 pkg
[13:20:51.265]             }))
[13:20:51.265]             future::FutureResult(value = ...future.value$value, 
[13:20:51.265]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.265]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.265]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.265]                     ...future.globalenv.names))
[13:20:51.265]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.265]         }, condition = base::local({
[13:20:51.265]             c <- base::c
[13:20:51.265]             inherits <- base::inherits
[13:20:51.265]             invokeRestart <- base::invokeRestart
[13:20:51.265]             length <- base::length
[13:20:51.265]             list <- base::list
[13:20:51.265]             seq.int <- base::seq.int
[13:20:51.265]             signalCondition <- base::signalCondition
[13:20:51.265]             sys.calls <- base::sys.calls
[13:20:51.265]             `[[` <- base::`[[`
[13:20:51.265]             `+` <- base::`+`
[13:20:51.265]             `<<-` <- base::`<<-`
[13:20:51.265]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.265]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.265]                   3L)]
[13:20:51.265]             }
[13:20:51.265]             function(cond) {
[13:20:51.265]                 is_error <- inherits(cond, "error")
[13:20:51.265]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.265]                   NULL)
[13:20:51.265]                 if (is_error) {
[13:20:51.265]                   sessionInformation <- function() {
[13:20:51.265]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.265]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.265]                       search = base::search(), system = base::Sys.info())
[13:20:51.265]                   }
[13:20:51.265]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.265]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.265]                     cond$call), session = sessionInformation(), 
[13:20:51.265]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.265]                   signalCondition(cond)
[13:20:51.265]                 }
[13:20:51.265]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.265]                 "immediateCondition"))) {
[13:20:51.265]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.265]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.265]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.265]                   if (TRUE && !signal) {
[13:20:51.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.265]                     {
[13:20:51.265]                       inherits <- base::inherits
[13:20:51.265]                       invokeRestart <- base::invokeRestart
[13:20:51.265]                       is.null <- base::is.null
[13:20:51.265]                       muffled <- FALSE
[13:20:51.265]                       if (inherits(cond, "message")) {
[13:20:51.265]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.265]                         if (muffled) 
[13:20:51.265]                           invokeRestart("muffleMessage")
[13:20:51.265]                       }
[13:20:51.265]                       else if (inherits(cond, "warning")) {
[13:20:51.265]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.265]                         if (muffled) 
[13:20:51.265]                           invokeRestart("muffleWarning")
[13:20:51.265]                       }
[13:20:51.265]                       else if (inherits(cond, "condition")) {
[13:20:51.265]                         if (!is.null(pattern)) {
[13:20:51.265]                           computeRestarts <- base::computeRestarts
[13:20:51.265]                           grepl <- base::grepl
[13:20:51.265]                           restarts <- computeRestarts(cond)
[13:20:51.265]                           for (restart in restarts) {
[13:20:51.265]                             name <- restart$name
[13:20:51.265]                             if (is.null(name)) 
[13:20:51.265]                               next
[13:20:51.265]                             if (!grepl(pattern, name)) 
[13:20:51.265]                               next
[13:20:51.265]                             invokeRestart(restart)
[13:20:51.265]                             muffled <- TRUE
[13:20:51.265]                             break
[13:20:51.265]                           }
[13:20:51.265]                         }
[13:20:51.265]                       }
[13:20:51.265]                       invisible(muffled)
[13:20:51.265]                     }
[13:20:51.265]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.265]                   }
[13:20:51.265]                 }
[13:20:51.265]                 else {
[13:20:51.265]                   if (TRUE) {
[13:20:51.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.265]                     {
[13:20:51.265]                       inherits <- base::inherits
[13:20:51.265]                       invokeRestart <- base::invokeRestart
[13:20:51.265]                       is.null <- base::is.null
[13:20:51.265]                       muffled <- FALSE
[13:20:51.265]                       if (inherits(cond, "message")) {
[13:20:51.265]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.265]                         if (muffled) 
[13:20:51.265]                           invokeRestart("muffleMessage")
[13:20:51.265]                       }
[13:20:51.265]                       else if (inherits(cond, "warning")) {
[13:20:51.265]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.265]                         if (muffled) 
[13:20:51.265]                           invokeRestart("muffleWarning")
[13:20:51.265]                       }
[13:20:51.265]                       else if (inherits(cond, "condition")) {
[13:20:51.265]                         if (!is.null(pattern)) {
[13:20:51.265]                           computeRestarts <- base::computeRestarts
[13:20:51.265]                           grepl <- base::grepl
[13:20:51.265]                           restarts <- computeRestarts(cond)
[13:20:51.265]                           for (restart in restarts) {
[13:20:51.265]                             name <- restart$name
[13:20:51.265]                             if (is.null(name)) 
[13:20:51.265]                               next
[13:20:51.265]                             if (!grepl(pattern, name)) 
[13:20:51.265]                               next
[13:20:51.265]                             invokeRestart(restart)
[13:20:51.265]                             muffled <- TRUE
[13:20:51.265]                             break
[13:20:51.265]                           }
[13:20:51.265]                         }
[13:20:51.265]                       }
[13:20:51.265]                       invisible(muffled)
[13:20:51.265]                     }
[13:20:51.265]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.265]                   }
[13:20:51.265]                 }
[13:20:51.265]             }
[13:20:51.265]         }))
[13:20:51.265]     }, error = function(ex) {
[13:20:51.265]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.265]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.265]                 ...future.rng), started = ...future.startTime, 
[13:20:51.265]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.265]             version = "1.8"), class = "FutureResult")
[13:20:51.265]     }, finally = {
[13:20:51.265]         if (!identical(...future.workdir, getwd())) 
[13:20:51.265]             setwd(...future.workdir)
[13:20:51.265]         {
[13:20:51.265]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.265]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.265]             }
[13:20:51.265]             base::options(...future.oldOptions)
[13:20:51.265]             if (.Platform$OS.type == "windows") {
[13:20:51.265]                 old_names <- names(...future.oldEnvVars)
[13:20:51.265]                 envs <- base::Sys.getenv()
[13:20:51.265]                 names <- names(envs)
[13:20:51.265]                 common <- intersect(names, old_names)
[13:20:51.265]                 added <- setdiff(names, old_names)
[13:20:51.265]                 removed <- setdiff(old_names, names)
[13:20:51.265]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.265]                   envs[common]]
[13:20:51.265]                 NAMES <- toupper(changed)
[13:20:51.265]                 args <- list()
[13:20:51.265]                 for (kk in seq_along(NAMES)) {
[13:20:51.265]                   name <- changed[[kk]]
[13:20:51.265]                   NAME <- NAMES[[kk]]
[13:20:51.265]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.265]                     next
[13:20:51.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.265]                 }
[13:20:51.265]                 NAMES <- toupper(added)
[13:20:51.265]                 for (kk in seq_along(NAMES)) {
[13:20:51.265]                   name <- added[[kk]]
[13:20:51.265]                   NAME <- NAMES[[kk]]
[13:20:51.265]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.265]                     next
[13:20:51.265]                   args[[name]] <- ""
[13:20:51.265]                 }
[13:20:51.265]                 NAMES <- toupper(removed)
[13:20:51.265]                 for (kk in seq_along(NAMES)) {
[13:20:51.265]                   name <- removed[[kk]]
[13:20:51.265]                   NAME <- NAMES[[kk]]
[13:20:51.265]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.265]                     next
[13:20:51.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.265]                 }
[13:20:51.265]                 if (length(args) > 0) 
[13:20:51.265]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.265]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.265]             }
[13:20:51.265]             else {
[13:20:51.265]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.265]             }
[13:20:51.265]             {
[13:20:51.265]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.265]                   0L) {
[13:20:51.265]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.265]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.265]                   base::options(opts)
[13:20:51.265]                 }
[13:20:51.265]                 {
[13:20:51.265]                   {
[13:20:51.265]                     NULL
[13:20:51.265]                     RNGkind("Mersenne-Twister")
[13:20:51.265]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:51.265]                       inherits = FALSE)
[13:20:51.265]                   }
[13:20:51.265]                   options(future.plan = NULL)
[13:20:51.265]                   if (is.na(NA_character_)) 
[13:20:51.265]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.265]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.265]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.265]                     envir = parent.frame()) 
[13:20:51.265]                   {
[13:20:51.265]                     default_workers <- missing(workers)
[13:20:51.265]                     if (is.function(workers)) 
[13:20:51.265]                       workers <- workers()
[13:20:51.265]                     workers <- structure(as.integer(workers), 
[13:20:51.265]                       class = class(workers))
[13:20:51.265]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.265]                       1L)
[13:20:51.265]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.265]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.265]                       if (default_workers) 
[13:20:51.265]                         supportsMulticore(warn = TRUE)
[13:20:51.265]                       return(sequential(..., envir = envir))
[13:20:51.265]                     }
[13:20:51.265]                     oopts <- options(mc.cores = workers)
[13:20:51.265]                     on.exit(options(oopts))
[13:20:51.265]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.265]                       envir = envir)
[13:20:51.265]                     if (!future$lazy) 
[13:20:51.265]                       future <- run(future)
[13:20:51.265]                     invisible(future)
[13:20:51.265]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.265]                 }
[13:20:51.265]             }
[13:20:51.265]         }
[13:20:51.265]     })
[13:20:51.265]     if (TRUE) {
[13:20:51.265]         base::sink(type = "output", split = FALSE)
[13:20:51.265]         if (TRUE) {
[13:20:51.265]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.265]         }
[13:20:51.265]         else {
[13:20:51.265]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.265]         }
[13:20:51.265]         base::close(...future.stdout)
[13:20:51.265]         ...future.stdout <- NULL
[13:20:51.265]     }
[13:20:51.265]     ...future.result$conditions <- ...future.conditions
[13:20:51.265]     ...future.result$finished <- base::Sys.time()
[13:20:51.265]     ...future.result
[13:20:51.265] }
[13:20:51.267] assign_globals() ...
[13:20:51.267] List of 1
[13:20:51.267]  $ pkg: chr "foo"
[13:20:51.267]  - attr(*, "where")=List of 1
[13:20:51.267]   ..$ pkg:<environment: R_EmptyEnv> 
[13:20:51.267]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:51.267]  - attr(*, "resolved")= logi TRUE
[13:20:51.267]  - attr(*, "total_size")= num 112
[13:20:51.270] - copied ‘pkg’ to environment
[13:20:51.270] assign_globals() ... done
[13:20:51.270] plan(): Setting new future strategy stack:
[13:20:51.270] List of future strategies:
[13:20:51.270] 1. sequential:
[13:20:51.270]    - args: function (..., envir = parent.frame())
[13:20:51.270]    - tweaked: FALSE
[13:20:51.270]    - call: NULL
[13:20:51.271] plan(): nbrOfWorkers() = 1
[13:20:51.272] plan(): Setting new future strategy stack:
[13:20:51.272] List of future strategies:
[13:20:51.272] 1. multicore:
[13:20:51.272]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.272]    - tweaked: FALSE
[13:20:51.272]    - call: plan(strategy)
[13:20:51.275] plan(): nbrOfWorkers() = 2
[13:20:51.276] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.277] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.277] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:51.279] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:20:51.279] Searching for globals ... DONE
[13:20:51.279] Resolving globals: TRUE
[13:20:51.279] Resolving any globals that are futures ...
[13:20:51.279] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:20:51.279] Resolving any globals that are futures ... DONE
[13:20:51.280] Resolving futures part of globals (recursively) ...
[13:20:51.280] resolve() on list ...
[13:20:51.280]  recursive: 99
[13:20:51.280]  length: 1
[13:20:51.280]  elements: ‘a’
[13:20:51.281]  length: 0 (resolved future 1)
[13:20:51.281] resolve() on list ... DONE
[13:20:51.281] - globals: [1] ‘a’
[13:20:51.281] Resolving futures part of globals (recursively) ... DONE
[13:20:51.281] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:51.281] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:20:51.288] - globals: [1] ‘a’
[13:20:51.289] 
[13:20:51.289] getGlobalsAndPackages() ... DONE
[13:20:51.289] run() for ‘Future’ ...
[13:20:51.289] - state: ‘created’
[13:20:51.289] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.293] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.293] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.293]   - Field: ‘label’
[13:20:51.293]   - Field: ‘local’
[13:20:51.293]   - Field: ‘owner’
[13:20:51.293]   - Field: ‘envir’
[13:20:51.294]   - Field: ‘workers’
[13:20:51.294]   - Field: ‘packages’
[13:20:51.294]   - Field: ‘gc’
[13:20:51.294]   - Field: ‘job’
[13:20:51.294]   - Field: ‘conditions’
[13:20:51.294]   - Field: ‘expr’
[13:20:51.294]   - Field: ‘uuid’
[13:20:51.294]   - Field: ‘seed’
[13:20:51.295]   - Field: ‘version’
[13:20:51.295]   - Field: ‘result’
[13:20:51.295]   - Field: ‘asynchronous’
[13:20:51.295]   - Field: ‘calls’
[13:20:51.295]   - Field: ‘globals’
[13:20:51.295]   - Field: ‘stdout’
[13:20:51.295]   - Field: ‘earlySignal’
[13:20:51.295]   - Field: ‘lazy’
[13:20:51.296]   - Field: ‘state’
[13:20:51.296] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.296] - Launch lazy future ...
[13:20:51.296] Packages needed by the future expression (n = 0): <none>
[13:20:51.296] Packages needed by future strategies (n = 0): <none>
[13:20:51.297] {
[13:20:51.297]     {
[13:20:51.297]         {
[13:20:51.297]             ...future.startTime <- base::Sys.time()
[13:20:51.297]             {
[13:20:51.297]                 {
[13:20:51.297]                   {
[13:20:51.297]                     {
[13:20:51.297]                       base::local({
[13:20:51.297]                         has_future <- base::requireNamespace("future", 
[13:20:51.297]                           quietly = TRUE)
[13:20:51.297]                         if (has_future) {
[13:20:51.297]                           ns <- base::getNamespace("future")
[13:20:51.297]                           version <- ns[[".package"]][["version"]]
[13:20:51.297]                           if (is.null(version)) 
[13:20:51.297]                             version <- utils::packageVersion("future")
[13:20:51.297]                         }
[13:20:51.297]                         else {
[13:20:51.297]                           version <- NULL
[13:20:51.297]                         }
[13:20:51.297]                         if (!has_future || version < "1.8.0") {
[13:20:51.297]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.297]                             "", base::R.version$version.string), 
[13:20:51.297]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:51.297]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:51.297]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.297]                               "release", "version")], collapse = " "), 
[13:20:51.297]                             hostname = base::Sys.info()[["nodename"]])
[13:20:51.297]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.297]                             info)
[13:20:51.297]                           info <- base::paste(info, collapse = "; ")
[13:20:51.297]                           if (!has_future) {
[13:20:51.297]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.297]                               info)
[13:20:51.297]                           }
[13:20:51.297]                           else {
[13:20:51.297]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.297]                               info, version)
[13:20:51.297]                           }
[13:20:51.297]                           base::stop(msg)
[13:20:51.297]                         }
[13:20:51.297]                       })
[13:20:51.297]                     }
[13:20:51.297]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.297]                     base::options(mc.cores = 1L)
[13:20:51.297]                   }
[13:20:51.297]                   options(future.plan = NULL)
[13:20:51.297]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.297]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.297]                 }
[13:20:51.297]                 ...future.workdir <- getwd()
[13:20:51.297]             }
[13:20:51.297]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.297]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.297]         }
[13:20:51.297]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.297]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:51.297]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.297]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.297]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.297]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.297]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.297]             base::names(...future.oldOptions))
[13:20:51.297]     }
[13:20:51.297]     if (FALSE) {
[13:20:51.297]     }
[13:20:51.297]     else {
[13:20:51.297]         if (TRUE) {
[13:20:51.297]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.297]                 open = "w")
[13:20:51.297]         }
[13:20:51.297]         else {
[13:20:51.297]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.297]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.297]         }
[13:20:51.297]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.297]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.297]             base::sink(type = "output", split = FALSE)
[13:20:51.297]             base::close(...future.stdout)
[13:20:51.297]         }, add = TRUE)
[13:20:51.297]     }
[13:20:51.297]     ...future.frame <- base::sys.nframe()
[13:20:51.297]     ...future.conditions <- base::list()
[13:20:51.297]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.297]     if (FALSE) {
[13:20:51.297]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.297]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.297]     }
[13:20:51.297]     ...future.result <- base::tryCatch({
[13:20:51.297]         base::withCallingHandlers({
[13:20:51.297]             ...future.value <- base::withVisible(base::local({
[13:20:51.297]                 withCallingHandlers({
[13:20:51.297]                   {
[13:20:51.297]                     b <- a
[13:20:51.297]                     a <- 2
[13:20:51.297]                     a * b
[13:20:51.297]                   }
[13:20:51.297]                 }, immediateCondition = function(cond) {
[13:20:51.297]                   save_rds <- function (object, pathname, ...) 
[13:20:51.297]                   {
[13:20:51.297]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.297]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.297]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.297]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.297]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.297]                         fi_tmp[["mtime"]])
[13:20:51.297]                     }
[13:20:51.297]                     tryCatch({
[13:20:51.297]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.297]                     }, error = function(ex) {
[13:20:51.297]                       msg <- conditionMessage(ex)
[13:20:51.297]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.297]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.297]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.297]                         fi_tmp[["mtime"]], msg)
[13:20:51.297]                       ex$message <- msg
[13:20:51.297]                       stop(ex)
[13:20:51.297]                     })
[13:20:51.297]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.297]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.297]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.297]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.297]                       fi <- file.info(pathname)
[13:20:51.297]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.297]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.297]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.297]                         fi[["size"]], fi[["mtime"]])
[13:20:51.297]                       stop(msg)
[13:20:51.297]                     }
[13:20:51.297]                     invisible(pathname)
[13:20:51.297]                   }
[13:20:51.297]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.297]                     rootPath = tempdir()) 
[13:20:51.297]                   {
[13:20:51.297]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.297]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.297]                       tmpdir = path, fileext = ".rds")
[13:20:51.297]                     save_rds(obj, file)
[13:20:51.297]                   }
[13:20:51.297]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.297]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.297]                   {
[13:20:51.297]                     inherits <- base::inherits
[13:20:51.297]                     invokeRestart <- base::invokeRestart
[13:20:51.297]                     is.null <- base::is.null
[13:20:51.297]                     muffled <- FALSE
[13:20:51.297]                     if (inherits(cond, "message")) {
[13:20:51.297]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.297]                       if (muffled) 
[13:20:51.297]                         invokeRestart("muffleMessage")
[13:20:51.297]                     }
[13:20:51.297]                     else if (inherits(cond, "warning")) {
[13:20:51.297]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.297]                       if (muffled) 
[13:20:51.297]                         invokeRestart("muffleWarning")
[13:20:51.297]                     }
[13:20:51.297]                     else if (inherits(cond, "condition")) {
[13:20:51.297]                       if (!is.null(pattern)) {
[13:20:51.297]                         computeRestarts <- base::computeRestarts
[13:20:51.297]                         grepl <- base::grepl
[13:20:51.297]                         restarts <- computeRestarts(cond)
[13:20:51.297]                         for (restart in restarts) {
[13:20:51.297]                           name <- restart$name
[13:20:51.297]                           if (is.null(name)) 
[13:20:51.297]                             next
[13:20:51.297]                           if (!grepl(pattern, name)) 
[13:20:51.297]                             next
[13:20:51.297]                           invokeRestart(restart)
[13:20:51.297]                           muffled <- TRUE
[13:20:51.297]                           break
[13:20:51.297]                         }
[13:20:51.297]                       }
[13:20:51.297]                     }
[13:20:51.297]                     invisible(muffled)
[13:20:51.297]                   }
[13:20:51.297]                   muffleCondition(cond)
[13:20:51.297]                 })
[13:20:51.297]             }))
[13:20:51.297]             future::FutureResult(value = ...future.value$value, 
[13:20:51.297]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.297]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.297]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.297]                     ...future.globalenv.names))
[13:20:51.297]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.297]         }, condition = base::local({
[13:20:51.297]             c <- base::c
[13:20:51.297]             inherits <- base::inherits
[13:20:51.297]             invokeRestart <- base::invokeRestart
[13:20:51.297]             length <- base::length
[13:20:51.297]             list <- base::list
[13:20:51.297]             seq.int <- base::seq.int
[13:20:51.297]             signalCondition <- base::signalCondition
[13:20:51.297]             sys.calls <- base::sys.calls
[13:20:51.297]             `[[` <- base::`[[`
[13:20:51.297]             `+` <- base::`+`
[13:20:51.297]             `<<-` <- base::`<<-`
[13:20:51.297]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.297]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.297]                   3L)]
[13:20:51.297]             }
[13:20:51.297]             function(cond) {
[13:20:51.297]                 is_error <- inherits(cond, "error")
[13:20:51.297]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.297]                   NULL)
[13:20:51.297]                 if (is_error) {
[13:20:51.297]                   sessionInformation <- function() {
[13:20:51.297]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.297]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.297]                       search = base::search(), system = base::Sys.info())
[13:20:51.297]                   }
[13:20:51.297]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.297]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.297]                     cond$call), session = sessionInformation(), 
[13:20:51.297]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.297]                   signalCondition(cond)
[13:20:51.297]                 }
[13:20:51.297]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.297]                 "immediateCondition"))) {
[13:20:51.297]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.297]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.297]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.297]                   if (TRUE && !signal) {
[13:20:51.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.297]                     {
[13:20:51.297]                       inherits <- base::inherits
[13:20:51.297]                       invokeRestart <- base::invokeRestart
[13:20:51.297]                       is.null <- base::is.null
[13:20:51.297]                       muffled <- FALSE
[13:20:51.297]                       if (inherits(cond, "message")) {
[13:20:51.297]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.297]                         if (muffled) 
[13:20:51.297]                           invokeRestart("muffleMessage")
[13:20:51.297]                       }
[13:20:51.297]                       else if (inherits(cond, "warning")) {
[13:20:51.297]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.297]                         if (muffled) 
[13:20:51.297]                           invokeRestart("muffleWarning")
[13:20:51.297]                       }
[13:20:51.297]                       else if (inherits(cond, "condition")) {
[13:20:51.297]                         if (!is.null(pattern)) {
[13:20:51.297]                           computeRestarts <- base::computeRestarts
[13:20:51.297]                           grepl <- base::grepl
[13:20:51.297]                           restarts <- computeRestarts(cond)
[13:20:51.297]                           for (restart in restarts) {
[13:20:51.297]                             name <- restart$name
[13:20:51.297]                             if (is.null(name)) 
[13:20:51.297]                               next
[13:20:51.297]                             if (!grepl(pattern, name)) 
[13:20:51.297]                               next
[13:20:51.297]                             invokeRestart(restart)
[13:20:51.297]                             muffled <- TRUE
[13:20:51.297]                             break
[13:20:51.297]                           }
[13:20:51.297]                         }
[13:20:51.297]                       }
[13:20:51.297]                       invisible(muffled)
[13:20:51.297]                     }
[13:20:51.297]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.297]                   }
[13:20:51.297]                 }
[13:20:51.297]                 else {
[13:20:51.297]                   if (TRUE) {
[13:20:51.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.297]                     {
[13:20:51.297]                       inherits <- base::inherits
[13:20:51.297]                       invokeRestart <- base::invokeRestart
[13:20:51.297]                       is.null <- base::is.null
[13:20:51.297]                       muffled <- FALSE
[13:20:51.297]                       if (inherits(cond, "message")) {
[13:20:51.297]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.297]                         if (muffled) 
[13:20:51.297]                           invokeRestart("muffleMessage")
[13:20:51.297]                       }
[13:20:51.297]                       else if (inherits(cond, "warning")) {
[13:20:51.297]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.297]                         if (muffled) 
[13:20:51.297]                           invokeRestart("muffleWarning")
[13:20:51.297]                       }
[13:20:51.297]                       else if (inherits(cond, "condition")) {
[13:20:51.297]                         if (!is.null(pattern)) {
[13:20:51.297]                           computeRestarts <- base::computeRestarts
[13:20:51.297]                           grepl <- base::grepl
[13:20:51.297]                           restarts <- computeRestarts(cond)
[13:20:51.297]                           for (restart in restarts) {
[13:20:51.297]                             name <- restart$name
[13:20:51.297]                             if (is.null(name)) 
[13:20:51.297]                               next
[13:20:51.297]                             if (!grepl(pattern, name)) 
[13:20:51.297]                               next
[13:20:51.297]                             invokeRestart(restart)
[13:20:51.297]                             muffled <- TRUE
[13:20:51.297]                             break
[13:20:51.297]                           }
[13:20:51.297]                         }
[13:20:51.297]                       }
[13:20:51.297]                       invisible(muffled)
[13:20:51.297]                     }
[13:20:51.297]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.297]                   }
[13:20:51.297]                 }
[13:20:51.297]             }
[13:20:51.297]         }))
[13:20:51.297]     }, error = function(ex) {
[13:20:51.297]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.297]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.297]                 ...future.rng), started = ...future.startTime, 
[13:20:51.297]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.297]             version = "1.8"), class = "FutureResult")
[13:20:51.297]     }, finally = {
[13:20:51.297]         if (!identical(...future.workdir, getwd())) 
[13:20:51.297]             setwd(...future.workdir)
[13:20:51.297]         {
[13:20:51.297]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.297]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.297]             }
[13:20:51.297]             base::options(...future.oldOptions)
[13:20:51.297]             if (.Platform$OS.type == "windows") {
[13:20:51.297]                 old_names <- names(...future.oldEnvVars)
[13:20:51.297]                 envs <- base::Sys.getenv()
[13:20:51.297]                 names <- names(envs)
[13:20:51.297]                 common <- intersect(names, old_names)
[13:20:51.297]                 added <- setdiff(names, old_names)
[13:20:51.297]                 removed <- setdiff(old_names, names)
[13:20:51.297]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.297]                   envs[common]]
[13:20:51.297]                 NAMES <- toupper(changed)
[13:20:51.297]                 args <- list()
[13:20:51.297]                 for (kk in seq_along(NAMES)) {
[13:20:51.297]                   name <- changed[[kk]]
[13:20:51.297]                   NAME <- NAMES[[kk]]
[13:20:51.297]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.297]                     next
[13:20:51.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.297]                 }
[13:20:51.297]                 NAMES <- toupper(added)
[13:20:51.297]                 for (kk in seq_along(NAMES)) {
[13:20:51.297]                   name <- added[[kk]]
[13:20:51.297]                   NAME <- NAMES[[kk]]
[13:20:51.297]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.297]                     next
[13:20:51.297]                   args[[name]] <- ""
[13:20:51.297]                 }
[13:20:51.297]                 NAMES <- toupper(removed)
[13:20:51.297]                 for (kk in seq_along(NAMES)) {
[13:20:51.297]                   name <- removed[[kk]]
[13:20:51.297]                   NAME <- NAMES[[kk]]
[13:20:51.297]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.297]                     next
[13:20:51.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.297]                 }
[13:20:51.297]                 if (length(args) > 0) 
[13:20:51.297]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.297]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.297]             }
[13:20:51.297]             else {
[13:20:51.297]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.297]             }
[13:20:51.297]             {
[13:20:51.297]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.297]                   0L) {
[13:20:51.297]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.297]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.297]                   base::options(opts)
[13:20:51.297]                 }
[13:20:51.297]                 {
[13:20:51.297]                   {
[13:20:51.297]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.297]                     NULL
[13:20:51.297]                   }
[13:20:51.297]                   options(future.plan = NULL)
[13:20:51.297]                   if (is.na(NA_character_)) 
[13:20:51.297]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.297]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.297]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.297]                     envir = parent.frame()) 
[13:20:51.297]                   {
[13:20:51.297]                     default_workers <- missing(workers)
[13:20:51.297]                     if (is.function(workers)) 
[13:20:51.297]                       workers <- workers()
[13:20:51.297]                     workers <- structure(as.integer(workers), 
[13:20:51.297]                       class = class(workers))
[13:20:51.297]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.297]                       1L)
[13:20:51.297]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.297]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.297]                       if (default_workers) 
[13:20:51.297]                         supportsMulticore(warn = TRUE)
[13:20:51.297]                       return(sequential(..., envir = envir))
[13:20:51.297]                     }
[13:20:51.297]                     oopts <- options(mc.cores = workers)
[13:20:51.297]                     on.exit(options(oopts))
[13:20:51.297]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.297]                       envir = envir)
[13:20:51.297]                     if (!future$lazy) 
[13:20:51.297]                       future <- run(future)
[13:20:51.297]                     invisible(future)
[13:20:51.297]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.297]                 }
[13:20:51.297]             }
[13:20:51.297]         }
[13:20:51.297]     })
[13:20:51.297]     if (TRUE) {
[13:20:51.297]         base::sink(type = "output", split = FALSE)
[13:20:51.297]         if (TRUE) {
[13:20:51.297]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.297]         }
[13:20:51.297]         else {
[13:20:51.297]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.297]         }
[13:20:51.297]         base::close(...future.stdout)
[13:20:51.297]         ...future.stdout <- NULL
[13:20:51.297]     }
[13:20:51.297]     ...future.result$conditions <- ...future.conditions
[13:20:51.297]     ...future.result$finished <- base::Sys.time()
[13:20:51.297]     ...future.result
[13:20:51.297] }
[13:20:51.299] assign_globals() ...
[13:20:51.299] List of 1
[13:20:51.299]  $ a: num 3
[13:20:51.299]  - attr(*, "where")=List of 1
[13:20:51.299]   ..$ a:<environment: R_EmptyEnv> 
[13:20:51.299]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:51.299]  - attr(*, "resolved")= logi TRUE
[13:20:51.299]  - attr(*, "total_size")= num 56
[13:20:51.299]  - attr(*, "already-done")= logi TRUE
[13:20:51.302] - copied ‘a’ to environment
[13:20:51.302] assign_globals() ... done
[13:20:51.302] requestCore(): workers = 2
[13:20:51.304] MulticoreFuture started
[13:20:51.305] - Launch lazy future ... done
[13:20:51.305] run() for ‘MulticoreFuture’ ... done
[13:20:51.305] plan(): Setting new future strategy stack:
[13:20:51.306] List of future strategies:
[13:20:51.306] 1. sequential:
[13:20:51.306]    - args: function (..., envir = parent.frame())
[13:20:51.306]    - tweaked: FALSE
[13:20:51.306]    - call: NULL
[13:20:51.307] plan(): nbrOfWorkers() = 1
[13:20:51.309] plan(): Setting new future strategy stack:
[13:20:51.309] List of future strategies:
[13:20:51.309] 1. multicore:
[13:20:51.309]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.309]    - tweaked: FALSE
[13:20:51.309]    - call: plan(strategy)
[13:20:51.314] plan(): nbrOfWorkers() = 2
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.316] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.316] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:51.319] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:20:51.319] Searching for globals ... DONE
[13:20:51.319] Resolving globals: TRUE
[13:20:51.320] Resolving any globals that are futures ...
[13:20:51.320] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:20:51.320] Resolving any globals that are futures ... DONE
[13:20:51.320] Resolving futures part of globals (recursively) ...
[13:20:51.321] resolve() on list ...
[13:20:51.321]  recursive: 99
[13:20:51.321]  length: 1
[13:20:51.321]  elements: ‘a’
[13:20:51.321]  length: 0 (resolved future 1)
[13:20:51.321] resolve() on list ... DONE
[13:20:51.321] - globals: [1] ‘a’
[13:20:51.322] Resolving futures part of globals (recursively) ... DONE
[13:20:51.322] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:51.322] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:20:51.322] - globals: [1] ‘a’
[13:20:51.323] 
[13:20:51.323] getGlobalsAndPackages() ... DONE
[13:20:51.323] run() for ‘Future’ ...
[13:20:51.323] - state: ‘created’
[13:20:51.323] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.327] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.328] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.328]   - Field: ‘label’
[13:20:51.328]   - Field: ‘local’
[13:20:51.328]   - Field: ‘owner’
[13:20:51.328]   - Field: ‘envir’
[13:20:51.328]   - Field: ‘workers’
[13:20:51.328]   - Field: ‘packages’
[13:20:51.329]   - Field: ‘gc’
[13:20:51.329]   - Field: ‘job’
[13:20:51.329]   - Field: ‘conditions’
[13:20:51.329]   - Field: ‘expr’
[13:20:51.329]   - Field: ‘uuid’
[13:20:51.329]   - Field: ‘seed’
[13:20:51.329]   - Field: ‘version’
[13:20:51.329]   - Field: ‘result’
[13:20:51.330]   - Field: ‘asynchronous’
[13:20:51.330]   - Field: ‘calls’
[13:20:51.330]   - Field: ‘globals’
[13:20:51.330]   - Field: ‘stdout’
[13:20:51.330]   - Field: ‘earlySignal’
[13:20:51.330]   - Field: ‘lazy’
[13:20:51.330]   - Field: ‘state’
[13:20:51.330] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.330] - Launch lazy future ...
[13:20:51.331] Packages needed by the future expression (n = 0): <none>
[13:20:51.331] Packages needed by future strategies (n = 0): <none>
[13:20:51.334] {
[13:20:51.334]     {
[13:20:51.334]         {
[13:20:51.334]             ...future.startTime <- base::Sys.time()
[13:20:51.334]             {
[13:20:51.334]                 {
[13:20:51.334]                   {
[13:20:51.334]                     {
[13:20:51.334]                       base::local({
[13:20:51.334]                         has_future <- base::requireNamespace("future", 
[13:20:51.334]                           quietly = TRUE)
[13:20:51.334]                         if (has_future) {
[13:20:51.334]                           ns <- base::getNamespace("future")
[13:20:51.334]                           version <- ns[[".package"]][["version"]]
[13:20:51.334]                           if (is.null(version)) 
[13:20:51.334]                             version <- utils::packageVersion("future")
[13:20:51.334]                         }
[13:20:51.334]                         else {
[13:20:51.334]                           version <- NULL
[13:20:51.334]                         }
[13:20:51.334]                         if (!has_future || version < "1.8.0") {
[13:20:51.334]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.334]                             "", base::R.version$version.string), 
[13:20:51.334]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:51.334]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:51.334]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.334]                               "release", "version")], collapse = " "), 
[13:20:51.334]                             hostname = base::Sys.info()[["nodename"]])
[13:20:51.334]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.334]                             info)
[13:20:51.334]                           info <- base::paste(info, collapse = "; ")
[13:20:51.334]                           if (!has_future) {
[13:20:51.334]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.334]                               info)
[13:20:51.334]                           }
[13:20:51.334]                           else {
[13:20:51.334]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.334]                               info, version)
[13:20:51.334]                           }
[13:20:51.334]                           base::stop(msg)
[13:20:51.334]                         }
[13:20:51.334]                       })
[13:20:51.334]                     }
[13:20:51.334]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.334]                     base::options(mc.cores = 1L)
[13:20:51.334]                   }
[13:20:51.334]                   options(future.plan = NULL)
[13:20:51.334]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.334]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.334]                 }
[13:20:51.334]                 ...future.workdir <- getwd()
[13:20:51.334]             }
[13:20:51.334]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.334]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.334]         }
[13:20:51.334]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.334]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:51.334]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.334]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.334]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.334]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.334]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.334]             base::names(...future.oldOptions))
[13:20:51.334]     }
[13:20:51.334]     if (FALSE) {
[13:20:51.334]     }
[13:20:51.334]     else {
[13:20:51.334]         if (TRUE) {
[13:20:51.334]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.334]                 open = "w")
[13:20:51.334]         }
[13:20:51.334]         else {
[13:20:51.334]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.334]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.334]         }
[13:20:51.334]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.334]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.334]             base::sink(type = "output", split = FALSE)
[13:20:51.334]             base::close(...future.stdout)
[13:20:51.334]         }, add = TRUE)
[13:20:51.334]     }
[13:20:51.334]     ...future.frame <- base::sys.nframe()
[13:20:51.334]     ...future.conditions <- base::list()
[13:20:51.334]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.334]     if (FALSE) {
[13:20:51.334]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.334]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.334]     }
[13:20:51.334]     ...future.result <- base::tryCatch({
[13:20:51.334]         base::withCallingHandlers({
[13:20:51.334]             ...future.value <- base::withVisible(base::local({
[13:20:51.334]                 withCallingHandlers({
[13:20:51.334]                   {
[13:20:51.334]                     b <- a
[13:20:51.334]                     a <- 2
[13:20:51.334]                     a * b
[13:20:51.334]                   }
[13:20:51.334]                 }, immediateCondition = function(cond) {
[13:20:51.334]                   save_rds <- function (object, pathname, ...) 
[13:20:51.334]                   {
[13:20:51.334]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.334]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.334]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.334]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.334]                         fi_tmp[["mtime"]])
[13:20:51.334]                     }
[13:20:51.334]                     tryCatch({
[13:20:51.334]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.334]                     }, error = function(ex) {
[13:20:51.334]                       msg <- conditionMessage(ex)
[13:20:51.334]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.334]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.334]                         fi_tmp[["mtime"]], msg)
[13:20:51.334]                       ex$message <- msg
[13:20:51.334]                       stop(ex)
[13:20:51.334]                     })
[13:20:51.334]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.334]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.334]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.334]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.334]                       fi <- file.info(pathname)
[13:20:51.334]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.334]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.334]                         fi[["size"]], fi[["mtime"]])
[13:20:51.334]                       stop(msg)
[13:20:51.334]                     }
[13:20:51.334]                     invisible(pathname)
[13:20:51.334]                   }
[13:20:51.334]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.334]                     rootPath = tempdir()) 
[13:20:51.334]                   {
[13:20:51.334]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.334]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.334]                       tmpdir = path, fileext = ".rds")
[13:20:51.334]                     save_rds(obj, file)
[13:20:51.334]                   }
[13:20:51.334]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.334]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.334]                   {
[13:20:51.334]                     inherits <- base::inherits
[13:20:51.334]                     invokeRestart <- base::invokeRestart
[13:20:51.334]                     is.null <- base::is.null
[13:20:51.334]                     muffled <- FALSE
[13:20:51.334]                     if (inherits(cond, "message")) {
[13:20:51.334]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.334]                       if (muffled) 
[13:20:51.334]                         invokeRestart("muffleMessage")
[13:20:51.334]                     }
[13:20:51.334]                     else if (inherits(cond, "warning")) {
[13:20:51.334]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.334]                       if (muffled) 
[13:20:51.334]                         invokeRestart("muffleWarning")
[13:20:51.334]                     }
[13:20:51.334]                     else if (inherits(cond, "condition")) {
[13:20:51.334]                       if (!is.null(pattern)) {
[13:20:51.334]                         computeRestarts <- base::computeRestarts
[13:20:51.334]                         grepl <- base::grepl
[13:20:51.334]                         restarts <- computeRestarts(cond)
[13:20:51.334]                         for (restart in restarts) {
[13:20:51.334]                           name <- restart$name
[13:20:51.334]                           if (is.null(name)) 
[13:20:51.334]                             next
[13:20:51.334]                           if (!grepl(pattern, name)) 
[13:20:51.334]                             next
[13:20:51.334]                           invokeRestart(restart)
[13:20:51.334]                           muffled <- TRUE
[13:20:51.334]                           break
[13:20:51.334]                         }
[13:20:51.334]                       }
[13:20:51.334]                     }
[13:20:51.334]                     invisible(muffled)
[13:20:51.334]                   }
[13:20:51.334]                   muffleCondition(cond)
[13:20:51.334]                 })
[13:20:51.334]             }))
[13:20:51.334]             future::FutureResult(value = ...future.value$value, 
[13:20:51.334]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.334]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.334]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.334]                     ...future.globalenv.names))
[13:20:51.334]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.334]         }, condition = base::local({
[13:20:51.334]             c <- base::c
[13:20:51.334]             inherits <- base::inherits
[13:20:51.334]             invokeRestart <- base::invokeRestart
[13:20:51.334]             length <- base::length
[13:20:51.334]             list <- base::list
[13:20:51.334]             seq.int <- base::seq.int
[13:20:51.334]             signalCondition <- base::signalCondition
[13:20:51.334]             sys.calls <- base::sys.calls
[13:20:51.334]             `[[` <- base::`[[`
[13:20:51.334]             `+` <- base::`+`
[13:20:51.334]             `<<-` <- base::`<<-`
[13:20:51.334]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.334]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.334]                   3L)]
[13:20:51.334]             }
[13:20:51.334]             function(cond) {
[13:20:51.334]                 is_error <- inherits(cond, "error")
[13:20:51.334]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.334]                   NULL)
[13:20:51.334]                 if (is_error) {
[13:20:51.334]                   sessionInformation <- function() {
[13:20:51.334]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.334]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.334]                       search = base::search(), system = base::Sys.info())
[13:20:51.334]                   }
[13:20:51.334]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.334]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.334]                     cond$call), session = sessionInformation(), 
[13:20:51.334]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.334]                   signalCondition(cond)
[13:20:51.334]                 }
[13:20:51.334]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.334]                 "immediateCondition"))) {
[13:20:51.334]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.334]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.334]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.334]                   if (TRUE && !signal) {
[13:20:51.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.334]                     {
[13:20:51.334]                       inherits <- base::inherits
[13:20:51.334]                       invokeRestart <- base::invokeRestart
[13:20:51.334]                       is.null <- base::is.null
[13:20:51.334]                       muffled <- FALSE
[13:20:51.334]                       if (inherits(cond, "message")) {
[13:20:51.334]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.334]                         if (muffled) 
[13:20:51.334]                           invokeRestart("muffleMessage")
[13:20:51.334]                       }
[13:20:51.334]                       else if (inherits(cond, "warning")) {
[13:20:51.334]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.334]                         if (muffled) 
[13:20:51.334]                           invokeRestart("muffleWarning")
[13:20:51.334]                       }
[13:20:51.334]                       else if (inherits(cond, "condition")) {
[13:20:51.334]                         if (!is.null(pattern)) {
[13:20:51.334]                           computeRestarts <- base::computeRestarts
[13:20:51.334]                           grepl <- base::grepl
[13:20:51.334]                           restarts <- computeRestarts(cond)
[13:20:51.334]                           for (restart in restarts) {
[13:20:51.334]                             name <- restart$name
[13:20:51.334]                             if (is.null(name)) 
[13:20:51.334]                               next
[13:20:51.334]                             if (!grepl(pattern, name)) 
[13:20:51.334]                               next
[13:20:51.334]                             invokeRestart(restart)
[13:20:51.334]                             muffled <- TRUE
[13:20:51.334]                             break
[13:20:51.334]                           }
[13:20:51.334]                         }
[13:20:51.334]                       }
[13:20:51.334]                       invisible(muffled)
[13:20:51.334]                     }
[13:20:51.334]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.334]                   }
[13:20:51.334]                 }
[13:20:51.334]                 else {
[13:20:51.334]                   if (TRUE) {
[13:20:51.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.334]                     {
[13:20:51.334]                       inherits <- base::inherits
[13:20:51.334]                       invokeRestart <- base::invokeRestart
[13:20:51.334]                       is.null <- base::is.null
[13:20:51.334]                       muffled <- FALSE
[13:20:51.334]                       if (inherits(cond, "message")) {
[13:20:51.334]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.334]                         if (muffled) 
[13:20:51.334]                           invokeRestart("muffleMessage")
[13:20:51.334]                       }
[13:20:51.334]                       else if (inherits(cond, "warning")) {
[13:20:51.334]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.334]                         if (muffled) 
[13:20:51.334]                           invokeRestart("muffleWarning")
[13:20:51.334]                       }
[13:20:51.334]                       else if (inherits(cond, "condition")) {
[13:20:51.334]                         if (!is.null(pattern)) {
[13:20:51.334]                           computeRestarts <- base::computeRestarts
[13:20:51.334]                           grepl <- base::grepl
[13:20:51.334]                           restarts <- computeRestarts(cond)
[13:20:51.334]                           for (restart in restarts) {
[13:20:51.334]                             name <- restart$name
[13:20:51.334]                             if (is.null(name)) 
[13:20:51.334]                               next
[13:20:51.334]                             if (!grepl(pattern, name)) 
[13:20:51.334]                               next
[13:20:51.334]                             invokeRestart(restart)
[13:20:51.334]                             muffled <- TRUE
[13:20:51.334]                             break
[13:20:51.334]                           }
[13:20:51.334]                         }
[13:20:51.334]                       }
[13:20:51.334]                       invisible(muffled)
[13:20:51.334]                     }
[13:20:51.334]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.334]                   }
[13:20:51.334]                 }
[13:20:51.334]             }
[13:20:51.334]         }))
[13:20:51.334]     }, error = function(ex) {
[13:20:51.334]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.334]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.334]                 ...future.rng), started = ...future.startTime, 
[13:20:51.334]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.334]             version = "1.8"), class = "FutureResult")
[13:20:51.334]     }, finally = {
[13:20:51.334]         if (!identical(...future.workdir, getwd())) 
[13:20:51.334]             setwd(...future.workdir)
[13:20:51.334]         {
[13:20:51.334]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.334]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.334]             }
[13:20:51.334]             base::options(...future.oldOptions)
[13:20:51.334]             if (.Platform$OS.type == "windows") {
[13:20:51.334]                 old_names <- names(...future.oldEnvVars)
[13:20:51.334]                 envs <- base::Sys.getenv()
[13:20:51.334]                 names <- names(envs)
[13:20:51.334]                 common <- intersect(names, old_names)
[13:20:51.334]                 added <- setdiff(names, old_names)
[13:20:51.334]                 removed <- setdiff(old_names, names)
[13:20:51.334]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.334]                   envs[common]]
[13:20:51.334]                 NAMES <- toupper(changed)
[13:20:51.334]                 args <- list()
[13:20:51.334]                 for (kk in seq_along(NAMES)) {
[13:20:51.334]                   name <- changed[[kk]]
[13:20:51.334]                   NAME <- NAMES[[kk]]
[13:20:51.334]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.334]                     next
[13:20:51.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.334]                 }
[13:20:51.334]                 NAMES <- toupper(added)
[13:20:51.334]                 for (kk in seq_along(NAMES)) {
[13:20:51.334]                   name <- added[[kk]]
[13:20:51.334]                   NAME <- NAMES[[kk]]
[13:20:51.334]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.334]                     next
[13:20:51.334]                   args[[name]] <- ""
[13:20:51.334]                 }
[13:20:51.334]                 NAMES <- toupper(removed)
[13:20:51.334]                 for (kk in seq_along(NAMES)) {
[13:20:51.334]                   name <- removed[[kk]]
[13:20:51.334]                   NAME <- NAMES[[kk]]
[13:20:51.334]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.334]                     next
[13:20:51.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.334]                 }
[13:20:51.334]                 if (length(args) > 0) 
[13:20:51.334]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.334]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.334]             }
[13:20:51.334]             else {
[13:20:51.334]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.334]             }
[13:20:51.334]             {
[13:20:51.334]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.334]                   0L) {
[13:20:51.334]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.334]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.334]                   base::options(opts)
[13:20:51.334]                 }
[13:20:51.334]                 {
[13:20:51.334]                   {
[13:20:51.334]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.334]                     NULL
[13:20:51.334]                   }
[13:20:51.334]                   options(future.plan = NULL)
[13:20:51.334]                   if (is.na(NA_character_)) 
[13:20:51.334]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.334]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.334]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.334]                     envir = parent.frame()) 
[13:20:51.334]                   {
[13:20:51.334]                     default_workers <- missing(workers)
[13:20:51.334]                     if (is.function(workers)) 
[13:20:51.334]                       workers <- workers()
[13:20:51.334]                     workers <- structure(as.integer(workers), 
[13:20:51.334]                       class = class(workers))
[13:20:51.334]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.334]                       1L)
[13:20:51.334]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.334]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.334]                       if (default_workers) 
[13:20:51.334]                         supportsMulticore(warn = TRUE)
[13:20:51.334]                       return(sequential(..., envir = envir))
[13:20:51.334]                     }
[13:20:51.334]                     oopts <- options(mc.cores = workers)
[13:20:51.334]                     on.exit(options(oopts))
[13:20:51.334]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.334]                       envir = envir)
[13:20:51.334]                     if (!future$lazy) 
[13:20:51.334]                       future <- run(future)
[13:20:51.334]                     invisible(future)
[13:20:51.334]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.334]                 }
[13:20:51.334]             }
[13:20:51.334]         }
[13:20:51.334]     })
[13:20:51.334]     if (TRUE) {
[13:20:51.334]         base::sink(type = "output", split = FALSE)
[13:20:51.334]         if (TRUE) {
[13:20:51.334]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.334]         }
[13:20:51.334]         else {
[13:20:51.334]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.334]         }
[13:20:51.334]         base::close(...future.stdout)
[13:20:51.334]         ...future.stdout <- NULL
[13:20:51.334]     }
[13:20:51.334]     ...future.result$conditions <- ...future.conditions
[13:20:51.334]     ...future.result$finished <- base::Sys.time()
[13:20:51.334]     ...future.result
[13:20:51.334] }
[13:20:51.337] assign_globals() ...
[13:20:51.337] List of 1
[13:20:51.337]  $ a: num 3
[13:20:51.337]  - attr(*, "where")=List of 1
[13:20:51.337]   ..$ a:<environment: R_EmptyEnv> 
[13:20:51.337]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:51.337]  - attr(*, "resolved")= logi TRUE
[13:20:51.337]  - attr(*, "total_size")= num 56
[13:20:51.337]  - attr(*, "already-done")= logi TRUE
[13:20:51.341] - copied ‘a’ to environment
[13:20:51.341] assign_globals() ... done
[13:20:51.341] requestCore(): workers = 2
[13:20:51.343] MulticoreFuture started
[13:20:51.344] - Launch lazy future ... done
[13:20:51.344] run() for ‘MulticoreFuture’ ... done
[13:20:51.344] plan(): Setting new future strategy stack:
[13:20:51.345] List of future strategies:
[13:20:51.345] 1. sequential:
[13:20:51.345]    - args: function (..., envir = parent.frame())
[13:20:51.345]    - tweaked: FALSE
[13:20:51.345]    - call: NULL
[13:20:51.346] plan(): nbrOfWorkers() = 1
[13:20:51.349] plan(): Setting new future strategy stack:
[13:20:51.350] List of future strategies:
[13:20:51.350] 1. multicore:
[13:20:51.350]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.350]    - tweaked: FALSE
[13:20:51.350]    - call: plan(strategy)
[13:20:51.355] plan(): nbrOfWorkers() = 2
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.358] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.359] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:51.362] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:51.362] Searching for globals ... DONE
[13:20:51.362] Resolving globals: TRUE
[13:20:51.362] Resolving any globals that are futures ...
[13:20:51.362] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:51.362] Resolving any globals that are futures ... DONE
[13:20:51.363] Resolving futures part of globals (recursively) ...
[13:20:51.363] resolve() on list ...
[13:20:51.363]  recursive: 99
[13:20:51.363]  length: 2
[13:20:51.364]  elements: ‘a’, ‘ii’
[13:20:51.364]  length: 1 (resolved future 1)
[13:20:51.364]  length: 0 (resolved future 2)
[13:20:51.364] resolve() on list ... DONE
[13:20:51.364] - globals: [2] ‘a’, ‘ii’
[13:20:51.364] Resolving futures part of globals (recursively) ... DONE
[13:20:51.364] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:51.365] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:20:51.365] - globals: [2] ‘a’, ‘ii’
[13:20:51.365] 
[13:20:51.365] getGlobalsAndPackages() ... DONE
[13:20:51.366] run() for ‘Future’ ...
[13:20:51.366] - state: ‘created’
[13:20:51.366] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.370] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.370] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.370]   - Field: ‘label’
[13:20:51.371]   - Field: ‘local’
[13:20:51.371]   - Field: ‘owner’
[13:20:51.371]   - Field: ‘envir’
[13:20:51.371]   - Field: ‘workers’
[13:20:51.371]   - Field: ‘packages’
[13:20:51.371]   - Field: ‘gc’
[13:20:51.371]   - Field: ‘job’
[13:20:51.371]   - Field: ‘conditions’
[13:20:51.371]   - Field: ‘expr’
[13:20:51.372]   - Field: ‘uuid’
[13:20:51.372]   - Field: ‘seed’
[13:20:51.372]   - Field: ‘version’
[13:20:51.372]   - Field: ‘result’
[13:20:51.372]   - Field: ‘asynchronous’
[13:20:51.372]   - Field: ‘calls’
[13:20:51.372]   - Field: ‘globals’
[13:20:51.372]   - Field: ‘stdout’
[13:20:51.372]   - Field: ‘earlySignal’
[13:20:51.373]   - Field: ‘lazy’
[13:20:51.373]   - Field: ‘state’
[13:20:51.373] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.373] - Launch lazy future ...
[13:20:51.373] Packages needed by the future expression (n = 0): <none>
[13:20:51.373] Packages needed by future strategies (n = 0): <none>
[13:20:51.374] {
[13:20:51.374]     {
[13:20:51.374]         {
[13:20:51.374]             ...future.startTime <- base::Sys.time()
[13:20:51.374]             {
[13:20:51.374]                 {
[13:20:51.374]                   {
[13:20:51.374]                     {
[13:20:51.374]                       base::local({
[13:20:51.374]                         has_future <- base::requireNamespace("future", 
[13:20:51.374]                           quietly = TRUE)
[13:20:51.374]                         if (has_future) {
[13:20:51.374]                           ns <- base::getNamespace("future")
[13:20:51.374]                           version <- ns[[".package"]][["version"]]
[13:20:51.374]                           if (is.null(version)) 
[13:20:51.374]                             version <- utils::packageVersion("future")
[13:20:51.374]                         }
[13:20:51.374]                         else {
[13:20:51.374]                           version <- NULL
[13:20:51.374]                         }
[13:20:51.374]                         if (!has_future || version < "1.8.0") {
[13:20:51.374]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.374]                             "", base::R.version$version.string), 
[13:20:51.374]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:51.374]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:51.374]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.374]                               "release", "version")], collapse = " "), 
[13:20:51.374]                             hostname = base::Sys.info()[["nodename"]])
[13:20:51.374]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.374]                             info)
[13:20:51.374]                           info <- base::paste(info, collapse = "; ")
[13:20:51.374]                           if (!has_future) {
[13:20:51.374]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.374]                               info)
[13:20:51.374]                           }
[13:20:51.374]                           else {
[13:20:51.374]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.374]                               info, version)
[13:20:51.374]                           }
[13:20:51.374]                           base::stop(msg)
[13:20:51.374]                         }
[13:20:51.374]                       })
[13:20:51.374]                     }
[13:20:51.374]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.374]                     base::options(mc.cores = 1L)
[13:20:51.374]                   }
[13:20:51.374]                   options(future.plan = NULL)
[13:20:51.374]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.374]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.374]                 }
[13:20:51.374]                 ...future.workdir <- getwd()
[13:20:51.374]             }
[13:20:51.374]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.374]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.374]         }
[13:20:51.374]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.374]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:51.374]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.374]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.374]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.374]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.374]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.374]             base::names(...future.oldOptions))
[13:20:51.374]     }
[13:20:51.374]     if (FALSE) {
[13:20:51.374]     }
[13:20:51.374]     else {
[13:20:51.374]         if (TRUE) {
[13:20:51.374]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.374]                 open = "w")
[13:20:51.374]         }
[13:20:51.374]         else {
[13:20:51.374]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.374]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.374]         }
[13:20:51.374]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.374]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.374]             base::sink(type = "output", split = FALSE)
[13:20:51.374]             base::close(...future.stdout)
[13:20:51.374]         }, add = TRUE)
[13:20:51.374]     }
[13:20:51.374]     ...future.frame <- base::sys.nframe()
[13:20:51.374]     ...future.conditions <- base::list()
[13:20:51.374]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.374]     if (FALSE) {
[13:20:51.374]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.374]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.374]     }
[13:20:51.374]     ...future.result <- base::tryCatch({
[13:20:51.374]         base::withCallingHandlers({
[13:20:51.374]             ...future.value <- base::withVisible(base::local({
[13:20:51.374]                 withCallingHandlers({
[13:20:51.374]                   {
[13:20:51.374]                     b <- a * ii
[13:20:51.374]                     a <- 0
[13:20:51.374]                     b
[13:20:51.374]                   }
[13:20:51.374]                 }, immediateCondition = function(cond) {
[13:20:51.374]                   save_rds <- function (object, pathname, ...) 
[13:20:51.374]                   {
[13:20:51.374]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.374]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.374]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.374]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.374]                         fi_tmp[["mtime"]])
[13:20:51.374]                     }
[13:20:51.374]                     tryCatch({
[13:20:51.374]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.374]                     }, error = function(ex) {
[13:20:51.374]                       msg <- conditionMessage(ex)
[13:20:51.374]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.374]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.374]                         fi_tmp[["mtime"]], msg)
[13:20:51.374]                       ex$message <- msg
[13:20:51.374]                       stop(ex)
[13:20:51.374]                     })
[13:20:51.374]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.374]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.374]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.374]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.374]                       fi <- file.info(pathname)
[13:20:51.374]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.374]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.374]                         fi[["size"]], fi[["mtime"]])
[13:20:51.374]                       stop(msg)
[13:20:51.374]                     }
[13:20:51.374]                     invisible(pathname)
[13:20:51.374]                   }
[13:20:51.374]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.374]                     rootPath = tempdir()) 
[13:20:51.374]                   {
[13:20:51.374]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.374]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.374]                       tmpdir = path, fileext = ".rds")
[13:20:51.374]                     save_rds(obj, file)
[13:20:51.374]                   }
[13:20:51.374]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.374]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.374]                   {
[13:20:51.374]                     inherits <- base::inherits
[13:20:51.374]                     invokeRestart <- base::invokeRestart
[13:20:51.374]                     is.null <- base::is.null
[13:20:51.374]                     muffled <- FALSE
[13:20:51.374]                     if (inherits(cond, "message")) {
[13:20:51.374]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.374]                       if (muffled) 
[13:20:51.374]                         invokeRestart("muffleMessage")
[13:20:51.374]                     }
[13:20:51.374]                     else if (inherits(cond, "warning")) {
[13:20:51.374]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.374]                       if (muffled) 
[13:20:51.374]                         invokeRestart("muffleWarning")
[13:20:51.374]                     }
[13:20:51.374]                     else if (inherits(cond, "condition")) {
[13:20:51.374]                       if (!is.null(pattern)) {
[13:20:51.374]                         computeRestarts <- base::computeRestarts
[13:20:51.374]                         grepl <- base::grepl
[13:20:51.374]                         restarts <- computeRestarts(cond)
[13:20:51.374]                         for (restart in restarts) {
[13:20:51.374]                           name <- restart$name
[13:20:51.374]                           if (is.null(name)) 
[13:20:51.374]                             next
[13:20:51.374]                           if (!grepl(pattern, name)) 
[13:20:51.374]                             next
[13:20:51.374]                           invokeRestart(restart)
[13:20:51.374]                           muffled <- TRUE
[13:20:51.374]                           break
[13:20:51.374]                         }
[13:20:51.374]                       }
[13:20:51.374]                     }
[13:20:51.374]                     invisible(muffled)
[13:20:51.374]                   }
[13:20:51.374]                   muffleCondition(cond)
[13:20:51.374]                 })
[13:20:51.374]             }))
[13:20:51.374]             future::FutureResult(value = ...future.value$value, 
[13:20:51.374]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.374]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.374]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.374]                     ...future.globalenv.names))
[13:20:51.374]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.374]         }, condition = base::local({
[13:20:51.374]             c <- base::c
[13:20:51.374]             inherits <- base::inherits
[13:20:51.374]             invokeRestart <- base::invokeRestart
[13:20:51.374]             length <- base::length
[13:20:51.374]             list <- base::list
[13:20:51.374]             seq.int <- base::seq.int
[13:20:51.374]             signalCondition <- base::signalCondition
[13:20:51.374]             sys.calls <- base::sys.calls
[13:20:51.374]             `[[` <- base::`[[`
[13:20:51.374]             `+` <- base::`+`
[13:20:51.374]             `<<-` <- base::`<<-`
[13:20:51.374]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.374]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.374]                   3L)]
[13:20:51.374]             }
[13:20:51.374]             function(cond) {
[13:20:51.374]                 is_error <- inherits(cond, "error")
[13:20:51.374]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.374]                   NULL)
[13:20:51.374]                 if (is_error) {
[13:20:51.374]                   sessionInformation <- function() {
[13:20:51.374]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.374]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.374]                       search = base::search(), system = base::Sys.info())
[13:20:51.374]                   }
[13:20:51.374]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.374]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.374]                     cond$call), session = sessionInformation(), 
[13:20:51.374]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.374]                   signalCondition(cond)
[13:20:51.374]                 }
[13:20:51.374]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.374]                 "immediateCondition"))) {
[13:20:51.374]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.374]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.374]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.374]                   if (TRUE && !signal) {
[13:20:51.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.374]                     {
[13:20:51.374]                       inherits <- base::inherits
[13:20:51.374]                       invokeRestart <- base::invokeRestart
[13:20:51.374]                       is.null <- base::is.null
[13:20:51.374]                       muffled <- FALSE
[13:20:51.374]                       if (inherits(cond, "message")) {
[13:20:51.374]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.374]                         if (muffled) 
[13:20:51.374]                           invokeRestart("muffleMessage")
[13:20:51.374]                       }
[13:20:51.374]                       else if (inherits(cond, "warning")) {
[13:20:51.374]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.374]                         if (muffled) 
[13:20:51.374]                           invokeRestart("muffleWarning")
[13:20:51.374]                       }
[13:20:51.374]                       else if (inherits(cond, "condition")) {
[13:20:51.374]                         if (!is.null(pattern)) {
[13:20:51.374]                           computeRestarts <- base::computeRestarts
[13:20:51.374]                           grepl <- base::grepl
[13:20:51.374]                           restarts <- computeRestarts(cond)
[13:20:51.374]                           for (restart in restarts) {
[13:20:51.374]                             name <- restart$name
[13:20:51.374]                             if (is.null(name)) 
[13:20:51.374]                               next
[13:20:51.374]                             if (!grepl(pattern, name)) 
[13:20:51.374]                               next
[13:20:51.374]                             invokeRestart(restart)
[13:20:51.374]                             muffled <- TRUE
[13:20:51.374]                             break
[13:20:51.374]                           }
[13:20:51.374]                         }
[13:20:51.374]                       }
[13:20:51.374]                       invisible(muffled)
[13:20:51.374]                     }
[13:20:51.374]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.374]                   }
[13:20:51.374]                 }
[13:20:51.374]                 else {
[13:20:51.374]                   if (TRUE) {
[13:20:51.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.374]                     {
[13:20:51.374]                       inherits <- base::inherits
[13:20:51.374]                       invokeRestart <- base::invokeRestart
[13:20:51.374]                       is.null <- base::is.null
[13:20:51.374]                       muffled <- FALSE
[13:20:51.374]                       if (inherits(cond, "message")) {
[13:20:51.374]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.374]                         if (muffled) 
[13:20:51.374]                           invokeRestart("muffleMessage")
[13:20:51.374]                       }
[13:20:51.374]                       else if (inherits(cond, "warning")) {
[13:20:51.374]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.374]                         if (muffled) 
[13:20:51.374]                           invokeRestart("muffleWarning")
[13:20:51.374]                       }
[13:20:51.374]                       else if (inherits(cond, "condition")) {
[13:20:51.374]                         if (!is.null(pattern)) {
[13:20:51.374]                           computeRestarts <- base::computeRestarts
[13:20:51.374]                           grepl <- base::grepl
[13:20:51.374]                           restarts <- computeRestarts(cond)
[13:20:51.374]                           for (restart in restarts) {
[13:20:51.374]                             name <- restart$name
[13:20:51.374]                             if (is.null(name)) 
[13:20:51.374]                               next
[13:20:51.374]                             if (!grepl(pattern, name)) 
[13:20:51.374]                               next
[13:20:51.374]                             invokeRestart(restart)
[13:20:51.374]                             muffled <- TRUE
[13:20:51.374]                             break
[13:20:51.374]                           }
[13:20:51.374]                         }
[13:20:51.374]                       }
[13:20:51.374]                       invisible(muffled)
[13:20:51.374]                     }
[13:20:51.374]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.374]                   }
[13:20:51.374]                 }
[13:20:51.374]             }
[13:20:51.374]         }))
[13:20:51.374]     }, error = function(ex) {
[13:20:51.374]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.374]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.374]                 ...future.rng), started = ...future.startTime, 
[13:20:51.374]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.374]             version = "1.8"), class = "FutureResult")
[13:20:51.374]     }, finally = {
[13:20:51.374]         if (!identical(...future.workdir, getwd())) 
[13:20:51.374]             setwd(...future.workdir)
[13:20:51.374]         {
[13:20:51.374]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.374]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.374]             }
[13:20:51.374]             base::options(...future.oldOptions)
[13:20:51.374]             if (.Platform$OS.type == "windows") {
[13:20:51.374]                 old_names <- names(...future.oldEnvVars)
[13:20:51.374]                 envs <- base::Sys.getenv()
[13:20:51.374]                 names <- names(envs)
[13:20:51.374]                 common <- intersect(names, old_names)
[13:20:51.374]                 added <- setdiff(names, old_names)
[13:20:51.374]                 removed <- setdiff(old_names, names)
[13:20:51.374]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.374]                   envs[common]]
[13:20:51.374]                 NAMES <- toupper(changed)
[13:20:51.374]                 args <- list()
[13:20:51.374]                 for (kk in seq_along(NAMES)) {
[13:20:51.374]                   name <- changed[[kk]]
[13:20:51.374]                   NAME <- NAMES[[kk]]
[13:20:51.374]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.374]                     next
[13:20:51.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.374]                 }
[13:20:51.374]                 NAMES <- toupper(added)
[13:20:51.374]                 for (kk in seq_along(NAMES)) {
[13:20:51.374]                   name <- added[[kk]]
[13:20:51.374]                   NAME <- NAMES[[kk]]
[13:20:51.374]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.374]                     next
[13:20:51.374]                   args[[name]] <- ""
[13:20:51.374]                 }
[13:20:51.374]                 NAMES <- toupper(removed)
[13:20:51.374]                 for (kk in seq_along(NAMES)) {
[13:20:51.374]                   name <- removed[[kk]]
[13:20:51.374]                   NAME <- NAMES[[kk]]
[13:20:51.374]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.374]                     next
[13:20:51.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.374]                 }
[13:20:51.374]                 if (length(args) > 0) 
[13:20:51.374]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.374]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.374]             }
[13:20:51.374]             else {
[13:20:51.374]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.374]             }
[13:20:51.374]             {
[13:20:51.374]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.374]                   0L) {
[13:20:51.374]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.374]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.374]                   base::options(opts)
[13:20:51.374]                 }
[13:20:51.374]                 {
[13:20:51.374]                   {
[13:20:51.374]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.374]                     NULL
[13:20:51.374]                   }
[13:20:51.374]                   options(future.plan = NULL)
[13:20:51.374]                   if (is.na(NA_character_)) 
[13:20:51.374]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.374]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.374]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.374]                     envir = parent.frame()) 
[13:20:51.374]                   {
[13:20:51.374]                     default_workers <- missing(workers)
[13:20:51.374]                     if (is.function(workers)) 
[13:20:51.374]                       workers <- workers()
[13:20:51.374]                     workers <- structure(as.integer(workers), 
[13:20:51.374]                       class = class(workers))
[13:20:51.374]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.374]                       1L)
[13:20:51.374]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.374]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.374]                       if (default_workers) 
[13:20:51.374]                         supportsMulticore(warn = TRUE)
[13:20:51.374]                       return(sequential(..., envir = envir))
[13:20:51.374]                     }
[13:20:51.374]                     oopts <- options(mc.cores = workers)
[13:20:51.374]                     on.exit(options(oopts))
[13:20:51.374]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.374]                       envir = envir)
[13:20:51.374]                     if (!future$lazy) 
[13:20:51.374]                       future <- run(future)
[13:20:51.374]                     invisible(future)
[13:20:51.374]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.374]                 }
[13:20:51.374]             }
[13:20:51.374]         }
[13:20:51.374]     })
[13:20:51.374]     if (TRUE) {
[13:20:51.374]         base::sink(type = "output", split = FALSE)
[13:20:51.374]         if (TRUE) {
[13:20:51.374]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.374]         }
[13:20:51.374]         else {
[13:20:51.374]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.374]         }
[13:20:51.374]         base::close(...future.stdout)
[13:20:51.374]         ...future.stdout <- NULL
[13:20:51.374]     }
[13:20:51.374]     ...future.result$conditions <- ...future.conditions
[13:20:51.374]     ...future.result$finished <- base::Sys.time()
[13:20:51.374]     ...future.result
[13:20:51.374] }
[13:20:51.377] assign_globals() ...
[13:20:51.377] List of 2
[13:20:51.377]  $ a : num 1
[13:20:51.377]  $ ii: int 1
[13:20:51.377]  - attr(*, "where")=List of 2
[13:20:51.377]   ..$ a :<environment: R_EmptyEnv> 
[13:20:51.377]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:51.377]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:51.377]  - attr(*, "resolved")= logi TRUE
[13:20:51.377]  - attr(*, "total_size")= num 112
[13:20:51.377]  - attr(*, "already-done")= logi TRUE
[13:20:51.380] - copied ‘a’ to environment
[13:20:51.381] - copied ‘ii’ to environment
[13:20:51.381] assign_globals() ... done
[13:20:51.381] requestCore(): workers = 2
[13:20:51.383] MulticoreFuture started
[13:20:51.383] - Launch lazy future ... done
[13:20:51.384] plan(): Setting new future strategy stack:
[13:20:51.388] run() for ‘MulticoreFuture’ ... done
[13:20:51.388] List of future strategies:
[13:20:51.388] 1. sequential:
[13:20:51.388]    - args: function (..., envir = parent.frame())
[13:20:51.388]    - tweaked: FALSE
[13:20:51.388]    - call: NULL
[13:20:51.390] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.390] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.391] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:51.392] plan(): Setting new future strategy stack:
[13:20:51.392] List of future strategies:
[13:20:51.392] 1. multicore:
[13:20:51.392]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.392]    - tweaked: FALSE
[13:20:51.392]    - call: plan(strategy)
[13:20:51.397] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:51.397] Searching for globals ... DONE
[13:20:51.397] Resolving globals: TRUE
[13:20:51.397] plan(): nbrOfWorkers() = 2
[13:20:51.397] Resolving any globals that are futures ...
[13:20:51.398] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:51.398] Resolving any globals that are futures ... DONE
[13:20:51.398] Resolving futures part of globals (recursively) ...
[13:20:51.399] resolve() on list ...
[13:20:51.399]  recursive: 99
[13:20:51.400]  length: 2
[13:20:51.400]  elements: ‘a’, ‘ii’
[13:20:51.400]  length: 1 (resolved future 1)
[13:20:51.400]  length: 0 (resolved future 2)
[13:20:51.400] resolve() on list ... DONE
[13:20:51.400] - globals: [2] ‘a’, ‘ii’
[13:20:51.401] Resolving futures part of globals (recursively) ... DONE
[13:20:51.401] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:51.402] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:20:51.402] - globals: [2] ‘a’, ‘ii’
[13:20:51.402] 
[13:20:51.402] getGlobalsAndPackages() ... DONE
[13:20:51.402] run() for ‘Future’ ...
[13:20:51.403] - state: ‘created’
[13:20:51.403] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.407] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.407] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.408]   - Field: ‘label’
[13:20:51.408]   - Field: ‘local’
[13:20:51.408]   - Field: ‘owner’
[13:20:51.408]   - Field: ‘envir’
[13:20:51.408]   - Field: ‘workers’
[13:20:51.408]   - Field: ‘packages’
[13:20:51.408]   - Field: ‘gc’
[13:20:51.408]   - Field: ‘job’
[13:20:51.409]   - Field: ‘conditions’
[13:20:51.409]   - Field: ‘expr’
[13:20:51.409]   - Field: ‘uuid’
[13:20:51.409]   - Field: ‘seed’
[13:20:51.409]   - Field: ‘version’
[13:20:51.409]   - Field: ‘result’
[13:20:51.409]   - Field: ‘asynchronous’
[13:20:51.410]   - Field: ‘calls’
[13:20:51.410]   - Field: ‘globals’
[13:20:51.410]   - Field: ‘stdout’
[13:20:51.410]   - Field: ‘earlySignal’
[13:20:51.410]   - Field: ‘lazy’
[13:20:51.410]   - Field: ‘state’
[13:20:51.410] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.410] - Launch lazy future ...
[13:20:51.411] Packages needed by the future expression (n = 0): <none>
[13:20:51.411] Packages needed by future strategies (n = 0): <none>
[13:20:51.412] {
[13:20:51.412]     {
[13:20:51.412]         {
[13:20:51.412]             ...future.startTime <- base::Sys.time()
[13:20:51.412]             {
[13:20:51.412]                 {
[13:20:51.412]                   {
[13:20:51.412]                     {
[13:20:51.412]                       base::local({
[13:20:51.412]                         has_future <- base::requireNamespace("future", 
[13:20:51.412]                           quietly = TRUE)
[13:20:51.412]                         if (has_future) {
[13:20:51.412]                           ns <- base::getNamespace("future")
[13:20:51.412]                           version <- ns[[".package"]][["version"]]
[13:20:51.412]                           if (is.null(version)) 
[13:20:51.412]                             version <- utils::packageVersion("future")
[13:20:51.412]                         }
[13:20:51.412]                         else {
[13:20:51.412]                           version <- NULL
[13:20:51.412]                         }
[13:20:51.412]                         if (!has_future || version < "1.8.0") {
[13:20:51.412]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.412]                             "", base::R.version$version.string), 
[13:20:51.412]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:51.412]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:51.412]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.412]                               "release", "version")], collapse = " "), 
[13:20:51.412]                             hostname = base::Sys.info()[["nodename"]])
[13:20:51.412]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.412]                             info)
[13:20:51.412]                           info <- base::paste(info, collapse = "; ")
[13:20:51.412]                           if (!has_future) {
[13:20:51.412]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.412]                               info)
[13:20:51.412]                           }
[13:20:51.412]                           else {
[13:20:51.412]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.412]                               info, version)
[13:20:51.412]                           }
[13:20:51.412]                           base::stop(msg)
[13:20:51.412]                         }
[13:20:51.412]                       })
[13:20:51.412]                     }
[13:20:51.412]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.412]                     base::options(mc.cores = 1L)
[13:20:51.412]                   }
[13:20:51.412]                   options(future.plan = NULL)
[13:20:51.412]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.412]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.412]                 }
[13:20:51.412]                 ...future.workdir <- getwd()
[13:20:51.412]             }
[13:20:51.412]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.412]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.412]         }
[13:20:51.412]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.412]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:51.412]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.412]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.412]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.412]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.412]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.412]             base::names(...future.oldOptions))
[13:20:51.412]     }
[13:20:51.412]     if (FALSE) {
[13:20:51.412]     }
[13:20:51.412]     else {
[13:20:51.412]         if (TRUE) {
[13:20:51.412]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.412]                 open = "w")
[13:20:51.412]         }
[13:20:51.412]         else {
[13:20:51.412]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.412]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.412]         }
[13:20:51.412]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.412]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.412]             base::sink(type = "output", split = FALSE)
[13:20:51.412]             base::close(...future.stdout)
[13:20:51.412]         }, add = TRUE)
[13:20:51.412]     }
[13:20:51.412]     ...future.frame <- base::sys.nframe()
[13:20:51.412]     ...future.conditions <- base::list()
[13:20:51.412]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.412]     if (FALSE) {
[13:20:51.412]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.412]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.412]     }
[13:20:51.412]     ...future.result <- base::tryCatch({
[13:20:51.412]         base::withCallingHandlers({
[13:20:51.412]             ...future.value <- base::withVisible(base::local({
[13:20:51.412]                 withCallingHandlers({
[13:20:51.412]                   {
[13:20:51.412]                     b <- a * ii
[13:20:51.412]                     a <- 0
[13:20:51.412]                     b
[13:20:51.412]                   }
[13:20:51.412]                 }, immediateCondition = function(cond) {
[13:20:51.412]                   save_rds <- function (object, pathname, ...) 
[13:20:51.412]                   {
[13:20:51.412]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.412]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.412]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.412]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.412]                         fi_tmp[["mtime"]])
[13:20:51.412]                     }
[13:20:51.412]                     tryCatch({
[13:20:51.412]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.412]                     }, error = function(ex) {
[13:20:51.412]                       msg <- conditionMessage(ex)
[13:20:51.412]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.412]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.412]                         fi_tmp[["mtime"]], msg)
[13:20:51.412]                       ex$message <- msg
[13:20:51.412]                       stop(ex)
[13:20:51.412]                     })
[13:20:51.412]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.412]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.412]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.412]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.412]                       fi <- file.info(pathname)
[13:20:51.412]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.412]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.412]                         fi[["size"]], fi[["mtime"]])
[13:20:51.412]                       stop(msg)
[13:20:51.412]                     }
[13:20:51.412]                     invisible(pathname)
[13:20:51.412]                   }
[13:20:51.412]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.412]                     rootPath = tempdir()) 
[13:20:51.412]                   {
[13:20:51.412]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.412]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.412]                       tmpdir = path, fileext = ".rds")
[13:20:51.412]                     save_rds(obj, file)
[13:20:51.412]                   }
[13:20:51.412]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.412]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.412]                   {
[13:20:51.412]                     inherits <- base::inherits
[13:20:51.412]                     invokeRestart <- base::invokeRestart
[13:20:51.412]                     is.null <- base::is.null
[13:20:51.412]                     muffled <- FALSE
[13:20:51.412]                     if (inherits(cond, "message")) {
[13:20:51.412]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.412]                       if (muffled) 
[13:20:51.412]                         invokeRestart("muffleMessage")
[13:20:51.412]                     }
[13:20:51.412]                     else if (inherits(cond, "warning")) {
[13:20:51.412]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.412]                       if (muffled) 
[13:20:51.412]                         invokeRestart("muffleWarning")
[13:20:51.412]                     }
[13:20:51.412]                     else if (inherits(cond, "condition")) {
[13:20:51.412]                       if (!is.null(pattern)) {
[13:20:51.412]                         computeRestarts <- base::computeRestarts
[13:20:51.412]                         grepl <- base::grepl
[13:20:51.412]                         restarts <- computeRestarts(cond)
[13:20:51.412]                         for (restart in restarts) {
[13:20:51.412]                           name <- restart$name
[13:20:51.412]                           if (is.null(name)) 
[13:20:51.412]                             next
[13:20:51.412]                           if (!grepl(pattern, name)) 
[13:20:51.412]                             next
[13:20:51.412]                           invokeRestart(restart)
[13:20:51.412]                           muffled <- TRUE
[13:20:51.412]                           break
[13:20:51.412]                         }
[13:20:51.412]                       }
[13:20:51.412]                     }
[13:20:51.412]                     invisible(muffled)
[13:20:51.412]                   }
[13:20:51.412]                   muffleCondition(cond)
[13:20:51.412]                 })
[13:20:51.412]             }))
[13:20:51.412]             future::FutureResult(value = ...future.value$value, 
[13:20:51.412]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.412]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.412]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.412]                     ...future.globalenv.names))
[13:20:51.412]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.412]         }, condition = base::local({
[13:20:51.412]             c <- base::c
[13:20:51.412]             inherits <- base::inherits
[13:20:51.412]             invokeRestart <- base::invokeRestart
[13:20:51.412]             length <- base::length
[13:20:51.412]             list <- base::list
[13:20:51.412]             seq.int <- base::seq.int
[13:20:51.412]             signalCondition <- base::signalCondition
[13:20:51.412]             sys.calls <- base::sys.calls
[13:20:51.412]             `[[` <- base::`[[`
[13:20:51.412]             `+` <- base::`+`
[13:20:51.412]             `<<-` <- base::`<<-`
[13:20:51.412]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.412]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.412]                   3L)]
[13:20:51.412]             }
[13:20:51.412]             function(cond) {
[13:20:51.412]                 is_error <- inherits(cond, "error")
[13:20:51.412]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.412]                   NULL)
[13:20:51.412]                 if (is_error) {
[13:20:51.412]                   sessionInformation <- function() {
[13:20:51.412]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.412]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.412]                       search = base::search(), system = base::Sys.info())
[13:20:51.412]                   }
[13:20:51.412]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.412]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.412]                     cond$call), session = sessionInformation(), 
[13:20:51.412]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.412]                   signalCondition(cond)
[13:20:51.412]                 }
[13:20:51.412]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.412]                 "immediateCondition"))) {
[13:20:51.412]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.412]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.412]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.412]                   if (TRUE && !signal) {
[13:20:51.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.412]                     {
[13:20:51.412]                       inherits <- base::inherits
[13:20:51.412]                       invokeRestart <- base::invokeRestart
[13:20:51.412]                       is.null <- base::is.null
[13:20:51.412]                       muffled <- FALSE
[13:20:51.412]                       if (inherits(cond, "message")) {
[13:20:51.412]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.412]                         if (muffled) 
[13:20:51.412]                           invokeRestart("muffleMessage")
[13:20:51.412]                       }
[13:20:51.412]                       else if (inherits(cond, "warning")) {
[13:20:51.412]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.412]                         if (muffled) 
[13:20:51.412]                           invokeRestart("muffleWarning")
[13:20:51.412]                       }
[13:20:51.412]                       else if (inherits(cond, "condition")) {
[13:20:51.412]                         if (!is.null(pattern)) {
[13:20:51.412]                           computeRestarts <- base::computeRestarts
[13:20:51.412]                           grepl <- base::grepl
[13:20:51.412]                           restarts <- computeRestarts(cond)
[13:20:51.412]                           for (restart in restarts) {
[13:20:51.412]                             name <- restart$name
[13:20:51.412]                             if (is.null(name)) 
[13:20:51.412]                               next
[13:20:51.412]                             if (!grepl(pattern, name)) 
[13:20:51.412]                               next
[13:20:51.412]                             invokeRestart(restart)
[13:20:51.412]                             muffled <- TRUE
[13:20:51.412]                             break
[13:20:51.412]                           }
[13:20:51.412]                         }
[13:20:51.412]                       }
[13:20:51.412]                       invisible(muffled)
[13:20:51.412]                     }
[13:20:51.412]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.412]                   }
[13:20:51.412]                 }
[13:20:51.412]                 else {
[13:20:51.412]                   if (TRUE) {
[13:20:51.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.412]                     {
[13:20:51.412]                       inherits <- base::inherits
[13:20:51.412]                       invokeRestart <- base::invokeRestart
[13:20:51.412]                       is.null <- base::is.null
[13:20:51.412]                       muffled <- FALSE
[13:20:51.412]                       if (inherits(cond, "message")) {
[13:20:51.412]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.412]                         if (muffled) 
[13:20:51.412]                           invokeRestart("muffleMessage")
[13:20:51.412]                       }
[13:20:51.412]                       else if (inherits(cond, "warning")) {
[13:20:51.412]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.412]                         if (muffled) 
[13:20:51.412]                           invokeRestart("muffleWarning")
[13:20:51.412]                       }
[13:20:51.412]                       else if (inherits(cond, "condition")) {
[13:20:51.412]                         if (!is.null(pattern)) {
[13:20:51.412]                           computeRestarts <- base::computeRestarts
[13:20:51.412]                           grepl <- base::grepl
[13:20:51.412]                           restarts <- computeRestarts(cond)
[13:20:51.412]                           for (restart in restarts) {
[13:20:51.412]                             name <- restart$name
[13:20:51.412]                             if (is.null(name)) 
[13:20:51.412]                               next
[13:20:51.412]                             if (!grepl(pattern, name)) 
[13:20:51.412]                               next
[13:20:51.412]                             invokeRestart(restart)
[13:20:51.412]                             muffled <- TRUE
[13:20:51.412]                             break
[13:20:51.412]                           }
[13:20:51.412]                         }
[13:20:51.412]                       }
[13:20:51.412]                       invisible(muffled)
[13:20:51.412]                     }
[13:20:51.412]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.412]                   }
[13:20:51.412]                 }
[13:20:51.412]             }
[13:20:51.412]         }))
[13:20:51.412]     }, error = function(ex) {
[13:20:51.412]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.412]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.412]                 ...future.rng), started = ...future.startTime, 
[13:20:51.412]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.412]             version = "1.8"), class = "FutureResult")
[13:20:51.412]     }, finally = {
[13:20:51.412]         if (!identical(...future.workdir, getwd())) 
[13:20:51.412]             setwd(...future.workdir)
[13:20:51.412]         {
[13:20:51.412]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.412]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.412]             }
[13:20:51.412]             base::options(...future.oldOptions)
[13:20:51.412]             if (.Platform$OS.type == "windows") {
[13:20:51.412]                 old_names <- names(...future.oldEnvVars)
[13:20:51.412]                 envs <- base::Sys.getenv()
[13:20:51.412]                 names <- names(envs)
[13:20:51.412]                 common <- intersect(names, old_names)
[13:20:51.412]                 added <- setdiff(names, old_names)
[13:20:51.412]                 removed <- setdiff(old_names, names)
[13:20:51.412]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.412]                   envs[common]]
[13:20:51.412]                 NAMES <- toupper(changed)
[13:20:51.412]                 args <- list()
[13:20:51.412]                 for (kk in seq_along(NAMES)) {
[13:20:51.412]                   name <- changed[[kk]]
[13:20:51.412]                   NAME <- NAMES[[kk]]
[13:20:51.412]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.412]                     next
[13:20:51.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.412]                 }
[13:20:51.412]                 NAMES <- toupper(added)
[13:20:51.412]                 for (kk in seq_along(NAMES)) {
[13:20:51.412]                   name <- added[[kk]]
[13:20:51.412]                   NAME <- NAMES[[kk]]
[13:20:51.412]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.412]                     next
[13:20:51.412]                   args[[name]] <- ""
[13:20:51.412]                 }
[13:20:51.412]                 NAMES <- toupper(removed)
[13:20:51.412]                 for (kk in seq_along(NAMES)) {
[13:20:51.412]                   name <- removed[[kk]]
[13:20:51.412]                   NAME <- NAMES[[kk]]
[13:20:51.412]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.412]                     next
[13:20:51.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.412]                 }
[13:20:51.412]                 if (length(args) > 0) 
[13:20:51.412]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.412]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.412]             }
[13:20:51.412]             else {
[13:20:51.412]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.412]             }
[13:20:51.412]             {
[13:20:51.412]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.412]                   0L) {
[13:20:51.412]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.412]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.412]                   base::options(opts)
[13:20:51.412]                 }
[13:20:51.412]                 {
[13:20:51.412]                   {
[13:20:51.412]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.412]                     NULL
[13:20:51.412]                   }
[13:20:51.412]                   options(future.plan = NULL)
[13:20:51.412]                   if (is.na(NA_character_)) 
[13:20:51.412]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.412]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.412]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.412]                     envir = parent.frame()) 
[13:20:51.412]                   {
[13:20:51.412]                     default_workers <- missing(workers)
[13:20:51.412]                     if (is.function(workers)) 
[13:20:51.412]                       workers <- workers()
[13:20:51.412]                     workers <- structure(as.integer(workers), 
[13:20:51.412]                       class = class(workers))
[13:20:51.412]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.412]                       1L)
[13:20:51.412]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.412]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.412]                       if (default_workers) 
[13:20:51.412]                         supportsMulticore(warn = TRUE)
[13:20:51.412]                       return(sequential(..., envir = envir))
[13:20:51.412]                     }
[13:20:51.412]                     oopts <- options(mc.cores = workers)
[13:20:51.412]                     on.exit(options(oopts))
[13:20:51.412]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.412]                       envir = envir)
[13:20:51.412]                     if (!future$lazy) 
[13:20:51.412]                       future <- run(future)
[13:20:51.412]                     invisible(future)
[13:20:51.412]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.412]                 }
[13:20:51.412]             }
[13:20:51.412]         }
[13:20:51.412]     })
[13:20:51.412]     if (TRUE) {
[13:20:51.412]         base::sink(type = "output", split = FALSE)
[13:20:51.412]         if (TRUE) {
[13:20:51.412]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.412]         }
[13:20:51.412]         else {
[13:20:51.412]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.412]         }
[13:20:51.412]         base::close(...future.stdout)
[13:20:51.412]         ...future.stdout <- NULL
[13:20:51.412]     }
[13:20:51.412]     ...future.result$conditions <- ...future.conditions
[13:20:51.412]     ...future.result$finished <- base::Sys.time()
[13:20:51.412]     ...future.result
[13:20:51.412] }
[13:20:51.414] assign_globals() ...
[13:20:51.414] List of 2
[13:20:51.414]  $ a : num 1
[13:20:51.414]  $ ii: int 2
[13:20:51.414]  - attr(*, "where")=List of 2
[13:20:51.414]   ..$ a :<environment: R_EmptyEnv> 
[13:20:51.414]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:51.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:51.414]  - attr(*, "resolved")= logi TRUE
[13:20:51.414]  - attr(*, "total_size")= num 112
[13:20:51.414]  - attr(*, "already-done")= logi TRUE
[13:20:51.418] - copied ‘a’ to environment
[13:20:51.419] - copied ‘ii’ to environment
[13:20:51.419] assign_globals() ... done
[13:20:51.419] requestCore(): workers = 2
[13:20:51.421] MulticoreFuture started
[13:20:51.421] - Launch lazy future ... done
[13:20:51.422] run() for ‘MulticoreFuture’ ... done
[13:20:51.422] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.423] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.422] List of future strategies:
[13:20:51.422] 1. sequential:
[13:20:51.422]    - args: function (..., envir = parent.frame())
[13:20:51.422]    - tweaked: FALSE
[13:20:51.422]    - call: NULL
[13:20:51.423] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:51.423] plan(): nbrOfWorkers() = 1
[13:20:51.425] plan(): Setting new future strategy stack:
[13:20:51.426] List of future strategies:
[13:20:51.426] 1. multicore:
[13:20:51.426]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.426]    - tweaked: FALSE
[13:20:51.426]    - call: plan(strategy)
[13:20:51.427] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:51.427] Searching for globals ... DONE
[13:20:51.427] Resolving globals: TRUE
[13:20:51.427] Resolving any globals that are futures ...
[13:20:51.428] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:51.428] Resolving any globals that are futures ... DONE
[13:20:51.428] Resolving futures part of globals (recursively) ...
[13:20:51.430] plan(): nbrOfWorkers() = 2
[13:20:51.433] resolve() on list ...
[13:20:51.433]  recursive: 99
[13:20:51.433]  length: 2
[13:20:51.434]  elements: ‘a’, ‘ii’
[13:20:51.434]  length: 1 (resolved future 1)
[13:20:51.434]  length: 0 (resolved future 2)
[13:20:51.435] resolve() on list ... DONE
[13:20:51.435] - globals: [2] ‘a’, ‘ii’
[13:20:51.435] Resolving futures part of globals (recursively) ... DONE
[13:20:51.435] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:51.436] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:20:51.436] - globals: [2] ‘a’, ‘ii’
[13:20:51.437] 
[13:20:51.437] getGlobalsAndPackages() ... DONE
[13:20:51.437] run() for ‘Future’ ...
[13:20:51.437] - state: ‘created’
[13:20:51.438] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.443] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.443] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.444]   - Field: ‘label’
[13:20:51.444]   - Field: ‘local’
[13:20:51.444]   - Field: ‘owner’
[13:20:51.444]   - Field: ‘envir’
[13:20:51.445]   - Field: ‘workers’
[13:20:51.445]   - Field: ‘packages’
[13:20:51.445]   - Field: ‘gc’
[13:20:51.445]   - Field: ‘job’
[13:20:51.445]   - Field: ‘conditions’
[13:20:51.445]   - Field: ‘expr’
[13:20:51.446]   - Field: ‘uuid’
[13:20:51.446]   - Field: ‘seed’
[13:20:51.446]   - Field: ‘version’
[13:20:51.446]   - Field: ‘result’
[13:20:51.446]   - Field: ‘asynchronous’
[13:20:51.446]   - Field: ‘calls’
[13:20:51.447]   - Field: ‘globals’
[13:20:51.447]   - Field: ‘stdout’
[13:20:51.447]   - Field: ‘earlySignal’
[13:20:51.447]   - Field: ‘lazy’
[13:20:51.447]   - Field: ‘state’
[13:20:51.447] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.448] - Launch lazy future ...
[13:20:51.448] Packages needed by the future expression (n = 0): <none>
[13:20:51.448] Packages needed by future strategies (n = 0): <none>
[13:20:51.449] {
[13:20:51.449]     {
[13:20:51.449]         {
[13:20:51.449]             ...future.startTime <- base::Sys.time()
[13:20:51.449]             {
[13:20:51.449]                 {
[13:20:51.449]                   {
[13:20:51.449]                     {
[13:20:51.449]                       base::local({
[13:20:51.449]                         has_future <- base::requireNamespace("future", 
[13:20:51.449]                           quietly = TRUE)
[13:20:51.449]                         if (has_future) {
[13:20:51.449]                           ns <- base::getNamespace("future")
[13:20:51.449]                           version <- ns[[".package"]][["version"]]
[13:20:51.449]                           if (is.null(version)) 
[13:20:51.449]                             version <- utils::packageVersion("future")
[13:20:51.449]                         }
[13:20:51.449]                         else {
[13:20:51.449]                           version <- NULL
[13:20:51.449]                         }
[13:20:51.449]                         if (!has_future || version < "1.8.0") {
[13:20:51.449]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.449]                             "", base::R.version$version.string), 
[13:20:51.449]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:51.449]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:51.449]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.449]                               "release", "version")], collapse = " "), 
[13:20:51.449]                             hostname = base::Sys.info()[["nodename"]])
[13:20:51.449]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.449]                             info)
[13:20:51.449]                           info <- base::paste(info, collapse = "; ")
[13:20:51.449]                           if (!has_future) {
[13:20:51.449]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.449]                               info)
[13:20:51.449]                           }
[13:20:51.449]                           else {
[13:20:51.449]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.449]                               info, version)
[13:20:51.449]                           }
[13:20:51.449]                           base::stop(msg)
[13:20:51.449]                         }
[13:20:51.449]                       })
[13:20:51.449]                     }
[13:20:51.449]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.449]                     base::options(mc.cores = 1L)
[13:20:51.449]                   }
[13:20:51.449]                   options(future.plan = NULL)
[13:20:51.449]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.449]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.449]                 }
[13:20:51.449]                 ...future.workdir <- getwd()
[13:20:51.449]             }
[13:20:51.449]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.449]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.449]         }
[13:20:51.449]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.449]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:51.449]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.449]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.449]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.449]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.449]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.449]             base::names(...future.oldOptions))
[13:20:51.449]     }
[13:20:51.449]     if (FALSE) {
[13:20:51.449]     }
[13:20:51.449]     else {
[13:20:51.449]         if (TRUE) {
[13:20:51.449]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.449]                 open = "w")
[13:20:51.449]         }
[13:20:51.449]         else {
[13:20:51.449]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.449]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.449]         }
[13:20:51.449]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.449]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.449]             base::sink(type = "output", split = FALSE)
[13:20:51.449]             base::close(...future.stdout)
[13:20:51.449]         }, add = TRUE)
[13:20:51.449]     }
[13:20:51.449]     ...future.frame <- base::sys.nframe()
[13:20:51.449]     ...future.conditions <- base::list()
[13:20:51.449]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.449]     if (FALSE) {
[13:20:51.449]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.449]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.449]     }
[13:20:51.449]     ...future.result <- base::tryCatch({
[13:20:51.449]         base::withCallingHandlers({
[13:20:51.449]             ...future.value <- base::withVisible(base::local({
[13:20:51.449]                 withCallingHandlers({
[13:20:51.449]                   {
[13:20:51.449]                     b <- a * ii
[13:20:51.449]                     a <- 0
[13:20:51.449]                     b
[13:20:51.449]                   }
[13:20:51.449]                 }, immediateCondition = function(cond) {
[13:20:51.449]                   save_rds <- function (object, pathname, ...) 
[13:20:51.449]                   {
[13:20:51.449]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.449]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.449]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.449]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.449]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.449]                         fi_tmp[["mtime"]])
[13:20:51.449]                     }
[13:20:51.449]                     tryCatch({
[13:20:51.449]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.449]                     }, error = function(ex) {
[13:20:51.449]                       msg <- conditionMessage(ex)
[13:20:51.449]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.449]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.449]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.449]                         fi_tmp[["mtime"]], msg)
[13:20:51.449]                       ex$message <- msg
[13:20:51.449]                       stop(ex)
[13:20:51.449]                     })
[13:20:51.449]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.449]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.449]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.449]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.449]                       fi <- file.info(pathname)
[13:20:51.449]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.449]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.449]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.449]                         fi[["size"]], fi[["mtime"]])
[13:20:51.449]                       stop(msg)
[13:20:51.449]                     }
[13:20:51.449]                     invisible(pathname)
[13:20:51.449]                   }
[13:20:51.449]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.449]                     rootPath = tempdir()) 
[13:20:51.449]                   {
[13:20:51.449]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.449]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.449]                       tmpdir = path, fileext = ".rds")
[13:20:51.449]                     save_rds(obj, file)
[13:20:51.449]                   }
[13:20:51.449]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.449]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.449]                   {
[13:20:51.449]                     inherits <- base::inherits
[13:20:51.449]                     invokeRestart <- base::invokeRestart
[13:20:51.449]                     is.null <- base::is.null
[13:20:51.449]                     muffled <- FALSE
[13:20:51.449]                     if (inherits(cond, "message")) {
[13:20:51.449]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.449]                       if (muffled) 
[13:20:51.449]                         invokeRestart("muffleMessage")
[13:20:51.449]                     }
[13:20:51.449]                     else if (inherits(cond, "warning")) {
[13:20:51.449]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.449]                       if (muffled) 
[13:20:51.449]                         invokeRestart("muffleWarning")
[13:20:51.449]                     }
[13:20:51.449]                     else if (inherits(cond, "condition")) {
[13:20:51.449]                       if (!is.null(pattern)) {
[13:20:51.449]                         computeRestarts <- base::computeRestarts
[13:20:51.449]                         grepl <- base::grepl
[13:20:51.449]                         restarts <- computeRestarts(cond)
[13:20:51.449]                         for (restart in restarts) {
[13:20:51.449]                           name <- restart$name
[13:20:51.449]                           if (is.null(name)) 
[13:20:51.449]                             next
[13:20:51.449]                           if (!grepl(pattern, name)) 
[13:20:51.449]                             next
[13:20:51.449]                           invokeRestart(restart)
[13:20:51.449]                           muffled <- TRUE
[13:20:51.449]                           break
[13:20:51.449]                         }
[13:20:51.449]                       }
[13:20:51.449]                     }
[13:20:51.449]                     invisible(muffled)
[13:20:51.449]                   }
[13:20:51.449]                   muffleCondition(cond)
[13:20:51.449]                 })
[13:20:51.449]             }))
[13:20:51.449]             future::FutureResult(value = ...future.value$value, 
[13:20:51.449]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.449]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.449]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.449]                     ...future.globalenv.names))
[13:20:51.449]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.449]         }, condition = base::local({
[13:20:51.449]             c <- base::c
[13:20:51.449]             inherits <- base::inherits
[13:20:51.449]             invokeRestart <- base::invokeRestart
[13:20:51.449]             length <- base::length
[13:20:51.449]             list <- base::list
[13:20:51.449]             seq.int <- base::seq.int
[13:20:51.449]             signalCondition <- base::signalCondition
[13:20:51.449]             sys.calls <- base::sys.calls
[13:20:51.449]             `[[` <- base::`[[`
[13:20:51.449]             `+` <- base::`+`
[13:20:51.449]             `<<-` <- base::`<<-`
[13:20:51.449]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.449]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.449]                   3L)]
[13:20:51.449]             }
[13:20:51.449]             function(cond) {
[13:20:51.449]                 is_error <- inherits(cond, "error")
[13:20:51.449]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.449]                   NULL)
[13:20:51.449]                 if (is_error) {
[13:20:51.449]                   sessionInformation <- function() {
[13:20:51.449]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.449]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.449]                       search = base::search(), system = base::Sys.info())
[13:20:51.449]                   }
[13:20:51.449]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.449]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.449]                     cond$call), session = sessionInformation(), 
[13:20:51.449]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.449]                   signalCondition(cond)
[13:20:51.449]                 }
[13:20:51.449]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.449]                 "immediateCondition"))) {
[13:20:51.449]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.449]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.449]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.449]                   if (TRUE && !signal) {
[13:20:51.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.449]                     {
[13:20:51.449]                       inherits <- base::inherits
[13:20:51.449]                       invokeRestart <- base::invokeRestart
[13:20:51.449]                       is.null <- base::is.null
[13:20:51.449]                       muffled <- FALSE
[13:20:51.449]                       if (inherits(cond, "message")) {
[13:20:51.449]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.449]                         if (muffled) 
[13:20:51.449]                           invokeRestart("muffleMessage")
[13:20:51.449]                       }
[13:20:51.449]                       else if (inherits(cond, "warning")) {
[13:20:51.449]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.449]                         if (muffled) 
[13:20:51.449]                           invokeRestart("muffleWarning")
[13:20:51.449]                       }
[13:20:51.449]                       else if (inherits(cond, "condition")) {
[13:20:51.449]                         if (!is.null(pattern)) {
[13:20:51.449]                           computeRestarts <- base::computeRestarts
[13:20:51.449]                           grepl <- base::grepl
[13:20:51.449]                           restarts <- computeRestarts(cond)
[13:20:51.449]                           for (restart in restarts) {
[13:20:51.449]                             name <- restart$name
[13:20:51.449]                             if (is.null(name)) 
[13:20:51.449]                               next
[13:20:51.449]                             if (!grepl(pattern, name)) 
[13:20:51.449]                               next
[13:20:51.449]                             invokeRestart(restart)
[13:20:51.449]                             muffled <- TRUE
[13:20:51.449]                             break
[13:20:51.449]                           }
[13:20:51.449]                         }
[13:20:51.449]                       }
[13:20:51.449]                       invisible(muffled)
[13:20:51.449]                     }
[13:20:51.449]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.449]                   }
[13:20:51.449]                 }
[13:20:51.449]                 else {
[13:20:51.449]                   if (TRUE) {
[13:20:51.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.449]                     {
[13:20:51.449]                       inherits <- base::inherits
[13:20:51.449]                       invokeRestart <- base::invokeRestart
[13:20:51.449]                       is.null <- base::is.null
[13:20:51.449]                       muffled <- FALSE
[13:20:51.449]                       if (inherits(cond, "message")) {
[13:20:51.449]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.449]                         if (muffled) 
[13:20:51.449]                           invokeRestart("muffleMessage")
[13:20:51.449]                       }
[13:20:51.449]                       else if (inherits(cond, "warning")) {
[13:20:51.449]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.449]                         if (muffled) 
[13:20:51.449]                           invokeRestart("muffleWarning")
[13:20:51.449]                       }
[13:20:51.449]                       else if (inherits(cond, "condition")) {
[13:20:51.449]                         if (!is.null(pattern)) {
[13:20:51.449]                           computeRestarts <- base::computeRestarts
[13:20:51.449]                           grepl <- base::grepl
[13:20:51.449]                           restarts <- computeRestarts(cond)
[13:20:51.449]                           for (restart in restarts) {
[13:20:51.449]                             name <- restart$name
[13:20:51.449]                             if (is.null(name)) 
[13:20:51.449]                               next
[13:20:51.449]                             if (!grepl(pattern, name)) 
[13:20:51.449]                               next
[13:20:51.449]                             invokeRestart(restart)
[13:20:51.449]                             muffled <- TRUE
[13:20:51.449]                             break
[13:20:51.449]                           }
[13:20:51.449]                         }
[13:20:51.449]                       }
[13:20:51.449]                       invisible(muffled)
[13:20:51.449]                     }
[13:20:51.449]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.449]                   }
[13:20:51.449]                 }
[13:20:51.449]             }
[13:20:51.449]         }))
[13:20:51.449]     }, error = function(ex) {
[13:20:51.449]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.449]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.449]                 ...future.rng), started = ...future.startTime, 
[13:20:51.449]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.449]             version = "1.8"), class = "FutureResult")
[13:20:51.449]     }, finally = {
[13:20:51.449]         if (!identical(...future.workdir, getwd())) 
[13:20:51.449]             setwd(...future.workdir)
[13:20:51.449]         {
[13:20:51.449]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.449]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.449]             }
[13:20:51.449]             base::options(...future.oldOptions)
[13:20:51.449]             if (.Platform$OS.type == "windows") {
[13:20:51.449]                 old_names <- names(...future.oldEnvVars)
[13:20:51.449]                 envs <- base::Sys.getenv()
[13:20:51.449]                 names <- names(envs)
[13:20:51.449]                 common <- intersect(names, old_names)
[13:20:51.449]                 added <- setdiff(names, old_names)
[13:20:51.449]                 removed <- setdiff(old_names, names)
[13:20:51.449]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.449]                   envs[common]]
[13:20:51.449]                 NAMES <- toupper(changed)
[13:20:51.449]                 args <- list()
[13:20:51.449]                 for (kk in seq_along(NAMES)) {
[13:20:51.449]                   name <- changed[[kk]]
[13:20:51.449]                   NAME <- NAMES[[kk]]
[13:20:51.449]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.449]                     next
[13:20:51.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.449]                 }
[13:20:51.449]                 NAMES <- toupper(added)
[13:20:51.449]                 for (kk in seq_along(NAMES)) {
[13:20:51.449]                   name <- added[[kk]]
[13:20:51.449]                   NAME <- NAMES[[kk]]
[13:20:51.449]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.449]                     next
[13:20:51.449]                   args[[name]] <- ""
[13:20:51.449]                 }
[13:20:51.449]                 NAMES <- toupper(removed)
[13:20:51.449]                 for (kk in seq_along(NAMES)) {
[13:20:51.449]                   name <- removed[[kk]]
[13:20:51.449]                   NAME <- NAMES[[kk]]
[13:20:51.449]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.449]                     next
[13:20:51.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.449]                 }
[13:20:51.449]                 if (length(args) > 0) 
[13:20:51.449]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.449]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.449]             }
[13:20:51.449]             else {
[13:20:51.449]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.449]             }
[13:20:51.449]             {
[13:20:51.449]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.449]                   0L) {
[13:20:51.449]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.449]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.449]                   base::options(opts)
[13:20:51.449]                 }
[13:20:51.449]                 {
[13:20:51.449]                   {
[13:20:51.449]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.449]                     NULL
[13:20:51.449]                   }
[13:20:51.449]                   options(future.plan = NULL)
[13:20:51.449]                   if (is.na(NA_character_)) 
[13:20:51.449]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.449]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.449]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.449]                     envir = parent.frame()) 
[13:20:51.449]                   {
[13:20:51.449]                     default_workers <- missing(workers)
[13:20:51.449]                     if (is.function(workers)) 
[13:20:51.449]                       workers <- workers()
[13:20:51.449]                     workers <- structure(as.integer(workers), 
[13:20:51.449]                       class = class(workers))
[13:20:51.449]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.449]                       1L)
[13:20:51.449]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.449]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.449]                       if (default_workers) 
[13:20:51.449]                         supportsMulticore(warn = TRUE)
[13:20:51.449]                       return(sequential(..., envir = envir))
[13:20:51.449]                     }
[13:20:51.449]                     oopts <- options(mc.cores = workers)
[13:20:51.449]                     on.exit(options(oopts))
[13:20:51.449]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.449]                       envir = envir)
[13:20:51.449]                     if (!future$lazy) 
[13:20:51.449]                       future <- run(future)
[13:20:51.449]                     invisible(future)
[13:20:51.449]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.449]                 }
[13:20:51.449]             }
[13:20:51.449]         }
[13:20:51.449]     })
[13:20:51.449]     if (TRUE) {
[13:20:51.449]         base::sink(type = "output", split = FALSE)
[13:20:51.449]         if (TRUE) {
[13:20:51.449]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.449]         }
[13:20:51.449]         else {
[13:20:51.449]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.449]         }
[13:20:51.449]         base::close(...future.stdout)
[13:20:51.449]         ...future.stdout <- NULL
[13:20:51.449]     }
[13:20:51.449]     ...future.result$conditions <- ...future.conditions
[13:20:51.449]     ...future.result$finished <- base::Sys.time()
[13:20:51.449]     ...future.result
[13:20:51.449] }
[13:20:51.452] assign_globals() ...
[13:20:51.452] List of 2
[13:20:51.452]  $ a : num 1
[13:20:51.452]  $ ii: int 3
[13:20:51.452]  - attr(*, "where")=List of 2
[13:20:51.452]   ..$ a :<environment: R_EmptyEnv> 
[13:20:51.452]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:51.452]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:51.452]  - attr(*, "resolved")= logi TRUE
[13:20:51.452]  - attr(*, "total_size")= num 112
[13:20:51.452]  - attr(*, "already-done")= logi TRUE
[13:20:51.456] - copied ‘a’ to environment
[13:20:51.456] - copied ‘ii’ to environment
[13:20:51.457] assign_globals() ... done
[13:20:51.457] requestCore(): workers = 2
[13:20:51.457] Poll #1 (0): usedCores() = 2, workers = 2
[13:20:51.485] MulticoreFuture started
[13:20:51.486] - Launch lazy future ... done
[13:20:51.486] plan(): Setting new future strategy stack:
[13:20:51.486] run() for ‘MulticoreFuture’ ... done
[13:20:51.487] List of future strategies:
[13:20:51.487] 1. sequential:
[13:20:51.487]    - args: function (..., envir = parent.frame())
[13:20:51.487]    - tweaked: FALSE
[13:20:51.487]    - call: NULL
[13:20:51.489] plan(): nbrOfWorkers() = 1
[13:20:51.492] plan(): Setting new future strategy stack:
[13:20:51.493] List of future strategies:
[13:20:51.493] 1. multicore:
[13:20:51.493]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.493]    - tweaked: FALSE
[13:20:51.493]    - call: plan(strategy)
[13:20:51.500] plan(): nbrOfWorkers() = 2
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.502] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.503] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:51.506] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:51.506] Searching for globals ... DONE
[13:20:51.506] Resolving globals: TRUE
[13:20:51.507] Resolving any globals that are futures ...
[13:20:51.507] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:51.507] Resolving any globals that are futures ... DONE
[13:20:51.507] Resolving futures part of globals (recursively) ...
[13:20:51.508] resolve() on list ...
[13:20:51.508]  recursive: 99
[13:20:51.508]  length: 2
[13:20:51.508]  elements: ‘a’, ‘ii’
[13:20:51.508]  length: 1 (resolved future 1)
[13:20:51.508]  length: 0 (resolved future 2)
[13:20:51.508] resolve() on list ... DONE
[13:20:51.509] - globals: [2] ‘a’, ‘ii’
[13:20:51.509] Resolving futures part of globals (recursively) ... DONE
[13:20:51.509] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:51.509] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:20:51.510] - globals: [2] ‘a’, ‘ii’
[13:20:51.510] 
[13:20:51.510] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.511] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.511] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:51.513] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:51.513] Searching for globals ... DONE
[13:20:51.513] Resolving globals: TRUE
[13:20:51.514] Resolving any globals that are futures ...
[13:20:51.514] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:51.514] Resolving any globals that are futures ... DONE
[13:20:51.514] Resolving futures part of globals (recursively) ...
[13:20:51.514] resolve() on list ...
[13:20:51.515]  recursive: 99
[13:20:51.515]  length: 2
[13:20:51.515]  elements: ‘a’, ‘ii’
[13:20:51.515]  length: 1 (resolved future 1)
[13:20:51.515]  length: 0 (resolved future 2)
[13:20:51.515] resolve() on list ... DONE
[13:20:51.515] - globals: [2] ‘a’, ‘ii’
[13:20:51.515] Resolving futures part of globals (recursively) ... DONE
[13:20:51.516] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:51.516] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:20:51.516] - globals: [2] ‘a’, ‘ii’
[13:20:51.516] 
[13:20:51.516] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.517] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.517] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:51.519] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:51.519] Searching for globals ... DONE
[13:20:51.521] Resolving globals: TRUE
[13:20:51.522] Resolving any globals that are futures ...
[13:20:51.522] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:51.522] Resolving any globals that are futures ... DONE
[13:20:51.522] Resolving futures part of globals (recursively) ...
[13:20:51.523] resolve() on list ...
[13:20:51.523]  recursive: 99
[13:20:51.523]  length: 2
[13:20:51.523]  elements: ‘a’, ‘ii’
[13:20:51.523]  length: 1 (resolved future 1)
[13:20:51.523]  length: 0 (resolved future 2)
[13:20:51.524] resolve() on list ... DONE
[13:20:51.524] - globals: [2] ‘a’, ‘ii’
[13:20:51.524] Resolving futures part of globals (recursively) ... DONE
[13:20:51.524] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:51.524] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:20:51.525] - globals: [2] ‘a’, ‘ii’
[13:20:51.525] 
[13:20:51.525] getGlobalsAndPackages() ... DONE
[13:20:51.525] run() for ‘Future’ ...
[13:20:51.525] - state: ‘created’
[13:20:51.526] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.530] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.530] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.530]   - Field: ‘label’
[13:20:51.530]   - Field: ‘local’
[13:20:51.530]   - Field: ‘owner’
[13:20:51.530]   - Field: ‘envir’
[13:20:51.531]   - Field: ‘workers’
[13:20:51.531]   - Field: ‘packages’
[13:20:51.531]   - Field: ‘gc’
[13:20:51.531]   - Field: ‘job’
[13:20:51.531]   - Field: ‘conditions’
[13:20:51.531]   - Field: ‘expr’
[13:20:51.531]   - Field: ‘uuid’
[13:20:51.531]   - Field: ‘seed’
[13:20:51.531]   - Field: ‘version’
[13:20:51.531]   - Field: ‘result’
[13:20:51.532]   - Field: ‘asynchronous’
[13:20:51.532]   - Field: ‘calls’
[13:20:51.532]   - Field: ‘globals’
[13:20:51.532]   - Field: ‘stdout’
[13:20:51.532]   - Field: ‘earlySignal’
[13:20:51.532]   - Field: ‘lazy’
[13:20:51.532]   - Field: ‘state’
[13:20:51.532] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.532] - Launch lazy future ...
[13:20:51.533] Packages needed by the future expression (n = 0): <none>
[13:20:51.533] Packages needed by future strategies (n = 0): <none>
[13:20:51.533] {
[13:20:51.533]     {
[13:20:51.533]         {
[13:20:51.533]             ...future.startTime <- base::Sys.time()
[13:20:51.533]             {
[13:20:51.533]                 {
[13:20:51.533]                   {
[13:20:51.533]                     {
[13:20:51.533]                       base::local({
[13:20:51.533]                         has_future <- base::requireNamespace("future", 
[13:20:51.533]                           quietly = TRUE)
[13:20:51.533]                         if (has_future) {
[13:20:51.533]                           ns <- base::getNamespace("future")
[13:20:51.533]                           version <- ns[[".package"]][["version"]]
[13:20:51.533]                           if (is.null(version)) 
[13:20:51.533]                             version <- utils::packageVersion("future")
[13:20:51.533]                         }
[13:20:51.533]                         else {
[13:20:51.533]                           version <- NULL
[13:20:51.533]                         }
[13:20:51.533]                         if (!has_future || version < "1.8.0") {
[13:20:51.533]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.533]                             "", base::R.version$version.string), 
[13:20:51.533]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:51.533]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:51.533]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.533]                               "release", "version")], collapse = " "), 
[13:20:51.533]                             hostname = base::Sys.info()[["nodename"]])
[13:20:51.533]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.533]                             info)
[13:20:51.533]                           info <- base::paste(info, collapse = "; ")
[13:20:51.533]                           if (!has_future) {
[13:20:51.533]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.533]                               info)
[13:20:51.533]                           }
[13:20:51.533]                           else {
[13:20:51.533]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.533]                               info, version)
[13:20:51.533]                           }
[13:20:51.533]                           base::stop(msg)
[13:20:51.533]                         }
[13:20:51.533]                       })
[13:20:51.533]                     }
[13:20:51.533]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.533]                     base::options(mc.cores = 1L)
[13:20:51.533]                   }
[13:20:51.533]                   options(future.plan = NULL)
[13:20:51.533]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.533]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.533]                 }
[13:20:51.533]                 ...future.workdir <- getwd()
[13:20:51.533]             }
[13:20:51.533]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.533]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.533]         }
[13:20:51.533]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.533]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:51.533]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.533]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.533]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.533]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.533]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.533]             base::names(...future.oldOptions))
[13:20:51.533]     }
[13:20:51.533]     if (FALSE) {
[13:20:51.533]     }
[13:20:51.533]     else {
[13:20:51.533]         if (TRUE) {
[13:20:51.533]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.533]                 open = "w")
[13:20:51.533]         }
[13:20:51.533]         else {
[13:20:51.533]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.533]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.533]         }
[13:20:51.533]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.533]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.533]             base::sink(type = "output", split = FALSE)
[13:20:51.533]             base::close(...future.stdout)
[13:20:51.533]         }, add = TRUE)
[13:20:51.533]     }
[13:20:51.533]     ...future.frame <- base::sys.nframe()
[13:20:51.533]     ...future.conditions <- base::list()
[13:20:51.533]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.533]     if (FALSE) {
[13:20:51.533]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.533]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.533]     }
[13:20:51.533]     ...future.result <- base::tryCatch({
[13:20:51.533]         base::withCallingHandlers({
[13:20:51.533]             ...future.value <- base::withVisible(base::local({
[13:20:51.533]                 withCallingHandlers({
[13:20:51.533]                   {
[13:20:51.533]                     b <- a * ii
[13:20:51.533]                     a <- 0
[13:20:51.533]                     b
[13:20:51.533]                   }
[13:20:51.533]                 }, immediateCondition = function(cond) {
[13:20:51.533]                   save_rds <- function (object, pathname, ...) 
[13:20:51.533]                   {
[13:20:51.533]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.533]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.533]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.533]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.533]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.533]                         fi_tmp[["mtime"]])
[13:20:51.533]                     }
[13:20:51.533]                     tryCatch({
[13:20:51.533]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.533]                     }, error = function(ex) {
[13:20:51.533]                       msg <- conditionMessage(ex)
[13:20:51.533]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.533]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.533]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.533]                         fi_tmp[["mtime"]], msg)
[13:20:51.533]                       ex$message <- msg
[13:20:51.533]                       stop(ex)
[13:20:51.533]                     })
[13:20:51.533]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.533]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.533]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.533]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.533]                       fi <- file.info(pathname)
[13:20:51.533]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.533]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.533]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.533]                         fi[["size"]], fi[["mtime"]])
[13:20:51.533]                       stop(msg)
[13:20:51.533]                     }
[13:20:51.533]                     invisible(pathname)
[13:20:51.533]                   }
[13:20:51.533]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.533]                     rootPath = tempdir()) 
[13:20:51.533]                   {
[13:20:51.533]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.533]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.533]                       tmpdir = path, fileext = ".rds")
[13:20:51.533]                     save_rds(obj, file)
[13:20:51.533]                   }
[13:20:51.533]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.533]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.533]                   {
[13:20:51.533]                     inherits <- base::inherits
[13:20:51.533]                     invokeRestart <- base::invokeRestart
[13:20:51.533]                     is.null <- base::is.null
[13:20:51.533]                     muffled <- FALSE
[13:20:51.533]                     if (inherits(cond, "message")) {
[13:20:51.533]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.533]                       if (muffled) 
[13:20:51.533]                         invokeRestart("muffleMessage")
[13:20:51.533]                     }
[13:20:51.533]                     else if (inherits(cond, "warning")) {
[13:20:51.533]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.533]                       if (muffled) 
[13:20:51.533]                         invokeRestart("muffleWarning")
[13:20:51.533]                     }
[13:20:51.533]                     else if (inherits(cond, "condition")) {
[13:20:51.533]                       if (!is.null(pattern)) {
[13:20:51.533]                         computeRestarts <- base::computeRestarts
[13:20:51.533]                         grepl <- base::grepl
[13:20:51.533]                         restarts <- computeRestarts(cond)
[13:20:51.533]                         for (restart in restarts) {
[13:20:51.533]                           name <- restart$name
[13:20:51.533]                           if (is.null(name)) 
[13:20:51.533]                             next
[13:20:51.533]                           if (!grepl(pattern, name)) 
[13:20:51.533]                             next
[13:20:51.533]                           invokeRestart(restart)
[13:20:51.533]                           muffled <- TRUE
[13:20:51.533]                           break
[13:20:51.533]                         }
[13:20:51.533]                       }
[13:20:51.533]                     }
[13:20:51.533]                     invisible(muffled)
[13:20:51.533]                   }
[13:20:51.533]                   muffleCondition(cond)
[13:20:51.533]                 })
[13:20:51.533]             }))
[13:20:51.533]             future::FutureResult(value = ...future.value$value, 
[13:20:51.533]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.533]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.533]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.533]                     ...future.globalenv.names))
[13:20:51.533]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.533]         }, condition = base::local({
[13:20:51.533]             c <- base::c
[13:20:51.533]             inherits <- base::inherits
[13:20:51.533]             invokeRestart <- base::invokeRestart
[13:20:51.533]             length <- base::length
[13:20:51.533]             list <- base::list
[13:20:51.533]             seq.int <- base::seq.int
[13:20:51.533]             signalCondition <- base::signalCondition
[13:20:51.533]             sys.calls <- base::sys.calls
[13:20:51.533]             `[[` <- base::`[[`
[13:20:51.533]             `+` <- base::`+`
[13:20:51.533]             `<<-` <- base::`<<-`
[13:20:51.533]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.533]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.533]                   3L)]
[13:20:51.533]             }
[13:20:51.533]             function(cond) {
[13:20:51.533]                 is_error <- inherits(cond, "error")
[13:20:51.533]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.533]                   NULL)
[13:20:51.533]                 if (is_error) {
[13:20:51.533]                   sessionInformation <- function() {
[13:20:51.533]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.533]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.533]                       search = base::search(), system = base::Sys.info())
[13:20:51.533]                   }
[13:20:51.533]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.533]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.533]                     cond$call), session = sessionInformation(), 
[13:20:51.533]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.533]                   signalCondition(cond)
[13:20:51.533]                 }
[13:20:51.533]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.533]                 "immediateCondition"))) {
[13:20:51.533]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.533]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.533]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.533]                   if (TRUE && !signal) {
[13:20:51.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.533]                     {
[13:20:51.533]                       inherits <- base::inherits
[13:20:51.533]                       invokeRestart <- base::invokeRestart
[13:20:51.533]                       is.null <- base::is.null
[13:20:51.533]                       muffled <- FALSE
[13:20:51.533]                       if (inherits(cond, "message")) {
[13:20:51.533]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.533]                         if (muffled) 
[13:20:51.533]                           invokeRestart("muffleMessage")
[13:20:51.533]                       }
[13:20:51.533]                       else if (inherits(cond, "warning")) {
[13:20:51.533]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.533]                         if (muffled) 
[13:20:51.533]                           invokeRestart("muffleWarning")
[13:20:51.533]                       }
[13:20:51.533]                       else if (inherits(cond, "condition")) {
[13:20:51.533]                         if (!is.null(pattern)) {
[13:20:51.533]                           computeRestarts <- base::computeRestarts
[13:20:51.533]                           grepl <- base::grepl
[13:20:51.533]                           restarts <- computeRestarts(cond)
[13:20:51.533]                           for (restart in restarts) {
[13:20:51.533]                             name <- restart$name
[13:20:51.533]                             if (is.null(name)) 
[13:20:51.533]                               next
[13:20:51.533]                             if (!grepl(pattern, name)) 
[13:20:51.533]                               next
[13:20:51.533]                             invokeRestart(restart)
[13:20:51.533]                             muffled <- TRUE
[13:20:51.533]                             break
[13:20:51.533]                           }
[13:20:51.533]                         }
[13:20:51.533]                       }
[13:20:51.533]                       invisible(muffled)
[13:20:51.533]                     }
[13:20:51.533]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.533]                   }
[13:20:51.533]                 }
[13:20:51.533]                 else {
[13:20:51.533]                   if (TRUE) {
[13:20:51.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.533]                     {
[13:20:51.533]                       inherits <- base::inherits
[13:20:51.533]                       invokeRestart <- base::invokeRestart
[13:20:51.533]                       is.null <- base::is.null
[13:20:51.533]                       muffled <- FALSE
[13:20:51.533]                       if (inherits(cond, "message")) {
[13:20:51.533]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.533]                         if (muffled) 
[13:20:51.533]                           invokeRestart("muffleMessage")
[13:20:51.533]                       }
[13:20:51.533]                       else if (inherits(cond, "warning")) {
[13:20:51.533]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.533]                         if (muffled) 
[13:20:51.533]                           invokeRestart("muffleWarning")
[13:20:51.533]                       }
[13:20:51.533]                       else if (inherits(cond, "condition")) {
[13:20:51.533]                         if (!is.null(pattern)) {
[13:20:51.533]                           computeRestarts <- base::computeRestarts
[13:20:51.533]                           grepl <- base::grepl
[13:20:51.533]                           restarts <- computeRestarts(cond)
[13:20:51.533]                           for (restart in restarts) {
[13:20:51.533]                             name <- restart$name
[13:20:51.533]                             if (is.null(name)) 
[13:20:51.533]                               next
[13:20:51.533]                             if (!grepl(pattern, name)) 
[13:20:51.533]                               next
[13:20:51.533]                             invokeRestart(restart)
[13:20:51.533]                             muffled <- TRUE
[13:20:51.533]                             break
[13:20:51.533]                           }
[13:20:51.533]                         }
[13:20:51.533]                       }
[13:20:51.533]                       invisible(muffled)
[13:20:51.533]                     }
[13:20:51.533]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.533]                   }
[13:20:51.533]                 }
[13:20:51.533]             }
[13:20:51.533]         }))
[13:20:51.533]     }, error = function(ex) {
[13:20:51.533]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.533]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.533]                 ...future.rng), started = ...future.startTime, 
[13:20:51.533]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.533]             version = "1.8"), class = "FutureResult")
[13:20:51.533]     }, finally = {
[13:20:51.533]         if (!identical(...future.workdir, getwd())) 
[13:20:51.533]             setwd(...future.workdir)
[13:20:51.533]         {
[13:20:51.533]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.533]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.533]             }
[13:20:51.533]             base::options(...future.oldOptions)
[13:20:51.533]             if (.Platform$OS.type == "windows") {
[13:20:51.533]                 old_names <- names(...future.oldEnvVars)
[13:20:51.533]                 envs <- base::Sys.getenv()
[13:20:51.533]                 names <- names(envs)
[13:20:51.533]                 common <- intersect(names, old_names)
[13:20:51.533]                 added <- setdiff(names, old_names)
[13:20:51.533]                 removed <- setdiff(old_names, names)
[13:20:51.533]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.533]                   envs[common]]
[13:20:51.533]                 NAMES <- toupper(changed)
[13:20:51.533]                 args <- list()
[13:20:51.533]                 for (kk in seq_along(NAMES)) {
[13:20:51.533]                   name <- changed[[kk]]
[13:20:51.533]                   NAME <- NAMES[[kk]]
[13:20:51.533]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.533]                     next
[13:20:51.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.533]                 }
[13:20:51.533]                 NAMES <- toupper(added)
[13:20:51.533]                 for (kk in seq_along(NAMES)) {
[13:20:51.533]                   name <- added[[kk]]
[13:20:51.533]                   NAME <- NAMES[[kk]]
[13:20:51.533]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.533]                     next
[13:20:51.533]                   args[[name]] <- ""
[13:20:51.533]                 }
[13:20:51.533]                 NAMES <- toupper(removed)
[13:20:51.533]                 for (kk in seq_along(NAMES)) {
[13:20:51.533]                   name <- removed[[kk]]
[13:20:51.533]                   NAME <- NAMES[[kk]]
[13:20:51.533]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.533]                     next
[13:20:51.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.533]                 }
[13:20:51.533]                 if (length(args) > 0) 
[13:20:51.533]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.533]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.533]             }
[13:20:51.533]             else {
[13:20:51.533]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.533]             }
[13:20:51.533]             {
[13:20:51.533]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.533]                   0L) {
[13:20:51.533]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.533]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.533]                   base::options(opts)
[13:20:51.533]                 }
[13:20:51.533]                 {
[13:20:51.533]                   {
[13:20:51.533]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.533]                     NULL
[13:20:51.533]                   }
[13:20:51.533]                   options(future.plan = NULL)
[13:20:51.533]                   if (is.na(NA_character_)) 
[13:20:51.533]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.533]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.533]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.533]                     envir = parent.frame()) 
[13:20:51.533]                   {
[13:20:51.533]                     default_workers <- missing(workers)
[13:20:51.533]                     if (is.function(workers)) 
[13:20:51.533]                       workers <- workers()
[13:20:51.533]                     workers <- structure(as.integer(workers), 
[13:20:51.533]                       class = class(workers))
[13:20:51.533]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.533]                       1L)
[13:20:51.533]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.533]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.533]                       if (default_workers) 
[13:20:51.533]                         supportsMulticore(warn = TRUE)
[13:20:51.533]                       return(sequential(..., envir = envir))
[13:20:51.533]                     }
[13:20:51.533]                     oopts <- options(mc.cores = workers)
[13:20:51.533]                     on.exit(options(oopts))
[13:20:51.533]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.533]                       envir = envir)
[13:20:51.533]                     if (!future$lazy) 
[13:20:51.533]                       future <- run(future)
[13:20:51.533]                     invisible(future)
[13:20:51.533]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.533]                 }
[13:20:51.533]             }
[13:20:51.533]         }
[13:20:51.533]     })
[13:20:51.533]     if (TRUE) {
[13:20:51.533]         base::sink(type = "output", split = FALSE)
[13:20:51.533]         if (TRUE) {
[13:20:51.533]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.533]         }
[13:20:51.533]         else {
[13:20:51.533]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.533]         }
[13:20:51.533]         base::close(...future.stdout)
[13:20:51.533]         ...future.stdout <- NULL
[13:20:51.533]     }
[13:20:51.533]     ...future.result$conditions <- ...future.conditions
[13:20:51.533]     ...future.result$finished <- base::Sys.time()
[13:20:51.533]     ...future.result
[13:20:51.533] }
[13:20:51.536] assign_globals() ...
[13:20:51.536] List of 2
[13:20:51.536]  $ a : num 1
[13:20:51.536]  $ ii: int 1
[13:20:51.536]  - attr(*, "where")=List of 2
[13:20:51.536]   ..$ a :<environment: R_EmptyEnv> 
[13:20:51.536]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:51.536]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:51.536]  - attr(*, "resolved")= logi TRUE
[13:20:51.536]  - attr(*, "total_size")= num 112
[13:20:51.536]  - attr(*, "already-done")= logi TRUE
[13:20:51.539] - copied ‘a’ to environment
[13:20:51.540] - copied ‘ii’ to environment
[13:20:51.540] assign_globals() ... done
[13:20:51.540] requestCore(): workers = 2
[13:20:51.542] MulticoreFuture started
[13:20:51.542] - Launch lazy future ... done
[13:20:51.543] run() for ‘MulticoreFuture’ ... done
[13:20:51.543] plan(): Setting new future strategy stack:
[13:20:51.543] List of future strategies:
[13:20:51.543] 1. sequential:
[13:20:51.543]    - args: function (..., envir = parent.frame())
[13:20:51.543]    - tweaked: FALSE
[13:20:51.543]    - call: NULL
[13:20:51.544] plan(): nbrOfWorkers() = 1
[13:20:51.547] plan(): Setting new future strategy stack:
[13:20:51.547] List of future strategies:
[13:20:51.547] 1. multicore:
[13:20:51.547]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.547]    - tweaked: FALSE
[13:20:51.547]    - call: plan(strategy)
[13:20:51.552] plan(): nbrOfWorkers() = 2
[13:20:51.553] run() for ‘Future’ ...
[13:20:51.553] - state: ‘created’
[13:20:51.554] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.558] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.558] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.558]   - Field: ‘label’
[13:20:51.558]   - Field: ‘local’
[13:20:51.558]   - Field: ‘owner’
[13:20:51.559]   - Field: ‘envir’
[13:20:51.559]   - Field: ‘workers’
[13:20:51.559]   - Field: ‘packages’
[13:20:51.559]   - Field: ‘gc’
[13:20:51.559]   - Field: ‘job’
[13:20:51.559]   - Field: ‘conditions’
[13:20:51.559]   - Field: ‘expr’
[13:20:51.560]   - Field: ‘uuid’
[13:20:51.560]   - Field: ‘seed’
[13:20:51.560]   - Field: ‘version’
[13:20:51.560]   - Field: ‘result’
[13:20:51.560]   - Field: ‘asynchronous’
[13:20:51.560]   - Field: ‘calls’
[13:20:51.560]   - Field: ‘globals’
[13:20:51.560]   - Field: ‘stdout’
[13:20:51.560]   - Field: ‘earlySignal’
[13:20:51.561]   - Field: ‘lazy’
[13:20:51.561]   - Field: ‘state’
[13:20:51.561] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.561] - Launch lazy future ...
[13:20:51.561] Packages needed by the future expression (n = 0): <none>
[13:20:51.562] Packages needed by future strategies (n = 0): <none>
[13:20:51.562] {
[13:20:51.562]     {
[13:20:51.562]         {
[13:20:51.562]             ...future.startTime <- base::Sys.time()
[13:20:51.562]             {
[13:20:51.562]                 {
[13:20:51.562]                   {
[13:20:51.562]                     {
[13:20:51.562]                       base::local({
[13:20:51.562]                         has_future <- base::requireNamespace("future", 
[13:20:51.562]                           quietly = TRUE)
[13:20:51.562]                         if (has_future) {
[13:20:51.562]                           ns <- base::getNamespace("future")
[13:20:51.562]                           version <- ns[[".package"]][["version"]]
[13:20:51.562]                           if (is.null(version)) 
[13:20:51.562]                             version <- utils::packageVersion("future")
[13:20:51.562]                         }
[13:20:51.562]                         else {
[13:20:51.562]                           version <- NULL
[13:20:51.562]                         }
[13:20:51.562]                         if (!has_future || version < "1.8.0") {
[13:20:51.562]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.562]                             "", base::R.version$version.string), 
[13:20:51.562]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:51.562]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:51.562]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.562]                               "release", "version")], collapse = " "), 
[13:20:51.562]                             hostname = base::Sys.info()[["nodename"]])
[13:20:51.562]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.562]                             info)
[13:20:51.562]                           info <- base::paste(info, collapse = "; ")
[13:20:51.562]                           if (!has_future) {
[13:20:51.562]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.562]                               info)
[13:20:51.562]                           }
[13:20:51.562]                           else {
[13:20:51.562]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.562]                               info, version)
[13:20:51.562]                           }
[13:20:51.562]                           base::stop(msg)
[13:20:51.562]                         }
[13:20:51.562]                       })
[13:20:51.562]                     }
[13:20:51.562]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.562]                     base::options(mc.cores = 1L)
[13:20:51.562]                   }
[13:20:51.562]                   options(future.plan = NULL)
[13:20:51.562]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.562]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.562]                 }
[13:20:51.562]                 ...future.workdir <- getwd()
[13:20:51.562]             }
[13:20:51.562]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.562]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.562]         }
[13:20:51.562]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.562]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:51.562]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.562]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.562]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.562]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.562]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.562]             base::names(...future.oldOptions))
[13:20:51.562]     }
[13:20:51.562]     if (FALSE) {
[13:20:51.562]     }
[13:20:51.562]     else {
[13:20:51.562]         if (TRUE) {
[13:20:51.562]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.562]                 open = "w")
[13:20:51.562]         }
[13:20:51.562]         else {
[13:20:51.562]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.562]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.562]         }
[13:20:51.562]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.562]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.562]             base::sink(type = "output", split = FALSE)
[13:20:51.562]             base::close(...future.stdout)
[13:20:51.562]         }, add = TRUE)
[13:20:51.562]     }
[13:20:51.562]     ...future.frame <- base::sys.nframe()
[13:20:51.562]     ...future.conditions <- base::list()
[13:20:51.562]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.562]     if (FALSE) {
[13:20:51.562]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.562]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.562]     }
[13:20:51.562]     ...future.result <- base::tryCatch({
[13:20:51.562]         base::withCallingHandlers({
[13:20:51.562]             ...future.value <- base::withVisible(base::local({
[13:20:51.562]                 withCallingHandlers({
[13:20:51.562]                   {
[13:20:51.562]                     b <- a * ii
[13:20:51.562]                     a <- 0
[13:20:51.562]                     b
[13:20:51.562]                   }
[13:20:51.562]                 }, immediateCondition = function(cond) {
[13:20:51.562]                   save_rds <- function (object, pathname, ...) 
[13:20:51.562]                   {
[13:20:51.562]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.562]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.562]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.562]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.562]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.562]                         fi_tmp[["mtime"]])
[13:20:51.562]                     }
[13:20:51.562]                     tryCatch({
[13:20:51.562]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.562]                     }, error = function(ex) {
[13:20:51.562]                       msg <- conditionMessage(ex)
[13:20:51.562]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.562]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.562]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.562]                         fi_tmp[["mtime"]], msg)
[13:20:51.562]                       ex$message <- msg
[13:20:51.562]                       stop(ex)
[13:20:51.562]                     })
[13:20:51.562]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.562]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.562]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.562]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.562]                       fi <- file.info(pathname)
[13:20:51.562]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.562]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.562]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.562]                         fi[["size"]], fi[["mtime"]])
[13:20:51.562]                       stop(msg)
[13:20:51.562]                     }
[13:20:51.562]                     invisible(pathname)
[13:20:51.562]                   }
[13:20:51.562]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.562]                     rootPath = tempdir()) 
[13:20:51.562]                   {
[13:20:51.562]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.562]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.562]                       tmpdir = path, fileext = ".rds")
[13:20:51.562]                     save_rds(obj, file)
[13:20:51.562]                   }
[13:20:51.562]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.562]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.562]                   {
[13:20:51.562]                     inherits <- base::inherits
[13:20:51.562]                     invokeRestart <- base::invokeRestart
[13:20:51.562]                     is.null <- base::is.null
[13:20:51.562]                     muffled <- FALSE
[13:20:51.562]                     if (inherits(cond, "message")) {
[13:20:51.562]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.562]                       if (muffled) 
[13:20:51.562]                         invokeRestart("muffleMessage")
[13:20:51.562]                     }
[13:20:51.562]                     else if (inherits(cond, "warning")) {
[13:20:51.562]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.562]                       if (muffled) 
[13:20:51.562]                         invokeRestart("muffleWarning")
[13:20:51.562]                     }
[13:20:51.562]                     else if (inherits(cond, "condition")) {
[13:20:51.562]                       if (!is.null(pattern)) {
[13:20:51.562]                         computeRestarts <- base::computeRestarts
[13:20:51.562]                         grepl <- base::grepl
[13:20:51.562]                         restarts <- computeRestarts(cond)
[13:20:51.562]                         for (restart in restarts) {
[13:20:51.562]                           name <- restart$name
[13:20:51.562]                           if (is.null(name)) 
[13:20:51.562]                             next
[13:20:51.562]                           if (!grepl(pattern, name)) 
[13:20:51.562]                             next
[13:20:51.562]                           invokeRestart(restart)
[13:20:51.562]                           muffled <- TRUE
[13:20:51.562]                           break
[13:20:51.562]                         }
[13:20:51.562]                       }
[13:20:51.562]                     }
[13:20:51.562]                     invisible(muffled)
[13:20:51.562]                   }
[13:20:51.562]                   muffleCondition(cond)
[13:20:51.562]                 })
[13:20:51.562]             }))
[13:20:51.562]             future::FutureResult(value = ...future.value$value, 
[13:20:51.562]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.562]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.562]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.562]                     ...future.globalenv.names))
[13:20:51.562]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.562]         }, condition = base::local({
[13:20:51.562]             c <- base::c
[13:20:51.562]             inherits <- base::inherits
[13:20:51.562]             invokeRestart <- base::invokeRestart
[13:20:51.562]             length <- base::length
[13:20:51.562]             list <- base::list
[13:20:51.562]             seq.int <- base::seq.int
[13:20:51.562]             signalCondition <- base::signalCondition
[13:20:51.562]             sys.calls <- base::sys.calls
[13:20:51.562]             `[[` <- base::`[[`
[13:20:51.562]             `+` <- base::`+`
[13:20:51.562]             `<<-` <- base::`<<-`
[13:20:51.562]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.562]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.562]                   3L)]
[13:20:51.562]             }
[13:20:51.562]             function(cond) {
[13:20:51.562]                 is_error <- inherits(cond, "error")
[13:20:51.562]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.562]                   NULL)
[13:20:51.562]                 if (is_error) {
[13:20:51.562]                   sessionInformation <- function() {
[13:20:51.562]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.562]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.562]                       search = base::search(), system = base::Sys.info())
[13:20:51.562]                   }
[13:20:51.562]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.562]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.562]                     cond$call), session = sessionInformation(), 
[13:20:51.562]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.562]                   signalCondition(cond)
[13:20:51.562]                 }
[13:20:51.562]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.562]                 "immediateCondition"))) {
[13:20:51.562]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.562]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.562]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.562]                   if (TRUE && !signal) {
[13:20:51.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.562]                     {
[13:20:51.562]                       inherits <- base::inherits
[13:20:51.562]                       invokeRestart <- base::invokeRestart
[13:20:51.562]                       is.null <- base::is.null
[13:20:51.562]                       muffled <- FALSE
[13:20:51.562]                       if (inherits(cond, "message")) {
[13:20:51.562]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.562]                         if (muffled) 
[13:20:51.562]                           invokeRestart("muffleMessage")
[13:20:51.562]                       }
[13:20:51.562]                       else if (inherits(cond, "warning")) {
[13:20:51.562]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.562]                         if (muffled) 
[13:20:51.562]                           invokeRestart("muffleWarning")
[13:20:51.562]                       }
[13:20:51.562]                       else if (inherits(cond, "condition")) {
[13:20:51.562]                         if (!is.null(pattern)) {
[13:20:51.562]                           computeRestarts <- base::computeRestarts
[13:20:51.562]                           grepl <- base::grepl
[13:20:51.562]                           restarts <- computeRestarts(cond)
[13:20:51.562]                           for (restart in restarts) {
[13:20:51.562]                             name <- restart$name
[13:20:51.562]                             if (is.null(name)) 
[13:20:51.562]                               next
[13:20:51.562]                             if (!grepl(pattern, name)) 
[13:20:51.562]                               next
[13:20:51.562]                             invokeRestart(restart)
[13:20:51.562]                             muffled <- TRUE
[13:20:51.562]                             break
[13:20:51.562]                           }
[13:20:51.562]                         }
[13:20:51.562]                       }
[13:20:51.562]                       invisible(muffled)
[13:20:51.562]                     }
[13:20:51.562]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.562]                   }
[13:20:51.562]                 }
[13:20:51.562]                 else {
[13:20:51.562]                   if (TRUE) {
[13:20:51.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.562]                     {
[13:20:51.562]                       inherits <- base::inherits
[13:20:51.562]                       invokeRestart <- base::invokeRestart
[13:20:51.562]                       is.null <- base::is.null
[13:20:51.562]                       muffled <- FALSE
[13:20:51.562]                       if (inherits(cond, "message")) {
[13:20:51.562]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.562]                         if (muffled) 
[13:20:51.562]                           invokeRestart("muffleMessage")
[13:20:51.562]                       }
[13:20:51.562]                       else if (inherits(cond, "warning")) {
[13:20:51.562]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.562]                         if (muffled) 
[13:20:51.562]                           invokeRestart("muffleWarning")
[13:20:51.562]                       }
[13:20:51.562]                       else if (inherits(cond, "condition")) {
[13:20:51.562]                         if (!is.null(pattern)) {
[13:20:51.562]                           computeRestarts <- base::computeRestarts
[13:20:51.562]                           grepl <- base::grepl
[13:20:51.562]                           restarts <- computeRestarts(cond)
[13:20:51.562]                           for (restart in restarts) {
[13:20:51.562]                             name <- restart$name
[13:20:51.562]                             if (is.null(name)) 
[13:20:51.562]                               next
[13:20:51.562]                             if (!grepl(pattern, name)) 
[13:20:51.562]                               next
[13:20:51.562]                             invokeRestart(restart)
[13:20:51.562]                             muffled <- TRUE
[13:20:51.562]                             break
[13:20:51.562]                           }
[13:20:51.562]                         }
[13:20:51.562]                       }
[13:20:51.562]                       invisible(muffled)
[13:20:51.562]                     }
[13:20:51.562]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.562]                   }
[13:20:51.562]                 }
[13:20:51.562]             }
[13:20:51.562]         }))
[13:20:51.562]     }, error = function(ex) {
[13:20:51.562]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.562]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.562]                 ...future.rng), started = ...future.startTime, 
[13:20:51.562]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.562]             version = "1.8"), class = "FutureResult")
[13:20:51.562]     }, finally = {
[13:20:51.562]         if (!identical(...future.workdir, getwd())) 
[13:20:51.562]             setwd(...future.workdir)
[13:20:51.562]         {
[13:20:51.562]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.562]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.562]             }
[13:20:51.562]             base::options(...future.oldOptions)
[13:20:51.562]             if (.Platform$OS.type == "windows") {
[13:20:51.562]                 old_names <- names(...future.oldEnvVars)
[13:20:51.562]                 envs <- base::Sys.getenv()
[13:20:51.562]                 names <- names(envs)
[13:20:51.562]                 common <- intersect(names, old_names)
[13:20:51.562]                 added <- setdiff(names, old_names)
[13:20:51.562]                 removed <- setdiff(old_names, names)
[13:20:51.562]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.562]                   envs[common]]
[13:20:51.562]                 NAMES <- toupper(changed)
[13:20:51.562]                 args <- list()
[13:20:51.562]                 for (kk in seq_along(NAMES)) {
[13:20:51.562]                   name <- changed[[kk]]
[13:20:51.562]                   NAME <- NAMES[[kk]]
[13:20:51.562]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.562]                     next
[13:20:51.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.562]                 }
[13:20:51.562]                 NAMES <- toupper(added)
[13:20:51.562]                 for (kk in seq_along(NAMES)) {
[13:20:51.562]                   name <- added[[kk]]
[13:20:51.562]                   NAME <- NAMES[[kk]]
[13:20:51.562]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.562]                     next
[13:20:51.562]                   args[[name]] <- ""
[13:20:51.562]                 }
[13:20:51.562]                 NAMES <- toupper(removed)
[13:20:51.562]                 for (kk in seq_along(NAMES)) {
[13:20:51.562]                   name <- removed[[kk]]
[13:20:51.562]                   NAME <- NAMES[[kk]]
[13:20:51.562]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.562]                     next
[13:20:51.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.562]                 }
[13:20:51.562]                 if (length(args) > 0) 
[13:20:51.562]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.562]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.562]             }
[13:20:51.562]             else {
[13:20:51.562]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.562]             }
[13:20:51.562]             {
[13:20:51.562]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.562]                   0L) {
[13:20:51.562]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.562]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.562]                   base::options(opts)
[13:20:51.562]                 }
[13:20:51.562]                 {
[13:20:51.562]                   {
[13:20:51.562]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.562]                     NULL
[13:20:51.562]                   }
[13:20:51.562]                   options(future.plan = NULL)
[13:20:51.562]                   if (is.na(NA_character_)) 
[13:20:51.562]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.562]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.562]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.562]                     envir = parent.frame()) 
[13:20:51.562]                   {
[13:20:51.562]                     default_workers <- missing(workers)
[13:20:51.562]                     if (is.function(workers)) 
[13:20:51.562]                       workers <- workers()
[13:20:51.562]                     workers <- structure(as.integer(workers), 
[13:20:51.562]                       class = class(workers))
[13:20:51.562]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.562]                       1L)
[13:20:51.562]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.562]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.562]                       if (default_workers) 
[13:20:51.562]                         supportsMulticore(warn = TRUE)
[13:20:51.562]                       return(sequential(..., envir = envir))
[13:20:51.562]                     }
[13:20:51.562]                     oopts <- options(mc.cores = workers)
[13:20:51.562]                     on.exit(options(oopts))
[13:20:51.562]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.562]                       envir = envir)
[13:20:51.562]                     if (!future$lazy) 
[13:20:51.562]                       future <- run(future)
[13:20:51.562]                     invisible(future)
[13:20:51.562]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.562]                 }
[13:20:51.562]             }
[13:20:51.562]         }
[13:20:51.562]     })
[13:20:51.562]     if (TRUE) {
[13:20:51.562]         base::sink(type = "output", split = FALSE)
[13:20:51.562]         if (TRUE) {
[13:20:51.562]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.562]         }
[13:20:51.562]         else {
[13:20:51.562]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.562]         }
[13:20:51.562]         base::close(...future.stdout)
[13:20:51.562]         ...future.stdout <- NULL
[13:20:51.562]     }
[13:20:51.562]     ...future.result$conditions <- ...future.conditions
[13:20:51.562]     ...future.result$finished <- base::Sys.time()
[13:20:51.562]     ...future.result
[13:20:51.562] }
[13:20:51.565] assign_globals() ...
[13:20:51.565] List of 2
[13:20:51.565]  $ a : num 1
[13:20:51.565]  $ ii: int 2
[13:20:51.565]  - attr(*, "where")=List of 2
[13:20:51.565]   ..$ a :<environment: R_EmptyEnv> 
[13:20:51.565]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:51.565]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:51.565]  - attr(*, "resolved")= logi TRUE
[13:20:51.565]  - attr(*, "total_size")= num 112
[13:20:51.565]  - attr(*, "already-done")= logi TRUE
[13:20:51.572] - copied ‘a’ to environment
[13:20:51.572] - copied ‘ii’ to environment
[13:20:51.573] assign_globals() ... done
[13:20:51.573] requestCore(): workers = 2
[13:20:51.575] MulticoreFuture started
[13:20:51.576] - Launch lazy future ... done
[13:20:51.576] plan(): Setting new future strategy stack:
[13:20:51.576] run() for ‘MulticoreFuture’ ... done
[13:20:51.577] List of future strategies:
[13:20:51.577] 1. sequential:
[13:20:51.577]    - args: function (..., envir = parent.frame())
[13:20:51.577]    - tweaked: FALSE
[13:20:51.577]    - call: NULL
[13:20:51.578] plan(): nbrOfWorkers() = 1
[13:20:51.581] plan(): Setting new future strategy stack:
[13:20:51.582] List of future strategies:
[13:20:51.582] 1. multicore:
[13:20:51.582]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.582]    - tweaked: FALSE
[13:20:51.582]    - call: plan(strategy)
[13:20:51.588] plan(): nbrOfWorkers() = 2
[13:20:51.590] run() for ‘Future’ ...
[13:20:51.590] - state: ‘created’
[13:20:51.590] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.595] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.595] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.595]   - Field: ‘label’
[13:20:51.596]   - Field: ‘local’
[13:20:51.596]   - Field: ‘owner’
[13:20:51.596]   - Field: ‘envir’
[13:20:51.596]   - Field: ‘workers’
[13:20:51.596]   - Field: ‘packages’
[13:20:51.596]   - Field: ‘gc’
[13:20:51.596]   - Field: ‘job’
[13:20:51.597]   - Field: ‘conditions’
[13:20:51.597]   - Field: ‘expr’
[13:20:51.597]   - Field: ‘uuid’
[13:20:51.597]   - Field: ‘seed’
[13:20:51.597]   - Field: ‘version’
[13:20:51.597]   - Field: ‘result’
[13:20:51.597]   - Field: ‘asynchronous’
[13:20:51.597]   - Field: ‘calls’
[13:20:51.598]   - Field: ‘globals’
[13:20:51.598]   - Field: ‘stdout’
[13:20:51.598]   - Field: ‘earlySignal’
[13:20:51.598]   - Field: ‘lazy’
[13:20:51.598]   - Field: ‘state’
[13:20:51.598] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.598] - Launch lazy future ...
[13:20:51.599] Packages needed by the future expression (n = 0): <none>
[13:20:51.599] Packages needed by future strategies (n = 0): <none>
[13:20:51.599] {
[13:20:51.599]     {
[13:20:51.599]         {
[13:20:51.599]             ...future.startTime <- base::Sys.time()
[13:20:51.599]             {
[13:20:51.599]                 {
[13:20:51.599]                   {
[13:20:51.599]                     {
[13:20:51.599]                       base::local({
[13:20:51.599]                         has_future <- base::requireNamespace("future", 
[13:20:51.599]                           quietly = TRUE)
[13:20:51.599]                         if (has_future) {
[13:20:51.599]                           ns <- base::getNamespace("future")
[13:20:51.599]                           version <- ns[[".package"]][["version"]]
[13:20:51.599]                           if (is.null(version)) 
[13:20:51.599]                             version <- utils::packageVersion("future")
[13:20:51.599]                         }
[13:20:51.599]                         else {
[13:20:51.599]                           version <- NULL
[13:20:51.599]                         }
[13:20:51.599]                         if (!has_future || version < "1.8.0") {
[13:20:51.599]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.599]                             "", base::R.version$version.string), 
[13:20:51.599]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:51.599]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:51.599]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.599]                               "release", "version")], collapse = " "), 
[13:20:51.599]                             hostname = base::Sys.info()[["nodename"]])
[13:20:51.599]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.599]                             info)
[13:20:51.599]                           info <- base::paste(info, collapse = "; ")
[13:20:51.599]                           if (!has_future) {
[13:20:51.599]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.599]                               info)
[13:20:51.599]                           }
[13:20:51.599]                           else {
[13:20:51.599]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.599]                               info, version)
[13:20:51.599]                           }
[13:20:51.599]                           base::stop(msg)
[13:20:51.599]                         }
[13:20:51.599]                       })
[13:20:51.599]                     }
[13:20:51.599]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.599]                     base::options(mc.cores = 1L)
[13:20:51.599]                   }
[13:20:51.599]                   options(future.plan = NULL)
[13:20:51.599]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.599]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.599]                 }
[13:20:51.599]                 ...future.workdir <- getwd()
[13:20:51.599]             }
[13:20:51.599]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.599]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.599]         }
[13:20:51.599]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.599]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:51.599]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.599]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.599]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.599]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.599]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.599]             base::names(...future.oldOptions))
[13:20:51.599]     }
[13:20:51.599]     if (FALSE) {
[13:20:51.599]     }
[13:20:51.599]     else {
[13:20:51.599]         if (TRUE) {
[13:20:51.599]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.599]                 open = "w")
[13:20:51.599]         }
[13:20:51.599]         else {
[13:20:51.599]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.599]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.599]         }
[13:20:51.599]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.599]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.599]             base::sink(type = "output", split = FALSE)
[13:20:51.599]             base::close(...future.stdout)
[13:20:51.599]         }, add = TRUE)
[13:20:51.599]     }
[13:20:51.599]     ...future.frame <- base::sys.nframe()
[13:20:51.599]     ...future.conditions <- base::list()
[13:20:51.599]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.599]     if (FALSE) {
[13:20:51.599]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.599]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.599]     }
[13:20:51.599]     ...future.result <- base::tryCatch({
[13:20:51.599]         base::withCallingHandlers({
[13:20:51.599]             ...future.value <- base::withVisible(base::local({
[13:20:51.599]                 withCallingHandlers({
[13:20:51.599]                   {
[13:20:51.599]                     b <- a * ii
[13:20:51.599]                     a <- 0
[13:20:51.599]                     b
[13:20:51.599]                   }
[13:20:51.599]                 }, immediateCondition = function(cond) {
[13:20:51.599]                   save_rds <- function (object, pathname, ...) 
[13:20:51.599]                   {
[13:20:51.599]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.599]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.599]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.599]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.599]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.599]                         fi_tmp[["mtime"]])
[13:20:51.599]                     }
[13:20:51.599]                     tryCatch({
[13:20:51.599]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.599]                     }, error = function(ex) {
[13:20:51.599]                       msg <- conditionMessage(ex)
[13:20:51.599]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.599]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.599]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.599]                         fi_tmp[["mtime"]], msg)
[13:20:51.599]                       ex$message <- msg
[13:20:51.599]                       stop(ex)
[13:20:51.599]                     })
[13:20:51.599]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.599]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.599]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.599]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.599]                       fi <- file.info(pathname)
[13:20:51.599]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.599]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.599]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.599]                         fi[["size"]], fi[["mtime"]])
[13:20:51.599]                       stop(msg)
[13:20:51.599]                     }
[13:20:51.599]                     invisible(pathname)
[13:20:51.599]                   }
[13:20:51.599]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.599]                     rootPath = tempdir()) 
[13:20:51.599]                   {
[13:20:51.599]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.599]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.599]                       tmpdir = path, fileext = ".rds")
[13:20:51.599]                     save_rds(obj, file)
[13:20:51.599]                   }
[13:20:51.599]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.599]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.599]                   {
[13:20:51.599]                     inherits <- base::inherits
[13:20:51.599]                     invokeRestart <- base::invokeRestart
[13:20:51.599]                     is.null <- base::is.null
[13:20:51.599]                     muffled <- FALSE
[13:20:51.599]                     if (inherits(cond, "message")) {
[13:20:51.599]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.599]                       if (muffled) 
[13:20:51.599]                         invokeRestart("muffleMessage")
[13:20:51.599]                     }
[13:20:51.599]                     else if (inherits(cond, "warning")) {
[13:20:51.599]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.599]                       if (muffled) 
[13:20:51.599]                         invokeRestart("muffleWarning")
[13:20:51.599]                     }
[13:20:51.599]                     else if (inherits(cond, "condition")) {
[13:20:51.599]                       if (!is.null(pattern)) {
[13:20:51.599]                         computeRestarts <- base::computeRestarts
[13:20:51.599]                         grepl <- base::grepl
[13:20:51.599]                         restarts <- computeRestarts(cond)
[13:20:51.599]                         for (restart in restarts) {
[13:20:51.599]                           name <- restart$name
[13:20:51.599]                           if (is.null(name)) 
[13:20:51.599]                             next
[13:20:51.599]                           if (!grepl(pattern, name)) 
[13:20:51.599]                             next
[13:20:51.599]                           invokeRestart(restart)
[13:20:51.599]                           muffled <- TRUE
[13:20:51.599]                           break
[13:20:51.599]                         }
[13:20:51.599]                       }
[13:20:51.599]                     }
[13:20:51.599]                     invisible(muffled)
[13:20:51.599]                   }
[13:20:51.599]                   muffleCondition(cond)
[13:20:51.599]                 })
[13:20:51.599]             }))
[13:20:51.599]             future::FutureResult(value = ...future.value$value, 
[13:20:51.599]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.599]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.599]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.599]                     ...future.globalenv.names))
[13:20:51.599]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.599]         }, condition = base::local({
[13:20:51.599]             c <- base::c
[13:20:51.599]             inherits <- base::inherits
[13:20:51.599]             invokeRestart <- base::invokeRestart
[13:20:51.599]             length <- base::length
[13:20:51.599]             list <- base::list
[13:20:51.599]             seq.int <- base::seq.int
[13:20:51.599]             signalCondition <- base::signalCondition
[13:20:51.599]             sys.calls <- base::sys.calls
[13:20:51.599]             `[[` <- base::`[[`
[13:20:51.599]             `+` <- base::`+`
[13:20:51.599]             `<<-` <- base::`<<-`
[13:20:51.599]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.599]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.599]                   3L)]
[13:20:51.599]             }
[13:20:51.599]             function(cond) {
[13:20:51.599]                 is_error <- inherits(cond, "error")
[13:20:51.599]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.599]                   NULL)
[13:20:51.599]                 if (is_error) {
[13:20:51.599]                   sessionInformation <- function() {
[13:20:51.599]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.599]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.599]                       search = base::search(), system = base::Sys.info())
[13:20:51.599]                   }
[13:20:51.599]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.599]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.599]                     cond$call), session = sessionInformation(), 
[13:20:51.599]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.599]                   signalCondition(cond)
[13:20:51.599]                 }
[13:20:51.599]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.599]                 "immediateCondition"))) {
[13:20:51.599]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.599]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.599]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.599]                   if (TRUE && !signal) {
[13:20:51.599]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.599]                     {
[13:20:51.599]                       inherits <- base::inherits
[13:20:51.599]                       invokeRestart <- base::invokeRestart
[13:20:51.599]                       is.null <- base::is.null
[13:20:51.599]                       muffled <- FALSE
[13:20:51.599]                       if (inherits(cond, "message")) {
[13:20:51.599]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.599]                         if (muffled) 
[13:20:51.599]                           invokeRestart("muffleMessage")
[13:20:51.599]                       }
[13:20:51.599]                       else if (inherits(cond, "warning")) {
[13:20:51.599]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.599]                         if (muffled) 
[13:20:51.599]                           invokeRestart("muffleWarning")
[13:20:51.599]                       }
[13:20:51.599]                       else if (inherits(cond, "condition")) {
[13:20:51.599]                         if (!is.null(pattern)) {
[13:20:51.599]                           computeRestarts <- base::computeRestarts
[13:20:51.599]                           grepl <- base::grepl
[13:20:51.599]                           restarts <- computeRestarts(cond)
[13:20:51.599]                           for (restart in restarts) {
[13:20:51.599]                             name <- restart$name
[13:20:51.599]                             if (is.null(name)) 
[13:20:51.599]                               next
[13:20:51.599]                             if (!grepl(pattern, name)) 
[13:20:51.599]                               next
[13:20:51.599]                             invokeRestart(restart)
[13:20:51.599]                             muffled <- TRUE
[13:20:51.599]                             break
[13:20:51.599]                           }
[13:20:51.599]                         }
[13:20:51.599]                       }
[13:20:51.599]                       invisible(muffled)
[13:20:51.599]                     }
[13:20:51.599]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.599]                   }
[13:20:51.599]                 }
[13:20:51.599]                 else {
[13:20:51.599]                   if (TRUE) {
[13:20:51.599]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.599]                     {
[13:20:51.599]                       inherits <- base::inherits
[13:20:51.599]                       invokeRestart <- base::invokeRestart
[13:20:51.599]                       is.null <- base::is.null
[13:20:51.599]                       muffled <- FALSE
[13:20:51.599]                       if (inherits(cond, "message")) {
[13:20:51.599]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.599]                         if (muffled) 
[13:20:51.599]                           invokeRestart("muffleMessage")
[13:20:51.599]                       }
[13:20:51.599]                       else if (inherits(cond, "warning")) {
[13:20:51.599]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.599]                         if (muffled) 
[13:20:51.599]                           invokeRestart("muffleWarning")
[13:20:51.599]                       }
[13:20:51.599]                       else if (inherits(cond, "condition")) {
[13:20:51.599]                         if (!is.null(pattern)) {
[13:20:51.599]                           computeRestarts <- base::computeRestarts
[13:20:51.599]                           grepl <- base::grepl
[13:20:51.599]                           restarts <- computeRestarts(cond)
[13:20:51.599]                           for (restart in restarts) {
[13:20:51.599]                             name <- restart$name
[13:20:51.599]                             if (is.null(name)) 
[13:20:51.599]                               next
[13:20:51.599]                             if (!grepl(pattern, name)) 
[13:20:51.599]                               next
[13:20:51.599]                             invokeRestart(restart)
[13:20:51.599]                             muffled <- TRUE
[13:20:51.599]                             break
[13:20:51.599]                           }
[13:20:51.599]                         }
[13:20:51.599]                       }
[13:20:51.599]                       invisible(muffled)
[13:20:51.599]                     }
[13:20:51.599]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.599]                   }
[13:20:51.599]                 }
[13:20:51.599]             }
[13:20:51.599]         }))
[13:20:51.599]     }, error = function(ex) {
[13:20:51.599]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.599]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.599]                 ...future.rng), started = ...future.startTime, 
[13:20:51.599]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.599]             version = "1.8"), class = "FutureResult")
[13:20:51.599]     }, finally = {
[13:20:51.599]         if (!identical(...future.workdir, getwd())) 
[13:20:51.599]             setwd(...future.workdir)
[13:20:51.599]         {
[13:20:51.599]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.599]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.599]             }
[13:20:51.599]             base::options(...future.oldOptions)
[13:20:51.599]             if (.Platform$OS.type == "windows") {
[13:20:51.599]                 old_names <- names(...future.oldEnvVars)
[13:20:51.599]                 envs <- base::Sys.getenv()
[13:20:51.599]                 names <- names(envs)
[13:20:51.599]                 common <- intersect(names, old_names)
[13:20:51.599]                 added <- setdiff(names, old_names)
[13:20:51.599]                 removed <- setdiff(old_names, names)
[13:20:51.599]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.599]                   envs[common]]
[13:20:51.599]                 NAMES <- toupper(changed)
[13:20:51.599]                 args <- list()
[13:20:51.599]                 for (kk in seq_along(NAMES)) {
[13:20:51.599]                   name <- changed[[kk]]
[13:20:51.599]                   NAME <- NAMES[[kk]]
[13:20:51.599]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.599]                     next
[13:20:51.599]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.599]                 }
[13:20:51.599]                 NAMES <- toupper(added)
[13:20:51.599]                 for (kk in seq_along(NAMES)) {
[13:20:51.599]                   name <- added[[kk]]
[13:20:51.599]                   NAME <- NAMES[[kk]]
[13:20:51.599]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.599]                     next
[13:20:51.599]                   args[[name]] <- ""
[13:20:51.599]                 }
[13:20:51.599]                 NAMES <- toupper(removed)
[13:20:51.599]                 for (kk in seq_along(NAMES)) {
[13:20:51.599]                   name <- removed[[kk]]
[13:20:51.599]                   NAME <- NAMES[[kk]]
[13:20:51.599]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.599]                     next
[13:20:51.599]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.599]                 }
[13:20:51.599]                 if (length(args) > 0) 
[13:20:51.599]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.599]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.599]             }
[13:20:51.599]             else {
[13:20:51.599]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.599]             }
[13:20:51.599]             {
[13:20:51.599]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.599]                   0L) {
[13:20:51.599]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.599]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.599]                   base::options(opts)
[13:20:51.599]                 }
[13:20:51.599]                 {
[13:20:51.599]                   {
[13:20:51.599]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.599]                     NULL
[13:20:51.599]                   }
[13:20:51.599]                   options(future.plan = NULL)
[13:20:51.599]                   if (is.na(NA_character_)) 
[13:20:51.599]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.599]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.599]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.599]                     envir = parent.frame()) 
[13:20:51.599]                   {
[13:20:51.599]                     default_workers <- missing(workers)
[13:20:51.599]                     if (is.function(workers)) 
[13:20:51.599]                       workers <- workers()
[13:20:51.599]                     workers <- structure(as.integer(workers), 
[13:20:51.599]                       class = class(workers))
[13:20:51.599]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.599]                       1L)
[13:20:51.599]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.599]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.599]                       if (default_workers) 
[13:20:51.599]                         supportsMulticore(warn = TRUE)
[13:20:51.599]                       return(sequential(..., envir = envir))
[13:20:51.599]                     }
[13:20:51.599]                     oopts <- options(mc.cores = workers)
[13:20:51.599]                     on.exit(options(oopts))
[13:20:51.599]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.599]                       envir = envir)
[13:20:51.599]                     if (!future$lazy) 
[13:20:51.599]                       future <- run(future)
[13:20:51.599]                     invisible(future)
[13:20:51.599]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.599]                 }
[13:20:51.599]             }
[13:20:51.599]         }
[13:20:51.599]     })
[13:20:51.599]     if (TRUE) {
[13:20:51.599]         base::sink(type = "output", split = FALSE)
[13:20:51.599]         if (TRUE) {
[13:20:51.599]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.599]         }
[13:20:51.599]         else {
[13:20:51.599]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.599]         }
[13:20:51.599]         base::close(...future.stdout)
[13:20:51.599]         ...future.stdout <- NULL
[13:20:51.599]     }
[13:20:51.599]     ...future.result$conditions <- ...future.conditions
[13:20:51.599]     ...future.result$finished <- base::Sys.time()
[13:20:51.599]     ...future.result
[13:20:51.599] }
[13:20:51.602] assign_globals() ...
[13:20:51.602] List of 2
[13:20:51.602]  $ a : num 1
[13:20:51.602]  $ ii: int 3
[13:20:51.602]  - attr(*, "where")=List of 2
[13:20:51.602]   ..$ a :<environment: R_EmptyEnv> 
[13:20:51.602]   ..$ ii:<environment: R_EmptyEnv> 
[13:20:51.602]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:51.602]  - attr(*, "resolved")= logi TRUE
[13:20:51.602]  - attr(*, "total_size")= num 112
[13:20:51.602]  - attr(*, "already-done")= logi TRUE
[13:20:51.606] - copied ‘a’ to environment
[13:20:51.606] - copied ‘ii’ to environment
[13:20:51.606] assign_globals() ... done
[13:20:51.607] requestCore(): workers = 2
[13:20:51.608] MulticoreFuture started
[13:20:51.609] - Launch lazy future ... done
[13:20:51.609] run() for ‘MulticoreFuture’ ... done
[13:20:51.610] plan(): Setting new future strategy stack:
[13:20:51.610] List of future strategies:
[13:20:51.610] 1. sequential:
[13:20:51.610]    - args: function (..., envir = parent.frame())
[13:20:51.610]    - tweaked: FALSE
[13:20:51.610]    - call: NULL
[13:20:51.611] plan(): nbrOfWorkers() = 1
[13:20:51.613] plan(): Setting new future strategy stack:
[13:20:51.613] List of future strategies:
[13:20:51.613] 1. multicore:
[13:20:51.613]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.613]    - tweaked: FALSE
[13:20:51.613]    - call: plan(strategy)
[13:20:51.618] plan(): nbrOfWorkers() = 2
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.620] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.621] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:51.622] 
[13:20:51.622] Searching for globals ... DONE
[13:20:51.622] - globals: [0] <none>
[13:20:51.622] getGlobalsAndPackages() ... DONE
[13:20:51.622] run() for ‘Future’ ...
[13:20:51.622] - state: ‘created’
[13:20:51.623] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.627] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.627] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.627]   - Field: ‘label’
[13:20:51.627]   - Field: ‘local’
[13:20:51.627]   - Field: ‘owner’
[13:20:51.627]   - Field: ‘envir’
[13:20:51.628]   - Field: ‘workers’
[13:20:51.628]   - Field: ‘packages’
[13:20:51.628]   - Field: ‘gc’
[13:20:51.628]   - Field: ‘job’
[13:20:51.628]   - Field: ‘conditions’
[13:20:51.628]   - Field: ‘expr’
[13:20:51.628]   - Field: ‘uuid’
[13:20:51.628]   - Field: ‘seed’
[13:20:51.628]   - Field: ‘version’
[13:20:51.629]   - Field: ‘result’
[13:20:51.629]   - Field: ‘asynchronous’
[13:20:51.629]   - Field: ‘calls’
[13:20:51.629]   - Field: ‘globals’
[13:20:51.629]   - Field: ‘stdout’
[13:20:51.629]   - Field: ‘earlySignal’
[13:20:51.629]   - Field: ‘lazy’
[13:20:51.629]   - Field: ‘state’
[13:20:51.630] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.630] - Launch lazy future ...
[13:20:51.630] Packages needed by the future expression (n = 0): <none>
[13:20:51.630] Packages needed by future strategies (n = 0): <none>
[13:20:51.633] {
[13:20:51.633]     {
[13:20:51.633]         {
[13:20:51.633]             ...future.startTime <- base::Sys.time()
[13:20:51.633]             {
[13:20:51.633]                 {
[13:20:51.633]                   {
[13:20:51.633]                     {
[13:20:51.633]                       base::local({
[13:20:51.633]                         has_future <- base::requireNamespace("future", 
[13:20:51.633]                           quietly = TRUE)
[13:20:51.633]                         if (has_future) {
[13:20:51.633]                           ns <- base::getNamespace("future")
[13:20:51.633]                           version <- ns[[".package"]][["version"]]
[13:20:51.633]                           if (is.null(version)) 
[13:20:51.633]                             version <- utils::packageVersion("future")
[13:20:51.633]                         }
[13:20:51.633]                         else {
[13:20:51.633]                           version <- NULL
[13:20:51.633]                         }
[13:20:51.633]                         if (!has_future || version < "1.8.0") {
[13:20:51.633]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.633]                             "", base::R.version$version.string), 
[13:20:51.633]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:51.633]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:51.633]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.633]                               "release", "version")], collapse = " "), 
[13:20:51.633]                             hostname = base::Sys.info()[["nodename"]])
[13:20:51.633]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.633]                             info)
[13:20:51.633]                           info <- base::paste(info, collapse = "; ")
[13:20:51.633]                           if (!has_future) {
[13:20:51.633]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.633]                               info)
[13:20:51.633]                           }
[13:20:51.633]                           else {
[13:20:51.633]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.633]                               info, version)
[13:20:51.633]                           }
[13:20:51.633]                           base::stop(msg)
[13:20:51.633]                         }
[13:20:51.633]                       })
[13:20:51.633]                     }
[13:20:51.633]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.633]                     base::options(mc.cores = 1L)
[13:20:51.633]                   }
[13:20:51.633]                   options(future.plan = NULL)
[13:20:51.633]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.633]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.633]                 }
[13:20:51.633]                 ...future.workdir <- getwd()
[13:20:51.633]             }
[13:20:51.633]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.633]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.633]         }
[13:20:51.633]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.633]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:51.633]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.633]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.633]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.633]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.633]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.633]             base::names(...future.oldOptions))
[13:20:51.633]     }
[13:20:51.633]     if (FALSE) {
[13:20:51.633]     }
[13:20:51.633]     else {
[13:20:51.633]         if (TRUE) {
[13:20:51.633]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.633]                 open = "w")
[13:20:51.633]         }
[13:20:51.633]         else {
[13:20:51.633]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.633]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.633]         }
[13:20:51.633]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.633]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.633]             base::sink(type = "output", split = FALSE)
[13:20:51.633]             base::close(...future.stdout)
[13:20:51.633]         }, add = TRUE)
[13:20:51.633]     }
[13:20:51.633]     ...future.frame <- base::sys.nframe()
[13:20:51.633]     ...future.conditions <- base::list()
[13:20:51.633]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.633]     if (FALSE) {
[13:20:51.633]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.633]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.633]     }
[13:20:51.633]     ...future.result <- base::tryCatch({
[13:20:51.633]         base::withCallingHandlers({
[13:20:51.633]             ...future.value <- base::withVisible(base::local({
[13:20:51.633]                 withCallingHandlers({
[13:20:51.633]                   1
[13:20:51.633]                 }, immediateCondition = function(cond) {
[13:20:51.633]                   save_rds <- function (object, pathname, ...) 
[13:20:51.633]                   {
[13:20:51.633]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.633]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.633]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.633]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.633]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.633]                         fi_tmp[["mtime"]])
[13:20:51.633]                     }
[13:20:51.633]                     tryCatch({
[13:20:51.633]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.633]                     }, error = function(ex) {
[13:20:51.633]                       msg <- conditionMessage(ex)
[13:20:51.633]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.633]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.633]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.633]                         fi_tmp[["mtime"]], msg)
[13:20:51.633]                       ex$message <- msg
[13:20:51.633]                       stop(ex)
[13:20:51.633]                     })
[13:20:51.633]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.633]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.633]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.633]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.633]                       fi <- file.info(pathname)
[13:20:51.633]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.633]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.633]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.633]                         fi[["size"]], fi[["mtime"]])
[13:20:51.633]                       stop(msg)
[13:20:51.633]                     }
[13:20:51.633]                     invisible(pathname)
[13:20:51.633]                   }
[13:20:51.633]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.633]                     rootPath = tempdir()) 
[13:20:51.633]                   {
[13:20:51.633]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.633]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.633]                       tmpdir = path, fileext = ".rds")
[13:20:51.633]                     save_rds(obj, file)
[13:20:51.633]                   }
[13:20:51.633]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.633]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.633]                   {
[13:20:51.633]                     inherits <- base::inherits
[13:20:51.633]                     invokeRestart <- base::invokeRestart
[13:20:51.633]                     is.null <- base::is.null
[13:20:51.633]                     muffled <- FALSE
[13:20:51.633]                     if (inherits(cond, "message")) {
[13:20:51.633]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.633]                       if (muffled) 
[13:20:51.633]                         invokeRestart("muffleMessage")
[13:20:51.633]                     }
[13:20:51.633]                     else if (inherits(cond, "warning")) {
[13:20:51.633]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.633]                       if (muffled) 
[13:20:51.633]                         invokeRestart("muffleWarning")
[13:20:51.633]                     }
[13:20:51.633]                     else if (inherits(cond, "condition")) {
[13:20:51.633]                       if (!is.null(pattern)) {
[13:20:51.633]                         computeRestarts <- base::computeRestarts
[13:20:51.633]                         grepl <- base::grepl
[13:20:51.633]                         restarts <- computeRestarts(cond)
[13:20:51.633]                         for (restart in restarts) {
[13:20:51.633]                           name <- restart$name
[13:20:51.633]                           if (is.null(name)) 
[13:20:51.633]                             next
[13:20:51.633]                           if (!grepl(pattern, name)) 
[13:20:51.633]                             next
[13:20:51.633]                           invokeRestart(restart)
[13:20:51.633]                           muffled <- TRUE
[13:20:51.633]                           break
[13:20:51.633]                         }
[13:20:51.633]                       }
[13:20:51.633]                     }
[13:20:51.633]                     invisible(muffled)
[13:20:51.633]                   }
[13:20:51.633]                   muffleCondition(cond)
[13:20:51.633]                 })
[13:20:51.633]             }))
[13:20:51.633]             future::FutureResult(value = ...future.value$value, 
[13:20:51.633]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.633]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.633]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.633]                     ...future.globalenv.names))
[13:20:51.633]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.633]         }, condition = base::local({
[13:20:51.633]             c <- base::c
[13:20:51.633]             inherits <- base::inherits
[13:20:51.633]             invokeRestart <- base::invokeRestart
[13:20:51.633]             length <- base::length
[13:20:51.633]             list <- base::list
[13:20:51.633]             seq.int <- base::seq.int
[13:20:51.633]             signalCondition <- base::signalCondition
[13:20:51.633]             sys.calls <- base::sys.calls
[13:20:51.633]             `[[` <- base::`[[`
[13:20:51.633]             `+` <- base::`+`
[13:20:51.633]             `<<-` <- base::`<<-`
[13:20:51.633]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.633]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.633]                   3L)]
[13:20:51.633]             }
[13:20:51.633]             function(cond) {
[13:20:51.633]                 is_error <- inherits(cond, "error")
[13:20:51.633]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.633]                   NULL)
[13:20:51.633]                 if (is_error) {
[13:20:51.633]                   sessionInformation <- function() {
[13:20:51.633]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.633]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.633]                       search = base::search(), system = base::Sys.info())
[13:20:51.633]                   }
[13:20:51.633]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.633]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.633]                     cond$call), session = sessionInformation(), 
[13:20:51.633]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.633]                   signalCondition(cond)
[13:20:51.633]                 }
[13:20:51.633]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.633]                 "immediateCondition"))) {
[13:20:51.633]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.633]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.633]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.633]                   if (TRUE && !signal) {
[13:20:51.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.633]                     {
[13:20:51.633]                       inherits <- base::inherits
[13:20:51.633]                       invokeRestart <- base::invokeRestart
[13:20:51.633]                       is.null <- base::is.null
[13:20:51.633]                       muffled <- FALSE
[13:20:51.633]                       if (inherits(cond, "message")) {
[13:20:51.633]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.633]                         if (muffled) 
[13:20:51.633]                           invokeRestart("muffleMessage")
[13:20:51.633]                       }
[13:20:51.633]                       else if (inherits(cond, "warning")) {
[13:20:51.633]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.633]                         if (muffled) 
[13:20:51.633]                           invokeRestart("muffleWarning")
[13:20:51.633]                       }
[13:20:51.633]                       else if (inherits(cond, "condition")) {
[13:20:51.633]                         if (!is.null(pattern)) {
[13:20:51.633]                           computeRestarts <- base::computeRestarts
[13:20:51.633]                           grepl <- base::grepl
[13:20:51.633]                           restarts <- computeRestarts(cond)
[13:20:51.633]                           for (restart in restarts) {
[13:20:51.633]                             name <- restart$name
[13:20:51.633]                             if (is.null(name)) 
[13:20:51.633]                               next
[13:20:51.633]                             if (!grepl(pattern, name)) 
[13:20:51.633]                               next
[13:20:51.633]                             invokeRestart(restart)
[13:20:51.633]                             muffled <- TRUE
[13:20:51.633]                             break
[13:20:51.633]                           }
[13:20:51.633]                         }
[13:20:51.633]                       }
[13:20:51.633]                       invisible(muffled)
[13:20:51.633]                     }
[13:20:51.633]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.633]                   }
[13:20:51.633]                 }
[13:20:51.633]                 else {
[13:20:51.633]                   if (TRUE) {
[13:20:51.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.633]                     {
[13:20:51.633]                       inherits <- base::inherits
[13:20:51.633]                       invokeRestart <- base::invokeRestart
[13:20:51.633]                       is.null <- base::is.null
[13:20:51.633]                       muffled <- FALSE
[13:20:51.633]                       if (inherits(cond, "message")) {
[13:20:51.633]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.633]                         if (muffled) 
[13:20:51.633]                           invokeRestart("muffleMessage")
[13:20:51.633]                       }
[13:20:51.633]                       else if (inherits(cond, "warning")) {
[13:20:51.633]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.633]                         if (muffled) 
[13:20:51.633]                           invokeRestart("muffleWarning")
[13:20:51.633]                       }
[13:20:51.633]                       else if (inherits(cond, "condition")) {
[13:20:51.633]                         if (!is.null(pattern)) {
[13:20:51.633]                           computeRestarts <- base::computeRestarts
[13:20:51.633]                           grepl <- base::grepl
[13:20:51.633]                           restarts <- computeRestarts(cond)
[13:20:51.633]                           for (restart in restarts) {
[13:20:51.633]                             name <- restart$name
[13:20:51.633]                             if (is.null(name)) 
[13:20:51.633]                               next
[13:20:51.633]                             if (!grepl(pattern, name)) 
[13:20:51.633]                               next
[13:20:51.633]                             invokeRestart(restart)
[13:20:51.633]                             muffled <- TRUE
[13:20:51.633]                             break
[13:20:51.633]                           }
[13:20:51.633]                         }
[13:20:51.633]                       }
[13:20:51.633]                       invisible(muffled)
[13:20:51.633]                     }
[13:20:51.633]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.633]                   }
[13:20:51.633]                 }
[13:20:51.633]             }
[13:20:51.633]         }))
[13:20:51.633]     }, error = function(ex) {
[13:20:51.633]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.633]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.633]                 ...future.rng), started = ...future.startTime, 
[13:20:51.633]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.633]             version = "1.8"), class = "FutureResult")
[13:20:51.633]     }, finally = {
[13:20:51.633]         if (!identical(...future.workdir, getwd())) 
[13:20:51.633]             setwd(...future.workdir)
[13:20:51.633]         {
[13:20:51.633]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.633]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.633]             }
[13:20:51.633]             base::options(...future.oldOptions)
[13:20:51.633]             if (.Platform$OS.type == "windows") {
[13:20:51.633]                 old_names <- names(...future.oldEnvVars)
[13:20:51.633]                 envs <- base::Sys.getenv()
[13:20:51.633]                 names <- names(envs)
[13:20:51.633]                 common <- intersect(names, old_names)
[13:20:51.633]                 added <- setdiff(names, old_names)
[13:20:51.633]                 removed <- setdiff(old_names, names)
[13:20:51.633]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.633]                   envs[common]]
[13:20:51.633]                 NAMES <- toupper(changed)
[13:20:51.633]                 args <- list()
[13:20:51.633]                 for (kk in seq_along(NAMES)) {
[13:20:51.633]                   name <- changed[[kk]]
[13:20:51.633]                   NAME <- NAMES[[kk]]
[13:20:51.633]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.633]                     next
[13:20:51.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.633]                 }
[13:20:51.633]                 NAMES <- toupper(added)
[13:20:51.633]                 for (kk in seq_along(NAMES)) {
[13:20:51.633]                   name <- added[[kk]]
[13:20:51.633]                   NAME <- NAMES[[kk]]
[13:20:51.633]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.633]                     next
[13:20:51.633]                   args[[name]] <- ""
[13:20:51.633]                 }
[13:20:51.633]                 NAMES <- toupper(removed)
[13:20:51.633]                 for (kk in seq_along(NAMES)) {
[13:20:51.633]                   name <- removed[[kk]]
[13:20:51.633]                   NAME <- NAMES[[kk]]
[13:20:51.633]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.633]                     next
[13:20:51.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.633]                 }
[13:20:51.633]                 if (length(args) > 0) 
[13:20:51.633]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.633]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.633]             }
[13:20:51.633]             else {
[13:20:51.633]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.633]             }
[13:20:51.633]             {
[13:20:51.633]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.633]                   0L) {
[13:20:51.633]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.633]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.633]                   base::options(opts)
[13:20:51.633]                 }
[13:20:51.633]                 {
[13:20:51.633]                   {
[13:20:51.633]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.633]                     NULL
[13:20:51.633]                   }
[13:20:51.633]                   options(future.plan = NULL)
[13:20:51.633]                   if (is.na(NA_character_)) 
[13:20:51.633]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.633]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.633]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.633]                     envir = parent.frame()) 
[13:20:51.633]                   {
[13:20:51.633]                     default_workers <- missing(workers)
[13:20:51.633]                     if (is.function(workers)) 
[13:20:51.633]                       workers <- workers()
[13:20:51.633]                     workers <- structure(as.integer(workers), 
[13:20:51.633]                       class = class(workers))
[13:20:51.633]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.633]                       1L)
[13:20:51.633]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.633]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.633]                       if (default_workers) 
[13:20:51.633]                         supportsMulticore(warn = TRUE)
[13:20:51.633]                       return(sequential(..., envir = envir))
[13:20:51.633]                     }
[13:20:51.633]                     oopts <- options(mc.cores = workers)
[13:20:51.633]                     on.exit(options(oopts))
[13:20:51.633]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.633]                       envir = envir)
[13:20:51.633]                     if (!future$lazy) 
[13:20:51.633]                       future <- run(future)
[13:20:51.633]                     invisible(future)
[13:20:51.633]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.633]                 }
[13:20:51.633]             }
[13:20:51.633]         }
[13:20:51.633]     })
[13:20:51.633]     if (TRUE) {
[13:20:51.633]         base::sink(type = "output", split = FALSE)
[13:20:51.633]         if (TRUE) {
[13:20:51.633]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.633]         }
[13:20:51.633]         else {
[13:20:51.633]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.633]         }
[13:20:51.633]         base::close(...future.stdout)
[13:20:51.633]         ...future.stdout <- NULL
[13:20:51.633]     }
[13:20:51.633]     ...future.result$conditions <- ...future.conditions
[13:20:51.633]     ...future.result$finished <- base::Sys.time()
[13:20:51.633]     ...future.result
[13:20:51.633] }
[13:20:51.636] requestCore(): workers = 2
[13:20:51.638] MulticoreFuture started
[13:20:51.639] - Launch lazy future ... done
[13:20:51.640] run() for ‘MulticoreFuture’ ... done
[13:20:51.640] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.641] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.640] List of future strategies:
[13:20:51.640] 1. sequential:
[13:20:51.640]    - args: function (..., envir = parent.frame())
[13:20:51.640]    - tweaked: FALSE
[13:20:51.640]    - call: NULL
[13:20:51.641] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:51.641] plan(): nbrOfWorkers() = 1
[13:20:51.644] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:51.644] plan(): Setting new future strategy stack:
[13:20:51.644] Searching for globals ... DONE
[13:20:51.644] Resolving globals: TRUE
[13:20:51.644] Resolving any globals that are futures ...
[13:20:51.644] List of future strategies:
[13:20:51.644] 1. multicore:
[13:20:51.644]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.644]    - tweaked: FALSE
[13:20:51.644]    - call: plan(strategy)
[13:20:51.644] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:51.645] Resolving any globals that are futures ... DONE
[13:20:51.646] Resolving futures part of globals (recursively) ...
[13:20:51.647] resolve() on list ...
[13:20:51.647]  recursive: 99
[13:20:51.648]  length: 1
[13:20:51.648]  elements: ‘a’
[13:20:51.649] plan(): nbrOfWorkers() = 2
[13:20:51.650] Future #1
[13:20:51.652] A MulticoreFuture was resolved
[13:20:51.652]  length: 0 (resolved future 1)
[13:20:51.652] resolve() on list ... DONE
[13:20:51.652] - globals: [1] ‘a’
[13:20:51.652] Resolving futures part of globals (recursively) ... DONE
[13:20:51.655] The total size of the 1 globals is 1.55 MiB (1629776 bytes)
[13:20:51.656] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[13:20:51.656] - globals: [1] ‘a’
[13:20:51.656] - packages: [1] ‘future’
[13:20:51.656] getGlobalsAndPackages() ... DONE
[13:20:51.657] run() for ‘Future’ ...
[13:20:51.657] - state: ‘created’
[13:20:51.657] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.661] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.661] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.661]   - Field: ‘label’
[13:20:51.661]   - Field: ‘local’
[13:20:51.662]   - Field: ‘owner’
[13:20:51.662]   - Field: ‘envir’
[13:20:51.662]   - Field: ‘workers’
[13:20:51.662]   - Field: ‘packages’
[13:20:51.662]   - Field: ‘gc’
[13:20:51.662]   - Field: ‘job’
[13:20:51.662]   - Field: ‘conditions’
[13:20:51.662]   - Field: ‘expr’
[13:20:51.662]   - Field: ‘uuid’
[13:20:51.663]   - Field: ‘seed’
[13:20:51.663]   - Field: ‘version’
[13:20:51.663]   - Field: ‘result’
[13:20:51.663]   - Field: ‘asynchronous’
[13:20:51.663]   - Field: ‘calls’
[13:20:51.663]   - Field: ‘globals’
[13:20:51.663]   - Field: ‘stdout’
[13:20:51.663]   - Field: ‘earlySignal’
[13:20:51.663]   - Field: ‘lazy’
[13:20:51.664]   - Field: ‘state’
[13:20:51.664] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.664] - Launch lazy future ...
[13:20:51.664] Packages needed by the future expression (n = 1): ‘future’
[13:20:51.664] Packages needed by future strategies (n = 0): <none>
[13:20:51.665] {
[13:20:51.665]     {
[13:20:51.665]         {
[13:20:51.665]             ...future.startTime <- base::Sys.time()
[13:20:51.665]             {
[13:20:51.665]                 {
[13:20:51.665]                   {
[13:20:51.665]                     {
[13:20:51.665]                       {
[13:20:51.665]                         base::local({
[13:20:51.665]                           has_future <- base::requireNamespace("future", 
[13:20:51.665]                             quietly = TRUE)
[13:20:51.665]                           if (has_future) {
[13:20:51.665]                             ns <- base::getNamespace("future")
[13:20:51.665]                             version <- ns[[".package"]][["version"]]
[13:20:51.665]                             if (is.null(version)) 
[13:20:51.665]                               version <- utils::packageVersion("future")
[13:20:51.665]                           }
[13:20:51.665]                           else {
[13:20:51.665]                             version <- NULL
[13:20:51.665]                           }
[13:20:51.665]                           if (!has_future || version < "1.8.0") {
[13:20:51.665]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.665]                               "", base::R.version$version.string), 
[13:20:51.665]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:51.665]                                 base::R.version$platform, 8 * 
[13:20:51.665]                                   base::.Machine$sizeof.pointer), 
[13:20:51.665]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.665]                                 "release", "version")], collapse = " "), 
[13:20:51.665]                               hostname = base::Sys.info()[["nodename"]])
[13:20:51.665]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.665]                               info)
[13:20:51.665]                             info <- base::paste(info, collapse = "; ")
[13:20:51.665]                             if (!has_future) {
[13:20:51.665]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.665]                                 info)
[13:20:51.665]                             }
[13:20:51.665]                             else {
[13:20:51.665]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.665]                                 info, version)
[13:20:51.665]                             }
[13:20:51.665]                             base::stop(msg)
[13:20:51.665]                           }
[13:20:51.665]                         })
[13:20:51.665]                       }
[13:20:51.665]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.665]                       base::options(mc.cores = 1L)
[13:20:51.665]                     }
[13:20:51.665]                     base::local({
[13:20:51.665]                       for (pkg in "future") {
[13:20:51.665]                         base::loadNamespace(pkg)
[13:20:51.665]                         base::library(pkg, character.only = TRUE)
[13:20:51.665]                       }
[13:20:51.665]                     })
[13:20:51.665]                   }
[13:20:51.665]                   options(future.plan = NULL)
[13:20:51.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.665]                 }
[13:20:51.665]                 ...future.workdir <- getwd()
[13:20:51.665]             }
[13:20:51.665]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.665]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.665]         }
[13:20:51.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.665]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:51.665]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.665]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.665]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.665]             base::names(...future.oldOptions))
[13:20:51.665]     }
[13:20:51.665]     if (FALSE) {
[13:20:51.665]     }
[13:20:51.665]     else {
[13:20:51.665]         if (TRUE) {
[13:20:51.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.665]                 open = "w")
[13:20:51.665]         }
[13:20:51.665]         else {
[13:20:51.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.665]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.665]         }
[13:20:51.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.665]             base::sink(type = "output", split = FALSE)
[13:20:51.665]             base::close(...future.stdout)
[13:20:51.665]         }, add = TRUE)
[13:20:51.665]     }
[13:20:51.665]     ...future.frame <- base::sys.nframe()
[13:20:51.665]     ...future.conditions <- base::list()
[13:20:51.665]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.665]     if (FALSE) {
[13:20:51.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.665]     }
[13:20:51.665]     ...future.result <- base::tryCatch({
[13:20:51.665]         base::withCallingHandlers({
[13:20:51.665]             ...future.value <- base::withVisible(base::local({
[13:20:51.665]                 withCallingHandlers({
[13:20:51.665]                   value(a) + 1
[13:20:51.665]                 }, immediateCondition = function(cond) {
[13:20:51.665]                   save_rds <- function (object, pathname, ...) 
[13:20:51.665]                   {
[13:20:51.665]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.665]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.665]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.665]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.665]                         fi_tmp[["mtime"]])
[13:20:51.665]                     }
[13:20:51.665]                     tryCatch({
[13:20:51.665]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.665]                     }, error = function(ex) {
[13:20:51.665]                       msg <- conditionMessage(ex)
[13:20:51.665]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.665]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.665]                         fi_tmp[["mtime"]], msg)
[13:20:51.665]                       ex$message <- msg
[13:20:51.665]                       stop(ex)
[13:20:51.665]                     })
[13:20:51.665]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.665]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.665]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.665]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.665]                       fi <- file.info(pathname)
[13:20:51.665]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.665]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.665]                         fi[["size"]], fi[["mtime"]])
[13:20:51.665]                       stop(msg)
[13:20:51.665]                     }
[13:20:51.665]                     invisible(pathname)
[13:20:51.665]                   }
[13:20:51.665]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.665]                     rootPath = tempdir()) 
[13:20:51.665]                   {
[13:20:51.665]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.665]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.665]                       tmpdir = path, fileext = ".rds")
[13:20:51.665]                     save_rds(obj, file)
[13:20:51.665]                   }
[13:20:51.665]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.665]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.665]                   {
[13:20:51.665]                     inherits <- base::inherits
[13:20:51.665]                     invokeRestart <- base::invokeRestart
[13:20:51.665]                     is.null <- base::is.null
[13:20:51.665]                     muffled <- FALSE
[13:20:51.665]                     if (inherits(cond, "message")) {
[13:20:51.665]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.665]                       if (muffled) 
[13:20:51.665]                         invokeRestart("muffleMessage")
[13:20:51.665]                     }
[13:20:51.665]                     else if (inherits(cond, "warning")) {
[13:20:51.665]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.665]                       if (muffled) 
[13:20:51.665]                         invokeRestart("muffleWarning")
[13:20:51.665]                     }
[13:20:51.665]                     else if (inherits(cond, "condition")) {
[13:20:51.665]                       if (!is.null(pattern)) {
[13:20:51.665]                         computeRestarts <- base::computeRestarts
[13:20:51.665]                         grepl <- base::grepl
[13:20:51.665]                         restarts <- computeRestarts(cond)
[13:20:51.665]                         for (restart in restarts) {
[13:20:51.665]                           name <- restart$name
[13:20:51.665]                           if (is.null(name)) 
[13:20:51.665]                             next
[13:20:51.665]                           if (!grepl(pattern, name)) 
[13:20:51.665]                             next
[13:20:51.665]                           invokeRestart(restart)
[13:20:51.665]                           muffled <- TRUE
[13:20:51.665]                           break
[13:20:51.665]                         }
[13:20:51.665]                       }
[13:20:51.665]                     }
[13:20:51.665]                     invisible(muffled)
[13:20:51.665]                   }
[13:20:51.665]                   muffleCondition(cond)
[13:20:51.665]                 })
[13:20:51.665]             }))
[13:20:51.665]             future::FutureResult(value = ...future.value$value, 
[13:20:51.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.665]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.665]                     ...future.globalenv.names))
[13:20:51.665]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.665]         }, condition = base::local({
[13:20:51.665]             c <- base::c
[13:20:51.665]             inherits <- base::inherits
[13:20:51.665]             invokeRestart <- base::invokeRestart
[13:20:51.665]             length <- base::length
[13:20:51.665]             list <- base::list
[13:20:51.665]             seq.int <- base::seq.int
[13:20:51.665]             signalCondition <- base::signalCondition
[13:20:51.665]             sys.calls <- base::sys.calls
[13:20:51.665]             `[[` <- base::`[[`
[13:20:51.665]             `+` <- base::`+`
[13:20:51.665]             `<<-` <- base::`<<-`
[13:20:51.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.665]                   3L)]
[13:20:51.665]             }
[13:20:51.665]             function(cond) {
[13:20:51.665]                 is_error <- inherits(cond, "error")
[13:20:51.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.665]                   NULL)
[13:20:51.665]                 if (is_error) {
[13:20:51.665]                   sessionInformation <- function() {
[13:20:51.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.665]                       search = base::search(), system = base::Sys.info())
[13:20:51.665]                   }
[13:20:51.665]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.665]                     cond$call), session = sessionInformation(), 
[13:20:51.665]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.665]                   signalCondition(cond)
[13:20:51.665]                 }
[13:20:51.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.665]                 "immediateCondition"))) {
[13:20:51.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.665]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.665]                   if (TRUE && !signal) {
[13:20:51.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.665]                     {
[13:20:51.665]                       inherits <- base::inherits
[13:20:51.665]                       invokeRestart <- base::invokeRestart
[13:20:51.665]                       is.null <- base::is.null
[13:20:51.665]                       muffled <- FALSE
[13:20:51.665]                       if (inherits(cond, "message")) {
[13:20:51.665]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.665]                         if (muffled) 
[13:20:51.665]                           invokeRestart("muffleMessage")
[13:20:51.665]                       }
[13:20:51.665]                       else if (inherits(cond, "warning")) {
[13:20:51.665]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.665]                         if (muffled) 
[13:20:51.665]                           invokeRestart("muffleWarning")
[13:20:51.665]                       }
[13:20:51.665]                       else if (inherits(cond, "condition")) {
[13:20:51.665]                         if (!is.null(pattern)) {
[13:20:51.665]                           computeRestarts <- base::computeRestarts
[13:20:51.665]                           grepl <- base::grepl
[13:20:51.665]                           restarts <- computeRestarts(cond)
[13:20:51.665]                           for (restart in restarts) {
[13:20:51.665]                             name <- restart$name
[13:20:51.665]                             if (is.null(name)) 
[13:20:51.665]                               next
[13:20:51.665]                             if (!grepl(pattern, name)) 
[13:20:51.665]                               next
[13:20:51.665]                             invokeRestart(restart)
[13:20:51.665]                             muffled <- TRUE
[13:20:51.665]                             break
[13:20:51.665]                           }
[13:20:51.665]                         }
[13:20:51.665]                       }
[13:20:51.665]                       invisible(muffled)
[13:20:51.665]                     }
[13:20:51.665]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.665]                   }
[13:20:51.665]                 }
[13:20:51.665]                 else {
[13:20:51.665]                   if (TRUE) {
[13:20:51.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.665]                     {
[13:20:51.665]                       inherits <- base::inherits
[13:20:51.665]                       invokeRestart <- base::invokeRestart
[13:20:51.665]                       is.null <- base::is.null
[13:20:51.665]                       muffled <- FALSE
[13:20:51.665]                       if (inherits(cond, "message")) {
[13:20:51.665]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.665]                         if (muffled) 
[13:20:51.665]                           invokeRestart("muffleMessage")
[13:20:51.665]                       }
[13:20:51.665]                       else if (inherits(cond, "warning")) {
[13:20:51.665]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.665]                         if (muffled) 
[13:20:51.665]                           invokeRestart("muffleWarning")
[13:20:51.665]                       }
[13:20:51.665]                       else if (inherits(cond, "condition")) {
[13:20:51.665]                         if (!is.null(pattern)) {
[13:20:51.665]                           computeRestarts <- base::computeRestarts
[13:20:51.665]                           grepl <- base::grepl
[13:20:51.665]                           restarts <- computeRestarts(cond)
[13:20:51.665]                           for (restart in restarts) {
[13:20:51.665]                             name <- restart$name
[13:20:51.665]                             if (is.null(name)) 
[13:20:51.665]                               next
[13:20:51.665]                             if (!grepl(pattern, name)) 
[13:20:51.665]                               next
[13:20:51.665]                             invokeRestart(restart)
[13:20:51.665]                             muffled <- TRUE
[13:20:51.665]                             break
[13:20:51.665]                           }
[13:20:51.665]                         }
[13:20:51.665]                       }
[13:20:51.665]                       invisible(muffled)
[13:20:51.665]                     }
[13:20:51.665]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.665]                   }
[13:20:51.665]                 }
[13:20:51.665]             }
[13:20:51.665]         }))
[13:20:51.665]     }, error = function(ex) {
[13:20:51.665]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.665]                 ...future.rng), started = ...future.startTime, 
[13:20:51.665]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.665]             version = "1.8"), class = "FutureResult")
[13:20:51.665]     }, finally = {
[13:20:51.665]         if (!identical(...future.workdir, getwd())) 
[13:20:51.665]             setwd(...future.workdir)
[13:20:51.665]         {
[13:20:51.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.665]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.665]             }
[13:20:51.665]             base::options(...future.oldOptions)
[13:20:51.665]             if (.Platform$OS.type == "windows") {
[13:20:51.665]                 old_names <- names(...future.oldEnvVars)
[13:20:51.665]                 envs <- base::Sys.getenv()
[13:20:51.665]                 names <- names(envs)
[13:20:51.665]                 common <- intersect(names, old_names)
[13:20:51.665]                 added <- setdiff(names, old_names)
[13:20:51.665]                 removed <- setdiff(old_names, names)
[13:20:51.665]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.665]                   envs[common]]
[13:20:51.665]                 NAMES <- toupper(changed)
[13:20:51.665]                 args <- list()
[13:20:51.665]                 for (kk in seq_along(NAMES)) {
[13:20:51.665]                   name <- changed[[kk]]
[13:20:51.665]                   NAME <- NAMES[[kk]]
[13:20:51.665]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.665]                     next
[13:20:51.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.665]                 }
[13:20:51.665]                 NAMES <- toupper(added)
[13:20:51.665]                 for (kk in seq_along(NAMES)) {
[13:20:51.665]                   name <- added[[kk]]
[13:20:51.665]                   NAME <- NAMES[[kk]]
[13:20:51.665]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.665]                     next
[13:20:51.665]                   args[[name]] <- ""
[13:20:51.665]                 }
[13:20:51.665]                 NAMES <- toupper(removed)
[13:20:51.665]                 for (kk in seq_along(NAMES)) {
[13:20:51.665]                   name <- removed[[kk]]
[13:20:51.665]                   NAME <- NAMES[[kk]]
[13:20:51.665]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.665]                     next
[13:20:51.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.665]                 }
[13:20:51.665]                 if (length(args) > 0) 
[13:20:51.665]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.665]             }
[13:20:51.665]             else {
[13:20:51.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.665]             }
[13:20:51.665]             {
[13:20:51.665]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.665]                   0L) {
[13:20:51.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.665]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.665]                   base::options(opts)
[13:20:51.665]                 }
[13:20:51.665]                 {
[13:20:51.665]                   {
[13:20:51.665]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.665]                     NULL
[13:20:51.665]                   }
[13:20:51.665]                   options(future.plan = NULL)
[13:20:51.665]                   if (is.na(NA_character_)) 
[13:20:51.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.665]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.665]                     envir = parent.frame()) 
[13:20:51.665]                   {
[13:20:51.665]                     default_workers <- missing(workers)
[13:20:51.665]                     if (is.function(workers)) 
[13:20:51.665]                       workers <- workers()
[13:20:51.665]                     workers <- structure(as.integer(workers), 
[13:20:51.665]                       class = class(workers))
[13:20:51.665]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.665]                       1L)
[13:20:51.665]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.665]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.665]                       if (default_workers) 
[13:20:51.665]                         supportsMulticore(warn = TRUE)
[13:20:51.665]                       return(sequential(..., envir = envir))
[13:20:51.665]                     }
[13:20:51.665]                     oopts <- options(mc.cores = workers)
[13:20:51.665]                     on.exit(options(oopts))
[13:20:51.665]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.665]                       envir = envir)
[13:20:51.665]                     if (!future$lazy) 
[13:20:51.665]                       future <- run(future)
[13:20:51.665]                     invisible(future)
[13:20:51.665]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.665]                 }
[13:20:51.665]             }
[13:20:51.665]         }
[13:20:51.665]     })
[13:20:51.665]     if (TRUE) {
[13:20:51.665]         base::sink(type = "output", split = FALSE)
[13:20:51.665]         if (TRUE) {
[13:20:51.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.665]         }
[13:20:51.665]         else {
[13:20:51.665]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.665]         }
[13:20:51.665]         base::close(...future.stdout)
[13:20:51.665]         ...future.stdout <- NULL
[13:20:51.665]     }
[13:20:51.665]     ...future.result$conditions <- ...future.conditions
[13:20:51.665]     ...future.result$finished <- base::Sys.time()
[13:20:51.665]     ...future.result
[13:20:51.665] }
[13:20:51.668] assign_globals() ...
[13:20:51.668] List of 1
[13:20:51.668]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x558ddfec5360> 
[13:20:51.668]  - attr(*, "where")=List of 1
[13:20:51.668]   ..$ a:<environment: R_EmptyEnv> 
[13:20:51.668]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:51.668]  - attr(*, "resolved")= logi TRUE
[13:20:51.668]  - attr(*, "total_size")= num 1629776
[13:20:51.668]  - attr(*, "already-done")= logi TRUE
[13:20:51.671] - copied ‘a’ to environment
[13:20:51.671] assign_globals() ... done
[13:20:51.671] requestCore(): workers = 2
[13:20:51.673] MulticoreFuture started
[13:20:51.673] - Launch lazy future ... done
[13:20:51.674] run() for ‘MulticoreFuture’ ... done
[13:20:51.675] plan(): Setting new future strategy stack:
[13:20:51.675] List of future strategies:
[13:20:51.675] 1. sequential:
[13:20:51.675]    - args: function (..., envir = parent.frame())
[13:20:51.675]    - tweaked: FALSE
[13:20:51.675]    - call: NULL
[13:20:51.676] plan(): nbrOfWorkers() = 1
[13:20:51.678] plan(): Setting new future strategy stack:
[13:20:51.678] List of future strategies:
[13:20:51.678] 1. multicore:
[13:20:51.678]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.678]    - tweaked: FALSE
[13:20:51.678]    - call: plan(strategy)
[13:20:51.689] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.690] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.691] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:51.691] 
[13:20:51.692] Searching for globals ... DONE
[13:20:51.692] - globals: [0] <none>
[13:20:51.692] getGlobalsAndPackages() ... DONE
[13:20:51.692] run() for ‘Future’ ...
[13:20:51.692] - state: ‘created’
[13:20:51.693] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.700] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.700] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.701]   - Field: ‘label’
[13:20:51.701]   - Field: ‘local’
[13:20:51.701]   - Field: ‘owner’
[13:20:51.701]   - Field: ‘envir’
[13:20:51.701]   - Field: ‘workers’
[13:20:51.701]   - Field: ‘packages’
[13:20:51.702]   - Field: ‘gc’
[13:20:51.702]   - Field: ‘job’
[13:20:51.702]   - Field: ‘conditions’
[13:20:51.702]   - Field: ‘expr’
[13:20:51.702]   - Field: ‘uuid’
[13:20:51.702]   - Field: ‘seed’
[13:20:51.702]   - Field: ‘version’
[13:20:51.703]   - Field: ‘result’
[13:20:51.703]   - Field: ‘asynchronous’
[13:20:51.703]   - Field: ‘calls’
[13:20:51.703]   - Field: ‘globals’
[13:20:51.703]   - Field: ‘stdout’
[13:20:51.703]   - Field: ‘earlySignal’
[13:20:51.704]   - Field: ‘lazy’
[13:20:51.704]   - Field: ‘state’
[13:20:51.704] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.704] - Launch lazy future ...
[13:20:51.705] Packages needed by the future expression (n = 0): <none>
[13:20:51.705] Packages needed by future strategies (n = 0): <none>
[13:20:51.705] {
[13:20:51.705]     {
[13:20:51.705]         {
[13:20:51.705]             ...future.startTime <- base::Sys.time()
[13:20:51.705]             {
[13:20:51.705]                 {
[13:20:51.705]                   {
[13:20:51.705]                     {
[13:20:51.705]                       base::local({
[13:20:51.705]                         has_future <- base::requireNamespace("future", 
[13:20:51.705]                           quietly = TRUE)
[13:20:51.705]                         if (has_future) {
[13:20:51.705]                           ns <- base::getNamespace("future")
[13:20:51.705]                           version <- ns[[".package"]][["version"]]
[13:20:51.705]                           if (is.null(version)) 
[13:20:51.705]                             version <- utils::packageVersion("future")
[13:20:51.705]                         }
[13:20:51.705]                         else {
[13:20:51.705]                           version <- NULL
[13:20:51.705]                         }
[13:20:51.705]                         if (!has_future || version < "1.8.0") {
[13:20:51.705]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.705]                             "", base::R.version$version.string), 
[13:20:51.705]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:51.705]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:51.705]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.705]                               "release", "version")], collapse = " "), 
[13:20:51.705]                             hostname = base::Sys.info()[["nodename"]])
[13:20:51.705]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.705]                             info)
[13:20:51.705]                           info <- base::paste(info, collapse = "; ")
[13:20:51.705]                           if (!has_future) {
[13:20:51.705]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.705]                               info)
[13:20:51.705]                           }
[13:20:51.705]                           else {
[13:20:51.705]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.705]                               info, version)
[13:20:51.705]                           }
[13:20:51.705]                           base::stop(msg)
[13:20:51.705]                         }
[13:20:51.705]                       })
[13:20:51.705]                     }
[13:20:51.705]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.705]                     base::options(mc.cores = 1L)
[13:20:51.705]                   }
[13:20:51.705]                   options(future.plan = NULL)
[13:20:51.705]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.705]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.705]                 }
[13:20:51.705]                 ...future.workdir <- getwd()
[13:20:51.705]             }
[13:20:51.705]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.705]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.705]         }
[13:20:51.705]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.705]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:51.705]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.705]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.705]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.705]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.705]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.705]             base::names(...future.oldOptions))
[13:20:51.705]     }
[13:20:51.705]     if (FALSE) {
[13:20:51.705]     }
[13:20:51.705]     else {
[13:20:51.705]         if (TRUE) {
[13:20:51.705]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.705]                 open = "w")
[13:20:51.705]         }
[13:20:51.705]         else {
[13:20:51.705]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.705]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.705]         }
[13:20:51.705]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.705]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.705]             base::sink(type = "output", split = FALSE)
[13:20:51.705]             base::close(...future.stdout)
[13:20:51.705]         }, add = TRUE)
[13:20:51.705]     }
[13:20:51.705]     ...future.frame <- base::sys.nframe()
[13:20:51.705]     ...future.conditions <- base::list()
[13:20:51.705]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.705]     if (FALSE) {
[13:20:51.705]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.705]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.705]     }
[13:20:51.705]     ...future.result <- base::tryCatch({
[13:20:51.705]         base::withCallingHandlers({
[13:20:51.705]             ...future.value <- base::withVisible(base::local({
[13:20:51.705]                 withCallingHandlers({
[13:20:51.705]                   1
[13:20:51.705]                 }, immediateCondition = function(cond) {
[13:20:51.705]                   save_rds <- function (object, pathname, ...) 
[13:20:51.705]                   {
[13:20:51.705]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.705]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.705]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.705]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.705]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.705]                         fi_tmp[["mtime"]])
[13:20:51.705]                     }
[13:20:51.705]                     tryCatch({
[13:20:51.705]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.705]                     }, error = function(ex) {
[13:20:51.705]                       msg <- conditionMessage(ex)
[13:20:51.705]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.705]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.705]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.705]                         fi_tmp[["mtime"]], msg)
[13:20:51.705]                       ex$message <- msg
[13:20:51.705]                       stop(ex)
[13:20:51.705]                     })
[13:20:51.705]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.705]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.705]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.705]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.705]                       fi <- file.info(pathname)
[13:20:51.705]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.705]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.705]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.705]                         fi[["size"]], fi[["mtime"]])
[13:20:51.705]                       stop(msg)
[13:20:51.705]                     }
[13:20:51.705]                     invisible(pathname)
[13:20:51.705]                   }
[13:20:51.705]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.705]                     rootPath = tempdir()) 
[13:20:51.705]                   {
[13:20:51.705]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.705]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.705]                       tmpdir = path, fileext = ".rds")
[13:20:51.705]                     save_rds(obj, file)
[13:20:51.705]                   }
[13:20:51.705]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.705]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.705]                   {
[13:20:51.705]                     inherits <- base::inherits
[13:20:51.705]                     invokeRestart <- base::invokeRestart
[13:20:51.705]                     is.null <- base::is.null
[13:20:51.705]                     muffled <- FALSE
[13:20:51.705]                     if (inherits(cond, "message")) {
[13:20:51.705]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.705]                       if (muffled) 
[13:20:51.705]                         invokeRestart("muffleMessage")
[13:20:51.705]                     }
[13:20:51.705]                     else if (inherits(cond, "warning")) {
[13:20:51.705]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.705]                       if (muffled) 
[13:20:51.705]                         invokeRestart("muffleWarning")
[13:20:51.705]                     }
[13:20:51.705]                     else if (inherits(cond, "condition")) {
[13:20:51.705]                       if (!is.null(pattern)) {
[13:20:51.705]                         computeRestarts <- base::computeRestarts
[13:20:51.705]                         grepl <- base::grepl
[13:20:51.705]                         restarts <- computeRestarts(cond)
[13:20:51.705]                         for (restart in restarts) {
[13:20:51.705]                           name <- restart$name
[13:20:51.705]                           if (is.null(name)) 
[13:20:51.705]                             next
[13:20:51.705]                           if (!grepl(pattern, name)) 
[13:20:51.705]                             next
[13:20:51.705]                           invokeRestart(restart)
[13:20:51.705]                           muffled <- TRUE
[13:20:51.705]                           break
[13:20:51.705]                         }
[13:20:51.705]                       }
[13:20:51.705]                     }
[13:20:51.705]                     invisible(muffled)
[13:20:51.705]                   }
[13:20:51.705]                   muffleCondition(cond)
[13:20:51.705]                 })
[13:20:51.705]             }))
[13:20:51.705]             future::FutureResult(value = ...future.value$value, 
[13:20:51.705]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.705]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.705]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.705]                     ...future.globalenv.names))
[13:20:51.705]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.705]         }, condition = base::local({
[13:20:51.705]             c <- base::c
[13:20:51.705]             inherits <- base::inherits
[13:20:51.705]             invokeRestart <- base::invokeRestart
[13:20:51.705]             length <- base::length
[13:20:51.705]             list <- base::list
[13:20:51.705]             seq.int <- base::seq.int
[13:20:51.705]             signalCondition <- base::signalCondition
[13:20:51.705]             sys.calls <- base::sys.calls
[13:20:51.705]             `[[` <- base::`[[`
[13:20:51.705]             `+` <- base::`+`
[13:20:51.705]             `<<-` <- base::`<<-`
[13:20:51.705]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.705]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.705]                   3L)]
[13:20:51.705]             }
[13:20:51.705]             function(cond) {
[13:20:51.705]                 is_error <- inherits(cond, "error")
[13:20:51.705]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.705]                   NULL)
[13:20:51.705]                 if (is_error) {
[13:20:51.705]                   sessionInformation <- function() {
[13:20:51.705]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.705]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.705]                       search = base::search(), system = base::Sys.info())
[13:20:51.705]                   }
[13:20:51.705]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.705]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.705]                     cond$call), session = sessionInformation(), 
[13:20:51.705]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.705]                   signalCondition(cond)
[13:20:51.705]                 }
[13:20:51.705]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.705]                 "immediateCondition"))) {
[13:20:51.705]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.705]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.705]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.705]                   if (TRUE && !signal) {
[13:20:51.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.705]                     {
[13:20:51.705]                       inherits <- base::inherits
[13:20:51.705]                       invokeRestart <- base::invokeRestart
[13:20:51.705]                       is.null <- base::is.null
[13:20:51.705]                       muffled <- FALSE
[13:20:51.705]                       if (inherits(cond, "message")) {
[13:20:51.705]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.705]                         if (muffled) 
[13:20:51.705]                           invokeRestart("muffleMessage")
[13:20:51.705]                       }
[13:20:51.705]                       else if (inherits(cond, "warning")) {
[13:20:51.705]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.705]                         if (muffled) 
[13:20:51.705]                           invokeRestart("muffleWarning")
[13:20:51.705]                       }
[13:20:51.705]                       else if (inherits(cond, "condition")) {
[13:20:51.705]                         if (!is.null(pattern)) {
[13:20:51.705]                           computeRestarts <- base::computeRestarts
[13:20:51.705]                           grepl <- base::grepl
[13:20:51.705]                           restarts <- computeRestarts(cond)
[13:20:51.705]                           for (restart in restarts) {
[13:20:51.705]                             name <- restart$name
[13:20:51.705]                             if (is.null(name)) 
[13:20:51.705]                               next
[13:20:51.705]                             if (!grepl(pattern, name)) 
[13:20:51.705]                               next
[13:20:51.705]                             invokeRestart(restart)
[13:20:51.705]                             muffled <- TRUE
[13:20:51.705]                             break
[13:20:51.705]                           }
[13:20:51.705]                         }
[13:20:51.705]                       }
[13:20:51.705]                       invisible(muffled)
[13:20:51.705]                     }
[13:20:51.705]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.705]                   }
[13:20:51.705]                 }
[13:20:51.705]                 else {
[13:20:51.705]                   if (TRUE) {
[13:20:51.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.705]                     {
[13:20:51.705]                       inherits <- base::inherits
[13:20:51.705]                       invokeRestart <- base::invokeRestart
[13:20:51.705]                       is.null <- base::is.null
[13:20:51.705]                       muffled <- FALSE
[13:20:51.705]                       if (inherits(cond, "message")) {
[13:20:51.705]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.705]                         if (muffled) 
[13:20:51.705]                           invokeRestart("muffleMessage")
[13:20:51.705]                       }
[13:20:51.705]                       else if (inherits(cond, "warning")) {
[13:20:51.705]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.705]                         if (muffled) 
[13:20:51.705]                           invokeRestart("muffleWarning")
[13:20:51.705]                       }
[13:20:51.705]                       else if (inherits(cond, "condition")) {
[13:20:51.705]                         if (!is.null(pattern)) {
[13:20:51.705]                           computeRestarts <- base::computeRestarts
[13:20:51.705]                           grepl <- base::grepl
[13:20:51.705]                           restarts <- computeRestarts(cond)
[13:20:51.705]                           for (restart in restarts) {
[13:20:51.705]                             name <- restart$name
[13:20:51.705]                             if (is.null(name)) 
[13:20:51.705]                               next
[13:20:51.705]                             if (!grepl(pattern, name)) 
[13:20:51.705]                               next
[13:20:51.705]                             invokeRestart(restart)
[13:20:51.705]                             muffled <- TRUE
[13:20:51.705]                             break
[13:20:51.705]                           }
[13:20:51.705]                         }
[13:20:51.705]                       }
[13:20:51.705]                       invisible(muffled)
[13:20:51.705]                     }
[13:20:51.705]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.705]                   }
[13:20:51.705]                 }
[13:20:51.705]             }
[13:20:51.705]         }))
[13:20:51.705]     }, error = function(ex) {
[13:20:51.705]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.705]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.705]                 ...future.rng), started = ...future.startTime, 
[13:20:51.705]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.705]             version = "1.8"), class = "FutureResult")
[13:20:51.705]     }, finally = {
[13:20:51.705]         if (!identical(...future.workdir, getwd())) 
[13:20:51.705]             setwd(...future.workdir)
[13:20:51.705]         {
[13:20:51.705]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.705]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.705]             }
[13:20:51.705]             base::options(...future.oldOptions)
[13:20:51.705]             if (.Platform$OS.type == "windows") {
[13:20:51.705]                 old_names <- names(...future.oldEnvVars)
[13:20:51.705]                 envs <- base::Sys.getenv()
[13:20:51.705]                 names <- names(envs)
[13:20:51.705]                 common <- intersect(names, old_names)
[13:20:51.705]                 added <- setdiff(names, old_names)
[13:20:51.705]                 removed <- setdiff(old_names, names)
[13:20:51.705]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.705]                   envs[common]]
[13:20:51.705]                 NAMES <- toupper(changed)
[13:20:51.705]                 args <- list()
[13:20:51.705]                 for (kk in seq_along(NAMES)) {
[13:20:51.705]                   name <- changed[[kk]]
[13:20:51.705]                   NAME <- NAMES[[kk]]
[13:20:51.705]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.705]                     next
[13:20:51.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.705]                 }
[13:20:51.705]                 NAMES <- toupper(added)
[13:20:51.705]                 for (kk in seq_along(NAMES)) {
[13:20:51.705]                   name <- added[[kk]]
[13:20:51.705]                   NAME <- NAMES[[kk]]
[13:20:51.705]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.705]                     next
[13:20:51.705]                   args[[name]] <- ""
[13:20:51.705]                 }
[13:20:51.705]                 NAMES <- toupper(removed)
[13:20:51.705]                 for (kk in seq_along(NAMES)) {
[13:20:51.705]                   name <- removed[[kk]]
[13:20:51.705]                   NAME <- NAMES[[kk]]
[13:20:51.705]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.705]                     next
[13:20:51.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.705]                 }
[13:20:51.705]                 if (length(args) > 0) 
[13:20:51.705]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.705]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.705]             }
[13:20:51.705]             else {
[13:20:51.705]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.705]             }
[13:20:51.705]             {
[13:20:51.705]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.705]                   0L) {
[13:20:51.705]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.705]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.705]                   base::options(opts)
[13:20:51.705]                 }
[13:20:51.705]                 {
[13:20:51.705]                   {
[13:20:51.705]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.705]                     NULL
[13:20:51.705]                   }
[13:20:51.705]                   options(future.plan = NULL)
[13:20:51.705]                   if (is.na(NA_character_)) 
[13:20:51.705]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.705]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.705]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.705]                     envir = parent.frame()) 
[13:20:51.705]                   {
[13:20:51.705]                     default_workers <- missing(workers)
[13:20:51.705]                     if (is.function(workers)) 
[13:20:51.705]                       workers <- workers()
[13:20:51.705]                     workers <- structure(as.integer(workers), 
[13:20:51.705]                       class = class(workers))
[13:20:51.705]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.705]                       1L)
[13:20:51.705]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.705]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.705]                       if (default_workers) 
[13:20:51.705]                         supportsMulticore(warn = TRUE)
[13:20:51.705]                       return(sequential(..., envir = envir))
[13:20:51.705]                     }
[13:20:51.705]                     oopts <- options(mc.cores = workers)
[13:20:51.705]                     on.exit(options(oopts))
[13:20:51.705]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.705]                       envir = envir)
[13:20:51.705]                     if (!future$lazy) 
[13:20:51.705]                       future <- run(future)
[13:20:51.705]                     invisible(future)
[13:20:51.705]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.705]                 }
[13:20:51.705]             }
[13:20:51.705]         }
[13:20:51.705]     })
[13:20:51.705]     if (TRUE) {
[13:20:51.705]         base::sink(type = "output", split = FALSE)
[13:20:51.705]         if (TRUE) {
[13:20:51.705]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.705]         }
[13:20:51.705]         else {
[13:20:51.705]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.705]         }
[13:20:51.705]         base::close(...future.stdout)
[13:20:51.705]         ...future.stdout <- NULL
[13:20:51.705]     }
[13:20:51.705]     ...future.result$conditions <- ...future.conditions
[13:20:51.705]     ...future.result$finished <- base::Sys.time()
[13:20:51.705]     ...future.result
[13:20:51.705] }
[13:20:51.708] requestCore(): workers = 2
[13:20:51.710] MulticoreFuture started
[13:20:51.711] - Launch lazy future ... done
[13:20:51.711] plan(): Setting new future strategy stack:
[13:20:51.711] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.712] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.712] List of future strategies:
[13:20:51.712] 1. sequential:
[13:20:51.712]    - args: function (..., envir = parent.frame())
[13:20:51.712]    - tweaked: FALSE
[13:20:51.712]    - call: NULL
[13:20:51.712] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:51.712] plan(): nbrOfWorkers() = 1
[13:20:51.714] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:51.714] plan(): Setting new future strategy stack:
[13:20:51.714] Searching for globals ... DONE
[13:20:51.715] Resolving globals: TRUE
[13:20:51.715] Resolving any globals that are futures ...
[13:20:51.715] List of future strategies:
[13:20:51.715] 1. multicore:
[13:20:51.715]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.715]    - tweaked: FALSE
[13:20:51.715]    - call: plan(strategy)
[13:20:51.715] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:51.715] Resolving any globals that are futures ... DONE
[13:20:51.716] Resolving futures part of globals (recursively) ...
[13:20:51.716] resolve() on list ...
[13:20:51.717]  recursive: 99
[13:20:51.717]  length: 1
[13:20:51.717]  elements: ‘a’
[13:20:51.719] plan(): nbrOfWorkers() = 2
[13:20:51.720] Future #1
[13:20:51.721] A MulticoreFuture was resolved
[13:20:51.721]  length: 0 (resolved future 1)
[13:20:51.722] resolve() on list ... DONE
[13:20:51.722] - globals: [1] ‘a’
[13:20:51.722] Resolving futures part of globals (recursively) ... DONE
[13:20:51.725] The total size of the 1 globals is 1.55 MiB (1629776 bytes)
[13:20:51.726] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[13:20:51.726] - globals: [1] ‘a’
[13:20:51.726] - packages: [1] ‘future’
[13:20:51.726] getGlobalsAndPackages() ... DONE
[13:20:51.726] run() for ‘Future’ ...
[13:20:51.727] - state: ‘created’
[13:20:51.727] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.731] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.731] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.731]   - Field: ‘label’
[13:20:51.731]   - Field: ‘local’
[13:20:51.731]   - Field: ‘owner’
[13:20:51.731]   - Field: ‘envir’
[13:20:51.731]   - Field: ‘workers’
[13:20:51.732]   - Field: ‘packages’
[13:20:51.732]   - Field: ‘gc’
[13:20:51.732]   - Field: ‘job’
[13:20:51.732]   - Field: ‘conditions’
[13:20:51.732]   - Field: ‘expr’
[13:20:51.732]   - Field: ‘uuid’
[13:20:51.732]   - Field: ‘seed’
[13:20:51.732]   - Field: ‘version’
[13:20:51.733]   - Field: ‘result’
[13:20:51.733]   - Field: ‘asynchronous’
[13:20:51.733]   - Field: ‘calls’
[13:20:51.733]   - Field: ‘globals’
[13:20:51.733]   - Field: ‘stdout’
[13:20:51.733]   - Field: ‘earlySignal’
[13:20:51.733]   - Field: ‘lazy’
[13:20:51.733]   - Field: ‘state’
[13:20:51.733] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.734] - Launch lazy future ...
[13:20:51.734] Packages needed by the future expression (n = 1): ‘future’
[13:20:51.734] Packages needed by future strategies (n = 0): <none>
[13:20:51.735] {
[13:20:51.735]     {
[13:20:51.735]         {
[13:20:51.735]             ...future.startTime <- base::Sys.time()
[13:20:51.735]             {
[13:20:51.735]                 {
[13:20:51.735]                   {
[13:20:51.735]                     {
[13:20:51.735]                       {
[13:20:51.735]                         base::local({
[13:20:51.735]                           has_future <- base::requireNamespace("future", 
[13:20:51.735]                             quietly = TRUE)
[13:20:51.735]                           if (has_future) {
[13:20:51.735]                             ns <- base::getNamespace("future")
[13:20:51.735]                             version <- ns[[".package"]][["version"]]
[13:20:51.735]                             if (is.null(version)) 
[13:20:51.735]                               version <- utils::packageVersion("future")
[13:20:51.735]                           }
[13:20:51.735]                           else {
[13:20:51.735]                             version <- NULL
[13:20:51.735]                           }
[13:20:51.735]                           if (!has_future || version < "1.8.0") {
[13:20:51.735]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.735]                               "", base::R.version$version.string), 
[13:20:51.735]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:51.735]                                 base::R.version$platform, 8 * 
[13:20:51.735]                                   base::.Machine$sizeof.pointer), 
[13:20:51.735]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.735]                                 "release", "version")], collapse = " "), 
[13:20:51.735]                               hostname = base::Sys.info()[["nodename"]])
[13:20:51.735]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.735]                               info)
[13:20:51.735]                             info <- base::paste(info, collapse = "; ")
[13:20:51.735]                             if (!has_future) {
[13:20:51.735]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.735]                                 info)
[13:20:51.735]                             }
[13:20:51.735]                             else {
[13:20:51.735]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.735]                                 info, version)
[13:20:51.735]                             }
[13:20:51.735]                             base::stop(msg)
[13:20:51.735]                           }
[13:20:51.735]                         })
[13:20:51.735]                       }
[13:20:51.735]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.735]                       base::options(mc.cores = 1L)
[13:20:51.735]                     }
[13:20:51.735]                     base::local({
[13:20:51.735]                       for (pkg in "future") {
[13:20:51.735]                         base::loadNamespace(pkg)
[13:20:51.735]                         base::library(pkg, character.only = TRUE)
[13:20:51.735]                       }
[13:20:51.735]                     })
[13:20:51.735]                   }
[13:20:51.735]                   options(future.plan = NULL)
[13:20:51.735]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.735]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.735]                 }
[13:20:51.735]                 ...future.workdir <- getwd()
[13:20:51.735]             }
[13:20:51.735]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.735]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.735]         }
[13:20:51.735]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.735]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:51.735]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.735]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.735]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.735]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.735]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.735]             base::names(...future.oldOptions))
[13:20:51.735]     }
[13:20:51.735]     if (FALSE) {
[13:20:51.735]     }
[13:20:51.735]     else {
[13:20:51.735]         if (TRUE) {
[13:20:51.735]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.735]                 open = "w")
[13:20:51.735]         }
[13:20:51.735]         else {
[13:20:51.735]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.735]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.735]         }
[13:20:51.735]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.735]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.735]             base::sink(type = "output", split = FALSE)
[13:20:51.735]             base::close(...future.stdout)
[13:20:51.735]         }, add = TRUE)
[13:20:51.735]     }
[13:20:51.735]     ...future.frame <- base::sys.nframe()
[13:20:51.735]     ...future.conditions <- base::list()
[13:20:51.735]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.735]     if (FALSE) {
[13:20:51.735]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.735]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.735]     }
[13:20:51.735]     ...future.result <- base::tryCatch({
[13:20:51.735]         base::withCallingHandlers({
[13:20:51.735]             ...future.value <- base::withVisible(base::local({
[13:20:51.735]                 withCallingHandlers({
[13:20:51.735]                   value(a) + 1
[13:20:51.735]                 }, immediateCondition = function(cond) {
[13:20:51.735]                   save_rds <- function (object, pathname, ...) 
[13:20:51.735]                   {
[13:20:51.735]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.735]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.735]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.735]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.735]                         fi_tmp[["mtime"]])
[13:20:51.735]                     }
[13:20:51.735]                     tryCatch({
[13:20:51.735]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.735]                     }, error = function(ex) {
[13:20:51.735]                       msg <- conditionMessage(ex)
[13:20:51.735]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.735]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.735]                         fi_tmp[["mtime"]], msg)
[13:20:51.735]                       ex$message <- msg
[13:20:51.735]                       stop(ex)
[13:20:51.735]                     })
[13:20:51.735]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.735]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.735]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.735]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.735]                       fi <- file.info(pathname)
[13:20:51.735]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.735]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.735]                         fi[["size"]], fi[["mtime"]])
[13:20:51.735]                       stop(msg)
[13:20:51.735]                     }
[13:20:51.735]                     invisible(pathname)
[13:20:51.735]                   }
[13:20:51.735]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.735]                     rootPath = tempdir()) 
[13:20:51.735]                   {
[13:20:51.735]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.735]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.735]                       tmpdir = path, fileext = ".rds")
[13:20:51.735]                     save_rds(obj, file)
[13:20:51.735]                   }
[13:20:51.735]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.735]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.735]                   {
[13:20:51.735]                     inherits <- base::inherits
[13:20:51.735]                     invokeRestart <- base::invokeRestart
[13:20:51.735]                     is.null <- base::is.null
[13:20:51.735]                     muffled <- FALSE
[13:20:51.735]                     if (inherits(cond, "message")) {
[13:20:51.735]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.735]                       if (muffled) 
[13:20:51.735]                         invokeRestart("muffleMessage")
[13:20:51.735]                     }
[13:20:51.735]                     else if (inherits(cond, "warning")) {
[13:20:51.735]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.735]                       if (muffled) 
[13:20:51.735]                         invokeRestart("muffleWarning")
[13:20:51.735]                     }
[13:20:51.735]                     else if (inherits(cond, "condition")) {
[13:20:51.735]                       if (!is.null(pattern)) {
[13:20:51.735]                         computeRestarts <- base::computeRestarts
[13:20:51.735]                         grepl <- base::grepl
[13:20:51.735]                         restarts <- computeRestarts(cond)
[13:20:51.735]                         for (restart in restarts) {
[13:20:51.735]                           name <- restart$name
[13:20:51.735]                           if (is.null(name)) 
[13:20:51.735]                             next
[13:20:51.735]                           if (!grepl(pattern, name)) 
[13:20:51.735]                             next
[13:20:51.735]                           invokeRestart(restart)
[13:20:51.735]                           muffled <- TRUE
[13:20:51.735]                           break
[13:20:51.735]                         }
[13:20:51.735]                       }
[13:20:51.735]                     }
[13:20:51.735]                     invisible(muffled)
[13:20:51.735]                   }
[13:20:51.735]                   muffleCondition(cond)
[13:20:51.735]                 })
[13:20:51.735]             }))
[13:20:51.735]             future::FutureResult(value = ...future.value$value, 
[13:20:51.735]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.735]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.735]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.735]                     ...future.globalenv.names))
[13:20:51.735]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.735]         }, condition = base::local({
[13:20:51.735]             c <- base::c
[13:20:51.735]             inherits <- base::inherits
[13:20:51.735]             invokeRestart <- base::invokeRestart
[13:20:51.735]             length <- base::length
[13:20:51.735]             list <- base::list
[13:20:51.735]             seq.int <- base::seq.int
[13:20:51.735]             signalCondition <- base::signalCondition
[13:20:51.735]             sys.calls <- base::sys.calls
[13:20:51.735]             `[[` <- base::`[[`
[13:20:51.735]             `+` <- base::`+`
[13:20:51.735]             `<<-` <- base::`<<-`
[13:20:51.735]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.735]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.735]                   3L)]
[13:20:51.735]             }
[13:20:51.735]             function(cond) {
[13:20:51.735]                 is_error <- inherits(cond, "error")
[13:20:51.735]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.735]                   NULL)
[13:20:51.735]                 if (is_error) {
[13:20:51.735]                   sessionInformation <- function() {
[13:20:51.735]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.735]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.735]                       search = base::search(), system = base::Sys.info())
[13:20:51.735]                   }
[13:20:51.735]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.735]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.735]                     cond$call), session = sessionInformation(), 
[13:20:51.735]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.735]                   signalCondition(cond)
[13:20:51.735]                 }
[13:20:51.735]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.735]                 "immediateCondition"))) {
[13:20:51.735]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.735]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.735]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.735]                   if (TRUE && !signal) {
[13:20:51.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.735]                     {
[13:20:51.735]                       inherits <- base::inherits
[13:20:51.735]                       invokeRestart <- base::invokeRestart
[13:20:51.735]                       is.null <- base::is.null
[13:20:51.735]                       muffled <- FALSE
[13:20:51.735]                       if (inherits(cond, "message")) {
[13:20:51.735]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.735]                         if (muffled) 
[13:20:51.735]                           invokeRestart("muffleMessage")
[13:20:51.735]                       }
[13:20:51.735]                       else if (inherits(cond, "warning")) {
[13:20:51.735]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.735]                         if (muffled) 
[13:20:51.735]                           invokeRestart("muffleWarning")
[13:20:51.735]                       }
[13:20:51.735]                       else if (inherits(cond, "condition")) {
[13:20:51.735]                         if (!is.null(pattern)) {
[13:20:51.735]                           computeRestarts <- base::computeRestarts
[13:20:51.735]                           grepl <- base::grepl
[13:20:51.735]                           restarts <- computeRestarts(cond)
[13:20:51.735]                           for (restart in restarts) {
[13:20:51.735]                             name <- restart$name
[13:20:51.735]                             if (is.null(name)) 
[13:20:51.735]                               next
[13:20:51.735]                             if (!grepl(pattern, name)) 
[13:20:51.735]                               next
[13:20:51.735]                             invokeRestart(restart)
[13:20:51.735]                             muffled <- TRUE
[13:20:51.735]                             break
[13:20:51.735]                           }
[13:20:51.735]                         }
[13:20:51.735]                       }
[13:20:51.735]                       invisible(muffled)
[13:20:51.735]                     }
[13:20:51.735]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.735]                   }
[13:20:51.735]                 }
[13:20:51.735]                 else {
[13:20:51.735]                   if (TRUE) {
[13:20:51.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.735]                     {
[13:20:51.735]                       inherits <- base::inherits
[13:20:51.735]                       invokeRestart <- base::invokeRestart
[13:20:51.735]                       is.null <- base::is.null
[13:20:51.735]                       muffled <- FALSE
[13:20:51.735]                       if (inherits(cond, "message")) {
[13:20:51.735]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.735]                         if (muffled) 
[13:20:51.735]                           invokeRestart("muffleMessage")
[13:20:51.735]                       }
[13:20:51.735]                       else if (inherits(cond, "warning")) {
[13:20:51.735]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.735]                         if (muffled) 
[13:20:51.735]                           invokeRestart("muffleWarning")
[13:20:51.735]                       }
[13:20:51.735]                       else if (inherits(cond, "condition")) {
[13:20:51.735]                         if (!is.null(pattern)) {
[13:20:51.735]                           computeRestarts <- base::computeRestarts
[13:20:51.735]                           grepl <- base::grepl
[13:20:51.735]                           restarts <- computeRestarts(cond)
[13:20:51.735]                           for (restart in restarts) {
[13:20:51.735]                             name <- restart$name
[13:20:51.735]                             if (is.null(name)) 
[13:20:51.735]                               next
[13:20:51.735]                             if (!grepl(pattern, name)) 
[13:20:51.735]                               next
[13:20:51.735]                             invokeRestart(restart)
[13:20:51.735]                             muffled <- TRUE
[13:20:51.735]                             break
[13:20:51.735]                           }
[13:20:51.735]                         }
[13:20:51.735]                       }
[13:20:51.735]                       invisible(muffled)
[13:20:51.735]                     }
[13:20:51.735]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.735]                   }
[13:20:51.735]                 }
[13:20:51.735]             }
[13:20:51.735]         }))
[13:20:51.735]     }, error = function(ex) {
[13:20:51.735]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.735]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.735]                 ...future.rng), started = ...future.startTime, 
[13:20:51.735]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.735]             version = "1.8"), class = "FutureResult")
[13:20:51.735]     }, finally = {
[13:20:51.735]         if (!identical(...future.workdir, getwd())) 
[13:20:51.735]             setwd(...future.workdir)
[13:20:51.735]         {
[13:20:51.735]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.735]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.735]             }
[13:20:51.735]             base::options(...future.oldOptions)
[13:20:51.735]             if (.Platform$OS.type == "windows") {
[13:20:51.735]                 old_names <- names(...future.oldEnvVars)
[13:20:51.735]                 envs <- base::Sys.getenv()
[13:20:51.735]                 names <- names(envs)
[13:20:51.735]                 common <- intersect(names, old_names)
[13:20:51.735]                 added <- setdiff(names, old_names)
[13:20:51.735]                 removed <- setdiff(old_names, names)
[13:20:51.735]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.735]                   envs[common]]
[13:20:51.735]                 NAMES <- toupper(changed)
[13:20:51.735]                 args <- list()
[13:20:51.735]                 for (kk in seq_along(NAMES)) {
[13:20:51.735]                   name <- changed[[kk]]
[13:20:51.735]                   NAME <- NAMES[[kk]]
[13:20:51.735]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.735]                     next
[13:20:51.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.735]                 }
[13:20:51.735]                 NAMES <- toupper(added)
[13:20:51.735]                 for (kk in seq_along(NAMES)) {
[13:20:51.735]                   name <- added[[kk]]
[13:20:51.735]                   NAME <- NAMES[[kk]]
[13:20:51.735]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.735]                     next
[13:20:51.735]                   args[[name]] <- ""
[13:20:51.735]                 }
[13:20:51.735]                 NAMES <- toupper(removed)
[13:20:51.735]                 for (kk in seq_along(NAMES)) {
[13:20:51.735]                   name <- removed[[kk]]
[13:20:51.735]                   NAME <- NAMES[[kk]]
[13:20:51.735]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.735]                     next
[13:20:51.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.735]                 }
[13:20:51.735]                 if (length(args) > 0) 
[13:20:51.735]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.735]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.735]             }
[13:20:51.735]             else {
[13:20:51.735]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.735]             }
[13:20:51.735]             {
[13:20:51.735]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.735]                   0L) {
[13:20:51.735]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.735]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.735]                   base::options(opts)
[13:20:51.735]                 }
[13:20:51.735]                 {
[13:20:51.735]                   {
[13:20:51.735]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.735]                     NULL
[13:20:51.735]                   }
[13:20:51.735]                   options(future.plan = NULL)
[13:20:51.735]                   if (is.na(NA_character_)) 
[13:20:51.735]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.735]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.735]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.735]                     envir = parent.frame()) 
[13:20:51.735]                   {
[13:20:51.735]                     default_workers <- missing(workers)
[13:20:51.735]                     if (is.function(workers)) 
[13:20:51.735]                       workers <- workers()
[13:20:51.735]                     workers <- structure(as.integer(workers), 
[13:20:51.735]                       class = class(workers))
[13:20:51.735]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.735]                       1L)
[13:20:51.735]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.735]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.735]                       if (default_workers) 
[13:20:51.735]                         supportsMulticore(warn = TRUE)
[13:20:51.735]                       return(sequential(..., envir = envir))
[13:20:51.735]                     }
[13:20:51.735]                     oopts <- options(mc.cores = workers)
[13:20:51.735]                     on.exit(options(oopts))
[13:20:51.735]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.735]                       envir = envir)
[13:20:51.735]                     if (!future$lazy) 
[13:20:51.735]                       future <- run(future)
[13:20:51.735]                     invisible(future)
[13:20:51.735]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.735]                 }
[13:20:51.735]             }
[13:20:51.735]         }
[13:20:51.735]     })
[13:20:51.735]     if (TRUE) {
[13:20:51.735]         base::sink(type = "output", split = FALSE)
[13:20:51.735]         if (TRUE) {
[13:20:51.735]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.735]         }
[13:20:51.735]         else {
[13:20:51.735]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.735]         }
[13:20:51.735]         base::close(...future.stdout)
[13:20:51.735]         ...future.stdout <- NULL
[13:20:51.735]     }
[13:20:51.735]     ...future.result$conditions <- ...future.conditions
[13:20:51.735]     ...future.result$finished <- base::Sys.time()
[13:20:51.735]     ...future.result
[13:20:51.735] }
[13:20:51.738] assign_globals() ...
[13:20:51.738] List of 1
[13:20:51.738]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x558de04511e0> 
[13:20:51.738]  - attr(*, "where")=List of 1
[13:20:51.738]   ..$ a:<environment: R_EmptyEnv> 
[13:20:51.738]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:51.738]  - attr(*, "resolved")= logi TRUE
[13:20:51.738]  - attr(*, "total_size")= num 1629776
[13:20:51.738]  - attr(*, "already-done")= logi TRUE
[13:20:51.743] - copied ‘a’ to environment
[13:20:51.743] assign_globals() ... done
[13:20:51.744] requestCore(): workers = 2
[13:20:51.746] MulticoreFuture started
[13:20:51.746] - Launch lazy future ... done
[13:20:51.746] run() for ‘MulticoreFuture’ ... done
[13:20:51.747] plan(): Setting new future strategy stack:
[13:20:51.747] List of future strategies:
[13:20:51.747] 1. sequential:
[13:20:51.747]    - args: function (..., envir = parent.frame())
[13:20:51.747]    - tweaked: FALSE
[13:20:51.747]    - call: NULL
[13:20:51.749] plan(): nbrOfWorkers() = 1
[13:20:51.753] plan(): Setting new future strategy stack:
[13:20:51.753] List of future strategies:
[13:20:51.753] 1. multicore:
[13:20:51.753]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.753]    - tweaked: FALSE
[13:20:51.753]    - call: plan(strategy)
[13:20:51.759] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.761] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.762] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:51.763] 
[13:20:51.763] Searching for globals ... DONE
[13:20:51.763] - globals: [0] <none>
[13:20:51.764] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.764] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.765] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:51.766] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:51.766] Searching for globals ... DONE
[13:20:51.766] Resolving globals: TRUE
[13:20:51.766] Resolving any globals that are futures ...
[13:20:51.766] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:51.766] Resolving any globals that are futures ... DONE
[13:20:51.767] Resolving futures part of globals (recursively) ...
[13:20:51.767] resolve() on list ...
[13:20:51.767]  recursive: 99
[13:20:51.767]  length: 1
[13:20:51.768]  elements: ‘a’
[13:20:51.768] run() for ‘Future’ ...
[13:20:51.768] - state: ‘created’
[13:20:51.768] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.772] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.772] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.772]   - Field: ‘label’
[13:20:51.772]   - Field: ‘local’
[13:20:51.773]   - Field: ‘owner’
[13:20:51.773]   - Field: ‘envir’
[13:20:51.773]   - Field: ‘workers’
[13:20:51.773]   - Field: ‘packages’
[13:20:51.773]   - Field: ‘gc’
[13:20:51.773]   - Field: ‘job’
[13:20:51.773]   - Field: ‘conditions’
[13:20:51.773]   - Field: ‘expr’
[13:20:51.774]   - Field: ‘uuid’
[13:20:51.774]   - Field: ‘seed’
[13:20:51.774]   - Field: ‘version’
[13:20:51.774]   - Field: ‘result’
[13:20:51.774]   - Field: ‘asynchronous’
[13:20:51.774]   - Field: ‘calls’
[13:20:51.774]   - Field: ‘globals’
[13:20:51.774]   - Field: ‘stdout’
[13:20:51.774]   - Field: ‘earlySignal’
[13:20:51.775]   - Field: ‘lazy’
[13:20:51.775]   - Field: ‘state’
[13:20:51.775] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.775] - Launch lazy future ...
[13:20:51.775] Packages needed by the future expression (n = 0): <none>
[13:20:51.775] Packages needed by future strategies (n = 0): <none>
[13:20:51.776] {
[13:20:51.776]     {
[13:20:51.776]         {
[13:20:51.776]             ...future.startTime <- base::Sys.time()
[13:20:51.776]             {
[13:20:51.776]                 {
[13:20:51.776]                   {
[13:20:51.776]                     {
[13:20:51.776]                       base::local({
[13:20:51.776]                         has_future <- base::requireNamespace("future", 
[13:20:51.776]                           quietly = TRUE)
[13:20:51.776]                         if (has_future) {
[13:20:51.776]                           ns <- base::getNamespace("future")
[13:20:51.776]                           version <- ns[[".package"]][["version"]]
[13:20:51.776]                           if (is.null(version)) 
[13:20:51.776]                             version <- utils::packageVersion("future")
[13:20:51.776]                         }
[13:20:51.776]                         else {
[13:20:51.776]                           version <- NULL
[13:20:51.776]                         }
[13:20:51.776]                         if (!has_future || version < "1.8.0") {
[13:20:51.776]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.776]                             "", base::R.version$version.string), 
[13:20:51.776]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:51.776]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:51.776]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.776]                               "release", "version")], collapse = " "), 
[13:20:51.776]                             hostname = base::Sys.info()[["nodename"]])
[13:20:51.776]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.776]                             info)
[13:20:51.776]                           info <- base::paste(info, collapse = "; ")
[13:20:51.776]                           if (!has_future) {
[13:20:51.776]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.776]                               info)
[13:20:51.776]                           }
[13:20:51.776]                           else {
[13:20:51.776]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.776]                               info, version)
[13:20:51.776]                           }
[13:20:51.776]                           base::stop(msg)
[13:20:51.776]                         }
[13:20:51.776]                       })
[13:20:51.776]                     }
[13:20:51.776]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.776]                     base::options(mc.cores = 1L)
[13:20:51.776]                   }
[13:20:51.776]                   options(future.plan = NULL)
[13:20:51.776]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.776]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.776]                 }
[13:20:51.776]                 ...future.workdir <- getwd()
[13:20:51.776]             }
[13:20:51.776]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.776]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.776]         }
[13:20:51.776]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.776]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:51.776]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.776]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.776]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.776]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.776]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.776]             base::names(...future.oldOptions))
[13:20:51.776]     }
[13:20:51.776]     if (FALSE) {
[13:20:51.776]     }
[13:20:51.776]     else {
[13:20:51.776]         if (TRUE) {
[13:20:51.776]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.776]                 open = "w")
[13:20:51.776]         }
[13:20:51.776]         else {
[13:20:51.776]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.776]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.776]         }
[13:20:51.776]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.776]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.776]             base::sink(type = "output", split = FALSE)
[13:20:51.776]             base::close(...future.stdout)
[13:20:51.776]         }, add = TRUE)
[13:20:51.776]     }
[13:20:51.776]     ...future.frame <- base::sys.nframe()
[13:20:51.776]     ...future.conditions <- base::list()
[13:20:51.776]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.776]     if (FALSE) {
[13:20:51.776]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.776]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.776]     }
[13:20:51.776]     ...future.result <- base::tryCatch({
[13:20:51.776]         base::withCallingHandlers({
[13:20:51.776]             ...future.value <- base::withVisible(base::local({
[13:20:51.776]                 withCallingHandlers({
[13:20:51.776]                   1
[13:20:51.776]                 }, immediateCondition = function(cond) {
[13:20:51.776]                   save_rds <- function (object, pathname, ...) 
[13:20:51.776]                   {
[13:20:51.776]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.776]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.776]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.776]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.776]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.776]                         fi_tmp[["mtime"]])
[13:20:51.776]                     }
[13:20:51.776]                     tryCatch({
[13:20:51.776]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.776]                     }, error = function(ex) {
[13:20:51.776]                       msg <- conditionMessage(ex)
[13:20:51.776]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.776]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.776]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.776]                         fi_tmp[["mtime"]], msg)
[13:20:51.776]                       ex$message <- msg
[13:20:51.776]                       stop(ex)
[13:20:51.776]                     })
[13:20:51.776]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.776]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.776]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.776]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.776]                       fi <- file.info(pathname)
[13:20:51.776]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.776]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.776]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.776]                         fi[["size"]], fi[["mtime"]])
[13:20:51.776]                       stop(msg)
[13:20:51.776]                     }
[13:20:51.776]                     invisible(pathname)
[13:20:51.776]                   }
[13:20:51.776]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.776]                     rootPath = tempdir()) 
[13:20:51.776]                   {
[13:20:51.776]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.776]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.776]                       tmpdir = path, fileext = ".rds")
[13:20:51.776]                     save_rds(obj, file)
[13:20:51.776]                   }
[13:20:51.776]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.776]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.776]                   {
[13:20:51.776]                     inherits <- base::inherits
[13:20:51.776]                     invokeRestart <- base::invokeRestart
[13:20:51.776]                     is.null <- base::is.null
[13:20:51.776]                     muffled <- FALSE
[13:20:51.776]                     if (inherits(cond, "message")) {
[13:20:51.776]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.776]                       if (muffled) 
[13:20:51.776]                         invokeRestart("muffleMessage")
[13:20:51.776]                     }
[13:20:51.776]                     else if (inherits(cond, "warning")) {
[13:20:51.776]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.776]                       if (muffled) 
[13:20:51.776]                         invokeRestart("muffleWarning")
[13:20:51.776]                     }
[13:20:51.776]                     else if (inherits(cond, "condition")) {
[13:20:51.776]                       if (!is.null(pattern)) {
[13:20:51.776]                         computeRestarts <- base::computeRestarts
[13:20:51.776]                         grepl <- base::grepl
[13:20:51.776]                         restarts <- computeRestarts(cond)
[13:20:51.776]                         for (restart in restarts) {
[13:20:51.776]                           name <- restart$name
[13:20:51.776]                           if (is.null(name)) 
[13:20:51.776]                             next
[13:20:51.776]                           if (!grepl(pattern, name)) 
[13:20:51.776]                             next
[13:20:51.776]                           invokeRestart(restart)
[13:20:51.776]                           muffled <- TRUE
[13:20:51.776]                           break
[13:20:51.776]                         }
[13:20:51.776]                       }
[13:20:51.776]                     }
[13:20:51.776]                     invisible(muffled)
[13:20:51.776]                   }
[13:20:51.776]                   muffleCondition(cond)
[13:20:51.776]                 })
[13:20:51.776]             }))
[13:20:51.776]             future::FutureResult(value = ...future.value$value, 
[13:20:51.776]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.776]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.776]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.776]                     ...future.globalenv.names))
[13:20:51.776]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.776]         }, condition = base::local({
[13:20:51.776]             c <- base::c
[13:20:51.776]             inherits <- base::inherits
[13:20:51.776]             invokeRestart <- base::invokeRestart
[13:20:51.776]             length <- base::length
[13:20:51.776]             list <- base::list
[13:20:51.776]             seq.int <- base::seq.int
[13:20:51.776]             signalCondition <- base::signalCondition
[13:20:51.776]             sys.calls <- base::sys.calls
[13:20:51.776]             `[[` <- base::`[[`
[13:20:51.776]             `+` <- base::`+`
[13:20:51.776]             `<<-` <- base::`<<-`
[13:20:51.776]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.776]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.776]                   3L)]
[13:20:51.776]             }
[13:20:51.776]             function(cond) {
[13:20:51.776]                 is_error <- inherits(cond, "error")
[13:20:51.776]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.776]                   NULL)
[13:20:51.776]                 if (is_error) {
[13:20:51.776]                   sessionInformation <- function() {
[13:20:51.776]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.776]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.776]                       search = base::search(), system = base::Sys.info())
[13:20:51.776]                   }
[13:20:51.776]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.776]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.776]                     cond$call), session = sessionInformation(), 
[13:20:51.776]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.776]                   signalCondition(cond)
[13:20:51.776]                 }
[13:20:51.776]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.776]                 "immediateCondition"))) {
[13:20:51.776]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.776]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.776]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.776]                   if (TRUE && !signal) {
[13:20:51.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.776]                     {
[13:20:51.776]                       inherits <- base::inherits
[13:20:51.776]                       invokeRestart <- base::invokeRestart
[13:20:51.776]                       is.null <- base::is.null
[13:20:51.776]                       muffled <- FALSE
[13:20:51.776]                       if (inherits(cond, "message")) {
[13:20:51.776]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.776]                         if (muffled) 
[13:20:51.776]                           invokeRestart("muffleMessage")
[13:20:51.776]                       }
[13:20:51.776]                       else if (inherits(cond, "warning")) {
[13:20:51.776]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.776]                         if (muffled) 
[13:20:51.776]                           invokeRestart("muffleWarning")
[13:20:51.776]                       }
[13:20:51.776]                       else if (inherits(cond, "condition")) {
[13:20:51.776]                         if (!is.null(pattern)) {
[13:20:51.776]                           computeRestarts <- base::computeRestarts
[13:20:51.776]                           grepl <- base::grepl
[13:20:51.776]                           restarts <- computeRestarts(cond)
[13:20:51.776]                           for (restart in restarts) {
[13:20:51.776]                             name <- restart$name
[13:20:51.776]                             if (is.null(name)) 
[13:20:51.776]                               next
[13:20:51.776]                             if (!grepl(pattern, name)) 
[13:20:51.776]                               next
[13:20:51.776]                             invokeRestart(restart)
[13:20:51.776]                             muffled <- TRUE
[13:20:51.776]                             break
[13:20:51.776]                           }
[13:20:51.776]                         }
[13:20:51.776]                       }
[13:20:51.776]                       invisible(muffled)
[13:20:51.776]                     }
[13:20:51.776]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.776]                   }
[13:20:51.776]                 }
[13:20:51.776]                 else {
[13:20:51.776]                   if (TRUE) {
[13:20:51.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.776]                     {
[13:20:51.776]                       inherits <- base::inherits
[13:20:51.776]                       invokeRestart <- base::invokeRestart
[13:20:51.776]                       is.null <- base::is.null
[13:20:51.776]                       muffled <- FALSE
[13:20:51.776]                       if (inherits(cond, "message")) {
[13:20:51.776]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.776]                         if (muffled) 
[13:20:51.776]                           invokeRestart("muffleMessage")
[13:20:51.776]                       }
[13:20:51.776]                       else if (inherits(cond, "warning")) {
[13:20:51.776]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.776]                         if (muffled) 
[13:20:51.776]                           invokeRestart("muffleWarning")
[13:20:51.776]                       }
[13:20:51.776]                       else if (inherits(cond, "condition")) {
[13:20:51.776]                         if (!is.null(pattern)) {
[13:20:51.776]                           computeRestarts <- base::computeRestarts
[13:20:51.776]                           grepl <- base::grepl
[13:20:51.776]                           restarts <- computeRestarts(cond)
[13:20:51.776]                           for (restart in restarts) {
[13:20:51.776]                             name <- restart$name
[13:20:51.776]                             if (is.null(name)) 
[13:20:51.776]                               next
[13:20:51.776]                             if (!grepl(pattern, name)) 
[13:20:51.776]                               next
[13:20:51.776]                             invokeRestart(restart)
[13:20:51.776]                             muffled <- TRUE
[13:20:51.776]                             break
[13:20:51.776]                           }
[13:20:51.776]                         }
[13:20:51.776]                       }
[13:20:51.776]                       invisible(muffled)
[13:20:51.776]                     }
[13:20:51.776]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.776]                   }
[13:20:51.776]                 }
[13:20:51.776]             }
[13:20:51.776]         }))
[13:20:51.776]     }, error = function(ex) {
[13:20:51.776]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.776]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.776]                 ...future.rng), started = ...future.startTime, 
[13:20:51.776]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.776]             version = "1.8"), class = "FutureResult")
[13:20:51.776]     }, finally = {
[13:20:51.776]         if (!identical(...future.workdir, getwd())) 
[13:20:51.776]             setwd(...future.workdir)
[13:20:51.776]         {
[13:20:51.776]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.776]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.776]             }
[13:20:51.776]             base::options(...future.oldOptions)
[13:20:51.776]             if (.Platform$OS.type == "windows") {
[13:20:51.776]                 old_names <- names(...future.oldEnvVars)
[13:20:51.776]                 envs <- base::Sys.getenv()
[13:20:51.776]                 names <- names(envs)
[13:20:51.776]                 common <- intersect(names, old_names)
[13:20:51.776]                 added <- setdiff(names, old_names)
[13:20:51.776]                 removed <- setdiff(old_names, names)
[13:20:51.776]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.776]                   envs[common]]
[13:20:51.776]                 NAMES <- toupper(changed)
[13:20:51.776]                 args <- list()
[13:20:51.776]                 for (kk in seq_along(NAMES)) {
[13:20:51.776]                   name <- changed[[kk]]
[13:20:51.776]                   NAME <- NAMES[[kk]]
[13:20:51.776]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.776]                     next
[13:20:51.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.776]                 }
[13:20:51.776]                 NAMES <- toupper(added)
[13:20:51.776]                 for (kk in seq_along(NAMES)) {
[13:20:51.776]                   name <- added[[kk]]
[13:20:51.776]                   NAME <- NAMES[[kk]]
[13:20:51.776]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.776]                     next
[13:20:51.776]                   args[[name]] <- ""
[13:20:51.776]                 }
[13:20:51.776]                 NAMES <- toupper(removed)
[13:20:51.776]                 for (kk in seq_along(NAMES)) {
[13:20:51.776]                   name <- removed[[kk]]
[13:20:51.776]                   NAME <- NAMES[[kk]]
[13:20:51.776]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.776]                     next
[13:20:51.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.776]                 }
[13:20:51.776]                 if (length(args) > 0) 
[13:20:51.776]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.776]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.776]             }
[13:20:51.776]             else {
[13:20:51.776]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.776]             }
[13:20:51.776]             {
[13:20:51.776]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.776]                   0L) {
[13:20:51.776]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.776]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.776]                   base::options(opts)
[13:20:51.776]                 }
[13:20:51.776]                 {
[13:20:51.776]                   {
[13:20:51.776]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.776]                     NULL
[13:20:51.776]                   }
[13:20:51.776]                   options(future.plan = NULL)
[13:20:51.776]                   if (is.na(NA_character_)) 
[13:20:51.776]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.776]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.776]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.776]                     envir = parent.frame()) 
[13:20:51.776]                   {
[13:20:51.776]                     default_workers <- missing(workers)
[13:20:51.776]                     if (is.function(workers)) 
[13:20:51.776]                       workers <- workers()
[13:20:51.776]                     workers <- structure(as.integer(workers), 
[13:20:51.776]                       class = class(workers))
[13:20:51.776]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.776]                       1L)
[13:20:51.776]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.776]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.776]                       if (default_workers) 
[13:20:51.776]                         supportsMulticore(warn = TRUE)
[13:20:51.776]                       return(sequential(..., envir = envir))
[13:20:51.776]                     }
[13:20:51.776]                     oopts <- options(mc.cores = workers)
[13:20:51.776]                     on.exit(options(oopts))
[13:20:51.776]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.776]                       envir = envir)
[13:20:51.776]                     if (!future$lazy) 
[13:20:51.776]                       future <- run(future)
[13:20:51.776]                     invisible(future)
[13:20:51.776]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.776]                 }
[13:20:51.776]             }
[13:20:51.776]         }
[13:20:51.776]     })
[13:20:51.776]     if (TRUE) {
[13:20:51.776]         base::sink(type = "output", split = FALSE)
[13:20:51.776]         if (TRUE) {
[13:20:51.776]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.776]         }
[13:20:51.776]         else {
[13:20:51.776]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.776]         }
[13:20:51.776]         base::close(...future.stdout)
[13:20:51.776]         ...future.stdout <- NULL
[13:20:51.776]     }
[13:20:51.776]     ...future.result$conditions <- ...future.conditions
[13:20:51.776]     ...future.result$finished <- base::Sys.time()
[13:20:51.776]     ...future.result
[13:20:51.776] }
[13:20:51.779] requestCore(): workers = 2
[13:20:51.780] MulticoreFuture started
[13:20:51.781] - Launch lazy future ... done
[13:20:51.781] run() for ‘MulticoreFuture’ ... done
[13:20:51.782] plan(): Setting new future strategy stack:
[13:20:51.782] List of future strategies:
[13:20:51.782] 1. sequential:
[13:20:51.782]    - args: function (..., envir = parent.frame())
[13:20:51.782]    - tweaked: FALSE
[13:20:51.782]    - call: NULL
[13:20:51.783] plan(): nbrOfWorkers() = 1
[13:20:51.785] plan(): Setting new future strategy stack:
[13:20:51.785] List of future strategies:
[13:20:51.785] 1. multicore:
[13:20:51.785]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.785]    - tweaked: FALSE
[13:20:51.785]    - call: plan(strategy)
[13:20:51.790] plan(): nbrOfWorkers() = 2
[13:20:51.791] Future #1
[13:20:51.792] A MulticoreFuture was resolved
[13:20:51.792]  length: 0 (resolved future 1)
[13:20:51.792] resolve() on list ... DONE
[13:20:51.792] - globals: [1] ‘a’
[13:20:51.793] Resolving futures part of globals (recursively) ... DONE
[13:20:51.795] The total size of the 1 globals is 1.55 MiB (1629944 bytes)
[13:20:51.796] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[13:20:51.796] - globals: [1] ‘a’
[13:20:51.796] - packages: [1] ‘future’
[13:20:51.796] getGlobalsAndPackages() ... DONE
[13:20:51.797] run() for ‘Future’ ...
[13:20:51.797] - state: ‘created’
[13:20:51.797] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.801] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.801] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.804]   - Field: ‘label’
[13:20:51.804]   - Field: ‘local’
[13:20:51.804]   - Field: ‘owner’
[13:20:51.804]   - Field: ‘envir’
[13:20:51.805]   - Field: ‘workers’
[13:20:51.805]   - Field: ‘packages’
[13:20:51.805]   - Field: ‘gc’
[13:20:51.805]   - Field: ‘job’
[13:20:51.805]   - Field: ‘conditions’
[13:20:51.805]   - Field: ‘expr’
[13:20:51.806]   - Field: ‘uuid’
[13:20:51.806]   - Field: ‘seed’
[13:20:51.806]   - Field: ‘version’
[13:20:51.806]   - Field: ‘result’
[13:20:51.806]   - Field: ‘asynchronous’
[13:20:51.806]   - Field: ‘calls’
[13:20:51.806]   - Field: ‘globals’
[13:20:51.807]   - Field: ‘stdout’
[13:20:51.807]   - Field: ‘earlySignal’
[13:20:51.807]   - Field: ‘lazy’
[13:20:51.807]   - Field: ‘state’
[13:20:51.807] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.807] - Launch lazy future ...
[13:20:51.808] Packages needed by the future expression (n = 1): ‘future’
[13:20:51.808] Packages needed by future strategies (n = 0): <none>
[13:20:51.809] {
[13:20:51.809]     {
[13:20:51.809]         {
[13:20:51.809]             ...future.startTime <- base::Sys.time()
[13:20:51.809]             {
[13:20:51.809]                 {
[13:20:51.809]                   {
[13:20:51.809]                     {
[13:20:51.809]                       {
[13:20:51.809]                         base::local({
[13:20:51.809]                           has_future <- base::requireNamespace("future", 
[13:20:51.809]                             quietly = TRUE)
[13:20:51.809]                           if (has_future) {
[13:20:51.809]                             ns <- base::getNamespace("future")
[13:20:51.809]                             version <- ns[[".package"]][["version"]]
[13:20:51.809]                             if (is.null(version)) 
[13:20:51.809]                               version <- utils::packageVersion("future")
[13:20:51.809]                           }
[13:20:51.809]                           else {
[13:20:51.809]                             version <- NULL
[13:20:51.809]                           }
[13:20:51.809]                           if (!has_future || version < "1.8.0") {
[13:20:51.809]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.809]                               "", base::R.version$version.string), 
[13:20:51.809]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:51.809]                                 base::R.version$platform, 8 * 
[13:20:51.809]                                   base::.Machine$sizeof.pointer), 
[13:20:51.809]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.809]                                 "release", "version")], collapse = " "), 
[13:20:51.809]                               hostname = base::Sys.info()[["nodename"]])
[13:20:51.809]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.809]                               info)
[13:20:51.809]                             info <- base::paste(info, collapse = "; ")
[13:20:51.809]                             if (!has_future) {
[13:20:51.809]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.809]                                 info)
[13:20:51.809]                             }
[13:20:51.809]                             else {
[13:20:51.809]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.809]                                 info, version)
[13:20:51.809]                             }
[13:20:51.809]                             base::stop(msg)
[13:20:51.809]                           }
[13:20:51.809]                         })
[13:20:51.809]                       }
[13:20:51.809]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.809]                       base::options(mc.cores = 1L)
[13:20:51.809]                     }
[13:20:51.809]                     base::local({
[13:20:51.809]                       for (pkg in "future") {
[13:20:51.809]                         base::loadNamespace(pkg)
[13:20:51.809]                         base::library(pkg, character.only = TRUE)
[13:20:51.809]                       }
[13:20:51.809]                     })
[13:20:51.809]                   }
[13:20:51.809]                   options(future.plan = NULL)
[13:20:51.809]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.809]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.809]                 }
[13:20:51.809]                 ...future.workdir <- getwd()
[13:20:51.809]             }
[13:20:51.809]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.809]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.809]         }
[13:20:51.809]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.809]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:51.809]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.809]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.809]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.809]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.809]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.809]             base::names(...future.oldOptions))
[13:20:51.809]     }
[13:20:51.809]     if (FALSE) {
[13:20:51.809]     }
[13:20:51.809]     else {
[13:20:51.809]         if (TRUE) {
[13:20:51.809]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.809]                 open = "w")
[13:20:51.809]         }
[13:20:51.809]         else {
[13:20:51.809]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.809]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.809]         }
[13:20:51.809]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.809]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.809]             base::sink(type = "output", split = FALSE)
[13:20:51.809]             base::close(...future.stdout)
[13:20:51.809]         }, add = TRUE)
[13:20:51.809]     }
[13:20:51.809]     ...future.frame <- base::sys.nframe()
[13:20:51.809]     ...future.conditions <- base::list()
[13:20:51.809]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.809]     if (FALSE) {
[13:20:51.809]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.809]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.809]     }
[13:20:51.809]     ...future.result <- base::tryCatch({
[13:20:51.809]         base::withCallingHandlers({
[13:20:51.809]             ...future.value <- base::withVisible(base::local({
[13:20:51.809]                 withCallingHandlers({
[13:20:51.809]                   value(a) + 1
[13:20:51.809]                 }, immediateCondition = function(cond) {
[13:20:51.809]                   save_rds <- function (object, pathname, ...) 
[13:20:51.809]                   {
[13:20:51.809]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.809]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.809]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.809]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.809]                         fi_tmp[["mtime"]])
[13:20:51.809]                     }
[13:20:51.809]                     tryCatch({
[13:20:51.809]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.809]                     }, error = function(ex) {
[13:20:51.809]                       msg <- conditionMessage(ex)
[13:20:51.809]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.809]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.809]                         fi_tmp[["mtime"]], msg)
[13:20:51.809]                       ex$message <- msg
[13:20:51.809]                       stop(ex)
[13:20:51.809]                     })
[13:20:51.809]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.809]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.809]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.809]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.809]                       fi <- file.info(pathname)
[13:20:51.809]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.809]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.809]                         fi[["size"]], fi[["mtime"]])
[13:20:51.809]                       stop(msg)
[13:20:51.809]                     }
[13:20:51.809]                     invisible(pathname)
[13:20:51.809]                   }
[13:20:51.809]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.809]                     rootPath = tempdir()) 
[13:20:51.809]                   {
[13:20:51.809]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.809]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.809]                       tmpdir = path, fileext = ".rds")
[13:20:51.809]                     save_rds(obj, file)
[13:20:51.809]                   }
[13:20:51.809]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.809]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.809]                   {
[13:20:51.809]                     inherits <- base::inherits
[13:20:51.809]                     invokeRestart <- base::invokeRestart
[13:20:51.809]                     is.null <- base::is.null
[13:20:51.809]                     muffled <- FALSE
[13:20:51.809]                     if (inherits(cond, "message")) {
[13:20:51.809]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.809]                       if (muffled) 
[13:20:51.809]                         invokeRestart("muffleMessage")
[13:20:51.809]                     }
[13:20:51.809]                     else if (inherits(cond, "warning")) {
[13:20:51.809]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.809]                       if (muffled) 
[13:20:51.809]                         invokeRestart("muffleWarning")
[13:20:51.809]                     }
[13:20:51.809]                     else if (inherits(cond, "condition")) {
[13:20:51.809]                       if (!is.null(pattern)) {
[13:20:51.809]                         computeRestarts <- base::computeRestarts
[13:20:51.809]                         grepl <- base::grepl
[13:20:51.809]                         restarts <- computeRestarts(cond)
[13:20:51.809]                         for (restart in restarts) {
[13:20:51.809]                           name <- restart$name
[13:20:51.809]                           if (is.null(name)) 
[13:20:51.809]                             next
[13:20:51.809]                           if (!grepl(pattern, name)) 
[13:20:51.809]                             next
[13:20:51.809]                           invokeRestart(restart)
[13:20:51.809]                           muffled <- TRUE
[13:20:51.809]                           break
[13:20:51.809]                         }
[13:20:51.809]                       }
[13:20:51.809]                     }
[13:20:51.809]                     invisible(muffled)
[13:20:51.809]                   }
[13:20:51.809]                   muffleCondition(cond)
[13:20:51.809]                 })
[13:20:51.809]             }))
[13:20:51.809]             future::FutureResult(value = ...future.value$value, 
[13:20:51.809]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.809]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.809]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.809]                     ...future.globalenv.names))
[13:20:51.809]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.809]         }, condition = base::local({
[13:20:51.809]             c <- base::c
[13:20:51.809]             inherits <- base::inherits
[13:20:51.809]             invokeRestart <- base::invokeRestart
[13:20:51.809]             length <- base::length
[13:20:51.809]             list <- base::list
[13:20:51.809]             seq.int <- base::seq.int
[13:20:51.809]             signalCondition <- base::signalCondition
[13:20:51.809]             sys.calls <- base::sys.calls
[13:20:51.809]             `[[` <- base::`[[`
[13:20:51.809]             `+` <- base::`+`
[13:20:51.809]             `<<-` <- base::`<<-`
[13:20:51.809]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.809]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.809]                   3L)]
[13:20:51.809]             }
[13:20:51.809]             function(cond) {
[13:20:51.809]                 is_error <- inherits(cond, "error")
[13:20:51.809]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.809]                   NULL)
[13:20:51.809]                 if (is_error) {
[13:20:51.809]                   sessionInformation <- function() {
[13:20:51.809]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.809]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.809]                       search = base::search(), system = base::Sys.info())
[13:20:51.809]                   }
[13:20:51.809]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.809]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.809]                     cond$call), session = sessionInformation(), 
[13:20:51.809]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.809]                   signalCondition(cond)
[13:20:51.809]                 }
[13:20:51.809]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.809]                 "immediateCondition"))) {
[13:20:51.809]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.809]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.809]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.809]                   if (TRUE && !signal) {
[13:20:51.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.809]                     {
[13:20:51.809]                       inherits <- base::inherits
[13:20:51.809]                       invokeRestart <- base::invokeRestart
[13:20:51.809]                       is.null <- base::is.null
[13:20:51.809]                       muffled <- FALSE
[13:20:51.809]                       if (inherits(cond, "message")) {
[13:20:51.809]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.809]                         if (muffled) 
[13:20:51.809]                           invokeRestart("muffleMessage")
[13:20:51.809]                       }
[13:20:51.809]                       else if (inherits(cond, "warning")) {
[13:20:51.809]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.809]                         if (muffled) 
[13:20:51.809]                           invokeRestart("muffleWarning")
[13:20:51.809]                       }
[13:20:51.809]                       else if (inherits(cond, "condition")) {
[13:20:51.809]                         if (!is.null(pattern)) {
[13:20:51.809]                           computeRestarts <- base::computeRestarts
[13:20:51.809]                           grepl <- base::grepl
[13:20:51.809]                           restarts <- computeRestarts(cond)
[13:20:51.809]                           for (restart in restarts) {
[13:20:51.809]                             name <- restart$name
[13:20:51.809]                             if (is.null(name)) 
[13:20:51.809]                               next
[13:20:51.809]                             if (!grepl(pattern, name)) 
[13:20:51.809]                               next
[13:20:51.809]                             invokeRestart(restart)
[13:20:51.809]                             muffled <- TRUE
[13:20:51.809]                             break
[13:20:51.809]                           }
[13:20:51.809]                         }
[13:20:51.809]                       }
[13:20:51.809]                       invisible(muffled)
[13:20:51.809]                     }
[13:20:51.809]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.809]                   }
[13:20:51.809]                 }
[13:20:51.809]                 else {
[13:20:51.809]                   if (TRUE) {
[13:20:51.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.809]                     {
[13:20:51.809]                       inherits <- base::inherits
[13:20:51.809]                       invokeRestart <- base::invokeRestart
[13:20:51.809]                       is.null <- base::is.null
[13:20:51.809]                       muffled <- FALSE
[13:20:51.809]                       if (inherits(cond, "message")) {
[13:20:51.809]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.809]                         if (muffled) 
[13:20:51.809]                           invokeRestart("muffleMessage")
[13:20:51.809]                       }
[13:20:51.809]                       else if (inherits(cond, "warning")) {
[13:20:51.809]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.809]                         if (muffled) 
[13:20:51.809]                           invokeRestart("muffleWarning")
[13:20:51.809]                       }
[13:20:51.809]                       else if (inherits(cond, "condition")) {
[13:20:51.809]                         if (!is.null(pattern)) {
[13:20:51.809]                           computeRestarts <- base::computeRestarts
[13:20:51.809]                           grepl <- base::grepl
[13:20:51.809]                           restarts <- computeRestarts(cond)
[13:20:51.809]                           for (restart in restarts) {
[13:20:51.809]                             name <- restart$name
[13:20:51.809]                             if (is.null(name)) 
[13:20:51.809]                               next
[13:20:51.809]                             if (!grepl(pattern, name)) 
[13:20:51.809]                               next
[13:20:51.809]                             invokeRestart(restart)
[13:20:51.809]                             muffled <- TRUE
[13:20:51.809]                             break
[13:20:51.809]                           }
[13:20:51.809]                         }
[13:20:51.809]                       }
[13:20:51.809]                       invisible(muffled)
[13:20:51.809]                     }
[13:20:51.809]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.809]                   }
[13:20:51.809]                 }
[13:20:51.809]             }
[13:20:51.809]         }))
[13:20:51.809]     }, error = function(ex) {
[13:20:51.809]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.809]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.809]                 ...future.rng), started = ...future.startTime, 
[13:20:51.809]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.809]             version = "1.8"), class = "FutureResult")
[13:20:51.809]     }, finally = {
[13:20:51.809]         if (!identical(...future.workdir, getwd())) 
[13:20:51.809]             setwd(...future.workdir)
[13:20:51.809]         {
[13:20:51.809]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.809]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.809]             }
[13:20:51.809]             base::options(...future.oldOptions)
[13:20:51.809]             if (.Platform$OS.type == "windows") {
[13:20:51.809]                 old_names <- names(...future.oldEnvVars)
[13:20:51.809]                 envs <- base::Sys.getenv()
[13:20:51.809]                 names <- names(envs)
[13:20:51.809]                 common <- intersect(names, old_names)
[13:20:51.809]                 added <- setdiff(names, old_names)
[13:20:51.809]                 removed <- setdiff(old_names, names)
[13:20:51.809]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.809]                   envs[common]]
[13:20:51.809]                 NAMES <- toupper(changed)
[13:20:51.809]                 args <- list()
[13:20:51.809]                 for (kk in seq_along(NAMES)) {
[13:20:51.809]                   name <- changed[[kk]]
[13:20:51.809]                   NAME <- NAMES[[kk]]
[13:20:51.809]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.809]                     next
[13:20:51.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.809]                 }
[13:20:51.809]                 NAMES <- toupper(added)
[13:20:51.809]                 for (kk in seq_along(NAMES)) {
[13:20:51.809]                   name <- added[[kk]]
[13:20:51.809]                   NAME <- NAMES[[kk]]
[13:20:51.809]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.809]                     next
[13:20:51.809]                   args[[name]] <- ""
[13:20:51.809]                 }
[13:20:51.809]                 NAMES <- toupper(removed)
[13:20:51.809]                 for (kk in seq_along(NAMES)) {
[13:20:51.809]                   name <- removed[[kk]]
[13:20:51.809]                   NAME <- NAMES[[kk]]
[13:20:51.809]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.809]                     next
[13:20:51.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.809]                 }
[13:20:51.809]                 if (length(args) > 0) 
[13:20:51.809]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.809]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.809]             }
[13:20:51.809]             else {
[13:20:51.809]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.809]             }
[13:20:51.809]             {
[13:20:51.809]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.809]                   0L) {
[13:20:51.809]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.809]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.809]                   base::options(opts)
[13:20:51.809]                 }
[13:20:51.809]                 {
[13:20:51.809]                   {
[13:20:51.809]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.809]                     NULL
[13:20:51.809]                   }
[13:20:51.809]                   options(future.plan = NULL)
[13:20:51.809]                   if (is.na(NA_character_)) 
[13:20:51.809]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.809]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.809]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.809]                     envir = parent.frame()) 
[13:20:51.809]                   {
[13:20:51.809]                     default_workers <- missing(workers)
[13:20:51.809]                     if (is.function(workers)) 
[13:20:51.809]                       workers <- workers()
[13:20:51.809]                     workers <- structure(as.integer(workers), 
[13:20:51.809]                       class = class(workers))
[13:20:51.809]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.809]                       1L)
[13:20:51.809]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.809]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.809]                       if (default_workers) 
[13:20:51.809]                         supportsMulticore(warn = TRUE)
[13:20:51.809]                       return(sequential(..., envir = envir))
[13:20:51.809]                     }
[13:20:51.809]                     oopts <- options(mc.cores = workers)
[13:20:51.809]                     on.exit(options(oopts))
[13:20:51.809]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.809]                       envir = envir)
[13:20:51.809]                     if (!future$lazy) 
[13:20:51.809]                       future <- run(future)
[13:20:51.809]                     invisible(future)
[13:20:51.809]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.809]                 }
[13:20:51.809]             }
[13:20:51.809]         }
[13:20:51.809]     })
[13:20:51.809]     if (TRUE) {
[13:20:51.809]         base::sink(type = "output", split = FALSE)
[13:20:51.809]         if (TRUE) {
[13:20:51.809]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.809]         }
[13:20:51.809]         else {
[13:20:51.809]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.809]         }
[13:20:51.809]         base::close(...future.stdout)
[13:20:51.809]         ...future.stdout <- NULL
[13:20:51.809]     }
[13:20:51.809]     ...future.result$conditions <- ...future.conditions
[13:20:51.809]     ...future.result$finished <- base::Sys.time()
[13:20:51.809]     ...future.result
[13:20:51.809] }
[13:20:51.811] assign_globals() ...
[13:20:51.811] List of 1
[13:20:51.811]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x558de0673bd0> 
[13:20:51.811]  - attr(*, "where")=List of 1
[13:20:51.811]   ..$ a:<environment: R_EmptyEnv> 
[13:20:51.811]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:51.811]  - attr(*, "resolved")= logi TRUE
[13:20:51.811]  - attr(*, "total_size")= num 1629944
[13:20:51.811]  - attr(*, "already-done")= logi TRUE
[13:20:51.815] - copied ‘a’ to environment
[13:20:51.815] assign_globals() ... done
[13:20:51.815] requestCore(): workers = 2
[13:20:51.817] MulticoreFuture started
[13:20:51.817] - Launch lazy future ... done
[13:20:51.818] run() for ‘MulticoreFuture’ ... done
[13:20:51.819] plan(): Setting new future strategy stack:
[13:20:51.819] List of future strategies:
[13:20:51.819] 1. sequential:
[13:20:51.819]    - args: function (..., envir = parent.frame())
[13:20:51.819]    - tweaked: FALSE
[13:20:51.819]    - call: NULL
[13:20:51.820] plan(): nbrOfWorkers() = 1
[13:20:51.822] plan(): Setting new future strategy stack:
[13:20:51.822] List of future strategies:
[13:20:51.822] 1. multicore:
[13:20:51.822]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.822]    - tweaked: FALSE
[13:20:51.822]    - call: plan(strategy)
[13:20:51.827] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.829] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.829] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:51.830] 
[13:20:51.830] Searching for globals ... DONE
[13:20:51.830] - globals: [0] <none>
[13:20:51.830] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.831] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.831] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:51.832] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:51.832] Searching for globals ... DONE
[13:20:51.832] Resolving globals: TRUE
[13:20:51.832] Resolving any globals that are futures ...
[13:20:51.833] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:51.833] Resolving any globals that are futures ... DONE
[13:20:51.833] Resolving futures part of globals (recursively) ...
[13:20:51.834] resolve() on list ...
[13:20:51.834]  recursive: 99
[13:20:51.834]  length: 1
[13:20:51.834]  elements: ‘a’
[13:20:51.834] run() for ‘Future’ ...
[13:20:51.834] - state: ‘created’
[13:20:51.834] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.839] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.839] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.839]   - Field: ‘label’
[13:20:51.839]   - Field: ‘local’
[13:20:51.839]   - Field: ‘owner’
[13:20:51.839]   - Field: ‘envir’
[13:20:51.840]   - Field: ‘workers’
[13:20:51.840]   - Field: ‘packages’
[13:20:51.840]   - Field: ‘gc’
[13:20:51.840]   - Field: ‘job’
[13:20:51.840]   - Field: ‘conditions’
[13:20:51.840]   - Field: ‘expr’
[13:20:51.840]   - Field: ‘uuid’
[13:20:51.840]   - Field: ‘seed’
[13:20:51.840]   - Field: ‘version’
[13:20:51.841]   - Field: ‘result’
[13:20:51.841]   - Field: ‘asynchronous’
[13:20:51.841]   - Field: ‘calls’
[13:20:51.841]   - Field: ‘globals’
[13:20:51.841]   - Field: ‘stdout’
[13:20:51.841]   - Field: ‘earlySignal’
[13:20:51.841]   - Field: ‘lazy’
[13:20:51.842]   - Field: ‘state’
[13:20:51.842] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.842] - Launch lazy future ...
[13:20:51.842] Packages needed by the future expression (n = 0): <none>
[13:20:51.842] Packages needed by future strategies (n = 0): <none>
[13:20:51.843] {
[13:20:51.843]     {
[13:20:51.843]         {
[13:20:51.843]             ...future.startTime <- base::Sys.time()
[13:20:51.843]             {
[13:20:51.843]                 {
[13:20:51.843]                   {
[13:20:51.843]                     {
[13:20:51.843]                       base::local({
[13:20:51.843]                         has_future <- base::requireNamespace("future", 
[13:20:51.843]                           quietly = TRUE)
[13:20:51.843]                         if (has_future) {
[13:20:51.843]                           ns <- base::getNamespace("future")
[13:20:51.843]                           version <- ns[[".package"]][["version"]]
[13:20:51.843]                           if (is.null(version)) 
[13:20:51.843]                             version <- utils::packageVersion("future")
[13:20:51.843]                         }
[13:20:51.843]                         else {
[13:20:51.843]                           version <- NULL
[13:20:51.843]                         }
[13:20:51.843]                         if (!has_future || version < "1.8.0") {
[13:20:51.843]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.843]                             "", base::R.version$version.string), 
[13:20:51.843]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:51.843]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:51.843]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.843]                               "release", "version")], collapse = " "), 
[13:20:51.843]                             hostname = base::Sys.info()[["nodename"]])
[13:20:51.843]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.843]                             info)
[13:20:51.843]                           info <- base::paste(info, collapse = "; ")
[13:20:51.843]                           if (!has_future) {
[13:20:51.843]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.843]                               info)
[13:20:51.843]                           }
[13:20:51.843]                           else {
[13:20:51.843]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.843]                               info, version)
[13:20:51.843]                           }
[13:20:51.843]                           base::stop(msg)
[13:20:51.843]                         }
[13:20:51.843]                       })
[13:20:51.843]                     }
[13:20:51.843]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.843]                     base::options(mc.cores = 1L)
[13:20:51.843]                   }
[13:20:51.843]                   options(future.plan = NULL)
[13:20:51.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.843]                 }
[13:20:51.843]                 ...future.workdir <- getwd()
[13:20:51.843]             }
[13:20:51.843]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.843]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.843]         }
[13:20:51.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.843]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:51.843]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.843]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.843]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.843]             base::names(...future.oldOptions))
[13:20:51.843]     }
[13:20:51.843]     if (FALSE) {
[13:20:51.843]     }
[13:20:51.843]     else {
[13:20:51.843]         if (TRUE) {
[13:20:51.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.843]                 open = "w")
[13:20:51.843]         }
[13:20:51.843]         else {
[13:20:51.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.843]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.843]         }
[13:20:51.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.843]             base::sink(type = "output", split = FALSE)
[13:20:51.843]             base::close(...future.stdout)
[13:20:51.843]         }, add = TRUE)
[13:20:51.843]     }
[13:20:51.843]     ...future.frame <- base::sys.nframe()
[13:20:51.843]     ...future.conditions <- base::list()
[13:20:51.843]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.843]     if (FALSE) {
[13:20:51.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.843]     }
[13:20:51.843]     ...future.result <- base::tryCatch({
[13:20:51.843]         base::withCallingHandlers({
[13:20:51.843]             ...future.value <- base::withVisible(base::local({
[13:20:51.843]                 withCallingHandlers({
[13:20:51.843]                   1
[13:20:51.843]                 }, immediateCondition = function(cond) {
[13:20:51.843]                   save_rds <- function (object, pathname, ...) 
[13:20:51.843]                   {
[13:20:51.843]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.843]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.843]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.843]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.843]                         fi_tmp[["mtime"]])
[13:20:51.843]                     }
[13:20:51.843]                     tryCatch({
[13:20:51.843]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.843]                     }, error = function(ex) {
[13:20:51.843]                       msg <- conditionMessage(ex)
[13:20:51.843]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.843]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.843]                         fi_tmp[["mtime"]], msg)
[13:20:51.843]                       ex$message <- msg
[13:20:51.843]                       stop(ex)
[13:20:51.843]                     })
[13:20:51.843]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.843]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.843]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.843]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.843]                       fi <- file.info(pathname)
[13:20:51.843]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.843]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.843]                         fi[["size"]], fi[["mtime"]])
[13:20:51.843]                       stop(msg)
[13:20:51.843]                     }
[13:20:51.843]                     invisible(pathname)
[13:20:51.843]                   }
[13:20:51.843]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.843]                     rootPath = tempdir()) 
[13:20:51.843]                   {
[13:20:51.843]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.843]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.843]                       tmpdir = path, fileext = ".rds")
[13:20:51.843]                     save_rds(obj, file)
[13:20:51.843]                   }
[13:20:51.843]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.843]                   {
[13:20:51.843]                     inherits <- base::inherits
[13:20:51.843]                     invokeRestart <- base::invokeRestart
[13:20:51.843]                     is.null <- base::is.null
[13:20:51.843]                     muffled <- FALSE
[13:20:51.843]                     if (inherits(cond, "message")) {
[13:20:51.843]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.843]                       if (muffled) 
[13:20:51.843]                         invokeRestart("muffleMessage")
[13:20:51.843]                     }
[13:20:51.843]                     else if (inherits(cond, "warning")) {
[13:20:51.843]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.843]                       if (muffled) 
[13:20:51.843]                         invokeRestart("muffleWarning")
[13:20:51.843]                     }
[13:20:51.843]                     else if (inherits(cond, "condition")) {
[13:20:51.843]                       if (!is.null(pattern)) {
[13:20:51.843]                         computeRestarts <- base::computeRestarts
[13:20:51.843]                         grepl <- base::grepl
[13:20:51.843]                         restarts <- computeRestarts(cond)
[13:20:51.843]                         for (restart in restarts) {
[13:20:51.843]                           name <- restart$name
[13:20:51.843]                           if (is.null(name)) 
[13:20:51.843]                             next
[13:20:51.843]                           if (!grepl(pattern, name)) 
[13:20:51.843]                             next
[13:20:51.843]                           invokeRestart(restart)
[13:20:51.843]                           muffled <- TRUE
[13:20:51.843]                           break
[13:20:51.843]                         }
[13:20:51.843]                       }
[13:20:51.843]                     }
[13:20:51.843]                     invisible(muffled)
[13:20:51.843]                   }
[13:20:51.843]                   muffleCondition(cond)
[13:20:51.843]                 })
[13:20:51.843]             }))
[13:20:51.843]             future::FutureResult(value = ...future.value$value, 
[13:20:51.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.843]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.843]                     ...future.globalenv.names))
[13:20:51.843]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.843]         }, condition = base::local({
[13:20:51.843]             c <- base::c
[13:20:51.843]             inherits <- base::inherits
[13:20:51.843]             invokeRestart <- base::invokeRestart
[13:20:51.843]             length <- base::length
[13:20:51.843]             list <- base::list
[13:20:51.843]             seq.int <- base::seq.int
[13:20:51.843]             signalCondition <- base::signalCondition
[13:20:51.843]             sys.calls <- base::sys.calls
[13:20:51.843]             `[[` <- base::`[[`
[13:20:51.843]             `+` <- base::`+`
[13:20:51.843]             `<<-` <- base::`<<-`
[13:20:51.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.843]                   3L)]
[13:20:51.843]             }
[13:20:51.843]             function(cond) {
[13:20:51.843]                 is_error <- inherits(cond, "error")
[13:20:51.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.843]                   NULL)
[13:20:51.843]                 if (is_error) {
[13:20:51.843]                   sessionInformation <- function() {
[13:20:51.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.843]                       search = base::search(), system = base::Sys.info())
[13:20:51.843]                   }
[13:20:51.843]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.843]                     cond$call), session = sessionInformation(), 
[13:20:51.843]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.843]                   signalCondition(cond)
[13:20:51.843]                 }
[13:20:51.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.843]                 "immediateCondition"))) {
[13:20:51.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.843]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.843]                   if (TRUE && !signal) {
[13:20:51.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.843]                     {
[13:20:51.843]                       inherits <- base::inherits
[13:20:51.843]                       invokeRestart <- base::invokeRestart
[13:20:51.843]                       is.null <- base::is.null
[13:20:51.843]                       muffled <- FALSE
[13:20:51.843]                       if (inherits(cond, "message")) {
[13:20:51.843]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.843]                         if (muffled) 
[13:20:51.843]                           invokeRestart("muffleMessage")
[13:20:51.843]                       }
[13:20:51.843]                       else if (inherits(cond, "warning")) {
[13:20:51.843]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.843]                         if (muffled) 
[13:20:51.843]                           invokeRestart("muffleWarning")
[13:20:51.843]                       }
[13:20:51.843]                       else if (inherits(cond, "condition")) {
[13:20:51.843]                         if (!is.null(pattern)) {
[13:20:51.843]                           computeRestarts <- base::computeRestarts
[13:20:51.843]                           grepl <- base::grepl
[13:20:51.843]                           restarts <- computeRestarts(cond)
[13:20:51.843]                           for (restart in restarts) {
[13:20:51.843]                             name <- restart$name
[13:20:51.843]                             if (is.null(name)) 
[13:20:51.843]                               next
[13:20:51.843]                             if (!grepl(pattern, name)) 
[13:20:51.843]                               next
[13:20:51.843]                             invokeRestart(restart)
[13:20:51.843]                             muffled <- TRUE
[13:20:51.843]                             break
[13:20:51.843]                           }
[13:20:51.843]                         }
[13:20:51.843]                       }
[13:20:51.843]                       invisible(muffled)
[13:20:51.843]                     }
[13:20:51.843]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.843]                   }
[13:20:51.843]                 }
[13:20:51.843]                 else {
[13:20:51.843]                   if (TRUE) {
[13:20:51.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.843]                     {
[13:20:51.843]                       inherits <- base::inherits
[13:20:51.843]                       invokeRestart <- base::invokeRestart
[13:20:51.843]                       is.null <- base::is.null
[13:20:51.843]                       muffled <- FALSE
[13:20:51.843]                       if (inherits(cond, "message")) {
[13:20:51.843]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.843]                         if (muffled) 
[13:20:51.843]                           invokeRestart("muffleMessage")
[13:20:51.843]                       }
[13:20:51.843]                       else if (inherits(cond, "warning")) {
[13:20:51.843]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.843]                         if (muffled) 
[13:20:51.843]                           invokeRestart("muffleWarning")
[13:20:51.843]                       }
[13:20:51.843]                       else if (inherits(cond, "condition")) {
[13:20:51.843]                         if (!is.null(pattern)) {
[13:20:51.843]                           computeRestarts <- base::computeRestarts
[13:20:51.843]                           grepl <- base::grepl
[13:20:51.843]                           restarts <- computeRestarts(cond)
[13:20:51.843]                           for (restart in restarts) {
[13:20:51.843]                             name <- restart$name
[13:20:51.843]                             if (is.null(name)) 
[13:20:51.843]                               next
[13:20:51.843]                             if (!grepl(pattern, name)) 
[13:20:51.843]                               next
[13:20:51.843]                             invokeRestart(restart)
[13:20:51.843]                             muffled <- TRUE
[13:20:51.843]                             break
[13:20:51.843]                           }
[13:20:51.843]                         }
[13:20:51.843]                       }
[13:20:51.843]                       invisible(muffled)
[13:20:51.843]                     }
[13:20:51.843]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.843]                   }
[13:20:51.843]                 }
[13:20:51.843]             }
[13:20:51.843]         }))
[13:20:51.843]     }, error = function(ex) {
[13:20:51.843]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.843]                 ...future.rng), started = ...future.startTime, 
[13:20:51.843]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.843]             version = "1.8"), class = "FutureResult")
[13:20:51.843]     }, finally = {
[13:20:51.843]         if (!identical(...future.workdir, getwd())) 
[13:20:51.843]             setwd(...future.workdir)
[13:20:51.843]         {
[13:20:51.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.843]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.843]             }
[13:20:51.843]             base::options(...future.oldOptions)
[13:20:51.843]             if (.Platform$OS.type == "windows") {
[13:20:51.843]                 old_names <- names(...future.oldEnvVars)
[13:20:51.843]                 envs <- base::Sys.getenv()
[13:20:51.843]                 names <- names(envs)
[13:20:51.843]                 common <- intersect(names, old_names)
[13:20:51.843]                 added <- setdiff(names, old_names)
[13:20:51.843]                 removed <- setdiff(old_names, names)
[13:20:51.843]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.843]                   envs[common]]
[13:20:51.843]                 NAMES <- toupper(changed)
[13:20:51.843]                 args <- list()
[13:20:51.843]                 for (kk in seq_along(NAMES)) {
[13:20:51.843]                   name <- changed[[kk]]
[13:20:51.843]                   NAME <- NAMES[[kk]]
[13:20:51.843]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.843]                     next
[13:20:51.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.843]                 }
[13:20:51.843]                 NAMES <- toupper(added)
[13:20:51.843]                 for (kk in seq_along(NAMES)) {
[13:20:51.843]                   name <- added[[kk]]
[13:20:51.843]                   NAME <- NAMES[[kk]]
[13:20:51.843]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.843]                     next
[13:20:51.843]                   args[[name]] <- ""
[13:20:51.843]                 }
[13:20:51.843]                 NAMES <- toupper(removed)
[13:20:51.843]                 for (kk in seq_along(NAMES)) {
[13:20:51.843]                   name <- removed[[kk]]
[13:20:51.843]                   NAME <- NAMES[[kk]]
[13:20:51.843]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.843]                     next
[13:20:51.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.843]                 }
[13:20:51.843]                 if (length(args) > 0) 
[13:20:51.843]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.843]             }
[13:20:51.843]             else {
[13:20:51.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.843]             }
[13:20:51.843]             {
[13:20:51.843]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.843]                   0L) {
[13:20:51.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.843]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.843]                   base::options(opts)
[13:20:51.843]                 }
[13:20:51.843]                 {
[13:20:51.843]                   {
[13:20:51.843]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.843]                     NULL
[13:20:51.843]                   }
[13:20:51.843]                   options(future.plan = NULL)
[13:20:51.843]                   if (is.na(NA_character_)) 
[13:20:51.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.843]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.843]                     envir = parent.frame()) 
[13:20:51.843]                   {
[13:20:51.843]                     default_workers <- missing(workers)
[13:20:51.843]                     if (is.function(workers)) 
[13:20:51.843]                       workers <- workers()
[13:20:51.843]                     workers <- structure(as.integer(workers), 
[13:20:51.843]                       class = class(workers))
[13:20:51.843]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.843]                       1L)
[13:20:51.843]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.843]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.843]                       if (default_workers) 
[13:20:51.843]                         supportsMulticore(warn = TRUE)
[13:20:51.843]                       return(sequential(..., envir = envir))
[13:20:51.843]                     }
[13:20:51.843]                     oopts <- options(mc.cores = workers)
[13:20:51.843]                     on.exit(options(oopts))
[13:20:51.843]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.843]                       envir = envir)
[13:20:51.843]                     if (!future$lazy) 
[13:20:51.843]                       future <- run(future)
[13:20:51.843]                     invisible(future)
[13:20:51.843]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.843]                 }
[13:20:51.843]             }
[13:20:51.843]         }
[13:20:51.843]     })
[13:20:51.843]     if (TRUE) {
[13:20:51.843]         base::sink(type = "output", split = FALSE)
[13:20:51.843]         if (TRUE) {
[13:20:51.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.843]         }
[13:20:51.843]         else {
[13:20:51.843]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.843]         }
[13:20:51.843]         base::close(...future.stdout)
[13:20:51.843]         ...future.stdout <- NULL
[13:20:51.843]     }
[13:20:51.843]     ...future.result$conditions <- ...future.conditions
[13:20:51.843]     ...future.result$finished <- base::Sys.time()
[13:20:51.843]     ...future.result
[13:20:51.843] }
[13:20:51.846] requestCore(): workers = 2
[13:20:51.848] MulticoreFuture started
[13:20:51.848] - Launch lazy future ... done
[13:20:51.849] run() for ‘MulticoreFuture’ ... done
[13:20:51.849] plan(): Setting new future strategy stack:
[13:20:51.849] List of future strategies:
[13:20:51.849] 1. sequential:
[13:20:51.849]    - args: function (..., envir = parent.frame())
[13:20:51.849]    - tweaked: FALSE
[13:20:51.849]    - call: NULL
[13:20:51.850] plan(): nbrOfWorkers() = 1
[13:20:51.852] plan(): Setting new future strategy stack:
[13:20:51.853] List of future strategies:
[13:20:51.853] 1. multicore:
[13:20:51.853]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.853]    - tweaked: FALSE
[13:20:51.853]    - call: plan(strategy)
[13:20:51.864] plan(): nbrOfWorkers() = 2
[13:20:51.870] Future #1
[13:20:51.871] A MulticoreFuture was resolved
[13:20:51.871]  length: 0 (resolved future 1)
[13:20:51.871] resolve() on list ... DONE
[13:20:51.871] - globals: [1] ‘a’
[13:20:51.872] Resolving futures part of globals (recursively) ... DONE
[13:20:51.879] The total size of the 1 globals is 1.55 MiB (1629944 bytes)
[13:20:51.879] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[13:20:51.879] - globals: [1] ‘a’
[13:20:51.880] - packages: [1] ‘future’
[13:20:51.880] getGlobalsAndPackages() ... DONE
[13:20:51.880] run() for ‘Future’ ...
[13:20:51.881] - state: ‘created’
[13:20:51.881] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.886] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.886] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.886]   - Field: ‘label’
[13:20:51.886]   - Field: ‘local’
[13:20:51.886]   - Field: ‘owner’
[13:20:51.887]   - Field: ‘envir’
[13:20:51.887]   - Field: ‘workers’
[13:20:51.887]   - Field: ‘packages’
[13:20:51.887]   - Field: ‘gc’
[13:20:51.887]   - Field: ‘job’
[13:20:51.887]   - Field: ‘conditions’
[13:20:51.887]   - Field: ‘expr’
[13:20:51.887]   - Field: ‘uuid’
[13:20:51.888]   - Field: ‘seed’
[13:20:51.888]   - Field: ‘version’
[13:20:51.888]   - Field: ‘result’
[13:20:51.888]   - Field: ‘asynchronous’
[13:20:51.888]   - Field: ‘calls’
[13:20:51.888]   - Field: ‘globals’
[13:20:51.888]   - Field: ‘stdout’
[13:20:51.888]   - Field: ‘earlySignal’
[13:20:51.888]   - Field: ‘lazy’
[13:20:51.889]   - Field: ‘state’
[13:20:51.889] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.889] - Launch lazy future ...
[13:20:51.889] Packages needed by the future expression (n = 1): ‘future’
[13:20:51.889] Packages needed by future strategies (n = 0): <none>
[13:20:51.890] {
[13:20:51.890]     {
[13:20:51.890]         {
[13:20:51.890]             ...future.startTime <- base::Sys.time()
[13:20:51.890]             {
[13:20:51.890]                 {
[13:20:51.890]                   {
[13:20:51.890]                     {
[13:20:51.890]                       {
[13:20:51.890]                         base::local({
[13:20:51.890]                           has_future <- base::requireNamespace("future", 
[13:20:51.890]                             quietly = TRUE)
[13:20:51.890]                           if (has_future) {
[13:20:51.890]                             ns <- base::getNamespace("future")
[13:20:51.890]                             version <- ns[[".package"]][["version"]]
[13:20:51.890]                             if (is.null(version)) 
[13:20:51.890]                               version <- utils::packageVersion("future")
[13:20:51.890]                           }
[13:20:51.890]                           else {
[13:20:51.890]                             version <- NULL
[13:20:51.890]                           }
[13:20:51.890]                           if (!has_future || version < "1.8.0") {
[13:20:51.890]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.890]                               "", base::R.version$version.string), 
[13:20:51.890]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:51.890]                                 base::R.version$platform, 8 * 
[13:20:51.890]                                   base::.Machine$sizeof.pointer), 
[13:20:51.890]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.890]                                 "release", "version")], collapse = " "), 
[13:20:51.890]                               hostname = base::Sys.info()[["nodename"]])
[13:20:51.890]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.890]                               info)
[13:20:51.890]                             info <- base::paste(info, collapse = "; ")
[13:20:51.890]                             if (!has_future) {
[13:20:51.890]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.890]                                 info)
[13:20:51.890]                             }
[13:20:51.890]                             else {
[13:20:51.890]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.890]                                 info, version)
[13:20:51.890]                             }
[13:20:51.890]                             base::stop(msg)
[13:20:51.890]                           }
[13:20:51.890]                         })
[13:20:51.890]                       }
[13:20:51.890]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.890]                       base::options(mc.cores = 1L)
[13:20:51.890]                     }
[13:20:51.890]                     base::local({
[13:20:51.890]                       for (pkg in "future") {
[13:20:51.890]                         base::loadNamespace(pkg)
[13:20:51.890]                         base::library(pkg, character.only = TRUE)
[13:20:51.890]                       }
[13:20:51.890]                     })
[13:20:51.890]                   }
[13:20:51.890]                   options(future.plan = NULL)
[13:20:51.890]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.890]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.890]                 }
[13:20:51.890]                 ...future.workdir <- getwd()
[13:20:51.890]             }
[13:20:51.890]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.890]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.890]         }
[13:20:51.890]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.890]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:51.890]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.890]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.890]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.890]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.890]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.890]             base::names(...future.oldOptions))
[13:20:51.890]     }
[13:20:51.890]     if (FALSE) {
[13:20:51.890]     }
[13:20:51.890]     else {
[13:20:51.890]         if (TRUE) {
[13:20:51.890]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.890]                 open = "w")
[13:20:51.890]         }
[13:20:51.890]         else {
[13:20:51.890]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.890]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.890]         }
[13:20:51.890]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.890]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.890]             base::sink(type = "output", split = FALSE)
[13:20:51.890]             base::close(...future.stdout)
[13:20:51.890]         }, add = TRUE)
[13:20:51.890]     }
[13:20:51.890]     ...future.frame <- base::sys.nframe()
[13:20:51.890]     ...future.conditions <- base::list()
[13:20:51.890]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.890]     if (FALSE) {
[13:20:51.890]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.890]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.890]     }
[13:20:51.890]     ...future.result <- base::tryCatch({
[13:20:51.890]         base::withCallingHandlers({
[13:20:51.890]             ...future.value <- base::withVisible(base::local({
[13:20:51.890]                 withCallingHandlers({
[13:20:51.890]                   value(a) + 1
[13:20:51.890]                 }, immediateCondition = function(cond) {
[13:20:51.890]                   save_rds <- function (object, pathname, ...) 
[13:20:51.890]                   {
[13:20:51.890]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.890]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.890]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.890]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.890]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.890]                         fi_tmp[["mtime"]])
[13:20:51.890]                     }
[13:20:51.890]                     tryCatch({
[13:20:51.890]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.890]                     }, error = function(ex) {
[13:20:51.890]                       msg <- conditionMessage(ex)
[13:20:51.890]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.890]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.890]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.890]                         fi_tmp[["mtime"]], msg)
[13:20:51.890]                       ex$message <- msg
[13:20:51.890]                       stop(ex)
[13:20:51.890]                     })
[13:20:51.890]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.890]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.890]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.890]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.890]                       fi <- file.info(pathname)
[13:20:51.890]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.890]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.890]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.890]                         fi[["size"]], fi[["mtime"]])
[13:20:51.890]                       stop(msg)
[13:20:51.890]                     }
[13:20:51.890]                     invisible(pathname)
[13:20:51.890]                   }
[13:20:51.890]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.890]                     rootPath = tempdir()) 
[13:20:51.890]                   {
[13:20:51.890]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.890]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.890]                       tmpdir = path, fileext = ".rds")
[13:20:51.890]                     save_rds(obj, file)
[13:20:51.890]                   }
[13:20:51.890]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.890]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.890]                   {
[13:20:51.890]                     inherits <- base::inherits
[13:20:51.890]                     invokeRestart <- base::invokeRestart
[13:20:51.890]                     is.null <- base::is.null
[13:20:51.890]                     muffled <- FALSE
[13:20:51.890]                     if (inherits(cond, "message")) {
[13:20:51.890]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.890]                       if (muffled) 
[13:20:51.890]                         invokeRestart("muffleMessage")
[13:20:51.890]                     }
[13:20:51.890]                     else if (inherits(cond, "warning")) {
[13:20:51.890]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.890]                       if (muffled) 
[13:20:51.890]                         invokeRestart("muffleWarning")
[13:20:51.890]                     }
[13:20:51.890]                     else if (inherits(cond, "condition")) {
[13:20:51.890]                       if (!is.null(pattern)) {
[13:20:51.890]                         computeRestarts <- base::computeRestarts
[13:20:51.890]                         grepl <- base::grepl
[13:20:51.890]                         restarts <- computeRestarts(cond)
[13:20:51.890]                         for (restart in restarts) {
[13:20:51.890]                           name <- restart$name
[13:20:51.890]                           if (is.null(name)) 
[13:20:51.890]                             next
[13:20:51.890]                           if (!grepl(pattern, name)) 
[13:20:51.890]                             next
[13:20:51.890]                           invokeRestart(restart)
[13:20:51.890]                           muffled <- TRUE
[13:20:51.890]                           break
[13:20:51.890]                         }
[13:20:51.890]                       }
[13:20:51.890]                     }
[13:20:51.890]                     invisible(muffled)
[13:20:51.890]                   }
[13:20:51.890]                   muffleCondition(cond)
[13:20:51.890]                 })
[13:20:51.890]             }))
[13:20:51.890]             future::FutureResult(value = ...future.value$value, 
[13:20:51.890]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.890]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.890]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.890]                     ...future.globalenv.names))
[13:20:51.890]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.890]         }, condition = base::local({
[13:20:51.890]             c <- base::c
[13:20:51.890]             inherits <- base::inherits
[13:20:51.890]             invokeRestart <- base::invokeRestart
[13:20:51.890]             length <- base::length
[13:20:51.890]             list <- base::list
[13:20:51.890]             seq.int <- base::seq.int
[13:20:51.890]             signalCondition <- base::signalCondition
[13:20:51.890]             sys.calls <- base::sys.calls
[13:20:51.890]             `[[` <- base::`[[`
[13:20:51.890]             `+` <- base::`+`
[13:20:51.890]             `<<-` <- base::`<<-`
[13:20:51.890]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.890]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.890]                   3L)]
[13:20:51.890]             }
[13:20:51.890]             function(cond) {
[13:20:51.890]                 is_error <- inherits(cond, "error")
[13:20:51.890]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.890]                   NULL)
[13:20:51.890]                 if (is_error) {
[13:20:51.890]                   sessionInformation <- function() {
[13:20:51.890]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.890]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.890]                       search = base::search(), system = base::Sys.info())
[13:20:51.890]                   }
[13:20:51.890]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.890]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.890]                     cond$call), session = sessionInformation(), 
[13:20:51.890]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.890]                   signalCondition(cond)
[13:20:51.890]                 }
[13:20:51.890]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.890]                 "immediateCondition"))) {
[13:20:51.890]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.890]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.890]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.890]                   if (TRUE && !signal) {
[13:20:51.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.890]                     {
[13:20:51.890]                       inherits <- base::inherits
[13:20:51.890]                       invokeRestart <- base::invokeRestart
[13:20:51.890]                       is.null <- base::is.null
[13:20:51.890]                       muffled <- FALSE
[13:20:51.890]                       if (inherits(cond, "message")) {
[13:20:51.890]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.890]                         if (muffled) 
[13:20:51.890]                           invokeRestart("muffleMessage")
[13:20:51.890]                       }
[13:20:51.890]                       else if (inherits(cond, "warning")) {
[13:20:51.890]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.890]                         if (muffled) 
[13:20:51.890]                           invokeRestart("muffleWarning")
[13:20:51.890]                       }
[13:20:51.890]                       else if (inherits(cond, "condition")) {
[13:20:51.890]                         if (!is.null(pattern)) {
[13:20:51.890]                           computeRestarts <- base::computeRestarts
[13:20:51.890]                           grepl <- base::grepl
[13:20:51.890]                           restarts <- computeRestarts(cond)
[13:20:51.890]                           for (restart in restarts) {
[13:20:51.890]                             name <- restart$name
[13:20:51.890]                             if (is.null(name)) 
[13:20:51.890]                               next
[13:20:51.890]                             if (!grepl(pattern, name)) 
[13:20:51.890]                               next
[13:20:51.890]                             invokeRestart(restart)
[13:20:51.890]                             muffled <- TRUE
[13:20:51.890]                             break
[13:20:51.890]                           }
[13:20:51.890]                         }
[13:20:51.890]                       }
[13:20:51.890]                       invisible(muffled)
[13:20:51.890]                     }
[13:20:51.890]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.890]                   }
[13:20:51.890]                 }
[13:20:51.890]                 else {
[13:20:51.890]                   if (TRUE) {
[13:20:51.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.890]                     {
[13:20:51.890]                       inherits <- base::inherits
[13:20:51.890]                       invokeRestart <- base::invokeRestart
[13:20:51.890]                       is.null <- base::is.null
[13:20:51.890]                       muffled <- FALSE
[13:20:51.890]                       if (inherits(cond, "message")) {
[13:20:51.890]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.890]                         if (muffled) 
[13:20:51.890]                           invokeRestart("muffleMessage")
[13:20:51.890]                       }
[13:20:51.890]                       else if (inherits(cond, "warning")) {
[13:20:51.890]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.890]                         if (muffled) 
[13:20:51.890]                           invokeRestart("muffleWarning")
[13:20:51.890]                       }
[13:20:51.890]                       else if (inherits(cond, "condition")) {
[13:20:51.890]                         if (!is.null(pattern)) {
[13:20:51.890]                           computeRestarts <- base::computeRestarts
[13:20:51.890]                           grepl <- base::grepl
[13:20:51.890]                           restarts <- computeRestarts(cond)
[13:20:51.890]                           for (restart in restarts) {
[13:20:51.890]                             name <- restart$name
[13:20:51.890]                             if (is.null(name)) 
[13:20:51.890]                               next
[13:20:51.890]                             if (!grepl(pattern, name)) 
[13:20:51.890]                               next
[13:20:51.890]                             invokeRestart(restart)
[13:20:51.890]                             muffled <- TRUE
[13:20:51.890]                             break
[13:20:51.890]                           }
[13:20:51.890]                         }
[13:20:51.890]                       }
[13:20:51.890]                       invisible(muffled)
[13:20:51.890]                     }
[13:20:51.890]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.890]                   }
[13:20:51.890]                 }
[13:20:51.890]             }
[13:20:51.890]         }))
[13:20:51.890]     }, error = function(ex) {
[13:20:51.890]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.890]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.890]                 ...future.rng), started = ...future.startTime, 
[13:20:51.890]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.890]             version = "1.8"), class = "FutureResult")
[13:20:51.890]     }, finally = {
[13:20:51.890]         if (!identical(...future.workdir, getwd())) 
[13:20:51.890]             setwd(...future.workdir)
[13:20:51.890]         {
[13:20:51.890]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.890]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.890]             }
[13:20:51.890]             base::options(...future.oldOptions)
[13:20:51.890]             if (.Platform$OS.type == "windows") {
[13:20:51.890]                 old_names <- names(...future.oldEnvVars)
[13:20:51.890]                 envs <- base::Sys.getenv()
[13:20:51.890]                 names <- names(envs)
[13:20:51.890]                 common <- intersect(names, old_names)
[13:20:51.890]                 added <- setdiff(names, old_names)
[13:20:51.890]                 removed <- setdiff(old_names, names)
[13:20:51.890]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.890]                   envs[common]]
[13:20:51.890]                 NAMES <- toupper(changed)
[13:20:51.890]                 args <- list()
[13:20:51.890]                 for (kk in seq_along(NAMES)) {
[13:20:51.890]                   name <- changed[[kk]]
[13:20:51.890]                   NAME <- NAMES[[kk]]
[13:20:51.890]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.890]                     next
[13:20:51.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.890]                 }
[13:20:51.890]                 NAMES <- toupper(added)
[13:20:51.890]                 for (kk in seq_along(NAMES)) {
[13:20:51.890]                   name <- added[[kk]]
[13:20:51.890]                   NAME <- NAMES[[kk]]
[13:20:51.890]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.890]                     next
[13:20:51.890]                   args[[name]] <- ""
[13:20:51.890]                 }
[13:20:51.890]                 NAMES <- toupper(removed)
[13:20:51.890]                 for (kk in seq_along(NAMES)) {
[13:20:51.890]                   name <- removed[[kk]]
[13:20:51.890]                   NAME <- NAMES[[kk]]
[13:20:51.890]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.890]                     next
[13:20:51.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.890]                 }
[13:20:51.890]                 if (length(args) > 0) 
[13:20:51.890]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.890]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.890]             }
[13:20:51.890]             else {
[13:20:51.890]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.890]             }
[13:20:51.890]             {
[13:20:51.890]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.890]                   0L) {
[13:20:51.890]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.890]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.890]                   base::options(opts)
[13:20:51.890]                 }
[13:20:51.890]                 {
[13:20:51.890]                   {
[13:20:51.890]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.890]                     NULL
[13:20:51.890]                   }
[13:20:51.890]                   options(future.plan = NULL)
[13:20:51.890]                   if (is.na(NA_character_)) 
[13:20:51.890]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.890]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.890]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.890]                     envir = parent.frame()) 
[13:20:51.890]                   {
[13:20:51.890]                     default_workers <- missing(workers)
[13:20:51.890]                     if (is.function(workers)) 
[13:20:51.890]                       workers <- workers()
[13:20:51.890]                     workers <- structure(as.integer(workers), 
[13:20:51.890]                       class = class(workers))
[13:20:51.890]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.890]                       1L)
[13:20:51.890]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.890]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.890]                       if (default_workers) 
[13:20:51.890]                         supportsMulticore(warn = TRUE)
[13:20:51.890]                       return(sequential(..., envir = envir))
[13:20:51.890]                     }
[13:20:51.890]                     oopts <- options(mc.cores = workers)
[13:20:51.890]                     on.exit(options(oopts))
[13:20:51.890]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.890]                       envir = envir)
[13:20:51.890]                     if (!future$lazy) 
[13:20:51.890]                       future <- run(future)
[13:20:51.890]                     invisible(future)
[13:20:51.890]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.890]                 }
[13:20:51.890]             }
[13:20:51.890]         }
[13:20:51.890]     })
[13:20:51.890]     if (TRUE) {
[13:20:51.890]         base::sink(type = "output", split = FALSE)
[13:20:51.890]         if (TRUE) {
[13:20:51.890]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.890]         }
[13:20:51.890]         else {
[13:20:51.890]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.890]         }
[13:20:51.890]         base::close(...future.stdout)
[13:20:51.890]         ...future.stdout <- NULL
[13:20:51.890]     }
[13:20:51.890]     ...future.result$conditions <- ...future.conditions
[13:20:51.890]     ...future.result$finished <- base::Sys.time()
[13:20:51.890]     ...future.result
[13:20:51.890] }
[13:20:51.893] assign_globals() ...
[13:20:51.893] List of 1
[13:20:51.893]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x558dde19b060> 
[13:20:51.893]  - attr(*, "where")=List of 1
[13:20:51.893]   ..$ a:<environment: R_EmptyEnv> 
[13:20:51.893]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:51.893]  - attr(*, "resolved")= logi TRUE
[13:20:51.893]  - attr(*, "total_size")= num 1629944
[13:20:51.893]  - attr(*, "already-done")= logi TRUE
[13:20:51.896] - copied ‘a’ to environment
[13:20:51.896] assign_globals() ... done
[13:20:51.896] requestCore(): workers = 2
[13:20:51.898] MulticoreFuture started
[13:20:51.898] - Launch lazy future ... done
[13:20:51.899] run() for ‘MulticoreFuture’ ... done
[13:20:51.899] plan(): Setting new future strategy stack:
[13:20:51.900] List of future strategies:
[13:20:51.900] 1. sequential:
[13:20:51.900]    - args: function (..., envir = parent.frame())
[13:20:51.900]    - tweaked: FALSE
[13:20:51.900]    - call: NULL
[13:20:51.901] plan(): nbrOfWorkers() = 1
[13:20:51.903] plan(): Setting new future strategy stack:
[13:20:51.903] List of future strategies:
[13:20:51.903] 1. multicore:
[13:20:51.903]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.903]    - tweaked: FALSE
[13:20:51.903]    - call: plan(strategy)
[13:20:51.908] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.910] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.910] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:51.911] - globals found: [2] ‘{’, ‘pkg’
[13:20:51.912] Searching for globals ... DONE
[13:20:51.912] Resolving globals: TRUE
[13:20:51.912] Resolving any globals that are futures ...
[13:20:51.912] - globals: [2] ‘{’, ‘pkg’
[13:20:51.912] Resolving any globals that are futures ... DONE
[13:20:51.912] Resolving futures part of globals (recursively) ...
[13:20:51.913] resolve() on list ...
[13:20:51.913]  recursive: 99
[13:20:51.913]  length: 1
[13:20:51.913]  elements: ‘pkg’
[13:20:51.913]  length: 0 (resolved future 1)
[13:20:51.913] resolve() on list ... DONE
[13:20:51.914] - globals: [1] ‘pkg’
[13:20:51.914] Resolving futures part of globals (recursively) ... DONE
[13:20:51.914] The total size of the 1 globals is 112 bytes (112 bytes)
[13:20:51.914] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[13:20:51.914] - globals: [1] ‘pkg’
[13:20:51.915] 
[13:20:51.915] getGlobalsAndPackages() ... DONE
[13:20:51.915] Packages needed by the future expression (n = 0): <none>
[13:20:51.915] Packages needed by future strategies (n = 0): <none>
[13:20:51.916] {
[13:20:51.916]     {
[13:20:51.916]         {
[13:20:51.916]             ...future.startTime <- base::Sys.time()
[13:20:51.916]             {
[13:20:51.916]                 {
[13:20:51.916]                   {
[13:20:51.916]                     base::local({
[13:20:51.916]                       has_future <- base::requireNamespace("future", 
[13:20:51.916]                         quietly = TRUE)
[13:20:51.916]                       if (has_future) {
[13:20:51.916]                         ns <- base::getNamespace("future")
[13:20:51.916]                         version <- ns[[".package"]][["version"]]
[13:20:51.916]                         if (is.null(version)) 
[13:20:51.916]                           version <- utils::packageVersion("future")
[13:20:51.916]                       }
[13:20:51.916]                       else {
[13:20:51.916]                         version <- NULL
[13:20:51.916]                       }
[13:20:51.916]                       if (!has_future || version < "1.8.0") {
[13:20:51.916]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.916]                           "", base::R.version$version.string), 
[13:20:51.916]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:51.916]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:51.916]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.916]                             "release", "version")], collapse = " "), 
[13:20:51.916]                           hostname = base::Sys.info()[["nodename"]])
[13:20:51.916]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.916]                           info)
[13:20:51.916]                         info <- base::paste(info, collapse = "; ")
[13:20:51.916]                         if (!has_future) {
[13:20:51.916]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.916]                             info)
[13:20:51.916]                         }
[13:20:51.916]                         else {
[13:20:51.916]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.916]                             info, version)
[13:20:51.916]                         }
[13:20:51.916]                         base::stop(msg)
[13:20:51.916]                       }
[13:20:51.916]                     })
[13:20:51.916]                   }
[13:20:51.916]                   options(future.plan = NULL)
[13:20:51.916]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.916]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.916]                 }
[13:20:51.916]                 ...future.workdir <- getwd()
[13:20:51.916]             }
[13:20:51.916]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.916]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.916]         }
[13:20:51.916]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.916]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:51.916]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.916]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.916]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.916]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.916]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.916]             base::names(...future.oldOptions))
[13:20:51.916]     }
[13:20:51.916]     if (FALSE) {
[13:20:51.916]     }
[13:20:51.916]     else {
[13:20:51.916]         if (TRUE) {
[13:20:51.916]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.916]                 open = "w")
[13:20:51.916]         }
[13:20:51.916]         else {
[13:20:51.916]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.916]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.916]         }
[13:20:51.916]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.916]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.916]             base::sink(type = "output", split = FALSE)
[13:20:51.916]             base::close(...future.stdout)
[13:20:51.916]         }, add = TRUE)
[13:20:51.916]     }
[13:20:51.916]     ...future.frame <- base::sys.nframe()
[13:20:51.916]     ...future.conditions <- base::list()
[13:20:51.916]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.916]     if (FALSE) {
[13:20:51.916]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.916]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.916]     }
[13:20:51.916]     ...future.result <- base::tryCatch({
[13:20:51.916]         base::withCallingHandlers({
[13:20:51.916]             ...future.value <- base::withVisible(base::local({
[13:20:51.916]                 pkg
[13:20:51.916]             }))
[13:20:51.916]             future::FutureResult(value = ...future.value$value, 
[13:20:51.916]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.916]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.916]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.916]                     ...future.globalenv.names))
[13:20:51.916]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.916]         }, condition = base::local({
[13:20:51.916]             c <- base::c
[13:20:51.916]             inherits <- base::inherits
[13:20:51.916]             invokeRestart <- base::invokeRestart
[13:20:51.916]             length <- base::length
[13:20:51.916]             list <- base::list
[13:20:51.916]             seq.int <- base::seq.int
[13:20:51.916]             signalCondition <- base::signalCondition
[13:20:51.916]             sys.calls <- base::sys.calls
[13:20:51.916]             `[[` <- base::`[[`
[13:20:51.916]             `+` <- base::`+`
[13:20:51.916]             `<<-` <- base::`<<-`
[13:20:51.916]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.916]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.916]                   3L)]
[13:20:51.916]             }
[13:20:51.916]             function(cond) {
[13:20:51.916]                 is_error <- inherits(cond, "error")
[13:20:51.916]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.916]                   NULL)
[13:20:51.916]                 if (is_error) {
[13:20:51.916]                   sessionInformation <- function() {
[13:20:51.916]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.916]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.916]                       search = base::search(), system = base::Sys.info())
[13:20:51.916]                   }
[13:20:51.916]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.916]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.916]                     cond$call), session = sessionInformation(), 
[13:20:51.916]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.916]                   signalCondition(cond)
[13:20:51.916]                 }
[13:20:51.916]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.916]                 "immediateCondition"))) {
[13:20:51.916]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.916]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.916]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.916]                   if (TRUE && !signal) {
[13:20:51.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.916]                     {
[13:20:51.916]                       inherits <- base::inherits
[13:20:51.916]                       invokeRestart <- base::invokeRestart
[13:20:51.916]                       is.null <- base::is.null
[13:20:51.916]                       muffled <- FALSE
[13:20:51.916]                       if (inherits(cond, "message")) {
[13:20:51.916]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.916]                         if (muffled) 
[13:20:51.916]                           invokeRestart("muffleMessage")
[13:20:51.916]                       }
[13:20:51.916]                       else if (inherits(cond, "warning")) {
[13:20:51.916]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.916]                         if (muffled) 
[13:20:51.916]                           invokeRestart("muffleWarning")
[13:20:51.916]                       }
[13:20:51.916]                       else if (inherits(cond, "condition")) {
[13:20:51.916]                         if (!is.null(pattern)) {
[13:20:51.916]                           computeRestarts <- base::computeRestarts
[13:20:51.916]                           grepl <- base::grepl
[13:20:51.916]                           restarts <- computeRestarts(cond)
[13:20:51.916]                           for (restart in restarts) {
[13:20:51.916]                             name <- restart$name
[13:20:51.916]                             if (is.null(name)) 
[13:20:51.916]                               next
[13:20:51.916]                             if (!grepl(pattern, name)) 
[13:20:51.916]                               next
[13:20:51.916]                             invokeRestart(restart)
[13:20:51.916]                             muffled <- TRUE
[13:20:51.916]                             break
[13:20:51.916]                           }
[13:20:51.916]                         }
[13:20:51.916]                       }
[13:20:51.916]                       invisible(muffled)
[13:20:51.916]                     }
[13:20:51.916]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.916]                   }
[13:20:51.916]                 }
[13:20:51.916]                 else {
[13:20:51.916]                   if (TRUE) {
[13:20:51.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.916]                     {
[13:20:51.916]                       inherits <- base::inherits
[13:20:51.916]                       invokeRestart <- base::invokeRestart
[13:20:51.916]                       is.null <- base::is.null
[13:20:51.916]                       muffled <- FALSE
[13:20:51.916]                       if (inherits(cond, "message")) {
[13:20:51.916]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.916]                         if (muffled) 
[13:20:51.916]                           invokeRestart("muffleMessage")
[13:20:51.916]                       }
[13:20:51.916]                       else if (inherits(cond, "warning")) {
[13:20:51.916]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.916]                         if (muffled) 
[13:20:51.916]                           invokeRestart("muffleWarning")
[13:20:51.916]                       }
[13:20:51.916]                       else if (inherits(cond, "condition")) {
[13:20:51.916]                         if (!is.null(pattern)) {
[13:20:51.916]                           computeRestarts <- base::computeRestarts
[13:20:51.916]                           grepl <- base::grepl
[13:20:51.916]                           restarts <- computeRestarts(cond)
[13:20:51.916]                           for (restart in restarts) {
[13:20:51.916]                             name <- restart$name
[13:20:51.916]                             if (is.null(name)) 
[13:20:51.916]                               next
[13:20:51.916]                             if (!grepl(pattern, name)) 
[13:20:51.916]                               next
[13:20:51.916]                             invokeRestart(restart)
[13:20:51.916]                             muffled <- TRUE
[13:20:51.916]                             break
[13:20:51.916]                           }
[13:20:51.916]                         }
[13:20:51.916]                       }
[13:20:51.916]                       invisible(muffled)
[13:20:51.916]                     }
[13:20:51.916]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.916]                   }
[13:20:51.916]                 }
[13:20:51.916]             }
[13:20:51.916]         }))
[13:20:51.916]     }, error = function(ex) {
[13:20:51.916]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.916]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.916]                 ...future.rng), started = ...future.startTime, 
[13:20:51.916]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.916]             version = "1.8"), class = "FutureResult")
[13:20:51.916]     }, finally = {
[13:20:51.916]         if (!identical(...future.workdir, getwd())) 
[13:20:51.916]             setwd(...future.workdir)
[13:20:51.916]         {
[13:20:51.916]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.916]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.916]             }
[13:20:51.916]             base::options(...future.oldOptions)
[13:20:51.916]             if (.Platform$OS.type == "windows") {
[13:20:51.916]                 old_names <- names(...future.oldEnvVars)
[13:20:51.916]                 envs <- base::Sys.getenv()
[13:20:51.916]                 names <- names(envs)
[13:20:51.916]                 common <- intersect(names, old_names)
[13:20:51.916]                 added <- setdiff(names, old_names)
[13:20:51.916]                 removed <- setdiff(old_names, names)
[13:20:51.916]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.916]                   envs[common]]
[13:20:51.916]                 NAMES <- toupper(changed)
[13:20:51.916]                 args <- list()
[13:20:51.916]                 for (kk in seq_along(NAMES)) {
[13:20:51.916]                   name <- changed[[kk]]
[13:20:51.916]                   NAME <- NAMES[[kk]]
[13:20:51.916]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.916]                     next
[13:20:51.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.916]                 }
[13:20:51.916]                 NAMES <- toupper(added)
[13:20:51.916]                 for (kk in seq_along(NAMES)) {
[13:20:51.916]                   name <- added[[kk]]
[13:20:51.916]                   NAME <- NAMES[[kk]]
[13:20:51.916]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.916]                     next
[13:20:51.916]                   args[[name]] <- ""
[13:20:51.916]                 }
[13:20:51.916]                 NAMES <- toupper(removed)
[13:20:51.916]                 for (kk in seq_along(NAMES)) {
[13:20:51.916]                   name <- removed[[kk]]
[13:20:51.916]                   NAME <- NAMES[[kk]]
[13:20:51.916]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.916]                     next
[13:20:51.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.916]                 }
[13:20:51.916]                 if (length(args) > 0) 
[13:20:51.916]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.916]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.916]             }
[13:20:51.916]             else {
[13:20:51.916]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.916]             }
[13:20:51.916]             {
[13:20:51.916]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.916]                   0L) {
[13:20:51.916]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.916]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.916]                   base::options(opts)
[13:20:51.916]                 }
[13:20:51.916]                 {
[13:20:51.916]                   {
[13:20:51.916]                     NULL
[13:20:51.916]                     RNGkind("Mersenne-Twister")
[13:20:51.916]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:51.916]                       inherits = FALSE)
[13:20:51.916]                   }
[13:20:51.916]                   options(future.plan = NULL)
[13:20:51.916]                   if (is.na(NA_character_)) 
[13:20:51.916]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.916]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.916]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.916]                     envir = parent.frame()) 
[13:20:51.916]                   {
[13:20:51.916]                     default_workers <- missing(workers)
[13:20:51.916]                     if (is.function(workers)) 
[13:20:51.916]                       workers <- workers()
[13:20:51.916]                     workers <- structure(as.integer(workers), 
[13:20:51.916]                       class = class(workers))
[13:20:51.916]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.916]                       1L)
[13:20:51.916]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.916]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.916]                       if (default_workers) 
[13:20:51.916]                         supportsMulticore(warn = TRUE)
[13:20:51.916]                       return(sequential(..., envir = envir))
[13:20:51.916]                     }
[13:20:51.916]                     oopts <- options(mc.cores = workers)
[13:20:51.916]                     on.exit(options(oopts))
[13:20:51.916]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.916]                       envir = envir)
[13:20:51.916]                     if (!future$lazy) 
[13:20:51.916]                       future <- run(future)
[13:20:51.916]                     invisible(future)
[13:20:51.916]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.916]                 }
[13:20:51.916]             }
[13:20:51.916]         }
[13:20:51.916]     })
[13:20:51.916]     if (TRUE) {
[13:20:51.916]         base::sink(type = "output", split = FALSE)
[13:20:51.916]         if (TRUE) {
[13:20:51.916]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.916]         }
[13:20:51.916]         else {
[13:20:51.916]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.916]         }
[13:20:51.916]         base::close(...future.stdout)
[13:20:51.916]         ...future.stdout <- NULL
[13:20:51.916]     }
[13:20:51.916]     ...future.result$conditions <- ...future.conditions
[13:20:51.916]     ...future.result$finished <- base::Sys.time()
[13:20:51.916]     ...future.result
[13:20:51.916] }
[13:20:51.918] assign_globals() ...
[13:20:51.918] List of 1
[13:20:51.918]  $ pkg: chr "foo"
[13:20:51.918]  - attr(*, "where")=List of 1
[13:20:51.918]   ..$ pkg:<environment: R_EmptyEnv> 
[13:20:51.918]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:51.918]  - attr(*, "resolved")= logi TRUE
[13:20:51.918]  - attr(*, "total_size")= num 112
[13:20:51.924] - copied ‘pkg’ to environment
[13:20:51.924] assign_globals() ... done
[13:20:51.925] plan(): Setting new future strategy stack:
[13:20:51.925] List of future strategies:
[13:20:51.925] 1. sequential:
[13:20:51.925]    - args: function (..., envir = parent.frame())
[13:20:51.925]    - tweaked: FALSE
[13:20:51.925]    - call: NULL
[13:20:51.925] plan(): nbrOfWorkers() = 1
[13:20:51.926] plan(): Setting new future strategy stack:
[13:20:51.926] List of future strategies:
[13:20:51.926] 1. multicore:
[13:20:51.926]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.926]    - tweaked: FALSE
[13:20:51.926]    - call: plan(strategy)
[13:20:51.931] plan(): nbrOfWorkers() = 2
[13:20:51.931] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.932] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.932] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:51.934] - globals found: [3] ‘{’, ‘<-’, ‘+’
[13:20:51.934] Searching for globals ... DONE
[13:20:51.934] Resolving globals: TRUE
[13:20:51.935] Resolving any globals that are futures ...
[13:20:51.935] - globals: [3] ‘{’, ‘<-’, ‘+’
[13:20:51.935] Resolving any globals that are futures ... DONE
[13:20:51.935] 
[13:20:51.935] 
[13:20:51.935] getGlobalsAndPackages() ... DONE
[13:20:51.936] run() for ‘Future’ ...
[13:20:51.936] - state: ‘created’
[13:20:51.936] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.940] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.940] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.940]   - Field: ‘label’
[13:20:51.940]   - Field: ‘local’
[13:20:51.941]   - Field: ‘owner’
[13:20:51.941]   - Field: ‘envir’
[13:20:51.941]   - Field: ‘workers’
[13:20:51.941]   - Field: ‘packages’
[13:20:51.941]   - Field: ‘gc’
[13:20:51.941]   - Field: ‘job’
[13:20:51.941]   - Field: ‘conditions’
[13:20:51.941]   - Field: ‘expr’
[13:20:51.942]   - Field: ‘uuid’
[13:20:51.942]   - Field: ‘seed’
[13:20:51.942]   - Field: ‘version’
[13:20:51.942]   - Field: ‘result’
[13:20:51.942]   - Field: ‘asynchronous’
[13:20:51.942]   - Field: ‘calls’
[13:20:51.942]   - Field: ‘globals’
[13:20:51.942]   - Field: ‘stdout’
[13:20:51.942]   - Field: ‘earlySignal’
[13:20:51.942]   - Field: ‘lazy’
[13:20:51.943]   - Field: ‘state’
[13:20:51.943] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.943] - Launch lazy future ...
[13:20:51.943] Packages needed by the future expression (n = 0): <none>
[13:20:51.943] Packages needed by future strategies (n = 0): <none>
[13:20:51.944] {
[13:20:51.944]     {
[13:20:51.944]         {
[13:20:51.944]             ...future.startTime <- base::Sys.time()
[13:20:51.944]             {
[13:20:51.944]                 {
[13:20:51.944]                   {
[13:20:51.944]                     {
[13:20:51.944]                       base::local({
[13:20:51.944]                         has_future <- base::requireNamespace("future", 
[13:20:51.944]                           quietly = TRUE)
[13:20:51.944]                         if (has_future) {
[13:20:51.944]                           ns <- base::getNamespace("future")
[13:20:51.944]                           version <- ns[[".package"]][["version"]]
[13:20:51.944]                           if (is.null(version)) 
[13:20:51.944]                             version <- utils::packageVersion("future")
[13:20:51.944]                         }
[13:20:51.944]                         else {
[13:20:51.944]                           version <- NULL
[13:20:51.944]                         }
[13:20:51.944]                         if (!has_future || version < "1.8.0") {
[13:20:51.944]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.944]                             "", base::R.version$version.string), 
[13:20:51.944]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:51.944]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:51.944]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.944]                               "release", "version")], collapse = " "), 
[13:20:51.944]                             hostname = base::Sys.info()[["nodename"]])
[13:20:51.944]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.944]                             info)
[13:20:51.944]                           info <- base::paste(info, collapse = "; ")
[13:20:51.944]                           if (!has_future) {
[13:20:51.944]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.944]                               info)
[13:20:51.944]                           }
[13:20:51.944]                           else {
[13:20:51.944]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.944]                               info, version)
[13:20:51.944]                           }
[13:20:51.944]                           base::stop(msg)
[13:20:51.944]                         }
[13:20:51.944]                       })
[13:20:51.944]                     }
[13:20:51.944]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.944]                     base::options(mc.cores = 1L)
[13:20:51.944]                   }
[13:20:51.944]                   options(future.plan = NULL)
[13:20:51.944]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.944]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.944]                 }
[13:20:51.944]                 ...future.workdir <- getwd()
[13:20:51.944]             }
[13:20:51.944]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.944]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.944]         }
[13:20:51.944]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.944]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:51.944]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.944]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.944]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.944]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.944]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.944]             base::names(...future.oldOptions))
[13:20:51.944]     }
[13:20:51.944]     if (FALSE) {
[13:20:51.944]     }
[13:20:51.944]     else {
[13:20:51.944]         if (TRUE) {
[13:20:51.944]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.944]                 open = "w")
[13:20:51.944]         }
[13:20:51.944]         else {
[13:20:51.944]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.944]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.944]         }
[13:20:51.944]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.944]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.944]             base::sink(type = "output", split = FALSE)
[13:20:51.944]             base::close(...future.stdout)
[13:20:51.944]         }, add = TRUE)
[13:20:51.944]     }
[13:20:51.944]     ...future.frame <- base::sys.nframe()
[13:20:51.944]     ...future.conditions <- base::list()
[13:20:51.944]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.944]     if (FALSE) {
[13:20:51.944]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.944]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.944]     }
[13:20:51.944]     ...future.result <- base::tryCatch({
[13:20:51.944]         base::withCallingHandlers({
[13:20:51.944]             ...future.value <- base::withVisible(base::local({
[13:20:51.944]                 withCallingHandlers({
[13:20:51.944]                   {
[13:20:51.944]                     x <- 0
[13:20:51.944]                     x <- x + 1
[13:20:51.944]                     x
[13:20:51.944]                   }
[13:20:51.944]                 }, immediateCondition = function(cond) {
[13:20:51.944]                   save_rds <- function (object, pathname, ...) 
[13:20:51.944]                   {
[13:20:51.944]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.944]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.944]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.944]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.944]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.944]                         fi_tmp[["mtime"]])
[13:20:51.944]                     }
[13:20:51.944]                     tryCatch({
[13:20:51.944]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.944]                     }, error = function(ex) {
[13:20:51.944]                       msg <- conditionMessage(ex)
[13:20:51.944]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.944]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.944]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.944]                         fi_tmp[["mtime"]], msg)
[13:20:51.944]                       ex$message <- msg
[13:20:51.944]                       stop(ex)
[13:20:51.944]                     })
[13:20:51.944]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.944]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.944]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.944]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.944]                       fi <- file.info(pathname)
[13:20:51.944]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.944]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.944]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.944]                         fi[["size"]], fi[["mtime"]])
[13:20:51.944]                       stop(msg)
[13:20:51.944]                     }
[13:20:51.944]                     invisible(pathname)
[13:20:51.944]                   }
[13:20:51.944]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.944]                     rootPath = tempdir()) 
[13:20:51.944]                   {
[13:20:51.944]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.944]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.944]                       tmpdir = path, fileext = ".rds")
[13:20:51.944]                     save_rds(obj, file)
[13:20:51.944]                   }
[13:20:51.944]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.944]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.944]                   {
[13:20:51.944]                     inherits <- base::inherits
[13:20:51.944]                     invokeRestart <- base::invokeRestart
[13:20:51.944]                     is.null <- base::is.null
[13:20:51.944]                     muffled <- FALSE
[13:20:51.944]                     if (inherits(cond, "message")) {
[13:20:51.944]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.944]                       if (muffled) 
[13:20:51.944]                         invokeRestart("muffleMessage")
[13:20:51.944]                     }
[13:20:51.944]                     else if (inherits(cond, "warning")) {
[13:20:51.944]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.944]                       if (muffled) 
[13:20:51.944]                         invokeRestart("muffleWarning")
[13:20:51.944]                     }
[13:20:51.944]                     else if (inherits(cond, "condition")) {
[13:20:51.944]                       if (!is.null(pattern)) {
[13:20:51.944]                         computeRestarts <- base::computeRestarts
[13:20:51.944]                         grepl <- base::grepl
[13:20:51.944]                         restarts <- computeRestarts(cond)
[13:20:51.944]                         for (restart in restarts) {
[13:20:51.944]                           name <- restart$name
[13:20:51.944]                           if (is.null(name)) 
[13:20:51.944]                             next
[13:20:51.944]                           if (!grepl(pattern, name)) 
[13:20:51.944]                             next
[13:20:51.944]                           invokeRestart(restart)
[13:20:51.944]                           muffled <- TRUE
[13:20:51.944]                           break
[13:20:51.944]                         }
[13:20:51.944]                       }
[13:20:51.944]                     }
[13:20:51.944]                     invisible(muffled)
[13:20:51.944]                   }
[13:20:51.944]                   muffleCondition(cond)
[13:20:51.944]                 })
[13:20:51.944]             }))
[13:20:51.944]             future::FutureResult(value = ...future.value$value, 
[13:20:51.944]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.944]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.944]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.944]                     ...future.globalenv.names))
[13:20:51.944]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.944]         }, condition = base::local({
[13:20:51.944]             c <- base::c
[13:20:51.944]             inherits <- base::inherits
[13:20:51.944]             invokeRestart <- base::invokeRestart
[13:20:51.944]             length <- base::length
[13:20:51.944]             list <- base::list
[13:20:51.944]             seq.int <- base::seq.int
[13:20:51.944]             signalCondition <- base::signalCondition
[13:20:51.944]             sys.calls <- base::sys.calls
[13:20:51.944]             `[[` <- base::`[[`
[13:20:51.944]             `+` <- base::`+`
[13:20:51.944]             `<<-` <- base::`<<-`
[13:20:51.944]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.944]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.944]                   3L)]
[13:20:51.944]             }
[13:20:51.944]             function(cond) {
[13:20:51.944]                 is_error <- inherits(cond, "error")
[13:20:51.944]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.944]                   NULL)
[13:20:51.944]                 if (is_error) {
[13:20:51.944]                   sessionInformation <- function() {
[13:20:51.944]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.944]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.944]                       search = base::search(), system = base::Sys.info())
[13:20:51.944]                   }
[13:20:51.944]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.944]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.944]                     cond$call), session = sessionInformation(), 
[13:20:51.944]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.944]                   signalCondition(cond)
[13:20:51.944]                 }
[13:20:51.944]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.944]                 "immediateCondition"))) {
[13:20:51.944]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.944]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.944]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.944]                   if (TRUE && !signal) {
[13:20:51.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.944]                     {
[13:20:51.944]                       inherits <- base::inherits
[13:20:51.944]                       invokeRestart <- base::invokeRestart
[13:20:51.944]                       is.null <- base::is.null
[13:20:51.944]                       muffled <- FALSE
[13:20:51.944]                       if (inherits(cond, "message")) {
[13:20:51.944]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.944]                         if (muffled) 
[13:20:51.944]                           invokeRestart("muffleMessage")
[13:20:51.944]                       }
[13:20:51.944]                       else if (inherits(cond, "warning")) {
[13:20:51.944]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.944]                         if (muffled) 
[13:20:51.944]                           invokeRestart("muffleWarning")
[13:20:51.944]                       }
[13:20:51.944]                       else if (inherits(cond, "condition")) {
[13:20:51.944]                         if (!is.null(pattern)) {
[13:20:51.944]                           computeRestarts <- base::computeRestarts
[13:20:51.944]                           grepl <- base::grepl
[13:20:51.944]                           restarts <- computeRestarts(cond)
[13:20:51.944]                           for (restart in restarts) {
[13:20:51.944]                             name <- restart$name
[13:20:51.944]                             if (is.null(name)) 
[13:20:51.944]                               next
[13:20:51.944]                             if (!grepl(pattern, name)) 
[13:20:51.944]                               next
[13:20:51.944]                             invokeRestart(restart)
[13:20:51.944]                             muffled <- TRUE
[13:20:51.944]                             break
[13:20:51.944]                           }
[13:20:51.944]                         }
[13:20:51.944]                       }
[13:20:51.944]                       invisible(muffled)
[13:20:51.944]                     }
[13:20:51.944]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.944]                   }
[13:20:51.944]                 }
[13:20:51.944]                 else {
[13:20:51.944]                   if (TRUE) {
[13:20:51.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.944]                     {
[13:20:51.944]                       inherits <- base::inherits
[13:20:51.944]                       invokeRestart <- base::invokeRestart
[13:20:51.944]                       is.null <- base::is.null
[13:20:51.944]                       muffled <- FALSE
[13:20:51.944]                       if (inherits(cond, "message")) {
[13:20:51.944]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.944]                         if (muffled) 
[13:20:51.944]                           invokeRestart("muffleMessage")
[13:20:51.944]                       }
[13:20:51.944]                       else if (inherits(cond, "warning")) {
[13:20:51.944]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.944]                         if (muffled) 
[13:20:51.944]                           invokeRestart("muffleWarning")
[13:20:51.944]                       }
[13:20:51.944]                       else if (inherits(cond, "condition")) {
[13:20:51.944]                         if (!is.null(pattern)) {
[13:20:51.944]                           computeRestarts <- base::computeRestarts
[13:20:51.944]                           grepl <- base::grepl
[13:20:51.944]                           restarts <- computeRestarts(cond)
[13:20:51.944]                           for (restart in restarts) {
[13:20:51.944]                             name <- restart$name
[13:20:51.944]                             if (is.null(name)) 
[13:20:51.944]                               next
[13:20:51.944]                             if (!grepl(pattern, name)) 
[13:20:51.944]                               next
[13:20:51.944]                             invokeRestart(restart)
[13:20:51.944]                             muffled <- TRUE
[13:20:51.944]                             break
[13:20:51.944]                           }
[13:20:51.944]                         }
[13:20:51.944]                       }
[13:20:51.944]                       invisible(muffled)
[13:20:51.944]                     }
[13:20:51.944]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.944]                   }
[13:20:51.944]                 }
[13:20:51.944]             }
[13:20:51.944]         }))
[13:20:51.944]     }, error = function(ex) {
[13:20:51.944]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.944]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.944]                 ...future.rng), started = ...future.startTime, 
[13:20:51.944]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.944]             version = "1.8"), class = "FutureResult")
[13:20:51.944]     }, finally = {
[13:20:51.944]         if (!identical(...future.workdir, getwd())) 
[13:20:51.944]             setwd(...future.workdir)
[13:20:51.944]         {
[13:20:51.944]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.944]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.944]             }
[13:20:51.944]             base::options(...future.oldOptions)
[13:20:51.944]             if (.Platform$OS.type == "windows") {
[13:20:51.944]                 old_names <- names(...future.oldEnvVars)
[13:20:51.944]                 envs <- base::Sys.getenv()
[13:20:51.944]                 names <- names(envs)
[13:20:51.944]                 common <- intersect(names, old_names)
[13:20:51.944]                 added <- setdiff(names, old_names)
[13:20:51.944]                 removed <- setdiff(old_names, names)
[13:20:51.944]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.944]                   envs[common]]
[13:20:51.944]                 NAMES <- toupper(changed)
[13:20:51.944]                 args <- list()
[13:20:51.944]                 for (kk in seq_along(NAMES)) {
[13:20:51.944]                   name <- changed[[kk]]
[13:20:51.944]                   NAME <- NAMES[[kk]]
[13:20:51.944]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.944]                     next
[13:20:51.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.944]                 }
[13:20:51.944]                 NAMES <- toupper(added)
[13:20:51.944]                 for (kk in seq_along(NAMES)) {
[13:20:51.944]                   name <- added[[kk]]
[13:20:51.944]                   NAME <- NAMES[[kk]]
[13:20:51.944]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.944]                     next
[13:20:51.944]                   args[[name]] <- ""
[13:20:51.944]                 }
[13:20:51.944]                 NAMES <- toupper(removed)
[13:20:51.944]                 for (kk in seq_along(NAMES)) {
[13:20:51.944]                   name <- removed[[kk]]
[13:20:51.944]                   NAME <- NAMES[[kk]]
[13:20:51.944]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.944]                     next
[13:20:51.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.944]                 }
[13:20:51.944]                 if (length(args) > 0) 
[13:20:51.944]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.944]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.944]             }
[13:20:51.944]             else {
[13:20:51.944]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.944]             }
[13:20:51.944]             {
[13:20:51.944]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.944]                   0L) {
[13:20:51.944]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.944]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.944]                   base::options(opts)
[13:20:51.944]                 }
[13:20:51.944]                 {
[13:20:51.944]                   {
[13:20:51.944]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.944]                     NULL
[13:20:51.944]                   }
[13:20:51.944]                   options(future.plan = NULL)
[13:20:51.944]                   if (is.na(NA_character_)) 
[13:20:51.944]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.944]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.944]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.944]                     envir = parent.frame()) 
[13:20:51.944]                   {
[13:20:51.944]                     default_workers <- missing(workers)
[13:20:51.944]                     if (is.function(workers)) 
[13:20:51.944]                       workers <- workers()
[13:20:51.944]                     workers <- structure(as.integer(workers), 
[13:20:51.944]                       class = class(workers))
[13:20:51.944]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.944]                       1L)
[13:20:51.944]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.944]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.944]                       if (default_workers) 
[13:20:51.944]                         supportsMulticore(warn = TRUE)
[13:20:51.944]                       return(sequential(..., envir = envir))
[13:20:51.944]                     }
[13:20:51.944]                     oopts <- options(mc.cores = workers)
[13:20:51.944]                     on.exit(options(oopts))
[13:20:51.944]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.944]                       envir = envir)
[13:20:51.944]                     if (!future$lazy) 
[13:20:51.944]                       future <- run(future)
[13:20:51.944]                     invisible(future)
[13:20:51.944]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.944]                 }
[13:20:51.944]             }
[13:20:51.944]         }
[13:20:51.944]     })
[13:20:51.944]     if (TRUE) {
[13:20:51.944]         base::sink(type = "output", split = FALSE)
[13:20:51.944]         if (TRUE) {
[13:20:51.944]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.944]         }
[13:20:51.944]         else {
[13:20:51.944]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.944]         }
[13:20:51.944]         base::close(...future.stdout)
[13:20:51.944]         ...future.stdout <- NULL
[13:20:51.944]     }
[13:20:51.944]     ...future.result$conditions <- ...future.conditions
[13:20:51.944]     ...future.result$finished <- base::Sys.time()
[13:20:51.944]     ...future.result
[13:20:51.944] }
[13:20:51.946] requestCore(): workers = 2
[13:20:51.948] MulticoreFuture started
[13:20:51.948] - Launch lazy future ... done
[13:20:51.949] run() for ‘MulticoreFuture’ ... done
[13:20:51.949] plan(): Setting new future strategy stack:
[13:20:51.950] List of future strategies:
[13:20:51.950] 1. sequential:
[13:20:51.950]    - args: function (..., envir = parent.frame())
[13:20:51.950]    - tweaked: FALSE
[13:20:51.950]    - call: NULL
[13:20:51.950] plan(): nbrOfWorkers() = 1
[13:20:51.953] plan(): Setting new future strategy stack:
[13:20:51.953] List of future strategies:
[13:20:51.953] 1. multicore:
[13:20:51.953]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.953]    - tweaked: FALSE
[13:20:51.953]    - call: plan(strategy)
[13:20:51.958] plan(): nbrOfWorkers() = 2
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:51.959] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:51.960] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:51.962] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[13:20:51.962] Searching for globals ... DONE
[13:20:51.962] Resolving globals: TRUE
[13:20:51.962] Resolving any globals that are futures ...
[13:20:51.962] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[13:20:51.962] Resolving any globals that are futures ... DONE
[13:20:51.963] Resolving futures part of globals (recursively) ...
[13:20:51.966] resolve() on list ...
[13:20:51.966]  recursive: 99
[13:20:51.967]  length: 1
[13:20:51.967]  elements: ‘x’
[13:20:51.967]  length: 0 (resolved future 1)
[13:20:51.967] resolve() on list ... DONE
[13:20:51.967] - globals: [1] ‘x’
[13:20:51.968] Resolving futures part of globals (recursively) ... DONE
[13:20:51.968] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:51.968] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[13:20:51.969] - globals: [1] ‘x’
[13:20:51.969] 
[13:20:51.969] getGlobalsAndPackages() ... DONE
[13:20:51.969] run() for ‘Future’ ...
[13:20:51.969] - state: ‘created’
[13:20:51.970] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:51.975] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:51.975] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:51.975]   - Field: ‘label’
[13:20:51.975]   - Field: ‘local’
[13:20:51.975]   - Field: ‘owner’
[13:20:51.976]   - Field: ‘envir’
[13:20:51.976]   - Field: ‘workers’
[13:20:51.976]   - Field: ‘packages’
[13:20:51.976]   - Field: ‘gc’
[13:20:51.976]   - Field: ‘job’
[13:20:51.976]   - Field: ‘conditions’
[13:20:51.976]   - Field: ‘expr’
[13:20:51.977]   - Field: ‘uuid’
[13:20:51.977]   - Field: ‘seed’
[13:20:51.977]   - Field: ‘version’
[13:20:51.977]   - Field: ‘result’
[13:20:51.977]   - Field: ‘asynchronous’
[13:20:51.977]   - Field: ‘calls’
[13:20:51.977]   - Field: ‘globals’
[13:20:51.978]   - Field: ‘stdout’
[13:20:51.978]   - Field: ‘earlySignal’
[13:20:51.978]   - Field: ‘lazy’
[13:20:51.978]   - Field: ‘state’
[13:20:51.978] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:51.978] - Launch lazy future ...
[13:20:51.978] Packages needed by the future expression (n = 0): <none>
[13:20:51.979] Packages needed by future strategies (n = 0): <none>
[13:20:51.979] {
[13:20:51.979]     {
[13:20:51.979]         {
[13:20:51.979]             ...future.startTime <- base::Sys.time()
[13:20:51.979]             {
[13:20:51.979]                 {
[13:20:51.979]                   {
[13:20:51.979]                     {
[13:20:51.979]                       base::local({
[13:20:51.979]                         has_future <- base::requireNamespace("future", 
[13:20:51.979]                           quietly = TRUE)
[13:20:51.979]                         if (has_future) {
[13:20:51.979]                           ns <- base::getNamespace("future")
[13:20:51.979]                           version <- ns[[".package"]][["version"]]
[13:20:51.979]                           if (is.null(version)) 
[13:20:51.979]                             version <- utils::packageVersion("future")
[13:20:51.979]                         }
[13:20:51.979]                         else {
[13:20:51.979]                           version <- NULL
[13:20:51.979]                         }
[13:20:51.979]                         if (!has_future || version < "1.8.0") {
[13:20:51.979]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:51.979]                             "", base::R.version$version.string), 
[13:20:51.979]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:51.979]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:51.979]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:51.979]                               "release", "version")], collapse = " "), 
[13:20:51.979]                             hostname = base::Sys.info()[["nodename"]])
[13:20:51.979]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:51.979]                             info)
[13:20:51.979]                           info <- base::paste(info, collapse = "; ")
[13:20:51.979]                           if (!has_future) {
[13:20:51.979]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:51.979]                               info)
[13:20:51.979]                           }
[13:20:51.979]                           else {
[13:20:51.979]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:51.979]                               info, version)
[13:20:51.979]                           }
[13:20:51.979]                           base::stop(msg)
[13:20:51.979]                         }
[13:20:51.979]                       })
[13:20:51.979]                     }
[13:20:51.979]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:51.979]                     base::options(mc.cores = 1L)
[13:20:51.979]                   }
[13:20:51.979]                   options(future.plan = NULL)
[13:20:51.979]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.979]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:51.979]                 }
[13:20:51.979]                 ...future.workdir <- getwd()
[13:20:51.979]             }
[13:20:51.979]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:51.979]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:51.979]         }
[13:20:51.979]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:51.979]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:51.979]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:51.979]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:51.979]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:51.979]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:51.979]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:51.979]             base::names(...future.oldOptions))
[13:20:51.979]     }
[13:20:51.979]     if (FALSE) {
[13:20:51.979]     }
[13:20:51.979]     else {
[13:20:51.979]         if (TRUE) {
[13:20:51.979]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:51.979]                 open = "w")
[13:20:51.979]         }
[13:20:51.979]         else {
[13:20:51.979]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:51.979]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:51.979]         }
[13:20:51.979]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:51.979]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:51.979]             base::sink(type = "output", split = FALSE)
[13:20:51.979]             base::close(...future.stdout)
[13:20:51.979]         }, add = TRUE)
[13:20:51.979]     }
[13:20:51.979]     ...future.frame <- base::sys.nframe()
[13:20:51.979]     ...future.conditions <- base::list()
[13:20:51.979]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:51.979]     if (FALSE) {
[13:20:51.979]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:51.979]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:51.979]     }
[13:20:51.979]     ...future.result <- base::tryCatch({
[13:20:51.979]         base::withCallingHandlers({
[13:20:51.979]             ...future.value <- base::withVisible(base::local({
[13:20:51.979]                 withCallingHandlers({
[13:20:51.979]                   {
[13:20:51.979]                     x <- x + 1
[13:20:51.979]                     x
[13:20:51.979]                   }
[13:20:51.979]                 }, immediateCondition = function(cond) {
[13:20:51.979]                   save_rds <- function (object, pathname, ...) 
[13:20:51.979]                   {
[13:20:51.979]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:51.979]                     if (file_test("-f", pathname_tmp)) {
[13:20:51.979]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.979]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:51.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.979]                         fi_tmp[["mtime"]])
[13:20:51.979]                     }
[13:20:51.979]                     tryCatch({
[13:20:51.979]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:51.979]                     }, error = function(ex) {
[13:20:51.979]                       msg <- conditionMessage(ex)
[13:20:51.979]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.979]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:51.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.979]                         fi_tmp[["mtime"]], msg)
[13:20:51.979]                       ex$message <- msg
[13:20:51.979]                       stop(ex)
[13:20:51.979]                     })
[13:20:51.979]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:51.979]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:51.979]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:51.979]                       fi_tmp <- file.info(pathname_tmp)
[13:20:51.979]                       fi <- file.info(pathname)
[13:20:51.979]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:51.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:51.979]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:51.979]                         fi[["size"]], fi[["mtime"]])
[13:20:51.979]                       stop(msg)
[13:20:51.979]                     }
[13:20:51.979]                     invisible(pathname)
[13:20:51.979]                   }
[13:20:51.979]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:51.979]                     rootPath = tempdir()) 
[13:20:51.979]                   {
[13:20:51.979]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:51.979]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:51.979]                       tmpdir = path, fileext = ".rds")
[13:20:51.979]                     save_rds(obj, file)
[13:20:51.979]                   }
[13:20:51.979]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:51.979]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.979]                   {
[13:20:51.979]                     inherits <- base::inherits
[13:20:51.979]                     invokeRestart <- base::invokeRestart
[13:20:51.979]                     is.null <- base::is.null
[13:20:51.979]                     muffled <- FALSE
[13:20:51.979]                     if (inherits(cond, "message")) {
[13:20:51.979]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:51.979]                       if (muffled) 
[13:20:51.979]                         invokeRestart("muffleMessage")
[13:20:51.979]                     }
[13:20:51.979]                     else if (inherits(cond, "warning")) {
[13:20:51.979]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:51.979]                       if (muffled) 
[13:20:51.979]                         invokeRestart("muffleWarning")
[13:20:51.979]                     }
[13:20:51.979]                     else if (inherits(cond, "condition")) {
[13:20:51.979]                       if (!is.null(pattern)) {
[13:20:51.979]                         computeRestarts <- base::computeRestarts
[13:20:51.979]                         grepl <- base::grepl
[13:20:51.979]                         restarts <- computeRestarts(cond)
[13:20:51.979]                         for (restart in restarts) {
[13:20:51.979]                           name <- restart$name
[13:20:51.979]                           if (is.null(name)) 
[13:20:51.979]                             next
[13:20:51.979]                           if (!grepl(pattern, name)) 
[13:20:51.979]                             next
[13:20:51.979]                           invokeRestart(restart)
[13:20:51.979]                           muffled <- TRUE
[13:20:51.979]                           break
[13:20:51.979]                         }
[13:20:51.979]                       }
[13:20:51.979]                     }
[13:20:51.979]                     invisible(muffled)
[13:20:51.979]                   }
[13:20:51.979]                   muffleCondition(cond)
[13:20:51.979]                 })
[13:20:51.979]             }))
[13:20:51.979]             future::FutureResult(value = ...future.value$value, 
[13:20:51.979]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.979]                   ...future.rng), globalenv = if (FALSE) 
[13:20:51.979]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:51.979]                     ...future.globalenv.names))
[13:20:51.979]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:51.979]         }, condition = base::local({
[13:20:51.979]             c <- base::c
[13:20:51.979]             inherits <- base::inherits
[13:20:51.979]             invokeRestart <- base::invokeRestart
[13:20:51.979]             length <- base::length
[13:20:51.979]             list <- base::list
[13:20:51.979]             seq.int <- base::seq.int
[13:20:51.979]             signalCondition <- base::signalCondition
[13:20:51.979]             sys.calls <- base::sys.calls
[13:20:51.979]             `[[` <- base::`[[`
[13:20:51.979]             `+` <- base::`+`
[13:20:51.979]             `<<-` <- base::`<<-`
[13:20:51.979]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:51.979]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:51.979]                   3L)]
[13:20:51.979]             }
[13:20:51.979]             function(cond) {
[13:20:51.979]                 is_error <- inherits(cond, "error")
[13:20:51.979]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:51.979]                   NULL)
[13:20:51.979]                 if (is_error) {
[13:20:51.979]                   sessionInformation <- function() {
[13:20:51.979]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:51.979]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:51.979]                       search = base::search(), system = base::Sys.info())
[13:20:51.979]                   }
[13:20:51.979]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.979]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:51.979]                     cond$call), session = sessionInformation(), 
[13:20:51.979]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:51.979]                   signalCondition(cond)
[13:20:51.979]                 }
[13:20:51.979]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:51.979]                 "immediateCondition"))) {
[13:20:51.979]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:51.979]                   ...future.conditions[[length(...future.conditions) + 
[13:20:51.979]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:51.979]                   if (TRUE && !signal) {
[13:20:51.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.979]                     {
[13:20:51.979]                       inherits <- base::inherits
[13:20:51.979]                       invokeRestart <- base::invokeRestart
[13:20:51.979]                       is.null <- base::is.null
[13:20:51.979]                       muffled <- FALSE
[13:20:51.979]                       if (inherits(cond, "message")) {
[13:20:51.979]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.979]                         if (muffled) 
[13:20:51.979]                           invokeRestart("muffleMessage")
[13:20:51.979]                       }
[13:20:51.979]                       else if (inherits(cond, "warning")) {
[13:20:51.979]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.979]                         if (muffled) 
[13:20:51.979]                           invokeRestart("muffleWarning")
[13:20:51.979]                       }
[13:20:51.979]                       else if (inherits(cond, "condition")) {
[13:20:51.979]                         if (!is.null(pattern)) {
[13:20:51.979]                           computeRestarts <- base::computeRestarts
[13:20:51.979]                           grepl <- base::grepl
[13:20:51.979]                           restarts <- computeRestarts(cond)
[13:20:51.979]                           for (restart in restarts) {
[13:20:51.979]                             name <- restart$name
[13:20:51.979]                             if (is.null(name)) 
[13:20:51.979]                               next
[13:20:51.979]                             if (!grepl(pattern, name)) 
[13:20:51.979]                               next
[13:20:51.979]                             invokeRestart(restart)
[13:20:51.979]                             muffled <- TRUE
[13:20:51.979]                             break
[13:20:51.979]                           }
[13:20:51.979]                         }
[13:20:51.979]                       }
[13:20:51.979]                       invisible(muffled)
[13:20:51.979]                     }
[13:20:51.979]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.979]                   }
[13:20:51.979]                 }
[13:20:51.979]                 else {
[13:20:51.979]                   if (TRUE) {
[13:20:51.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:51.979]                     {
[13:20:51.979]                       inherits <- base::inherits
[13:20:51.979]                       invokeRestart <- base::invokeRestart
[13:20:51.979]                       is.null <- base::is.null
[13:20:51.979]                       muffled <- FALSE
[13:20:51.979]                       if (inherits(cond, "message")) {
[13:20:51.979]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:51.979]                         if (muffled) 
[13:20:51.979]                           invokeRestart("muffleMessage")
[13:20:51.979]                       }
[13:20:51.979]                       else if (inherits(cond, "warning")) {
[13:20:51.979]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:51.979]                         if (muffled) 
[13:20:51.979]                           invokeRestart("muffleWarning")
[13:20:51.979]                       }
[13:20:51.979]                       else if (inherits(cond, "condition")) {
[13:20:51.979]                         if (!is.null(pattern)) {
[13:20:51.979]                           computeRestarts <- base::computeRestarts
[13:20:51.979]                           grepl <- base::grepl
[13:20:51.979]                           restarts <- computeRestarts(cond)
[13:20:51.979]                           for (restart in restarts) {
[13:20:51.979]                             name <- restart$name
[13:20:51.979]                             if (is.null(name)) 
[13:20:51.979]                               next
[13:20:51.979]                             if (!grepl(pattern, name)) 
[13:20:51.979]                               next
[13:20:51.979]                             invokeRestart(restart)
[13:20:51.979]                             muffled <- TRUE
[13:20:51.979]                             break
[13:20:51.979]                           }
[13:20:51.979]                         }
[13:20:51.979]                       }
[13:20:51.979]                       invisible(muffled)
[13:20:51.979]                     }
[13:20:51.979]                     muffleCondition(cond, pattern = "^muffle")
[13:20:51.979]                   }
[13:20:51.979]                 }
[13:20:51.979]             }
[13:20:51.979]         }))
[13:20:51.979]     }, error = function(ex) {
[13:20:51.979]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:51.979]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:51.979]                 ...future.rng), started = ...future.startTime, 
[13:20:51.979]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:51.979]             version = "1.8"), class = "FutureResult")
[13:20:51.979]     }, finally = {
[13:20:51.979]         if (!identical(...future.workdir, getwd())) 
[13:20:51.979]             setwd(...future.workdir)
[13:20:51.979]         {
[13:20:51.979]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:51.979]                 ...future.oldOptions$nwarnings <- NULL
[13:20:51.979]             }
[13:20:51.979]             base::options(...future.oldOptions)
[13:20:51.979]             if (.Platform$OS.type == "windows") {
[13:20:51.979]                 old_names <- names(...future.oldEnvVars)
[13:20:51.979]                 envs <- base::Sys.getenv()
[13:20:51.979]                 names <- names(envs)
[13:20:51.979]                 common <- intersect(names, old_names)
[13:20:51.979]                 added <- setdiff(names, old_names)
[13:20:51.979]                 removed <- setdiff(old_names, names)
[13:20:51.979]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:51.979]                   envs[common]]
[13:20:51.979]                 NAMES <- toupper(changed)
[13:20:51.979]                 args <- list()
[13:20:51.979]                 for (kk in seq_along(NAMES)) {
[13:20:51.979]                   name <- changed[[kk]]
[13:20:51.979]                   NAME <- NAMES[[kk]]
[13:20:51.979]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.979]                     next
[13:20:51.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.979]                 }
[13:20:51.979]                 NAMES <- toupper(added)
[13:20:51.979]                 for (kk in seq_along(NAMES)) {
[13:20:51.979]                   name <- added[[kk]]
[13:20:51.979]                   NAME <- NAMES[[kk]]
[13:20:51.979]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.979]                     next
[13:20:51.979]                   args[[name]] <- ""
[13:20:51.979]                 }
[13:20:51.979]                 NAMES <- toupper(removed)
[13:20:51.979]                 for (kk in seq_along(NAMES)) {
[13:20:51.979]                   name <- removed[[kk]]
[13:20:51.979]                   NAME <- NAMES[[kk]]
[13:20:51.979]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:51.979]                     next
[13:20:51.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:51.979]                 }
[13:20:51.979]                 if (length(args) > 0) 
[13:20:51.979]                   base::do.call(base::Sys.setenv, args = args)
[13:20:51.979]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:51.979]             }
[13:20:51.979]             else {
[13:20:51.979]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:51.979]             }
[13:20:51.979]             {
[13:20:51.979]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:51.979]                   0L) {
[13:20:51.979]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:51.979]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:51.979]                   base::options(opts)
[13:20:51.979]                 }
[13:20:51.979]                 {
[13:20:51.979]                   {
[13:20:51.979]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:51.979]                     NULL
[13:20:51.979]                   }
[13:20:51.979]                   options(future.plan = NULL)
[13:20:51.979]                   if (is.na(NA_character_)) 
[13:20:51.979]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:51.979]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:51.979]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:51.979]                     envir = parent.frame()) 
[13:20:51.979]                   {
[13:20:51.979]                     default_workers <- missing(workers)
[13:20:51.979]                     if (is.function(workers)) 
[13:20:51.979]                       workers <- workers()
[13:20:51.979]                     workers <- structure(as.integer(workers), 
[13:20:51.979]                       class = class(workers))
[13:20:51.979]                     stop_if_not(is.finite(workers), workers >= 
[13:20:51.979]                       1L)
[13:20:51.979]                     if ((workers == 1L && !inherits(workers, 
[13:20:51.979]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:51.979]                       if (default_workers) 
[13:20:51.979]                         supportsMulticore(warn = TRUE)
[13:20:51.979]                       return(sequential(..., envir = envir))
[13:20:51.979]                     }
[13:20:51.979]                     oopts <- options(mc.cores = workers)
[13:20:51.979]                     on.exit(options(oopts))
[13:20:51.979]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:51.979]                       envir = envir)
[13:20:51.979]                     if (!future$lazy) 
[13:20:51.979]                       future <- run(future)
[13:20:51.979]                     invisible(future)
[13:20:51.979]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:51.979]                 }
[13:20:51.979]             }
[13:20:51.979]         }
[13:20:51.979]     })
[13:20:51.979]     if (TRUE) {
[13:20:51.979]         base::sink(type = "output", split = FALSE)
[13:20:51.979]         if (TRUE) {
[13:20:51.979]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:51.979]         }
[13:20:51.979]         else {
[13:20:51.979]             ...future.result["stdout"] <- base::list(NULL)
[13:20:51.979]         }
[13:20:51.979]         base::close(...future.stdout)
[13:20:51.979]         ...future.stdout <- NULL
[13:20:51.979]     }
[13:20:51.979]     ...future.result$conditions <- ...future.conditions
[13:20:51.979]     ...future.result$finished <- base::Sys.time()
[13:20:51.979]     ...future.result
[13:20:51.979] }
[13:20:51.982] assign_globals() ...
[13:20:51.982] List of 1
[13:20:51.982]  $ x: num 1
[13:20:51.982]  - attr(*, "where")=List of 1
[13:20:51.982]   ..$ x:<environment: R_EmptyEnv> 
[13:20:51.982]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:51.982]  - attr(*, "resolved")= logi TRUE
[13:20:51.982]  - attr(*, "total_size")= num 56
[13:20:51.982]  - attr(*, "already-done")= logi TRUE
[13:20:51.985] - copied ‘x’ to environment
[13:20:51.985] assign_globals() ... done
[13:20:51.985] requestCore(): workers = 2
[13:20:51.987] MulticoreFuture started
[13:20:51.988] - Launch lazy future ... done
[13:20:51.988] run() for ‘MulticoreFuture’ ... done
[13:20:51.989] plan(): Setting new future strategy stack:
[13:20:51.989] List of future strategies:
[13:20:51.989] 1. sequential:
[13:20:51.989]    - args: function (..., envir = parent.frame())
[13:20:51.989]    - tweaked: FALSE
[13:20:51.989]    - call: NULL
[13:20:51.990] plan(): nbrOfWorkers() = 1
[13:20:51.992] plan(): Setting new future strategy stack:
[13:20:51.992] List of future strategies:
[13:20:51.992] 1. multicore:
[13:20:51.992]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:51.992]    - tweaked: FALSE
[13:20:51.992]    - call: plan(strategy)
[13:20:51.998] plan(): nbrOfWorkers() = 2
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:52.000] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:52.000] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:52.003] - globals found: [3] ‘{’, ‘<-’, ‘x’
[13:20:52.003] Searching for globals ... DONE
[13:20:52.003] Resolving globals: TRUE
[13:20:52.003] Resolving any globals that are futures ...
[13:20:52.003] - globals: [3] ‘{’, ‘<-’, ‘x’
[13:20:52.004] Resolving any globals that are futures ... DONE
[13:20:52.004] Resolving futures part of globals (recursively) ...
[13:20:52.004] resolve() on list ...
[13:20:52.005]  recursive: 99
[13:20:52.005]  length: 1
[13:20:52.005]  elements: ‘x’
[13:20:52.005]  length: 0 (resolved future 1)
[13:20:52.005] resolve() on list ... DONE
[13:20:52.005] - globals: [1] ‘x’
[13:20:52.005] Resolving futures part of globals (recursively) ... DONE
[13:20:52.006] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[13:20:52.006] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[13:20:52.006] - globals: [1] ‘x’
[13:20:52.006] 
[13:20:52.006] getGlobalsAndPackages() ... DONE
[13:20:52.007] run() for ‘Future’ ...
[13:20:52.007] - state: ‘created’
[13:20:52.007] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:20:52.011] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:52.011] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:20:52.011]   - Field: ‘label’
[13:20:52.012]   - Field: ‘local’
[13:20:52.015]   - Field: ‘owner’
[13:20:52.015]   - Field: ‘envir’
[13:20:52.015]   - Field: ‘workers’
[13:20:52.015]   - Field: ‘packages’
[13:20:52.015]   - Field: ‘gc’
[13:20:52.016]   - Field: ‘job’
[13:20:52.016]   - Field: ‘conditions’
[13:20:52.016]   - Field: ‘expr’
[13:20:52.016]   - Field: ‘uuid’
[13:20:52.016]   - Field: ‘seed’
[13:20:52.016]   - Field: ‘version’
[13:20:52.017]   - Field: ‘result’
[13:20:52.017]   - Field: ‘asynchronous’
[13:20:52.017]   - Field: ‘calls’
[13:20:52.017]   - Field: ‘globals’
[13:20:52.017]   - Field: ‘stdout’
[13:20:52.017]   - Field: ‘earlySignal’
[13:20:52.017]   - Field: ‘lazy’
[13:20:52.018]   - Field: ‘state’
[13:20:52.018] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:20:52.018] - Launch lazy future ...
[13:20:52.018] Packages needed by the future expression (n = 0): <none>
[13:20:52.018] Packages needed by future strategies (n = 0): <none>
[13:20:52.019] {
[13:20:52.019]     {
[13:20:52.019]         {
[13:20:52.019]             ...future.startTime <- base::Sys.time()
[13:20:52.019]             {
[13:20:52.019]                 {
[13:20:52.019]                   {
[13:20:52.019]                     {
[13:20:52.019]                       base::local({
[13:20:52.019]                         has_future <- base::requireNamespace("future", 
[13:20:52.019]                           quietly = TRUE)
[13:20:52.019]                         if (has_future) {
[13:20:52.019]                           ns <- base::getNamespace("future")
[13:20:52.019]                           version <- ns[[".package"]][["version"]]
[13:20:52.019]                           if (is.null(version)) 
[13:20:52.019]                             version <- utils::packageVersion("future")
[13:20:52.019]                         }
[13:20:52.019]                         else {
[13:20:52.019]                           version <- NULL
[13:20:52.019]                         }
[13:20:52.019]                         if (!has_future || version < "1.8.0") {
[13:20:52.019]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:52.019]                             "", base::R.version$version.string), 
[13:20:52.019]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:52.019]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:52.019]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:52.019]                               "release", "version")], collapse = " "), 
[13:20:52.019]                             hostname = base::Sys.info()[["nodename"]])
[13:20:52.019]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:52.019]                             info)
[13:20:52.019]                           info <- base::paste(info, collapse = "; ")
[13:20:52.019]                           if (!has_future) {
[13:20:52.019]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:52.019]                               info)
[13:20:52.019]                           }
[13:20:52.019]                           else {
[13:20:52.019]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:52.019]                               info, version)
[13:20:52.019]                           }
[13:20:52.019]                           base::stop(msg)
[13:20:52.019]                         }
[13:20:52.019]                       })
[13:20:52.019]                     }
[13:20:52.019]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:52.019]                     base::options(mc.cores = 1L)
[13:20:52.019]                   }
[13:20:52.019]                   options(future.plan = NULL)
[13:20:52.019]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:52.019]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:52.019]                 }
[13:20:52.019]                 ...future.workdir <- getwd()
[13:20:52.019]             }
[13:20:52.019]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:52.019]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:52.019]         }
[13:20:52.019]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:52.019]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:52.019]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:52.019]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:52.019]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:52.019]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:52.019]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:52.019]             base::names(...future.oldOptions))
[13:20:52.019]     }
[13:20:52.019]     if (FALSE) {
[13:20:52.019]     }
[13:20:52.019]     else {
[13:20:52.019]         if (TRUE) {
[13:20:52.019]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:52.019]                 open = "w")
[13:20:52.019]         }
[13:20:52.019]         else {
[13:20:52.019]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:52.019]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:52.019]         }
[13:20:52.019]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:52.019]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:52.019]             base::sink(type = "output", split = FALSE)
[13:20:52.019]             base::close(...future.stdout)
[13:20:52.019]         }, add = TRUE)
[13:20:52.019]     }
[13:20:52.019]     ...future.frame <- base::sys.nframe()
[13:20:52.019]     ...future.conditions <- base::list()
[13:20:52.019]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:52.019]     if (FALSE) {
[13:20:52.019]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:52.019]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:52.019]     }
[13:20:52.019]     ...future.result <- base::tryCatch({
[13:20:52.019]         base::withCallingHandlers({
[13:20:52.019]             ...future.value <- base::withVisible(base::local({
[13:20:52.019]                 withCallingHandlers({
[13:20:52.019]                   {
[13:20:52.019]                     x <- x()
[13:20:52.019]                     x
[13:20:52.019]                   }
[13:20:52.019]                 }, immediateCondition = function(cond) {
[13:20:52.019]                   save_rds <- function (object, pathname, ...) 
[13:20:52.019]                   {
[13:20:52.019]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:20:52.019]                     if (file_test("-f", pathname_tmp)) {
[13:20:52.019]                       fi_tmp <- file.info(pathname_tmp)
[13:20:52.019]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:20:52.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:52.019]                         fi_tmp[["mtime"]])
[13:20:52.019]                     }
[13:20:52.019]                     tryCatch({
[13:20:52.019]                       saveRDS(object, file = pathname_tmp, ...)
[13:20:52.019]                     }, error = function(ex) {
[13:20:52.019]                       msg <- conditionMessage(ex)
[13:20:52.019]                       fi_tmp <- file.info(pathname_tmp)
[13:20:52.019]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:20:52.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:52.019]                         fi_tmp[["mtime"]], msg)
[13:20:52.019]                       ex$message <- msg
[13:20:52.019]                       stop(ex)
[13:20:52.019]                     })
[13:20:52.019]                     stopifnot(file_test("-f", pathname_tmp))
[13:20:52.019]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:20:52.019]                     if (!res || file_test("-f", pathname_tmp)) {
[13:20:52.019]                       fi_tmp <- file.info(pathname_tmp)
[13:20:52.019]                       fi <- file.info(pathname)
[13:20:52.019]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:20:52.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:20:52.019]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:20:52.019]                         fi[["size"]], fi[["mtime"]])
[13:20:52.019]                       stop(msg)
[13:20:52.019]                     }
[13:20:52.019]                     invisible(pathname)
[13:20:52.019]                   }
[13:20:52.019]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:20:52.019]                     rootPath = tempdir()) 
[13:20:52.019]                   {
[13:20:52.019]                     obj <- list(time = Sys.time(), condition = cond)
[13:20:52.019]                     file <- tempfile(pattern = class(cond)[1], 
[13:20:52.019]                       tmpdir = path, fileext = ".rds")
[13:20:52.019]                     save_rds(obj, file)
[13:20:52.019]                   }
[13:20:52.019]                   saveImmediateCondition(cond, path = "/tmp/RtmpsfRfxU/.future/immediateConditions")
[13:20:52.019]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:52.019]                   {
[13:20:52.019]                     inherits <- base::inherits
[13:20:52.019]                     invokeRestart <- base::invokeRestart
[13:20:52.019]                     is.null <- base::is.null
[13:20:52.019]                     muffled <- FALSE
[13:20:52.019]                     if (inherits(cond, "message")) {
[13:20:52.019]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:52.019]                       if (muffled) 
[13:20:52.019]                         invokeRestart("muffleMessage")
[13:20:52.019]                     }
[13:20:52.019]                     else if (inherits(cond, "warning")) {
[13:20:52.019]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:52.019]                       if (muffled) 
[13:20:52.019]                         invokeRestart("muffleWarning")
[13:20:52.019]                     }
[13:20:52.019]                     else if (inherits(cond, "condition")) {
[13:20:52.019]                       if (!is.null(pattern)) {
[13:20:52.019]                         computeRestarts <- base::computeRestarts
[13:20:52.019]                         grepl <- base::grepl
[13:20:52.019]                         restarts <- computeRestarts(cond)
[13:20:52.019]                         for (restart in restarts) {
[13:20:52.019]                           name <- restart$name
[13:20:52.019]                           if (is.null(name)) 
[13:20:52.019]                             next
[13:20:52.019]                           if (!grepl(pattern, name)) 
[13:20:52.019]                             next
[13:20:52.019]                           invokeRestart(restart)
[13:20:52.019]                           muffled <- TRUE
[13:20:52.019]                           break
[13:20:52.019]                         }
[13:20:52.019]                       }
[13:20:52.019]                     }
[13:20:52.019]                     invisible(muffled)
[13:20:52.019]                   }
[13:20:52.019]                   muffleCondition(cond)
[13:20:52.019]                 })
[13:20:52.019]             }))
[13:20:52.019]             future::FutureResult(value = ...future.value$value, 
[13:20:52.019]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:52.019]                   ...future.rng), globalenv = if (FALSE) 
[13:20:52.019]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:52.019]                     ...future.globalenv.names))
[13:20:52.019]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:52.019]         }, condition = base::local({
[13:20:52.019]             c <- base::c
[13:20:52.019]             inherits <- base::inherits
[13:20:52.019]             invokeRestart <- base::invokeRestart
[13:20:52.019]             length <- base::length
[13:20:52.019]             list <- base::list
[13:20:52.019]             seq.int <- base::seq.int
[13:20:52.019]             signalCondition <- base::signalCondition
[13:20:52.019]             sys.calls <- base::sys.calls
[13:20:52.019]             `[[` <- base::`[[`
[13:20:52.019]             `+` <- base::`+`
[13:20:52.019]             `<<-` <- base::`<<-`
[13:20:52.019]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:52.019]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:52.019]                   3L)]
[13:20:52.019]             }
[13:20:52.019]             function(cond) {
[13:20:52.019]                 is_error <- inherits(cond, "error")
[13:20:52.019]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:52.019]                   NULL)
[13:20:52.019]                 if (is_error) {
[13:20:52.019]                   sessionInformation <- function() {
[13:20:52.019]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:52.019]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:52.019]                       search = base::search(), system = base::Sys.info())
[13:20:52.019]                   }
[13:20:52.019]                   ...future.conditions[[length(...future.conditions) + 
[13:20:52.019]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:52.019]                     cond$call), session = sessionInformation(), 
[13:20:52.019]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:52.019]                   signalCondition(cond)
[13:20:52.019]                 }
[13:20:52.019]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:52.019]                 "immediateCondition"))) {
[13:20:52.019]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:52.019]                   ...future.conditions[[length(...future.conditions) + 
[13:20:52.019]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:52.019]                   if (TRUE && !signal) {
[13:20:52.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:52.019]                     {
[13:20:52.019]                       inherits <- base::inherits
[13:20:52.019]                       invokeRestart <- base::invokeRestart
[13:20:52.019]                       is.null <- base::is.null
[13:20:52.019]                       muffled <- FALSE
[13:20:52.019]                       if (inherits(cond, "message")) {
[13:20:52.019]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:52.019]                         if (muffled) 
[13:20:52.019]                           invokeRestart("muffleMessage")
[13:20:52.019]                       }
[13:20:52.019]                       else if (inherits(cond, "warning")) {
[13:20:52.019]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:52.019]                         if (muffled) 
[13:20:52.019]                           invokeRestart("muffleWarning")
[13:20:52.019]                       }
[13:20:52.019]                       else if (inherits(cond, "condition")) {
[13:20:52.019]                         if (!is.null(pattern)) {
[13:20:52.019]                           computeRestarts <- base::computeRestarts
[13:20:52.019]                           grepl <- base::grepl
[13:20:52.019]                           restarts <- computeRestarts(cond)
[13:20:52.019]                           for (restart in restarts) {
[13:20:52.019]                             name <- restart$name
[13:20:52.019]                             if (is.null(name)) 
[13:20:52.019]                               next
[13:20:52.019]                             if (!grepl(pattern, name)) 
[13:20:52.019]                               next
[13:20:52.019]                             invokeRestart(restart)
[13:20:52.019]                             muffled <- TRUE
[13:20:52.019]                             break
[13:20:52.019]                           }
[13:20:52.019]                         }
[13:20:52.019]                       }
[13:20:52.019]                       invisible(muffled)
[13:20:52.019]                     }
[13:20:52.019]                     muffleCondition(cond, pattern = "^muffle")
[13:20:52.019]                   }
[13:20:52.019]                 }
[13:20:52.019]                 else {
[13:20:52.019]                   if (TRUE) {
[13:20:52.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:52.019]                     {
[13:20:52.019]                       inherits <- base::inherits
[13:20:52.019]                       invokeRestart <- base::invokeRestart
[13:20:52.019]                       is.null <- base::is.null
[13:20:52.019]                       muffled <- FALSE
[13:20:52.019]                       if (inherits(cond, "message")) {
[13:20:52.019]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:52.019]                         if (muffled) 
[13:20:52.019]                           invokeRestart("muffleMessage")
[13:20:52.019]                       }
[13:20:52.019]                       else if (inherits(cond, "warning")) {
[13:20:52.019]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:52.019]                         if (muffled) 
[13:20:52.019]                           invokeRestart("muffleWarning")
[13:20:52.019]                       }
[13:20:52.019]                       else if (inherits(cond, "condition")) {
[13:20:52.019]                         if (!is.null(pattern)) {
[13:20:52.019]                           computeRestarts <- base::computeRestarts
[13:20:52.019]                           grepl <- base::grepl
[13:20:52.019]                           restarts <- computeRestarts(cond)
[13:20:52.019]                           for (restart in restarts) {
[13:20:52.019]                             name <- restart$name
[13:20:52.019]                             if (is.null(name)) 
[13:20:52.019]                               next
[13:20:52.019]                             if (!grepl(pattern, name)) 
[13:20:52.019]                               next
[13:20:52.019]                             invokeRestart(restart)
[13:20:52.019]                             muffled <- TRUE
[13:20:52.019]                             break
[13:20:52.019]                           }
[13:20:52.019]                         }
[13:20:52.019]                       }
[13:20:52.019]                       invisible(muffled)
[13:20:52.019]                     }
[13:20:52.019]                     muffleCondition(cond, pattern = "^muffle")
[13:20:52.019]                   }
[13:20:52.019]                 }
[13:20:52.019]             }
[13:20:52.019]         }))
[13:20:52.019]     }, error = function(ex) {
[13:20:52.019]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:52.019]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:52.019]                 ...future.rng), started = ...future.startTime, 
[13:20:52.019]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:52.019]             version = "1.8"), class = "FutureResult")
[13:20:52.019]     }, finally = {
[13:20:52.019]         if (!identical(...future.workdir, getwd())) 
[13:20:52.019]             setwd(...future.workdir)
[13:20:52.019]         {
[13:20:52.019]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:52.019]                 ...future.oldOptions$nwarnings <- NULL
[13:20:52.019]             }
[13:20:52.019]             base::options(...future.oldOptions)
[13:20:52.019]             if (.Platform$OS.type == "windows") {
[13:20:52.019]                 old_names <- names(...future.oldEnvVars)
[13:20:52.019]                 envs <- base::Sys.getenv()
[13:20:52.019]                 names <- names(envs)
[13:20:52.019]                 common <- intersect(names, old_names)
[13:20:52.019]                 added <- setdiff(names, old_names)
[13:20:52.019]                 removed <- setdiff(old_names, names)
[13:20:52.019]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:52.019]                   envs[common]]
[13:20:52.019]                 NAMES <- toupper(changed)
[13:20:52.019]                 args <- list()
[13:20:52.019]                 for (kk in seq_along(NAMES)) {
[13:20:52.019]                   name <- changed[[kk]]
[13:20:52.019]                   NAME <- NAMES[[kk]]
[13:20:52.019]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:52.019]                     next
[13:20:52.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:52.019]                 }
[13:20:52.019]                 NAMES <- toupper(added)
[13:20:52.019]                 for (kk in seq_along(NAMES)) {
[13:20:52.019]                   name <- added[[kk]]
[13:20:52.019]                   NAME <- NAMES[[kk]]
[13:20:52.019]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:52.019]                     next
[13:20:52.019]                   args[[name]] <- ""
[13:20:52.019]                 }
[13:20:52.019]                 NAMES <- toupper(removed)
[13:20:52.019]                 for (kk in seq_along(NAMES)) {
[13:20:52.019]                   name <- removed[[kk]]
[13:20:52.019]                   NAME <- NAMES[[kk]]
[13:20:52.019]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:52.019]                     next
[13:20:52.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:52.019]                 }
[13:20:52.019]                 if (length(args) > 0) 
[13:20:52.019]                   base::do.call(base::Sys.setenv, args = args)
[13:20:52.019]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:52.019]             }
[13:20:52.019]             else {
[13:20:52.019]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:52.019]             }
[13:20:52.019]             {
[13:20:52.019]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:52.019]                   0L) {
[13:20:52.019]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:52.019]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:52.019]                   base::options(opts)
[13:20:52.019]                 }
[13:20:52.019]                 {
[13:20:52.019]                   {
[13:20:52.019]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:52.019]                     NULL
[13:20:52.019]                   }
[13:20:52.019]                   options(future.plan = NULL)
[13:20:52.019]                   if (is.na(NA_character_)) 
[13:20:52.019]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:52.019]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:52.019]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:20:52.019]                     envir = parent.frame()) 
[13:20:52.019]                   {
[13:20:52.019]                     default_workers <- missing(workers)
[13:20:52.019]                     if (is.function(workers)) 
[13:20:52.019]                       workers <- workers()
[13:20:52.019]                     workers <- structure(as.integer(workers), 
[13:20:52.019]                       class = class(workers))
[13:20:52.019]                     stop_if_not(is.finite(workers), workers >= 
[13:20:52.019]                       1L)
[13:20:52.019]                     if ((workers == 1L && !inherits(workers, 
[13:20:52.019]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:20:52.019]                       if (default_workers) 
[13:20:52.019]                         supportsMulticore(warn = TRUE)
[13:20:52.019]                       return(sequential(..., envir = envir))
[13:20:52.019]                     }
[13:20:52.019]                     oopts <- options(mc.cores = workers)
[13:20:52.019]                     on.exit(options(oopts))
[13:20:52.019]                     future <- MulticoreFuture(..., workers = workers, 
[13:20:52.019]                       envir = envir)
[13:20:52.019]                     if (!future$lazy) 
[13:20:52.019]                       future <- run(future)
[13:20:52.019]                     invisible(future)
[13:20:52.019]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:52.019]                 }
[13:20:52.019]             }
[13:20:52.019]         }
[13:20:52.019]     })
[13:20:52.019]     if (TRUE) {
[13:20:52.019]         base::sink(type = "output", split = FALSE)
[13:20:52.019]         if (TRUE) {
[13:20:52.019]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:52.019]         }
[13:20:52.019]         else {
[13:20:52.019]             ...future.result["stdout"] <- base::list(NULL)
[13:20:52.019]         }
[13:20:52.019]         base::close(...future.stdout)
[13:20:52.019]         ...future.stdout <- NULL
[13:20:52.019]     }
[13:20:52.019]     ...future.result$conditions <- ...future.conditions
[13:20:52.019]     ...future.result$finished <- base::Sys.time()
[13:20:52.019]     ...future.result
[13:20:52.019] }
[13:20:52.022] assign_globals() ...
[13:20:52.022] List of 1
[13:20:52.022]  $ x:function ()  
[13:20:52.022]  - attr(*, "where")=List of 1
[13:20:52.022]   ..$ x:<environment: R_EmptyEnv> 
[13:20:52.022]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:52.022]  - attr(*, "resolved")= logi TRUE
[13:20:52.022]  - attr(*, "total_size")= num 1032
[13:20:52.022]  - attr(*, "already-done")= logi TRUE
[13:20:52.026] - reassign environment for ‘x’
[13:20:52.026] - copied ‘x’ to environment
[13:20:52.026] assign_globals() ... done
[13:20:52.026] requestCore(): workers = 2
[13:20:52.028] MulticoreFuture started
[13:20:52.028] - Launch lazy future ... done
[13:20:52.029] run() for ‘MulticoreFuture’ ... done
[13:20:52.029] plan(): Setting new future strategy stack:
[13:20:52.030] List of future strategies:
[13:20:52.030] 1. sequential:
[13:20:52.030]    - args: function (..., envir = parent.frame())
[13:20:52.030]    - tweaked: FALSE
[13:20:52.030]    - call: NULL
[13:20:52.031] plan(): nbrOfWorkers() = 1
[13:20:52.033] plan(): Setting new future strategy stack:
[13:20:52.033] List of future strategies:
[13:20:52.033] 1. multicore:
[13:20:52.033]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:20:52.033]    - tweaked: FALSE
[13:20:52.033]    - call: plan(strategy)
[13:20:52.039] plan(): nbrOfWorkers() = 2
value(f) = ‘TRUE’
- plan('multisession') ...
[13:20:52.040] plan(): Setting new future strategy stack:
[13:20:52.041] List of future strategies:
[13:20:52.041] 1. multisession:
[13:20:52.041]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:52.041]    - tweaked: FALSE
[13:20:52.041]    - call: plan(strategy)
[13:20:52.041] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:20:52.041] multisession:
[13:20:52.041] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:52.041] - tweaked: FALSE
[13:20:52.041] - call: plan(strategy)
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:52.049] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:52.049] Not searching for globals
[13:20:52.050] - globals: [0] <none>
[13:20:52.050] getGlobalsAndPackages() ... DONE
[13:20:52.050] [local output] makeClusterPSOCK() ...
[13:20:52.097] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:20:52.102] [local output] Base port: 11032
[13:20:52.102] [local output] Getting setup options for 2 cluster nodes ...
[13:20:52.102] [local output]  - Node 1 of 2 ...
[13:20:52.103] [local output] localMachine=TRUE => revtunnel=FALSE

[13:20:52.103] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpsfRfxU/worker.rank=1.parallelly.parent=87305.155097070c562.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpsfRfxU/worker.rank=1.parallelly.parent=87305.155097070c562.pid")'’
[13:20:52.293] - Possible to infer worker's PID: TRUE
[13:20:52.293] [local output] Rscript port: 11032

[13:20:52.294] [local output]  - Node 2 of 2 ...
[13:20:52.294] [local output] localMachine=TRUE => revtunnel=FALSE

[13:20:52.295] [local output] Rscript port: 11032

[13:20:52.295] [local output] Getting setup options for 2 cluster nodes ... done
[13:20:52.295] [local output]  - Parallel setup requested for some PSOCK nodes
[13:20:52.296] [local output] Setting up PSOCK nodes in parallel
[13:20:52.296] List of 36
[13:20:52.296]  $ worker          : chr "localhost"
[13:20:52.296]   ..- attr(*, "localhost")= logi TRUE
[13:20:52.296]  $ master          : chr "localhost"
[13:20:52.296]  $ port            : int 11032
[13:20:52.296]  $ connectTimeout  : num 120
[13:20:52.296]  $ timeout         : num 2592000
[13:20:52.296]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:20:52.296]  $ homogeneous     : logi TRUE
[13:20:52.296]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:20:52.296]  $ rscript_envs    : NULL
[13:20:52.296]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:20:52.296]  $ rscript_startup : NULL
[13:20:52.296]  $ rscript_sh      : chr "sh"
[13:20:52.296]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:20:52.296]  $ methods         : logi TRUE
[13:20:52.296]  $ socketOptions   : chr "no-delay"
[13:20:52.296]  $ useXDR          : logi FALSE
[13:20:52.296]  $ outfile         : chr "/dev/null"
[13:20:52.296]  $ renice          : int NA
[13:20:52.296]  $ rshcmd          : NULL
[13:20:52.296]  $ user            : chr(0) 
[13:20:52.296]  $ revtunnel       : logi FALSE
[13:20:52.296]  $ rshlogfile      : NULL
[13:20:52.296]  $ rshopts         : chr(0) 
[13:20:52.296]  $ rank            : int 1
[13:20:52.296]  $ manual          : logi FALSE
[13:20:52.296]  $ dryrun          : logi FALSE
[13:20:52.296]  $ quiet           : logi FALSE
[13:20:52.296]  $ setup_strategy  : chr "parallel"
[13:20:52.296]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:20:52.296]  $ pidfile         : chr "/tmp/RtmpsfRfxU/worker.rank=1.parallelly.parent=87305.155097070c562.pid"
[13:20:52.296]  $ rshcmd_label    : NULL
[13:20:52.296]  $ rsh_call        : NULL
[13:20:52.296]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:20:52.296]  $ localMachine    : logi TRUE
[13:20:52.296]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:20:52.296]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:20:52.296]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:20:52.296]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:20:52.296]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:20:52.296]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:20:52.296]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:20:52.296]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:20:52.296]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:20:52.296]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:20:52.296]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:20:52.296]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:20:52.296]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:20:52.296]  $ arguments       :List of 28
[13:20:52.296]   ..$ worker          : chr "localhost"
[13:20:52.296]   ..$ master          : NULL
[13:20:52.296]   ..$ port            : int 11032
[13:20:52.296]   ..$ connectTimeout  : num 120
[13:20:52.296]   ..$ timeout         : num 2592000
[13:20:52.296]   ..$ rscript         : NULL
[13:20:52.296]   ..$ homogeneous     : NULL
[13:20:52.296]   ..$ rscript_args    : NULL
[13:20:52.296]   ..$ rscript_envs    : NULL
[13:20:52.296]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:20:52.296]   ..$ rscript_startup : NULL
[13:20:52.296]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:20:52.296]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:20:52.296]   ..$ methods         : logi TRUE
[13:20:52.296]   ..$ socketOptions   : chr "no-delay"
[13:20:52.296]   ..$ useXDR          : logi FALSE
[13:20:52.296]   ..$ outfile         : chr "/dev/null"
[13:20:52.296]   ..$ renice          : int NA
[13:20:52.296]   ..$ rshcmd          : NULL
[13:20:52.296]   ..$ user            : NULL
[13:20:52.296]   ..$ revtunnel       : logi NA
[13:20:52.296]   ..$ rshlogfile      : NULL
[13:20:52.296]   ..$ rshopts         : NULL
[13:20:52.296]   ..$ rank            : int 1
[13:20:52.296]   ..$ manual          : logi FALSE
[13:20:52.296]   ..$ dryrun          : logi FALSE
[13:20:52.296]   ..$ quiet           : logi FALSE
[13:20:52.296]   ..$ setup_strategy  : chr "parallel"
[13:20:52.296]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:20:52.313] [local output] System call to launch all workers:
[13:20:52.313] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpsfRfxU/worker.rank=1.parallelly.parent=87305.155097070c562.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11032 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:20:52.313] [local output] Starting PSOCK main server
[13:20:52.314] [local output] Workers launched
[13:20:52.314] [local output] Waiting for workers to connect back
[13:20:52.315]  - [local output] 0 workers out of 2 ready
[13:20:52.566]  - [local output] 0 workers out of 2 ready
[13:20:52.567]  - [local output] 1 workers out of 2 ready
[13:20:52.567]  - [local output] 1 workers out of 2 ready
[13:20:52.568]  - [local output] 2 workers out of 2 ready
[13:20:52.568] [local output] Launching of workers completed
[13:20:52.568] [local output] Collecting session information from workers
[13:20:52.569] [local output]  - Worker #1 of 2
[13:20:52.570] [local output]  - Worker #2 of 2
[13:20:52.570] [local output] makeClusterPSOCK() ... done
[13:20:52.582] Packages needed by the future expression (n = 0): <none>
[13:20:52.582] Packages needed by future strategies (n = 0): <none>
[13:20:52.583] {
[13:20:52.583]     {
[13:20:52.583]         {
[13:20:52.583]             ...future.startTime <- base::Sys.time()
[13:20:52.583]             {
[13:20:52.583]                 {
[13:20:52.583]                   {
[13:20:52.583]                     {
[13:20:52.583]                       base::local({
[13:20:52.583]                         has_future <- base::requireNamespace("future", 
[13:20:52.583]                           quietly = TRUE)
[13:20:52.583]                         if (has_future) {
[13:20:52.583]                           ns <- base::getNamespace("future")
[13:20:52.583]                           version <- ns[[".package"]][["version"]]
[13:20:52.583]                           if (is.null(version)) 
[13:20:52.583]                             version <- utils::packageVersion("future")
[13:20:52.583]                         }
[13:20:52.583]                         else {
[13:20:52.583]                           version <- NULL
[13:20:52.583]                         }
[13:20:52.583]                         if (!has_future || version < "1.8.0") {
[13:20:52.583]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:52.583]                             "", base::R.version$version.string), 
[13:20:52.583]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:52.583]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:52.583]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:52.583]                               "release", "version")], collapse = " "), 
[13:20:52.583]                             hostname = base::Sys.info()[["nodename"]])
[13:20:52.583]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:52.583]                             info)
[13:20:52.583]                           info <- base::paste(info, collapse = "; ")
[13:20:52.583]                           if (!has_future) {
[13:20:52.583]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:52.583]                               info)
[13:20:52.583]                           }
[13:20:52.583]                           else {
[13:20:52.583]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:52.583]                               info, version)
[13:20:52.583]                           }
[13:20:52.583]                           base::stop(msg)
[13:20:52.583]                         }
[13:20:52.583]                       })
[13:20:52.583]                     }
[13:20:52.583]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:52.583]                     base::options(mc.cores = 1L)
[13:20:52.583]                   }
[13:20:52.583]                   options(future.plan = NULL)
[13:20:52.583]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:52.583]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:52.583]                 }
[13:20:52.583]                 ...future.workdir <- getwd()
[13:20:52.583]             }
[13:20:52.583]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:52.583]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:52.583]         }
[13:20:52.583]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:52.583]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:52.583]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:52.583]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:52.583]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:52.583]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:52.583]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:52.583]             base::names(...future.oldOptions))
[13:20:52.583]     }
[13:20:52.583]     if (FALSE) {
[13:20:52.583]     }
[13:20:52.583]     else {
[13:20:52.583]         if (TRUE) {
[13:20:52.583]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:52.583]                 open = "w")
[13:20:52.583]         }
[13:20:52.583]         else {
[13:20:52.583]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:52.583]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:52.583]         }
[13:20:52.583]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:52.583]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:52.583]             base::sink(type = "output", split = FALSE)
[13:20:52.583]             base::close(...future.stdout)
[13:20:52.583]         }, add = TRUE)
[13:20:52.583]     }
[13:20:52.583]     ...future.frame <- base::sys.nframe()
[13:20:52.583]     ...future.conditions <- base::list()
[13:20:52.583]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:52.583]     if (FALSE) {
[13:20:52.583]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:52.583]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:52.583]     }
[13:20:52.583]     ...future.result <- base::tryCatch({
[13:20:52.583]         base::withCallingHandlers({
[13:20:52.583]             ...future.value <- base::withVisible(base::local({
[13:20:52.583]                 ...future.makeSendCondition <- local({
[13:20:52.583]                   sendCondition <- NULL
[13:20:52.583]                   function(frame = 1L) {
[13:20:52.583]                     if (is.function(sendCondition)) 
[13:20:52.583]                       return(sendCondition)
[13:20:52.583]                     ns <- getNamespace("parallel")
[13:20:52.583]                     if (exists("sendData", mode = "function", 
[13:20:52.583]                       envir = ns)) {
[13:20:52.583]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:52.583]                         envir = ns)
[13:20:52.583]                       envir <- sys.frame(frame)
[13:20:52.583]                       master <- NULL
[13:20:52.583]                       while (!identical(envir, .GlobalEnv) && 
[13:20:52.583]                         !identical(envir, emptyenv())) {
[13:20:52.583]                         if (exists("master", mode = "list", envir = envir, 
[13:20:52.583]                           inherits = FALSE)) {
[13:20:52.583]                           master <- get("master", mode = "list", 
[13:20:52.583]                             envir = envir, inherits = FALSE)
[13:20:52.583]                           if (inherits(master, c("SOCKnode", 
[13:20:52.583]                             "SOCK0node"))) {
[13:20:52.583]                             sendCondition <<- function(cond) {
[13:20:52.583]                               data <- list(type = "VALUE", value = cond, 
[13:20:52.583]                                 success = TRUE)
[13:20:52.583]                               parallel_sendData(master, data)
[13:20:52.583]                             }
[13:20:52.583]                             return(sendCondition)
[13:20:52.583]                           }
[13:20:52.583]                         }
[13:20:52.583]                         frame <- frame + 1L
[13:20:52.583]                         envir <- sys.frame(frame)
[13:20:52.583]                       }
[13:20:52.583]                     }
[13:20:52.583]                     sendCondition <<- function(cond) NULL
[13:20:52.583]                   }
[13:20:52.583]                 })
[13:20:52.583]                 withCallingHandlers({
[13:20:52.583]                   NA
[13:20:52.583]                 }, immediateCondition = function(cond) {
[13:20:52.583]                   sendCondition <- ...future.makeSendCondition()
[13:20:52.583]                   sendCondition(cond)
[13:20:52.583]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:52.583]                   {
[13:20:52.583]                     inherits <- base::inherits
[13:20:52.583]                     invokeRestart <- base::invokeRestart
[13:20:52.583]                     is.null <- base::is.null
[13:20:52.583]                     muffled <- FALSE
[13:20:52.583]                     if (inherits(cond, "message")) {
[13:20:52.583]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:52.583]                       if (muffled) 
[13:20:52.583]                         invokeRestart("muffleMessage")
[13:20:52.583]                     }
[13:20:52.583]                     else if (inherits(cond, "warning")) {
[13:20:52.583]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:52.583]                       if (muffled) 
[13:20:52.583]                         invokeRestart("muffleWarning")
[13:20:52.583]                     }
[13:20:52.583]                     else if (inherits(cond, "condition")) {
[13:20:52.583]                       if (!is.null(pattern)) {
[13:20:52.583]                         computeRestarts <- base::computeRestarts
[13:20:52.583]                         grepl <- base::grepl
[13:20:52.583]                         restarts <- computeRestarts(cond)
[13:20:52.583]                         for (restart in restarts) {
[13:20:52.583]                           name <- restart$name
[13:20:52.583]                           if (is.null(name)) 
[13:20:52.583]                             next
[13:20:52.583]                           if (!grepl(pattern, name)) 
[13:20:52.583]                             next
[13:20:52.583]                           invokeRestart(restart)
[13:20:52.583]                           muffled <- TRUE
[13:20:52.583]                           break
[13:20:52.583]                         }
[13:20:52.583]                       }
[13:20:52.583]                     }
[13:20:52.583]                     invisible(muffled)
[13:20:52.583]                   }
[13:20:52.583]                   muffleCondition(cond)
[13:20:52.583]                 })
[13:20:52.583]             }))
[13:20:52.583]             future::FutureResult(value = ...future.value$value, 
[13:20:52.583]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:52.583]                   ...future.rng), globalenv = if (FALSE) 
[13:20:52.583]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:52.583]                     ...future.globalenv.names))
[13:20:52.583]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:52.583]         }, condition = base::local({
[13:20:52.583]             c <- base::c
[13:20:52.583]             inherits <- base::inherits
[13:20:52.583]             invokeRestart <- base::invokeRestart
[13:20:52.583]             length <- base::length
[13:20:52.583]             list <- base::list
[13:20:52.583]             seq.int <- base::seq.int
[13:20:52.583]             signalCondition <- base::signalCondition
[13:20:52.583]             sys.calls <- base::sys.calls
[13:20:52.583]             `[[` <- base::`[[`
[13:20:52.583]             `+` <- base::`+`
[13:20:52.583]             `<<-` <- base::`<<-`
[13:20:52.583]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:52.583]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:52.583]                   3L)]
[13:20:52.583]             }
[13:20:52.583]             function(cond) {
[13:20:52.583]                 is_error <- inherits(cond, "error")
[13:20:52.583]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:52.583]                   NULL)
[13:20:52.583]                 if (is_error) {
[13:20:52.583]                   sessionInformation <- function() {
[13:20:52.583]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:52.583]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:52.583]                       search = base::search(), system = base::Sys.info())
[13:20:52.583]                   }
[13:20:52.583]                   ...future.conditions[[length(...future.conditions) + 
[13:20:52.583]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:52.583]                     cond$call), session = sessionInformation(), 
[13:20:52.583]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:52.583]                   signalCondition(cond)
[13:20:52.583]                 }
[13:20:52.583]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:52.583]                 "immediateCondition"))) {
[13:20:52.583]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:52.583]                   ...future.conditions[[length(...future.conditions) + 
[13:20:52.583]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:52.583]                   if (TRUE && !signal) {
[13:20:52.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:52.583]                     {
[13:20:52.583]                       inherits <- base::inherits
[13:20:52.583]                       invokeRestart <- base::invokeRestart
[13:20:52.583]                       is.null <- base::is.null
[13:20:52.583]                       muffled <- FALSE
[13:20:52.583]                       if (inherits(cond, "message")) {
[13:20:52.583]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:52.583]                         if (muffled) 
[13:20:52.583]                           invokeRestart("muffleMessage")
[13:20:52.583]                       }
[13:20:52.583]                       else if (inherits(cond, "warning")) {
[13:20:52.583]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:52.583]                         if (muffled) 
[13:20:52.583]                           invokeRestart("muffleWarning")
[13:20:52.583]                       }
[13:20:52.583]                       else if (inherits(cond, "condition")) {
[13:20:52.583]                         if (!is.null(pattern)) {
[13:20:52.583]                           computeRestarts <- base::computeRestarts
[13:20:52.583]                           grepl <- base::grepl
[13:20:52.583]                           restarts <- computeRestarts(cond)
[13:20:52.583]                           for (restart in restarts) {
[13:20:52.583]                             name <- restart$name
[13:20:52.583]                             if (is.null(name)) 
[13:20:52.583]                               next
[13:20:52.583]                             if (!grepl(pattern, name)) 
[13:20:52.583]                               next
[13:20:52.583]                             invokeRestart(restart)
[13:20:52.583]                             muffled <- TRUE
[13:20:52.583]                             break
[13:20:52.583]                           }
[13:20:52.583]                         }
[13:20:52.583]                       }
[13:20:52.583]                       invisible(muffled)
[13:20:52.583]                     }
[13:20:52.583]                     muffleCondition(cond, pattern = "^muffle")
[13:20:52.583]                   }
[13:20:52.583]                 }
[13:20:52.583]                 else {
[13:20:52.583]                   if (TRUE) {
[13:20:52.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:52.583]                     {
[13:20:52.583]                       inherits <- base::inherits
[13:20:52.583]                       invokeRestart <- base::invokeRestart
[13:20:52.583]                       is.null <- base::is.null
[13:20:52.583]                       muffled <- FALSE
[13:20:52.583]                       if (inherits(cond, "message")) {
[13:20:52.583]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:52.583]                         if (muffled) 
[13:20:52.583]                           invokeRestart("muffleMessage")
[13:20:52.583]                       }
[13:20:52.583]                       else if (inherits(cond, "warning")) {
[13:20:52.583]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:52.583]                         if (muffled) 
[13:20:52.583]                           invokeRestart("muffleWarning")
[13:20:52.583]                       }
[13:20:52.583]                       else if (inherits(cond, "condition")) {
[13:20:52.583]                         if (!is.null(pattern)) {
[13:20:52.583]                           computeRestarts <- base::computeRestarts
[13:20:52.583]                           grepl <- base::grepl
[13:20:52.583]                           restarts <- computeRestarts(cond)
[13:20:52.583]                           for (restart in restarts) {
[13:20:52.583]                             name <- restart$name
[13:20:52.583]                             if (is.null(name)) 
[13:20:52.583]                               next
[13:20:52.583]                             if (!grepl(pattern, name)) 
[13:20:52.583]                               next
[13:20:52.583]                             invokeRestart(restart)
[13:20:52.583]                             muffled <- TRUE
[13:20:52.583]                             break
[13:20:52.583]                           }
[13:20:52.583]                         }
[13:20:52.583]                       }
[13:20:52.583]                       invisible(muffled)
[13:20:52.583]                     }
[13:20:52.583]                     muffleCondition(cond, pattern = "^muffle")
[13:20:52.583]                   }
[13:20:52.583]                 }
[13:20:52.583]             }
[13:20:52.583]         }))
[13:20:52.583]     }, error = function(ex) {
[13:20:52.583]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:52.583]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:52.583]                 ...future.rng), started = ...future.startTime, 
[13:20:52.583]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:52.583]             version = "1.8"), class = "FutureResult")
[13:20:52.583]     }, finally = {
[13:20:52.583]         if (!identical(...future.workdir, getwd())) 
[13:20:52.583]             setwd(...future.workdir)
[13:20:52.583]         {
[13:20:52.583]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:52.583]                 ...future.oldOptions$nwarnings <- NULL
[13:20:52.583]             }
[13:20:52.583]             base::options(...future.oldOptions)
[13:20:52.583]             if (.Platform$OS.type == "windows") {
[13:20:52.583]                 old_names <- names(...future.oldEnvVars)
[13:20:52.583]                 envs <- base::Sys.getenv()
[13:20:52.583]                 names <- names(envs)
[13:20:52.583]                 common <- intersect(names, old_names)
[13:20:52.583]                 added <- setdiff(names, old_names)
[13:20:52.583]                 removed <- setdiff(old_names, names)
[13:20:52.583]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:52.583]                   envs[common]]
[13:20:52.583]                 NAMES <- toupper(changed)
[13:20:52.583]                 args <- list()
[13:20:52.583]                 for (kk in seq_along(NAMES)) {
[13:20:52.583]                   name <- changed[[kk]]
[13:20:52.583]                   NAME <- NAMES[[kk]]
[13:20:52.583]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:52.583]                     next
[13:20:52.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:52.583]                 }
[13:20:52.583]                 NAMES <- toupper(added)
[13:20:52.583]                 for (kk in seq_along(NAMES)) {
[13:20:52.583]                   name <- added[[kk]]
[13:20:52.583]                   NAME <- NAMES[[kk]]
[13:20:52.583]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:52.583]                     next
[13:20:52.583]                   args[[name]] <- ""
[13:20:52.583]                 }
[13:20:52.583]                 NAMES <- toupper(removed)
[13:20:52.583]                 for (kk in seq_along(NAMES)) {
[13:20:52.583]                   name <- removed[[kk]]
[13:20:52.583]                   NAME <- NAMES[[kk]]
[13:20:52.583]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:52.583]                     next
[13:20:52.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:52.583]                 }
[13:20:52.583]                 if (length(args) > 0) 
[13:20:52.583]                   base::do.call(base::Sys.setenv, args = args)
[13:20:52.583]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:52.583]             }
[13:20:52.583]             else {
[13:20:52.583]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:52.583]             }
[13:20:52.583]             {
[13:20:52.583]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:52.583]                   0L) {
[13:20:52.583]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:52.583]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:52.583]                   base::options(opts)
[13:20:52.583]                 }
[13:20:52.583]                 {
[13:20:52.583]                   {
[13:20:52.583]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:52.583]                     NULL
[13:20:52.583]                   }
[13:20:52.583]                   options(future.plan = NULL)
[13:20:52.583]                   if (is.na(NA_character_)) 
[13:20:52.583]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:52.583]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:52.583]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:52.583]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:52.583]                     envir = parent.frame()) 
[13:20:52.583]                   {
[13:20:52.583]                     if (is.function(workers)) 
[13:20:52.583]                       workers <- workers()
[13:20:52.583]                     workers <- structure(as.integer(workers), 
[13:20:52.583]                       class = class(workers))
[13:20:52.583]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:52.583]                       workers >= 1)
[13:20:52.583]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:52.583]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:52.583]                     }
[13:20:52.583]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:52.583]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:52.583]                       envir = envir)
[13:20:52.583]                     if (!future$lazy) 
[13:20:52.583]                       future <- run(future)
[13:20:52.583]                     invisible(future)
[13:20:52.583]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:52.583]                 }
[13:20:52.583]             }
[13:20:52.583]         }
[13:20:52.583]     })
[13:20:52.583]     if (TRUE) {
[13:20:52.583]         base::sink(type = "output", split = FALSE)
[13:20:52.583]         if (TRUE) {
[13:20:52.583]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:52.583]         }
[13:20:52.583]         else {
[13:20:52.583]             ...future.result["stdout"] <- base::list(NULL)
[13:20:52.583]         }
[13:20:52.583]         base::close(...future.stdout)
[13:20:52.583]         ...future.stdout <- NULL
[13:20:52.583]     }
[13:20:52.583]     ...future.result$conditions <- ...future.conditions
[13:20:52.583]     ...future.result$finished <- base::Sys.time()
[13:20:52.583]     ...future.result
[13:20:52.583] }
[13:20:52.655] MultisessionFuture started
[13:20:52.655] result() for ClusterFuture ...
[13:20:52.655] receiveMessageFromWorker() for ClusterFuture ...
[13:20:52.656] - Validating connection of MultisessionFuture
[13:20:52.687] - received message: FutureResult
[13:20:52.687] - Received FutureResult
[13:20:52.687] - Erased future from FutureRegistry
[13:20:52.687] result() for ClusterFuture ...
[13:20:52.687] - result already collected: FutureResult
[13:20:52.687] result() for ClusterFuture ... done
[13:20:52.687] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:52.688] result() for ClusterFuture ... done
[13:20:52.688] result() for ClusterFuture ...
[13:20:52.688] - result already collected: FutureResult
[13:20:52.688] result() for ClusterFuture ... done
[13:20:52.688] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:20:52.692] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:52.692] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:52.692] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:52.694] - globals found: [3] ‘{’, ‘<-’, ‘*’
[13:20:52.694] Searching for globals ... DONE
[13:20:52.694] Resolving globals: TRUE
[13:20:52.694] Resolving any globals that are futures ...
[13:20:52.694] - globals: [3] ‘{’, ‘<-’, ‘*’
[13:20:52.695] Resolving any globals that are futures ... DONE
[13:20:52.695] 
[13:20:52.695] 
[13:20:52.695] getGlobalsAndPackages() ... DONE
[13:20:52.695] run() for ‘Future’ ...
[13:20:52.696] - state: ‘created’
[13:20:52.696] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:52.711] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:52.711] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:52.711]   - Field: ‘node’
[13:20:52.711]   - Field: ‘label’
[13:20:52.712]   - Field: ‘local’
[13:20:52.712]   - Field: ‘owner’
[13:20:52.712]   - Field: ‘envir’
[13:20:52.712]   - Field: ‘workers’
[13:20:52.712]   - Field: ‘packages’
[13:20:52.712]   - Field: ‘gc’
[13:20:52.712]   - Field: ‘conditions’
[13:20:52.712]   - Field: ‘persistent’
[13:20:52.712]   - Field: ‘expr’
[13:20:52.713]   - Field: ‘uuid’
[13:20:52.713]   - Field: ‘seed’
[13:20:52.713]   - Field: ‘version’
[13:20:52.713]   - Field: ‘result’
[13:20:52.713]   - Field: ‘asynchronous’
[13:20:52.713]   - Field: ‘calls’
[13:20:52.713]   - Field: ‘globals’
[13:20:52.713]   - Field: ‘stdout’
[13:20:52.714]   - Field: ‘earlySignal’
[13:20:52.714]   - Field: ‘lazy’
[13:20:52.714]   - Field: ‘state’
[13:20:52.714] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:52.714] - Launch lazy future ...
[13:20:52.714] Packages needed by the future expression (n = 0): <none>
[13:20:52.715] Packages needed by future strategies (n = 0): <none>
[13:20:52.715] {
[13:20:52.715]     {
[13:20:52.715]         {
[13:20:52.715]             ...future.startTime <- base::Sys.time()
[13:20:52.715]             {
[13:20:52.715]                 {
[13:20:52.715]                   {
[13:20:52.715]                     {
[13:20:52.715]                       base::local({
[13:20:52.715]                         has_future <- base::requireNamespace("future", 
[13:20:52.715]                           quietly = TRUE)
[13:20:52.715]                         if (has_future) {
[13:20:52.715]                           ns <- base::getNamespace("future")
[13:20:52.715]                           version <- ns[[".package"]][["version"]]
[13:20:52.715]                           if (is.null(version)) 
[13:20:52.715]                             version <- utils::packageVersion("future")
[13:20:52.715]                         }
[13:20:52.715]                         else {
[13:20:52.715]                           version <- NULL
[13:20:52.715]                         }
[13:20:52.715]                         if (!has_future || version < "1.8.0") {
[13:20:52.715]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:52.715]                             "", base::R.version$version.string), 
[13:20:52.715]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:52.715]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:52.715]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:52.715]                               "release", "version")], collapse = " "), 
[13:20:52.715]                             hostname = base::Sys.info()[["nodename"]])
[13:20:52.715]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:52.715]                             info)
[13:20:52.715]                           info <- base::paste(info, collapse = "; ")
[13:20:52.715]                           if (!has_future) {
[13:20:52.715]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:52.715]                               info)
[13:20:52.715]                           }
[13:20:52.715]                           else {
[13:20:52.715]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:52.715]                               info, version)
[13:20:52.715]                           }
[13:20:52.715]                           base::stop(msg)
[13:20:52.715]                         }
[13:20:52.715]                       })
[13:20:52.715]                     }
[13:20:52.715]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:52.715]                     base::options(mc.cores = 1L)
[13:20:52.715]                   }
[13:20:52.715]                   options(future.plan = NULL)
[13:20:52.715]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:52.715]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:52.715]                 }
[13:20:52.715]                 ...future.workdir <- getwd()
[13:20:52.715]             }
[13:20:52.715]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:52.715]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:52.715]         }
[13:20:52.715]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:52.715]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:52.715]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:52.715]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:52.715]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:52.715]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:52.715]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:52.715]             base::names(...future.oldOptions))
[13:20:52.715]     }
[13:20:52.715]     if (FALSE) {
[13:20:52.715]     }
[13:20:52.715]     else {
[13:20:52.715]         if (TRUE) {
[13:20:52.715]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:52.715]                 open = "w")
[13:20:52.715]         }
[13:20:52.715]         else {
[13:20:52.715]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:52.715]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:52.715]         }
[13:20:52.715]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:52.715]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:52.715]             base::sink(type = "output", split = FALSE)
[13:20:52.715]             base::close(...future.stdout)
[13:20:52.715]         }, add = TRUE)
[13:20:52.715]     }
[13:20:52.715]     ...future.frame <- base::sys.nframe()
[13:20:52.715]     ...future.conditions <- base::list()
[13:20:52.715]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:52.715]     if (FALSE) {
[13:20:52.715]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:52.715]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:52.715]     }
[13:20:52.715]     ...future.result <- base::tryCatch({
[13:20:52.715]         base::withCallingHandlers({
[13:20:52.715]             ...future.value <- base::withVisible(base::local({
[13:20:52.715]                 ...future.makeSendCondition <- local({
[13:20:52.715]                   sendCondition <- NULL
[13:20:52.715]                   function(frame = 1L) {
[13:20:52.715]                     if (is.function(sendCondition)) 
[13:20:52.715]                       return(sendCondition)
[13:20:52.715]                     ns <- getNamespace("parallel")
[13:20:52.715]                     if (exists("sendData", mode = "function", 
[13:20:52.715]                       envir = ns)) {
[13:20:52.715]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:52.715]                         envir = ns)
[13:20:52.715]                       envir <- sys.frame(frame)
[13:20:52.715]                       master <- NULL
[13:20:52.715]                       while (!identical(envir, .GlobalEnv) && 
[13:20:52.715]                         !identical(envir, emptyenv())) {
[13:20:52.715]                         if (exists("master", mode = "list", envir = envir, 
[13:20:52.715]                           inherits = FALSE)) {
[13:20:52.715]                           master <- get("master", mode = "list", 
[13:20:52.715]                             envir = envir, inherits = FALSE)
[13:20:52.715]                           if (inherits(master, c("SOCKnode", 
[13:20:52.715]                             "SOCK0node"))) {
[13:20:52.715]                             sendCondition <<- function(cond) {
[13:20:52.715]                               data <- list(type = "VALUE", value = cond, 
[13:20:52.715]                                 success = TRUE)
[13:20:52.715]                               parallel_sendData(master, data)
[13:20:52.715]                             }
[13:20:52.715]                             return(sendCondition)
[13:20:52.715]                           }
[13:20:52.715]                         }
[13:20:52.715]                         frame <- frame + 1L
[13:20:52.715]                         envir <- sys.frame(frame)
[13:20:52.715]                       }
[13:20:52.715]                     }
[13:20:52.715]                     sendCondition <<- function(cond) NULL
[13:20:52.715]                   }
[13:20:52.715]                 })
[13:20:52.715]                 withCallingHandlers({
[13:20:52.715]                   {
[13:20:52.715]                     b <- a
[13:20:52.715]                     a <- 2
[13:20:52.715]                     a * b
[13:20:52.715]                   }
[13:20:52.715]                 }, immediateCondition = function(cond) {
[13:20:52.715]                   sendCondition <- ...future.makeSendCondition()
[13:20:52.715]                   sendCondition(cond)
[13:20:52.715]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:52.715]                   {
[13:20:52.715]                     inherits <- base::inherits
[13:20:52.715]                     invokeRestart <- base::invokeRestart
[13:20:52.715]                     is.null <- base::is.null
[13:20:52.715]                     muffled <- FALSE
[13:20:52.715]                     if (inherits(cond, "message")) {
[13:20:52.715]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:52.715]                       if (muffled) 
[13:20:52.715]                         invokeRestart("muffleMessage")
[13:20:52.715]                     }
[13:20:52.715]                     else if (inherits(cond, "warning")) {
[13:20:52.715]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:52.715]                       if (muffled) 
[13:20:52.715]                         invokeRestart("muffleWarning")
[13:20:52.715]                     }
[13:20:52.715]                     else if (inherits(cond, "condition")) {
[13:20:52.715]                       if (!is.null(pattern)) {
[13:20:52.715]                         computeRestarts <- base::computeRestarts
[13:20:52.715]                         grepl <- base::grepl
[13:20:52.715]                         restarts <- computeRestarts(cond)
[13:20:52.715]                         for (restart in restarts) {
[13:20:52.715]                           name <- restart$name
[13:20:52.715]                           if (is.null(name)) 
[13:20:52.715]                             next
[13:20:52.715]                           if (!grepl(pattern, name)) 
[13:20:52.715]                             next
[13:20:52.715]                           invokeRestart(restart)
[13:20:52.715]                           muffled <- TRUE
[13:20:52.715]                           break
[13:20:52.715]                         }
[13:20:52.715]                       }
[13:20:52.715]                     }
[13:20:52.715]                     invisible(muffled)
[13:20:52.715]                   }
[13:20:52.715]                   muffleCondition(cond)
[13:20:52.715]                 })
[13:20:52.715]             }))
[13:20:52.715]             future::FutureResult(value = ...future.value$value, 
[13:20:52.715]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:52.715]                   ...future.rng), globalenv = if (FALSE) 
[13:20:52.715]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:52.715]                     ...future.globalenv.names))
[13:20:52.715]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:52.715]         }, condition = base::local({
[13:20:52.715]             c <- base::c
[13:20:52.715]             inherits <- base::inherits
[13:20:52.715]             invokeRestart <- base::invokeRestart
[13:20:52.715]             length <- base::length
[13:20:52.715]             list <- base::list
[13:20:52.715]             seq.int <- base::seq.int
[13:20:52.715]             signalCondition <- base::signalCondition
[13:20:52.715]             sys.calls <- base::sys.calls
[13:20:52.715]             `[[` <- base::`[[`
[13:20:52.715]             `+` <- base::`+`
[13:20:52.715]             `<<-` <- base::`<<-`
[13:20:52.715]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:52.715]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:52.715]                   3L)]
[13:20:52.715]             }
[13:20:52.715]             function(cond) {
[13:20:52.715]                 is_error <- inherits(cond, "error")
[13:20:52.715]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:52.715]                   NULL)
[13:20:52.715]                 if (is_error) {
[13:20:52.715]                   sessionInformation <- function() {
[13:20:52.715]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:52.715]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:52.715]                       search = base::search(), system = base::Sys.info())
[13:20:52.715]                   }
[13:20:52.715]                   ...future.conditions[[length(...future.conditions) + 
[13:20:52.715]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:52.715]                     cond$call), session = sessionInformation(), 
[13:20:52.715]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:52.715]                   signalCondition(cond)
[13:20:52.715]                 }
[13:20:52.715]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:52.715]                 "immediateCondition"))) {
[13:20:52.715]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:52.715]                   ...future.conditions[[length(...future.conditions) + 
[13:20:52.715]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:52.715]                   if (TRUE && !signal) {
[13:20:52.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:52.715]                     {
[13:20:52.715]                       inherits <- base::inherits
[13:20:52.715]                       invokeRestart <- base::invokeRestart
[13:20:52.715]                       is.null <- base::is.null
[13:20:52.715]                       muffled <- FALSE
[13:20:52.715]                       if (inherits(cond, "message")) {
[13:20:52.715]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:52.715]                         if (muffled) 
[13:20:52.715]                           invokeRestart("muffleMessage")
[13:20:52.715]                       }
[13:20:52.715]                       else if (inherits(cond, "warning")) {
[13:20:52.715]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:52.715]                         if (muffled) 
[13:20:52.715]                           invokeRestart("muffleWarning")
[13:20:52.715]                       }
[13:20:52.715]                       else if (inherits(cond, "condition")) {
[13:20:52.715]                         if (!is.null(pattern)) {
[13:20:52.715]                           computeRestarts <- base::computeRestarts
[13:20:52.715]                           grepl <- base::grepl
[13:20:52.715]                           restarts <- computeRestarts(cond)
[13:20:52.715]                           for (restart in restarts) {
[13:20:52.715]                             name <- restart$name
[13:20:52.715]                             if (is.null(name)) 
[13:20:52.715]                               next
[13:20:52.715]                             if (!grepl(pattern, name)) 
[13:20:52.715]                               next
[13:20:52.715]                             invokeRestart(restart)
[13:20:52.715]                             muffled <- TRUE
[13:20:52.715]                             break
[13:20:52.715]                           }
[13:20:52.715]                         }
[13:20:52.715]                       }
[13:20:52.715]                       invisible(muffled)
[13:20:52.715]                     }
[13:20:52.715]                     muffleCondition(cond, pattern = "^muffle")
[13:20:52.715]                   }
[13:20:52.715]                 }
[13:20:52.715]                 else {
[13:20:52.715]                   if (TRUE) {
[13:20:52.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:52.715]                     {
[13:20:52.715]                       inherits <- base::inherits
[13:20:52.715]                       invokeRestart <- base::invokeRestart
[13:20:52.715]                       is.null <- base::is.null
[13:20:52.715]                       muffled <- FALSE
[13:20:52.715]                       if (inherits(cond, "message")) {
[13:20:52.715]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:52.715]                         if (muffled) 
[13:20:52.715]                           invokeRestart("muffleMessage")
[13:20:52.715]                       }
[13:20:52.715]                       else if (inherits(cond, "warning")) {
[13:20:52.715]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:52.715]                         if (muffled) 
[13:20:52.715]                           invokeRestart("muffleWarning")
[13:20:52.715]                       }
[13:20:52.715]                       else if (inherits(cond, "condition")) {
[13:20:52.715]                         if (!is.null(pattern)) {
[13:20:52.715]                           computeRestarts <- base::computeRestarts
[13:20:52.715]                           grepl <- base::grepl
[13:20:52.715]                           restarts <- computeRestarts(cond)
[13:20:52.715]                           for (restart in restarts) {
[13:20:52.715]                             name <- restart$name
[13:20:52.715]                             if (is.null(name)) 
[13:20:52.715]                               next
[13:20:52.715]                             if (!grepl(pattern, name)) 
[13:20:52.715]                               next
[13:20:52.715]                             invokeRestart(restart)
[13:20:52.715]                             muffled <- TRUE
[13:20:52.715]                             break
[13:20:52.715]                           }
[13:20:52.715]                         }
[13:20:52.715]                       }
[13:20:52.715]                       invisible(muffled)
[13:20:52.715]                     }
[13:20:52.715]                     muffleCondition(cond, pattern = "^muffle")
[13:20:52.715]                   }
[13:20:52.715]                 }
[13:20:52.715]             }
[13:20:52.715]         }))
[13:20:52.715]     }, error = function(ex) {
[13:20:52.715]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:52.715]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:52.715]                 ...future.rng), started = ...future.startTime, 
[13:20:52.715]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:52.715]             version = "1.8"), class = "FutureResult")
[13:20:52.715]     }, finally = {
[13:20:52.715]         if (!identical(...future.workdir, getwd())) 
[13:20:52.715]             setwd(...future.workdir)
[13:20:52.715]         {
[13:20:52.715]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:52.715]                 ...future.oldOptions$nwarnings <- NULL
[13:20:52.715]             }
[13:20:52.715]             base::options(...future.oldOptions)
[13:20:52.715]             if (.Platform$OS.type == "windows") {
[13:20:52.715]                 old_names <- names(...future.oldEnvVars)
[13:20:52.715]                 envs <- base::Sys.getenv()
[13:20:52.715]                 names <- names(envs)
[13:20:52.715]                 common <- intersect(names, old_names)
[13:20:52.715]                 added <- setdiff(names, old_names)
[13:20:52.715]                 removed <- setdiff(old_names, names)
[13:20:52.715]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:52.715]                   envs[common]]
[13:20:52.715]                 NAMES <- toupper(changed)
[13:20:52.715]                 args <- list()
[13:20:52.715]                 for (kk in seq_along(NAMES)) {
[13:20:52.715]                   name <- changed[[kk]]
[13:20:52.715]                   NAME <- NAMES[[kk]]
[13:20:52.715]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:52.715]                     next
[13:20:52.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:52.715]                 }
[13:20:52.715]                 NAMES <- toupper(added)
[13:20:52.715]                 for (kk in seq_along(NAMES)) {
[13:20:52.715]                   name <- added[[kk]]
[13:20:52.715]                   NAME <- NAMES[[kk]]
[13:20:52.715]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:52.715]                     next
[13:20:52.715]                   args[[name]] <- ""
[13:20:52.715]                 }
[13:20:52.715]                 NAMES <- toupper(removed)
[13:20:52.715]                 for (kk in seq_along(NAMES)) {
[13:20:52.715]                   name <- removed[[kk]]
[13:20:52.715]                   NAME <- NAMES[[kk]]
[13:20:52.715]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:52.715]                     next
[13:20:52.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:52.715]                 }
[13:20:52.715]                 if (length(args) > 0) 
[13:20:52.715]                   base::do.call(base::Sys.setenv, args = args)
[13:20:52.715]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:52.715]             }
[13:20:52.715]             else {
[13:20:52.715]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:52.715]             }
[13:20:52.715]             {
[13:20:52.715]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:52.715]                   0L) {
[13:20:52.715]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:52.715]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:52.715]                   base::options(opts)
[13:20:52.715]                 }
[13:20:52.715]                 {
[13:20:52.715]                   {
[13:20:52.715]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:52.715]                     NULL
[13:20:52.715]                   }
[13:20:52.715]                   options(future.plan = NULL)
[13:20:52.715]                   if (is.na(NA_character_)) 
[13:20:52.715]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:52.715]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:52.715]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:52.715]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:52.715]                     envir = parent.frame()) 
[13:20:52.715]                   {
[13:20:52.715]                     if (is.function(workers)) 
[13:20:52.715]                       workers <- workers()
[13:20:52.715]                     workers <- structure(as.integer(workers), 
[13:20:52.715]                       class = class(workers))
[13:20:52.715]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:52.715]                       workers >= 1)
[13:20:52.715]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:52.715]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:52.715]                     }
[13:20:52.715]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:52.715]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:52.715]                       envir = envir)
[13:20:52.715]                     if (!future$lazy) 
[13:20:52.715]                       future <- run(future)
[13:20:52.715]                     invisible(future)
[13:20:52.715]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:52.715]                 }
[13:20:52.715]             }
[13:20:52.715]         }
[13:20:52.715]     })
[13:20:52.715]     if (TRUE) {
[13:20:52.715]         base::sink(type = "output", split = FALSE)
[13:20:52.715]         if (TRUE) {
[13:20:52.715]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:52.715]         }
[13:20:52.715]         else {
[13:20:52.715]             ...future.result["stdout"] <- base::list(NULL)
[13:20:52.715]         }
[13:20:52.715]         base::close(...future.stdout)
[13:20:52.715]         ...future.stdout <- NULL
[13:20:52.715]     }
[13:20:52.715]     ...future.result$conditions <- ...future.conditions
[13:20:52.715]     ...future.result$finished <- base::Sys.time()
[13:20:52.715]     ...future.result
[13:20:52.715] }
[13:20:52.719] MultisessionFuture started
[13:20:52.719] - Launch lazy future ... done
[13:20:52.719] run() for ‘MultisessionFuture’ ... done
[13:20:52.719] result() for ClusterFuture ...
[13:20:52.719] receiveMessageFromWorker() for ClusterFuture ...
[13:20:52.720] - Validating connection of MultisessionFuture
[13:20:52.767] - received message: FutureResult
[13:20:52.767] - Received FutureResult
[13:20:52.767] - Erased future from FutureRegistry
[13:20:52.767] result() for ClusterFuture ...
[13:20:52.767] - result already collected: FutureResult
[13:20:52.768] result() for ClusterFuture ... done
[13:20:52.768] signalConditions() ...
[13:20:52.768]  - include = ‘immediateCondition’
[13:20:52.768]  - exclude = 
[13:20:52.768]  - resignal = FALSE
[13:20:52.768]  - Number of conditions: 1
[13:20:52.768] signalConditions() ... done
[13:20:52.768] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:52.769] result() for ClusterFuture ... done
[13:20:52.769] result() for ClusterFuture ...
[13:20:52.769] - result already collected: FutureResult
[13:20:52.769] result() for ClusterFuture ... done
[13:20:52.769] signalConditions() ...
[13:20:52.769]  - include = ‘immediateCondition’
[13:20:52.769]  - exclude = 
[13:20:52.769]  - resignal = FALSE
[13:20:52.769]  - Number of conditions: 1
[13:20:52.770] signalConditions() ... done
[13:20:52.770] Future state: ‘finished’
[13:20:52.770] result() for ClusterFuture ...
[13:20:52.770] - result already collected: FutureResult
[13:20:52.770] result() for ClusterFuture ... done
[13:20:52.770] signalConditions() ...
[13:20:52.770]  - include = ‘condition’
[13:20:52.770]  - exclude = ‘immediateCondition’
[13:20:52.771]  - resignal = TRUE
[13:20:52.771]  - Number of conditions: 1
[13:20:52.771]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:52.771] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "5853cd8d1af0" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:20:52"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:52.788] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:52.789] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:52.790] - globals found: [3] ‘{’, ‘<-’, ‘*’
[13:20:52.791] Searching for globals ... DONE
[13:20:52.791] Resolving globals: TRUE
[13:20:52.791] Resolving any globals that are futures ...
[13:20:52.791] - globals: [3] ‘{’, ‘<-’, ‘*’
[13:20:52.791] Resolving any globals that are futures ... DONE
[13:20:52.792] 
[13:20:52.792] 
[13:20:52.792] getGlobalsAndPackages() ... DONE
[13:20:52.792] run() for ‘Future’ ...
[13:20:52.792] - state: ‘created’
[13:20:52.792] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:52.808] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:52.808] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:52.808]   - Field: ‘node’
[13:20:52.809]   - Field: ‘label’
[13:20:52.809]   - Field: ‘local’
[13:20:52.809]   - Field: ‘owner’
[13:20:52.809]   - Field: ‘envir’
[13:20:52.809]   - Field: ‘workers’
[13:20:52.809]   - Field: ‘packages’
[13:20:52.809]   - Field: ‘gc’
[13:20:52.809]   - Field: ‘conditions’
[13:20:52.809]   - Field: ‘persistent’
[13:20:52.810]   - Field: ‘expr’
[13:20:52.810]   - Field: ‘uuid’
[13:20:52.810]   - Field: ‘seed’
[13:20:52.810]   - Field: ‘version’
[13:20:52.810]   - Field: ‘result’
[13:20:52.810]   - Field: ‘asynchronous’
[13:20:52.810]   - Field: ‘calls’
[13:20:52.810]   - Field: ‘globals’
[13:20:52.811]   - Field: ‘stdout’
[13:20:52.811]   - Field: ‘earlySignal’
[13:20:52.811]   - Field: ‘lazy’
[13:20:52.811]   - Field: ‘state’
[13:20:52.811] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:52.811] - Launch lazy future ...
[13:20:52.812] Packages needed by the future expression (n = 0): <none>
[13:20:52.812] Packages needed by future strategies (n = 0): <none>
[13:20:52.812] {
[13:20:52.812]     {
[13:20:52.812]         {
[13:20:52.812]             ...future.startTime <- base::Sys.time()
[13:20:52.812]             {
[13:20:52.812]                 {
[13:20:52.812]                   {
[13:20:52.812]                     {
[13:20:52.812]                       base::local({
[13:20:52.812]                         has_future <- base::requireNamespace("future", 
[13:20:52.812]                           quietly = TRUE)
[13:20:52.812]                         if (has_future) {
[13:20:52.812]                           ns <- base::getNamespace("future")
[13:20:52.812]                           version <- ns[[".package"]][["version"]]
[13:20:52.812]                           if (is.null(version)) 
[13:20:52.812]                             version <- utils::packageVersion("future")
[13:20:52.812]                         }
[13:20:52.812]                         else {
[13:20:52.812]                           version <- NULL
[13:20:52.812]                         }
[13:20:52.812]                         if (!has_future || version < "1.8.0") {
[13:20:52.812]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:52.812]                             "", base::R.version$version.string), 
[13:20:52.812]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:52.812]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:52.812]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:52.812]                               "release", "version")], collapse = " "), 
[13:20:52.812]                             hostname = base::Sys.info()[["nodename"]])
[13:20:52.812]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:52.812]                             info)
[13:20:52.812]                           info <- base::paste(info, collapse = "; ")
[13:20:52.812]                           if (!has_future) {
[13:20:52.812]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:52.812]                               info)
[13:20:52.812]                           }
[13:20:52.812]                           else {
[13:20:52.812]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:52.812]                               info, version)
[13:20:52.812]                           }
[13:20:52.812]                           base::stop(msg)
[13:20:52.812]                         }
[13:20:52.812]                       })
[13:20:52.812]                     }
[13:20:52.812]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:52.812]                     base::options(mc.cores = 1L)
[13:20:52.812]                   }
[13:20:52.812]                   options(future.plan = NULL)
[13:20:52.812]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:52.812]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:52.812]                 }
[13:20:52.812]                 ...future.workdir <- getwd()
[13:20:52.812]             }
[13:20:52.812]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:52.812]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:52.812]         }
[13:20:52.812]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:52.812]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:52.812]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:52.812]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:52.812]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:52.812]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:52.812]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:52.812]             base::names(...future.oldOptions))
[13:20:52.812]     }
[13:20:52.812]     if (FALSE) {
[13:20:52.812]     }
[13:20:52.812]     else {
[13:20:52.812]         if (TRUE) {
[13:20:52.812]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:52.812]                 open = "w")
[13:20:52.812]         }
[13:20:52.812]         else {
[13:20:52.812]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:52.812]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:52.812]         }
[13:20:52.812]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:52.812]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:52.812]             base::sink(type = "output", split = FALSE)
[13:20:52.812]             base::close(...future.stdout)
[13:20:52.812]         }, add = TRUE)
[13:20:52.812]     }
[13:20:52.812]     ...future.frame <- base::sys.nframe()
[13:20:52.812]     ...future.conditions <- base::list()
[13:20:52.812]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:52.812]     if (FALSE) {
[13:20:52.812]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:52.812]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:52.812]     }
[13:20:52.812]     ...future.result <- base::tryCatch({
[13:20:52.812]         base::withCallingHandlers({
[13:20:52.812]             ...future.value <- base::withVisible(base::local({
[13:20:52.812]                 ...future.makeSendCondition <- local({
[13:20:52.812]                   sendCondition <- NULL
[13:20:52.812]                   function(frame = 1L) {
[13:20:52.812]                     if (is.function(sendCondition)) 
[13:20:52.812]                       return(sendCondition)
[13:20:52.812]                     ns <- getNamespace("parallel")
[13:20:52.812]                     if (exists("sendData", mode = "function", 
[13:20:52.812]                       envir = ns)) {
[13:20:52.812]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:52.812]                         envir = ns)
[13:20:52.812]                       envir <- sys.frame(frame)
[13:20:52.812]                       master <- NULL
[13:20:52.812]                       while (!identical(envir, .GlobalEnv) && 
[13:20:52.812]                         !identical(envir, emptyenv())) {
[13:20:52.812]                         if (exists("master", mode = "list", envir = envir, 
[13:20:52.812]                           inherits = FALSE)) {
[13:20:52.812]                           master <- get("master", mode = "list", 
[13:20:52.812]                             envir = envir, inherits = FALSE)
[13:20:52.812]                           if (inherits(master, c("SOCKnode", 
[13:20:52.812]                             "SOCK0node"))) {
[13:20:52.812]                             sendCondition <<- function(cond) {
[13:20:52.812]                               data <- list(type = "VALUE", value = cond, 
[13:20:52.812]                                 success = TRUE)
[13:20:52.812]                               parallel_sendData(master, data)
[13:20:52.812]                             }
[13:20:52.812]                             return(sendCondition)
[13:20:52.812]                           }
[13:20:52.812]                         }
[13:20:52.812]                         frame <- frame + 1L
[13:20:52.812]                         envir <- sys.frame(frame)
[13:20:52.812]                       }
[13:20:52.812]                     }
[13:20:52.812]                     sendCondition <<- function(cond) NULL
[13:20:52.812]                   }
[13:20:52.812]                 })
[13:20:52.812]                 withCallingHandlers({
[13:20:52.812]                   {
[13:20:52.812]                     b <- a
[13:20:52.812]                     a <- 2
[13:20:52.812]                     a * b
[13:20:52.812]                   }
[13:20:52.812]                 }, immediateCondition = function(cond) {
[13:20:52.812]                   sendCondition <- ...future.makeSendCondition()
[13:20:52.812]                   sendCondition(cond)
[13:20:52.812]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:52.812]                   {
[13:20:52.812]                     inherits <- base::inherits
[13:20:52.812]                     invokeRestart <- base::invokeRestart
[13:20:52.812]                     is.null <- base::is.null
[13:20:52.812]                     muffled <- FALSE
[13:20:52.812]                     if (inherits(cond, "message")) {
[13:20:52.812]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:52.812]                       if (muffled) 
[13:20:52.812]                         invokeRestart("muffleMessage")
[13:20:52.812]                     }
[13:20:52.812]                     else if (inherits(cond, "warning")) {
[13:20:52.812]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:52.812]                       if (muffled) 
[13:20:52.812]                         invokeRestart("muffleWarning")
[13:20:52.812]                     }
[13:20:52.812]                     else if (inherits(cond, "condition")) {
[13:20:52.812]                       if (!is.null(pattern)) {
[13:20:52.812]                         computeRestarts <- base::computeRestarts
[13:20:52.812]                         grepl <- base::grepl
[13:20:52.812]                         restarts <- computeRestarts(cond)
[13:20:52.812]                         for (restart in restarts) {
[13:20:52.812]                           name <- restart$name
[13:20:52.812]                           if (is.null(name)) 
[13:20:52.812]                             next
[13:20:52.812]                           if (!grepl(pattern, name)) 
[13:20:52.812]                             next
[13:20:52.812]                           invokeRestart(restart)
[13:20:52.812]                           muffled <- TRUE
[13:20:52.812]                           break
[13:20:52.812]                         }
[13:20:52.812]                       }
[13:20:52.812]                     }
[13:20:52.812]                     invisible(muffled)
[13:20:52.812]                   }
[13:20:52.812]                   muffleCondition(cond)
[13:20:52.812]                 })
[13:20:52.812]             }))
[13:20:52.812]             future::FutureResult(value = ...future.value$value, 
[13:20:52.812]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:52.812]                   ...future.rng), globalenv = if (FALSE) 
[13:20:52.812]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:52.812]                     ...future.globalenv.names))
[13:20:52.812]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:52.812]         }, condition = base::local({
[13:20:52.812]             c <- base::c
[13:20:52.812]             inherits <- base::inherits
[13:20:52.812]             invokeRestart <- base::invokeRestart
[13:20:52.812]             length <- base::length
[13:20:52.812]             list <- base::list
[13:20:52.812]             seq.int <- base::seq.int
[13:20:52.812]             signalCondition <- base::signalCondition
[13:20:52.812]             sys.calls <- base::sys.calls
[13:20:52.812]             `[[` <- base::`[[`
[13:20:52.812]             `+` <- base::`+`
[13:20:52.812]             `<<-` <- base::`<<-`
[13:20:52.812]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:52.812]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:52.812]                   3L)]
[13:20:52.812]             }
[13:20:52.812]             function(cond) {
[13:20:52.812]                 is_error <- inherits(cond, "error")
[13:20:52.812]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:52.812]                   NULL)
[13:20:52.812]                 if (is_error) {
[13:20:52.812]                   sessionInformation <- function() {
[13:20:52.812]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:52.812]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:52.812]                       search = base::search(), system = base::Sys.info())
[13:20:52.812]                   }
[13:20:52.812]                   ...future.conditions[[length(...future.conditions) + 
[13:20:52.812]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:52.812]                     cond$call), session = sessionInformation(), 
[13:20:52.812]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:52.812]                   signalCondition(cond)
[13:20:52.812]                 }
[13:20:52.812]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:52.812]                 "immediateCondition"))) {
[13:20:52.812]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:52.812]                   ...future.conditions[[length(...future.conditions) + 
[13:20:52.812]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:52.812]                   if (TRUE && !signal) {
[13:20:52.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:52.812]                     {
[13:20:52.812]                       inherits <- base::inherits
[13:20:52.812]                       invokeRestart <- base::invokeRestart
[13:20:52.812]                       is.null <- base::is.null
[13:20:52.812]                       muffled <- FALSE
[13:20:52.812]                       if (inherits(cond, "message")) {
[13:20:52.812]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:52.812]                         if (muffled) 
[13:20:52.812]                           invokeRestart("muffleMessage")
[13:20:52.812]                       }
[13:20:52.812]                       else if (inherits(cond, "warning")) {
[13:20:52.812]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:52.812]                         if (muffled) 
[13:20:52.812]                           invokeRestart("muffleWarning")
[13:20:52.812]                       }
[13:20:52.812]                       else if (inherits(cond, "condition")) {
[13:20:52.812]                         if (!is.null(pattern)) {
[13:20:52.812]                           computeRestarts <- base::computeRestarts
[13:20:52.812]                           grepl <- base::grepl
[13:20:52.812]                           restarts <- computeRestarts(cond)
[13:20:52.812]                           for (restart in restarts) {
[13:20:52.812]                             name <- restart$name
[13:20:52.812]                             if (is.null(name)) 
[13:20:52.812]                               next
[13:20:52.812]                             if (!grepl(pattern, name)) 
[13:20:52.812]                               next
[13:20:52.812]                             invokeRestart(restart)
[13:20:52.812]                             muffled <- TRUE
[13:20:52.812]                             break
[13:20:52.812]                           }
[13:20:52.812]                         }
[13:20:52.812]                       }
[13:20:52.812]                       invisible(muffled)
[13:20:52.812]                     }
[13:20:52.812]                     muffleCondition(cond, pattern = "^muffle")
[13:20:52.812]                   }
[13:20:52.812]                 }
[13:20:52.812]                 else {
[13:20:52.812]                   if (TRUE) {
[13:20:52.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:52.812]                     {
[13:20:52.812]                       inherits <- base::inherits
[13:20:52.812]                       invokeRestart <- base::invokeRestart
[13:20:52.812]                       is.null <- base::is.null
[13:20:52.812]                       muffled <- FALSE
[13:20:52.812]                       if (inherits(cond, "message")) {
[13:20:52.812]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:52.812]                         if (muffled) 
[13:20:52.812]                           invokeRestart("muffleMessage")
[13:20:52.812]                       }
[13:20:52.812]                       else if (inherits(cond, "warning")) {
[13:20:52.812]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:52.812]                         if (muffled) 
[13:20:52.812]                           invokeRestart("muffleWarning")
[13:20:52.812]                       }
[13:20:52.812]                       else if (inherits(cond, "condition")) {
[13:20:52.812]                         if (!is.null(pattern)) {
[13:20:52.812]                           computeRestarts <- base::computeRestarts
[13:20:52.812]                           grepl <- base::grepl
[13:20:52.812]                           restarts <- computeRestarts(cond)
[13:20:52.812]                           for (restart in restarts) {
[13:20:52.812]                             name <- restart$name
[13:20:52.812]                             if (is.null(name)) 
[13:20:52.812]                               next
[13:20:52.812]                             if (!grepl(pattern, name)) 
[13:20:52.812]                               next
[13:20:52.812]                             invokeRestart(restart)
[13:20:52.812]                             muffled <- TRUE
[13:20:52.812]                             break
[13:20:52.812]                           }
[13:20:52.812]                         }
[13:20:52.812]                       }
[13:20:52.812]                       invisible(muffled)
[13:20:52.812]                     }
[13:20:52.812]                     muffleCondition(cond, pattern = "^muffle")
[13:20:52.812]                   }
[13:20:52.812]                 }
[13:20:52.812]             }
[13:20:52.812]         }))
[13:20:52.812]     }, error = function(ex) {
[13:20:52.812]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:52.812]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:52.812]                 ...future.rng), started = ...future.startTime, 
[13:20:52.812]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:52.812]             version = "1.8"), class = "FutureResult")
[13:20:52.812]     }, finally = {
[13:20:52.812]         if (!identical(...future.workdir, getwd())) 
[13:20:52.812]             setwd(...future.workdir)
[13:20:52.812]         {
[13:20:52.812]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:52.812]                 ...future.oldOptions$nwarnings <- NULL
[13:20:52.812]             }
[13:20:52.812]             base::options(...future.oldOptions)
[13:20:52.812]             if (.Platform$OS.type == "windows") {
[13:20:52.812]                 old_names <- names(...future.oldEnvVars)
[13:20:52.812]                 envs <- base::Sys.getenv()
[13:20:52.812]                 names <- names(envs)
[13:20:52.812]                 common <- intersect(names, old_names)
[13:20:52.812]                 added <- setdiff(names, old_names)
[13:20:52.812]                 removed <- setdiff(old_names, names)
[13:20:52.812]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:52.812]                   envs[common]]
[13:20:52.812]                 NAMES <- toupper(changed)
[13:20:52.812]                 args <- list()
[13:20:52.812]                 for (kk in seq_along(NAMES)) {
[13:20:52.812]                   name <- changed[[kk]]
[13:20:52.812]                   NAME <- NAMES[[kk]]
[13:20:52.812]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:52.812]                     next
[13:20:52.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:52.812]                 }
[13:20:52.812]                 NAMES <- toupper(added)
[13:20:52.812]                 for (kk in seq_along(NAMES)) {
[13:20:52.812]                   name <- added[[kk]]
[13:20:52.812]                   NAME <- NAMES[[kk]]
[13:20:52.812]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:52.812]                     next
[13:20:52.812]                   args[[name]] <- ""
[13:20:52.812]                 }
[13:20:52.812]                 NAMES <- toupper(removed)
[13:20:52.812]                 for (kk in seq_along(NAMES)) {
[13:20:52.812]                   name <- removed[[kk]]
[13:20:52.812]                   NAME <- NAMES[[kk]]
[13:20:52.812]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:52.812]                     next
[13:20:52.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:52.812]                 }
[13:20:52.812]                 if (length(args) > 0) 
[13:20:52.812]                   base::do.call(base::Sys.setenv, args = args)
[13:20:52.812]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:52.812]             }
[13:20:52.812]             else {
[13:20:52.812]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:52.812]             }
[13:20:52.812]             {
[13:20:52.812]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:52.812]                   0L) {
[13:20:52.812]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:52.812]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:52.812]                   base::options(opts)
[13:20:52.812]                 }
[13:20:52.812]                 {
[13:20:52.812]                   {
[13:20:52.812]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:52.812]                     NULL
[13:20:52.812]                   }
[13:20:52.812]                   options(future.plan = NULL)
[13:20:52.812]                   if (is.na(NA_character_)) 
[13:20:52.812]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:52.812]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:52.812]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:52.812]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:52.812]                     envir = parent.frame()) 
[13:20:52.812]                   {
[13:20:52.812]                     if (is.function(workers)) 
[13:20:52.812]                       workers <- workers()
[13:20:52.812]                     workers <- structure(as.integer(workers), 
[13:20:52.812]                       class = class(workers))
[13:20:52.812]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:52.812]                       workers >= 1)
[13:20:52.812]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:52.812]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:52.812]                     }
[13:20:52.812]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:52.812]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:52.812]                       envir = envir)
[13:20:52.812]                     if (!future$lazy) 
[13:20:52.812]                       future <- run(future)
[13:20:52.812]                     invisible(future)
[13:20:52.812]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:52.812]                 }
[13:20:52.812]             }
[13:20:52.812]         }
[13:20:52.812]     })
[13:20:52.812]     if (TRUE) {
[13:20:52.812]         base::sink(type = "output", split = FALSE)
[13:20:52.812]         if (TRUE) {
[13:20:52.812]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:52.812]         }
[13:20:52.812]         else {
[13:20:52.812]             ...future.result["stdout"] <- base::list(NULL)
[13:20:52.812]         }
[13:20:52.812]         base::close(...future.stdout)
[13:20:52.812]         ...future.stdout <- NULL
[13:20:52.812]     }
[13:20:52.812]     ...future.result$conditions <- ...future.conditions
[13:20:52.812]     ...future.result$finished <- base::Sys.time()
[13:20:52.812]     ...future.result
[13:20:52.812] }
[13:20:52.818] MultisessionFuture started
[13:20:52.818] - Launch lazy future ... done
[13:20:52.818] run() for ‘MultisessionFuture’ ... done
[13:20:52.819] result() for ClusterFuture ...
[13:20:52.819] receiveMessageFromWorker() for ClusterFuture ...
[13:20:52.819] - Validating connection of MultisessionFuture
[13:20:52.866] - received message: FutureResult
[13:20:52.866] - Received FutureResult
[13:20:52.866] - Erased future from FutureRegistry
[13:20:52.867] result() for ClusterFuture ...
[13:20:52.867] - result already collected: FutureResult
[13:20:52.867] result() for ClusterFuture ... done
[13:20:52.867] signalConditions() ...
[13:20:52.867]  - include = ‘immediateCondition’
[13:20:52.867]  - exclude = 
[13:20:52.867]  - resignal = FALSE
[13:20:52.867]  - Number of conditions: 1
[13:20:52.867] signalConditions() ... done
[13:20:52.867] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:52.867] result() for ClusterFuture ... done
[13:20:52.868] result() for ClusterFuture ...
[13:20:52.868] - result already collected: FutureResult
[13:20:52.868] result() for ClusterFuture ... done
[13:20:52.868] signalConditions() ...
[13:20:52.868]  - include = ‘immediateCondition’
[13:20:52.868]  - exclude = 
[13:20:52.868]  - resignal = FALSE
[13:20:52.868]  - Number of conditions: 1
[13:20:52.868] signalConditions() ... done
[13:20:52.868] Future state: ‘finished’
[13:20:52.869] result() for ClusterFuture ...
[13:20:52.869] - result already collected: FutureResult
[13:20:52.869] result() for ClusterFuture ... done
[13:20:52.869] signalConditions() ...
[13:20:52.869]  - include = ‘condition’
[13:20:52.869]  - exclude = ‘immediateCondition’
[13:20:52.869]  - resignal = TRUE
[13:20:52.869]  - Number of conditions: 1
[13:20:52.869]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:52.869] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "5853cd8d1af0" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:20:52"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:52.884] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:52.884] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:52.885] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:52.885] Searching for globals ... DONE
[13:20:52.885] Resolving globals: TRUE
[13:20:52.886] Resolving any globals that are futures ...
[13:20:52.886] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:52.886] Resolving any globals that are futures ... DONE
[13:20:52.886] Resolving futures part of globals (recursively) ...
[13:20:52.886] resolve() on list ...
[13:20:52.886]  recursive: 99
[13:20:52.886]  length: 1
[13:20:52.887]  elements: ‘ii’
[13:20:52.887]  length: 0 (resolved future 1)
[13:20:52.887] resolve() on list ... DONE
[13:20:52.887] - globals: [1] ‘ii’
[13:20:52.887] Resolving futures part of globals (recursively) ... DONE
[13:20:52.887] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:52.887] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:52.888] - globals: [1] ‘ii’
[13:20:52.888] 
[13:20:52.888] getGlobalsAndPackages() ... DONE
[13:20:52.888] run() for ‘Future’ ...
[13:20:52.888] - state: ‘created’
[13:20:52.888] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:52.903] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:52.903] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:52.903]   - Field: ‘node’
[13:20:52.903]   - Field: ‘label’
[13:20:52.903]   - Field: ‘local’
[13:20:52.903]   - Field: ‘owner’
[13:20:52.903]   - Field: ‘envir’
[13:20:52.903]   - Field: ‘workers’
[13:20:52.904]   - Field: ‘packages’
[13:20:52.904]   - Field: ‘gc’
[13:20:52.904]   - Field: ‘conditions’
[13:20:52.904]   - Field: ‘persistent’
[13:20:52.904]   - Field: ‘expr’
[13:20:52.904]   - Field: ‘uuid’
[13:20:52.904]   - Field: ‘seed’
[13:20:52.904]   - Field: ‘version’
[13:20:52.904]   - Field: ‘result’
[13:20:52.904]   - Field: ‘asynchronous’
[13:20:52.904]   - Field: ‘calls’
[13:20:52.905]   - Field: ‘globals’
[13:20:52.905]   - Field: ‘stdout’
[13:20:52.905]   - Field: ‘earlySignal’
[13:20:52.905]   - Field: ‘lazy’
[13:20:52.905]   - Field: ‘state’
[13:20:52.905] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:52.905] - Launch lazy future ...
[13:20:52.905] Packages needed by the future expression (n = 0): <none>
[13:20:52.906] Packages needed by future strategies (n = 0): <none>
[13:20:52.906] {
[13:20:52.906]     {
[13:20:52.906]         {
[13:20:52.906]             ...future.startTime <- base::Sys.time()
[13:20:52.906]             {
[13:20:52.906]                 {
[13:20:52.906]                   {
[13:20:52.906]                     {
[13:20:52.906]                       base::local({
[13:20:52.906]                         has_future <- base::requireNamespace("future", 
[13:20:52.906]                           quietly = TRUE)
[13:20:52.906]                         if (has_future) {
[13:20:52.906]                           ns <- base::getNamespace("future")
[13:20:52.906]                           version <- ns[[".package"]][["version"]]
[13:20:52.906]                           if (is.null(version)) 
[13:20:52.906]                             version <- utils::packageVersion("future")
[13:20:52.906]                         }
[13:20:52.906]                         else {
[13:20:52.906]                           version <- NULL
[13:20:52.906]                         }
[13:20:52.906]                         if (!has_future || version < "1.8.0") {
[13:20:52.906]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:52.906]                             "", base::R.version$version.string), 
[13:20:52.906]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:52.906]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:52.906]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:52.906]                               "release", "version")], collapse = " "), 
[13:20:52.906]                             hostname = base::Sys.info()[["nodename"]])
[13:20:52.906]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:52.906]                             info)
[13:20:52.906]                           info <- base::paste(info, collapse = "; ")
[13:20:52.906]                           if (!has_future) {
[13:20:52.906]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:52.906]                               info)
[13:20:52.906]                           }
[13:20:52.906]                           else {
[13:20:52.906]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:52.906]                               info, version)
[13:20:52.906]                           }
[13:20:52.906]                           base::stop(msg)
[13:20:52.906]                         }
[13:20:52.906]                       })
[13:20:52.906]                     }
[13:20:52.906]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:52.906]                     base::options(mc.cores = 1L)
[13:20:52.906]                   }
[13:20:52.906]                   options(future.plan = NULL)
[13:20:52.906]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:52.906]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:52.906]                 }
[13:20:52.906]                 ...future.workdir <- getwd()
[13:20:52.906]             }
[13:20:52.906]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:52.906]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:52.906]         }
[13:20:52.906]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:52.906]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:52.906]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:52.906]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:52.906]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:52.906]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:52.906]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:52.906]             base::names(...future.oldOptions))
[13:20:52.906]     }
[13:20:52.906]     if (FALSE) {
[13:20:52.906]     }
[13:20:52.906]     else {
[13:20:52.906]         if (TRUE) {
[13:20:52.906]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:52.906]                 open = "w")
[13:20:52.906]         }
[13:20:52.906]         else {
[13:20:52.906]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:52.906]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:52.906]         }
[13:20:52.906]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:52.906]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:52.906]             base::sink(type = "output", split = FALSE)
[13:20:52.906]             base::close(...future.stdout)
[13:20:52.906]         }, add = TRUE)
[13:20:52.906]     }
[13:20:52.906]     ...future.frame <- base::sys.nframe()
[13:20:52.906]     ...future.conditions <- base::list()
[13:20:52.906]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:52.906]     if (FALSE) {
[13:20:52.906]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:52.906]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:52.906]     }
[13:20:52.906]     ...future.result <- base::tryCatch({
[13:20:52.906]         base::withCallingHandlers({
[13:20:52.906]             ...future.value <- base::withVisible(base::local({
[13:20:52.906]                 ...future.makeSendCondition <- local({
[13:20:52.906]                   sendCondition <- NULL
[13:20:52.906]                   function(frame = 1L) {
[13:20:52.906]                     if (is.function(sendCondition)) 
[13:20:52.906]                       return(sendCondition)
[13:20:52.906]                     ns <- getNamespace("parallel")
[13:20:52.906]                     if (exists("sendData", mode = "function", 
[13:20:52.906]                       envir = ns)) {
[13:20:52.906]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:52.906]                         envir = ns)
[13:20:52.906]                       envir <- sys.frame(frame)
[13:20:52.906]                       master <- NULL
[13:20:52.906]                       while (!identical(envir, .GlobalEnv) && 
[13:20:52.906]                         !identical(envir, emptyenv())) {
[13:20:52.906]                         if (exists("master", mode = "list", envir = envir, 
[13:20:52.906]                           inherits = FALSE)) {
[13:20:52.906]                           master <- get("master", mode = "list", 
[13:20:52.906]                             envir = envir, inherits = FALSE)
[13:20:52.906]                           if (inherits(master, c("SOCKnode", 
[13:20:52.906]                             "SOCK0node"))) {
[13:20:52.906]                             sendCondition <<- function(cond) {
[13:20:52.906]                               data <- list(type = "VALUE", value = cond, 
[13:20:52.906]                                 success = TRUE)
[13:20:52.906]                               parallel_sendData(master, data)
[13:20:52.906]                             }
[13:20:52.906]                             return(sendCondition)
[13:20:52.906]                           }
[13:20:52.906]                         }
[13:20:52.906]                         frame <- frame + 1L
[13:20:52.906]                         envir <- sys.frame(frame)
[13:20:52.906]                       }
[13:20:52.906]                     }
[13:20:52.906]                     sendCondition <<- function(cond) NULL
[13:20:52.906]                   }
[13:20:52.906]                 })
[13:20:52.906]                 withCallingHandlers({
[13:20:52.906]                   {
[13:20:52.906]                     b <- a * ii
[13:20:52.906]                     a <- 0
[13:20:52.906]                     b
[13:20:52.906]                   }
[13:20:52.906]                 }, immediateCondition = function(cond) {
[13:20:52.906]                   sendCondition <- ...future.makeSendCondition()
[13:20:52.906]                   sendCondition(cond)
[13:20:52.906]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:52.906]                   {
[13:20:52.906]                     inherits <- base::inherits
[13:20:52.906]                     invokeRestart <- base::invokeRestart
[13:20:52.906]                     is.null <- base::is.null
[13:20:52.906]                     muffled <- FALSE
[13:20:52.906]                     if (inherits(cond, "message")) {
[13:20:52.906]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:52.906]                       if (muffled) 
[13:20:52.906]                         invokeRestart("muffleMessage")
[13:20:52.906]                     }
[13:20:52.906]                     else if (inherits(cond, "warning")) {
[13:20:52.906]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:52.906]                       if (muffled) 
[13:20:52.906]                         invokeRestart("muffleWarning")
[13:20:52.906]                     }
[13:20:52.906]                     else if (inherits(cond, "condition")) {
[13:20:52.906]                       if (!is.null(pattern)) {
[13:20:52.906]                         computeRestarts <- base::computeRestarts
[13:20:52.906]                         grepl <- base::grepl
[13:20:52.906]                         restarts <- computeRestarts(cond)
[13:20:52.906]                         for (restart in restarts) {
[13:20:52.906]                           name <- restart$name
[13:20:52.906]                           if (is.null(name)) 
[13:20:52.906]                             next
[13:20:52.906]                           if (!grepl(pattern, name)) 
[13:20:52.906]                             next
[13:20:52.906]                           invokeRestart(restart)
[13:20:52.906]                           muffled <- TRUE
[13:20:52.906]                           break
[13:20:52.906]                         }
[13:20:52.906]                       }
[13:20:52.906]                     }
[13:20:52.906]                     invisible(muffled)
[13:20:52.906]                   }
[13:20:52.906]                   muffleCondition(cond)
[13:20:52.906]                 })
[13:20:52.906]             }))
[13:20:52.906]             future::FutureResult(value = ...future.value$value, 
[13:20:52.906]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:52.906]                   ...future.rng), globalenv = if (FALSE) 
[13:20:52.906]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:52.906]                     ...future.globalenv.names))
[13:20:52.906]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:52.906]         }, condition = base::local({
[13:20:52.906]             c <- base::c
[13:20:52.906]             inherits <- base::inherits
[13:20:52.906]             invokeRestart <- base::invokeRestart
[13:20:52.906]             length <- base::length
[13:20:52.906]             list <- base::list
[13:20:52.906]             seq.int <- base::seq.int
[13:20:52.906]             signalCondition <- base::signalCondition
[13:20:52.906]             sys.calls <- base::sys.calls
[13:20:52.906]             `[[` <- base::`[[`
[13:20:52.906]             `+` <- base::`+`
[13:20:52.906]             `<<-` <- base::`<<-`
[13:20:52.906]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:52.906]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:52.906]                   3L)]
[13:20:52.906]             }
[13:20:52.906]             function(cond) {
[13:20:52.906]                 is_error <- inherits(cond, "error")
[13:20:52.906]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:52.906]                   NULL)
[13:20:52.906]                 if (is_error) {
[13:20:52.906]                   sessionInformation <- function() {
[13:20:52.906]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:52.906]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:52.906]                       search = base::search(), system = base::Sys.info())
[13:20:52.906]                   }
[13:20:52.906]                   ...future.conditions[[length(...future.conditions) + 
[13:20:52.906]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:52.906]                     cond$call), session = sessionInformation(), 
[13:20:52.906]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:52.906]                   signalCondition(cond)
[13:20:52.906]                 }
[13:20:52.906]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:52.906]                 "immediateCondition"))) {
[13:20:52.906]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:52.906]                   ...future.conditions[[length(...future.conditions) + 
[13:20:52.906]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:52.906]                   if (TRUE && !signal) {
[13:20:52.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:52.906]                     {
[13:20:52.906]                       inherits <- base::inherits
[13:20:52.906]                       invokeRestart <- base::invokeRestart
[13:20:52.906]                       is.null <- base::is.null
[13:20:52.906]                       muffled <- FALSE
[13:20:52.906]                       if (inherits(cond, "message")) {
[13:20:52.906]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:52.906]                         if (muffled) 
[13:20:52.906]                           invokeRestart("muffleMessage")
[13:20:52.906]                       }
[13:20:52.906]                       else if (inherits(cond, "warning")) {
[13:20:52.906]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:52.906]                         if (muffled) 
[13:20:52.906]                           invokeRestart("muffleWarning")
[13:20:52.906]                       }
[13:20:52.906]                       else if (inherits(cond, "condition")) {
[13:20:52.906]                         if (!is.null(pattern)) {
[13:20:52.906]                           computeRestarts <- base::computeRestarts
[13:20:52.906]                           grepl <- base::grepl
[13:20:52.906]                           restarts <- computeRestarts(cond)
[13:20:52.906]                           for (restart in restarts) {
[13:20:52.906]                             name <- restart$name
[13:20:52.906]                             if (is.null(name)) 
[13:20:52.906]                               next
[13:20:52.906]                             if (!grepl(pattern, name)) 
[13:20:52.906]                               next
[13:20:52.906]                             invokeRestart(restart)
[13:20:52.906]                             muffled <- TRUE
[13:20:52.906]                             break
[13:20:52.906]                           }
[13:20:52.906]                         }
[13:20:52.906]                       }
[13:20:52.906]                       invisible(muffled)
[13:20:52.906]                     }
[13:20:52.906]                     muffleCondition(cond, pattern = "^muffle")
[13:20:52.906]                   }
[13:20:52.906]                 }
[13:20:52.906]                 else {
[13:20:52.906]                   if (TRUE) {
[13:20:52.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:52.906]                     {
[13:20:52.906]                       inherits <- base::inherits
[13:20:52.906]                       invokeRestart <- base::invokeRestart
[13:20:52.906]                       is.null <- base::is.null
[13:20:52.906]                       muffled <- FALSE
[13:20:52.906]                       if (inherits(cond, "message")) {
[13:20:52.906]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:52.906]                         if (muffled) 
[13:20:52.906]                           invokeRestart("muffleMessage")
[13:20:52.906]                       }
[13:20:52.906]                       else if (inherits(cond, "warning")) {
[13:20:52.906]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:52.906]                         if (muffled) 
[13:20:52.906]                           invokeRestart("muffleWarning")
[13:20:52.906]                       }
[13:20:52.906]                       else if (inherits(cond, "condition")) {
[13:20:52.906]                         if (!is.null(pattern)) {
[13:20:52.906]                           computeRestarts <- base::computeRestarts
[13:20:52.906]                           grepl <- base::grepl
[13:20:52.906]                           restarts <- computeRestarts(cond)
[13:20:52.906]                           for (restart in restarts) {
[13:20:52.906]                             name <- restart$name
[13:20:52.906]                             if (is.null(name)) 
[13:20:52.906]                               next
[13:20:52.906]                             if (!grepl(pattern, name)) 
[13:20:52.906]                               next
[13:20:52.906]                             invokeRestart(restart)
[13:20:52.906]                             muffled <- TRUE
[13:20:52.906]                             break
[13:20:52.906]                           }
[13:20:52.906]                         }
[13:20:52.906]                       }
[13:20:52.906]                       invisible(muffled)
[13:20:52.906]                     }
[13:20:52.906]                     muffleCondition(cond, pattern = "^muffle")
[13:20:52.906]                   }
[13:20:52.906]                 }
[13:20:52.906]             }
[13:20:52.906]         }))
[13:20:52.906]     }, error = function(ex) {
[13:20:52.906]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:52.906]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:52.906]                 ...future.rng), started = ...future.startTime, 
[13:20:52.906]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:52.906]             version = "1.8"), class = "FutureResult")
[13:20:52.906]     }, finally = {
[13:20:52.906]         if (!identical(...future.workdir, getwd())) 
[13:20:52.906]             setwd(...future.workdir)
[13:20:52.906]         {
[13:20:52.906]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:52.906]                 ...future.oldOptions$nwarnings <- NULL
[13:20:52.906]             }
[13:20:52.906]             base::options(...future.oldOptions)
[13:20:52.906]             if (.Platform$OS.type == "windows") {
[13:20:52.906]                 old_names <- names(...future.oldEnvVars)
[13:20:52.906]                 envs <- base::Sys.getenv()
[13:20:52.906]                 names <- names(envs)
[13:20:52.906]                 common <- intersect(names, old_names)
[13:20:52.906]                 added <- setdiff(names, old_names)
[13:20:52.906]                 removed <- setdiff(old_names, names)
[13:20:52.906]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:52.906]                   envs[common]]
[13:20:52.906]                 NAMES <- toupper(changed)
[13:20:52.906]                 args <- list()
[13:20:52.906]                 for (kk in seq_along(NAMES)) {
[13:20:52.906]                   name <- changed[[kk]]
[13:20:52.906]                   NAME <- NAMES[[kk]]
[13:20:52.906]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:52.906]                     next
[13:20:52.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:52.906]                 }
[13:20:52.906]                 NAMES <- toupper(added)
[13:20:52.906]                 for (kk in seq_along(NAMES)) {
[13:20:52.906]                   name <- added[[kk]]
[13:20:52.906]                   NAME <- NAMES[[kk]]
[13:20:52.906]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:52.906]                     next
[13:20:52.906]                   args[[name]] <- ""
[13:20:52.906]                 }
[13:20:52.906]                 NAMES <- toupper(removed)
[13:20:52.906]                 for (kk in seq_along(NAMES)) {
[13:20:52.906]                   name <- removed[[kk]]
[13:20:52.906]                   NAME <- NAMES[[kk]]
[13:20:52.906]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:52.906]                     next
[13:20:52.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:52.906]                 }
[13:20:52.906]                 if (length(args) > 0) 
[13:20:52.906]                   base::do.call(base::Sys.setenv, args = args)
[13:20:52.906]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:52.906]             }
[13:20:52.906]             else {
[13:20:52.906]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:52.906]             }
[13:20:52.906]             {
[13:20:52.906]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:52.906]                   0L) {
[13:20:52.906]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:52.906]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:52.906]                   base::options(opts)
[13:20:52.906]                 }
[13:20:52.906]                 {
[13:20:52.906]                   {
[13:20:52.906]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:52.906]                     NULL
[13:20:52.906]                   }
[13:20:52.906]                   options(future.plan = NULL)
[13:20:52.906]                   if (is.na(NA_character_)) 
[13:20:52.906]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:52.906]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:52.906]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:52.906]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:52.906]                     envir = parent.frame()) 
[13:20:52.906]                   {
[13:20:52.906]                     if (is.function(workers)) 
[13:20:52.906]                       workers <- workers()
[13:20:52.906]                     workers <- structure(as.integer(workers), 
[13:20:52.906]                       class = class(workers))
[13:20:52.906]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:52.906]                       workers >= 1)
[13:20:52.906]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:52.906]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:52.906]                     }
[13:20:52.906]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:52.906]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:52.906]                       envir = envir)
[13:20:52.906]                     if (!future$lazy) 
[13:20:52.906]                       future <- run(future)
[13:20:52.906]                     invisible(future)
[13:20:52.906]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:52.906]                 }
[13:20:52.906]             }
[13:20:52.906]         }
[13:20:52.906]     })
[13:20:52.906]     if (TRUE) {
[13:20:52.906]         base::sink(type = "output", split = FALSE)
[13:20:52.906]         if (TRUE) {
[13:20:52.906]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:52.906]         }
[13:20:52.906]         else {
[13:20:52.906]             ...future.result["stdout"] <- base::list(NULL)
[13:20:52.906]         }
[13:20:52.906]         base::close(...future.stdout)
[13:20:52.906]         ...future.stdout <- NULL
[13:20:52.906]     }
[13:20:52.906]     ...future.result$conditions <- ...future.conditions
[13:20:52.906]     ...future.result$finished <- base::Sys.time()
[13:20:52.906]     ...future.result
[13:20:52.906] }
[13:20:52.909] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:20:52.909] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:20:52.909] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:20:52.909] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:20:52.910] MultisessionFuture started
[13:20:52.910] - Launch lazy future ... done
[13:20:52.910] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:52.911] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:52.911] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:52.912] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:52.912] Searching for globals ... DONE
[13:20:52.912] Resolving globals: TRUE
[13:20:52.912] Resolving any globals that are futures ...
[13:20:52.912] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:52.913] Resolving any globals that are futures ... DONE
[13:20:52.913] Resolving futures part of globals (recursively) ...
[13:20:52.913] resolve() on list ...
[13:20:52.913]  recursive: 99
[13:20:52.913]  length: 1
[13:20:52.913]  elements: ‘ii’
[13:20:52.914]  length: 0 (resolved future 1)
[13:20:52.914] resolve() on list ... DONE
[13:20:52.914] - globals: [1] ‘ii’
[13:20:52.914] Resolving futures part of globals (recursively) ... DONE
[13:20:52.914] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:52.914] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:52.914] - globals: [1] ‘ii’
[13:20:52.915] 
[13:20:52.915] getGlobalsAndPackages() ... DONE
[13:20:52.915] run() for ‘Future’ ...
[13:20:52.915] - state: ‘created’
[13:20:52.915] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:52.929] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:52.929] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:52.929]   - Field: ‘node’
[13:20:52.930]   - Field: ‘label’
[13:20:52.930]   - Field: ‘local’
[13:20:52.930]   - Field: ‘owner’
[13:20:52.930]   - Field: ‘envir’
[13:20:52.930]   - Field: ‘workers’
[13:20:52.930]   - Field: ‘packages’
[13:20:52.930]   - Field: ‘gc’
[13:20:52.930]   - Field: ‘conditions’
[13:20:52.930]   - Field: ‘persistent’
[13:20:52.930]   - Field: ‘expr’
[13:20:52.931]   - Field: ‘uuid’
[13:20:52.931]   - Field: ‘seed’
[13:20:52.931]   - Field: ‘version’
[13:20:52.931]   - Field: ‘result’
[13:20:52.931]   - Field: ‘asynchronous’
[13:20:52.931]   - Field: ‘calls’
[13:20:52.931]   - Field: ‘globals’
[13:20:52.931]   - Field: ‘stdout’
[13:20:52.931]   - Field: ‘earlySignal’
[13:20:52.931]   - Field: ‘lazy’
[13:20:52.931]   - Field: ‘state’
[13:20:52.932] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:52.932] - Launch lazy future ...
[13:20:52.932] Packages needed by the future expression (n = 0): <none>
[13:20:52.932] Packages needed by future strategies (n = 0): <none>
[13:20:52.932] {
[13:20:52.932]     {
[13:20:52.932]         {
[13:20:52.932]             ...future.startTime <- base::Sys.time()
[13:20:52.932]             {
[13:20:52.932]                 {
[13:20:52.932]                   {
[13:20:52.932]                     {
[13:20:52.932]                       base::local({
[13:20:52.932]                         has_future <- base::requireNamespace("future", 
[13:20:52.932]                           quietly = TRUE)
[13:20:52.932]                         if (has_future) {
[13:20:52.932]                           ns <- base::getNamespace("future")
[13:20:52.932]                           version <- ns[[".package"]][["version"]]
[13:20:52.932]                           if (is.null(version)) 
[13:20:52.932]                             version <- utils::packageVersion("future")
[13:20:52.932]                         }
[13:20:52.932]                         else {
[13:20:52.932]                           version <- NULL
[13:20:52.932]                         }
[13:20:52.932]                         if (!has_future || version < "1.8.0") {
[13:20:52.932]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:52.932]                             "", base::R.version$version.string), 
[13:20:52.932]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:52.932]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:52.932]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:52.932]                               "release", "version")], collapse = " "), 
[13:20:52.932]                             hostname = base::Sys.info()[["nodename"]])
[13:20:52.932]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:52.932]                             info)
[13:20:52.932]                           info <- base::paste(info, collapse = "; ")
[13:20:52.932]                           if (!has_future) {
[13:20:52.932]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:52.932]                               info)
[13:20:52.932]                           }
[13:20:52.932]                           else {
[13:20:52.932]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:52.932]                               info, version)
[13:20:52.932]                           }
[13:20:52.932]                           base::stop(msg)
[13:20:52.932]                         }
[13:20:52.932]                       })
[13:20:52.932]                     }
[13:20:52.932]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:52.932]                     base::options(mc.cores = 1L)
[13:20:52.932]                   }
[13:20:52.932]                   options(future.plan = NULL)
[13:20:52.932]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:52.932]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:52.932]                 }
[13:20:52.932]                 ...future.workdir <- getwd()
[13:20:52.932]             }
[13:20:52.932]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:52.932]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:52.932]         }
[13:20:52.932]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:52.932]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:52.932]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:52.932]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:52.932]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:52.932]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:52.932]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:52.932]             base::names(...future.oldOptions))
[13:20:52.932]     }
[13:20:52.932]     if (FALSE) {
[13:20:52.932]     }
[13:20:52.932]     else {
[13:20:52.932]         if (TRUE) {
[13:20:52.932]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:52.932]                 open = "w")
[13:20:52.932]         }
[13:20:52.932]         else {
[13:20:52.932]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:52.932]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:52.932]         }
[13:20:52.932]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:52.932]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:52.932]             base::sink(type = "output", split = FALSE)
[13:20:52.932]             base::close(...future.stdout)
[13:20:52.932]         }, add = TRUE)
[13:20:52.932]     }
[13:20:52.932]     ...future.frame <- base::sys.nframe()
[13:20:52.932]     ...future.conditions <- base::list()
[13:20:52.932]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:52.932]     if (FALSE) {
[13:20:52.932]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:52.932]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:52.932]     }
[13:20:52.932]     ...future.result <- base::tryCatch({
[13:20:52.932]         base::withCallingHandlers({
[13:20:52.932]             ...future.value <- base::withVisible(base::local({
[13:20:52.932]                 ...future.makeSendCondition <- local({
[13:20:52.932]                   sendCondition <- NULL
[13:20:52.932]                   function(frame = 1L) {
[13:20:52.932]                     if (is.function(sendCondition)) 
[13:20:52.932]                       return(sendCondition)
[13:20:52.932]                     ns <- getNamespace("parallel")
[13:20:52.932]                     if (exists("sendData", mode = "function", 
[13:20:52.932]                       envir = ns)) {
[13:20:52.932]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:52.932]                         envir = ns)
[13:20:52.932]                       envir <- sys.frame(frame)
[13:20:52.932]                       master <- NULL
[13:20:52.932]                       while (!identical(envir, .GlobalEnv) && 
[13:20:52.932]                         !identical(envir, emptyenv())) {
[13:20:52.932]                         if (exists("master", mode = "list", envir = envir, 
[13:20:52.932]                           inherits = FALSE)) {
[13:20:52.932]                           master <- get("master", mode = "list", 
[13:20:52.932]                             envir = envir, inherits = FALSE)
[13:20:52.932]                           if (inherits(master, c("SOCKnode", 
[13:20:52.932]                             "SOCK0node"))) {
[13:20:52.932]                             sendCondition <<- function(cond) {
[13:20:52.932]                               data <- list(type = "VALUE", value = cond, 
[13:20:52.932]                                 success = TRUE)
[13:20:52.932]                               parallel_sendData(master, data)
[13:20:52.932]                             }
[13:20:52.932]                             return(sendCondition)
[13:20:52.932]                           }
[13:20:52.932]                         }
[13:20:52.932]                         frame <- frame + 1L
[13:20:52.932]                         envir <- sys.frame(frame)
[13:20:52.932]                       }
[13:20:52.932]                     }
[13:20:52.932]                     sendCondition <<- function(cond) NULL
[13:20:52.932]                   }
[13:20:52.932]                 })
[13:20:52.932]                 withCallingHandlers({
[13:20:52.932]                   {
[13:20:52.932]                     b <- a * ii
[13:20:52.932]                     a <- 0
[13:20:52.932]                     b
[13:20:52.932]                   }
[13:20:52.932]                 }, immediateCondition = function(cond) {
[13:20:52.932]                   sendCondition <- ...future.makeSendCondition()
[13:20:52.932]                   sendCondition(cond)
[13:20:52.932]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:52.932]                   {
[13:20:52.932]                     inherits <- base::inherits
[13:20:52.932]                     invokeRestart <- base::invokeRestart
[13:20:52.932]                     is.null <- base::is.null
[13:20:52.932]                     muffled <- FALSE
[13:20:52.932]                     if (inherits(cond, "message")) {
[13:20:52.932]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:52.932]                       if (muffled) 
[13:20:52.932]                         invokeRestart("muffleMessage")
[13:20:52.932]                     }
[13:20:52.932]                     else if (inherits(cond, "warning")) {
[13:20:52.932]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:52.932]                       if (muffled) 
[13:20:52.932]                         invokeRestart("muffleWarning")
[13:20:52.932]                     }
[13:20:52.932]                     else if (inherits(cond, "condition")) {
[13:20:52.932]                       if (!is.null(pattern)) {
[13:20:52.932]                         computeRestarts <- base::computeRestarts
[13:20:52.932]                         grepl <- base::grepl
[13:20:52.932]                         restarts <- computeRestarts(cond)
[13:20:52.932]                         for (restart in restarts) {
[13:20:52.932]                           name <- restart$name
[13:20:52.932]                           if (is.null(name)) 
[13:20:52.932]                             next
[13:20:52.932]                           if (!grepl(pattern, name)) 
[13:20:52.932]                             next
[13:20:52.932]                           invokeRestart(restart)
[13:20:52.932]                           muffled <- TRUE
[13:20:52.932]                           break
[13:20:52.932]                         }
[13:20:52.932]                       }
[13:20:52.932]                     }
[13:20:52.932]                     invisible(muffled)
[13:20:52.932]                   }
[13:20:52.932]                   muffleCondition(cond)
[13:20:52.932]                 })
[13:20:52.932]             }))
[13:20:52.932]             future::FutureResult(value = ...future.value$value, 
[13:20:52.932]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:52.932]                   ...future.rng), globalenv = if (FALSE) 
[13:20:52.932]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:52.932]                     ...future.globalenv.names))
[13:20:52.932]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:52.932]         }, condition = base::local({
[13:20:52.932]             c <- base::c
[13:20:52.932]             inherits <- base::inherits
[13:20:52.932]             invokeRestart <- base::invokeRestart
[13:20:52.932]             length <- base::length
[13:20:52.932]             list <- base::list
[13:20:52.932]             seq.int <- base::seq.int
[13:20:52.932]             signalCondition <- base::signalCondition
[13:20:52.932]             sys.calls <- base::sys.calls
[13:20:52.932]             `[[` <- base::`[[`
[13:20:52.932]             `+` <- base::`+`
[13:20:52.932]             `<<-` <- base::`<<-`
[13:20:52.932]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:52.932]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:52.932]                   3L)]
[13:20:52.932]             }
[13:20:52.932]             function(cond) {
[13:20:52.932]                 is_error <- inherits(cond, "error")
[13:20:52.932]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:52.932]                   NULL)
[13:20:52.932]                 if (is_error) {
[13:20:52.932]                   sessionInformation <- function() {
[13:20:52.932]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:52.932]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:52.932]                       search = base::search(), system = base::Sys.info())
[13:20:52.932]                   }
[13:20:52.932]                   ...future.conditions[[length(...future.conditions) + 
[13:20:52.932]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:52.932]                     cond$call), session = sessionInformation(), 
[13:20:52.932]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:52.932]                   signalCondition(cond)
[13:20:52.932]                 }
[13:20:52.932]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:52.932]                 "immediateCondition"))) {
[13:20:52.932]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:52.932]                   ...future.conditions[[length(...future.conditions) + 
[13:20:52.932]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:52.932]                   if (TRUE && !signal) {
[13:20:52.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:52.932]                     {
[13:20:52.932]                       inherits <- base::inherits
[13:20:52.932]                       invokeRestart <- base::invokeRestart
[13:20:52.932]                       is.null <- base::is.null
[13:20:52.932]                       muffled <- FALSE
[13:20:52.932]                       if (inherits(cond, "message")) {
[13:20:52.932]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:52.932]                         if (muffled) 
[13:20:52.932]                           invokeRestart("muffleMessage")
[13:20:52.932]                       }
[13:20:52.932]                       else if (inherits(cond, "warning")) {
[13:20:52.932]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:52.932]                         if (muffled) 
[13:20:52.932]                           invokeRestart("muffleWarning")
[13:20:52.932]                       }
[13:20:52.932]                       else if (inherits(cond, "condition")) {
[13:20:52.932]                         if (!is.null(pattern)) {
[13:20:52.932]                           computeRestarts <- base::computeRestarts
[13:20:52.932]                           grepl <- base::grepl
[13:20:52.932]                           restarts <- computeRestarts(cond)
[13:20:52.932]                           for (restart in restarts) {
[13:20:52.932]                             name <- restart$name
[13:20:52.932]                             if (is.null(name)) 
[13:20:52.932]                               next
[13:20:52.932]                             if (!grepl(pattern, name)) 
[13:20:52.932]                               next
[13:20:52.932]                             invokeRestart(restart)
[13:20:52.932]                             muffled <- TRUE
[13:20:52.932]                             break
[13:20:52.932]                           }
[13:20:52.932]                         }
[13:20:52.932]                       }
[13:20:52.932]                       invisible(muffled)
[13:20:52.932]                     }
[13:20:52.932]                     muffleCondition(cond, pattern = "^muffle")
[13:20:52.932]                   }
[13:20:52.932]                 }
[13:20:52.932]                 else {
[13:20:52.932]                   if (TRUE) {
[13:20:52.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:52.932]                     {
[13:20:52.932]                       inherits <- base::inherits
[13:20:52.932]                       invokeRestart <- base::invokeRestart
[13:20:52.932]                       is.null <- base::is.null
[13:20:52.932]                       muffled <- FALSE
[13:20:52.932]                       if (inherits(cond, "message")) {
[13:20:52.932]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:52.932]                         if (muffled) 
[13:20:52.932]                           invokeRestart("muffleMessage")
[13:20:52.932]                       }
[13:20:52.932]                       else if (inherits(cond, "warning")) {
[13:20:52.932]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:52.932]                         if (muffled) 
[13:20:52.932]                           invokeRestart("muffleWarning")
[13:20:52.932]                       }
[13:20:52.932]                       else if (inherits(cond, "condition")) {
[13:20:52.932]                         if (!is.null(pattern)) {
[13:20:52.932]                           computeRestarts <- base::computeRestarts
[13:20:52.932]                           grepl <- base::grepl
[13:20:52.932]                           restarts <- computeRestarts(cond)
[13:20:52.932]                           for (restart in restarts) {
[13:20:52.932]                             name <- restart$name
[13:20:52.932]                             if (is.null(name)) 
[13:20:52.932]                               next
[13:20:52.932]                             if (!grepl(pattern, name)) 
[13:20:52.932]                               next
[13:20:52.932]                             invokeRestart(restart)
[13:20:52.932]                             muffled <- TRUE
[13:20:52.932]                             break
[13:20:52.932]                           }
[13:20:52.932]                         }
[13:20:52.932]                       }
[13:20:52.932]                       invisible(muffled)
[13:20:52.932]                     }
[13:20:52.932]                     muffleCondition(cond, pattern = "^muffle")
[13:20:52.932]                   }
[13:20:52.932]                 }
[13:20:52.932]             }
[13:20:52.932]         }))
[13:20:52.932]     }, error = function(ex) {
[13:20:52.932]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:52.932]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:52.932]                 ...future.rng), started = ...future.startTime, 
[13:20:52.932]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:52.932]             version = "1.8"), class = "FutureResult")
[13:20:52.932]     }, finally = {
[13:20:52.932]         if (!identical(...future.workdir, getwd())) 
[13:20:52.932]             setwd(...future.workdir)
[13:20:52.932]         {
[13:20:52.932]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:52.932]                 ...future.oldOptions$nwarnings <- NULL
[13:20:52.932]             }
[13:20:52.932]             base::options(...future.oldOptions)
[13:20:52.932]             if (.Platform$OS.type == "windows") {
[13:20:52.932]                 old_names <- names(...future.oldEnvVars)
[13:20:52.932]                 envs <- base::Sys.getenv()
[13:20:52.932]                 names <- names(envs)
[13:20:52.932]                 common <- intersect(names, old_names)
[13:20:52.932]                 added <- setdiff(names, old_names)
[13:20:52.932]                 removed <- setdiff(old_names, names)
[13:20:52.932]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:52.932]                   envs[common]]
[13:20:52.932]                 NAMES <- toupper(changed)
[13:20:52.932]                 args <- list()
[13:20:52.932]                 for (kk in seq_along(NAMES)) {
[13:20:52.932]                   name <- changed[[kk]]
[13:20:52.932]                   NAME <- NAMES[[kk]]
[13:20:52.932]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:52.932]                     next
[13:20:52.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:52.932]                 }
[13:20:52.932]                 NAMES <- toupper(added)
[13:20:52.932]                 for (kk in seq_along(NAMES)) {
[13:20:52.932]                   name <- added[[kk]]
[13:20:52.932]                   NAME <- NAMES[[kk]]
[13:20:52.932]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:52.932]                     next
[13:20:52.932]                   args[[name]] <- ""
[13:20:52.932]                 }
[13:20:52.932]                 NAMES <- toupper(removed)
[13:20:52.932]                 for (kk in seq_along(NAMES)) {
[13:20:52.932]                   name <- removed[[kk]]
[13:20:52.932]                   NAME <- NAMES[[kk]]
[13:20:52.932]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:52.932]                     next
[13:20:52.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:52.932]                 }
[13:20:52.932]                 if (length(args) > 0) 
[13:20:52.932]                   base::do.call(base::Sys.setenv, args = args)
[13:20:52.932]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:52.932]             }
[13:20:52.932]             else {
[13:20:52.932]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:52.932]             }
[13:20:52.932]             {
[13:20:52.932]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:52.932]                   0L) {
[13:20:52.932]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:52.932]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:52.932]                   base::options(opts)
[13:20:52.932]                 }
[13:20:52.932]                 {
[13:20:52.932]                   {
[13:20:52.932]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:52.932]                     NULL
[13:20:52.932]                   }
[13:20:52.932]                   options(future.plan = NULL)
[13:20:52.932]                   if (is.na(NA_character_)) 
[13:20:52.932]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:52.932]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:52.932]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:52.932]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:52.932]                     envir = parent.frame()) 
[13:20:52.932]                   {
[13:20:52.932]                     if (is.function(workers)) 
[13:20:52.932]                       workers <- workers()
[13:20:52.932]                     workers <- structure(as.integer(workers), 
[13:20:52.932]                       class = class(workers))
[13:20:52.932]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:52.932]                       workers >= 1)
[13:20:52.932]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:52.932]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:52.932]                     }
[13:20:52.932]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:52.932]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:52.932]                       envir = envir)
[13:20:52.932]                     if (!future$lazy) 
[13:20:52.932]                       future <- run(future)
[13:20:52.932]                     invisible(future)
[13:20:52.932]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:52.932]                 }
[13:20:52.932]             }
[13:20:52.932]         }
[13:20:52.932]     })
[13:20:52.932]     if (TRUE) {
[13:20:52.932]         base::sink(type = "output", split = FALSE)
[13:20:52.932]         if (TRUE) {
[13:20:52.932]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:52.932]         }
[13:20:52.932]         else {
[13:20:52.932]             ...future.result["stdout"] <- base::list(NULL)
[13:20:52.932]         }
[13:20:52.932]         base::close(...future.stdout)
[13:20:52.932]         ...future.stdout <- NULL
[13:20:52.932]     }
[13:20:52.932]     ...future.result$conditions <- ...future.conditions
[13:20:52.932]     ...future.result$finished <- base::Sys.time()
[13:20:52.932]     ...future.result
[13:20:52.932] }
[13:20:53.005] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[13:20:53.006] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[13:20:53.006] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[13:20:53.006] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[13:20:53.007] MultisessionFuture started
[13:20:53.007] - Launch lazy future ... done
[13:20:53.007] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:53.008] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:53.008] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:53.009] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:53.010] Searching for globals ... DONE
[13:20:53.010] Resolving globals: TRUE
[13:20:53.010] Resolving any globals that are futures ...
[13:20:53.010] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:53.010] Resolving any globals that are futures ... DONE
[13:20:53.010] Resolving futures part of globals (recursively) ...
[13:20:53.011] resolve() on list ...
[13:20:53.011]  recursive: 99
[13:20:53.011]  length: 1
[13:20:53.011]  elements: ‘ii’
[13:20:53.011]  length: 0 (resolved future 1)
[13:20:53.011] resolve() on list ... DONE
[13:20:53.011] - globals: [1] ‘ii’
[13:20:53.011] Resolving futures part of globals (recursively) ... DONE
[13:20:53.011] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:53.012] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:53.012] - globals: [1] ‘ii’
[13:20:53.012] 
[13:20:53.012] getGlobalsAndPackages() ... DONE
[13:20:53.012] run() for ‘Future’ ...
[13:20:53.012] - state: ‘created’
[13:20:53.013] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:53.027] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:53.027] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:53.027]   - Field: ‘node’
[13:20:53.028]   - Field: ‘label’
[13:20:53.028]   - Field: ‘local’
[13:20:53.028]   - Field: ‘owner’
[13:20:53.028]   - Field: ‘envir’
[13:20:53.028]   - Field: ‘workers’
[13:20:53.028]   - Field: ‘packages’
[13:20:53.028]   - Field: ‘gc’
[13:20:53.028]   - Field: ‘conditions’
[13:20:53.028]   - Field: ‘persistent’
[13:20:53.028]   - Field: ‘expr’
[13:20:53.028]   - Field: ‘uuid’
[13:20:53.029]   - Field: ‘seed’
[13:20:53.029]   - Field: ‘version’
[13:20:53.029]   - Field: ‘result’
[13:20:53.029]   - Field: ‘asynchronous’
[13:20:53.029]   - Field: ‘calls’
[13:20:53.029]   - Field: ‘globals’
[13:20:53.029]   - Field: ‘stdout’
[13:20:53.029]   - Field: ‘earlySignal’
[13:20:53.029]   - Field: ‘lazy’
[13:20:53.029]   - Field: ‘state’
[13:20:53.030] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:53.030] - Launch lazy future ...
[13:20:53.030] Packages needed by the future expression (n = 0): <none>
[13:20:53.030] Packages needed by future strategies (n = 0): <none>
[13:20:53.031] {
[13:20:53.031]     {
[13:20:53.031]         {
[13:20:53.031]             ...future.startTime <- base::Sys.time()
[13:20:53.031]             {
[13:20:53.031]                 {
[13:20:53.031]                   {
[13:20:53.031]                     {
[13:20:53.031]                       base::local({
[13:20:53.031]                         has_future <- base::requireNamespace("future", 
[13:20:53.031]                           quietly = TRUE)
[13:20:53.031]                         if (has_future) {
[13:20:53.031]                           ns <- base::getNamespace("future")
[13:20:53.031]                           version <- ns[[".package"]][["version"]]
[13:20:53.031]                           if (is.null(version)) 
[13:20:53.031]                             version <- utils::packageVersion("future")
[13:20:53.031]                         }
[13:20:53.031]                         else {
[13:20:53.031]                           version <- NULL
[13:20:53.031]                         }
[13:20:53.031]                         if (!has_future || version < "1.8.0") {
[13:20:53.031]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:53.031]                             "", base::R.version$version.string), 
[13:20:53.031]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:53.031]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:53.031]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:53.031]                               "release", "version")], collapse = " "), 
[13:20:53.031]                             hostname = base::Sys.info()[["nodename"]])
[13:20:53.031]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:53.031]                             info)
[13:20:53.031]                           info <- base::paste(info, collapse = "; ")
[13:20:53.031]                           if (!has_future) {
[13:20:53.031]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:53.031]                               info)
[13:20:53.031]                           }
[13:20:53.031]                           else {
[13:20:53.031]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:53.031]                               info, version)
[13:20:53.031]                           }
[13:20:53.031]                           base::stop(msg)
[13:20:53.031]                         }
[13:20:53.031]                       })
[13:20:53.031]                     }
[13:20:53.031]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:53.031]                     base::options(mc.cores = 1L)
[13:20:53.031]                   }
[13:20:53.031]                   options(future.plan = NULL)
[13:20:53.031]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:53.031]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:53.031]                 }
[13:20:53.031]                 ...future.workdir <- getwd()
[13:20:53.031]             }
[13:20:53.031]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:53.031]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:53.031]         }
[13:20:53.031]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:53.031]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:53.031]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:53.031]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:53.031]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:53.031]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:53.031]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:53.031]             base::names(...future.oldOptions))
[13:20:53.031]     }
[13:20:53.031]     if (FALSE) {
[13:20:53.031]     }
[13:20:53.031]     else {
[13:20:53.031]         if (TRUE) {
[13:20:53.031]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:53.031]                 open = "w")
[13:20:53.031]         }
[13:20:53.031]         else {
[13:20:53.031]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:53.031]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:53.031]         }
[13:20:53.031]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:53.031]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:53.031]             base::sink(type = "output", split = FALSE)
[13:20:53.031]             base::close(...future.stdout)
[13:20:53.031]         }, add = TRUE)
[13:20:53.031]     }
[13:20:53.031]     ...future.frame <- base::sys.nframe()
[13:20:53.031]     ...future.conditions <- base::list()
[13:20:53.031]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:53.031]     if (FALSE) {
[13:20:53.031]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:53.031]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:53.031]     }
[13:20:53.031]     ...future.result <- base::tryCatch({
[13:20:53.031]         base::withCallingHandlers({
[13:20:53.031]             ...future.value <- base::withVisible(base::local({
[13:20:53.031]                 ...future.makeSendCondition <- local({
[13:20:53.031]                   sendCondition <- NULL
[13:20:53.031]                   function(frame = 1L) {
[13:20:53.031]                     if (is.function(sendCondition)) 
[13:20:53.031]                       return(sendCondition)
[13:20:53.031]                     ns <- getNamespace("parallel")
[13:20:53.031]                     if (exists("sendData", mode = "function", 
[13:20:53.031]                       envir = ns)) {
[13:20:53.031]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:53.031]                         envir = ns)
[13:20:53.031]                       envir <- sys.frame(frame)
[13:20:53.031]                       master <- NULL
[13:20:53.031]                       while (!identical(envir, .GlobalEnv) && 
[13:20:53.031]                         !identical(envir, emptyenv())) {
[13:20:53.031]                         if (exists("master", mode = "list", envir = envir, 
[13:20:53.031]                           inherits = FALSE)) {
[13:20:53.031]                           master <- get("master", mode = "list", 
[13:20:53.031]                             envir = envir, inherits = FALSE)
[13:20:53.031]                           if (inherits(master, c("SOCKnode", 
[13:20:53.031]                             "SOCK0node"))) {
[13:20:53.031]                             sendCondition <<- function(cond) {
[13:20:53.031]                               data <- list(type = "VALUE", value = cond, 
[13:20:53.031]                                 success = TRUE)
[13:20:53.031]                               parallel_sendData(master, data)
[13:20:53.031]                             }
[13:20:53.031]                             return(sendCondition)
[13:20:53.031]                           }
[13:20:53.031]                         }
[13:20:53.031]                         frame <- frame + 1L
[13:20:53.031]                         envir <- sys.frame(frame)
[13:20:53.031]                       }
[13:20:53.031]                     }
[13:20:53.031]                     sendCondition <<- function(cond) NULL
[13:20:53.031]                   }
[13:20:53.031]                 })
[13:20:53.031]                 withCallingHandlers({
[13:20:53.031]                   {
[13:20:53.031]                     b <- a * ii
[13:20:53.031]                     a <- 0
[13:20:53.031]                     b
[13:20:53.031]                   }
[13:20:53.031]                 }, immediateCondition = function(cond) {
[13:20:53.031]                   sendCondition <- ...future.makeSendCondition()
[13:20:53.031]                   sendCondition(cond)
[13:20:53.031]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.031]                   {
[13:20:53.031]                     inherits <- base::inherits
[13:20:53.031]                     invokeRestart <- base::invokeRestart
[13:20:53.031]                     is.null <- base::is.null
[13:20:53.031]                     muffled <- FALSE
[13:20:53.031]                     if (inherits(cond, "message")) {
[13:20:53.031]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:53.031]                       if (muffled) 
[13:20:53.031]                         invokeRestart("muffleMessage")
[13:20:53.031]                     }
[13:20:53.031]                     else if (inherits(cond, "warning")) {
[13:20:53.031]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:53.031]                       if (muffled) 
[13:20:53.031]                         invokeRestart("muffleWarning")
[13:20:53.031]                     }
[13:20:53.031]                     else if (inherits(cond, "condition")) {
[13:20:53.031]                       if (!is.null(pattern)) {
[13:20:53.031]                         computeRestarts <- base::computeRestarts
[13:20:53.031]                         grepl <- base::grepl
[13:20:53.031]                         restarts <- computeRestarts(cond)
[13:20:53.031]                         for (restart in restarts) {
[13:20:53.031]                           name <- restart$name
[13:20:53.031]                           if (is.null(name)) 
[13:20:53.031]                             next
[13:20:53.031]                           if (!grepl(pattern, name)) 
[13:20:53.031]                             next
[13:20:53.031]                           invokeRestart(restart)
[13:20:53.031]                           muffled <- TRUE
[13:20:53.031]                           break
[13:20:53.031]                         }
[13:20:53.031]                       }
[13:20:53.031]                     }
[13:20:53.031]                     invisible(muffled)
[13:20:53.031]                   }
[13:20:53.031]                   muffleCondition(cond)
[13:20:53.031]                 })
[13:20:53.031]             }))
[13:20:53.031]             future::FutureResult(value = ...future.value$value, 
[13:20:53.031]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:53.031]                   ...future.rng), globalenv = if (FALSE) 
[13:20:53.031]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:53.031]                     ...future.globalenv.names))
[13:20:53.031]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:53.031]         }, condition = base::local({
[13:20:53.031]             c <- base::c
[13:20:53.031]             inherits <- base::inherits
[13:20:53.031]             invokeRestart <- base::invokeRestart
[13:20:53.031]             length <- base::length
[13:20:53.031]             list <- base::list
[13:20:53.031]             seq.int <- base::seq.int
[13:20:53.031]             signalCondition <- base::signalCondition
[13:20:53.031]             sys.calls <- base::sys.calls
[13:20:53.031]             `[[` <- base::`[[`
[13:20:53.031]             `+` <- base::`+`
[13:20:53.031]             `<<-` <- base::`<<-`
[13:20:53.031]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:53.031]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:53.031]                   3L)]
[13:20:53.031]             }
[13:20:53.031]             function(cond) {
[13:20:53.031]                 is_error <- inherits(cond, "error")
[13:20:53.031]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:53.031]                   NULL)
[13:20:53.031]                 if (is_error) {
[13:20:53.031]                   sessionInformation <- function() {
[13:20:53.031]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:53.031]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:53.031]                       search = base::search(), system = base::Sys.info())
[13:20:53.031]                   }
[13:20:53.031]                   ...future.conditions[[length(...future.conditions) + 
[13:20:53.031]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:53.031]                     cond$call), session = sessionInformation(), 
[13:20:53.031]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:53.031]                   signalCondition(cond)
[13:20:53.031]                 }
[13:20:53.031]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:53.031]                 "immediateCondition"))) {
[13:20:53.031]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:53.031]                   ...future.conditions[[length(...future.conditions) + 
[13:20:53.031]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:53.031]                   if (TRUE && !signal) {
[13:20:53.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.031]                     {
[13:20:53.031]                       inherits <- base::inherits
[13:20:53.031]                       invokeRestart <- base::invokeRestart
[13:20:53.031]                       is.null <- base::is.null
[13:20:53.031]                       muffled <- FALSE
[13:20:53.031]                       if (inherits(cond, "message")) {
[13:20:53.031]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:53.031]                         if (muffled) 
[13:20:53.031]                           invokeRestart("muffleMessage")
[13:20:53.031]                       }
[13:20:53.031]                       else if (inherits(cond, "warning")) {
[13:20:53.031]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:53.031]                         if (muffled) 
[13:20:53.031]                           invokeRestart("muffleWarning")
[13:20:53.031]                       }
[13:20:53.031]                       else if (inherits(cond, "condition")) {
[13:20:53.031]                         if (!is.null(pattern)) {
[13:20:53.031]                           computeRestarts <- base::computeRestarts
[13:20:53.031]                           grepl <- base::grepl
[13:20:53.031]                           restarts <- computeRestarts(cond)
[13:20:53.031]                           for (restart in restarts) {
[13:20:53.031]                             name <- restart$name
[13:20:53.031]                             if (is.null(name)) 
[13:20:53.031]                               next
[13:20:53.031]                             if (!grepl(pattern, name)) 
[13:20:53.031]                               next
[13:20:53.031]                             invokeRestart(restart)
[13:20:53.031]                             muffled <- TRUE
[13:20:53.031]                             break
[13:20:53.031]                           }
[13:20:53.031]                         }
[13:20:53.031]                       }
[13:20:53.031]                       invisible(muffled)
[13:20:53.031]                     }
[13:20:53.031]                     muffleCondition(cond, pattern = "^muffle")
[13:20:53.031]                   }
[13:20:53.031]                 }
[13:20:53.031]                 else {
[13:20:53.031]                   if (TRUE) {
[13:20:53.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.031]                     {
[13:20:53.031]                       inherits <- base::inherits
[13:20:53.031]                       invokeRestart <- base::invokeRestart
[13:20:53.031]                       is.null <- base::is.null
[13:20:53.031]                       muffled <- FALSE
[13:20:53.031]                       if (inherits(cond, "message")) {
[13:20:53.031]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:53.031]                         if (muffled) 
[13:20:53.031]                           invokeRestart("muffleMessage")
[13:20:53.031]                       }
[13:20:53.031]                       else if (inherits(cond, "warning")) {
[13:20:53.031]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:53.031]                         if (muffled) 
[13:20:53.031]                           invokeRestart("muffleWarning")
[13:20:53.031]                       }
[13:20:53.031]                       else if (inherits(cond, "condition")) {
[13:20:53.031]                         if (!is.null(pattern)) {
[13:20:53.031]                           computeRestarts <- base::computeRestarts
[13:20:53.031]                           grepl <- base::grepl
[13:20:53.031]                           restarts <- computeRestarts(cond)
[13:20:53.031]                           for (restart in restarts) {
[13:20:53.031]                             name <- restart$name
[13:20:53.031]                             if (is.null(name)) 
[13:20:53.031]                               next
[13:20:53.031]                             if (!grepl(pattern, name)) 
[13:20:53.031]                               next
[13:20:53.031]                             invokeRestart(restart)
[13:20:53.031]                             muffled <- TRUE
[13:20:53.031]                             break
[13:20:53.031]                           }
[13:20:53.031]                         }
[13:20:53.031]                       }
[13:20:53.031]                       invisible(muffled)
[13:20:53.031]                     }
[13:20:53.031]                     muffleCondition(cond, pattern = "^muffle")
[13:20:53.031]                   }
[13:20:53.031]                 }
[13:20:53.031]             }
[13:20:53.031]         }))
[13:20:53.031]     }, error = function(ex) {
[13:20:53.031]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:53.031]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:53.031]                 ...future.rng), started = ...future.startTime, 
[13:20:53.031]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:53.031]             version = "1.8"), class = "FutureResult")
[13:20:53.031]     }, finally = {
[13:20:53.031]         if (!identical(...future.workdir, getwd())) 
[13:20:53.031]             setwd(...future.workdir)
[13:20:53.031]         {
[13:20:53.031]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:53.031]                 ...future.oldOptions$nwarnings <- NULL
[13:20:53.031]             }
[13:20:53.031]             base::options(...future.oldOptions)
[13:20:53.031]             if (.Platform$OS.type == "windows") {
[13:20:53.031]                 old_names <- names(...future.oldEnvVars)
[13:20:53.031]                 envs <- base::Sys.getenv()
[13:20:53.031]                 names <- names(envs)
[13:20:53.031]                 common <- intersect(names, old_names)
[13:20:53.031]                 added <- setdiff(names, old_names)
[13:20:53.031]                 removed <- setdiff(old_names, names)
[13:20:53.031]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:53.031]                   envs[common]]
[13:20:53.031]                 NAMES <- toupper(changed)
[13:20:53.031]                 args <- list()
[13:20:53.031]                 for (kk in seq_along(NAMES)) {
[13:20:53.031]                   name <- changed[[kk]]
[13:20:53.031]                   NAME <- NAMES[[kk]]
[13:20:53.031]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.031]                     next
[13:20:53.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:53.031]                 }
[13:20:53.031]                 NAMES <- toupper(added)
[13:20:53.031]                 for (kk in seq_along(NAMES)) {
[13:20:53.031]                   name <- added[[kk]]
[13:20:53.031]                   NAME <- NAMES[[kk]]
[13:20:53.031]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.031]                     next
[13:20:53.031]                   args[[name]] <- ""
[13:20:53.031]                 }
[13:20:53.031]                 NAMES <- toupper(removed)
[13:20:53.031]                 for (kk in seq_along(NAMES)) {
[13:20:53.031]                   name <- removed[[kk]]
[13:20:53.031]                   NAME <- NAMES[[kk]]
[13:20:53.031]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.031]                     next
[13:20:53.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:53.031]                 }
[13:20:53.031]                 if (length(args) > 0) 
[13:20:53.031]                   base::do.call(base::Sys.setenv, args = args)
[13:20:53.031]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:53.031]             }
[13:20:53.031]             else {
[13:20:53.031]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:53.031]             }
[13:20:53.031]             {
[13:20:53.031]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:53.031]                   0L) {
[13:20:53.031]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:53.031]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:53.031]                   base::options(opts)
[13:20:53.031]                 }
[13:20:53.031]                 {
[13:20:53.031]                   {
[13:20:53.031]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:53.031]                     NULL
[13:20:53.031]                   }
[13:20:53.031]                   options(future.plan = NULL)
[13:20:53.031]                   if (is.na(NA_character_)) 
[13:20:53.031]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:53.031]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:53.031]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:53.031]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:53.031]                     envir = parent.frame()) 
[13:20:53.031]                   {
[13:20:53.031]                     if (is.function(workers)) 
[13:20:53.031]                       workers <- workers()
[13:20:53.031]                     workers <- structure(as.integer(workers), 
[13:20:53.031]                       class = class(workers))
[13:20:53.031]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:53.031]                       workers >= 1)
[13:20:53.031]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:53.031]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:53.031]                     }
[13:20:53.031]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:53.031]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:53.031]                       envir = envir)
[13:20:53.031]                     if (!future$lazy) 
[13:20:53.031]                       future <- run(future)
[13:20:53.031]                     invisible(future)
[13:20:53.031]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:53.031]                 }
[13:20:53.031]             }
[13:20:53.031]         }
[13:20:53.031]     })
[13:20:53.031]     if (TRUE) {
[13:20:53.031]         base::sink(type = "output", split = FALSE)
[13:20:53.031]         if (TRUE) {
[13:20:53.031]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:53.031]         }
[13:20:53.031]         else {
[13:20:53.031]             ...future.result["stdout"] <- base::list(NULL)
[13:20:53.031]         }
[13:20:53.031]         base::close(...future.stdout)
[13:20:53.031]         ...future.stdout <- NULL
[13:20:53.031]     }
[13:20:53.031]     ...future.result$conditions <- ...future.conditions
[13:20:53.031]     ...future.result$finished <- base::Sys.time()
[13:20:53.031]     ...future.result
[13:20:53.031] }
[13:20:53.033] Poll #1 (0): usedNodes() = 2, workers = 2
[13:20:53.044] receiveMessageFromWorker() for ClusterFuture ...
[13:20:53.044] - Validating connection of MultisessionFuture
[13:20:53.044] - received message: FutureResult
[13:20:53.045] - Received FutureResult
[13:20:53.045] - Erased future from FutureRegistry
[13:20:53.045] result() for ClusterFuture ...
[13:20:53.045] - result already collected: FutureResult
[13:20:53.045] result() for ClusterFuture ... done
[13:20:53.045] signalConditions() ...
[13:20:53.045]  - include = ‘immediateCondition’
[13:20:53.045]  - exclude = 
[13:20:53.045]  - resignal = FALSE
[13:20:53.046]  - Number of conditions: 1
[13:20:53.046] signalConditions() ... done
[13:20:53.046] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:53.046] result() for ClusterFuture ...
[13:20:53.046] - result already collected: FutureResult
[13:20:53.046] result() for ClusterFuture ... done
[13:20:53.046] result() for ClusterFuture ...
[13:20:53.046] - result already collected: FutureResult
[13:20:53.046] result() for ClusterFuture ... done
[13:20:53.046] signalConditions() ...
[13:20:53.046]  - include = ‘immediateCondition’
[13:20:53.047]  - exclude = 
[13:20:53.047]  - resignal = FALSE
[13:20:53.047]  - Number of conditions: 1
[13:20:53.047] signalConditions() ... done
[13:20:53.048] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:20:53.048] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:20:53.048] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:20:53.048] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:20:53.049] MultisessionFuture started
[13:20:53.049] - Launch lazy future ... done
[13:20:53.049] run() for ‘MultisessionFuture’ ... done
[13:20:53.049] result() for ClusterFuture ...
[13:20:53.050] - result already collected: FutureResult
[13:20:53.050] result() for ClusterFuture ... done
[13:20:53.050] result() for ClusterFuture ...
[13:20:53.050] - result already collected: FutureResult
[13:20:53.050] result() for ClusterFuture ... done
[13:20:53.050] signalConditions() ...
[13:20:53.051]  - include = ‘immediateCondition’
[13:20:53.051]  - exclude = 
[13:20:53.051]  - resignal = FALSE
[13:20:53.051]  - Number of conditions: 1
[13:20:53.051] signalConditions() ... done
[13:20:53.051] Future state: ‘finished’
[13:20:53.052] result() for ClusterFuture ...
[13:20:53.052] - result already collected: FutureResult
[13:20:53.052] result() for ClusterFuture ... done
[13:20:53.052] signalConditions() ...
[13:20:53.052]  - include = ‘condition’
[13:20:53.052]  - exclude = ‘immediateCondition’
[13:20:53.052]  - resignal = TRUE
[13:20:53.053]  - Number of conditions: 1
[13:20:53.053]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:53.053] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "5853cd8d1af0" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:20:52"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:53.074] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:53.075] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:53.076] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:53.076] Searching for globals ... DONE
[13:20:53.076] Resolving globals: TRUE
[13:20:53.076] Resolving any globals that are futures ...
[13:20:53.076] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:53.077] Resolving any globals that are futures ... DONE
[13:20:53.077] Resolving futures part of globals (recursively) ...
[13:20:53.077] resolve() on list ...
[13:20:53.077]  recursive: 99
[13:20:53.077]  length: 1
[13:20:53.077]  elements: ‘ii’
[13:20:53.078]  length: 0 (resolved future 1)
[13:20:53.078] resolve() on list ... DONE
[13:20:53.078] - globals: [1] ‘ii’
[13:20:53.078] Resolving futures part of globals (recursively) ... DONE
[13:20:53.078] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:53.078] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:53.078] - globals: [1] ‘ii’
[13:20:53.079] 
[13:20:53.079] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:53.079] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:53.080] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:53.081] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:53.081] Searching for globals ... DONE
[13:20:53.081] Resolving globals: TRUE
[13:20:53.081] Resolving any globals that are futures ...
[13:20:53.081] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:53.081] Resolving any globals that are futures ... DONE
[13:20:53.082] Resolving futures part of globals (recursively) ...
[13:20:53.082] resolve() on list ...
[13:20:53.082]  recursive: 99
[13:20:53.082]  length: 1
[13:20:53.082]  elements: ‘ii’
[13:20:53.082]  length: 0 (resolved future 1)
[13:20:53.082] resolve() on list ... DONE
[13:20:53.083] - globals: [1] ‘ii’
[13:20:53.083] Resolving futures part of globals (recursively) ... DONE
[13:20:53.083] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:53.083] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:53.083] - globals: [1] ‘ii’
[13:20:53.083] 
[13:20:53.083] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:53.084] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:53.084] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:53.086] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:53.086] Searching for globals ... DONE
[13:20:53.086] Resolving globals: TRUE
[13:20:53.087] Resolving any globals that are futures ...
[13:20:53.087] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[13:20:53.087] Resolving any globals that are futures ... DONE
[13:20:53.087] Resolving futures part of globals (recursively) ...
[13:20:53.088] resolve() on list ...
[13:20:53.088]  recursive: 99
[13:20:53.088]  length: 1
[13:20:53.088]  elements: ‘ii’
[13:20:53.088]  length: 0 (resolved future 1)
[13:20:53.089] resolve() on list ... DONE
[13:20:53.089] - globals: [1] ‘ii’
[13:20:53.089] Resolving futures part of globals (recursively) ... DONE
[13:20:53.089] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:53.090] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:20:53.090] - globals: [1] ‘ii’
[13:20:53.090] 
[13:20:53.090] getGlobalsAndPackages() ... DONE
[13:20:53.090] run() for ‘Future’ ...
[13:20:53.090] - state: ‘created’
[13:20:53.091] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:53.108] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:53.108] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:53.108]   - Field: ‘node’
[13:20:53.108]   - Field: ‘label’
[13:20:53.108]   - Field: ‘local’
[13:20:53.108]   - Field: ‘owner’
[13:20:53.108]   - Field: ‘envir’
[13:20:53.108]   - Field: ‘workers’
[13:20:53.108]   - Field: ‘packages’
[13:20:53.109]   - Field: ‘gc’
[13:20:53.109]   - Field: ‘conditions’
[13:20:53.109]   - Field: ‘persistent’
[13:20:53.109]   - Field: ‘expr’
[13:20:53.109]   - Field: ‘uuid’
[13:20:53.109]   - Field: ‘seed’
[13:20:53.109]   - Field: ‘version’
[13:20:53.109]   - Field: ‘result’
[13:20:53.109]   - Field: ‘asynchronous’
[13:20:53.110]   - Field: ‘calls’
[13:20:53.110]   - Field: ‘globals’
[13:20:53.110]   - Field: ‘stdout’
[13:20:53.110]   - Field: ‘earlySignal’
[13:20:53.110]   - Field: ‘lazy’
[13:20:53.110]   - Field: ‘state’
[13:20:53.110] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:53.110] - Launch lazy future ...
[13:20:53.111] Packages needed by the future expression (n = 0): <none>
[13:20:53.111] Packages needed by future strategies (n = 0): <none>
[13:20:53.111] {
[13:20:53.111]     {
[13:20:53.111]         {
[13:20:53.111]             ...future.startTime <- base::Sys.time()
[13:20:53.111]             {
[13:20:53.111]                 {
[13:20:53.111]                   {
[13:20:53.111]                     {
[13:20:53.111]                       base::local({
[13:20:53.111]                         has_future <- base::requireNamespace("future", 
[13:20:53.111]                           quietly = TRUE)
[13:20:53.111]                         if (has_future) {
[13:20:53.111]                           ns <- base::getNamespace("future")
[13:20:53.111]                           version <- ns[[".package"]][["version"]]
[13:20:53.111]                           if (is.null(version)) 
[13:20:53.111]                             version <- utils::packageVersion("future")
[13:20:53.111]                         }
[13:20:53.111]                         else {
[13:20:53.111]                           version <- NULL
[13:20:53.111]                         }
[13:20:53.111]                         if (!has_future || version < "1.8.0") {
[13:20:53.111]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:53.111]                             "", base::R.version$version.string), 
[13:20:53.111]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:53.111]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:53.111]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:53.111]                               "release", "version")], collapse = " "), 
[13:20:53.111]                             hostname = base::Sys.info()[["nodename"]])
[13:20:53.111]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:53.111]                             info)
[13:20:53.111]                           info <- base::paste(info, collapse = "; ")
[13:20:53.111]                           if (!has_future) {
[13:20:53.111]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:53.111]                               info)
[13:20:53.111]                           }
[13:20:53.111]                           else {
[13:20:53.111]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:53.111]                               info, version)
[13:20:53.111]                           }
[13:20:53.111]                           base::stop(msg)
[13:20:53.111]                         }
[13:20:53.111]                       })
[13:20:53.111]                     }
[13:20:53.111]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:53.111]                     base::options(mc.cores = 1L)
[13:20:53.111]                   }
[13:20:53.111]                   options(future.plan = NULL)
[13:20:53.111]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:53.111]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:53.111]                 }
[13:20:53.111]                 ...future.workdir <- getwd()
[13:20:53.111]             }
[13:20:53.111]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:53.111]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:53.111]         }
[13:20:53.111]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:53.111]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:53.111]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:53.111]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:53.111]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:53.111]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:53.111]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:53.111]             base::names(...future.oldOptions))
[13:20:53.111]     }
[13:20:53.111]     if (FALSE) {
[13:20:53.111]     }
[13:20:53.111]     else {
[13:20:53.111]         if (TRUE) {
[13:20:53.111]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:53.111]                 open = "w")
[13:20:53.111]         }
[13:20:53.111]         else {
[13:20:53.111]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:53.111]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:53.111]         }
[13:20:53.111]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:53.111]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:53.111]             base::sink(type = "output", split = FALSE)
[13:20:53.111]             base::close(...future.stdout)
[13:20:53.111]         }, add = TRUE)
[13:20:53.111]     }
[13:20:53.111]     ...future.frame <- base::sys.nframe()
[13:20:53.111]     ...future.conditions <- base::list()
[13:20:53.111]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:53.111]     if (FALSE) {
[13:20:53.111]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:53.111]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:53.111]     }
[13:20:53.111]     ...future.result <- base::tryCatch({
[13:20:53.111]         base::withCallingHandlers({
[13:20:53.111]             ...future.value <- base::withVisible(base::local({
[13:20:53.111]                 ...future.makeSendCondition <- local({
[13:20:53.111]                   sendCondition <- NULL
[13:20:53.111]                   function(frame = 1L) {
[13:20:53.111]                     if (is.function(sendCondition)) 
[13:20:53.111]                       return(sendCondition)
[13:20:53.111]                     ns <- getNamespace("parallel")
[13:20:53.111]                     if (exists("sendData", mode = "function", 
[13:20:53.111]                       envir = ns)) {
[13:20:53.111]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:53.111]                         envir = ns)
[13:20:53.111]                       envir <- sys.frame(frame)
[13:20:53.111]                       master <- NULL
[13:20:53.111]                       while (!identical(envir, .GlobalEnv) && 
[13:20:53.111]                         !identical(envir, emptyenv())) {
[13:20:53.111]                         if (exists("master", mode = "list", envir = envir, 
[13:20:53.111]                           inherits = FALSE)) {
[13:20:53.111]                           master <- get("master", mode = "list", 
[13:20:53.111]                             envir = envir, inherits = FALSE)
[13:20:53.111]                           if (inherits(master, c("SOCKnode", 
[13:20:53.111]                             "SOCK0node"))) {
[13:20:53.111]                             sendCondition <<- function(cond) {
[13:20:53.111]                               data <- list(type = "VALUE", value = cond, 
[13:20:53.111]                                 success = TRUE)
[13:20:53.111]                               parallel_sendData(master, data)
[13:20:53.111]                             }
[13:20:53.111]                             return(sendCondition)
[13:20:53.111]                           }
[13:20:53.111]                         }
[13:20:53.111]                         frame <- frame + 1L
[13:20:53.111]                         envir <- sys.frame(frame)
[13:20:53.111]                       }
[13:20:53.111]                     }
[13:20:53.111]                     sendCondition <<- function(cond) NULL
[13:20:53.111]                   }
[13:20:53.111]                 })
[13:20:53.111]                 withCallingHandlers({
[13:20:53.111]                   {
[13:20:53.111]                     b <- a * ii
[13:20:53.111]                     a <- 0
[13:20:53.111]                     b
[13:20:53.111]                   }
[13:20:53.111]                 }, immediateCondition = function(cond) {
[13:20:53.111]                   sendCondition <- ...future.makeSendCondition()
[13:20:53.111]                   sendCondition(cond)
[13:20:53.111]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.111]                   {
[13:20:53.111]                     inherits <- base::inherits
[13:20:53.111]                     invokeRestart <- base::invokeRestart
[13:20:53.111]                     is.null <- base::is.null
[13:20:53.111]                     muffled <- FALSE
[13:20:53.111]                     if (inherits(cond, "message")) {
[13:20:53.111]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:53.111]                       if (muffled) 
[13:20:53.111]                         invokeRestart("muffleMessage")
[13:20:53.111]                     }
[13:20:53.111]                     else if (inherits(cond, "warning")) {
[13:20:53.111]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:53.111]                       if (muffled) 
[13:20:53.111]                         invokeRestart("muffleWarning")
[13:20:53.111]                     }
[13:20:53.111]                     else if (inherits(cond, "condition")) {
[13:20:53.111]                       if (!is.null(pattern)) {
[13:20:53.111]                         computeRestarts <- base::computeRestarts
[13:20:53.111]                         grepl <- base::grepl
[13:20:53.111]                         restarts <- computeRestarts(cond)
[13:20:53.111]                         for (restart in restarts) {
[13:20:53.111]                           name <- restart$name
[13:20:53.111]                           if (is.null(name)) 
[13:20:53.111]                             next
[13:20:53.111]                           if (!grepl(pattern, name)) 
[13:20:53.111]                             next
[13:20:53.111]                           invokeRestart(restart)
[13:20:53.111]                           muffled <- TRUE
[13:20:53.111]                           break
[13:20:53.111]                         }
[13:20:53.111]                       }
[13:20:53.111]                     }
[13:20:53.111]                     invisible(muffled)
[13:20:53.111]                   }
[13:20:53.111]                   muffleCondition(cond)
[13:20:53.111]                 })
[13:20:53.111]             }))
[13:20:53.111]             future::FutureResult(value = ...future.value$value, 
[13:20:53.111]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:53.111]                   ...future.rng), globalenv = if (FALSE) 
[13:20:53.111]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:53.111]                     ...future.globalenv.names))
[13:20:53.111]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:53.111]         }, condition = base::local({
[13:20:53.111]             c <- base::c
[13:20:53.111]             inherits <- base::inherits
[13:20:53.111]             invokeRestart <- base::invokeRestart
[13:20:53.111]             length <- base::length
[13:20:53.111]             list <- base::list
[13:20:53.111]             seq.int <- base::seq.int
[13:20:53.111]             signalCondition <- base::signalCondition
[13:20:53.111]             sys.calls <- base::sys.calls
[13:20:53.111]             `[[` <- base::`[[`
[13:20:53.111]             `+` <- base::`+`
[13:20:53.111]             `<<-` <- base::`<<-`
[13:20:53.111]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:53.111]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:53.111]                   3L)]
[13:20:53.111]             }
[13:20:53.111]             function(cond) {
[13:20:53.111]                 is_error <- inherits(cond, "error")
[13:20:53.111]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:53.111]                   NULL)
[13:20:53.111]                 if (is_error) {
[13:20:53.111]                   sessionInformation <- function() {
[13:20:53.111]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:53.111]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:53.111]                       search = base::search(), system = base::Sys.info())
[13:20:53.111]                   }
[13:20:53.111]                   ...future.conditions[[length(...future.conditions) + 
[13:20:53.111]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:53.111]                     cond$call), session = sessionInformation(), 
[13:20:53.111]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:53.111]                   signalCondition(cond)
[13:20:53.111]                 }
[13:20:53.111]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:53.111]                 "immediateCondition"))) {
[13:20:53.111]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:53.111]                   ...future.conditions[[length(...future.conditions) + 
[13:20:53.111]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:53.111]                   if (TRUE && !signal) {
[13:20:53.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.111]                     {
[13:20:53.111]                       inherits <- base::inherits
[13:20:53.111]                       invokeRestart <- base::invokeRestart
[13:20:53.111]                       is.null <- base::is.null
[13:20:53.111]                       muffled <- FALSE
[13:20:53.111]                       if (inherits(cond, "message")) {
[13:20:53.111]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:53.111]                         if (muffled) 
[13:20:53.111]                           invokeRestart("muffleMessage")
[13:20:53.111]                       }
[13:20:53.111]                       else if (inherits(cond, "warning")) {
[13:20:53.111]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:53.111]                         if (muffled) 
[13:20:53.111]                           invokeRestart("muffleWarning")
[13:20:53.111]                       }
[13:20:53.111]                       else if (inherits(cond, "condition")) {
[13:20:53.111]                         if (!is.null(pattern)) {
[13:20:53.111]                           computeRestarts <- base::computeRestarts
[13:20:53.111]                           grepl <- base::grepl
[13:20:53.111]                           restarts <- computeRestarts(cond)
[13:20:53.111]                           for (restart in restarts) {
[13:20:53.111]                             name <- restart$name
[13:20:53.111]                             if (is.null(name)) 
[13:20:53.111]                               next
[13:20:53.111]                             if (!grepl(pattern, name)) 
[13:20:53.111]                               next
[13:20:53.111]                             invokeRestart(restart)
[13:20:53.111]                             muffled <- TRUE
[13:20:53.111]                             break
[13:20:53.111]                           }
[13:20:53.111]                         }
[13:20:53.111]                       }
[13:20:53.111]                       invisible(muffled)
[13:20:53.111]                     }
[13:20:53.111]                     muffleCondition(cond, pattern = "^muffle")
[13:20:53.111]                   }
[13:20:53.111]                 }
[13:20:53.111]                 else {
[13:20:53.111]                   if (TRUE) {
[13:20:53.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.111]                     {
[13:20:53.111]                       inherits <- base::inherits
[13:20:53.111]                       invokeRestart <- base::invokeRestart
[13:20:53.111]                       is.null <- base::is.null
[13:20:53.111]                       muffled <- FALSE
[13:20:53.111]                       if (inherits(cond, "message")) {
[13:20:53.111]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:53.111]                         if (muffled) 
[13:20:53.111]                           invokeRestart("muffleMessage")
[13:20:53.111]                       }
[13:20:53.111]                       else if (inherits(cond, "warning")) {
[13:20:53.111]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:53.111]                         if (muffled) 
[13:20:53.111]                           invokeRestart("muffleWarning")
[13:20:53.111]                       }
[13:20:53.111]                       else if (inherits(cond, "condition")) {
[13:20:53.111]                         if (!is.null(pattern)) {
[13:20:53.111]                           computeRestarts <- base::computeRestarts
[13:20:53.111]                           grepl <- base::grepl
[13:20:53.111]                           restarts <- computeRestarts(cond)
[13:20:53.111]                           for (restart in restarts) {
[13:20:53.111]                             name <- restart$name
[13:20:53.111]                             if (is.null(name)) 
[13:20:53.111]                               next
[13:20:53.111]                             if (!grepl(pattern, name)) 
[13:20:53.111]                               next
[13:20:53.111]                             invokeRestart(restart)
[13:20:53.111]                             muffled <- TRUE
[13:20:53.111]                             break
[13:20:53.111]                           }
[13:20:53.111]                         }
[13:20:53.111]                       }
[13:20:53.111]                       invisible(muffled)
[13:20:53.111]                     }
[13:20:53.111]                     muffleCondition(cond, pattern = "^muffle")
[13:20:53.111]                   }
[13:20:53.111]                 }
[13:20:53.111]             }
[13:20:53.111]         }))
[13:20:53.111]     }, error = function(ex) {
[13:20:53.111]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:53.111]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:53.111]                 ...future.rng), started = ...future.startTime, 
[13:20:53.111]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:53.111]             version = "1.8"), class = "FutureResult")
[13:20:53.111]     }, finally = {
[13:20:53.111]         if (!identical(...future.workdir, getwd())) 
[13:20:53.111]             setwd(...future.workdir)
[13:20:53.111]         {
[13:20:53.111]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:53.111]                 ...future.oldOptions$nwarnings <- NULL
[13:20:53.111]             }
[13:20:53.111]             base::options(...future.oldOptions)
[13:20:53.111]             if (.Platform$OS.type == "windows") {
[13:20:53.111]                 old_names <- names(...future.oldEnvVars)
[13:20:53.111]                 envs <- base::Sys.getenv()
[13:20:53.111]                 names <- names(envs)
[13:20:53.111]                 common <- intersect(names, old_names)
[13:20:53.111]                 added <- setdiff(names, old_names)
[13:20:53.111]                 removed <- setdiff(old_names, names)
[13:20:53.111]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:53.111]                   envs[common]]
[13:20:53.111]                 NAMES <- toupper(changed)
[13:20:53.111]                 args <- list()
[13:20:53.111]                 for (kk in seq_along(NAMES)) {
[13:20:53.111]                   name <- changed[[kk]]
[13:20:53.111]                   NAME <- NAMES[[kk]]
[13:20:53.111]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.111]                     next
[13:20:53.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:53.111]                 }
[13:20:53.111]                 NAMES <- toupper(added)
[13:20:53.111]                 for (kk in seq_along(NAMES)) {
[13:20:53.111]                   name <- added[[kk]]
[13:20:53.111]                   NAME <- NAMES[[kk]]
[13:20:53.111]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.111]                     next
[13:20:53.111]                   args[[name]] <- ""
[13:20:53.111]                 }
[13:20:53.111]                 NAMES <- toupper(removed)
[13:20:53.111]                 for (kk in seq_along(NAMES)) {
[13:20:53.111]                   name <- removed[[kk]]
[13:20:53.111]                   NAME <- NAMES[[kk]]
[13:20:53.111]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.111]                     next
[13:20:53.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:53.111]                 }
[13:20:53.111]                 if (length(args) > 0) 
[13:20:53.111]                   base::do.call(base::Sys.setenv, args = args)
[13:20:53.111]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:53.111]             }
[13:20:53.111]             else {
[13:20:53.111]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:53.111]             }
[13:20:53.111]             {
[13:20:53.111]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:53.111]                   0L) {
[13:20:53.111]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:53.111]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:53.111]                   base::options(opts)
[13:20:53.111]                 }
[13:20:53.111]                 {
[13:20:53.111]                   {
[13:20:53.111]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:53.111]                     NULL
[13:20:53.111]                   }
[13:20:53.111]                   options(future.plan = NULL)
[13:20:53.111]                   if (is.na(NA_character_)) 
[13:20:53.111]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:53.111]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:53.111]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:53.111]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:53.111]                     envir = parent.frame()) 
[13:20:53.111]                   {
[13:20:53.111]                     if (is.function(workers)) 
[13:20:53.111]                       workers <- workers()
[13:20:53.111]                     workers <- structure(as.integer(workers), 
[13:20:53.111]                       class = class(workers))
[13:20:53.111]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:53.111]                       workers >= 1)
[13:20:53.111]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:53.111]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:53.111]                     }
[13:20:53.111]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:53.111]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:53.111]                       envir = envir)
[13:20:53.111]                     if (!future$lazy) 
[13:20:53.111]                       future <- run(future)
[13:20:53.111]                     invisible(future)
[13:20:53.111]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:53.111]                 }
[13:20:53.111]             }
[13:20:53.111]         }
[13:20:53.111]     })
[13:20:53.111]     if (TRUE) {
[13:20:53.111]         base::sink(type = "output", split = FALSE)
[13:20:53.111]         if (TRUE) {
[13:20:53.111]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:53.111]         }
[13:20:53.111]         else {
[13:20:53.111]             ...future.result["stdout"] <- base::list(NULL)
[13:20:53.111]         }
[13:20:53.111]         base::close(...future.stdout)
[13:20:53.111]         ...future.stdout <- NULL
[13:20:53.111]     }
[13:20:53.111]     ...future.result$conditions <- ...future.conditions
[13:20:53.111]     ...future.result$finished <- base::Sys.time()
[13:20:53.111]     ...future.result
[13:20:53.111] }
[13:20:53.113] Poll #1 (0): usedNodes() = 2, workers = 2
[13:20:53.124] receiveMessageFromWorker() for ClusterFuture ...
[13:20:53.124] - Validating connection of MultisessionFuture
[13:20:53.125] - received message: FutureResult
[13:20:53.125] - Received FutureResult
[13:20:53.125] - Erased future from FutureRegistry
[13:20:53.125] result() for ClusterFuture ...
[13:20:53.125] - result already collected: FutureResult
[13:20:53.126] result() for ClusterFuture ... done
[13:20:53.126] signalConditions() ...
[13:20:53.126]  - include = ‘immediateCondition’
[13:20:53.126]  - exclude = 
[13:20:53.126]  - resignal = FALSE
[13:20:53.126]  - Number of conditions: 1
[13:20:53.126] signalConditions() ... done
[13:20:53.126] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:53.126] result() for ClusterFuture ...
[13:20:53.126] - result already collected: FutureResult
[13:20:53.127] result() for ClusterFuture ... done
[13:20:53.127] result() for ClusterFuture ...
[13:20:53.127] - result already collected: FutureResult
[13:20:53.127] result() for ClusterFuture ... done
[13:20:53.127] signalConditions() ...
[13:20:53.127]  - include = ‘immediateCondition’
[13:20:53.127]  - exclude = 
[13:20:53.127]  - resignal = FALSE
[13:20:53.127]  - Number of conditions: 1
[13:20:53.127] signalConditions() ... done
[13:20:53.128] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[13:20:53.128] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[13:20:53.129] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[13:20:53.129] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[13:20:53.129] MultisessionFuture started
[13:20:53.129] - Launch lazy future ... done
[13:20:53.129] run() for ‘MultisessionFuture’ ... done
[13:20:53.130] result() for ClusterFuture ...
[13:20:53.130] receiveMessageFromWorker() for ClusterFuture ...
[13:20:53.130] - Validating connection of MultisessionFuture
[13:20:53.178] - received message: FutureResult
[13:20:53.179] - Received FutureResult
[13:20:53.179] - Erased future from FutureRegistry
[13:20:53.179] result() for ClusterFuture ...
[13:20:53.179] - result already collected: FutureResult
[13:20:53.179] result() for ClusterFuture ... done
[13:20:53.179] signalConditions() ...
[13:20:53.179]  - include = ‘immediateCondition’
[13:20:53.179]  - exclude = 
[13:20:53.180]  - resignal = FALSE
[13:20:53.180]  - Number of conditions: 1
[13:20:53.180] signalConditions() ... done
[13:20:53.180] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:53.180] result() for ClusterFuture ... done
[13:20:53.180] result() for ClusterFuture ...
[13:20:53.180] - result already collected: FutureResult
[13:20:53.180] result() for ClusterFuture ... done
[13:20:53.180] signalConditions() ...
[13:20:53.180]  - include = ‘immediateCondition’
[13:20:53.181]  - exclude = 
[13:20:53.181]  - resignal = FALSE
[13:20:53.181]  - Number of conditions: 1
[13:20:53.181] signalConditions() ... done
[13:20:53.181] Future state: ‘finished’
[13:20:53.181] result() for ClusterFuture ...
[13:20:53.181] - result already collected: FutureResult
[13:20:53.181] result() for ClusterFuture ... done
[13:20:53.181] signalConditions() ...
[13:20:53.181]  - include = ‘condition’
[13:20:53.181]  - exclude = ‘immediateCondition’
[13:20:53.182]  - resignal = TRUE
[13:20:53.182]  - Number of conditions: 1
[13:20:53.182]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:20:53.182] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "5853cd8d1af0" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-01-07 13:20:53"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:53.196] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:53.196] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:53.197] 
[13:20:53.197] Searching for globals ... DONE
[13:20:53.197] - globals: [0] <none>
[13:20:53.197] getGlobalsAndPackages() ... DONE
[13:20:53.197] run() for ‘Future’ ...
[13:20:53.198] - state: ‘created’
[13:20:53.198] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:53.212] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:53.213] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:53.213]   - Field: ‘node’
[13:20:53.213]   - Field: ‘label’
[13:20:53.213]   - Field: ‘local’
[13:20:53.213]   - Field: ‘owner’
[13:20:53.213]   - Field: ‘envir’
[13:20:53.213]   - Field: ‘workers’
[13:20:53.213]   - Field: ‘packages’
[13:20:53.213]   - Field: ‘gc’
[13:20:53.214]   - Field: ‘conditions’
[13:20:53.214]   - Field: ‘persistent’
[13:20:53.214]   - Field: ‘expr’
[13:20:53.214]   - Field: ‘uuid’
[13:20:53.214]   - Field: ‘seed’
[13:20:53.214]   - Field: ‘version’
[13:20:53.214]   - Field: ‘result’
[13:20:53.214]   - Field: ‘asynchronous’
[13:20:53.214]   - Field: ‘calls’
[13:20:53.214]   - Field: ‘globals’
[13:20:53.214]   - Field: ‘stdout’
[13:20:53.215]   - Field: ‘earlySignal’
[13:20:53.215]   - Field: ‘lazy’
[13:20:53.215]   - Field: ‘state’
[13:20:53.215] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:53.215] - Launch lazy future ...
[13:20:53.215] Packages needed by the future expression (n = 0): <none>
[13:20:53.215] Packages needed by future strategies (n = 0): <none>
[13:20:53.216] {
[13:20:53.216]     {
[13:20:53.216]         {
[13:20:53.216]             ...future.startTime <- base::Sys.time()
[13:20:53.216]             {
[13:20:53.216]                 {
[13:20:53.216]                   {
[13:20:53.216]                     {
[13:20:53.216]                       base::local({
[13:20:53.216]                         has_future <- base::requireNamespace("future", 
[13:20:53.216]                           quietly = TRUE)
[13:20:53.216]                         if (has_future) {
[13:20:53.216]                           ns <- base::getNamespace("future")
[13:20:53.216]                           version <- ns[[".package"]][["version"]]
[13:20:53.216]                           if (is.null(version)) 
[13:20:53.216]                             version <- utils::packageVersion("future")
[13:20:53.216]                         }
[13:20:53.216]                         else {
[13:20:53.216]                           version <- NULL
[13:20:53.216]                         }
[13:20:53.216]                         if (!has_future || version < "1.8.0") {
[13:20:53.216]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:53.216]                             "", base::R.version$version.string), 
[13:20:53.216]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:53.216]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:53.216]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:53.216]                               "release", "version")], collapse = " "), 
[13:20:53.216]                             hostname = base::Sys.info()[["nodename"]])
[13:20:53.216]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:53.216]                             info)
[13:20:53.216]                           info <- base::paste(info, collapse = "; ")
[13:20:53.216]                           if (!has_future) {
[13:20:53.216]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:53.216]                               info)
[13:20:53.216]                           }
[13:20:53.216]                           else {
[13:20:53.216]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:53.216]                               info, version)
[13:20:53.216]                           }
[13:20:53.216]                           base::stop(msg)
[13:20:53.216]                         }
[13:20:53.216]                       })
[13:20:53.216]                     }
[13:20:53.216]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:53.216]                     base::options(mc.cores = 1L)
[13:20:53.216]                   }
[13:20:53.216]                   options(future.plan = NULL)
[13:20:53.216]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:53.216]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:53.216]                 }
[13:20:53.216]                 ...future.workdir <- getwd()
[13:20:53.216]             }
[13:20:53.216]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:53.216]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:53.216]         }
[13:20:53.216]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:53.216]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:53.216]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:53.216]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:53.216]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:53.216]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:53.216]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:53.216]             base::names(...future.oldOptions))
[13:20:53.216]     }
[13:20:53.216]     if (FALSE) {
[13:20:53.216]     }
[13:20:53.216]     else {
[13:20:53.216]         if (TRUE) {
[13:20:53.216]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:53.216]                 open = "w")
[13:20:53.216]         }
[13:20:53.216]         else {
[13:20:53.216]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:53.216]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:53.216]         }
[13:20:53.216]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:53.216]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:53.216]             base::sink(type = "output", split = FALSE)
[13:20:53.216]             base::close(...future.stdout)
[13:20:53.216]         }, add = TRUE)
[13:20:53.216]     }
[13:20:53.216]     ...future.frame <- base::sys.nframe()
[13:20:53.216]     ...future.conditions <- base::list()
[13:20:53.216]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:53.216]     if (FALSE) {
[13:20:53.216]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:53.216]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:53.216]     }
[13:20:53.216]     ...future.result <- base::tryCatch({
[13:20:53.216]         base::withCallingHandlers({
[13:20:53.216]             ...future.value <- base::withVisible(base::local({
[13:20:53.216]                 ...future.makeSendCondition <- local({
[13:20:53.216]                   sendCondition <- NULL
[13:20:53.216]                   function(frame = 1L) {
[13:20:53.216]                     if (is.function(sendCondition)) 
[13:20:53.216]                       return(sendCondition)
[13:20:53.216]                     ns <- getNamespace("parallel")
[13:20:53.216]                     if (exists("sendData", mode = "function", 
[13:20:53.216]                       envir = ns)) {
[13:20:53.216]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:53.216]                         envir = ns)
[13:20:53.216]                       envir <- sys.frame(frame)
[13:20:53.216]                       master <- NULL
[13:20:53.216]                       while (!identical(envir, .GlobalEnv) && 
[13:20:53.216]                         !identical(envir, emptyenv())) {
[13:20:53.216]                         if (exists("master", mode = "list", envir = envir, 
[13:20:53.216]                           inherits = FALSE)) {
[13:20:53.216]                           master <- get("master", mode = "list", 
[13:20:53.216]                             envir = envir, inherits = FALSE)
[13:20:53.216]                           if (inherits(master, c("SOCKnode", 
[13:20:53.216]                             "SOCK0node"))) {
[13:20:53.216]                             sendCondition <<- function(cond) {
[13:20:53.216]                               data <- list(type = "VALUE", value = cond, 
[13:20:53.216]                                 success = TRUE)
[13:20:53.216]                               parallel_sendData(master, data)
[13:20:53.216]                             }
[13:20:53.216]                             return(sendCondition)
[13:20:53.216]                           }
[13:20:53.216]                         }
[13:20:53.216]                         frame <- frame + 1L
[13:20:53.216]                         envir <- sys.frame(frame)
[13:20:53.216]                       }
[13:20:53.216]                     }
[13:20:53.216]                     sendCondition <<- function(cond) NULL
[13:20:53.216]                   }
[13:20:53.216]                 })
[13:20:53.216]                 withCallingHandlers({
[13:20:53.216]                   1
[13:20:53.216]                 }, immediateCondition = function(cond) {
[13:20:53.216]                   sendCondition <- ...future.makeSendCondition()
[13:20:53.216]                   sendCondition(cond)
[13:20:53.216]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.216]                   {
[13:20:53.216]                     inherits <- base::inherits
[13:20:53.216]                     invokeRestart <- base::invokeRestart
[13:20:53.216]                     is.null <- base::is.null
[13:20:53.216]                     muffled <- FALSE
[13:20:53.216]                     if (inherits(cond, "message")) {
[13:20:53.216]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:53.216]                       if (muffled) 
[13:20:53.216]                         invokeRestart("muffleMessage")
[13:20:53.216]                     }
[13:20:53.216]                     else if (inherits(cond, "warning")) {
[13:20:53.216]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:53.216]                       if (muffled) 
[13:20:53.216]                         invokeRestart("muffleWarning")
[13:20:53.216]                     }
[13:20:53.216]                     else if (inherits(cond, "condition")) {
[13:20:53.216]                       if (!is.null(pattern)) {
[13:20:53.216]                         computeRestarts <- base::computeRestarts
[13:20:53.216]                         grepl <- base::grepl
[13:20:53.216]                         restarts <- computeRestarts(cond)
[13:20:53.216]                         for (restart in restarts) {
[13:20:53.216]                           name <- restart$name
[13:20:53.216]                           if (is.null(name)) 
[13:20:53.216]                             next
[13:20:53.216]                           if (!grepl(pattern, name)) 
[13:20:53.216]                             next
[13:20:53.216]                           invokeRestart(restart)
[13:20:53.216]                           muffled <- TRUE
[13:20:53.216]                           break
[13:20:53.216]                         }
[13:20:53.216]                       }
[13:20:53.216]                     }
[13:20:53.216]                     invisible(muffled)
[13:20:53.216]                   }
[13:20:53.216]                   muffleCondition(cond)
[13:20:53.216]                 })
[13:20:53.216]             }))
[13:20:53.216]             future::FutureResult(value = ...future.value$value, 
[13:20:53.216]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:53.216]                   ...future.rng), globalenv = if (FALSE) 
[13:20:53.216]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:53.216]                     ...future.globalenv.names))
[13:20:53.216]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:53.216]         }, condition = base::local({
[13:20:53.216]             c <- base::c
[13:20:53.216]             inherits <- base::inherits
[13:20:53.216]             invokeRestart <- base::invokeRestart
[13:20:53.216]             length <- base::length
[13:20:53.216]             list <- base::list
[13:20:53.216]             seq.int <- base::seq.int
[13:20:53.216]             signalCondition <- base::signalCondition
[13:20:53.216]             sys.calls <- base::sys.calls
[13:20:53.216]             `[[` <- base::`[[`
[13:20:53.216]             `+` <- base::`+`
[13:20:53.216]             `<<-` <- base::`<<-`
[13:20:53.216]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:53.216]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:53.216]                   3L)]
[13:20:53.216]             }
[13:20:53.216]             function(cond) {
[13:20:53.216]                 is_error <- inherits(cond, "error")
[13:20:53.216]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:53.216]                   NULL)
[13:20:53.216]                 if (is_error) {
[13:20:53.216]                   sessionInformation <- function() {
[13:20:53.216]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:53.216]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:53.216]                       search = base::search(), system = base::Sys.info())
[13:20:53.216]                   }
[13:20:53.216]                   ...future.conditions[[length(...future.conditions) + 
[13:20:53.216]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:53.216]                     cond$call), session = sessionInformation(), 
[13:20:53.216]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:53.216]                   signalCondition(cond)
[13:20:53.216]                 }
[13:20:53.216]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:53.216]                 "immediateCondition"))) {
[13:20:53.216]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:53.216]                   ...future.conditions[[length(...future.conditions) + 
[13:20:53.216]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:53.216]                   if (TRUE && !signal) {
[13:20:53.216]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.216]                     {
[13:20:53.216]                       inherits <- base::inherits
[13:20:53.216]                       invokeRestart <- base::invokeRestart
[13:20:53.216]                       is.null <- base::is.null
[13:20:53.216]                       muffled <- FALSE
[13:20:53.216]                       if (inherits(cond, "message")) {
[13:20:53.216]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:53.216]                         if (muffled) 
[13:20:53.216]                           invokeRestart("muffleMessage")
[13:20:53.216]                       }
[13:20:53.216]                       else if (inherits(cond, "warning")) {
[13:20:53.216]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:53.216]                         if (muffled) 
[13:20:53.216]                           invokeRestart("muffleWarning")
[13:20:53.216]                       }
[13:20:53.216]                       else if (inherits(cond, "condition")) {
[13:20:53.216]                         if (!is.null(pattern)) {
[13:20:53.216]                           computeRestarts <- base::computeRestarts
[13:20:53.216]                           grepl <- base::grepl
[13:20:53.216]                           restarts <- computeRestarts(cond)
[13:20:53.216]                           for (restart in restarts) {
[13:20:53.216]                             name <- restart$name
[13:20:53.216]                             if (is.null(name)) 
[13:20:53.216]                               next
[13:20:53.216]                             if (!grepl(pattern, name)) 
[13:20:53.216]                               next
[13:20:53.216]                             invokeRestart(restart)
[13:20:53.216]                             muffled <- TRUE
[13:20:53.216]                             break
[13:20:53.216]                           }
[13:20:53.216]                         }
[13:20:53.216]                       }
[13:20:53.216]                       invisible(muffled)
[13:20:53.216]                     }
[13:20:53.216]                     muffleCondition(cond, pattern = "^muffle")
[13:20:53.216]                   }
[13:20:53.216]                 }
[13:20:53.216]                 else {
[13:20:53.216]                   if (TRUE) {
[13:20:53.216]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.216]                     {
[13:20:53.216]                       inherits <- base::inherits
[13:20:53.216]                       invokeRestart <- base::invokeRestart
[13:20:53.216]                       is.null <- base::is.null
[13:20:53.216]                       muffled <- FALSE
[13:20:53.216]                       if (inherits(cond, "message")) {
[13:20:53.216]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:53.216]                         if (muffled) 
[13:20:53.216]                           invokeRestart("muffleMessage")
[13:20:53.216]                       }
[13:20:53.216]                       else if (inherits(cond, "warning")) {
[13:20:53.216]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:53.216]                         if (muffled) 
[13:20:53.216]                           invokeRestart("muffleWarning")
[13:20:53.216]                       }
[13:20:53.216]                       else if (inherits(cond, "condition")) {
[13:20:53.216]                         if (!is.null(pattern)) {
[13:20:53.216]                           computeRestarts <- base::computeRestarts
[13:20:53.216]                           grepl <- base::grepl
[13:20:53.216]                           restarts <- computeRestarts(cond)
[13:20:53.216]                           for (restart in restarts) {
[13:20:53.216]                             name <- restart$name
[13:20:53.216]                             if (is.null(name)) 
[13:20:53.216]                               next
[13:20:53.216]                             if (!grepl(pattern, name)) 
[13:20:53.216]                               next
[13:20:53.216]                             invokeRestart(restart)
[13:20:53.216]                             muffled <- TRUE
[13:20:53.216]                             break
[13:20:53.216]                           }
[13:20:53.216]                         }
[13:20:53.216]                       }
[13:20:53.216]                       invisible(muffled)
[13:20:53.216]                     }
[13:20:53.216]                     muffleCondition(cond, pattern = "^muffle")
[13:20:53.216]                   }
[13:20:53.216]                 }
[13:20:53.216]             }
[13:20:53.216]         }))
[13:20:53.216]     }, error = function(ex) {
[13:20:53.216]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:53.216]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:53.216]                 ...future.rng), started = ...future.startTime, 
[13:20:53.216]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:53.216]             version = "1.8"), class = "FutureResult")
[13:20:53.216]     }, finally = {
[13:20:53.216]         if (!identical(...future.workdir, getwd())) 
[13:20:53.216]             setwd(...future.workdir)
[13:20:53.216]         {
[13:20:53.216]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:53.216]                 ...future.oldOptions$nwarnings <- NULL
[13:20:53.216]             }
[13:20:53.216]             base::options(...future.oldOptions)
[13:20:53.216]             if (.Platform$OS.type == "windows") {
[13:20:53.216]                 old_names <- names(...future.oldEnvVars)
[13:20:53.216]                 envs <- base::Sys.getenv()
[13:20:53.216]                 names <- names(envs)
[13:20:53.216]                 common <- intersect(names, old_names)
[13:20:53.216]                 added <- setdiff(names, old_names)
[13:20:53.216]                 removed <- setdiff(old_names, names)
[13:20:53.216]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:53.216]                   envs[common]]
[13:20:53.216]                 NAMES <- toupper(changed)
[13:20:53.216]                 args <- list()
[13:20:53.216]                 for (kk in seq_along(NAMES)) {
[13:20:53.216]                   name <- changed[[kk]]
[13:20:53.216]                   NAME <- NAMES[[kk]]
[13:20:53.216]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.216]                     next
[13:20:53.216]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:53.216]                 }
[13:20:53.216]                 NAMES <- toupper(added)
[13:20:53.216]                 for (kk in seq_along(NAMES)) {
[13:20:53.216]                   name <- added[[kk]]
[13:20:53.216]                   NAME <- NAMES[[kk]]
[13:20:53.216]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.216]                     next
[13:20:53.216]                   args[[name]] <- ""
[13:20:53.216]                 }
[13:20:53.216]                 NAMES <- toupper(removed)
[13:20:53.216]                 for (kk in seq_along(NAMES)) {
[13:20:53.216]                   name <- removed[[kk]]
[13:20:53.216]                   NAME <- NAMES[[kk]]
[13:20:53.216]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.216]                     next
[13:20:53.216]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:53.216]                 }
[13:20:53.216]                 if (length(args) > 0) 
[13:20:53.216]                   base::do.call(base::Sys.setenv, args = args)
[13:20:53.216]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:53.216]             }
[13:20:53.216]             else {
[13:20:53.216]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:53.216]             }
[13:20:53.216]             {
[13:20:53.216]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:53.216]                   0L) {
[13:20:53.216]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:53.216]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:53.216]                   base::options(opts)
[13:20:53.216]                 }
[13:20:53.216]                 {
[13:20:53.216]                   {
[13:20:53.216]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:53.216]                     NULL
[13:20:53.216]                   }
[13:20:53.216]                   options(future.plan = NULL)
[13:20:53.216]                   if (is.na(NA_character_)) 
[13:20:53.216]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:53.216]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:53.216]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:53.216]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:53.216]                     envir = parent.frame()) 
[13:20:53.216]                   {
[13:20:53.216]                     if (is.function(workers)) 
[13:20:53.216]                       workers <- workers()
[13:20:53.216]                     workers <- structure(as.integer(workers), 
[13:20:53.216]                       class = class(workers))
[13:20:53.216]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:53.216]                       workers >= 1)
[13:20:53.216]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:53.216]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:53.216]                     }
[13:20:53.216]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:53.216]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:53.216]                       envir = envir)
[13:20:53.216]                     if (!future$lazy) 
[13:20:53.216]                       future <- run(future)
[13:20:53.216]                     invisible(future)
[13:20:53.216]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:53.216]                 }
[13:20:53.216]             }
[13:20:53.216]         }
[13:20:53.216]     })
[13:20:53.216]     if (TRUE) {
[13:20:53.216]         base::sink(type = "output", split = FALSE)
[13:20:53.216]         if (TRUE) {
[13:20:53.216]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:53.216]         }
[13:20:53.216]         else {
[13:20:53.216]             ...future.result["stdout"] <- base::list(NULL)
[13:20:53.216]         }
[13:20:53.216]         base::close(...future.stdout)
[13:20:53.216]         ...future.stdout <- NULL
[13:20:53.216]     }
[13:20:53.216]     ...future.result$conditions <- ...future.conditions
[13:20:53.216]     ...future.result$finished <- base::Sys.time()
[13:20:53.216]     ...future.result
[13:20:53.216] }
[13:20:53.219] MultisessionFuture started
[13:20:53.219] - Launch lazy future ... done
[13:20:53.219] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:53.219] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:53.220] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:53.221] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:53.221] Searching for globals ... DONE
[13:20:53.221] Resolving globals: TRUE
[13:20:53.221] Resolving any globals that are futures ...
[13:20:53.221] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:53.221] Resolving any globals that are futures ... DONE
[13:20:53.221] Resolving futures part of globals (recursively) ...
[13:20:53.222] resolve() on list ...
[13:20:53.222]  recursive: 99
[13:20:53.222]  length: 1
[13:20:53.222]  elements: ‘a’
[13:20:53.266] receiveMessageFromWorker() for ClusterFuture ...
[13:20:53.267] - Validating connection of MultisessionFuture
[13:20:53.267] - received message: FutureResult
[13:20:53.267] - Received FutureResult
[13:20:53.267] - Erased future from FutureRegistry
[13:20:53.267] result() for ClusterFuture ...
[13:20:53.267] - result already collected: FutureResult
[13:20:53.267] result() for ClusterFuture ... done
[13:20:53.268] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:53.268] Future #1
[13:20:53.268] result() for ClusterFuture ...
[13:20:53.268] - result already collected: FutureResult
[13:20:53.268] result() for ClusterFuture ... done
[13:20:53.268] result() for ClusterFuture ...
[13:20:53.268] - result already collected: FutureResult
[13:20:53.268] result() for ClusterFuture ... done
[13:20:53.268] A MultisessionFuture was resolved
[13:20:53.269]  length: 0 (resolved future 1)
[13:20:53.269] resolve() on list ... DONE
[13:20:53.269] - globals: [1] ‘a’
[13:20:53.269] Resolving futures part of globals (recursively) ... DONE
[13:20:53.270] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[13:20:53.270] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[13:20:53.270] - globals: [1] ‘a’
[13:20:53.271] - packages: [1] ‘future’
[13:20:53.271] getGlobalsAndPackages() ... DONE
[13:20:53.271] run() for ‘Future’ ...
[13:20:53.271] - state: ‘created’
[13:20:53.271] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:53.286] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:53.286] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:53.286]   - Field: ‘node’
[13:20:53.286]   - Field: ‘label’
[13:20:53.286]   - Field: ‘local’
[13:20:53.286]   - Field: ‘owner’
[13:20:53.288]   - Field: ‘envir’
[13:20:53.289]   - Field: ‘workers’
[13:20:53.289]   - Field: ‘packages’
[13:20:53.289]   - Field: ‘gc’
[13:20:53.289]   - Field: ‘conditions’
[13:20:53.289]   - Field: ‘persistent’
[13:20:53.289]   - Field: ‘expr’
[13:20:53.289]   - Field: ‘uuid’
[13:20:53.289]   - Field: ‘seed’
[13:20:53.289]   - Field: ‘version’
[13:20:53.289]   - Field: ‘result’
[13:20:53.290]   - Field: ‘asynchronous’
[13:20:53.290]   - Field: ‘calls’
[13:20:53.290]   - Field: ‘globals’
[13:20:53.290]   - Field: ‘stdout’
[13:20:53.290]   - Field: ‘earlySignal’
[13:20:53.290]   - Field: ‘lazy’
[13:20:53.290]   - Field: ‘state’
[13:20:53.290] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:53.290] - Launch lazy future ...
[13:20:53.291] Packages needed by the future expression (n = 1): ‘future’
[13:20:53.291] Packages needed by future strategies (n = 0): <none>
[13:20:53.291] {
[13:20:53.291]     {
[13:20:53.291]         {
[13:20:53.291]             ...future.startTime <- base::Sys.time()
[13:20:53.291]             {
[13:20:53.291]                 {
[13:20:53.291]                   {
[13:20:53.291]                     {
[13:20:53.291]                       {
[13:20:53.291]                         base::local({
[13:20:53.291]                           has_future <- base::requireNamespace("future", 
[13:20:53.291]                             quietly = TRUE)
[13:20:53.291]                           if (has_future) {
[13:20:53.291]                             ns <- base::getNamespace("future")
[13:20:53.291]                             version <- ns[[".package"]][["version"]]
[13:20:53.291]                             if (is.null(version)) 
[13:20:53.291]                               version <- utils::packageVersion("future")
[13:20:53.291]                           }
[13:20:53.291]                           else {
[13:20:53.291]                             version <- NULL
[13:20:53.291]                           }
[13:20:53.291]                           if (!has_future || version < "1.8.0") {
[13:20:53.291]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:53.291]                               "", base::R.version$version.string), 
[13:20:53.291]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:53.291]                                 base::R.version$platform, 8 * 
[13:20:53.291]                                   base::.Machine$sizeof.pointer), 
[13:20:53.291]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:53.291]                                 "release", "version")], collapse = " "), 
[13:20:53.291]                               hostname = base::Sys.info()[["nodename"]])
[13:20:53.291]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:53.291]                               info)
[13:20:53.291]                             info <- base::paste(info, collapse = "; ")
[13:20:53.291]                             if (!has_future) {
[13:20:53.291]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:53.291]                                 info)
[13:20:53.291]                             }
[13:20:53.291]                             else {
[13:20:53.291]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:53.291]                                 info, version)
[13:20:53.291]                             }
[13:20:53.291]                             base::stop(msg)
[13:20:53.291]                           }
[13:20:53.291]                         })
[13:20:53.291]                       }
[13:20:53.291]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:53.291]                       base::options(mc.cores = 1L)
[13:20:53.291]                     }
[13:20:53.291]                     base::local({
[13:20:53.291]                       for (pkg in "future") {
[13:20:53.291]                         base::loadNamespace(pkg)
[13:20:53.291]                         base::library(pkg, character.only = TRUE)
[13:20:53.291]                       }
[13:20:53.291]                     })
[13:20:53.291]                   }
[13:20:53.291]                   options(future.plan = NULL)
[13:20:53.291]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:53.291]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:53.291]                 }
[13:20:53.291]                 ...future.workdir <- getwd()
[13:20:53.291]             }
[13:20:53.291]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:53.291]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:53.291]         }
[13:20:53.291]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:53.291]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:53.291]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:53.291]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:53.291]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:53.291]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:53.291]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:53.291]             base::names(...future.oldOptions))
[13:20:53.291]     }
[13:20:53.291]     if (FALSE) {
[13:20:53.291]     }
[13:20:53.291]     else {
[13:20:53.291]         if (TRUE) {
[13:20:53.291]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:53.291]                 open = "w")
[13:20:53.291]         }
[13:20:53.291]         else {
[13:20:53.291]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:53.291]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:53.291]         }
[13:20:53.291]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:53.291]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:53.291]             base::sink(type = "output", split = FALSE)
[13:20:53.291]             base::close(...future.stdout)
[13:20:53.291]         }, add = TRUE)
[13:20:53.291]     }
[13:20:53.291]     ...future.frame <- base::sys.nframe()
[13:20:53.291]     ...future.conditions <- base::list()
[13:20:53.291]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:53.291]     if (FALSE) {
[13:20:53.291]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:53.291]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:53.291]     }
[13:20:53.291]     ...future.result <- base::tryCatch({
[13:20:53.291]         base::withCallingHandlers({
[13:20:53.291]             ...future.value <- base::withVisible(base::local({
[13:20:53.291]                 ...future.makeSendCondition <- local({
[13:20:53.291]                   sendCondition <- NULL
[13:20:53.291]                   function(frame = 1L) {
[13:20:53.291]                     if (is.function(sendCondition)) 
[13:20:53.291]                       return(sendCondition)
[13:20:53.291]                     ns <- getNamespace("parallel")
[13:20:53.291]                     if (exists("sendData", mode = "function", 
[13:20:53.291]                       envir = ns)) {
[13:20:53.291]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:53.291]                         envir = ns)
[13:20:53.291]                       envir <- sys.frame(frame)
[13:20:53.291]                       master <- NULL
[13:20:53.291]                       while (!identical(envir, .GlobalEnv) && 
[13:20:53.291]                         !identical(envir, emptyenv())) {
[13:20:53.291]                         if (exists("master", mode = "list", envir = envir, 
[13:20:53.291]                           inherits = FALSE)) {
[13:20:53.291]                           master <- get("master", mode = "list", 
[13:20:53.291]                             envir = envir, inherits = FALSE)
[13:20:53.291]                           if (inherits(master, c("SOCKnode", 
[13:20:53.291]                             "SOCK0node"))) {
[13:20:53.291]                             sendCondition <<- function(cond) {
[13:20:53.291]                               data <- list(type = "VALUE", value = cond, 
[13:20:53.291]                                 success = TRUE)
[13:20:53.291]                               parallel_sendData(master, data)
[13:20:53.291]                             }
[13:20:53.291]                             return(sendCondition)
[13:20:53.291]                           }
[13:20:53.291]                         }
[13:20:53.291]                         frame <- frame + 1L
[13:20:53.291]                         envir <- sys.frame(frame)
[13:20:53.291]                       }
[13:20:53.291]                     }
[13:20:53.291]                     sendCondition <<- function(cond) NULL
[13:20:53.291]                   }
[13:20:53.291]                 })
[13:20:53.291]                 withCallingHandlers({
[13:20:53.291]                   value(a) + 1
[13:20:53.291]                 }, immediateCondition = function(cond) {
[13:20:53.291]                   sendCondition <- ...future.makeSendCondition()
[13:20:53.291]                   sendCondition(cond)
[13:20:53.291]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.291]                   {
[13:20:53.291]                     inherits <- base::inherits
[13:20:53.291]                     invokeRestart <- base::invokeRestart
[13:20:53.291]                     is.null <- base::is.null
[13:20:53.291]                     muffled <- FALSE
[13:20:53.291]                     if (inherits(cond, "message")) {
[13:20:53.291]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:53.291]                       if (muffled) 
[13:20:53.291]                         invokeRestart("muffleMessage")
[13:20:53.291]                     }
[13:20:53.291]                     else if (inherits(cond, "warning")) {
[13:20:53.291]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:53.291]                       if (muffled) 
[13:20:53.291]                         invokeRestart("muffleWarning")
[13:20:53.291]                     }
[13:20:53.291]                     else if (inherits(cond, "condition")) {
[13:20:53.291]                       if (!is.null(pattern)) {
[13:20:53.291]                         computeRestarts <- base::computeRestarts
[13:20:53.291]                         grepl <- base::grepl
[13:20:53.291]                         restarts <- computeRestarts(cond)
[13:20:53.291]                         for (restart in restarts) {
[13:20:53.291]                           name <- restart$name
[13:20:53.291]                           if (is.null(name)) 
[13:20:53.291]                             next
[13:20:53.291]                           if (!grepl(pattern, name)) 
[13:20:53.291]                             next
[13:20:53.291]                           invokeRestart(restart)
[13:20:53.291]                           muffled <- TRUE
[13:20:53.291]                           break
[13:20:53.291]                         }
[13:20:53.291]                       }
[13:20:53.291]                     }
[13:20:53.291]                     invisible(muffled)
[13:20:53.291]                   }
[13:20:53.291]                   muffleCondition(cond)
[13:20:53.291]                 })
[13:20:53.291]             }))
[13:20:53.291]             future::FutureResult(value = ...future.value$value, 
[13:20:53.291]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:53.291]                   ...future.rng), globalenv = if (FALSE) 
[13:20:53.291]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:53.291]                     ...future.globalenv.names))
[13:20:53.291]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:53.291]         }, condition = base::local({
[13:20:53.291]             c <- base::c
[13:20:53.291]             inherits <- base::inherits
[13:20:53.291]             invokeRestart <- base::invokeRestart
[13:20:53.291]             length <- base::length
[13:20:53.291]             list <- base::list
[13:20:53.291]             seq.int <- base::seq.int
[13:20:53.291]             signalCondition <- base::signalCondition
[13:20:53.291]             sys.calls <- base::sys.calls
[13:20:53.291]             `[[` <- base::`[[`
[13:20:53.291]             `+` <- base::`+`
[13:20:53.291]             `<<-` <- base::`<<-`
[13:20:53.291]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:53.291]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:53.291]                   3L)]
[13:20:53.291]             }
[13:20:53.291]             function(cond) {
[13:20:53.291]                 is_error <- inherits(cond, "error")
[13:20:53.291]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:53.291]                   NULL)
[13:20:53.291]                 if (is_error) {
[13:20:53.291]                   sessionInformation <- function() {
[13:20:53.291]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:53.291]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:53.291]                       search = base::search(), system = base::Sys.info())
[13:20:53.291]                   }
[13:20:53.291]                   ...future.conditions[[length(...future.conditions) + 
[13:20:53.291]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:53.291]                     cond$call), session = sessionInformation(), 
[13:20:53.291]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:53.291]                   signalCondition(cond)
[13:20:53.291]                 }
[13:20:53.291]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:53.291]                 "immediateCondition"))) {
[13:20:53.291]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:53.291]                   ...future.conditions[[length(...future.conditions) + 
[13:20:53.291]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:53.291]                   if (TRUE && !signal) {
[13:20:53.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.291]                     {
[13:20:53.291]                       inherits <- base::inherits
[13:20:53.291]                       invokeRestart <- base::invokeRestart
[13:20:53.291]                       is.null <- base::is.null
[13:20:53.291]                       muffled <- FALSE
[13:20:53.291]                       if (inherits(cond, "message")) {
[13:20:53.291]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:53.291]                         if (muffled) 
[13:20:53.291]                           invokeRestart("muffleMessage")
[13:20:53.291]                       }
[13:20:53.291]                       else if (inherits(cond, "warning")) {
[13:20:53.291]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:53.291]                         if (muffled) 
[13:20:53.291]                           invokeRestart("muffleWarning")
[13:20:53.291]                       }
[13:20:53.291]                       else if (inherits(cond, "condition")) {
[13:20:53.291]                         if (!is.null(pattern)) {
[13:20:53.291]                           computeRestarts <- base::computeRestarts
[13:20:53.291]                           grepl <- base::grepl
[13:20:53.291]                           restarts <- computeRestarts(cond)
[13:20:53.291]                           for (restart in restarts) {
[13:20:53.291]                             name <- restart$name
[13:20:53.291]                             if (is.null(name)) 
[13:20:53.291]                               next
[13:20:53.291]                             if (!grepl(pattern, name)) 
[13:20:53.291]                               next
[13:20:53.291]                             invokeRestart(restart)
[13:20:53.291]                             muffled <- TRUE
[13:20:53.291]                             break
[13:20:53.291]                           }
[13:20:53.291]                         }
[13:20:53.291]                       }
[13:20:53.291]                       invisible(muffled)
[13:20:53.291]                     }
[13:20:53.291]                     muffleCondition(cond, pattern = "^muffle")
[13:20:53.291]                   }
[13:20:53.291]                 }
[13:20:53.291]                 else {
[13:20:53.291]                   if (TRUE) {
[13:20:53.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.291]                     {
[13:20:53.291]                       inherits <- base::inherits
[13:20:53.291]                       invokeRestart <- base::invokeRestart
[13:20:53.291]                       is.null <- base::is.null
[13:20:53.291]                       muffled <- FALSE
[13:20:53.291]                       if (inherits(cond, "message")) {
[13:20:53.291]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:53.291]                         if (muffled) 
[13:20:53.291]                           invokeRestart("muffleMessage")
[13:20:53.291]                       }
[13:20:53.291]                       else if (inherits(cond, "warning")) {
[13:20:53.291]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:53.291]                         if (muffled) 
[13:20:53.291]                           invokeRestart("muffleWarning")
[13:20:53.291]                       }
[13:20:53.291]                       else if (inherits(cond, "condition")) {
[13:20:53.291]                         if (!is.null(pattern)) {
[13:20:53.291]                           computeRestarts <- base::computeRestarts
[13:20:53.291]                           grepl <- base::grepl
[13:20:53.291]                           restarts <- computeRestarts(cond)
[13:20:53.291]                           for (restart in restarts) {
[13:20:53.291]                             name <- restart$name
[13:20:53.291]                             if (is.null(name)) 
[13:20:53.291]                               next
[13:20:53.291]                             if (!grepl(pattern, name)) 
[13:20:53.291]                               next
[13:20:53.291]                             invokeRestart(restart)
[13:20:53.291]                             muffled <- TRUE
[13:20:53.291]                             break
[13:20:53.291]                           }
[13:20:53.291]                         }
[13:20:53.291]                       }
[13:20:53.291]                       invisible(muffled)
[13:20:53.291]                     }
[13:20:53.291]                     muffleCondition(cond, pattern = "^muffle")
[13:20:53.291]                   }
[13:20:53.291]                 }
[13:20:53.291]             }
[13:20:53.291]         }))
[13:20:53.291]     }, error = function(ex) {
[13:20:53.291]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:53.291]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:53.291]                 ...future.rng), started = ...future.startTime, 
[13:20:53.291]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:53.291]             version = "1.8"), class = "FutureResult")
[13:20:53.291]     }, finally = {
[13:20:53.291]         if (!identical(...future.workdir, getwd())) 
[13:20:53.291]             setwd(...future.workdir)
[13:20:53.291]         {
[13:20:53.291]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:53.291]                 ...future.oldOptions$nwarnings <- NULL
[13:20:53.291]             }
[13:20:53.291]             base::options(...future.oldOptions)
[13:20:53.291]             if (.Platform$OS.type == "windows") {
[13:20:53.291]                 old_names <- names(...future.oldEnvVars)
[13:20:53.291]                 envs <- base::Sys.getenv()
[13:20:53.291]                 names <- names(envs)
[13:20:53.291]                 common <- intersect(names, old_names)
[13:20:53.291]                 added <- setdiff(names, old_names)
[13:20:53.291]                 removed <- setdiff(old_names, names)
[13:20:53.291]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:53.291]                   envs[common]]
[13:20:53.291]                 NAMES <- toupper(changed)
[13:20:53.291]                 args <- list()
[13:20:53.291]                 for (kk in seq_along(NAMES)) {
[13:20:53.291]                   name <- changed[[kk]]
[13:20:53.291]                   NAME <- NAMES[[kk]]
[13:20:53.291]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.291]                     next
[13:20:53.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:53.291]                 }
[13:20:53.291]                 NAMES <- toupper(added)
[13:20:53.291]                 for (kk in seq_along(NAMES)) {
[13:20:53.291]                   name <- added[[kk]]
[13:20:53.291]                   NAME <- NAMES[[kk]]
[13:20:53.291]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.291]                     next
[13:20:53.291]                   args[[name]] <- ""
[13:20:53.291]                 }
[13:20:53.291]                 NAMES <- toupper(removed)
[13:20:53.291]                 for (kk in seq_along(NAMES)) {
[13:20:53.291]                   name <- removed[[kk]]
[13:20:53.291]                   NAME <- NAMES[[kk]]
[13:20:53.291]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.291]                     next
[13:20:53.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:53.291]                 }
[13:20:53.291]                 if (length(args) > 0) 
[13:20:53.291]                   base::do.call(base::Sys.setenv, args = args)
[13:20:53.291]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:53.291]             }
[13:20:53.291]             else {
[13:20:53.291]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:53.291]             }
[13:20:53.291]             {
[13:20:53.291]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:53.291]                   0L) {
[13:20:53.291]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:53.291]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:53.291]                   base::options(opts)
[13:20:53.291]                 }
[13:20:53.291]                 {
[13:20:53.291]                   {
[13:20:53.291]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:53.291]                     NULL
[13:20:53.291]                   }
[13:20:53.291]                   options(future.plan = NULL)
[13:20:53.291]                   if (is.na(NA_character_)) 
[13:20:53.291]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:53.291]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:53.291]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:53.291]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:53.291]                     envir = parent.frame()) 
[13:20:53.291]                   {
[13:20:53.291]                     if (is.function(workers)) 
[13:20:53.291]                       workers <- workers()
[13:20:53.291]                     workers <- structure(as.integer(workers), 
[13:20:53.291]                       class = class(workers))
[13:20:53.291]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:53.291]                       workers >= 1)
[13:20:53.291]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:53.291]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:53.291]                     }
[13:20:53.291]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:53.291]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:53.291]                       envir = envir)
[13:20:53.291]                     if (!future$lazy) 
[13:20:53.291]                       future <- run(future)
[13:20:53.291]                     invisible(future)
[13:20:53.291]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:53.291]                 }
[13:20:53.291]             }
[13:20:53.291]         }
[13:20:53.291]     })
[13:20:53.291]     if (TRUE) {
[13:20:53.291]         base::sink(type = "output", split = FALSE)
[13:20:53.291]         if (TRUE) {
[13:20:53.291]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:53.291]         }
[13:20:53.291]         else {
[13:20:53.291]             ...future.result["stdout"] <- base::list(NULL)
[13:20:53.291]         }
[13:20:53.291]         base::close(...future.stdout)
[13:20:53.291]         ...future.stdout <- NULL
[13:20:53.291]     }
[13:20:53.291]     ...future.result$conditions <- ...future.conditions
[13:20:53.291]     ...future.result$finished <- base::Sys.time()
[13:20:53.291]     ...future.result
[13:20:53.291] }
[13:20:53.294] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[13:20:53.295] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[13:20:53.345] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[13:20:53.345] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[13:20:53.346] MultisessionFuture started
[13:20:53.346] - Launch lazy future ... done
[13:20:53.346] run() for ‘MultisessionFuture’ ... done
[13:20:53.346] result() for ClusterFuture ...
[13:20:53.346] receiveMessageFromWorker() for ClusterFuture ...
[13:20:53.347] - Validating connection of MultisessionFuture
[13:20:53.398] - received message: FutureResult
[13:20:53.398] - Received FutureResult
[13:20:53.398] - Erased future from FutureRegistry
[13:20:53.398] result() for ClusterFuture ...
[13:20:53.398] - result already collected: FutureResult
[13:20:53.399] result() for ClusterFuture ... done
[13:20:53.399] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:53.399] result() for ClusterFuture ... done
[13:20:53.399] result() for ClusterFuture ...
[13:20:53.399] - result already collected: FutureResult
[13:20:53.399] result() for ClusterFuture ... done
value(b) = 2
[13:20:53.399] result() for ClusterFuture ...
[13:20:53.399] - result already collected: FutureResult
[13:20:53.399] result() for ClusterFuture ... done
[13:20:53.400] result() for ClusterFuture ...
[13:20:53.400] - result already collected: FutureResult
[13:20:53.400] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:53.400] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:53.400] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:53.401] 
[13:20:53.401] Searching for globals ... DONE
[13:20:53.401] - globals: [0] <none>
[13:20:53.401] getGlobalsAndPackages() ... DONE
[13:20:53.401] run() for ‘Future’ ...
[13:20:53.401] - state: ‘created’
[13:20:53.402] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:53.416] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:53.416] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:53.416]   - Field: ‘node’
[13:20:53.416]   - Field: ‘label’
[13:20:53.416]   - Field: ‘local’
[13:20:53.416]   - Field: ‘owner’
[13:20:53.416]   - Field: ‘envir’
[13:20:53.416]   - Field: ‘workers’
[13:20:53.417]   - Field: ‘packages’
[13:20:53.417]   - Field: ‘gc’
[13:20:53.417]   - Field: ‘conditions’
[13:20:53.417]   - Field: ‘persistent’
[13:20:53.417]   - Field: ‘expr’
[13:20:53.417]   - Field: ‘uuid’
[13:20:53.417]   - Field: ‘seed’
[13:20:53.417]   - Field: ‘version’
[13:20:53.417]   - Field: ‘result’
[13:20:53.417]   - Field: ‘asynchronous’
[13:20:53.417]   - Field: ‘calls’
[13:20:53.418]   - Field: ‘globals’
[13:20:53.418]   - Field: ‘stdout’
[13:20:53.418]   - Field: ‘earlySignal’
[13:20:53.418]   - Field: ‘lazy’
[13:20:53.418]   - Field: ‘state’
[13:20:53.418] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:53.418] - Launch lazy future ...
[13:20:53.418] Packages needed by the future expression (n = 0): <none>
[13:20:53.418] Packages needed by future strategies (n = 0): <none>
[13:20:53.419] {
[13:20:53.419]     {
[13:20:53.419]         {
[13:20:53.419]             ...future.startTime <- base::Sys.time()
[13:20:53.419]             {
[13:20:53.419]                 {
[13:20:53.419]                   {
[13:20:53.419]                     {
[13:20:53.419]                       base::local({
[13:20:53.419]                         has_future <- base::requireNamespace("future", 
[13:20:53.419]                           quietly = TRUE)
[13:20:53.419]                         if (has_future) {
[13:20:53.419]                           ns <- base::getNamespace("future")
[13:20:53.419]                           version <- ns[[".package"]][["version"]]
[13:20:53.419]                           if (is.null(version)) 
[13:20:53.419]                             version <- utils::packageVersion("future")
[13:20:53.419]                         }
[13:20:53.419]                         else {
[13:20:53.419]                           version <- NULL
[13:20:53.419]                         }
[13:20:53.419]                         if (!has_future || version < "1.8.0") {
[13:20:53.419]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:53.419]                             "", base::R.version$version.string), 
[13:20:53.419]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:53.419]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:53.419]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:53.419]                               "release", "version")], collapse = " "), 
[13:20:53.419]                             hostname = base::Sys.info()[["nodename"]])
[13:20:53.419]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:53.419]                             info)
[13:20:53.419]                           info <- base::paste(info, collapse = "; ")
[13:20:53.419]                           if (!has_future) {
[13:20:53.419]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:53.419]                               info)
[13:20:53.419]                           }
[13:20:53.419]                           else {
[13:20:53.419]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:53.419]                               info, version)
[13:20:53.419]                           }
[13:20:53.419]                           base::stop(msg)
[13:20:53.419]                         }
[13:20:53.419]                       })
[13:20:53.419]                     }
[13:20:53.419]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:53.419]                     base::options(mc.cores = 1L)
[13:20:53.419]                   }
[13:20:53.419]                   options(future.plan = NULL)
[13:20:53.419]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:53.419]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:53.419]                 }
[13:20:53.419]                 ...future.workdir <- getwd()
[13:20:53.419]             }
[13:20:53.419]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:53.419]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:53.419]         }
[13:20:53.419]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:53.419]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:53.419]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:53.419]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:53.419]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:53.419]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:53.419]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:53.419]             base::names(...future.oldOptions))
[13:20:53.419]     }
[13:20:53.419]     if (FALSE) {
[13:20:53.419]     }
[13:20:53.419]     else {
[13:20:53.419]         if (TRUE) {
[13:20:53.419]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:53.419]                 open = "w")
[13:20:53.419]         }
[13:20:53.419]         else {
[13:20:53.419]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:53.419]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:53.419]         }
[13:20:53.419]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:53.419]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:53.419]             base::sink(type = "output", split = FALSE)
[13:20:53.419]             base::close(...future.stdout)
[13:20:53.419]         }, add = TRUE)
[13:20:53.419]     }
[13:20:53.419]     ...future.frame <- base::sys.nframe()
[13:20:53.419]     ...future.conditions <- base::list()
[13:20:53.419]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:53.419]     if (FALSE) {
[13:20:53.419]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:53.419]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:53.419]     }
[13:20:53.419]     ...future.result <- base::tryCatch({
[13:20:53.419]         base::withCallingHandlers({
[13:20:53.419]             ...future.value <- base::withVisible(base::local({
[13:20:53.419]                 ...future.makeSendCondition <- local({
[13:20:53.419]                   sendCondition <- NULL
[13:20:53.419]                   function(frame = 1L) {
[13:20:53.419]                     if (is.function(sendCondition)) 
[13:20:53.419]                       return(sendCondition)
[13:20:53.419]                     ns <- getNamespace("parallel")
[13:20:53.419]                     if (exists("sendData", mode = "function", 
[13:20:53.419]                       envir = ns)) {
[13:20:53.419]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:53.419]                         envir = ns)
[13:20:53.419]                       envir <- sys.frame(frame)
[13:20:53.419]                       master <- NULL
[13:20:53.419]                       while (!identical(envir, .GlobalEnv) && 
[13:20:53.419]                         !identical(envir, emptyenv())) {
[13:20:53.419]                         if (exists("master", mode = "list", envir = envir, 
[13:20:53.419]                           inherits = FALSE)) {
[13:20:53.419]                           master <- get("master", mode = "list", 
[13:20:53.419]                             envir = envir, inherits = FALSE)
[13:20:53.419]                           if (inherits(master, c("SOCKnode", 
[13:20:53.419]                             "SOCK0node"))) {
[13:20:53.419]                             sendCondition <<- function(cond) {
[13:20:53.419]                               data <- list(type = "VALUE", value = cond, 
[13:20:53.419]                                 success = TRUE)
[13:20:53.419]                               parallel_sendData(master, data)
[13:20:53.419]                             }
[13:20:53.419]                             return(sendCondition)
[13:20:53.419]                           }
[13:20:53.419]                         }
[13:20:53.419]                         frame <- frame + 1L
[13:20:53.419]                         envir <- sys.frame(frame)
[13:20:53.419]                       }
[13:20:53.419]                     }
[13:20:53.419]                     sendCondition <<- function(cond) NULL
[13:20:53.419]                   }
[13:20:53.419]                 })
[13:20:53.419]                 withCallingHandlers({
[13:20:53.419]                   1
[13:20:53.419]                 }, immediateCondition = function(cond) {
[13:20:53.419]                   sendCondition <- ...future.makeSendCondition()
[13:20:53.419]                   sendCondition(cond)
[13:20:53.419]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.419]                   {
[13:20:53.419]                     inherits <- base::inherits
[13:20:53.419]                     invokeRestart <- base::invokeRestart
[13:20:53.419]                     is.null <- base::is.null
[13:20:53.419]                     muffled <- FALSE
[13:20:53.419]                     if (inherits(cond, "message")) {
[13:20:53.419]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:53.419]                       if (muffled) 
[13:20:53.419]                         invokeRestart("muffleMessage")
[13:20:53.419]                     }
[13:20:53.419]                     else if (inherits(cond, "warning")) {
[13:20:53.419]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:53.419]                       if (muffled) 
[13:20:53.419]                         invokeRestart("muffleWarning")
[13:20:53.419]                     }
[13:20:53.419]                     else if (inherits(cond, "condition")) {
[13:20:53.419]                       if (!is.null(pattern)) {
[13:20:53.419]                         computeRestarts <- base::computeRestarts
[13:20:53.419]                         grepl <- base::grepl
[13:20:53.419]                         restarts <- computeRestarts(cond)
[13:20:53.419]                         for (restart in restarts) {
[13:20:53.419]                           name <- restart$name
[13:20:53.419]                           if (is.null(name)) 
[13:20:53.419]                             next
[13:20:53.419]                           if (!grepl(pattern, name)) 
[13:20:53.419]                             next
[13:20:53.419]                           invokeRestart(restart)
[13:20:53.419]                           muffled <- TRUE
[13:20:53.419]                           break
[13:20:53.419]                         }
[13:20:53.419]                       }
[13:20:53.419]                     }
[13:20:53.419]                     invisible(muffled)
[13:20:53.419]                   }
[13:20:53.419]                   muffleCondition(cond)
[13:20:53.419]                 })
[13:20:53.419]             }))
[13:20:53.419]             future::FutureResult(value = ...future.value$value, 
[13:20:53.419]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:53.419]                   ...future.rng), globalenv = if (FALSE) 
[13:20:53.419]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:53.419]                     ...future.globalenv.names))
[13:20:53.419]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:53.419]         }, condition = base::local({
[13:20:53.419]             c <- base::c
[13:20:53.419]             inherits <- base::inherits
[13:20:53.419]             invokeRestart <- base::invokeRestart
[13:20:53.419]             length <- base::length
[13:20:53.419]             list <- base::list
[13:20:53.419]             seq.int <- base::seq.int
[13:20:53.419]             signalCondition <- base::signalCondition
[13:20:53.419]             sys.calls <- base::sys.calls
[13:20:53.419]             `[[` <- base::`[[`
[13:20:53.419]             `+` <- base::`+`
[13:20:53.419]             `<<-` <- base::`<<-`
[13:20:53.419]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:53.419]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:53.419]                   3L)]
[13:20:53.419]             }
[13:20:53.419]             function(cond) {
[13:20:53.419]                 is_error <- inherits(cond, "error")
[13:20:53.419]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:53.419]                   NULL)
[13:20:53.419]                 if (is_error) {
[13:20:53.419]                   sessionInformation <- function() {
[13:20:53.419]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:53.419]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:53.419]                       search = base::search(), system = base::Sys.info())
[13:20:53.419]                   }
[13:20:53.419]                   ...future.conditions[[length(...future.conditions) + 
[13:20:53.419]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:53.419]                     cond$call), session = sessionInformation(), 
[13:20:53.419]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:53.419]                   signalCondition(cond)
[13:20:53.419]                 }
[13:20:53.419]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:53.419]                 "immediateCondition"))) {
[13:20:53.419]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:53.419]                   ...future.conditions[[length(...future.conditions) + 
[13:20:53.419]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:53.419]                   if (TRUE && !signal) {
[13:20:53.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.419]                     {
[13:20:53.419]                       inherits <- base::inherits
[13:20:53.419]                       invokeRestart <- base::invokeRestart
[13:20:53.419]                       is.null <- base::is.null
[13:20:53.419]                       muffled <- FALSE
[13:20:53.419]                       if (inherits(cond, "message")) {
[13:20:53.419]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:53.419]                         if (muffled) 
[13:20:53.419]                           invokeRestart("muffleMessage")
[13:20:53.419]                       }
[13:20:53.419]                       else if (inherits(cond, "warning")) {
[13:20:53.419]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:53.419]                         if (muffled) 
[13:20:53.419]                           invokeRestart("muffleWarning")
[13:20:53.419]                       }
[13:20:53.419]                       else if (inherits(cond, "condition")) {
[13:20:53.419]                         if (!is.null(pattern)) {
[13:20:53.419]                           computeRestarts <- base::computeRestarts
[13:20:53.419]                           grepl <- base::grepl
[13:20:53.419]                           restarts <- computeRestarts(cond)
[13:20:53.419]                           for (restart in restarts) {
[13:20:53.419]                             name <- restart$name
[13:20:53.419]                             if (is.null(name)) 
[13:20:53.419]                               next
[13:20:53.419]                             if (!grepl(pattern, name)) 
[13:20:53.419]                               next
[13:20:53.419]                             invokeRestart(restart)
[13:20:53.419]                             muffled <- TRUE
[13:20:53.419]                             break
[13:20:53.419]                           }
[13:20:53.419]                         }
[13:20:53.419]                       }
[13:20:53.419]                       invisible(muffled)
[13:20:53.419]                     }
[13:20:53.419]                     muffleCondition(cond, pattern = "^muffle")
[13:20:53.419]                   }
[13:20:53.419]                 }
[13:20:53.419]                 else {
[13:20:53.419]                   if (TRUE) {
[13:20:53.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.419]                     {
[13:20:53.419]                       inherits <- base::inherits
[13:20:53.419]                       invokeRestart <- base::invokeRestart
[13:20:53.419]                       is.null <- base::is.null
[13:20:53.419]                       muffled <- FALSE
[13:20:53.419]                       if (inherits(cond, "message")) {
[13:20:53.419]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:53.419]                         if (muffled) 
[13:20:53.419]                           invokeRestart("muffleMessage")
[13:20:53.419]                       }
[13:20:53.419]                       else if (inherits(cond, "warning")) {
[13:20:53.419]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:53.419]                         if (muffled) 
[13:20:53.419]                           invokeRestart("muffleWarning")
[13:20:53.419]                       }
[13:20:53.419]                       else if (inherits(cond, "condition")) {
[13:20:53.419]                         if (!is.null(pattern)) {
[13:20:53.419]                           computeRestarts <- base::computeRestarts
[13:20:53.419]                           grepl <- base::grepl
[13:20:53.419]                           restarts <- computeRestarts(cond)
[13:20:53.419]                           for (restart in restarts) {
[13:20:53.419]                             name <- restart$name
[13:20:53.419]                             if (is.null(name)) 
[13:20:53.419]                               next
[13:20:53.419]                             if (!grepl(pattern, name)) 
[13:20:53.419]                               next
[13:20:53.419]                             invokeRestart(restart)
[13:20:53.419]                             muffled <- TRUE
[13:20:53.419]                             break
[13:20:53.419]                           }
[13:20:53.419]                         }
[13:20:53.419]                       }
[13:20:53.419]                       invisible(muffled)
[13:20:53.419]                     }
[13:20:53.419]                     muffleCondition(cond, pattern = "^muffle")
[13:20:53.419]                   }
[13:20:53.419]                 }
[13:20:53.419]             }
[13:20:53.419]         }))
[13:20:53.419]     }, error = function(ex) {
[13:20:53.419]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:53.419]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:53.419]                 ...future.rng), started = ...future.startTime, 
[13:20:53.419]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:53.419]             version = "1.8"), class = "FutureResult")
[13:20:53.419]     }, finally = {
[13:20:53.419]         if (!identical(...future.workdir, getwd())) 
[13:20:53.419]             setwd(...future.workdir)
[13:20:53.419]         {
[13:20:53.419]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:53.419]                 ...future.oldOptions$nwarnings <- NULL
[13:20:53.419]             }
[13:20:53.419]             base::options(...future.oldOptions)
[13:20:53.419]             if (.Platform$OS.type == "windows") {
[13:20:53.419]                 old_names <- names(...future.oldEnvVars)
[13:20:53.419]                 envs <- base::Sys.getenv()
[13:20:53.419]                 names <- names(envs)
[13:20:53.419]                 common <- intersect(names, old_names)
[13:20:53.419]                 added <- setdiff(names, old_names)
[13:20:53.419]                 removed <- setdiff(old_names, names)
[13:20:53.419]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:53.419]                   envs[common]]
[13:20:53.419]                 NAMES <- toupper(changed)
[13:20:53.419]                 args <- list()
[13:20:53.419]                 for (kk in seq_along(NAMES)) {
[13:20:53.419]                   name <- changed[[kk]]
[13:20:53.419]                   NAME <- NAMES[[kk]]
[13:20:53.419]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.419]                     next
[13:20:53.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:53.419]                 }
[13:20:53.419]                 NAMES <- toupper(added)
[13:20:53.419]                 for (kk in seq_along(NAMES)) {
[13:20:53.419]                   name <- added[[kk]]
[13:20:53.419]                   NAME <- NAMES[[kk]]
[13:20:53.419]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.419]                     next
[13:20:53.419]                   args[[name]] <- ""
[13:20:53.419]                 }
[13:20:53.419]                 NAMES <- toupper(removed)
[13:20:53.419]                 for (kk in seq_along(NAMES)) {
[13:20:53.419]                   name <- removed[[kk]]
[13:20:53.419]                   NAME <- NAMES[[kk]]
[13:20:53.419]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.419]                     next
[13:20:53.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:53.419]                 }
[13:20:53.419]                 if (length(args) > 0) 
[13:20:53.419]                   base::do.call(base::Sys.setenv, args = args)
[13:20:53.419]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:53.419]             }
[13:20:53.419]             else {
[13:20:53.419]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:53.419]             }
[13:20:53.419]             {
[13:20:53.419]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:53.419]                   0L) {
[13:20:53.419]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:53.419]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:53.419]                   base::options(opts)
[13:20:53.419]                 }
[13:20:53.419]                 {
[13:20:53.419]                   {
[13:20:53.419]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:53.419]                     NULL
[13:20:53.419]                   }
[13:20:53.419]                   options(future.plan = NULL)
[13:20:53.419]                   if (is.na(NA_character_)) 
[13:20:53.419]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:53.419]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:53.419]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:53.419]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:53.419]                     envir = parent.frame()) 
[13:20:53.419]                   {
[13:20:53.419]                     if (is.function(workers)) 
[13:20:53.419]                       workers <- workers()
[13:20:53.419]                     workers <- structure(as.integer(workers), 
[13:20:53.419]                       class = class(workers))
[13:20:53.419]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:53.419]                       workers >= 1)
[13:20:53.419]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:53.419]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:53.419]                     }
[13:20:53.419]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:53.419]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:53.419]                       envir = envir)
[13:20:53.419]                     if (!future$lazy) 
[13:20:53.419]                       future <- run(future)
[13:20:53.419]                     invisible(future)
[13:20:53.419]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:53.419]                 }
[13:20:53.419]             }
[13:20:53.419]         }
[13:20:53.419]     })
[13:20:53.419]     if (TRUE) {
[13:20:53.419]         base::sink(type = "output", split = FALSE)
[13:20:53.419]         if (TRUE) {
[13:20:53.419]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:53.419]         }
[13:20:53.419]         else {
[13:20:53.419]             ...future.result["stdout"] <- base::list(NULL)
[13:20:53.419]         }
[13:20:53.419]         base::close(...future.stdout)
[13:20:53.419]         ...future.stdout <- NULL
[13:20:53.419]     }
[13:20:53.419]     ...future.result$conditions <- ...future.conditions
[13:20:53.419]     ...future.result$finished <- base::Sys.time()
[13:20:53.419]     ...future.result
[13:20:53.419] }
[13:20:53.422] MultisessionFuture started
[13:20:53.422] - Launch lazy future ... done
[13:20:53.422] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:53.423] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:53.423] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:53.424] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:53.424] Searching for globals ... DONE
[13:20:53.424] Resolving globals: TRUE
[13:20:53.424] Resolving any globals that are futures ...
[13:20:53.424] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:53.424] Resolving any globals that are futures ... DONE
[13:20:53.425] Resolving futures part of globals (recursively) ...
[13:20:53.425] resolve() on list ...
[13:20:53.425]  recursive: 99
[13:20:53.425]  length: 1
[13:20:53.425]  elements: ‘a’
[13:20:53.470] receiveMessageFromWorker() for ClusterFuture ...
[13:20:53.470] - Validating connection of MultisessionFuture
[13:20:53.470] - received message: FutureResult
[13:20:53.470] - Received FutureResult
[13:20:53.471] - Erased future from FutureRegistry
[13:20:53.471] result() for ClusterFuture ...
[13:20:53.471] - result already collected: FutureResult
[13:20:53.471] result() for ClusterFuture ... done
[13:20:53.471] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:53.471] Future #1
[13:20:53.471] result() for ClusterFuture ...
[13:20:53.471] - result already collected: FutureResult
[13:20:53.471] result() for ClusterFuture ... done
[13:20:53.471] result() for ClusterFuture ...
[13:20:53.471] - result already collected: FutureResult
[13:20:53.472] result() for ClusterFuture ... done
[13:20:53.472] A MultisessionFuture was resolved
[13:20:53.472]  length: 0 (resolved future 1)
[13:20:53.472] resolve() on list ... DONE
[13:20:53.472] - globals: [1] ‘a’
[13:20:53.472] Resolving futures part of globals (recursively) ... DONE
[13:20:53.473] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[13:20:53.474] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[13:20:53.474] - globals: [1] ‘a’
[13:20:53.474] - packages: [1] ‘future’
[13:20:53.474] getGlobalsAndPackages() ... DONE
[13:20:53.474] run() for ‘Future’ ...
[13:20:53.474] - state: ‘created’
[13:20:53.474] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:53.489] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:53.489] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:53.489]   - Field: ‘node’
[13:20:53.489]   - Field: ‘label’
[13:20:53.489]   - Field: ‘local’
[13:20:53.489]   - Field: ‘owner’
[13:20:53.490]   - Field: ‘envir’
[13:20:53.490]   - Field: ‘workers’
[13:20:53.490]   - Field: ‘packages’
[13:20:53.490]   - Field: ‘gc’
[13:20:53.490]   - Field: ‘conditions’
[13:20:53.490]   - Field: ‘persistent’
[13:20:53.490]   - Field: ‘expr’
[13:20:53.490]   - Field: ‘uuid’
[13:20:53.490]   - Field: ‘seed’
[13:20:53.490]   - Field: ‘version’
[13:20:53.491]   - Field: ‘result’
[13:20:53.491]   - Field: ‘asynchronous’
[13:20:53.491]   - Field: ‘calls’
[13:20:53.491]   - Field: ‘globals’
[13:20:53.491]   - Field: ‘stdout’
[13:20:53.491]   - Field: ‘earlySignal’
[13:20:53.491]   - Field: ‘lazy’
[13:20:53.491]   - Field: ‘state’
[13:20:53.491] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:53.491] - Launch lazy future ...
[13:20:53.492] Packages needed by the future expression (n = 1): ‘future’
[13:20:53.492] Packages needed by future strategies (n = 0): <none>
[13:20:53.492] {
[13:20:53.492]     {
[13:20:53.492]         {
[13:20:53.492]             ...future.startTime <- base::Sys.time()
[13:20:53.492]             {
[13:20:53.492]                 {
[13:20:53.492]                   {
[13:20:53.492]                     {
[13:20:53.492]                       {
[13:20:53.492]                         base::local({
[13:20:53.492]                           has_future <- base::requireNamespace("future", 
[13:20:53.492]                             quietly = TRUE)
[13:20:53.492]                           if (has_future) {
[13:20:53.492]                             ns <- base::getNamespace("future")
[13:20:53.492]                             version <- ns[[".package"]][["version"]]
[13:20:53.492]                             if (is.null(version)) 
[13:20:53.492]                               version <- utils::packageVersion("future")
[13:20:53.492]                           }
[13:20:53.492]                           else {
[13:20:53.492]                             version <- NULL
[13:20:53.492]                           }
[13:20:53.492]                           if (!has_future || version < "1.8.0") {
[13:20:53.492]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:53.492]                               "", base::R.version$version.string), 
[13:20:53.492]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:53.492]                                 base::R.version$platform, 8 * 
[13:20:53.492]                                   base::.Machine$sizeof.pointer), 
[13:20:53.492]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:53.492]                                 "release", "version")], collapse = " "), 
[13:20:53.492]                               hostname = base::Sys.info()[["nodename"]])
[13:20:53.492]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:53.492]                               info)
[13:20:53.492]                             info <- base::paste(info, collapse = "; ")
[13:20:53.492]                             if (!has_future) {
[13:20:53.492]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:53.492]                                 info)
[13:20:53.492]                             }
[13:20:53.492]                             else {
[13:20:53.492]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:53.492]                                 info, version)
[13:20:53.492]                             }
[13:20:53.492]                             base::stop(msg)
[13:20:53.492]                           }
[13:20:53.492]                         })
[13:20:53.492]                       }
[13:20:53.492]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:53.492]                       base::options(mc.cores = 1L)
[13:20:53.492]                     }
[13:20:53.492]                     base::local({
[13:20:53.492]                       for (pkg in "future") {
[13:20:53.492]                         base::loadNamespace(pkg)
[13:20:53.492]                         base::library(pkg, character.only = TRUE)
[13:20:53.492]                       }
[13:20:53.492]                     })
[13:20:53.492]                   }
[13:20:53.492]                   options(future.plan = NULL)
[13:20:53.492]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:53.492]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:53.492]                 }
[13:20:53.492]                 ...future.workdir <- getwd()
[13:20:53.492]             }
[13:20:53.492]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:53.492]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:53.492]         }
[13:20:53.492]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:53.492]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:53.492]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:53.492]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:53.492]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:53.492]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:53.492]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:53.492]             base::names(...future.oldOptions))
[13:20:53.492]     }
[13:20:53.492]     if (FALSE) {
[13:20:53.492]     }
[13:20:53.492]     else {
[13:20:53.492]         if (TRUE) {
[13:20:53.492]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:53.492]                 open = "w")
[13:20:53.492]         }
[13:20:53.492]         else {
[13:20:53.492]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:53.492]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:53.492]         }
[13:20:53.492]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:53.492]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:53.492]             base::sink(type = "output", split = FALSE)
[13:20:53.492]             base::close(...future.stdout)
[13:20:53.492]         }, add = TRUE)
[13:20:53.492]     }
[13:20:53.492]     ...future.frame <- base::sys.nframe()
[13:20:53.492]     ...future.conditions <- base::list()
[13:20:53.492]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:53.492]     if (FALSE) {
[13:20:53.492]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:53.492]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:53.492]     }
[13:20:53.492]     ...future.result <- base::tryCatch({
[13:20:53.492]         base::withCallingHandlers({
[13:20:53.492]             ...future.value <- base::withVisible(base::local({
[13:20:53.492]                 ...future.makeSendCondition <- local({
[13:20:53.492]                   sendCondition <- NULL
[13:20:53.492]                   function(frame = 1L) {
[13:20:53.492]                     if (is.function(sendCondition)) 
[13:20:53.492]                       return(sendCondition)
[13:20:53.492]                     ns <- getNamespace("parallel")
[13:20:53.492]                     if (exists("sendData", mode = "function", 
[13:20:53.492]                       envir = ns)) {
[13:20:53.492]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:53.492]                         envir = ns)
[13:20:53.492]                       envir <- sys.frame(frame)
[13:20:53.492]                       master <- NULL
[13:20:53.492]                       while (!identical(envir, .GlobalEnv) && 
[13:20:53.492]                         !identical(envir, emptyenv())) {
[13:20:53.492]                         if (exists("master", mode = "list", envir = envir, 
[13:20:53.492]                           inherits = FALSE)) {
[13:20:53.492]                           master <- get("master", mode = "list", 
[13:20:53.492]                             envir = envir, inherits = FALSE)
[13:20:53.492]                           if (inherits(master, c("SOCKnode", 
[13:20:53.492]                             "SOCK0node"))) {
[13:20:53.492]                             sendCondition <<- function(cond) {
[13:20:53.492]                               data <- list(type = "VALUE", value = cond, 
[13:20:53.492]                                 success = TRUE)
[13:20:53.492]                               parallel_sendData(master, data)
[13:20:53.492]                             }
[13:20:53.492]                             return(sendCondition)
[13:20:53.492]                           }
[13:20:53.492]                         }
[13:20:53.492]                         frame <- frame + 1L
[13:20:53.492]                         envir <- sys.frame(frame)
[13:20:53.492]                       }
[13:20:53.492]                     }
[13:20:53.492]                     sendCondition <<- function(cond) NULL
[13:20:53.492]                   }
[13:20:53.492]                 })
[13:20:53.492]                 withCallingHandlers({
[13:20:53.492]                   value(a) + 1
[13:20:53.492]                 }, immediateCondition = function(cond) {
[13:20:53.492]                   sendCondition <- ...future.makeSendCondition()
[13:20:53.492]                   sendCondition(cond)
[13:20:53.492]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.492]                   {
[13:20:53.492]                     inherits <- base::inherits
[13:20:53.492]                     invokeRestart <- base::invokeRestart
[13:20:53.492]                     is.null <- base::is.null
[13:20:53.492]                     muffled <- FALSE
[13:20:53.492]                     if (inherits(cond, "message")) {
[13:20:53.492]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:53.492]                       if (muffled) 
[13:20:53.492]                         invokeRestart("muffleMessage")
[13:20:53.492]                     }
[13:20:53.492]                     else if (inherits(cond, "warning")) {
[13:20:53.492]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:53.492]                       if (muffled) 
[13:20:53.492]                         invokeRestart("muffleWarning")
[13:20:53.492]                     }
[13:20:53.492]                     else if (inherits(cond, "condition")) {
[13:20:53.492]                       if (!is.null(pattern)) {
[13:20:53.492]                         computeRestarts <- base::computeRestarts
[13:20:53.492]                         grepl <- base::grepl
[13:20:53.492]                         restarts <- computeRestarts(cond)
[13:20:53.492]                         for (restart in restarts) {
[13:20:53.492]                           name <- restart$name
[13:20:53.492]                           if (is.null(name)) 
[13:20:53.492]                             next
[13:20:53.492]                           if (!grepl(pattern, name)) 
[13:20:53.492]                             next
[13:20:53.492]                           invokeRestart(restart)
[13:20:53.492]                           muffled <- TRUE
[13:20:53.492]                           break
[13:20:53.492]                         }
[13:20:53.492]                       }
[13:20:53.492]                     }
[13:20:53.492]                     invisible(muffled)
[13:20:53.492]                   }
[13:20:53.492]                   muffleCondition(cond)
[13:20:53.492]                 })
[13:20:53.492]             }))
[13:20:53.492]             future::FutureResult(value = ...future.value$value, 
[13:20:53.492]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:53.492]                   ...future.rng), globalenv = if (FALSE) 
[13:20:53.492]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:53.492]                     ...future.globalenv.names))
[13:20:53.492]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:53.492]         }, condition = base::local({
[13:20:53.492]             c <- base::c
[13:20:53.492]             inherits <- base::inherits
[13:20:53.492]             invokeRestart <- base::invokeRestart
[13:20:53.492]             length <- base::length
[13:20:53.492]             list <- base::list
[13:20:53.492]             seq.int <- base::seq.int
[13:20:53.492]             signalCondition <- base::signalCondition
[13:20:53.492]             sys.calls <- base::sys.calls
[13:20:53.492]             `[[` <- base::`[[`
[13:20:53.492]             `+` <- base::`+`
[13:20:53.492]             `<<-` <- base::`<<-`
[13:20:53.492]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:53.492]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:53.492]                   3L)]
[13:20:53.492]             }
[13:20:53.492]             function(cond) {
[13:20:53.492]                 is_error <- inherits(cond, "error")
[13:20:53.492]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:53.492]                   NULL)
[13:20:53.492]                 if (is_error) {
[13:20:53.492]                   sessionInformation <- function() {
[13:20:53.492]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:53.492]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:53.492]                       search = base::search(), system = base::Sys.info())
[13:20:53.492]                   }
[13:20:53.492]                   ...future.conditions[[length(...future.conditions) + 
[13:20:53.492]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:53.492]                     cond$call), session = sessionInformation(), 
[13:20:53.492]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:53.492]                   signalCondition(cond)
[13:20:53.492]                 }
[13:20:53.492]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:53.492]                 "immediateCondition"))) {
[13:20:53.492]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:53.492]                   ...future.conditions[[length(...future.conditions) + 
[13:20:53.492]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:53.492]                   if (TRUE && !signal) {
[13:20:53.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.492]                     {
[13:20:53.492]                       inherits <- base::inherits
[13:20:53.492]                       invokeRestart <- base::invokeRestart
[13:20:53.492]                       is.null <- base::is.null
[13:20:53.492]                       muffled <- FALSE
[13:20:53.492]                       if (inherits(cond, "message")) {
[13:20:53.492]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:53.492]                         if (muffled) 
[13:20:53.492]                           invokeRestart("muffleMessage")
[13:20:53.492]                       }
[13:20:53.492]                       else if (inherits(cond, "warning")) {
[13:20:53.492]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:53.492]                         if (muffled) 
[13:20:53.492]                           invokeRestart("muffleWarning")
[13:20:53.492]                       }
[13:20:53.492]                       else if (inherits(cond, "condition")) {
[13:20:53.492]                         if (!is.null(pattern)) {
[13:20:53.492]                           computeRestarts <- base::computeRestarts
[13:20:53.492]                           grepl <- base::grepl
[13:20:53.492]                           restarts <- computeRestarts(cond)
[13:20:53.492]                           for (restart in restarts) {
[13:20:53.492]                             name <- restart$name
[13:20:53.492]                             if (is.null(name)) 
[13:20:53.492]                               next
[13:20:53.492]                             if (!grepl(pattern, name)) 
[13:20:53.492]                               next
[13:20:53.492]                             invokeRestart(restart)
[13:20:53.492]                             muffled <- TRUE
[13:20:53.492]                             break
[13:20:53.492]                           }
[13:20:53.492]                         }
[13:20:53.492]                       }
[13:20:53.492]                       invisible(muffled)
[13:20:53.492]                     }
[13:20:53.492]                     muffleCondition(cond, pattern = "^muffle")
[13:20:53.492]                   }
[13:20:53.492]                 }
[13:20:53.492]                 else {
[13:20:53.492]                   if (TRUE) {
[13:20:53.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.492]                     {
[13:20:53.492]                       inherits <- base::inherits
[13:20:53.492]                       invokeRestart <- base::invokeRestart
[13:20:53.492]                       is.null <- base::is.null
[13:20:53.492]                       muffled <- FALSE
[13:20:53.492]                       if (inherits(cond, "message")) {
[13:20:53.492]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:53.492]                         if (muffled) 
[13:20:53.492]                           invokeRestart("muffleMessage")
[13:20:53.492]                       }
[13:20:53.492]                       else if (inherits(cond, "warning")) {
[13:20:53.492]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:53.492]                         if (muffled) 
[13:20:53.492]                           invokeRestart("muffleWarning")
[13:20:53.492]                       }
[13:20:53.492]                       else if (inherits(cond, "condition")) {
[13:20:53.492]                         if (!is.null(pattern)) {
[13:20:53.492]                           computeRestarts <- base::computeRestarts
[13:20:53.492]                           grepl <- base::grepl
[13:20:53.492]                           restarts <- computeRestarts(cond)
[13:20:53.492]                           for (restart in restarts) {
[13:20:53.492]                             name <- restart$name
[13:20:53.492]                             if (is.null(name)) 
[13:20:53.492]                               next
[13:20:53.492]                             if (!grepl(pattern, name)) 
[13:20:53.492]                               next
[13:20:53.492]                             invokeRestart(restart)
[13:20:53.492]                             muffled <- TRUE
[13:20:53.492]                             break
[13:20:53.492]                           }
[13:20:53.492]                         }
[13:20:53.492]                       }
[13:20:53.492]                       invisible(muffled)
[13:20:53.492]                     }
[13:20:53.492]                     muffleCondition(cond, pattern = "^muffle")
[13:20:53.492]                   }
[13:20:53.492]                 }
[13:20:53.492]             }
[13:20:53.492]         }))
[13:20:53.492]     }, error = function(ex) {
[13:20:53.492]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:53.492]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:53.492]                 ...future.rng), started = ...future.startTime, 
[13:20:53.492]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:53.492]             version = "1.8"), class = "FutureResult")
[13:20:53.492]     }, finally = {
[13:20:53.492]         if (!identical(...future.workdir, getwd())) 
[13:20:53.492]             setwd(...future.workdir)
[13:20:53.492]         {
[13:20:53.492]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:53.492]                 ...future.oldOptions$nwarnings <- NULL
[13:20:53.492]             }
[13:20:53.492]             base::options(...future.oldOptions)
[13:20:53.492]             if (.Platform$OS.type == "windows") {
[13:20:53.492]                 old_names <- names(...future.oldEnvVars)
[13:20:53.492]                 envs <- base::Sys.getenv()
[13:20:53.492]                 names <- names(envs)
[13:20:53.492]                 common <- intersect(names, old_names)
[13:20:53.492]                 added <- setdiff(names, old_names)
[13:20:53.492]                 removed <- setdiff(old_names, names)
[13:20:53.492]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:53.492]                   envs[common]]
[13:20:53.492]                 NAMES <- toupper(changed)
[13:20:53.492]                 args <- list()
[13:20:53.492]                 for (kk in seq_along(NAMES)) {
[13:20:53.492]                   name <- changed[[kk]]
[13:20:53.492]                   NAME <- NAMES[[kk]]
[13:20:53.492]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.492]                     next
[13:20:53.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:53.492]                 }
[13:20:53.492]                 NAMES <- toupper(added)
[13:20:53.492]                 for (kk in seq_along(NAMES)) {
[13:20:53.492]                   name <- added[[kk]]
[13:20:53.492]                   NAME <- NAMES[[kk]]
[13:20:53.492]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.492]                     next
[13:20:53.492]                   args[[name]] <- ""
[13:20:53.492]                 }
[13:20:53.492]                 NAMES <- toupper(removed)
[13:20:53.492]                 for (kk in seq_along(NAMES)) {
[13:20:53.492]                   name <- removed[[kk]]
[13:20:53.492]                   NAME <- NAMES[[kk]]
[13:20:53.492]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.492]                     next
[13:20:53.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:53.492]                 }
[13:20:53.492]                 if (length(args) > 0) 
[13:20:53.492]                   base::do.call(base::Sys.setenv, args = args)
[13:20:53.492]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:53.492]             }
[13:20:53.492]             else {
[13:20:53.492]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:53.492]             }
[13:20:53.492]             {
[13:20:53.492]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:53.492]                   0L) {
[13:20:53.492]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:53.492]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:53.492]                   base::options(opts)
[13:20:53.492]                 }
[13:20:53.492]                 {
[13:20:53.492]                   {
[13:20:53.492]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:53.492]                     NULL
[13:20:53.492]                   }
[13:20:53.492]                   options(future.plan = NULL)
[13:20:53.492]                   if (is.na(NA_character_)) 
[13:20:53.492]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:53.492]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:53.492]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:53.492]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:53.492]                     envir = parent.frame()) 
[13:20:53.492]                   {
[13:20:53.492]                     if (is.function(workers)) 
[13:20:53.492]                       workers <- workers()
[13:20:53.492]                     workers <- structure(as.integer(workers), 
[13:20:53.492]                       class = class(workers))
[13:20:53.492]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:53.492]                       workers >= 1)
[13:20:53.492]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:53.492]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:53.492]                     }
[13:20:53.492]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:53.492]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:53.492]                       envir = envir)
[13:20:53.492]                     if (!future$lazy) 
[13:20:53.492]                       future <- run(future)
[13:20:53.492]                     invisible(future)
[13:20:53.492]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:53.492]                 }
[13:20:53.492]             }
[13:20:53.492]         }
[13:20:53.492]     })
[13:20:53.492]     if (TRUE) {
[13:20:53.492]         base::sink(type = "output", split = FALSE)
[13:20:53.492]         if (TRUE) {
[13:20:53.492]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:53.492]         }
[13:20:53.492]         else {
[13:20:53.492]             ...future.result["stdout"] <- base::list(NULL)
[13:20:53.492]         }
[13:20:53.492]         base::close(...future.stdout)
[13:20:53.492]         ...future.stdout <- NULL
[13:20:53.492]     }
[13:20:53.492]     ...future.result$conditions <- ...future.conditions
[13:20:53.492]     ...future.result$finished <- base::Sys.time()
[13:20:53.492]     ...future.result
[13:20:53.492] }
[13:20:53.495] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[13:20:53.496] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[13:20:53.549] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[13:20:53.549] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[13:20:53.550] MultisessionFuture started
[13:20:53.550] - Launch lazy future ... done
[13:20:53.550] run() for ‘MultisessionFuture’ ... done
[13:20:53.550] result() for ClusterFuture ...
[13:20:53.550] receiveMessageFromWorker() for ClusterFuture ...
[13:20:53.550] - Validating connection of MultisessionFuture
[13:20:53.598] - received message: FutureResult
[13:20:53.599] - Received FutureResult
[13:20:53.599] - Erased future from FutureRegistry
[13:20:53.599] result() for ClusterFuture ...
[13:20:53.599] - result already collected: FutureResult
[13:20:53.599] result() for ClusterFuture ... done
[13:20:53.599] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:53.599] result() for ClusterFuture ... done
[13:20:53.599] result() for ClusterFuture ...
[13:20:53.600] - result already collected: FutureResult
[13:20:53.600] result() for ClusterFuture ... done
value(b) = 2
[13:20:53.600] result() for ClusterFuture ...
[13:20:53.600] - result already collected: FutureResult
[13:20:53.600] result() for ClusterFuture ... done
[13:20:53.600] result() for ClusterFuture ...
[13:20:53.600] - result already collected: FutureResult
[13:20:53.600] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:53.601] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:53.601] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:53.601] 
[13:20:53.602] Searching for globals ... DONE
[13:20:53.602] - globals: [0] <none>
[13:20:53.602] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:53.602] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:53.602] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:53.603] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:53.603] Searching for globals ... DONE
[13:20:53.603] Resolving globals: TRUE
[13:20:53.603] Resolving any globals that are futures ...
[13:20:53.604] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:53.604] Resolving any globals that are futures ... DONE
[13:20:53.604] Resolving futures part of globals (recursively) ...
[13:20:53.604] resolve() on list ...
[13:20:53.604]  recursive: 99
[13:20:53.604]  length: 1
[13:20:53.605]  elements: ‘a’
[13:20:53.605] run() for ‘Future’ ...
[13:20:53.605] - state: ‘created’
[13:20:53.605] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:53.619] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:53.620] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:53.620]   - Field: ‘node’
[13:20:53.620]   - Field: ‘label’
[13:20:53.620]   - Field: ‘local’
[13:20:53.620]   - Field: ‘owner’
[13:20:53.620]   - Field: ‘envir’
[13:20:53.620]   - Field: ‘workers’
[13:20:53.620]   - Field: ‘packages’
[13:20:53.620]   - Field: ‘gc’
[13:20:53.620]   - Field: ‘conditions’
[13:20:53.621]   - Field: ‘persistent’
[13:20:53.621]   - Field: ‘expr’
[13:20:53.621]   - Field: ‘uuid’
[13:20:53.621]   - Field: ‘seed’
[13:20:53.621]   - Field: ‘version’
[13:20:53.621]   - Field: ‘result’
[13:20:53.621]   - Field: ‘asynchronous’
[13:20:53.621]   - Field: ‘calls’
[13:20:53.621]   - Field: ‘globals’
[13:20:53.621]   - Field: ‘stdout’
[13:20:53.622]   - Field: ‘earlySignal’
[13:20:53.622]   - Field: ‘lazy’
[13:20:53.622]   - Field: ‘state’
[13:20:53.622] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:53.622] - Launch lazy future ...
[13:20:53.622] Packages needed by the future expression (n = 0): <none>
[13:20:53.622] Packages needed by future strategies (n = 0): <none>
[13:20:53.623] {
[13:20:53.623]     {
[13:20:53.623]         {
[13:20:53.623]             ...future.startTime <- base::Sys.time()
[13:20:53.623]             {
[13:20:53.623]                 {
[13:20:53.623]                   {
[13:20:53.623]                     {
[13:20:53.623]                       base::local({
[13:20:53.623]                         has_future <- base::requireNamespace("future", 
[13:20:53.623]                           quietly = TRUE)
[13:20:53.623]                         if (has_future) {
[13:20:53.623]                           ns <- base::getNamespace("future")
[13:20:53.623]                           version <- ns[[".package"]][["version"]]
[13:20:53.623]                           if (is.null(version)) 
[13:20:53.623]                             version <- utils::packageVersion("future")
[13:20:53.623]                         }
[13:20:53.623]                         else {
[13:20:53.623]                           version <- NULL
[13:20:53.623]                         }
[13:20:53.623]                         if (!has_future || version < "1.8.0") {
[13:20:53.623]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:53.623]                             "", base::R.version$version.string), 
[13:20:53.623]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:53.623]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:53.623]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:53.623]                               "release", "version")], collapse = " "), 
[13:20:53.623]                             hostname = base::Sys.info()[["nodename"]])
[13:20:53.623]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:53.623]                             info)
[13:20:53.623]                           info <- base::paste(info, collapse = "; ")
[13:20:53.623]                           if (!has_future) {
[13:20:53.623]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:53.623]                               info)
[13:20:53.623]                           }
[13:20:53.623]                           else {
[13:20:53.623]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:53.623]                               info, version)
[13:20:53.623]                           }
[13:20:53.623]                           base::stop(msg)
[13:20:53.623]                         }
[13:20:53.623]                       })
[13:20:53.623]                     }
[13:20:53.623]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:53.623]                     base::options(mc.cores = 1L)
[13:20:53.623]                   }
[13:20:53.623]                   options(future.plan = NULL)
[13:20:53.623]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:53.623]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:53.623]                 }
[13:20:53.623]                 ...future.workdir <- getwd()
[13:20:53.623]             }
[13:20:53.623]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:53.623]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:53.623]         }
[13:20:53.623]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:53.623]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:53.623]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:53.623]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:53.623]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:53.623]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:53.623]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:53.623]             base::names(...future.oldOptions))
[13:20:53.623]     }
[13:20:53.623]     if (FALSE) {
[13:20:53.623]     }
[13:20:53.623]     else {
[13:20:53.623]         if (TRUE) {
[13:20:53.623]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:53.623]                 open = "w")
[13:20:53.623]         }
[13:20:53.623]         else {
[13:20:53.623]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:53.623]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:53.623]         }
[13:20:53.623]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:53.623]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:53.623]             base::sink(type = "output", split = FALSE)
[13:20:53.623]             base::close(...future.stdout)
[13:20:53.623]         }, add = TRUE)
[13:20:53.623]     }
[13:20:53.623]     ...future.frame <- base::sys.nframe()
[13:20:53.623]     ...future.conditions <- base::list()
[13:20:53.623]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:53.623]     if (FALSE) {
[13:20:53.623]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:53.623]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:53.623]     }
[13:20:53.623]     ...future.result <- base::tryCatch({
[13:20:53.623]         base::withCallingHandlers({
[13:20:53.623]             ...future.value <- base::withVisible(base::local({
[13:20:53.623]                 ...future.makeSendCondition <- local({
[13:20:53.623]                   sendCondition <- NULL
[13:20:53.623]                   function(frame = 1L) {
[13:20:53.623]                     if (is.function(sendCondition)) 
[13:20:53.623]                       return(sendCondition)
[13:20:53.623]                     ns <- getNamespace("parallel")
[13:20:53.623]                     if (exists("sendData", mode = "function", 
[13:20:53.623]                       envir = ns)) {
[13:20:53.623]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:53.623]                         envir = ns)
[13:20:53.623]                       envir <- sys.frame(frame)
[13:20:53.623]                       master <- NULL
[13:20:53.623]                       while (!identical(envir, .GlobalEnv) && 
[13:20:53.623]                         !identical(envir, emptyenv())) {
[13:20:53.623]                         if (exists("master", mode = "list", envir = envir, 
[13:20:53.623]                           inherits = FALSE)) {
[13:20:53.623]                           master <- get("master", mode = "list", 
[13:20:53.623]                             envir = envir, inherits = FALSE)
[13:20:53.623]                           if (inherits(master, c("SOCKnode", 
[13:20:53.623]                             "SOCK0node"))) {
[13:20:53.623]                             sendCondition <<- function(cond) {
[13:20:53.623]                               data <- list(type = "VALUE", value = cond, 
[13:20:53.623]                                 success = TRUE)
[13:20:53.623]                               parallel_sendData(master, data)
[13:20:53.623]                             }
[13:20:53.623]                             return(sendCondition)
[13:20:53.623]                           }
[13:20:53.623]                         }
[13:20:53.623]                         frame <- frame + 1L
[13:20:53.623]                         envir <- sys.frame(frame)
[13:20:53.623]                       }
[13:20:53.623]                     }
[13:20:53.623]                     sendCondition <<- function(cond) NULL
[13:20:53.623]                   }
[13:20:53.623]                 })
[13:20:53.623]                 withCallingHandlers({
[13:20:53.623]                   1
[13:20:53.623]                 }, immediateCondition = function(cond) {
[13:20:53.623]                   sendCondition <- ...future.makeSendCondition()
[13:20:53.623]                   sendCondition(cond)
[13:20:53.623]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.623]                   {
[13:20:53.623]                     inherits <- base::inherits
[13:20:53.623]                     invokeRestart <- base::invokeRestart
[13:20:53.623]                     is.null <- base::is.null
[13:20:53.623]                     muffled <- FALSE
[13:20:53.623]                     if (inherits(cond, "message")) {
[13:20:53.623]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:53.623]                       if (muffled) 
[13:20:53.623]                         invokeRestart("muffleMessage")
[13:20:53.623]                     }
[13:20:53.623]                     else if (inherits(cond, "warning")) {
[13:20:53.623]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:53.623]                       if (muffled) 
[13:20:53.623]                         invokeRestart("muffleWarning")
[13:20:53.623]                     }
[13:20:53.623]                     else if (inherits(cond, "condition")) {
[13:20:53.623]                       if (!is.null(pattern)) {
[13:20:53.623]                         computeRestarts <- base::computeRestarts
[13:20:53.623]                         grepl <- base::grepl
[13:20:53.623]                         restarts <- computeRestarts(cond)
[13:20:53.623]                         for (restart in restarts) {
[13:20:53.623]                           name <- restart$name
[13:20:53.623]                           if (is.null(name)) 
[13:20:53.623]                             next
[13:20:53.623]                           if (!grepl(pattern, name)) 
[13:20:53.623]                             next
[13:20:53.623]                           invokeRestart(restart)
[13:20:53.623]                           muffled <- TRUE
[13:20:53.623]                           break
[13:20:53.623]                         }
[13:20:53.623]                       }
[13:20:53.623]                     }
[13:20:53.623]                     invisible(muffled)
[13:20:53.623]                   }
[13:20:53.623]                   muffleCondition(cond)
[13:20:53.623]                 })
[13:20:53.623]             }))
[13:20:53.623]             future::FutureResult(value = ...future.value$value, 
[13:20:53.623]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:53.623]                   ...future.rng), globalenv = if (FALSE) 
[13:20:53.623]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:53.623]                     ...future.globalenv.names))
[13:20:53.623]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:53.623]         }, condition = base::local({
[13:20:53.623]             c <- base::c
[13:20:53.623]             inherits <- base::inherits
[13:20:53.623]             invokeRestart <- base::invokeRestart
[13:20:53.623]             length <- base::length
[13:20:53.623]             list <- base::list
[13:20:53.623]             seq.int <- base::seq.int
[13:20:53.623]             signalCondition <- base::signalCondition
[13:20:53.623]             sys.calls <- base::sys.calls
[13:20:53.623]             `[[` <- base::`[[`
[13:20:53.623]             `+` <- base::`+`
[13:20:53.623]             `<<-` <- base::`<<-`
[13:20:53.623]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:53.623]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:53.623]                   3L)]
[13:20:53.623]             }
[13:20:53.623]             function(cond) {
[13:20:53.623]                 is_error <- inherits(cond, "error")
[13:20:53.623]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:53.623]                   NULL)
[13:20:53.623]                 if (is_error) {
[13:20:53.623]                   sessionInformation <- function() {
[13:20:53.623]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:53.623]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:53.623]                       search = base::search(), system = base::Sys.info())
[13:20:53.623]                   }
[13:20:53.623]                   ...future.conditions[[length(...future.conditions) + 
[13:20:53.623]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:53.623]                     cond$call), session = sessionInformation(), 
[13:20:53.623]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:53.623]                   signalCondition(cond)
[13:20:53.623]                 }
[13:20:53.623]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:53.623]                 "immediateCondition"))) {
[13:20:53.623]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:53.623]                   ...future.conditions[[length(...future.conditions) + 
[13:20:53.623]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:53.623]                   if (TRUE && !signal) {
[13:20:53.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.623]                     {
[13:20:53.623]                       inherits <- base::inherits
[13:20:53.623]                       invokeRestart <- base::invokeRestart
[13:20:53.623]                       is.null <- base::is.null
[13:20:53.623]                       muffled <- FALSE
[13:20:53.623]                       if (inherits(cond, "message")) {
[13:20:53.623]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:53.623]                         if (muffled) 
[13:20:53.623]                           invokeRestart("muffleMessage")
[13:20:53.623]                       }
[13:20:53.623]                       else if (inherits(cond, "warning")) {
[13:20:53.623]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:53.623]                         if (muffled) 
[13:20:53.623]                           invokeRestart("muffleWarning")
[13:20:53.623]                       }
[13:20:53.623]                       else if (inherits(cond, "condition")) {
[13:20:53.623]                         if (!is.null(pattern)) {
[13:20:53.623]                           computeRestarts <- base::computeRestarts
[13:20:53.623]                           grepl <- base::grepl
[13:20:53.623]                           restarts <- computeRestarts(cond)
[13:20:53.623]                           for (restart in restarts) {
[13:20:53.623]                             name <- restart$name
[13:20:53.623]                             if (is.null(name)) 
[13:20:53.623]                               next
[13:20:53.623]                             if (!grepl(pattern, name)) 
[13:20:53.623]                               next
[13:20:53.623]                             invokeRestart(restart)
[13:20:53.623]                             muffled <- TRUE
[13:20:53.623]                             break
[13:20:53.623]                           }
[13:20:53.623]                         }
[13:20:53.623]                       }
[13:20:53.623]                       invisible(muffled)
[13:20:53.623]                     }
[13:20:53.623]                     muffleCondition(cond, pattern = "^muffle")
[13:20:53.623]                   }
[13:20:53.623]                 }
[13:20:53.623]                 else {
[13:20:53.623]                   if (TRUE) {
[13:20:53.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.623]                     {
[13:20:53.623]                       inherits <- base::inherits
[13:20:53.623]                       invokeRestart <- base::invokeRestart
[13:20:53.623]                       is.null <- base::is.null
[13:20:53.623]                       muffled <- FALSE
[13:20:53.623]                       if (inherits(cond, "message")) {
[13:20:53.623]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:53.623]                         if (muffled) 
[13:20:53.623]                           invokeRestart("muffleMessage")
[13:20:53.623]                       }
[13:20:53.623]                       else if (inherits(cond, "warning")) {
[13:20:53.623]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:53.623]                         if (muffled) 
[13:20:53.623]                           invokeRestart("muffleWarning")
[13:20:53.623]                       }
[13:20:53.623]                       else if (inherits(cond, "condition")) {
[13:20:53.623]                         if (!is.null(pattern)) {
[13:20:53.623]                           computeRestarts <- base::computeRestarts
[13:20:53.623]                           grepl <- base::grepl
[13:20:53.623]                           restarts <- computeRestarts(cond)
[13:20:53.623]                           for (restart in restarts) {
[13:20:53.623]                             name <- restart$name
[13:20:53.623]                             if (is.null(name)) 
[13:20:53.623]                               next
[13:20:53.623]                             if (!grepl(pattern, name)) 
[13:20:53.623]                               next
[13:20:53.623]                             invokeRestart(restart)
[13:20:53.623]                             muffled <- TRUE
[13:20:53.623]                             break
[13:20:53.623]                           }
[13:20:53.623]                         }
[13:20:53.623]                       }
[13:20:53.623]                       invisible(muffled)
[13:20:53.623]                     }
[13:20:53.623]                     muffleCondition(cond, pattern = "^muffle")
[13:20:53.623]                   }
[13:20:53.623]                 }
[13:20:53.623]             }
[13:20:53.623]         }))
[13:20:53.623]     }, error = function(ex) {
[13:20:53.623]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:53.623]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:53.623]                 ...future.rng), started = ...future.startTime, 
[13:20:53.623]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:53.623]             version = "1.8"), class = "FutureResult")
[13:20:53.623]     }, finally = {
[13:20:53.623]         if (!identical(...future.workdir, getwd())) 
[13:20:53.623]             setwd(...future.workdir)
[13:20:53.623]         {
[13:20:53.623]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:53.623]                 ...future.oldOptions$nwarnings <- NULL
[13:20:53.623]             }
[13:20:53.623]             base::options(...future.oldOptions)
[13:20:53.623]             if (.Platform$OS.type == "windows") {
[13:20:53.623]                 old_names <- names(...future.oldEnvVars)
[13:20:53.623]                 envs <- base::Sys.getenv()
[13:20:53.623]                 names <- names(envs)
[13:20:53.623]                 common <- intersect(names, old_names)
[13:20:53.623]                 added <- setdiff(names, old_names)
[13:20:53.623]                 removed <- setdiff(old_names, names)
[13:20:53.623]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:53.623]                   envs[common]]
[13:20:53.623]                 NAMES <- toupper(changed)
[13:20:53.623]                 args <- list()
[13:20:53.623]                 for (kk in seq_along(NAMES)) {
[13:20:53.623]                   name <- changed[[kk]]
[13:20:53.623]                   NAME <- NAMES[[kk]]
[13:20:53.623]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.623]                     next
[13:20:53.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:53.623]                 }
[13:20:53.623]                 NAMES <- toupper(added)
[13:20:53.623]                 for (kk in seq_along(NAMES)) {
[13:20:53.623]                   name <- added[[kk]]
[13:20:53.623]                   NAME <- NAMES[[kk]]
[13:20:53.623]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.623]                     next
[13:20:53.623]                   args[[name]] <- ""
[13:20:53.623]                 }
[13:20:53.623]                 NAMES <- toupper(removed)
[13:20:53.623]                 for (kk in seq_along(NAMES)) {
[13:20:53.623]                   name <- removed[[kk]]
[13:20:53.623]                   NAME <- NAMES[[kk]]
[13:20:53.623]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.623]                     next
[13:20:53.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:53.623]                 }
[13:20:53.623]                 if (length(args) > 0) 
[13:20:53.623]                   base::do.call(base::Sys.setenv, args = args)
[13:20:53.623]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:53.623]             }
[13:20:53.623]             else {
[13:20:53.623]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:53.623]             }
[13:20:53.623]             {
[13:20:53.623]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:53.623]                   0L) {
[13:20:53.623]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:53.623]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:53.623]                   base::options(opts)
[13:20:53.623]                 }
[13:20:53.623]                 {
[13:20:53.623]                   {
[13:20:53.623]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:53.623]                     NULL
[13:20:53.623]                   }
[13:20:53.623]                   options(future.plan = NULL)
[13:20:53.623]                   if (is.na(NA_character_)) 
[13:20:53.623]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:53.623]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:53.623]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:53.623]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:53.623]                     envir = parent.frame()) 
[13:20:53.623]                   {
[13:20:53.623]                     if (is.function(workers)) 
[13:20:53.623]                       workers <- workers()
[13:20:53.623]                     workers <- structure(as.integer(workers), 
[13:20:53.623]                       class = class(workers))
[13:20:53.623]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:53.623]                       workers >= 1)
[13:20:53.623]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:53.623]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:53.623]                     }
[13:20:53.623]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:53.623]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:53.623]                       envir = envir)
[13:20:53.623]                     if (!future$lazy) 
[13:20:53.623]                       future <- run(future)
[13:20:53.623]                     invisible(future)
[13:20:53.623]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:53.623]                 }
[13:20:53.623]             }
[13:20:53.623]         }
[13:20:53.623]     })
[13:20:53.623]     if (TRUE) {
[13:20:53.623]         base::sink(type = "output", split = FALSE)
[13:20:53.623]         if (TRUE) {
[13:20:53.623]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:53.623]         }
[13:20:53.623]         else {
[13:20:53.623]             ...future.result["stdout"] <- base::list(NULL)
[13:20:53.623]         }
[13:20:53.623]         base::close(...future.stdout)
[13:20:53.623]         ...future.stdout <- NULL
[13:20:53.623]     }
[13:20:53.623]     ...future.result$conditions <- ...future.conditions
[13:20:53.623]     ...future.result$finished <- base::Sys.time()
[13:20:53.623]     ...future.result
[13:20:53.623] }
[13:20:53.626] MultisessionFuture started
[13:20:53.626] - Launch lazy future ... done
[13:20:53.626] run() for ‘MultisessionFuture’ ... done
[13:20:53.674] receiveMessageFromWorker() for ClusterFuture ...
[13:20:53.674] - Validating connection of MultisessionFuture
[13:20:53.674] - received message: FutureResult
[13:20:53.674] - Received FutureResult
[13:20:53.674] - Erased future from FutureRegistry
[13:20:53.674] result() for ClusterFuture ...
[13:20:53.675] - result already collected: FutureResult
[13:20:53.675] result() for ClusterFuture ... done
[13:20:53.675] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:53.675] Future #1
[13:20:53.675] result() for ClusterFuture ...
[13:20:53.675] - result already collected: FutureResult
[13:20:53.675] result() for ClusterFuture ... done
[13:20:53.675] result() for ClusterFuture ...
[13:20:53.675] - result already collected: FutureResult
[13:20:53.675] result() for ClusterFuture ... done
[13:20:53.676] A MultisessionFuture was resolved
[13:20:53.676]  length: 0 (resolved future 1)
[13:20:53.676] resolve() on list ... DONE
[13:20:53.676] - globals: [1] ‘a’
[13:20:53.676] Resolving futures part of globals (recursively) ... DONE
[13:20:53.677] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[13:20:53.677] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[13:20:53.678] - globals: [1] ‘a’
[13:20:53.678] - packages: [1] ‘future’
[13:20:53.678] getGlobalsAndPackages() ... DONE
[13:20:53.678] run() for ‘Future’ ...
[13:20:53.678] - state: ‘created’
[13:20:53.678] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:53.693] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:53.693] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:53.693]   - Field: ‘node’
[13:20:53.693]   - Field: ‘label’
[13:20:53.693]   - Field: ‘local’
[13:20:53.693]   - Field: ‘owner’
[13:20:53.694]   - Field: ‘envir’
[13:20:53.694]   - Field: ‘workers’
[13:20:53.694]   - Field: ‘packages’
[13:20:53.694]   - Field: ‘gc’
[13:20:53.694]   - Field: ‘conditions’
[13:20:53.694]   - Field: ‘persistent’
[13:20:53.694]   - Field: ‘expr’
[13:20:53.694]   - Field: ‘uuid’
[13:20:53.694]   - Field: ‘seed’
[13:20:53.694]   - Field: ‘version’
[13:20:53.694]   - Field: ‘result’
[13:20:53.695]   - Field: ‘asynchronous’
[13:20:53.695]   - Field: ‘calls’
[13:20:53.695]   - Field: ‘globals’
[13:20:53.695]   - Field: ‘stdout’
[13:20:53.695]   - Field: ‘earlySignal’
[13:20:53.695]   - Field: ‘lazy’
[13:20:53.695]   - Field: ‘state’
[13:20:53.695] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:53.695] - Launch lazy future ...
[13:20:53.696] Packages needed by the future expression (n = 1): ‘future’
[13:20:53.696] Packages needed by future strategies (n = 0): <none>
[13:20:53.696] {
[13:20:53.696]     {
[13:20:53.696]         {
[13:20:53.696]             ...future.startTime <- base::Sys.time()
[13:20:53.696]             {
[13:20:53.696]                 {
[13:20:53.696]                   {
[13:20:53.696]                     {
[13:20:53.696]                       {
[13:20:53.696]                         base::local({
[13:20:53.696]                           has_future <- base::requireNamespace("future", 
[13:20:53.696]                             quietly = TRUE)
[13:20:53.696]                           if (has_future) {
[13:20:53.696]                             ns <- base::getNamespace("future")
[13:20:53.696]                             version <- ns[[".package"]][["version"]]
[13:20:53.696]                             if (is.null(version)) 
[13:20:53.696]                               version <- utils::packageVersion("future")
[13:20:53.696]                           }
[13:20:53.696]                           else {
[13:20:53.696]                             version <- NULL
[13:20:53.696]                           }
[13:20:53.696]                           if (!has_future || version < "1.8.0") {
[13:20:53.696]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:53.696]                               "", base::R.version$version.string), 
[13:20:53.696]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:53.696]                                 base::R.version$platform, 8 * 
[13:20:53.696]                                   base::.Machine$sizeof.pointer), 
[13:20:53.696]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:53.696]                                 "release", "version")], collapse = " "), 
[13:20:53.696]                               hostname = base::Sys.info()[["nodename"]])
[13:20:53.696]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:53.696]                               info)
[13:20:53.696]                             info <- base::paste(info, collapse = "; ")
[13:20:53.696]                             if (!has_future) {
[13:20:53.696]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:53.696]                                 info)
[13:20:53.696]                             }
[13:20:53.696]                             else {
[13:20:53.696]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:53.696]                                 info, version)
[13:20:53.696]                             }
[13:20:53.696]                             base::stop(msg)
[13:20:53.696]                           }
[13:20:53.696]                         })
[13:20:53.696]                       }
[13:20:53.696]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:53.696]                       base::options(mc.cores = 1L)
[13:20:53.696]                     }
[13:20:53.696]                     base::local({
[13:20:53.696]                       for (pkg in "future") {
[13:20:53.696]                         base::loadNamespace(pkg)
[13:20:53.696]                         base::library(pkg, character.only = TRUE)
[13:20:53.696]                       }
[13:20:53.696]                     })
[13:20:53.696]                   }
[13:20:53.696]                   options(future.plan = NULL)
[13:20:53.696]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:53.696]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:53.696]                 }
[13:20:53.696]                 ...future.workdir <- getwd()
[13:20:53.696]             }
[13:20:53.696]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:53.696]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:53.696]         }
[13:20:53.696]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:53.696]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:53.696]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:53.696]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:53.696]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:53.696]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:53.696]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:53.696]             base::names(...future.oldOptions))
[13:20:53.696]     }
[13:20:53.696]     if (FALSE) {
[13:20:53.696]     }
[13:20:53.696]     else {
[13:20:53.696]         if (TRUE) {
[13:20:53.696]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:53.696]                 open = "w")
[13:20:53.696]         }
[13:20:53.696]         else {
[13:20:53.696]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:53.696]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:53.696]         }
[13:20:53.696]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:53.696]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:53.696]             base::sink(type = "output", split = FALSE)
[13:20:53.696]             base::close(...future.stdout)
[13:20:53.696]         }, add = TRUE)
[13:20:53.696]     }
[13:20:53.696]     ...future.frame <- base::sys.nframe()
[13:20:53.696]     ...future.conditions <- base::list()
[13:20:53.696]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:53.696]     if (FALSE) {
[13:20:53.696]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:53.696]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:53.696]     }
[13:20:53.696]     ...future.result <- base::tryCatch({
[13:20:53.696]         base::withCallingHandlers({
[13:20:53.696]             ...future.value <- base::withVisible(base::local({
[13:20:53.696]                 ...future.makeSendCondition <- local({
[13:20:53.696]                   sendCondition <- NULL
[13:20:53.696]                   function(frame = 1L) {
[13:20:53.696]                     if (is.function(sendCondition)) 
[13:20:53.696]                       return(sendCondition)
[13:20:53.696]                     ns <- getNamespace("parallel")
[13:20:53.696]                     if (exists("sendData", mode = "function", 
[13:20:53.696]                       envir = ns)) {
[13:20:53.696]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:53.696]                         envir = ns)
[13:20:53.696]                       envir <- sys.frame(frame)
[13:20:53.696]                       master <- NULL
[13:20:53.696]                       while (!identical(envir, .GlobalEnv) && 
[13:20:53.696]                         !identical(envir, emptyenv())) {
[13:20:53.696]                         if (exists("master", mode = "list", envir = envir, 
[13:20:53.696]                           inherits = FALSE)) {
[13:20:53.696]                           master <- get("master", mode = "list", 
[13:20:53.696]                             envir = envir, inherits = FALSE)
[13:20:53.696]                           if (inherits(master, c("SOCKnode", 
[13:20:53.696]                             "SOCK0node"))) {
[13:20:53.696]                             sendCondition <<- function(cond) {
[13:20:53.696]                               data <- list(type = "VALUE", value = cond, 
[13:20:53.696]                                 success = TRUE)
[13:20:53.696]                               parallel_sendData(master, data)
[13:20:53.696]                             }
[13:20:53.696]                             return(sendCondition)
[13:20:53.696]                           }
[13:20:53.696]                         }
[13:20:53.696]                         frame <- frame + 1L
[13:20:53.696]                         envir <- sys.frame(frame)
[13:20:53.696]                       }
[13:20:53.696]                     }
[13:20:53.696]                     sendCondition <<- function(cond) NULL
[13:20:53.696]                   }
[13:20:53.696]                 })
[13:20:53.696]                 withCallingHandlers({
[13:20:53.696]                   value(a) + 1
[13:20:53.696]                 }, immediateCondition = function(cond) {
[13:20:53.696]                   sendCondition <- ...future.makeSendCondition()
[13:20:53.696]                   sendCondition(cond)
[13:20:53.696]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.696]                   {
[13:20:53.696]                     inherits <- base::inherits
[13:20:53.696]                     invokeRestart <- base::invokeRestart
[13:20:53.696]                     is.null <- base::is.null
[13:20:53.696]                     muffled <- FALSE
[13:20:53.696]                     if (inherits(cond, "message")) {
[13:20:53.696]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:53.696]                       if (muffled) 
[13:20:53.696]                         invokeRestart("muffleMessage")
[13:20:53.696]                     }
[13:20:53.696]                     else if (inherits(cond, "warning")) {
[13:20:53.696]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:53.696]                       if (muffled) 
[13:20:53.696]                         invokeRestart("muffleWarning")
[13:20:53.696]                     }
[13:20:53.696]                     else if (inherits(cond, "condition")) {
[13:20:53.696]                       if (!is.null(pattern)) {
[13:20:53.696]                         computeRestarts <- base::computeRestarts
[13:20:53.696]                         grepl <- base::grepl
[13:20:53.696]                         restarts <- computeRestarts(cond)
[13:20:53.696]                         for (restart in restarts) {
[13:20:53.696]                           name <- restart$name
[13:20:53.696]                           if (is.null(name)) 
[13:20:53.696]                             next
[13:20:53.696]                           if (!grepl(pattern, name)) 
[13:20:53.696]                             next
[13:20:53.696]                           invokeRestart(restart)
[13:20:53.696]                           muffled <- TRUE
[13:20:53.696]                           break
[13:20:53.696]                         }
[13:20:53.696]                       }
[13:20:53.696]                     }
[13:20:53.696]                     invisible(muffled)
[13:20:53.696]                   }
[13:20:53.696]                   muffleCondition(cond)
[13:20:53.696]                 })
[13:20:53.696]             }))
[13:20:53.696]             future::FutureResult(value = ...future.value$value, 
[13:20:53.696]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:53.696]                   ...future.rng), globalenv = if (FALSE) 
[13:20:53.696]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:53.696]                     ...future.globalenv.names))
[13:20:53.696]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:53.696]         }, condition = base::local({
[13:20:53.696]             c <- base::c
[13:20:53.696]             inherits <- base::inherits
[13:20:53.696]             invokeRestart <- base::invokeRestart
[13:20:53.696]             length <- base::length
[13:20:53.696]             list <- base::list
[13:20:53.696]             seq.int <- base::seq.int
[13:20:53.696]             signalCondition <- base::signalCondition
[13:20:53.696]             sys.calls <- base::sys.calls
[13:20:53.696]             `[[` <- base::`[[`
[13:20:53.696]             `+` <- base::`+`
[13:20:53.696]             `<<-` <- base::`<<-`
[13:20:53.696]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:53.696]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:53.696]                   3L)]
[13:20:53.696]             }
[13:20:53.696]             function(cond) {
[13:20:53.696]                 is_error <- inherits(cond, "error")
[13:20:53.696]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:53.696]                   NULL)
[13:20:53.696]                 if (is_error) {
[13:20:53.696]                   sessionInformation <- function() {
[13:20:53.696]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:53.696]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:53.696]                       search = base::search(), system = base::Sys.info())
[13:20:53.696]                   }
[13:20:53.696]                   ...future.conditions[[length(...future.conditions) + 
[13:20:53.696]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:53.696]                     cond$call), session = sessionInformation(), 
[13:20:53.696]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:53.696]                   signalCondition(cond)
[13:20:53.696]                 }
[13:20:53.696]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:53.696]                 "immediateCondition"))) {
[13:20:53.696]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:53.696]                   ...future.conditions[[length(...future.conditions) + 
[13:20:53.696]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:53.696]                   if (TRUE && !signal) {
[13:20:53.696]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.696]                     {
[13:20:53.696]                       inherits <- base::inherits
[13:20:53.696]                       invokeRestart <- base::invokeRestart
[13:20:53.696]                       is.null <- base::is.null
[13:20:53.696]                       muffled <- FALSE
[13:20:53.696]                       if (inherits(cond, "message")) {
[13:20:53.696]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:53.696]                         if (muffled) 
[13:20:53.696]                           invokeRestart("muffleMessage")
[13:20:53.696]                       }
[13:20:53.696]                       else if (inherits(cond, "warning")) {
[13:20:53.696]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:53.696]                         if (muffled) 
[13:20:53.696]                           invokeRestart("muffleWarning")
[13:20:53.696]                       }
[13:20:53.696]                       else if (inherits(cond, "condition")) {
[13:20:53.696]                         if (!is.null(pattern)) {
[13:20:53.696]                           computeRestarts <- base::computeRestarts
[13:20:53.696]                           grepl <- base::grepl
[13:20:53.696]                           restarts <- computeRestarts(cond)
[13:20:53.696]                           for (restart in restarts) {
[13:20:53.696]                             name <- restart$name
[13:20:53.696]                             if (is.null(name)) 
[13:20:53.696]                               next
[13:20:53.696]                             if (!grepl(pattern, name)) 
[13:20:53.696]                               next
[13:20:53.696]                             invokeRestart(restart)
[13:20:53.696]                             muffled <- TRUE
[13:20:53.696]                             break
[13:20:53.696]                           }
[13:20:53.696]                         }
[13:20:53.696]                       }
[13:20:53.696]                       invisible(muffled)
[13:20:53.696]                     }
[13:20:53.696]                     muffleCondition(cond, pattern = "^muffle")
[13:20:53.696]                   }
[13:20:53.696]                 }
[13:20:53.696]                 else {
[13:20:53.696]                   if (TRUE) {
[13:20:53.696]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.696]                     {
[13:20:53.696]                       inherits <- base::inherits
[13:20:53.696]                       invokeRestart <- base::invokeRestart
[13:20:53.696]                       is.null <- base::is.null
[13:20:53.696]                       muffled <- FALSE
[13:20:53.696]                       if (inherits(cond, "message")) {
[13:20:53.696]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:53.696]                         if (muffled) 
[13:20:53.696]                           invokeRestart("muffleMessage")
[13:20:53.696]                       }
[13:20:53.696]                       else if (inherits(cond, "warning")) {
[13:20:53.696]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:53.696]                         if (muffled) 
[13:20:53.696]                           invokeRestart("muffleWarning")
[13:20:53.696]                       }
[13:20:53.696]                       else if (inherits(cond, "condition")) {
[13:20:53.696]                         if (!is.null(pattern)) {
[13:20:53.696]                           computeRestarts <- base::computeRestarts
[13:20:53.696]                           grepl <- base::grepl
[13:20:53.696]                           restarts <- computeRestarts(cond)
[13:20:53.696]                           for (restart in restarts) {
[13:20:53.696]                             name <- restart$name
[13:20:53.696]                             if (is.null(name)) 
[13:20:53.696]                               next
[13:20:53.696]                             if (!grepl(pattern, name)) 
[13:20:53.696]                               next
[13:20:53.696]                             invokeRestart(restart)
[13:20:53.696]                             muffled <- TRUE
[13:20:53.696]                             break
[13:20:53.696]                           }
[13:20:53.696]                         }
[13:20:53.696]                       }
[13:20:53.696]                       invisible(muffled)
[13:20:53.696]                     }
[13:20:53.696]                     muffleCondition(cond, pattern = "^muffle")
[13:20:53.696]                   }
[13:20:53.696]                 }
[13:20:53.696]             }
[13:20:53.696]         }))
[13:20:53.696]     }, error = function(ex) {
[13:20:53.696]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:53.696]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:53.696]                 ...future.rng), started = ...future.startTime, 
[13:20:53.696]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:53.696]             version = "1.8"), class = "FutureResult")
[13:20:53.696]     }, finally = {
[13:20:53.696]         if (!identical(...future.workdir, getwd())) 
[13:20:53.696]             setwd(...future.workdir)
[13:20:53.696]         {
[13:20:53.696]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:53.696]                 ...future.oldOptions$nwarnings <- NULL
[13:20:53.696]             }
[13:20:53.696]             base::options(...future.oldOptions)
[13:20:53.696]             if (.Platform$OS.type == "windows") {
[13:20:53.696]                 old_names <- names(...future.oldEnvVars)
[13:20:53.696]                 envs <- base::Sys.getenv()
[13:20:53.696]                 names <- names(envs)
[13:20:53.696]                 common <- intersect(names, old_names)
[13:20:53.696]                 added <- setdiff(names, old_names)
[13:20:53.696]                 removed <- setdiff(old_names, names)
[13:20:53.696]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:53.696]                   envs[common]]
[13:20:53.696]                 NAMES <- toupper(changed)
[13:20:53.696]                 args <- list()
[13:20:53.696]                 for (kk in seq_along(NAMES)) {
[13:20:53.696]                   name <- changed[[kk]]
[13:20:53.696]                   NAME <- NAMES[[kk]]
[13:20:53.696]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.696]                     next
[13:20:53.696]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:53.696]                 }
[13:20:53.696]                 NAMES <- toupper(added)
[13:20:53.696]                 for (kk in seq_along(NAMES)) {
[13:20:53.696]                   name <- added[[kk]]
[13:20:53.696]                   NAME <- NAMES[[kk]]
[13:20:53.696]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.696]                     next
[13:20:53.696]                   args[[name]] <- ""
[13:20:53.696]                 }
[13:20:53.696]                 NAMES <- toupper(removed)
[13:20:53.696]                 for (kk in seq_along(NAMES)) {
[13:20:53.696]                   name <- removed[[kk]]
[13:20:53.696]                   NAME <- NAMES[[kk]]
[13:20:53.696]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.696]                     next
[13:20:53.696]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:53.696]                 }
[13:20:53.696]                 if (length(args) > 0) 
[13:20:53.696]                   base::do.call(base::Sys.setenv, args = args)
[13:20:53.696]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:53.696]             }
[13:20:53.696]             else {
[13:20:53.696]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:53.696]             }
[13:20:53.696]             {
[13:20:53.696]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:53.696]                   0L) {
[13:20:53.696]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:53.696]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:53.696]                   base::options(opts)
[13:20:53.696]                 }
[13:20:53.696]                 {
[13:20:53.696]                   {
[13:20:53.696]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:53.696]                     NULL
[13:20:53.696]                   }
[13:20:53.696]                   options(future.plan = NULL)
[13:20:53.696]                   if (is.na(NA_character_)) 
[13:20:53.696]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:53.696]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:53.696]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:53.696]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:53.696]                     envir = parent.frame()) 
[13:20:53.696]                   {
[13:20:53.696]                     if (is.function(workers)) 
[13:20:53.696]                       workers <- workers()
[13:20:53.696]                     workers <- structure(as.integer(workers), 
[13:20:53.696]                       class = class(workers))
[13:20:53.696]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:53.696]                       workers >= 1)
[13:20:53.696]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:53.696]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:53.696]                     }
[13:20:53.696]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:53.696]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:53.696]                       envir = envir)
[13:20:53.696]                     if (!future$lazy) 
[13:20:53.696]                       future <- run(future)
[13:20:53.696]                     invisible(future)
[13:20:53.696]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:53.696]                 }
[13:20:53.696]             }
[13:20:53.696]         }
[13:20:53.696]     })
[13:20:53.696]     if (TRUE) {
[13:20:53.696]         base::sink(type = "output", split = FALSE)
[13:20:53.696]         if (TRUE) {
[13:20:53.696]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:53.696]         }
[13:20:53.696]         else {
[13:20:53.696]             ...future.result["stdout"] <- base::list(NULL)
[13:20:53.696]         }
[13:20:53.696]         base::close(...future.stdout)
[13:20:53.696]         ...future.stdout <- NULL
[13:20:53.696]     }
[13:20:53.696]     ...future.result$conditions <- ...future.conditions
[13:20:53.696]     ...future.result$finished <- base::Sys.time()
[13:20:53.696]     ...future.result
[13:20:53.696] }
[13:20:53.699] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[13:20:53.700] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[13:20:53.753] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[13:20:53.753] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[13:20:53.754] MultisessionFuture started
[13:20:53.754] - Launch lazy future ... done
[13:20:53.754] run() for ‘MultisessionFuture’ ... done
[13:20:53.754] result() for ClusterFuture ...
[13:20:53.754] receiveMessageFromWorker() for ClusterFuture ...
[13:20:53.755] - Validating connection of MultisessionFuture
[13:20:53.802] - received message: FutureResult
[13:20:53.802] - Received FutureResult
[13:20:53.802] - Erased future from FutureRegistry
[13:20:53.803] result() for ClusterFuture ...
[13:20:53.803] - result already collected: FutureResult
[13:20:53.803] result() for ClusterFuture ... done
[13:20:53.803] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:53.803] result() for ClusterFuture ... done
[13:20:53.803] result() for ClusterFuture ...
[13:20:53.803] - result already collected: FutureResult
[13:20:53.803] result() for ClusterFuture ... done
value(b) = 2
[13:20:53.803] result() for ClusterFuture ...
[13:20:53.804] - result already collected: FutureResult
[13:20:53.804] result() for ClusterFuture ... done
[13:20:53.804] result() for ClusterFuture ...
[13:20:53.804] - result already collected: FutureResult
[13:20:53.804] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:53.804] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:53.804] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:53.805] 
[13:20:53.805] Searching for globals ... DONE
[13:20:53.805] - globals: [0] <none>
[13:20:53.805] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:53.806] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:53.806] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:53.807] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:53.807] Searching for globals ... DONE
[13:20:53.807] Resolving globals: TRUE
[13:20:53.807] Resolving any globals that are futures ...
[13:20:53.807] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:53.807] Resolving any globals that are futures ... DONE
[13:20:53.808] Resolving futures part of globals (recursively) ...
[13:20:53.808] resolve() on list ...
[13:20:53.808]  recursive: 99
[13:20:53.808]  length: 1
[13:20:53.808]  elements: ‘a’
[13:20:53.808] run() for ‘Future’ ...
[13:20:53.809] - state: ‘created’
[13:20:53.811] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:53.825] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:53.825] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:53.825]   - Field: ‘node’
[13:20:53.826]   - Field: ‘label’
[13:20:53.826]   - Field: ‘local’
[13:20:53.826]   - Field: ‘owner’
[13:20:53.826]   - Field: ‘envir’
[13:20:53.826]   - Field: ‘workers’
[13:20:53.826]   - Field: ‘packages’
[13:20:53.826]   - Field: ‘gc’
[13:20:53.826]   - Field: ‘conditions’
[13:20:53.826]   - Field: ‘persistent’
[13:20:53.826]   - Field: ‘expr’
[13:20:53.826]   - Field: ‘uuid’
[13:20:53.827]   - Field: ‘seed’
[13:20:53.827]   - Field: ‘version’
[13:20:53.827]   - Field: ‘result’
[13:20:53.827]   - Field: ‘asynchronous’
[13:20:53.827]   - Field: ‘calls’
[13:20:53.827]   - Field: ‘globals’
[13:20:53.827]   - Field: ‘stdout’
[13:20:53.827]   - Field: ‘earlySignal’
[13:20:53.827]   - Field: ‘lazy’
[13:20:53.827]   - Field: ‘state’
[13:20:53.827] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:53.828] - Launch lazy future ...
[13:20:53.828] Packages needed by the future expression (n = 0): <none>
[13:20:53.828] Packages needed by future strategies (n = 0): <none>
[13:20:53.828] {
[13:20:53.828]     {
[13:20:53.828]         {
[13:20:53.828]             ...future.startTime <- base::Sys.time()
[13:20:53.828]             {
[13:20:53.828]                 {
[13:20:53.828]                   {
[13:20:53.828]                     {
[13:20:53.828]                       base::local({
[13:20:53.828]                         has_future <- base::requireNamespace("future", 
[13:20:53.828]                           quietly = TRUE)
[13:20:53.828]                         if (has_future) {
[13:20:53.828]                           ns <- base::getNamespace("future")
[13:20:53.828]                           version <- ns[[".package"]][["version"]]
[13:20:53.828]                           if (is.null(version)) 
[13:20:53.828]                             version <- utils::packageVersion("future")
[13:20:53.828]                         }
[13:20:53.828]                         else {
[13:20:53.828]                           version <- NULL
[13:20:53.828]                         }
[13:20:53.828]                         if (!has_future || version < "1.8.0") {
[13:20:53.828]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:53.828]                             "", base::R.version$version.string), 
[13:20:53.828]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:53.828]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:53.828]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:53.828]                               "release", "version")], collapse = " "), 
[13:20:53.828]                             hostname = base::Sys.info()[["nodename"]])
[13:20:53.828]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:53.828]                             info)
[13:20:53.828]                           info <- base::paste(info, collapse = "; ")
[13:20:53.828]                           if (!has_future) {
[13:20:53.828]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:53.828]                               info)
[13:20:53.828]                           }
[13:20:53.828]                           else {
[13:20:53.828]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:53.828]                               info, version)
[13:20:53.828]                           }
[13:20:53.828]                           base::stop(msg)
[13:20:53.828]                         }
[13:20:53.828]                       })
[13:20:53.828]                     }
[13:20:53.828]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:53.828]                     base::options(mc.cores = 1L)
[13:20:53.828]                   }
[13:20:53.828]                   options(future.plan = NULL)
[13:20:53.828]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:53.828]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:53.828]                 }
[13:20:53.828]                 ...future.workdir <- getwd()
[13:20:53.828]             }
[13:20:53.828]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:53.828]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:53.828]         }
[13:20:53.828]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:53.828]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:53.828]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:53.828]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:53.828]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:53.828]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:53.828]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:53.828]             base::names(...future.oldOptions))
[13:20:53.828]     }
[13:20:53.828]     if (FALSE) {
[13:20:53.828]     }
[13:20:53.828]     else {
[13:20:53.828]         if (TRUE) {
[13:20:53.828]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:53.828]                 open = "w")
[13:20:53.828]         }
[13:20:53.828]         else {
[13:20:53.828]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:53.828]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:53.828]         }
[13:20:53.828]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:53.828]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:53.828]             base::sink(type = "output", split = FALSE)
[13:20:53.828]             base::close(...future.stdout)
[13:20:53.828]         }, add = TRUE)
[13:20:53.828]     }
[13:20:53.828]     ...future.frame <- base::sys.nframe()
[13:20:53.828]     ...future.conditions <- base::list()
[13:20:53.828]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:53.828]     if (FALSE) {
[13:20:53.828]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:53.828]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:53.828]     }
[13:20:53.828]     ...future.result <- base::tryCatch({
[13:20:53.828]         base::withCallingHandlers({
[13:20:53.828]             ...future.value <- base::withVisible(base::local({
[13:20:53.828]                 ...future.makeSendCondition <- local({
[13:20:53.828]                   sendCondition <- NULL
[13:20:53.828]                   function(frame = 1L) {
[13:20:53.828]                     if (is.function(sendCondition)) 
[13:20:53.828]                       return(sendCondition)
[13:20:53.828]                     ns <- getNamespace("parallel")
[13:20:53.828]                     if (exists("sendData", mode = "function", 
[13:20:53.828]                       envir = ns)) {
[13:20:53.828]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:53.828]                         envir = ns)
[13:20:53.828]                       envir <- sys.frame(frame)
[13:20:53.828]                       master <- NULL
[13:20:53.828]                       while (!identical(envir, .GlobalEnv) && 
[13:20:53.828]                         !identical(envir, emptyenv())) {
[13:20:53.828]                         if (exists("master", mode = "list", envir = envir, 
[13:20:53.828]                           inherits = FALSE)) {
[13:20:53.828]                           master <- get("master", mode = "list", 
[13:20:53.828]                             envir = envir, inherits = FALSE)
[13:20:53.828]                           if (inherits(master, c("SOCKnode", 
[13:20:53.828]                             "SOCK0node"))) {
[13:20:53.828]                             sendCondition <<- function(cond) {
[13:20:53.828]                               data <- list(type = "VALUE", value = cond, 
[13:20:53.828]                                 success = TRUE)
[13:20:53.828]                               parallel_sendData(master, data)
[13:20:53.828]                             }
[13:20:53.828]                             return(sendCondition)
[13:20:53.828]                           }
[13:20:53.828]                         }
[13:20:53.828]                         frame <- frame + 1L
[13:20:53.828]                         envir <- sys.frame(frame)
[13:20:53.828]                       }
[13:20:53.828]                     }
[13:20:53.828]                     sendCondition <<- function(cond) NULL
[13:20:53.828]                   }
[13:20:53.828]                 })
[13:20:53.828]                 withCallingHandlers({
[13:20:53.828]                   1
[13:20:53.828]                 }, immediateCondition = function(cond) {
[13:20:53.828]                   sendCondition <- ...future.makeSendCondition()
[13:20:53.828]                   sendCondition(cond)
[13:20:53.828]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.828]                   {
[13:20:53.828]                     inherits <- base::inherits
[13:20:53.828]                     invokeRestart <- base::invokeRestart
[13:20:53.828]                     is.null <- base::is.null
[13:20:53.828]                     muffled <- FALSE
[13:20:53.828]                     if (inherits(cond, "message")) {
[13:20:53.828]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:53.828]                       if (muffled) 
[13:20:53.828]                         invokeRestart("muffleMessage")
[13:20:53.828]                     }
[13:20:53.828]                     else if (inherits(cond, "warning")) {
[13:20:53.828]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:53.828]                       if (muffled) 
[13:20:53.828]                         invokeRestart("muffleWarning")
[13:20:53.828]                     }
[13:20:53.828]                     else if (inherits(cond, "condition")) {
[13:20:53.828]                       if (!is.null(pattern)) {
[13:20:53.828]                         computeRestarts <- base::computeRestarts
[13:20:53.828]                         grepl <- base::grepl
[13:20:53.828]                         restarts <- computeRestarts(cond)
[13:20:53.828]                         for (restart in restarts) {
[13:20:53.828]                           name <- restart$name
[13:20:53.828]                           if (is.null(name)) 
[13:20:53.828]                             next
[13:20:53.828]                           if (!grepl(pattern, name)) 
[13:20:53.828]                             next
[13:20:53.828]                           invokeRestart(restart)
[13:20:53.828]                           muffled <- TRUE
[13:20:53.828]                           break
[13:20:53.828]                         }
[13:20:53.828]                       }
[13:20:53.828]                     }
[13:20:53.828]                     invisible(muffled)
[13:20:53.828]                   }
[13:20:53.828]                   muffleCondition(cond)
[13:20:53.828]                 })
[13:20:53.828]             }))
[13:20:53.828]             future::FutureResult(value = ...future.value$value, 
[13:20:53.828]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:53.828]                   ...future.rng), globalenv = if (FALSE) 
[13:20:53.828]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:53.828]                     ...future.globalenv.names))
[13:20:53.828]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:53.828]         }, condition = base::local({
[13:20:53.828]             c <- base::c
[13:20:53.828]             inherits <- base::inherits
[13:20:53.828]             invokeRestart <- base::invokeRestart
[13:20:53.828]             length <- base::length
[13:20:53.828]             list <- base::list
[13:20:53.828]             seq.int <- base::seq.int
[13:20:53.828]             signalCondition <- base::signalCondition
[13:20:53.828]             sys.calls <- base::sys.calls
[13:20:53.828]             `[[` <- base::`[[`
[13:20:53.828]             `+` <- base::`+`
[13:20:53.828]             `<<-` <- base::`<<-`
[13:20:53.828]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:53.828]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:53.828]                   3L)]
[13:20:53.828]             }
[13:20:53.828]             function(cond) {
[13:20:53.828]                 is_error <- inherits(cond, "error")
[13:20:53.828]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:53.828]                   NULL)
[13:20:53.828]                 if (is_error) {
[13:20:53.828]                   sessionInformation <- function() {
[13:20:53.828]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:53.828]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:53.828]                       search = base::search(), system = base::Sys.info())
[13:20:53.828]                   }
[13:20:53.828]                   ...future.conditions[[length(...future.conditions) + 
[13:20:53.828]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:53.828]                     cond$call), session = sessionInformation(), 
[13:20:53.828]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:53.828]                   signalCondition(cond)
[13:20:53.828]                 }
[13:20:53.828]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:53.828]                 "immediateCondition"))) {
[13:20:53.828]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:53.828]                   ...future.conditions[[length(...future.conditions) + 
[13:20:53.828]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:53.828]                   if (TRUE && !signal) {
[13:20:53.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.828]                     {
[13:20:53.828]                       inherits <- base::inherits
[13:20:53.828]                       invokeRestart <- base::invokeRestart
[13:20:53.828]                       is.null <- base::is.null
[13:20:53.828]                       muffled <- FALSE
[13:20:53.828]                       if (inherits(cond, "message")) {
[13:20:53.828]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:53.828]                         if (muffled) 
[13:20:53.828]                           invokeRestart("muffleMessage")
[13:20:53.828]                       }
[13:20:53.828]                       else if (inherits(cond, "warning")) {
[13:20:53.828]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:53.828]                         if (muffled) 
[13:20:53.828]                           invokeRestart("muffleWarning")
[13:20:53.828]                       }
[13:20:53.828]                       else if (inherits(cond, "condition")) {
[13:20:53.828]                         if (!is.null(pattern)) {
[13:20:53.828]                           computeRestarts <- base::computeRestarts
[13:20:53.828]                           grepl <- base::grepl
[13:20:53.828]                           restarts <- computeRestarts(cond)
[13:20:53.828]                           for (restart in restarts) {
[13:20:53.828]                             name <- restart$name
[13:20:53.828]                             if (is.null(name)) 
[13:20:53.828]                               next
[13:20:53.828]                             if (!grepl(pattern, name)) 
[13:20:53.828]                               next
[13:20:53.828]                             invokeRestart(restart)
[13:20:53.828]                             muffled <- TRUE
[13:20:53.828]                             break
[13:20:53.828]                           }
[13:20:53.828]                         }
[13:20:53.828]                       }
[13:20:53.828]                       invisible(muffled)
[13:20:53.828]                     }
[13:20:53.828]                     muffleCondition(cond, pattern = "^muffle")
[13:20:53.828]                   }
[13:20:53.828]                 }
[13:20:53.828]                 else {
[13:20:53.828]                   if (TRUE) {
[13:20:53.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.828]                     {
[13:20:53.828]                       inherits <- base::inherits
[13:20:53.828]                       invokeRestart <- base::invokeRestart
[13:20:53.828]                       is.null <- base::is.null
[13:20:53.828]                       muffled <- FALSE
[13:20:53.828]                       if (inherits(cond, "message")) {
[13:20:53.828]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:53.828]                         if (muffled) 
[13:20:53.828]                           invokeRestart("muffleMessage")
[13:20:53.828]                       }
[13:20:53.828]                       else if (inherits(cond, "warning")) {
[13:20:53.828]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:53.828]                         if (muffled) 
[13:20:53.828]                           invokeRestart("muffleWarning")
[13:20:53.828]                       }
[13:20:53.828]                       else if (inherits(cond, "condition")) {
[13:20:53.828]                         if (!is.null(pattern)) {
[13:20:53.828]                           computeRestarts <- base::computeRestarts
[13:20:53.828]                           grepl <- base::grepl
[13:20:53.828]                           restarts <- computeRestarts(cond)
[13:20:53.828]                           for (restart in restarts) {
[13:20:53.828]                             name <- restart$name
[13:20:53.828]                             if (is.null(name)) 
[13:20:53.828]                               next
[13:20:53.828]                             if (!grepl(pattern, name)) 
[13:20:53.828]                               next
[13:20:53.828]                             invokeRestart(restart)
[13:20:53.828]                             muffled <- TRUE
[13:20:53.828]                             break
[13:20:53.828]                           }
[13:20:53.828]                         }
[13:20:53.828]                       }
[13:20:53.828]                       invisible(muffled)
[13:20:53.828]                     }
[13:20:53.828]                     muffleCondition(cond, pattern = "^muffle")
[13:20:53.828]                   }
[13:20:53.828]                 }
[13:20:53.828]             }
[13:20:53.828]         }))
[13:20:53.828]     }, error = function(ex) {
[13:20:53.828]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:53.828]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:53.828]                 ...future.rng), started = ...future.startTime, 
[13:20:53.828]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:53.828]             version = "1.8"), class = "FutureResult")
[13:20:53.828]     }, finally = {
[13:20:53.828]         if (!identical(...future.workdir, getwd())) 
[13:20:53.828]             setwd(...future.workdir)
[13:20:53.828]         {
[13:20:53.828]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:53.828]                 ...future.oldOptions$nwarnings <- NULL
[13:20:53.828]             }
[13:20:53.828]             base::options(...future.oldOptions)
[13:20:53.828]             if (.Platform$OS.type == "windows") {
[13:20:53.828]                 old_names <- names(...future.oldEnvVars)
[13:20:53.828]                 envs <- base::Sys.getenv()
[13:20:53.828]                 names <- names(envs)
[13:20:53.828]                 common <- intersect(names, old_names)
[13:20:53.828]                 added <- setdiff(names, old_names)
[13:20:53.828]                 removed <- setdiff(old_names, names)
[13:20:53.828]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:53.828]                   envs[common]]
[13:20:53.828]                 NAMES <- toupper(changed)
[13:20:53.828]                 args <- list()
[13:20:53.828]                 for (kk in seq_along(NAMES)) {
[13:20:53.828]                   name <- changed[[kk]]
[13:20:53.828]                   NAME <- NAMES[[kk]]
[13:20:53.828]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.828]                     next
[13:20:53.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:53.828]                 }
[13:20:53.828]                 NAMES <- toupper(added)
[13:20:53.828]                 for (kk in seq_along(NAMES)) {
[13:20:53.828]                   name <- added[[kk]]
[13:20:53.828]                   NAME <- NAMES[[kk]]
[13:20:53.828]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.828]                     next
[13:20:53.828]                   args[[name]] <- ""
[13:20:53.828]                 }
[13:20:53.828]                 NAMES <- toupper(removed)
[13:20:53.828]                 for (kk in seq_along(NAMES)) {
[13:20:53.828]                   name <- removed[[kk]]
[13:20:53.828]                   NAME <- NAMES[[kk]]
[13:20:53.828]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.828]                     next
[13:20:53.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:53.828]                 }
[13:20:53.828]                 if (length(args) > 0) 
[13:20:53.828]                   base::do.call(base::Sys.setenv, args = args)
[13:20:53.828]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:53.828]             }
[13:20:53.828]             else {
[13:20:53.828]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:53.828]             }
[13:20:53.828]             {
[13:20:53.828]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:53.828]                   0L) {
[13:20:53.828]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:53.828]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:53.828]                   base::options(opts)
[13:20:53.828]                 }
[13:20:53.828]                 {
[13:20:53.828]                   {
[13:20:53.828]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:53.828]                     NULL
[13:20:53.828]                   }
[13:20:53.828]                   options(future.plan = NULL)
[13:20:53.828]                   if (is.na(NA_character_)) 
[13:20:53.828]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:53.828]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:53.828]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:53.828]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:53.828]                     envir = parent.frame()) 
[13:20:53.828]                   {
[13:20:53.828]                     if (is.function(workers)) 
[13:20:53.828]                       workers <- workers()
[13:20:53.828]                     workers <- structure(as.integer(workers), 
[13:20:53.828]                       class = class(workers))
[13:20:53.828]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:53.828]                       workers >= 1)
[13:20:53.828]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:53.828]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:53.828]                     }
[13:20:53.828]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:53.828]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:53.828]                       envir = envir)
[13:20:53.828]                     if (!future$lazy) 
[13:20:53.828]                       future <- run(future)
[13:20:53.828]                     invisible(future)
[13:20:53.828]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:53.828]                 }
[13:20:53.828]             }
[13:20:53.828]         }
[13:20:53.828]     })
[13:20:53.828]     if (TRUE) {
[13:20:53.828]         base::sink(type = "output", split = FALSE)
[13:20:53.828]         if (TRUE) {
[13:20:53.828]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:53.828]         }
[13:20:53.828]         else {
[13:20:53.828]             ...future.result["stdout"] <- base::list(NULL)
[13:20:53.828]         }
[13:20:53.828]         base::close(...future.stdout)
[13:20:53.828]         ...future.stdout <- NULL
[13:20:53.828]     }
[13:20:53.828]     ...future.result$conditions <- ...future.conditions
[13:20:53.828]     ...future.result$finished <- base::Sys.time()
[13:20:53.828]     ...future.result
[13:20:53.828] }
[13:20:53.831] MultisessionFuture started
[13:20:53.831] - Launch lazy future ... done
[13:20:53.832] run() for ‘MultisessionFuture’ ... done
[13:20:53.878] receiveMessageFromWorker() for ClusterFuture ...
[13:20:53.878] - Validating connection of MultisessionFuture
[13:20:53.878] - received message: FutureResult
[13:20:53.878] - Received FutureResult
[13:20:53.878] - Erased future from FutureRegistry
[13:20:53.878] result() for ClusterFuture ...
[13:20:53.878] - result already collected: FutureResult
[13:20:53.879] result() for ClusterFuture ... done
[13:20:53.879] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:53.879] Future #1
[13:20:53.879] result() for ClusterFuture ...
[13:20:53.879] - result already collected: FutureResult
[13:20:53.879] result() for ClusterFuture ... done
[13:20:53.879] result() for ClusterFuture ...
[13:20:53.879] - result already collected: FutureResult
[13:20:53.879] result() for ClusterFuture ... done
[13:20:53.879] A MultisessionFuture was resolved
[13:20:53.880]  length: 0 (resolved future 1)
[13:20:53.880] resolve() on list ... DONE
[13:20:53.880] - globals: [1] ‘a’
[13:20:53.880] Resolving futures part of globals (recursively) ... DONE
[13:20:53.881] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[13:20:53.881] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[13:20:53.881] - globals: [1] ‘a’
[13:20:53.881] - packages: [1] ‘future’
[13:20:53.882] getGlobalsAndPackages() ... DONE
[13:20:53.882] run() for ‘Future’ ...
[13:20:53.882] - state: ‘created’
[13:20:53.882] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:53.896] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:53.897] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:53.897]   - Field: ‘node’
[13:20:53.897]   - Field: ‘label’
[13:20:53.897]   - Field: ‘local’
[13:20:53.897]   - Field: ‘owner’
[13:20:53.897]   - Field: ‘envir’
[13:20:53.897]   - Field: ‘workers’
[13:20:53.897]   - Field: ‘packages’
[13:20:53.897]   - Field: ‘gc’
[13:20:53.897]   - Field: ‘conditions’
[13:20:53.898]   - Field: ‘persistent’
[13:20:53.898]   - Field: ‘expr’
[13:20:53.898]   - Field: ‘uuid’
[13:20:53.898]   - Field: ‘seed’
[13:20:53.898]   - Field: ‘version’
[13:20:53.898]   - Field: ‘result’
[13:20:53.898]   - Field: ‘asynchronous’
[13:20:53.898]   - Field: ‘calls’
[13:20:53.898]   - Field: ‘globals’
[13:20:53.898]   - Field: ‘stdout’
[13:20:53.898]   - Field: ‘earlySignal’
[13:20:53.899]   - Field: ‘lazy’
[13:20:53.899]   - Field: ‘state’
[13:20:53.899] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:53.899] - Launch lazy future ...
[13:20:53.899] Packages needed by the future expression (n = 1): ‘future’
[13:20:53.899] Packages needed by future strategies (n = 0): <none>
[13:20:53.900] {
[13:20:53.900]     {
[13:20:53.900]         {
[13:20:53.900]             ...future.startTime <- base::Sys.time()
[13:20:53.900]             {
[13:20:53.900]                 {
[13:20:53.900]                   {
[13:20:53.900]                     {
[13:20:53.900]                       {
[13:20:53.900]                         base::local({
[13:20:53.900]                           has_future <- base::requireNamespace("future", 
[13:20:53.900]                             quietly = TRUE)
[13:20:53.900]                           if (has_future) {
[13:20:53.900]                             ns <- base::getNamespace("future")
[13:20:53.900]                             version <- ns[[".package"]][["version"]]
[13:20:53.900]                             if (is.null(version)) 
[13:20:53.900]                               version <- utils::packageVersion("future")
[13:20:53.900]                           }
[13:20:53.900]                           else {
[13:20:53.900]                             version <- NULL
[13:20:53.900]                           }
[13:20:53.900]                           if (!has_future || version < "1.8.0") {
[13:20:53.900]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:53.900]                               "", base::R.version$version.string), 
[13:20:53.900]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:53.900]                                 base::R.version$platform, 8 * 
[13:20:53.900]                                   base::.Machine$sizeof.pointer), 
[13:20:53.900]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:53.900]                                 "release", "version")], collapse = " "), 
[13:20:53.900]                               hostname = base::Sys.info()[["nodename"]])
[13:20:53.900]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:53.900]                               info)
[13:20:53.900]                             info <- base::paste(info, collapse = "; ")
[13:20:53.900]                             if (!has_future) {
[13:20:53.900]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:53.900]                                 info)
[13:20:53.900]                             }
[13:20:53.900]                             else {
[13:20:53.900]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:53.900]                                 info, version)
[13:20:53.900]                             }
[13:20:53.900]                             base::stop(msg)
[13:20:53.900]                           }
[13:20:53.900]                         })
[13:20:53.900]                       }
[13:20:53.900]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:53.900]                       base::options(mc.cores = 1L)
[13:20:53.900]                     }
[13:20:53.900]                     base::local({
[13:20:53.900]                       for (pkg in "future") {
[13:20:53.900]                         base::loadNamespace(pkg)
[13:20:53.900]                         base::library(pkg, character.only = TRUE)
[13:20:53.900]                       }
[13:20:53.900]                     })
[13:20:53.900]                   }
[13:20:53.900]                   options(future.plan = NULL)
[13:20:53.900]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:53.900]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:53.900]                 }
[13:20:53.900]                 ...future.workdir <- getwd()
[13:20:53.900]             }
[13:20:53.900]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:53.900]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:53.900]         }
[13:20:53.900]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:53.900]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:53.900]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:53.900]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:53.900]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:53.900]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:53.900]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:53.900]             base::names(...future.oldOptions))
[13:20:53.900]     }
[13:20:53.900]     if (FALSE) {
[13:20:53.900]     }
[13:20:53.900]     else {
[13:20:53.900]         if (TRUE) {
[13:20:53.900]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:53.900]                 open = "w")
[13:20:53.900]         }
[13:20:53.900]         else {
[13:20:53.900]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:53.900]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:53.900]         }
[13:20:53.900]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:53.900]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:53.900]             base::sink(type = "output", split = FALSE)
[13:20:53.900]             base::close(...future.stdout)
[13:20:53.900]         }, add = TRUE)
[13:20:53.900]     }
[13:20:53.900]     ...future.frame <- base::sys.nframe()
[13:20:53.900]     ...future.conditions <- base::list()
[13:20:53.900]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:53.900]     if (FALSE) {
[13:20:53.900]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:53.900]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:53.900]     }
[13:20:53.900]     ...future.result <- base::tryCatch({
[13:20:53.900]         base::withCallingHandlers({
[13:20:53.900]             ...future.value <- base::withVisible(base::local({
[13:20:53.900]                 ...future.makeSendCondition <- local({
[13:20:53.900]                   sendCondition <- NULL
[13:20:53.900]                   function(frame = 1L) {
[13:20:53.900]                     if (is.function(sendCondition)) 
[13:20:53.900]                       return(sendCondition)
[13:20:53.900]                     ns <- getNamespace("parallel")
[13:20:53.900]                     if (exists("sendData", mode = "function", 
[13:20:53.900]                       envir = ns)) {
[13:20:53.900]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:53.900]                         envir = ns)
[13:20:53.900]                       envir <- sys.frame(frame)
[13:20:53.900]                       master <- NULL
[13:20:53.900]                       while (!identical(envir, .GlobalEnv) && 
[13:20:53.900]                         !identical(envir, emptyenv())) {
[13:20:53.900]                         if (exists("master", mode = "list", envir = envir, 
[13:20:53.900]                           inherits = FALSE)) {
[13:20:53.900]                           master <- get("master", mode = "list", 
[13:20:53.900]                             envir = envir, inherits = FALSE)
[13:20:53.900]                           if (inherits(master, c("SOCKnode", 
[13:20:53.900]                             "SOCK0node"))) {
[13:20:53.900]                             sendCondition <<- function(cond) {
[13:20:53.900]                               data <- list(type = "VALUE", value = cond, 
[13:20:53.900]                                 success = TRUE)
[13:20:53.900]                               parallel_sendData(master, data)
[13:20:53.900]                             }
[13:20:53.900]                             return(sendCondition)
[13:20:53.900]                           }
[13:20:53.900]                         }
[13:20:53.900]                         frame <- frame + 1L
[13:20:53.900]                         envir <- sys.frame(frame)
[13:20:53.900]                       }
[13:20:53.900]                     }
[13:20:53.900]                     sendCondition <<- function(cond) NULL
[13:20:53.900]                   }
[13:20:53.900]                 })
[13:20:53.900]                 withCallingHandlers({
[13:20:53.900]                   value(a) + 1
[13:20:53.900]                 }, immediateCondition = function(cond) {
[13:20:53.900]                   sendCondition <- ...future.makeSendCondition()
[13:20:53.900]                   sendCondition(cond)
[13:20:53.900]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.900]                   {
[13:20:53.900]                     inherits <- base::inherits
[13:20:53.900]                     invokeRestart <- base::invokeRestart
[13:20:53.900]                     is.null <- base::is.null
[13:20:53.900]                     muffled <- FALSE
[13:20:53.900]                     if (inherits(cond, "message")) {
[13:20:53.900]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:53.900]                       if (muffled) 
[13:20:53.900]                         invokeRestart("muffleMessage")
[13:20:53.900]                     }
[13:20:53.900]                     else if (inherits(cond, "warning")) {
[13:20:53.900]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:53.900]                       if (muffled) 
[13:20:53.900]                         invokeRestart("muffleWarning")
[13:20:53.900]                     }
[13:20:53.900]                     else if (inherits(cond, "condition")) {
[13:20:53.900]                       if (!is.null(pattern)) {
[13:20:53.900]                         computeRestarts <- base::computeRestarts
[13:20:53.900]                         grepl <- base::grepl
[13:20:53.900]                         restarts <- computeRestarts(cond)
[13:20:53.900]                         for (restart in restarts) {
[13:20:53.900]                           name <- restart$name
[13:20:53.900]                           if (is.null(name)) 
[13:20:53.900]                             next
[13:20:53.900]                           if (!grepl(pattern, name)) 
[13:20:53.900]                             next
[13:20:53.900]                           invokeRestart(restart)
[13:20:53.900]                           muffled <- TRUE
[13:20:53.900]                           break
[13:20:53.900]                         }
[13:20:53.900]                       }
[13:20:53.900]                     }
[13:20:53.900]                     invisible(muffled)
[13:20:53.900]                   }
[13:20:53.900]                   muffleCondition(cond)
[13:20:53.900]                 })
[13:20:53.900]             }))
[13:20:53.900]             future::FutureResult(value = ...future.value$value, 
[13:20:53.900]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:53.900]                   ...future.rng), globalenv = if (FALSE) 
[13:20:53.900]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:53.900]                     ...future.globalenv.names))
[13:20:53.900]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:53.900]         }, condition = base::local({
[13:20:53.900]             c <- base::c
[13:20:53.900]             inherits <- base::inherits
[13:20:53.900]             invokeRestart <- base::invokeRestart
[13:20:53.900]             length <- base::length
[13:20:53.900]             list <- base::list
[13:20:53.900]             seq.int <- base::seq.int
[13:20:53.900]             signalCondition <- base::signalCondition
[13:20:53.900]             sys.calls <- base::sys.calls
[13:20:53.900]             `[[` <- base::`[[`
[13:20:53.900]             `+` <- base::`+`
[13:20:53.900]             `<<-` <- base::`<<-`
[13:20:53.900]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:53.900]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:53.900]                   3L)]
[13:20:53.900]             }
[13:20:53.900]             function(cond) {
[13:20:53.900]                 is_error <- inherits(cond, "error")
[13:20:53.900]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:53.900]                   NULL)
[13:20:53.900]                 if (is_error) {
[13:20:53.900]                   sessionInformation <- function() {
[13:20:53.900]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:53.900]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:53.900]                       search = base::search(), system = base::Sys.info())
[13:20:53.900]                   }
[13:20:53.900]                   ...future.conditions[[length(...future.conditions) + 
[13:20:53.900]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:53.900]                     cond$call), session = sessionInformation(), 
[13:20:53.900]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:53.900]                   signalCondition(cond)
[13:20:53.900]                 }
[13:20:53.900]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:53.900]                 "immediateCondition"))) {
[13:20:53.900]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:53.900]                   ...future.conditions[[length(...future.conditions) + 
[13:20:53.900]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:53.900]                   if (TRUE && !signal) {
[13:20:53.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.900]                     {
[13:20:53.900]                       inherits <- base::inherits
[13:20:53.900]                       invokeRestart <- base::invokeRestart
[13:20:53.900]                       is.null <- base::is.null
[13:20:53.900]                       muffled <- FALSE
[13:20:53.900]                       if (inherits(cond, "message")) {
[13:20:53.900]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:53.900]                         if (muffled) 
[13:20:53.900]                           invokeRestart("muffleMessage")
[13:20:53.900]                       }
[13:20:53.900]                       else if (inherits(cond, "warning")) {
[13:20:53.900]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:53.900]                         if (muffled) 
[13:20:53.900]                           invokeRestart("muffleWarning")
[13:20:53.900]                       }
[13:20:53.900]                       else if (inherits(cond, "condition")) {
[13:20:53.900]                         if (!is.null(pattern)) {
[13:20:53.900]                           computeRestarts <- base::computeRestarts
[13:20:53.900]                           grepl <- base::grepl
[13:20:53.900]                           restarts <- computeRestarts(cond)
[13:20:53.900]                           for (restart in restarts) {
[13:20:53.900]                             name <- restart$name
[13:20:53.900]                             if (is.null(name)) 
[13:20:53.900]                               next
[13:20:53.900]                             if (!grepl(pattern, name)) 
[13:20:53.900]                               next
[13:20:53.900]                             invokeRestart(restart)
[13:20:53.900]                             muffled <- TRUE
[13:20:53.900]                             break
[13:20:53.900]                           }
[13:20:53.900]                         }
[13:20:53.900]                       }
[13:20:53.900]                       invisible(muffled)
[13:20:53.900]                     }
[13:20:53.900]                     muffleCondition(cond, pattern = "^muffle")
[13:20:53.900]                   }
[13:20:53.900]                 }
[13:20:53.900]                 else {
[13:20:53.900]                   if (TRUE) {
[13:20:53.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:53.900]                     {
[13:20:53.900]                       inherits <- base::inherits
[13:20:53.900]                       invokeRestart <- base::invokeRestart
[13:20:53.900]                       is.null <- base::is.null
[13:20:53.900]                       muffled <- FALSE
[13:20:53.900]                       if (inherits(cond, "message")) {
[13:20:53.900]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:53.900]                         if (muffled) 
[13:20:53.900]                           invokeRestart("muffleMessage")
[13:20:53.900]                       }
[13:20:53.900]                       else if (inherits(cond, "warning")) {
[13:20:53.900]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:53.900]                         if (muffled) 
[13:20:53.900]                           invokeRestart("muffleWarning")
[13:20:53.900]                       }
[13:20:53.900]                       else if (inherits(cond, "condition")) {
[13:20:53.900]                         if (!is.null(pattern)) {
[13:20:53.900]                           computeRestarts <- base::computeRestarts
[13:20:53.900]                           grepl <- base::grepl
[13:20:53.900]                           restarts <- computeRestarts(cond)
[13:20:53.900]                           for (restart in restarts) {
[13:20:53.900]                             name <- restart$name
[13:20:53.900]                             if (is.null(name)) 
[13:20:53.900]                               next
[13:20:53.900]                             if (!grepl(pattern, name)) 
[13:20:53.900]                               next
[13:20:53.900]                             invokeRestart(restart)
[13:20:53.900]                             muffled <- TRUE
[13:20:53.900]                             break
[13:20:53.900]                           }
[13:20:53.900]                         }
[13:20:53.900]                       }
[13:20:53.900]                       invisible(muffled)
[13:20:53.900]                     }
[13:20:53.900]                     muffleCondition(cond, pattern = "^muffle")
[13:20:53.900]                   }
[13:20:53.900]                 }
[13:20:53.900]             }
[13:20:53.900]         }))
[13:20:53.900]     }, error = function(ex) {
[13:20:53.900]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:53.900]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:53.900]                 ...future.rng), started = ...future.startTime, 
[13:20:53.900]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:53.900]             version = "1.8"), class = "FutureResult")
[13:20:53.900]     }, finally = {
[13:20:53.900]         if (!identical(...future.workdir, getwd())) 
[13:20:53.900]             setwd(...future.workdir)
[13:20:53.900]         {
[13:20:53.900]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:53.900]                 ...future.oldOptions$nwarnings <- NULL
[13:20:53.900]             }
[13:20:53.900]             base::options(...future.oldOptions)
[13:20:53.900]             if (.Platform$OS.type == "windows") {
[13:20:53.900]                 old_names <- names(...future.oldEnvVars)
[13:20:53.900]                 envs <- base::Sys.getenv()
[13:20:53.900]                 names <- names(envs)
[13:20:53.900]                 common <- intersect(names, old_names)
[13:20:53.900]                 added <- setdiff(names, old_names)
[13:20:53.900]                 removed <- setdiff(old_names, names)
[13:20:53.900]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:53.900]                   envs[common]]
[13:20:53.900]                 NAMES <- toupper(changed)
[13:20:53.900]                 args <- list()
[13:20:53.900]                 for (kk in seq_along(NAMES)) {
[13:20:53.900]                   name <- changed[[kk]]
[13:20:53.900]                   NAME <- NAMES[[kk]]
[13:20:53.900]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.900]                     next
[13:20:53.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:53.900]                 }
[13:20:53.900]                 NAMES <- toupper(added)
[13:20:53.900]                 for (kk in seq_along(NAMES)) {
[13:20:53.900]                   name <- added[[kk]]
[13:20:53.900]                   NAME <- NAMES[[kk]]
[13:20:53.900]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.900]                     next
[13:20:53.900]                   args[[name]] <- ""
[13:20:53.900]                 }
[13:20:53.900]                 NAMES <- toupper(removed)
[13:20:53.900]                 for (kk in seq_along(NAMES)) {
[13:20:53.900]                   name <- removed[[kk]]
[13:20:53.900]                   NAME <- NAMES[[kk]]
[13:20:53.900]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:53.900]                     next
[13:20:53.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:53.900]                 }
[13:20:53.900]                 if (length(args) > 0) 
[13:20:53.900]                   base::do.call(base::Sys.setenv, args = args)
[13:20:53.900]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:53.900]             }
[13:20:53.900]             else {
[13:20:53.900]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:53.900]             }
[13:20:53.900]             {
[13:20:53.900]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:53.900]                   0L) {
[13:20:53.900]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:53.900]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:53.900]                   base::options(opts)
[13:20:53.900]                 }
[13:20:53.900]                 {
[13:20:53.900]                   {
[13:20:53.900]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:53.900]                     NULL
[13:20:53.900]                   }
[13:20:53.900]                   options(future.plan = NULL)
[13:20:53.900]                   if (is.na(NA_character_)) 
[13:20:53.900]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:53.900]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:53.900]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:53.900]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:53.900]                     envir = parent.frame()) 
[13:20:53.900]                   {
[13:20:53.900]                     if (is.function(workers)) 
[13:20:53.900]                       workers <- workers()
[13:20:53.900]                     workers <- structure(as.integer(workers), 
[13:20:53.900]                       class = class(workers))
[13:20:53.900]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:53.900]                       workers >= 1)
[13:20:53.900]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:53.900]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:53.900]                     }
[13:20:53.900]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:53.900]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:53.900]                       envir = envir)
[13:20:53.900]                     if (!future$lazy) 
[13:20:53.900]                       future <- run(future)
[13:20:53.900]                     invisible(future)
[13:20:53.900]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:53.900]                 }
[13:20:53.900]             }
[13:20:53.900]         }
[13:20:53.900]     })
[13:20:53.900]     if (TRUE) {
[13:20:53.900]         base::sink(type = "output", split = FALSE)
[13:20:53.900]         if (TRUE) {
[13:20:53.900]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:53.900]         }
[13:20:53.900]         else {
[13:20:53.900]             ...future.result["stdout"] <- base::list(NULL)
[13:20:53.900]         }
[13:20:53.900]         base::close(...future.stdout)
[13:20:53.900]         ...future.stdout <- NULL
[13:20:53.900]     }
[13:20:53.900]     ...future.result$conditions <- ...future.conditions
[13:20:53.900]     ...future.result$finished <- base::Sys.time()
[13:20:53.900]     ...future.result
[13:20:53.900] }
[13:20:53.902] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[13:20:53.903] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[13:20:53.957] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[13:20:53.957] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[13:20:53.958] MultisessionFuture started
[13:20:53.958] - Launch lazy future ... done
[13:20:53.958] run() for ‘MultisessionFuture’ ... done
[13:20:53.959] result() for ClusterFuture ...
[13:20:53.959] receiveMessageFromWorker() for ClusterFuture ...
[13:20:53.959] - Validating connection of MultisessionFuture
[13:20:54.006] - received message: FutureResult
[13:20:54.007] - Received FutureResult
[13:20:54.007] - Erased future from FutureRegistry
[13:20:54.007] result() for ClusterFuture ...
[13:20:54.007] - result already collected: FutureResult
[13:20:54.007] result() for ClusterFuture ... done
[13:20:54.007] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:54.007] result() for ClusterFuture ... done
[13:20:54.007] result() for ClusterFuture ...
[13:20:54.007] - result already collected: FutureResult
[13:20:54.008] result() for ClusterFuture ... done
value(b) = 2
[13:20:54.008] result() for ClusterFuture ...
[13:20:54.008] - result already collected: FutureResult
[13:20:54.008] result() for ClusterFuture ... done
[13:20:54.008] result() for ClusterFuture ...
[13:20:54.008] - result already collected: FutureResult
[13:20:54.008] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:54.009] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:54.009] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[13:20:54.010] - globals found: [2] ‘{’, ‘pkg’
[13:20:54.010] Searching for globals ... DONE
[13:20:54.010] Resolving globals: TRUE
[13:20:54.010] Resolving any globals that are futures ...
[13:20:54.010] - globals: [2] ‘{’, ‘pkg’
[13:20:54.010] Resolving any globals that are futures ... DONE
[13:20:54.010] Resolving futures part of globals (recursively) ...
[13:20:54.011] resolve() on list ...
[13:20:54.011]  recursive: 99
[13:20:54.011]  length: 1
[13:20:54.011]  elements: ‘pkg’
[13:20:54.011]  length: 0 (resolved future 1)
[13:20:54.011] resolve() on list ... DONE
[13:20:54.011] - globals: [1] ‘pkg’
[13:20:54.011] Resolving futures part of globals (recursively) ... DONE
[13:20:54.012] The total size of the 1 globals is 112 bytes (112 bytes)
[13:20:54.012] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[13:20:54.012] - globals: [1] ‘pkg’
[13:20:54.012] 
[13:20:54.012] getGlobalsAndPackages() ... DONE
[13:20:54.013] Packages needed by the future expression (n = 0): <none>
[13:20:54.013] Packages needed by future strategies (n = 0): <none>
[13:20:54.013] {
[13:20:54.013]     {
[13:20:54.013]         {
[13:20:54.013]             ...future.startTime <- base::Sys.time()
[13:20:54.013]             {
[13:20:54.013]                 {
[13:20:54.013]                   {
[13:20:54.013]                     base::local({
[13:20:54.013]                       has_future <- base::requireNamespace("future", 
[13:20:54.013]                         quietly = TRUE)
[13:20:54.013]                       if (has_future) {
[13:20:54.013]                         ns <- base::getNamespace("future")
[13:20:54.013]                         version <- ns[[".package"]][["version"]]
[13:20:54.013]                         if (is.null(version)) 
[13:20:54.013]                           version <- utils::packageVersion("future")
[13:20:54.013]                       }
[13:20:54.013]                       else {
[13:20:54.013]                         version <- NULL
[13:20:54.013]                       }
[13:20:54.013]                       if (!has_future || version < "1.8.0") {
[13:20:54.013]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:54.013]                           "", base::R.version$version.string), 
[13:20:54.013]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:54.013]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:54.013]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:54.013]                             "release", "version")], collapse = " "), 
[13:20:54.013]                           hostname = base::Sys.info()[["nodename"]])
[13:20:54.013]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:54.013]                           info)
[13:20:54.013]                         info <- base::paste(info, collapse = "; ")
[13:20:54.013]                         if (!has_future) {
[13:20:54.013]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:54.013]                             info)
[13:20:54.013]                         }
[13:20:54.013]                         else {
[13:20:54.013]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:54.013]                             info, version)
[13:20:54.013]                         }
[13:20:54.013]                         base::stop(msg)
[13:20:54.013]                       }
[13:20:54.013]                     })
[13:20:54.013]                   }
[13:20:54.013]                   options(future.plan = NULL)
[13:20:54.013]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.013]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:54.013]                 }
[13:20:54.013]                 ...future.workdir <- getwd()
[13:20:54.013]             }
[13:20:54.013]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:54.013]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:54.013]         }
[13:20:54.013]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:54.013]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[13:20:54.013]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:54.013]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:54.013]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:54.013]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:54.013]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:54.013]             base::names(...future.oldOptions))
[13:20:54.013]     }
[13:20:54.013]     if (FALSE) {
[13:20:54.013]     }
[13:20:54.013]     else {
[13:20:54.013]         if (TRUE) {
[13:20:54.013]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:54.013]                 open = "w")
[13:20:54.013]         }
[13:20:54.013]         else {
[13:20:54.013]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:54.013]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:54.013]         }
[13:20:54.013]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:54.013]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:54.013]             base::sink(type = "output", split = FALSE)
[13:20:54.013]             base::close(...future.stdout)
[13:20:54.013]         }, add = TRUE)
[13:20:54.013]     }
[13:20:54.013]     ...future.frame <- base::sys.nframe()
[13:20:54.013]     ...future.conditions <- base::list()
[13:20:54.013]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:54.013]     if (FALSE) {
[13:20:54.013]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:54.013]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:54.013]     }
[13:20:54.013]     ...future.result <- base::tryCatch({
[13:20:54.013]         base::withCallingHandlers({
[13:20:54.013]             ...future.value <- base::withVisible(base::local({
[13:20:54.013]                 pkg
[13:20:54.013]             }))
[13:20:54.013]             future::FutureResult(value = ...future.value$value, 
[13:20:54.013]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.013]                   ...future.rng), globalenv = if (FALSE) 
[13:20:54.013]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:54.013]                     ...future.globalenv.names))
[13:20:54.013]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:54.013]         }, condition = base::local({
[13:20:54.013]             c <- base::c
[13:20:54.013]             inherits <- base::inherits
[13:20:54.013]             invokeRestart <- base::invokeRestart
[13:20:54.013]             length <- base::length
[13:20:54.013]             list <- base::list
[13:20:54.013]             seq.int <- base::seq.int
[13:20:54.013]             signalCondition <- base::signalCondition
[13:20:54.013]             sys.calls <- base::sys.calls
[13:20:54.013]             `[[` <- base::`[[`
[13:20:54.013]             `+` <- base::`+`
[13:20:54.013]             `<<-` <- base::`<<-`
[13:20:54.013]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:54.013]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:54.013]                   3L)]
[13:20:54.013]             }
[13:20:54.013]             function(cond) {
[13:20:54.013]                 is_error <- inherits(cond, "error")
[13:20:54.013]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:54.013]                   NULL)
[13:20:54.013]                 if (is_error) {
[13:20:54.013]                   sessionInformation <- function() {
[13:20:54.013]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:54.013]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:54.013]                       search = base::search(), system = base::Sys.info())
[13:20:54.013]                   }
[13:20:54.013]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.013]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:54.013]                     cond$call), session = sessionInformation(), 
[13:20:54.013]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:54.013]                   signalCondition(cond)
[13:20:54.013]                 }
[13:20:54.013]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:54.013]                 "immediateCondition"))) {
[13:20:54.013]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:54.013]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.013]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:54.013]                   if (TRUE && !signal) {
[13:20:54.013]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.013]                     {
[13:20:54.013]                       inherits <- base::inherits
[13:20:54.013]                       invokeRestart <- base::invokeRestart
[13:20:54.013]                       is.null <- base::is.null
[13:20:54.013]                       muffled <- FALSE
[13:20:54.013]                       if (inherits(cond, "message")) {
[13:20:54.013]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.013]                         if (muffled) 
[13:20:54.013]                           invokeRestart("muffleMessage")
[13:20:54.013]                       }
[13:20:54.013]                       else if (inherits(cond, "warning")) {
[13:20:54.013]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.013]                         if (muffled) 
[13:20:54.013]                           invokeRestart("muffleWarning")
[13:20:54.013]                       }
[13:20:54.013]                       else if (inherits(cond, "condition")) {
[13:20:54.013]                         if (!is.null(pattern)) {
[13:20:54.013]                           computeRestarts <- base::computeRestarts
[13:20:54.013]                           grepl <- base::grepl
[13:20:54.013]                           restarts <- computeRestarts(cond)
[13:20:54.013]                           for (restart in restarts) {
[13:20:54.013]                             name <- restart$name
[13:20:54.013]                             if (is.null(name)) 
[13:20:54.013]                               next
[13:20:54.013]                             if (!grepl(pattern, name)) 
[13:20:54.013]                               next
[13:20:54.013]                             invokeRestart(restart)
[13:20:54.013]                             muffled <- TRUE
[13:20:54.013]                             break
[13:20:54.013]                           }
[13:20:54.013]                         }
[13:20:54.013]                       }
[13:20:54.013]                       invisible(muffled)
[13:20:54.013]                     }
[13:20:54.013]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.013]                   }
[13:20:54.013]                 }
[13:20:54.013]                 else {
[13:20:54.013]                   if (TRUE) {
[13:20:54.013]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.013]                     {
[13:20:54.013]                       inherits <- base::inherits
[13:20:54.013]                       invokeRestart <- base::invokeRestart
[13:20:54.013]                       is.null <- base::is.null
[13:20:54.013]                       muffled <- FALSE
[13:20:54.013]                       if (inherits(cond, "message")) {
[13:20:54.013]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.013]                         if (muffled) 
[13:20:54.013]                           invokeRestart("muffleMessage")
[13:20:54.013]                       }
[13:20:54.013]                       else if (inherits(cond, "warning")) {
[13:20:54.013]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.013]                         if (muffled) 
[13:20:54.013]                           invokeRestart("muffleWarning")
[13:20:54.013]                       }
[13:20:54.013]                       else if (inherits(cond, "condition")) {
[13:20:54.013]                         if (!is.null(pattern)) {
[13:20:54.013]                           computeRestarts <- base::computeRestarts
[13:20:54.013]                           grepl <- base::grepl
[13:20:54.013]                           restarts <- computeRestarts(cond)
[13:20:54.013]                           for (restart in restarts) {
[13:20:54.013]                             name <- restart$name
[13:20:54.013]                             if (is.null(name)) 
[13:20:54.013]                               next
[13:20:54.013]                             if (!grepl(pattern, name)) 
[13:20:54.013]                               next
[13:20:54.013]                             invokeRestart(restart)
[13:20:54.013]                             muffled <- TRUE
[13:20:54.013]                             break
[13:20:54.013]                           }
[13:20:54.013]                         }
[13:20:54.013]                       }
[13:20:54.013]                       invisible(muffled)
[13:20:54.013]                     }
[13:20:54.013]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.013]                   }
[13:20:54.013]                 }
[13:20:54.013]             }
[13:20:54.013]         }))
[13:20:54.013]     }, error = function(ex) {
[13:20:54.013]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:54.013]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.013]                 ...future.rng), started = ...future.startTime, 
[13:20:54.013]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:54.013]             version = "1.8"), class = "FutureResult")
[13:20:54.013]     }, finally = {
[13:20:54.013]         if (!identical(...future.workdir, getwd())) 
[13:20:54.013]             setwd(...future.workdir)
[13:20:54.013]         {
[13:20:54.013]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:54.013]                 ...future.oldOptions$nwarnings <- NULL
[13:20:54.013]             }
[13:20:54.013]             base::options(...future.oldOptions)
[13:20:54.013]             if (.Platform$OS.type == "windows") {
[13:20:54.013]                 old_names <- names(...future.oldEnvVars)
[13:20:54.013]                 envs <- base::Sys.getenv()
[13:20:54.013]                 names <- names(envs)
[13:20:54.013]                 common <- intersect(names, old_names)
[13:20:54.013]                 added <- setdiff(names, old_names)
[13:20:54.013]                 removed <- setdiff(old_names, names)
[13:20:54.013]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:54.013]                   envs[common]]
[13:20:54.013]                 NAMES <- toupper(changed)
[13:20:54.013]                 args <- list()
[13:20:54.013]                 for (kk in seq_along(NAMES)) {
[13:20:54.013]                   name <- changed[[kk]]
[13:20:54.013]                   NAME <- NAMES[[kk]]
[13:20:54.013]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.013]                     next
[13:20:54.013]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.013]                 }
[13:20:54.013]                 NAMES <- toupper(added)
[13:20:54.013]                 for (kk in seq_along(NAMES)) {
[13:20:54.013]                   name <- added[[kk]]
[13:20:54.013]                   NAME <- NAMES[[kk]]
[13:20:54.013]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.013]                     next
[13:20:54.013]                   args[[name]] <- ""
[13:20:54.013]                 }
[13:20:54.013]                 NAMES <- toupper(removed)
[13:20:54.013]                 for (kk in seq_along(NAMES)) {
[13:20:54.013]                   name <- removed[[kk]]
[13:20:54.013]                   NAME <- NAMES[[kk]]
[13:20:54.013]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.013]                     next
[13:20:54.013]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.013]                 }
[13:20:54.013]                 if (length(args) > 0) 
[13:20:54.013]                   base::do.call(base::Sys.setenv, args = args)
[13:20:54.013]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:54.013]             }
[13:20:54.013]             else {
[13:20:54.013]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:54.013]             }
[13:20:54.013]             {
[13:20:54.013]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:54.013]                   0L) {
[13:20:54.013]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:54.013]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:54.013]                   base::options(opts)
[13:20:54.013]                 }
[13:20:54.013]                 {
[13:20:54.013]                   {
[13:20:54.013]                     NULL
[13:20:54.013]                     RNGkind("Mersenne-Twister")
[13:20:54.013]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:54.013]                       inherits = FALSE)
[13:20:54.013]                   }
[13:20:54.013]                   options(future.plan = NULL)
[13:20:54.013]                   if (is.na(NA_character_)) 
[13:20:54.013]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.013]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:54.013]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:54.013]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:54.013]                     envir = parent.frame()) 
[13:20:54.013]                   {
[13:20:54.013]                     if (is.function(workers)) 
[13:20:54.013]                       workers <- workers()
[13:20:54.013]                     workers <- structure(as.integer(workers), 
[13:20:54.013]                       class = class(workers))
[13:20:54.013]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:54.013]                       workers >= 1)
[13:20:54.013]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:54.013]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:54.013]                     }
[13:20:54.013]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:54.013]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:54.013]                       envir = envir)
[13:20:54.013]                     if (!future$lazy) 
[13:20:54.013]                       future <- run(future)
[13:20:54.013]                     invisible(future)
[13:20:54.013]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:54.013]                 }
[13:20:54.013]             }
[13:20:54.013]         }
[13:20:54.013]     })
[13:20:54.013]     if (TRUE) {
[13:20:54.013]         base::sink(type = "output", split = FALSE)
[13:20:54.013]         if (TRUE) {
[13:20:54.013]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:54.013]         }
[13:20:54.013]         else {
[13:20:54.013]             ...future.result["stdout"] <- base::list(NULL)
[13:20:54.013]         }
[13:20:54.013]         base::close(...future.stdout)
[13:20:54.013]         ...future.stdout <- NULL
[13:20:54.013]     }
[13:20:54.013]     ...future.result$conditions <- ...future.conditions
[13:20:54.013]     ...future.result$finished <- base::Sys.time()
[13:20:54.013]     ...future.result
[13:20:54.013] }
[13:20:54.015] assign_globals() ...
[13:20:54.015] List of 1
[13:20:54.015]  $ pkg: chr "foo"
[13:20:54.015]  - attr(*, "where")=List of 1
[13:20:54.015]   ..$ pkg:<environment: R_EmptyEnv> 
[13:20:54.015]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:54.015]  - attr(*, "resolved")= logi TRUE
[13:20:54.015]  - attr(*, "total_size")= num 112
[13:20:54.017] - copied ‘pkg’ to environment
[13:20:54.017] assign_globals() ... done
[13:20:54.018] plan(): Setting new future strategy stack:
[13:20:54.018] List of future strategies:
[13:20:54.018] 1. sequential:
[13:20:54.018]    - args: function (..., envir = parent.frame())
[13:20:54.018]    - tweaked: FALSE
[13:20:54.018]    - call: NULL
[13:20:54.018] plan(): nbrOfWorkers() = 1
[13:20:54.019] plan(): Setting new future strategy stack:
[13:20:54.019] List of future strategies:
[13:20:54.019] 1. multisession:
[13:20:54.019]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:54.019]    - tweaked: FALSE
[13:20:54.019]    - call: plan(strategy)
[13:20:54.023] plan(): nbrOfWorkers() = 2
[13:20:54.023] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:54.024] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:54.024] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:54.026] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:20:54.026] Searching for globals ... DONE
[13:20:54.026] Resolving globals: TRUE
[13:20:54.026] Resolving any globals that are futures ...
[13:20:54.026] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:20:54.026] Resolving any globals that are futures ... DONE
[13:20:54.027] Resolving futures part of globals (recursively) ...
[13:20:54.027] resolve() on list ...
[13:20:54.027]  recursive: 99
[13:20:54.027]  length: 1
[13:20:54.027]  elements: ‘a’
[13:20:54.027]  length: 0 (resolved future 1)
[13:20:54.027] resolve() on list ... DONE
[13:20:54.028] - globals: [1] ‘a’
[13:20:54.028] Resolving futures part of globals (recursively) ... DONE
[13:20:54.028] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:54.028] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:20:54.028] - globals: [1] ‘a’
[13:20:54.028] 
[13:20:54.028] getGlobalsAndPackages() ... DONE
[13:20:54.029] run() for ‘Future’ ...
[13:20:54.029] - state: ‘created’
[13:20:54.029] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:54.043] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:54.043] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:54.043]   - Field: ‘node’
[13:20:54.043]   - Field: ‘label’
[13:20:54.043]   - Field: ‘local’
[13:20:54.043]   - Field: ‘owner’
[13:20:54.044]   - Field: ‘envir’
[13:20:54.044]   - Field: ‘workers’
[13:20:54.044]   - Field: ‘packages’
[13:20:54.044]   - Field: ‘gc’
[13:20:54.044]   - Field: ‘conditions’
[13:20:54.044]   - Field: ‘persistent’
[13:20:54.044]   - Field: ‘expr’
[13:20:54.044]   - Field: ‘uuid’
[13:20:54.044]   - Field: ‘seed’
[13:20:54.044]   - Field: ‘version’
[13:20:54.045]   - Field: ‘result’
[13:20:54.045]   - Field: ‘asynchronous’
[13:20:54.045]   - Field: ‘calls’
[13:20:54.045]   - Field: ‘globals’
[13:20:54.045]   - Field: ‘stdout’
[13:20:54.045]   - Field: ‘earlySignal’
[13:20:54.045]   - Field: ‘lazy’
[13:20:54.045]   - Field: ‘state’
[13:20:54.045] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:54.045] - Launch lazy future ...
[13:20:54.046] Packages needed by the future expression (n = 0): <none>
[13:20:54.046] Packages needed by future strategies (n = 0): <none>
[13:20:54.046] {
[13:20:54.046]     {
[13:20:54.046]         {
[13:20:54.046]             ...future.startTime <- base::Sys.time()
[13:20:54.046]             {
[13:20:54.046]                 {
[13:20:54.046]                   {
[13:20:54.046]                     {
[13:20:54.046]                       base::local({
[13:20:54.046]                         has_future <- base::requireNamespace("future", 
[13:20:54.046]                           quietly = TRUE)
[13:20:54.046]                         if (has_future) {
[13:20:54.046]                           ns <- base::getNamespace("future")
[13:20:54.046]                           version <- ns[[".package"]][["version"]]
[13:20:54.046]                           if (is.null(version)) 
[13:20:54.046]                             version <- utils::packageVersion("future")
[13:20:54.046]                         }
[13:20:54.046]                         else {
[13:20:54.046]                           version <- NULL
[13:20:54.046]                         }
[13:20:54.046]                         if (!has_future || version < "1.8.0") {
[13:20:54.046]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:54.046]                             "", base::R.version$version.string), 
[13:20:54.046]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:54.046]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:54.046]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:54.046]                               "release", "version")], collapse = " "), 
[13:20:54.046]                             hostname = base::Sys.info()[["nodename"]])
[13:20:54.046]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:54.046]                             info)
[13:20:54.046]                           info <- base::paste(info, collapse = "; ")
[13:20:54.046]                           if (!has_future) {
[13:20:54.046]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:54.046]                               info)
[13:20:54.046]                           }
[13:20:54.046]                           else {
[13:20:54.046]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:54.046]                               info, version)
[13:20:54.046]                           }
[13:20:54.046]                           base::stop(msg)
[13:20:54.046]                         }
[13:20:54.046]                       })
[13:20:54.046]                     }
[13:20:54.046]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:54.046]                     base::options(mc.cores = 1L)
[13:20:54.046]                   }
[13:20:54.046]                   options(future.plan = NULL)
[13:20:54.046]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.046]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:54.046]                 }
[13:20:54.046]                 ...future.workdir <- getwd()
[13:20:54.046]             }
[13:20:54.046]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:54.046]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:54.046]         }
[13:20:54.046]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:54.046]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:54.046]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:54.046]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:54.046]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:54.046]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:54.046]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:54.046]             base::names(...future.oldOptions))
[13:20:54.046]     }
[13:20:54.046]     if (FALSE) {
[13:20:54.046]     }
[13:20:54.046]     else {
[13:20:54.046]         if (TRUE) {
[13:20:54.046]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:54.046]                 open = "w")
[13:20:54.046]         }
[13:20:54.046]         else {
[13:20:54.046]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:54.046]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:54.046]         }
[13:20:54.046]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:54.046]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:54.046]             base::sink(type = "output", split = FALSE)
[13:20:54.046]             base::close(...future.stdout)
[13:20:54.046]         }, add = TRUE)
[13:20:54.046]     }
[13:20:54.046]     ...future.frame <- base::sys.nframe()
[13:20:54.046]     ...future.conditions <- base::list()
[13:20:54.046]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:54.046]     if (FALSE) {
[13:20:54.046]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:54.046]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:54.046]     }
[13:20:54.046]     ...future.result <- base::tryCatch({
[13:20:54.046]         base::withCallingHandlers({
[13:20:54.046]             ...future.value <- base::withVisible(base::local({
[13:20:54.046]                 ...future.makeSendCondition <- local({
[13:20:54.046]                   sendCondition <- NULL
[13:20:54.046]                   function(frame = 1L) {
[13:20:54.046]                     if (is.function(sendCondition)) 
[13:20:54.046]                       return(sendCondition)
[13:20:54.046]                     ns <- getNamespace("parallel")
[13:20:54.046]                     if (exists("sendData", mode = "function", 
[13:20:54.046]                       envir = ns)) {
[13:20:54.046]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:54.046]                         envir = ns)
[13:20:54.046]                       envir <- sys.frame(frame)
[13:20:54.046]                       master <- NULL
[13:20:54.046]                       while (!identical(envir, .GlobalEnv) && 
[13:20:54.046]                         !identical(envir, emptyenv())) {
[13:20:54.046]                         if (exists("master", mode = "list", envir = envir, 
[13:20:54.046]                           inherits = FALSE)) {
[13:20:54.046]                           master <- get("master", mode = "list", 
[13:20:54.046]                             envir = envir, inherits = FALSE)
[13:20:54.046]                           if (inherits(master, c("SOCKnode", 
[13:20:54.046]                             "SOCK0node"))) {
[13:20:54.046]                             sendCondition <<- function(cond) {
[13:20:54.046]                               data <- list(type = "VALUE", value = cond, 
[13:20:54.046]                                 success = TRUE)
[13:20:54.046]                               parallel_sendData(master, data)
[13:20:54.046]                             }
[13:20:54.046]                             return(sendCondition)
[13:20:54.046]                           }
[13:20:54.046]                         }
[13:20:54.046]                         frame <- frame + 1L
[13:20:54.046]                         envir <- sys.frame(frame)
[13:20:54.046]                       }
[13:20:54.046]                     }
[13:20:54.046]                     sendCondition <<- function(cond) NULL
[13:20:54.046]                   }
[13:20:54.046]                 })
[13:20:54.046]                 withCallingHandlers({
[13:20:54.046]                   {
[13:20:54.046]                     b <- a
[13:20:54.046]                     a <- 2
[13:20:54.046]                     a * b
[13:20:54.046]                   }
[13:20:54.046]                 }, immediateCondition = function(cond) {
[13:20:54.046]                   sendCondition <- ...future.makeSendCondition()
[13:20:54.046]                   sendCondition(cond)
[13:20:54.046]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.046]                   {
[13:20:54.046]                     inherits <- base::inherits
[13:20:54.046]                     invokeRestart <- base::invokeRestart
[13:20:54.046]                     is.null <- base::is.null
[13:20:54.046]                     muffled <- FALSE
[13:20:54.046]                     if (inherits(cond, "message")) {
[13:20:54.046]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:54.046]                       if (muffled) 
[13:20:54.046]                         invokeRestart("muffleMessage")
[13:20:54.046]                     }
[13:20:54.046]                     else if (inherits(cond, "warning")) {
[13:20:54.046]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:54.046]                       if (muffled) 
[13:20:54.046]                         invokeRestart("muffleWarning")
[13:20:54.046]                     }
[13:20:54.046]                     else if (inherits(cond, "condition")) {
[13:20:54.046]                       if (!is.null(pattern)) {
[13:20:54.046]                         computeRestarts <- base::computeRestarts
[13:20:54.046]                         grepl <- base::grepl
[13:20:54.046]                         restarts <- computeRestarts(cond)
[13:20:54.046]                         for (restart in restarts) {
[13:20:54.046]                           name <- restart$name
[13:20:54.046]                           if (is.null(name)) 
[13:20:54.046]                             next
[13:20:54.046]                           if (!grepl(pattern, name)) 
[13:20:54.046]                             next
[13:20:54.046]                           invokeRestart(restart)
[13:20:54.046]                           muffled <- TRUE
[13:20:54.046]                           break
[13:20:54.046]                         }
[13:20:54.046]                       }
[13:20:54.046]                     }
[13:20:54.046]                     invisible(muffled)
[13:20:54.046]                   }
[13:20:54.046]                   muffleCondition(cond)
[13:20:54.046]                 })
[13:20:54.046]             }))
[13:20:54.046]             future::FutureResult(value = ...future.value$value, 
[13:20:54.046]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.046]                   ...future.rng), globalenv = if (FALSE) 
[13:20:54.046]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:54.046]                     ...future.globalenv.names))
[13:20:54.046]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:54.046]         }, condition = base::local({
[13:20:54.046]             c <- base::c
[13:20:54.046]             inherits <- base::inherits
[13:20:54.046]             invokeRestart <- base::invokeRestart
[13:20:54.046]             length <- base::length
[13:20:54.046]             list <- base::list
[13:20:54.046]             seq.int <- base::seq.int
[13:20:54.046]             signalCondition <- base::signalCondition
[13:20:54.046]             sys.calls <- base::sys.calls
[13:20:54.046]             `[[` <- base::`[[`
[13:20:54.046]             `+` <- base::`+`
[13:20:54.046]             `<<-` <- base::`<<-`
[13:20:54.046]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:54.046]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:54.046]                   3L)]
[13:20:54.046]             }
[13:20:54.046]             function(cond) {
[13:20:54.046]                 is_error <- inherits(cond, "error")
[13:20:54.046]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:54.046]                   NULL)
[13:20:54.046]                 if (is_error) {
[13:20:54.046]                   sessionInformation <- function() {
[13:20:54.046]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:54.046]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:54.046]                       search = base::search(), system = base::Sys.info())
[13:20:54.046]                   }
[13:20:54.046]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.046]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:54.046]                     cond$call), session = sessionInformation(), 
[13:20:54.046]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:54.046]                   signalCondition(cond)
[13:20:54.046]                 }
[13:20:54.046]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:54.046]                 "immediateCondition"))) {
[13:20:54.046]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:54.046]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.046]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:54.046]                   if (TRUE && !signal) {
[13:20:54.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.046]                     {
[13:20:54.046]                       inherits <- base::inherits
[13:20:54.046]                       invokeRestart <- base::invokeRestart
[13:20:54.046]                       is.null <- base::is.null
[13:20:54.046]                       muffled <- FALSE
[13:20:54.046]                       if (inherits(cond, "message")) {
[13:20:54.046]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.046]                         if (muffled) 
[13:20:54.046]                           invokeRestart("muffleMessage")
[13:20:54.046]                       }
[13:20:54.046]                       else if (inherits(cond, "warning")) {
[13:20:54.046]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.046]                         if (muffled) 
[13:20:54.046]                           invokeRestart("muffleWarning")
[13:20:54.046]                       }
[13:20:54.046]                       else if (inherits(cond, "condition")) {
[13:20:54.046]                         if (!is.null(pattern)) {
[13:20:54.046]                           computeRestarts <- base::computeRestarts
[13:20:54.046]                           grepl <- base::grepl
[13:20:54.046]                           restarts <- computeRestarts(cond)
[13:20:54.046]                           for (restart in restarts) {
[13:20:54.046]                             name <- restart$name
[13:20:54.046]                             if (is.null(name)) 
[13:20:54.046]                               next
[13:20:54.046]                             if (!grepl(pattern, name)) 
[13:20:54.046]                               next
[13:20:54.046]                             invokeRestart(restart)
[13:20:54.046]                             muffled <- TRUE
[13:20:54.046]                             break
[13:20:54.046]                           }
[13:20:54.046]                         }
[13:20:54.046]                       }
[13:20:54.046]                       invisible(muffled)
[13:20:54.046]                     }
[13:20:54.046]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.046]                   }
[13:20:54.046]                 }
[13:20:54.046]                 else {
[13:20:54.046]                   if (TRUE) {
[13:20:54.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.046]                     {
[13:20:54.046]                       inherits <- base::inherits
[13:20:54.046]                       invokeRestart <- base::invokeRestart
[13:20:54.046]                       is.null <- base::is.null
[13:20:54.046]                       muffled <- FALSE
[13:20:54.046]                       if (inherits(cond, "message")) {
[13:20:54.046]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.046]                         if (muffled) 
[13:20:54.046]                           invokeRestart("muffleMessage")
[13:20:54.046]                       }
[13:20:54.046]                       else if (inherits(cond, "warning")) {
[13:20:54.046]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.046]                         if (muffled) 
[13:20:54.046]                           invokeRestart("muffleWarning")
[13:20:54.046]                       }
[13:20:54.046]                       else if (inherits(cond, "condition")) {
[13:20:54.046]                         if (!is.null(pattern)) {
[13:20:54.046]                           computeRestarts <- base::computeRestarts
[13:20:54.046]                           grepl <- base::grepl
[13:20:54.046]                           restarts <- computeRestarts(cond)
[13:20:54.046]                           for (restart in restarts) {
[13:20:54.046]                             name <- restart$name
[13:20:54.046]                             if (is.null(name)) 
[13:20:54.046]                               next
[13:20:54.046]                             if (!grepl(pattern, name)) 
[13:20:54.046]                               next
[13:20:54.046]                             invokeRestart(restart)
[13:20:54.046]                             muffled <- TRUE
[13:20:54.046]                             break
[13:20:54.046]                           }
[13:20:54.046]                         }
[13:20:54.046]                       }
[13:20:54.046]                       invisible(muffled)
[13:20:54.046]                     }
[13:20:54.046]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.046]                   }
[13:20:54.046]                 }
[13:20:54.046]             }
[13:20:54.046]         }))
[13:20:54.046]     }, error = function(ex) {
[13:20:54.046]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:54.046]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.046]                 ...future.rng), started = ...future.startTime, 
[13:20:54.046]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:54.046]             version = "1.8"), class = "FutureResult")
[13:20:54.046]     }, finally = {
[13:20:54.046]         if (!identical(...future.workdir, getwd())) 
[13:20:54.046]             setwd(...future.workdir)
[13:20:54.046]         {
[13:20:54.046]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:54.046]                 ...future.oldOptions$nwarnings <- NULL
[13:20:54.046]             }
[13:20:54.046]             base::options(...future.oldOptions)
[13:20:54.046]             if (.Platform$OS.type == "windows") {
[13:20:54.046]                 old_names <- names(...future.oldEnvVars)
[13:20:54.046]                 envs <- base::Sys.getenv()
[13:20:54.046]                 names <- names(envs)
[13:20:54.046]                 common <- intersect(names, old_names)
[13:20:54.046]                 added <- setdiff(names, old_names)
[13:20:54.046]                 removed <- setdiff(old_names, names)
[13:20:54.046]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:54.046]                   envs[common]]
[13:20:54.046]                 NAMES <- toupper(changed)
[13:20:54.046]                 args <- list()
[13:20:54.046]                 for (kk in seq_along(NAMES)) {
[13:20:54.046]                   name <- changed[[kk]]
[13:20:54.046]                   NAME <- NAMES[[kk]]
[13:20:54.046]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.046]                     next
[13:20:54.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.046]                 }
[13:20:54.046]                 NAMES <- toupper(added)
[13:20:54.046]                 for (kk in seq_along(NAMES)) {
[13:20:54.046]                   name <- added[[kk]]
[13:20:54.046]                   NAME <- NAMES[[kk]]
[13:20:54.046]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.046]                     next
[13:20:54.046]                   args[[name]] <- ""
[13:20:54.046]                 }
[13:20:54.046]                 NAMES <- toupper(removed)
[13:20:54.046]                 for (kk in seq_along(NAMES)) {
[13:20:54.046]                   name <- removed[[kk]]
[13:20:54.046]                   NAME <- NAMES[[kk]]
[13:20:54.046]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.046]                     next
[13:20:54.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.046]                 }
[13:20:54.046]                 if (length(args) > 0) 
[13:20:54.046]                   base::do.call(base::Sys.setenv, args = args)
[13:20:54.046]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:54.046]             }
[13:20:54.046]             else {
[13:20:54.046]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:54.046]             }
[13:20:54.046]             {
[13:20:54.046]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:54.046]                   0L) {
[13:20:54.046]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:54.046]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:54.046]                   base::options(opts)
[13:20:54.046]                 }
[13:20:54.046]                 {
[13:20:54.046]                   {
[13:20:54.046]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:54.046]                     NULL
[13:20:54.046]                   }
[13:20:54.046]                   options(future.plan = NULL)
[13:20:54.046]                   if (is.na(NA_character_)) 
[13:20:54.046]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.046]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:54.046]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:54.046]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:54.046]                     envir = parent.frame()) 
[13:20:54.046]                   {
[13:20:54.046]                     if (is.function(workers)) 
[13:20:54.046]                       workers <- workers()
[13:20:54.046]                     workers <- structure(as.integer(workers), 
[13:20:54.046]                       class = class(workers))
[13:20:54.046]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:54.046]                       workers >= 1)
[13:20:54.046]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:54.046]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:54.046]                     }
[13:20:54.046]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:54.046]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:54.046]                       envir = envir)
[13:20:54.046]                     if (!future$lazy) 
[13:20:54.046]                       future <- run(future)
[13:20:54.046]                     invisible(future)
[13:20:54.046]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:54.046]                 }
[13:20:54.046]             }
[13:20:54.046]         }
[13:20:54.046]     })
[13:20:54.046]     if (TRUE) {
[13:20:54.046]         base::sink(type = "output", split = FALSE)
[13:20:54.046]         if (TRUE) {
[13:20:54.046]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:54.046]         }
[13:20:54.046]         else {
[13:20:54.046]             ...future.result["stdout"] <- base::list(NULL)
[13:20:54.046]         }
[13:20:54.046]         base::close(...future.stdout)
[13:20:54.046]         ...future.stdout <- NULL
[13:20:54.046]     }
[13:20:54.046]     ...future.result$conditions <- ...future.conditions
[13:20:54.046]     ...future.result$finished <- base::Sys.time()
[13:20:54.046]     ...future.result
[13:20:54.046] }
[13:20:54.049] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[13:20:54.049] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[13:20:54.050] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[13:20:54.050] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[13:20:54.050] MultisessionFuture started
[13:20:54.050] - Launch lazy future ... done
[13:20:54.050] run() for ‘MultisessionFuture’ ... done
[13:20:54.050] result() for ClusterFuture ...
[13:20:54.051] receiveMessageFromWorker() for ClusterFuture ...
[13:20:54.051] - Validating connection of MultisessionFuture
[13:20:54.098] - received message: FutureResult
[13:20:54.099] - Received FutureResult
[13:20:54.099] - Erased future from FutureRegistry
[13:20:54.099] result() for ClusterFuture ...
[13:20:54.099] - result already collected: FutureResult
[13:20:54.099] result() for ClusterFuture ... done
[13:20:54.099] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:54.100] result() for ClusterFuture ... done
[13:20:54.100] result() for ClusterFuture ...
[13:20:54.100] - result already collected: FutureResult
[13:20:54.100] result() for ClusterFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:54.100] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:54.101] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:54.102] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:20:54.103] Searching for globals ... DONE
[13:20:54.103] Resolving globals: TRUE
[13:20:54.103] Resolving any globals that are futures ...
[13:20:54.103] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[13:20:54.103] Resolving any globals that are futures ... DONE
[13:20:54.103] Resolving futures part of globals (recursively) ...
[13:20:54.104] resolve() on list ...
[13:20:54.104]  recursive: 99
[13:20:54.104]  length: 1
[13:20:54.104]  elements: ‘a’
[13:20:54.104]  length: 0 (resolved future 1)
[13:20:54.104] resolve() on list ... DONE
[13:20:54.104] - globals: [1] ‘a’
[13:20:54.104] Resolving futures part of globals (recursively) ... DONE
[13:20:54.104] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:54.105] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:20:54.105] - globals: [1] ‘a’
[13:20:54.105] 
[13:20:54.105] getGlobalsAndPackages() ... DONE
[13:20:54.106] run() for ‘Future’ ...
[13:20:54.106] - state: ‘created’
[13:20:54.106] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:54.120] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:54.120] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:54.120]   - Field: ‘node’
[13:20:54.120]   - Field: ‘label’
[13:20:54.120]   - Field: ‘local’
[13:20:54.121]   - Field: ‘owner’
[13:20:54.121]   - Field: ‘envir’
[13:20:54.121]   - Field: ‘workers’
[13:20:54.121]   - Field: ‘packages’
[13:20:54.121]   - Field: ‘gc’
[13:20:54.121]   - Field: ‘conditions’
[13:20:54.121]   - Field: ‘persistent’
[13:20:54.121]   - Field: ‘expr’
[13:20:54.121]   - Field: ‘uuid’
[13:20:54.121]   - Field: ‘seed’
[13:20:54.122]   - Field: ‘version’
[13:20:54.122]   - Field: ‘result’
[13:20:54.122]   - Field: ‘asynchronous’
[13:20:54.122]   - Field: ‘calls’
[13:20:54.122]   - Field: ‘globals’
[13:20:54.122]   - Field: ‘stdout’
[13:20:54.122]   - Field: ‘earlySignal’
[13:20:54.122]   - Field: ‘lazy’
[13:20:54.122]   - Field: ‘state’
[13:20:54.122] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:54.122] - Launch lazy future ...
[13:20:54.123] Packages needed by the future expression (n = 0): <none>
[13:20:54.123] Packages needed by future strategies (n = 0): <none>
[13:20:54.123] {
[13:20:54.123]     {
[13:20:54.123]         {
[13:20:54.123]             ...future.startTime <- base::Sys.time()
[13:20:54.123]             {
[13:20:54.123]                 {
[13:20:54.123]                   {
[13:20:54.123]                     {
[13:20:54.123]                       base::local({
[13:20:54.123]                         has_future <- base::requireNamespace("future", 
[13:20:54.123]                           quietly = TRUE)
[13:20:54.123]                         if (has_future) {
[13:20:54.123]                           ns <- base::getNamespace("future")
[13:20:54.123]                           version <- ns[[".package"]][["version"]]
[13:20:54.123]                           if (is.null(version)) 
[13:20:54.123]                             version <- utils::packageVersion("future")
[13:20:54.123]                         }
[13:20:54.123]                         else {
[13:20:54.123]                           version <- NULL
[13:20:54.123]                         }
[13:20:54.123]                         if (!has_future || version < "1.8.0") {
[13:20:54.123]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:54.123]                             "", base::R.version$version.string), 
[13:20:54.123]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:54.123]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:54.123]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:54.123]                               "release", "version")], collapse = " "), 
[13:20:54.123]                             hostname = base::Sys.info()[["nodename"]])
[13:20:54.123]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:54.123]                             info)
[13:20:54.123]                           info <- base::paste(info, collapse = "; ")
[13:20:54.123]                           if (!has_future) {
[13:20:54.123]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:54.123]                               info)
[13:20:54.123]                           }
[13:20:54.123]                           else {
[13:20:54.123]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:54.123]                               info, version)
[13:20:54.123]                           }
[13:20:54.123]                           base::stop(msg)
[13:20:54.123]                         }
[13:20:54.123]                       })
[13:20:54.123]                     }
[13:20:54.123]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:54.123]                     base::options(mc.cores = 1L)
[13:20:54.123]                   }
[13:20:54.123]                   options(future.plan = NULL)
[13:20:54.123]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.123]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:54.123]                 }
[13:20:54.123]                 ...future.workdir <- getwd()
[13:20:54.123]             }
[13:20:54.123]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:54.123]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:54.123]         }
[13:20:54.123]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:54.123]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:54.123]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:54.123]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:54.123]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:54.123]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:54.123]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:54.123]             base::names(...future.oldOptions))
[13:20:54.123]     }
[13:20:54.123]     if (FALSE) {
[13:20:54.123]     }
[13:20:54.123]     else {
[13:20:54.123]         if (TRUE) {
[13:20:54.123]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:54.123]                 open = "w")
[13:20:54.123]         }
[13:20:54.123]         else {
[13:20:54.123]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:54.123]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:54.123]         }
[13:20:54.123]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:54.123]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:54.123]             base::sink(type = "output", split = FALSE)
[13:20:54.123]             base::close(...future.stdout)
[13:20:54.123]         }, add = TRUE)
[13:20:54.123]     }
[13:20:54.123]     ...future.frame <- base::sys.nframe()
[13:20:54.123]     ...future.conditions <- base::list()
[13:20:54.123]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:54.123]     if (FALSE) {
[13:20:54.123]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:54.123]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:54.123]     }
[13:20:54.123]     ...future.result <- base::tryCatch({
[13:20:54.123]         base::withCallingHandlers({
[13:20:54.123]             ...future.value <- base::withVisible(base::local({
[13:20:54.123]                 ...future.makeSendCondition <- local({
[13:20:54.123]                   sendCondition <- NULL
[13:20:54.123]                   function(frame = 1L) {
[13:20:54.123]                     if (is.function(sendCondition)) 
[13:20:54.123]                       return(sendCondition)
[13:20:54.123]                     ns <- getNamespace("parallel")
[13:20:54.123]                     if (exists("sendData", mode = "function", 
[13:20:54.123]                       envir = ns)) {
[13:20:54.123]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:54.123]                         envir = ns)
[13:20:54.123]                       envir <- sys.frame(frame)
[13:20:54.123]                       master <- NULL
[13:20:54.123]                       while (!identical(envir, .GlobalEnv) && 
[13:20:54.123]                         !identical(envir, emptyenv())) {
[13:20:54.123]                         if (exists("master", mode = "list", envir = envir, 
[13:20:54.123]                           inherits = FALSE)) {
[13:20:54.123]                           master <- get("master", mode = "list", 
[13:20:54.123]                             envir = envir, inherits = FALSE)
[13:20:54.123]                           if (inherits(master, c("SOCKnode", 
[13:20:54.123]                             "SOCK0node"))) {
[13:20:54.123]                             sendCondition <<- function(cond) {
[13:20:54.123]                               data <- list(type = "VALUE", value = cond, 
[13:20:54.123]                                 success = TRUE)
[13:20:54.123]                               parallel_sendData(master, data)
[13:20:54.123]                             }
[13:20:54.123]                             return(sendCondition)
[13:20:54.123]                           }
[13:20:54.123]                         }
[13:20:54.123]                         frame <- frame + 1L
[13:20:54.123]                         envir <- sys.frame(frame)
[13:20:54.123]                       }
[13:20:54.123]                     }
[13:20:54.123]                     sendCondition <<- function(cond) NULL
[13:20:54.123]                   }
[13:20:54.123]                 })
[13:20:54.123]                 withCallingHandlers({
[13:20:54.123]                   {
[13:20:54.123]                     b <- a
[13:20:54.123]                     a <- 2
[13:20:54.123]                     a * b
[13:20:54.123]                   }
[13:20:54.123]                 }, immediateCondition = function(cond) {
[13:20:54.123]                   sendCondition <- ...future.makeSendCondition()
[13:20:54.123]                   sendCondition(cond)
[13:20:54.123]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.123]                   {
[13:20:54.123]                     inherits <- base::inherits
[13:20:54.123]                     invokeRestart <- base::invokeRestart
[13:20:54.123]                     is.null <- base::is.null
[13:20:54.123]                     muffled <- FALSE
[13:20:54.123]                     if (inherits(cond, "message")) {
[13:20:54.123]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:54.123]                       if (muffled) 
[13:20:54.123]                         invokeRestart("muffleMessage")
[13:20:54.123]                     }
[13:20:54.123]                     else if (inherits(cond, "warning")) {
[13:20:54.123]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:54.123]                       if (muffled) 
[13:20:54.123]                         invokeRestart("muffleWarning")
[13:20:54.123]                     }
[13:20:54.123]                     else if (inherits(cond, "condition")) {
[13:20:54.123]                       if (!is.null(pattern)) {
[13:20:54.123]                         computeRestarts <- base::computeRestarts
[13:20:54.123]                         grepl <- base::grepl
[13:20:54.123]                         restarts <- computeRestarts(cond)
[13:20:54.123]                         for (restart in restarts) {
[13:20:54.123]                           name <- restart$name
[13:20:54.123]                           if (is.null(name)) 
[13:20:54.123]                             next
[13:20:54.123]                           if (!grepl(pattern, name)) 
[13:20:54.123]                             next
[13:20:54.123]                           invokeRestart(restart)
[13:20:54.123]                           muffled <- TRUE
[13:20:54.123]                           break
[13:20:54.123]                         }
[13:20:54.123]                       }
[13:20:54.123]                     }
[13:20:54.123]                     invisible(muffled)
[13:20:54.123]                   }
[13:20:54.123]                   muffleCondition(cond)
[13:20:54.123]                 })
[13:20:54.123]             }))
[13:20:54.123]             future::FutureResult(value = ...future.value$value, 
[13:20:54.123]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.123]                   ...future.rng), globalenv = if (FALSE) 
[13:20:54.123]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:54.123]                     ...future.globalenv.names))
[13:20:54.123]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:54.123]         }, condition = base::local({
[13:20:54.123]             c <- base::c
[13:20:54.123]             inherits <- base::inherits
[13:20:54.123]             invokeRestart <- base::invokeRestart
[13:20:54.123]             length <- base::length
[13:20:54.123]             list <- base::list
[13:20:54.123]             seq.int <- base::seq.int
[13:20:54.123]             signalCondition <- base::signalCondition
[13:20:54.123]             sys.calls <- base::sys.calls
[13:20:54.123]             `[[` <- base::`[[`
[13:20:54.123]             `+` <- base::`+`
[13:20:54.123]             `<<-` <- base::`<<-`
[13:20:54.123]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:54.123]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:54.123]                   3L)]
[13:20:54.123]             }
[13:20:54.123]             function(cond) {
[13:20:54.123]                 is_error <- inherits(cond, "error")
[13:20:54.123]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:54.123]                   NULL)
[13:20:54.123]                 if (is_error) {
[13:20:54.123]                   sessionInformation <- function() {
[13:20:54.123]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:54.123]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:54.123]                       search = base::search(), system = base::Sys.info())
[13:20:54.123]                   }
[13:20:54.123]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.123]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:54.123]                     cond$call), session = sessionInformation(), 
[13:20:54.123]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:54.123]                   signalCondition(cond)
[13:20:54.123]                 }
[13:20:54.123]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:54.123]                 "immediateCondition"))) {
[13:20:54.123]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:54.123]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.123]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:54.123]                   if (TRUE && !signal) {
[13:20:54.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.123]                     {
[13:20:54.123]                       inherits <- base::inherits
[13:20:54.123]                       invokeRestart <- base::invokeRestart
[13:20:54.123]                       is.null <- base::is.null
[13:20:54.123]                       muffled <- FALSE
[13:20:54.123]                       if (inherits(cond, "message")) {
[13:20:54.123]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.123]                         if (muffled) 
[13:20:54.123]                           invokeRestart("muffleMessage")
[13:20:54.123]                       }
[13:20:54.123]                       else if (inherits(cond, "warning")) {
[13:20:54.123]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.123]                         if (muffled) 
[13:20:54.123]                           invokeRestart("muffleWarning")
[13:20:54.123]                       }
[13:20:54.123]                       else if (inherits(cond, "condition")) {
[13:20:54.123]                         if (!is.null(pattern)) {
[13:20:54.123]                           computeRestarts <- base::computeRestarts
[13:20:54.123]                           grepl <- base::grepl
[13:20:54.123]                           restarts <- computeRestarts(cond)
[13:20:54.123]                           for (restart in restarts) {
[13:20:54.123]                             name <- restart$name
[13:20:54.123]                             if (is.null(name)) 
[13:20:54.123]                               next
[13:20:54.123]                             if (!grepl(pattern, name)) 
[13:20:54.123]                               next
[13:20:54.123]                             invokeRestart(restart)
[13:20:54.123]                             muffled <- TRUE
[13:20:54.123]                             break
[13:20:54.123]                           }
[13:20:54.123]                         }
[13:20:54.123]                       }
[13:20:54.123]                       invisible(muffled)
[13:20:54.123]                     }
[13:20:54.123]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.123]                   }
[13:20:54.123]                 }
[13:20:54.123]                 else {
[13:20:54.123]                   if (TRUE) {
[13:20:54.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.123]                     {
[13:20:54.123]                       inherits <- base::inherits
[13:20:54.123]                       invokeRestart <- base::invokeRestart
[13:20:54.123]                       is.null <- base::is.null
[13:20:54.123]                       muffled <- FALSE
[13:20:54.123]                       if (inherits(cond, "message")) {
[13:20:54.123]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.123]                         if (muffled) 
[13:20:54.123]                           invokeRestart("muffleMessage")
[13:20:54.123]                       }
[13:20:54.123]                       else if (inherits(cond, "warning")) {
[13:20:54.123]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.123]                         if (muffled) 
[13:20:54.123]                           invokeRestart("muffleWarning")
[13:20:54.123]                       }
[13:20:54.123]                       else if (inherits(cond, "condition")) {
[13:20:54.123]                         if (!is.null(pattern)) {
[13:20:54.123]                           computeRestarts <- base::computeRestarts
[13:20:54.123]                           grepl <- base::grepl
[13:20:54.123]                           restarts <- computeRestarts(cond)
[13:20:54.123]                           for (restart in restarts) {
[13:20:54.123]                             name <- restart$name
[13:20:54.123]                             if (is.null(name)) 
[13:20:54.123]                               next
[13:20:54.123]                             if (!grepl(pattern, name)) 
[13:20:54.123]                               next
[13:20:54.123]                             invokeRestart(restart)
[13:20:54.123]                             muffled <- TRUE
[13:20:54.123]                             break
[13:20:54.123]                           }
[13:20:54.123]                         }
[13:20:54.123]                       }
[13:20:54.123]                       invisible(muffled)
[13:20:54.123]                     }
[13:20:54.123]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.123]                   }
[13:20:54.123]                 }
[13:20:54.123]             }
[13:20:54.123]         }))
[13:20:54.123]     }, error = function(ex) {
[13:20:54.123]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:54.123]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.123]                 ...future.rng), started = ...future.startTime, 
[13:20:54.123]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:54.123]             version = "1.8"), class = "FutureResult")
[13:20:54.123]     }, finally = {
[13:20:54.123]         if (!identical(...future.workdir, getwd())) 
[13:20:54.123]             setwd(...future.workdir)
[13:20:54.123]         {
[13:20:54.123]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:54.123]                 ...future.oldOptions$nwarnings <- NULL
[13:20:54.123]             }
[13:20:54.123]             base::options(...future.oldOptions)
[13:20:54.123]             if (.Platform$OS.type == "windows") {
[13:20:54.123]                 old_names <- names(...future.oldEnvVars)
[13:20:54.123]                 envs <- base::Sys.getenv()
[13:20:54.123]                 names <- names(envs)
[13:20:54.123]                 common <- intersect(names, old_names)
[13:20:54.123]                 added <- setdiff(names, old_names)
[13:20:54.123]                 removed <- setdiff(old_names, names)
[13:20:54.123]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:54.123]                   envs[common]]
[13:20:54.123]                 NAMES <- toupper(changed)
[13:20:54.123]                 args <- list()
[13:20:54.123]                 for (kk in seq_along(NAMES)) {
[13:20:54.123]                   name <- changed[[kk]]
[13:20:54.123]                   NAME <- NAMES[[kk]]
[13:20:54.123]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.123]                     next
[13:20:54.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.123]                 }
[13:20:54.123]                 NAMES <- toupper(added)
[13:20:54.123]                 for (kk in seq_along(NAMES)) {
[13:20:54.123]                   name <- added[[kk]]
[13:20:54.123]                   NAME <- NAMES[[kk]]
[13:20:54.123]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.123]                     next
[13:20:54.123]                   args[[name]] <- ""
[13:20:54.123]                 }
[13:20:54.123]                 NAMES <- toupper(removed)
[13:20:54.123]                 for (kk in seq_along(NAMES)) {
[13:20:54.123]                   name <- removed[[kk]]
[13:20:54.123]                   NAME <- NAMES[[kk]]
[13:20:54.123]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.123]                     next
[13:20:54.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.123]                 }
[13:20:54.123]                 if (length(args) > 0) 
[13:20:54.123]                   base::do.call(base::Sys.setenv, args = args)
[13:20:54.123]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:54.123]             }
[13:20:54.123]             else {
[13:20:54.123]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:54.123]             }
[13:20:54.123]             {
[13:20:54.123]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:54.123]                   0L) {
[13:20:54.123]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:54.123]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:54.123]                   base::options(opts)
[13:20:54.123]                 }
[13:20:54.123]                 {
[13:20:54.123]                   {
[13:20:54.123]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:54.123]                     NULL
[13:20:54.123]                   }
[13:20:54.123]                   options(future.plan = NULL)
[13:20:54.123]                   if (is.na(NA_character_)) 
[13:20:54.123]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.123]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:54.123]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:54.123]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:54.123]                     envir = parent.frame()) 
[13:20:54.123]                   {
[13:20:54.123]                     if (is.function(workers)) 
[13:20:54.123]                       workers <- workers()
[13:20:54.123]                     workers <- structure(as.integer(workers), 
[13:20:54.123]                       class = class(workers))
[13:20:54.123]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:54.123]                       workers >= 1)
[13:20:54.123]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:54.123]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:54.123]                     }
[13:20:54.123]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:54.123]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:54.123]                       envir = envir)
[13:20:54.123]                     if (!future$lazy) 
[13:20:54.123]                       future <- run(future)
[13:20:54.123]                     invisible(future)
[13:20:54.123]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:54.123]                 }
[13:20:54.123]             }
[13:20:54.123]         }
[13:20:54.123]     })
[13:20:54.123]     if (TRUE) {
[13:20:54.123]         base::sink(type = "output", split = FALSE)
[13:20:54.123]         if (TRUE) {
[13:20:54.123]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:54.123]         }
[13:20:54.123]         else {
[13:20:54.123]             ...future.result["stdout"] <- base::list(NULL)
[13:20:54.123]         }
[13:20:54.123]         base::close(...future.stdout)
[13:20:54.123]         ...future.stdout <- NULL
[13:20:54.123]     }
[13:20:54.123]     ...future.result$conditions <- ...future.conditions
[13:20:54.123]     ...future.result$finished <- base::Sys.time()
[13:20:54.123]     ...future.result
[13:20:54.123] }
[13:20:54.126] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[13:20:54.126] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[13:20:54.126] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[13:20:54.127] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[13:20:54.127] MultisessionFuture started
[13:20:54.127] - Launch lazy future ... done
[13:20:54.127] run() for ‘MultisessionFuture’ ... done
[13:20:54.127] result() for ClusterFuture ...
[13:20:54.127] receiveMessageFromWorker() for ClusterFuture ...
[13:20:54.128] - Validating connection of MultisessionFuture
[13:20:54.174] - received message: FutureResult
[13:20:54.175] - Received FutureResult
[13:20:54.175] - Erased future from FutureRegistry
[13:20:54.175] result() for ClusterFuture ...
[13:20:54.175] - result already collected: FutureResult
[13:20:54.175] result() for ClusterFuture ... done
[13:20:54.175] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:54.175] result() for ClusterFuture ... done
[13:20:54.175] result() for ClusterFuture ...
[13:20:54.176] - result already collected: FutureResult
[13:20:54.176] result() for ClusterFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:54.176] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:54.176] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:54.178] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:54.179] Searching for globals ... DONE
[13:20:54.179] Resolving globals: TRUE
[13:20:54.179] Resolving any globals that are futures ...
[13:20:54.179] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:54.179] Resolving any globals that are futures ... DONE
[13:20:54.179] Resolving futures part of globals (recursively) ...
[13:20:54.180] resolve() on list ...
[13:20:54.180]  recursive: 99
[13:20:54.180]  length: 2
[13:20:54.180]  elements: ‘a’, ‘ii’
[13:20:54.180]  length: 1 (resolved future 1)
[13:20:54.180]  length: 0 (resolved future 2)
[13:20:54.180] resolve() on list ... DONE
[13:20:54.180] - globals: [2] ‘a’, ‘ii’
[13:20:54.181] Resolving futures part of globals (recursively) ... DONE
[13:20:54.181] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:54.183] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:20:54.183] - globals: [2] ‘a’, ‘ii’
[13:20:54.184] 
[13:20:54.184] getGlobalsAndPackages() ... DONE
[13:20:54.184] run() for ‘Future’ ...
[13:20:54.184] - state: ‘created’
[13:20:54.184] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:54.198] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:54.198] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:54.199]   - Field: ‘node’
[13:20:54.199]   - Field: ‘label’
[13:20:54.199]   - Field: ‘local’
[13:20:54.199]   - Field: ‘owner’
[13:20:54.199]   - Field: ‘envir’
[13:20:54.199]   - Field: ‘workers’
[13:20:54.199]   - Field: ‘packages’
[13:20:54.199]   - Field: ‘gc’
[13:20:54.199]   - Field: ‘conditions’
[13:20:54.199]   - Field: ‘persistent’
[13:20:54.200]   - Field: ‘expr’
[13:20:54.200]   - Field: ‘uuid’
[13:20:54.200]   - Field: ‘seed’
[13:20:54.200]   - Field: ‘version’
[13:20:54.200]   - Field: ‘result’
[13:20:54.200]   - Field: ‘asynchronous’
[13:20:54.200]   - Field: ‘calls’
[13:20:54.200]   - Field: ‘globals’
[13:20:54.200]   - Field: ‘stdout’
[13:20:54.200]   - Field: ‘earlySignal’
[13:20:54.200]   - Field: ‘lazy’
[13:20:54.201]   - Field: ‘state’
[13:20:54.201] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:54.201] - Launch lazy future ...
[13:20:54.201] Packages needed by the future expression (n = 0): <none>
[13:20:54.201] Packages needed by future strategies (n = 0): <none>
[13:20:54.202] {
[13:20:54.202]     {
[13:20:54.202]         {
[13:20:54.202]             ...future.startTime <- base::Sys.time()
[13:20:54.202]             {
[13:20:54.202]                 {
[13:20:54.202]                   {
[13:20:54.202]                     {
[13:20:54.202]                       base::local({
[13:20:54.202]                         has_future <- base::requireNamespace("future", 
[13:20:54.202]                           quietly = TRUE)
[13:20:54.202]                         if (has_future) {
[13:20:54.202]                           ns <- base::getNamespace("future")
[13:20:54.202]                           version <- ns[[".package"]][["version"]]
[13:20:54.202]                           if (is.null(version)) 
[13:20:54.202]                             version <- utils::packageVersion("future")
[13:20:54.202]                         }
[13:20:54.202]                         else {
[13:20:54.202]                           version <- NULL
[13:20:54.202]                         }
[13:20:54.202]                         if (!has_future || version < "1.8.0") {
[13:20:54.202]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:54.202]                             "", base::R.version$version.string), 
[13:20:54.202]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:54.202]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:54.202]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:54.202]                               "release", "version")], collapse = " "), 
[13:20:54.202]                             hostname = base::Sys.info()[["nodename"]])
[13:20:54.202]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:54.202]                             info)
[13:20:54.202]                           info <- base::paste(info, collapse = "; ")
[13:20:54.202]                           if (!has_future) {
[13:20:54.202]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:54.202]                               info)
[13:20:54.202]                           }
[13:20:54.202]                           else {
[13:20:54.202]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:54.202]                               info, version)
[13:20:54.202]                           }
[13:20:54.202]                           base::stop(msg)
[13:20:54.202]                         }
[13:20:54.202]                       })
[13:20:54.202]                     }
[13:20:54.202]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:54.202]                     base::options(mc.cores = 1L)
[13:20:54.202]                   }
[13:20:54.202]                   options(future.plan = NULL)
[13:20:54.202]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.202]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:54.202]                 }
[13:20:54.202]                 ...future.workdir <- getwd()
[13:20:54.202]             }
[13:20:54.202]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:54.202]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:54.202]         }
[13:20:54.202]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:54.202]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:54.202]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:54.202]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:54.202]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:54.202]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:54.202]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:54.202]             base::names(...future.oldOptions))
[13:20:54.202]     }
[13:20:54.202]     if (FALSE) {
[13:20:54.202]     }
[13:20:54.202]     else {
[13:20:54.202]         if (TRUE) {
[13:20:54.202]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:54.202]                 open = "w")
[13:20:54.202]         }
[13:20:54.202]         else {
[13:20:54.202]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:54.202]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:54.202]         }
[13:20:54.202]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:54.202]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:54.202]             base::sink(type = "output", split = FALSE)
[13:20:54.202]             base::close(...future.stdout)
[13:20:54.202]         }, add = TRUE)
[13:20:54.202]     }
[13:20:54.202]     ...future.frame <- base::sys.nframe()
[13:20:54.202]     ...future.conditions <- base::list()
[13:20:54.202]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:54.202]     if (FALSE) {
[13:20:54.202]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:54.202]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:54.202]     }
[13:20:54.202]     ...future.result <- base::tryCatch({
[13:20:54.202]         base::withCallingHandlers({
[13:20:54.202]             ...future.value <- base::withVisible(base::local({
[13:20:54.202]                 ...future.makeSendCondition <- local({
[13:20:54.202]                   sendCondition <- NULL
[13:20:54.202]                   function(frame = 1L) {
[13:20:54.202]                     if (is.function(sendCondition)) 
[13:20:54.202]                       return(sendCondition)
[13:20:54.202]                     ns <- getNamespace("parallel")
[13:20:54.202]                     if (exists("sendData", mode = "function", 
[13:20:54.202]                       envir = ns)) {
[13:20:54.202]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:54.202]                         envir = ns)
[13:20:54.202]                       envir <- sys.frame(frame)
[13:20:54.202]                       master <- NULL
[13:20:54.202]                       while (!identical(envir, .GlobalEnv) && 
[13:20:54.202]                         !identical(envir, emptyenv())) {
[13:20:54.202]                         if (exists("master", mode = "list", envir = envir, 
[13:20:54.202]                           inherits = FALSE)) {
[13:20:54.202]                           master <- get("master", mode = "list", 
[13:20:54.202]                             envir = envir, inherits = FALSE)
[13:20:54.202]                           if (inherits(master, c("SOCKnode", 
[13:20:54.202]                             "SOCK0node"))) {
[13:20:54.202]                             sendCondition <<- function(cond) {
[13:20:54.202]                               data <- list(type = "VALUE", value = cond, 
[13:20:54.202]                                 success = TRUE)
[13:20:54.202]                               parallel_sendData(master, data)
[13:20:54.202]                             }
[13:20:54.202]                             return(sendCondition)
[13:20:54.202]                           }
[13:20:54.202]                         }
[13:20:54.202]                         frame <- frame + 1L
[13:20:54.202]                         envir <- sys.frame(frame)
[13:20:54.202]                       }
[13:20:54.202]                     }
[13:20:54.202]                     sendCondition <<- function(cond) NULL
[13:20:54.202]                   }
[13:20:54.202]                 })
[13:20:54.202]                 withCallingHandlers({
[13:20:54.202]                   {
[13:20:54.202]                     b <- a * ii
[13:20:54.202]                     a <- 0
[13:20:54.202]                     b
[13:20:54.202]                   }
[13:20:54.202]                 }, immediateCondition = function(cond) {
[13:20:54.202]                   sendCondition <- ...future.makeSendCondition()
[13:20:54.202]                   sendCondition(cond)
[13:20:54.202]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.202]                   {
[13:20:54.202]                     inherits <- base::inherits
[13:20:54.202]                     invokeRestart <- base::invokeRestart
[13:20:54.202]                     is.null <- base::is.null
[13:20:54.202]                     muffled <- FALSE
[13:20:54.202]                     if (inherits(cond, "message")) {
[13:20:54.202]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:54.202]                       if (muffled) 
[13:20:54.202]                         invokeRestart("muffleMessage")
[13:20:54.202]                     }
[13:20:54.202]                     else if (inherits(cond, "warning")) {
[13:20:54.202]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:54.202]                       if (muffled) 
[13:20:54.202]                         invokeRestart("muffleWarning")
[13:20:54.202]                     }
[13:20:54.202]                     else if (inherits(cond, "condition")) {
[13:20:54.202]                       if (!is.null(pattern)) {
[13:20:54.202]                         computeRestarts <- base::computeRestarts
[13:20:54.202]                         grepl <- base::grepl
[13:20:54.202]                         restarts <- computeRestarts(cond)
[13:20:54.202]                         for (restart in restarts) {
[13:20:54.202]                           name <- restart$name
[13:20:54.202]                           if (is.null(name)) 
[13:20:54.202]                             next
[13:20:54.202]                           if (!grepl(pattern, name)) 
[13:20:54.202]                             next
[13:20:54.202]                           invokeRestart(restart)
[13:20:54.202]                           muffled <- TRUE
[13:20:54.202]                           break
[13:20:54.202]                         }
[13:20:54.202]                       }
[13:20:54.202]                     }
[13:20:54.202]                     invisible(muffled)
[13:20:54.202]                   }
[13:20:54.202]                   muffleCondition(cond)
[13:20:54.202]                 })
[13:20:54.202]             }))
[13:20:54.202]             future::FutureResult(value = ...future.value$value, 
[13:20:54.202]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.202]                   ...future.rng), globalenv = if (FALSE) 
[13:20:54.202]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:54.202]                     ...future.globalenv.names))
[13:20:54.202]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:54.202]         }, condition = base::local({
[13:20:54.202]             c <- base::c
[13:20:54.202]             inherits <- base::inherits
[13:20:54.202]             invokeRestart <- base::invokeRestart
[13:20:54.202]             length <- base::length
[13:20:54.202]             list <- base::list
[13:20:54.202]             seq.int <- base::seq.int
[13:20:54.202]             signalCondition <- base::signalCondition
[13:20:54.202]             sys.calls <- base::sys.calls
[13:20:54.202]             `[[` <- base::`[[`
[13:20:54.202]             `+` <- base::`+`
[13:20:54.202]             `<<-` <- base::`<<-`
[13:20:54.202]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:54.202]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:54.202]                   3L)]
[13:20:54.202]             }
[13:20:54.202]             function(cond) {
[13:20:54.202]                 is_error <- inherits(cond, "error")
[13:20:54.202]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:54.202]                   NULL)
[13:20:54.202]                 if (is_error) {
[13:20:54.202]                   sessionInformation <- function() {
[13:20:54.202]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:54.202]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:54.202]                       search = base::search(), system = base::Sys.info())
[13:20:54.202]                   }
[13:20:54.202]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.202]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:54.202]                     cond$call), session = sessionInformation(), 
[13:20:54.202]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:54.202]                   signalCondition(cond)
[13:20:54.202]                 }
[13:20:54.202]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:54.202]                 "immediateCondition"))) {
[13:20:54.202]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:54.202]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.202]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:54.202]                   if (TRUE && !signal) {
[13:20:54.202]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.202]                     {
[13:20:54.202]                       inherits <- base::inherits
[13:20:54.202]                       invokeRestart <- base::invokeRestart
[13:20:54.202]                       is.null <- base::is.null
[13:20:54.202]                       muffled <- FALSE
[13:20:54.202]                       if (inherits(cond, "message")) {
[13:20:54.202]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.202]                         if (muffled) 
[13:20:54.202]                           invokeRestart("muffleMessage")
[13:20:54.202]                       }
[13:20:54.202]                       else if (inherits(cond, "warning")) {
[13:20:54.202]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.202]                         if (muffled) 
[13:20:54.202]                           invokeRestart("muffleWarning")
[13:20:54.202]                       }
[13:20:54.202]                       else if (inherits(cond, "condition")) {
[13:20:54.202]                         if (!is.null(pattern)) {
[13:20:54.202]                           computeRestarts <- base::computeRestarts
[13:20:54.202]                           grepl <- base::grepl
[13:20:54.202]                           restarts <- computeRestarts(cond)
[13:20:54.202]                           for (restart in restarts) {
[13:20:54.202]                             name <- restart$name
[13:20:54.202]                             if (is.null(name)) 
[13:20:54.202]                               next
[13:20:54.202]                             if (!grepl(pattern, name)) 
[13:20:54.202]                               next
[13:20:54.202]                             invokeRestart(restart)
[13:20:54.202]                             muffled <- TRUE
[13:20:54.202]                             break
[13:20:54.202]                           }
[13:20:54.202]                         }
[13:20:54.202]                       }
[13:20:54.202]                       invisible(muffled)
[13:20:54.202]                     }
[13:20:54.202]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.202]                   }
[13:20:54.202]                 }
[13:20:54.202]                 else {
[13:20:54.202]                   if (TRUE) {
[13:20:54.202]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.202]                     {
[13:20:54.202]                       inherits <- base::inherits
[13:20:54.202]                       invokeRestart <- base::invokeRestart
[13:20:54.202]                       is.null <- base::is.null
[13:20:54.202]                       muffled <- FALSE
[13:20:54.202]                       if (inherits(cond, "message")) {
[13:20:54.202]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.202]                         if (muffled) 
[13:20:54.202]                           invokeRestart("muffleMessage")
[13:20:54.202]                       }
[13:20:54.202]                       else if (inherits(cond, "warning")) {
[13:20:54.202]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.202]                         if (muffled) 
[13:20:54.202]                           invokeRestart("muffleWarning")
[13:20:54.202]                       }
[13:20:54.202]                       else if (inherits(cond, "condition")) {
[13:20:54.202]                         if (!is.null(pattern)) {
[13:20:54.202]                           computeRestarts <- base::computeRestarts
[13:20:54.202]                           grepl <- base::grepl
[13:20:54.202]                           restarts <- computeRestarts(cond)
[13:20:54.202]                           for (restart in restarts) {
[13:20:54.202]                             name <- restart$name
[13:20:54.202]                             if (is.null(name)) 
[13:20:54.202]                               next
[13:20:54.202]                             if (!grepl(pattern, name)) 
[13:20:54.202]                               next
[13:20:54.202]                             invokeRestart(restart)
[13:20:54.202]                             muffled <- TRUE
[13:20:54.202]                             break
[13:20:54.202]                           }
[13:20:54.202]                         }
[13:20:54.202]                       }
[13:20:54.202]                       invisible(muffled)
[13:20:54.202]                     }
[13:20:54.202]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.202]                   }
[13:20:54.202]                 }
[13:20:54.202]             }
[13:20:54.202]         }))
[13:20:54.202]     }, error = function(ex) {
[13:20:54.202]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:54.202]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.202]                 ...future.rng), started = ...future.startTime, 
[13:20:54.202]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:54.202]             version = "1.8"), class = "FutureResult")
[13:20:54.202]     }, finally = {
[13:20:54.202]         if (!identical(...future.workdir, getwd())) 
[13:20:54.202]             setwd(...future.workdir)
[13:20:54.202]         {
[13:20:54.202]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:54.202]                 ...future.oldOptions$nwarnings <- NULL
[13:20:54.202]             }
[13:20:54.202]             base::options(...future.oldOptions)
[13:20:54.202]             if (.Platform$OS.type == "windows") {
[13:20:54.202]                 old_names <- names(...future.oldEnvVars)
[13:20:54.202]                 envs <- base::Sys.getenv()
[13:20:54.202]                 names <- names(envs)
[13:20:54.202]                 common <- intersect(names, old_names)
[13:20:54.202]                 added <- setdiff(names, old_names)
[13:20:54.202]                 removed <- setdiff(old_names, names)
[13:20:54.202]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:54.202]                   envs[common]]
[13:20:54.202]                 NAMES <- toupper(changed)
[13:20:54.202]                 args <- list()
[13:20:54.202]                 for (kk in seq_along(NAMES)) {
[13:20:54.202]                   name <- changed[[kk]]
[13:20:54.202]                   NAME <- NAMES[[kk]]
[13:20:54.202]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.202]                     next
[13:20:54.202]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.202]                 }
[13:20:54.202]                 NAMES <- toupper(added)
[13:20:54.202]                 for (kk in seq_along(NAMES)) {
[13:20:54.202]                   name <- added[[kk]]
[13:20:54.202]                   NAME <- NAMES[[kk]]
[13:20:54.202]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.202]                     next
[13:20:54.202]                   args[[name]] <- ""
[13:20:54.202]                 }
[13:20:54.202]                 NAMES <- toupper(removed)
[13:20:54.202]                 for (kk in seq_along(NAMES)) {
[13:20:54.202]                   name <- removed[[kk]]
[13:20:54.202]                   NAME <- NAMES[[kk]]
[13:20:54.202]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.202]                     next
[13:20:54.202]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.202]                 }
[13:20:54.202]                 if (length(args) > 0) 
[13:20:54.202]                   base::do.call(base::Sys.setenv, args = args)
[13:20:54.202]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:54.202]             }
[13:20:54.202]             else {
[13:20:54.202]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:54.202]             }
[13:20:54.202]             {
[13:20:54.202]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:54.202]                   0L) {
[13:20:54.202]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:54.202]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:54.202]                   base::options(opts)
[13:20:54.202]                 }
[13:20:54.202]                 {
[13:20:54.202]                   {
[13:20:54.202]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:54.202]                     NULL
[13:20:54.202]                   }
[13:20:54.202]                   options(future.plan = NULL)
[13:20:54.202]                   if (is.na(NA_character_)) 
[13:20:54.202]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.202]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:54.202]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:54.202]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:54.202]                     envir = parent.frame()) 
[13:20:54.202]                   {
[13:20:54.202]                     if (is.function(workers)) 
[13:20:54.202]                       workers <- workers()
[13:20:54.202]                     workers <- structure(as.integer(workers), 
[13:20:54.202]                       class = class(workers))
[13:20:54.202]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:54.202]                       workers >= 1)
[13:20:54.202]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:54.202]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:54.202]                     }
[13:20:54.202]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:54.202]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:54.202]                       envir = envir)
[13:20:54.202]                     if (!future$lazy) 
[13:20:54.202]                       future <- run(future)
[13:20:54.202]                     invisible(future)
[13:20:54.202]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:54.202]                 }
[13:20:54.202]             }
[13:20:54.202]         }
[13:20:54.202]     })
[13:20:54.202]     if (TRUE) {
[13:20:54.202]         base::sink(type = "output", split = FALSE)
[13:20:54.202]         if (TRUE) {
[13:20:54.202]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:54.202]         }
[13:20:54.202]         else {
[13:20:54.202]             ...future.result["stdout"] <- base::list(NULL)
[13:20:54.202]         }
[13:20:54.202]         base::close(...future.stdout)
[13:20:54.202]         ...future.stdout <- NULL
[13:20:54.202]     }
[13:20:54.202]     ...future.result$conditions <- ...future.conditions
[13:20:54.202]     ...future.result$finished <- base::Sys.time()
[13:20:54.202]     ...future.result
[13:20:54.202] }
[13:20:54.204] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[13:20:54.204] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[13:20:54.205] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[13:20:54.205] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[13:20:54.205] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[13:20:54.205] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[13:20:54.206] MultisessionFuture started
[13:20:54.206] - Launch lazy future ... done
[13:20:54.206] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:54.206] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:54.207] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:54.208] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:54.209] Searching for globals ... DONE
[13:20:54.209] Resolving globals: TRUE
[13:20:54.209] Resolving any globals that are futures ...
[13:20:54.209] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:54.209] Resolving any globals that are futures ... DONE
[13:20:54.209] Resolving futures part of globals (recursively) ...
[13:20:54.210] resolve() on list ...
[13:20:54.210]  recursive: 99
[13:20:54.210]  length: 2
[13:20:54.210]  elements: ‘a’, ‘ii’
[13:20:54.210]  length: 1 (resolved future 1)
[13:20:54.210]  length: 0 (resolved future 2)
[13:20:54.210] resolve() on list ... DONE
[13:20:54.210] - globals: [2] ‘a’, ‘ii’
[13:20:54.210] Resolving futures part of globals (recursively) ... DONE
[13:20:54.210] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:54.211] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:20:54.211] - globals: [2] ‘a’, ‘ii’
[13:20:54.211] 
[13:20:54.211] getGlobalsAndPackages() ... DONE
[13:20:54.211] run() for ‘Future’ ...
[13:20:54.211] - state: ‘created’
[13:20:54.212] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:54.226] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:54.226] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:54.226]   - Field: ‘node’
[13:20:54.226]   - Field: ‘label’
[13:20:54.226]   - Field: ‘local’
[13:20:54.226]   - Field: ‘owner’
[13:20:54.226]   - Field: ‘envir’
[13:20:54.227]   - Field: ‘workers’
[13:20:54.227]   - Field: ‘packages’
[13:20:54.227]   - Field: ‘gc’
[13:20:54.227]   - Field: ‘conditions’
[13:20:54.227]   - Field: ‘persistent’
[13:20:54.227]   - Field: ‘expr’
[13:20:54.227]   - Field: ‘uuid’
[13:20:54.227]   - Field: ‘seed’
[13:20:54.227]   - Field: ‘version’
[13:20:54.227]   - Field: ‘result’
[13:20:54.227]   - Field: ‘asynchronous’
[13:20:54.228]   - Field: ‘calls’
[13:20:54.228]   - Field: ‘globals’
[13:20:54.228]   - Field: ‘stdout’
[13:20:54.228]   - Field: ‘earlySignal’
[13:20:54.228]   - Field: ‘lazy’
[13:20:54.228]   - Field: ‘state’
[13:20:54.228] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:54.228] - Launch lazy future ...
[13:20:54.228] Packages needed by the future expression (n = 0): <none>
[13:20:54.229] Packages needed by future strategies (n = 0): <none>
[13:20:54.229] {
[13:20:54.229]     {
[13:20:54.229]         {
[13:20:54.229]             ...future.startTime <- base::Sys.time()
[13:20:54.229]             {
[13:20:54.229]                 {
[13:20:54.229]                   {
[13:20:54.229]                     {
[13:20:54.229]                       base::local({
[13:20:54.229]                         has_future <- base::requireNamespace("future", 
[13:20:54.229]                           quietly = TRUE)
[13:20:54.229]                         if (has_future) {
[13:20:54.229]                           ns <- base::getNamespace("future")
[13:20:54.229]                           version <- ns[[".package"]][["version"]]
[13:20:54.229]                           if (is.null(version)) 
[13:20:54.229]                             version <- utils::packageVersion("future")
[13:20:54.229]                         }
[13:20:54.229]                         else {
[13:20:54.229]                           version <- NULL
[13:20:54.229]                         }
[13:20:54.229]                         if (!has_future || version < "1.8.0") {
[13:20:54.229]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:54.229]                             "", base::R.version$version.string), 
[13:20:54.229]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:54.229]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:54.229]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:54.229]                               "release", "version")], collapse = " "), 
[13:20:54.229]                             hostname = base::Sys.info()[["nodename"]])
[13:20:54.229]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:54.229]                             info)
[13:20:54.229]                           info <- base::paste(info, collapse = "; ")
[13:20:54.229]                           if (!has_future) {
[13:20:54.229]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:54.229]                               info)
[13:20:54.229]                           }
[13:20:54.229]                           else {
[13:20:54.229]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:54.229]                               info, version)
[13:20:54.229]                           }
[13:20:54.229]                           base::stop(msg)
[13:20:54.229]                         }
[13:20:54.229]                       })
[13:20:54.229]                     }
[13:20:54.229]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:54.229]                     base::options(mc.cores = 1L)
[13:20:54.229]                   }
[13:20:54.229]                   options(future.plan = NULL)
[13:20:54.229]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.229]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:54.229]                 }
[13:20:54.229]                 ...future.workdir <- getwd()
[13:20:54.229]             }
[13:20:54.229]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:54.229]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:54.229]         }
[13:20:54.229]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:54.229]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:54.229]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:54.229]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:54.229]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:54.229]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:54.229]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:54.229]             base::names(...future.oldOptions))
[13:20:54.229]     }
[13:20:54.229]     if (FALSE) {
[13:20:54.229]     }
[13:20:54.229]     else {
[13:20:54.229]         if (TRUE) {
[13:20:54.229]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:54.229]                 open = "w")
[13:20:54.229]         }
[13:20:54.229]         else {
[13:20:54.229]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:54.229]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:54.229]         }
[13:20:54.229]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:54.229]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:54.229]             base::sink(type = "output", split = FALSE)
[13:20:54.229]             base::close(...future.stdout)
[13:20:54.229]         }, add = TRUE)
[13:20:54.229]     }
[13:20:54.229]     ...future.frame <- base::sys.nframe()
[13:20:54.229]     ...future.conditions <- base::list()
[13:20:54.229]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:54.229]     if (FALSE) {
[13:20:54.229]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:54.229]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:54.229]     }
[13:20:54.229]     ...future.result <- base::tryCatch({
[13:20:54.229]         base::withCallingHandlers({
[13:20:54.229]             ...future.value <- base::withVisible(base::local({
[13:20:54.229]                 ...future.makeSendCondition <- local({
[13:20:54.229]                   sendCondition <- NULL
[13:20:54.229]                   function(frame = 1L) {
[13:20:54.229]                     if (is.function(sendCondition)) 
[13:20:54.229]                       return(sendCondition)
[13:20:54.229]                     ns <- getNamespace("parallel")
[13:20:54.229]                     if (exists("sendData", mode = "function", 
[13:20:54.229]                       envir = ns)) {
[13:20:54.229]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:54.229]                         envir = ns)
[13:20:54.229]                       envir <- sys.frame(frame)
[13:20:54.229]                       master <- NULL
[13:20:54.229]                       while (!identical(envir, .GlobalEnv) && 
[13:20:54.229]                         !identical(envir, emptyenv())) {
[13:20:54.229]                         if (exists("master", mode = "list", envir = envir, 
[13:20:54.229]                           inherits = FALSE)) {
[13:20:54.229]                           master <- get("master", mode = "list", 
[13:20:54.229]                             envir = envir, inherits = FALSE)
[13:20:54.229]                           if (inherits(master, c("SOCKnode", 
[13:20:54.229]                             "SOCK0node"))) {
[13:20:54.229]                             sendCondition <<- function(cond) {
[13:20:54.229]                               data <- list(type = "VALUE", value = cond, 
[13:20:54.229]                                 success = TRUE)
[13:20:54.229]                               parallel_sendData(master, data)
[13:20:54.229]                             }
[13:20:54.229]                             return(sendCondition)
[13:20:54.229]                           }
[13:20:54.229]                         }
[13:20:54.229]                         frame <- frame + 1L
[13:20:54.229]                         envir <- sys.frame(frame)
[13:20:54.229]                       }
[13:20:54.229]                     }
[13:20:54.229]                     sendCondition <<- function(cond) NULL
[13:20:54.229]                   }
[13:20:54.229]                 })
[13:20:54.229]                 withCallingHandlers({
[13:20:54.229]                   {
[13:20:54.229]                     b <- a * ii
[13:20:54.229]                     a <- 0
[13:20:54.229]                     b
[13:20:54.229]                   }
[13:20:54.229]                 }, immediateCondition = function(cond) {
[13:20:54.229]                   sendCondition <- ...future.makeSendCondition()
[13:20:54.229]                   sendCondition(cond)
[13:20:54.229]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.229]                   {
[13:20:54.229]                     inherits <- base::inherits
[13:20:54.229]                     invokeRestart <- base::invokeRestart
[13:20:54.229]                     is.null <- base::is.null
[13:20:54.229]                     muffled <- FALSE
[13:20:54.229]                     if (inherits(cond, "message")) {
[13:20:54.229]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:54.229]                       if (muffled) 
[13:20:54.229]                         invokeRestart("muffleMessage")
[13:20:54.229]                     }
[13:20:54.229]                     else if (inherits(cond, "warning")) {
[13:20:54.229]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:54.229]                       if (muffled) 
[13:20:54.229]                         invokeRestart("muffleWarning")
[13:20:54.229]                     }
[13:20:54.229]                     else if (inherits(cond, "condition")) {
[13:20:54.229]                       if (!is.null(pattern)) {
[13:20:54.229]                         computeRestarts <- base::computeRestarts
[13:20:54.229]                         grepl <- base::grepl
[13:20:54.229]                         restarts <- computeRestarts(cond)
[13:20:54.229]                         for (restart in restarts) {
[13:20:54.229]                           name <- restart$name
[13:20:54.229]                           if (is.null(name)) 
[13:20:54.229]                             next
[13:20:54.229]                           if (!grepl(pattern, name)) 
[13:20:54.229]                             next
[13:20:54.229]                           invokeRestart(restart)
[13:20:54.229]                           muffled <- TRUE
[13:20:54.229]                           break
[13:20:54.229]                         }
[13:20:54.229]                       }
[13:20:54.229]                     }
[13:20:54.229]                     invisible(muffled)
[13:20:54.229]                   }
[13:20:54.229]                   muffleCondition(cond)
[13:20:54.229]                 })
[13:20:54.229]             }))
[13:20:54.229]             future::FutureResult(value = ...future.value$value, 
[13:20:54.229]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.229]                   ...future.rng), globalenv = if (FALSE) 
[13:20:54.229]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:54.229]                     ...future.globalenv.names))
[13:20:54.229]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:54.229]         }, condition = base::local({
[13:20:54.229]             c <- base::c
[13:20:54.229]             inherits <- base::inherits
[13:20:54.229]             invokeRestart <- base::invokeRestart
[13:20:54.229]             length <- base::length
[13:20:54.229]             list <- base::list
[13:20:54.229]             seq.int <- base::seq.int
[13:20:54.229]             signalCondition <- base::signalCondition
[13:20:54.229]             sys.calls <- base::sys.calls
[13:20:54.229]             `[[` <- base::`[[`
[13:20:54.229]             `+` <- base::`+`
[13:20:54.229]             `<<-` <- base::`<<-`
[13:20:54.229]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:54.229]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:54.229]                   3L)]
[13:20:54.229]             }
[13:20:54.229]             function(cond) {
[13:20:54.229]                 is_error <- inherits(cond, "error")
[13:20:54.229]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:54.229]                   NULL)
[13:20:54.229]                 if (is_error) {
[13:20:54.229]                   sessionInformation <- function() {
[13:20:54.229]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:54.229]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:54.229]                       search = base::search(), system = base::Sys.info())
[13:20:54.229]                   }
[13:20:54.229]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.229]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:54.229]                     cond$call), session = sessionInformation(), 
[13:20:54.229]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:54.229]                   signalCondition(cond)
[13:20:54.229]                 }
[13:20:54.229]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:54.229]                 "immediateCondition"))) {
[13:20:54.229]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:54.229]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.229]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:54.229]                   if (TRUE && !signal) {
[13:20:54.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.229]                     {
[13:20:54.229]                       inherits <- base::inherits
[13:20:54.229]                       invokeRestart <- base::invokeRestart
[13:20:54.229]                       is.null <- base::is.null
[13:20:54.229]                       muffled <- FALSE
[13:20:54.229]                       if (inherits(cond, "message")) {
[13:20:54.229]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.229]                         if (muffled) 
[13:20:54.229]                           invokeRestart("muffleMessage")
[13:20:54.229]                       }
[13:20:54.229]                       else if (inherits(cond, "warning")) {
[13:20:54.229]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.229]                         if (muffled) 
[13:20:54.229]                           invokeRestart("muffleWarning")
[13:20:54.229]                       }
[13:20:54.229]                       else if (inherits(cond, "condition")) {
[13:20:54.229]                         if (!is.null(pattern)) {
[13:20:54.229]                           computeRestarts <- base::computeRestarts
[13:20:54.229]                           grepl <- base::grepl
[13:20:54.229]                           restarts <- computeRestarts(cond)
[13:20:54.229]                           for (restart in restarts) {
[13:20:54.229]                             name <- restart$name
[13:20:54.229]                             if (is.null(name)) 
[13:20:54.229]                               next
[13:20:54.229]                             if (!grepl(pattern, name)) 
[13:20:54.229]                               next
[13:20:54.229]                             invokeRestart(restart)
[13:20:54.229]                             muffled <- TRUE
[13:20:54.229]                             break
[13:20:54.229]                           }
[13:20:54.229]                         }
[13:20:54.229]                       }
[13:20:54.229]                       invisible(muffled)
[13:20:54.229]                     }
[13:20:54.229]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.229]                   }
[13:20:54.229]                 }
[13:20:54.229]                 else {
[13:20:54.229]                   if (TRUE) {
[13:20:54.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.229]                     {
[13:20:54.229]                       inherits <- base::inherits
[13:20:54.229]                       invokeRestart <- base::invokeRestart
[13:20:54.229]                       is.null <- base::is.null
[13:20:54.229]                       muffled <- FALSE
[13:20:54.229]                       if (inherits(cond, "message")) {
[13:20:54.229]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.229]                         if (muffled) 
[13:20:54.229]                           invokeRestart("muffleMessage")
[13:20:54.229]                       }
[13:20:54.229]                       else if (inherits(cond, "warning")) {
[13:20:54.229]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.229]                         if (muffled) 
[13:20:54.229]                           invokeRestart("muffleWarning")
[13:20:54.229]                       }
[13:20:54.229]                       else if (inherits(cond, "condition")) {
[13:20:54.229]                         if (!is.null(pattern)) {
[13:20:54.229]                           computeRestarts <- base::computeRestarts
[13:20:54.229]                           grepl <- base::grepl
[13:20:54.229]                           restarts <- computeRestarts(cond)
[13:20:54.229]                           for (restart in restarts) {
[13:20:54.229]                             name <- restart$name
[13:20:54.229]                             if (is.null(name)) 
[13:20:54.229]                               next
[13:20:54.229]                             if (!grepl(pattern, name)) 
[13:20:54.229]                               next
[13:20:54.229]                             invokeRestart(restart)
[13:20:54.229]                             muffled <- TRUE
[13:20:54.229]                             break
[13:20:54.229]                           }
[13:20:54.229]                         }
[13:20:54.229]                       }
[13:20:54.229]                       invisible(muffled)
[13:20:54.229]                     }
[13:20:54.229]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.229]                   }
[13:20:54.229]                 }
[13:20:54.229]             }
[13:20:54.229]         }))
[13:20:54.229]     }, error = function(ex) {
[13:20:54.229]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:54.229]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.229]                 ...future.rng), started = ...future.startTime, 
[13:20:54.229]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:54.229]             version = "1.8"), class = "FutureResult")
[13:20:54.229]     }, finally = {
[13:20:54.229]         if (!identical(...future.workdir, getwd())) 
[13:20:54.229]             setwd(...future.workdir)
[13:20:54.229]         {
[13:20:54.229]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:54.229]                 ...future.oldOptions$nwarnings <- NULL
[13:20:54.229]             }
[13:20:54.229]             base::options(...future.oldOptions)
[13:20:54.229]             if (.Platform$OS.type == "windows") {
[13:20:54.229]                 old_names <- names(...future.oldEnvVars)
[13:20:54.229]                 envs <- base::Sys.getenv()
[13:20:54.229]                 names <- names(envs)
[13:20:54.229]                 common <- intersect(names, old_names)
[13:20:54.229]                 added <- setdiff(names, old_names)
[13:20:54.229]                 removed <- setdiff(old_names, names)
[13:20:54.229]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:54.229]                   envs[common]]
[13:20:54.229]                 NAMES <- toupper(changed)
[13:20:54.229]                 args <- list()
[13:20:54.229]                 for (kk in seq_along(NAMES)) {
[13:20:54.229]                   name <- changed[[kk]]
[13:20:54.229]                   NAME <- NAMES[[kk]]
[13:20:54.229]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.229]                     next
[13:20:54.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.229]                 }
[13:20:54.229]                 NAMES <- toupper(added)
[13:20:54.229]                 for (kk in seq_along(NAMES)) {
[13:20:54.229]                   name <- added[[kk]]
[13:20:54.229]                   NAME <- NAMES[[kk]]
[13:20:54.229]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.229]                     next
[13:20:54.229]                   args[[name]] <- ""
[13:20:54.229]                 }
[13:20:54.229]                 NAMES <- toupper(removed)
[13:20:54.229]                 for (kk in seq_along(NAMES)) {
[13:20:54.229]                   name <- removed[[kk]]
[13:20:54.229]                   NAME <- NAMES[[kk]]
[13:20:54.229]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.229]                     next
[13:20:54.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.229]                 }
[13:20:54.229]                 if (length(args) > 0) 
[13:20:54.229]                   base::do.call(base::Sys.setenv, args = args)
[13:20:54.229]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:54.229]             }
[13:20:54.229]             else {
[13:20:54.229]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:54.229]             }
[13:20:54.229]             {
[13:20:54.229]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:54.229]                   0L) {
[13:20:54.229]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:54.229]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:54.229]                   base::options(opts)
[13:20:54.229]                 }
[13:20:54.229]                 {
[13:20:54.229]                   {
[13:20:54.229]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:54.229]                     NULL
[13:20:54.229]                   }
[13:20:54.229]                   options(future.plan = NULL)
[13:20:54.229]                   if (is.na(NA_character_)) 
[13:20:54.229]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.229]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:54.229]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:54.229]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:54.229]                     envir = parent.frame()) 
[13:20:54.229]                   {
[13:20:54.229]                     if (is.function(workers)) 
[13:20:54.229]                       workers <- workers()
[13:20:54.229]                     workers <- structure(as.integer(workers), 
[13:20:54.229]                       class = class(workers))
[13:20:54.229]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:54.229]                       workers >= 1)
[13:20:54.229]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:54.229]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:54.229]                     }
[13:20:54.229]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:54.229]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:54.229]                       envir = envir)
[13:20:54.229]                     if (!future$lazy) 
[13:20:54.229]                       future <- run(future)
[13:20:54.229]                     invisible(future)
[13:20:54.229]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:54.229]                 }
[13:20:54.229]             }
[13:20:54.229]         }
[13:20:54.229]     })
[13:20:54.229]     if (TRUE) {
[13:20:54.229]         base::sink(type = "output", split = FALSE)
[13:20:54.229]         if (TRUE) {
[13:20:54.229]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:54.229]         }
[13:20:54.229]         else {
[13:20:54.229]             ...future.result["stdout"] <- base::list(NULL)
[13:20:54.229]         }
[13:20:54.229]         base::close(...future.stdout)
[13:20:54.229]         ...future.stdout <- NULL
[13:20:54.229]     }
[13:20:54.229]     ...future.result$conditions <- ...future.conditions
[13:20:54.229]     ...future.result$finished <- base::Sys.time()
[13:20:54.229]     ...future.result
[13:20:54.229] }
[13:20:54.231] Poll #1 (0): usedNodes() = 2, workers = 2
[13:20:54.242] receiveMessageFromWorker() for ClusterFuture ...
[13:20:54.242] - Validating connection of MultisessionFuture
[13:20:54.242] - received message: FutureResult
[13:20:54.242] - Received FutureResult
[13:20:54.243] - Erased future from FutureRegistry
[13:20:54.243] result() for ClusterFuture ...
[13:20:54.243] - result already collected: FutureResult
[13:20:54.243] result() for ClusterFuture ... done
[13:20:54.243] signalConditions() ...
[13:20:54.243]  - include = ‘immediateCondition’
[13:20:54.243]  - exclude = 
[13:20:54.243]  - resignal = FALSE
[13:20:54.243]  - Number of conditions: 1
[13:20:54.243] signalConditions() ... done
[13:20:54.244] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:54.244] result() for ClusterFuture ...
[13:20:54.244] - result already collected: FutureResult
[13:20:54.244] result() for ClusterFuture ... done
[13:20:54.244] result() for ClusterFuture ...
[13:20:54.244] - result already collected: FutureResult
[13:20:54.244] result() for ClusterFuture ... done
[13:20:54.244] signalConditions() ...
[13:20:54.244]  - include = ‘immediateCondition’
[13:20:54.244]  - exclude = 
[13:20:54.244]  - resignal = FALSE
[13:20:54.245]  - Number of conditions: 1
[13:20:54.245] signalConditions() ... done
[13:20:54.245] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[13:20:54.246] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:20:54.246] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:20:54.246] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:20:54.246] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:20:54.247] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[13:20:54.247] MultisessionFuture started
[13:20:54.247] - Launch lazy future ... done
[13:20:54.248] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:54.248] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:54.248] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:54.250] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:54.250] Searching for globals ... DONE
[13:20:54.250] Resolving globals: TRUE
[13:20:54.251] Resolving any globals that are futures ...
[13:20:54.251] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:54.251] Resolving any globals that are futures ... DONE
[13:20:54.251] Resolving futures part of globals (recursively) ...
[13:20:54.251] resolve() on list ...
[13:20:54.252]  recursive: 99
[13:20:54.252]  length: 2
[13:20:54.252]  elements: ‘a’, ‘ii’
[13:20:54.252]  length: 1 (resolved future 1)
[13:20:54.252]  length: 0 (resolved future 2)
[13:20:54.252] resolve() on list ... DONE
[13:20:54.252] - globals: [2] ‘a’, ‘ii’
[13:20:54.252] Resolving futures part of globals (recursively) ... DONE
[13:20:54.253] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:54.253] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:20:54.253] - globals: [2] ‘a’, ‘ii’
[13:20:54.254] 
[13:20:54.254] getGlobalsAndPackages() ... DONE
[13:20:54.254] run() for ‘Future’ ...
[13:20:54.254] - state: ‘created’
[13:20:54.254] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:54.269] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:54.269] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:54.269]   - Field: ‘node’
[13:20:54.269]   - Field: ‘label’
[13:20:54.269]   - Field: ‘local’
[13:20:54.269]   - Field: ‘owner’
[13:20:54.269]   - Field: ‘envir’
[13:20:54.269]   - Field: ‘workers’
[13:20:54.269]   - Field: ‘packages’
[13:20:54.270]   - Field: ‘gc’
[13:20:54.270]   - Field: ‘conditions’
[13:20:54.270]   - Field: ‘persistent’
[13:20:54.270]   - Field: ‘expr’
[13:20:54.270]   - Field: ‘uuid’
[13:20:54.270]   - Field: ‘seed’
[13:20:54.270]   - Field: ‘version’
[13:20:54.270]   - Field: ‘result’
[13:20:54.270]   - Field: ‘asynchronous’
[13:20:54.270]   - Field: ‘calls’
[13:20:54.270]   - Field: ‘globals’
[13:20:54.271]   - Field: ‘stdout’
[13:20:54.271]   - Field: ‘earlySignal’
[13:20:54.271]   - Field: ‘lazy’
[13:20:54.271]   - Field: ‘state’
[13:20:54.271] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:54.271] - Launch lazy future ...
[13:20:54.271] Packages needed by the future expression (n = 0): <none>
[13:20:54.271] Packages needed by future strategies (n = 0): <none>
[13:20:54.272] {
[13:20:54.272]     {
[13:20:54.272]         {
[13:20:54.272]             ...future.startTime <- base::Sys.time()
[13:20:54.272]             {
[13:20:54.272]                 {
[13:20:54.272]                   {
[13:20:54.272]                     {
[13:20:54.272]                       base::local({
[13:20:54.272]                         has_future <- base::requireNamespace("future", 
[13:20:54.272]                           quietly = TRUE)
[13:20:54.272]                         if (has_future) {
[13:20:54.272]                           ns <- base::getNamespace("future")
[13:20:54.272]                           version <- ns[[".package"]][["version"]]
[13:20:54.272]                           if (is.null(version)) 
[13:20:54.272]                             version <- utils::packageVersion("future")
[13:20:54.272]                         }
[13:20:54.272]                         else {
[13:20:54.272]                           version <- NULL
[13:20:54.272]                         }
[13:20:54.272]                         if (!has_future || version < "1.8.0") {
[13:20:54.272]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:54.272]                             "", base::R.version$version.string), 
[13:20:54.272]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:54.272]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:54.272]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:54.272]                               "release", "version")], collapse = " "), 
[13:20:54.272]                             hostname = base::Sys.info()[["nodename"]])
[13:20:54.272]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:54.272]                             info)
[13:20:54.272]                           info <- base::paste(info, collapse = "; ")
[13:20:54.272]                           if (!has_future) {
[13:20:54.272]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:54.272]                               info)
[13:20:54.272]                           }
[13:20:54.272]                           else {
[13:20:54.272]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:54.272]                               info, version)
[13:20:54.272]                           }
[13:20:54.272]                           base::stop(msg)
[13:20:54.272]                         }
[13:20:54.272]                       })
[13:20:54.272]                     }
[13:20:54.272]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:54.272]                     base::options(mc.cores = 1L)
[13:20:54.272]                   }
[13:20:54.272]                   options(future.plan = NULL)
[13:20:54.272]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.272]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:54.272]                 }
[13:20:54.272]                 ...future.workdir <- getwd()
[13:20:54.272]             }
[13:20:54.272]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:54.272]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:54.272]         }
[13:20:54.272]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:54.272]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:54.272]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:54.272]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:54.272]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:54.272]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:54.272]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:54.272]             base::names(...future.oldOptions))
[13:20:54.272]     }
[13:20:54.272]     if (FALSE) {
[13:20:54.272]     }
[13:20:54.272]     else {
[13:20:54.272]         if (TRUE) {
[13:20:54.272]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:54.272]                 open = "w")
[13:20:54.272]         }
[13:20:54.272]         else {
[13:20:54.272]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:54.272]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:54.272]         }
[13:20:54.272]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:54.272]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:54.272]             base::sink(type = "output", split = FALSE)
[13:20:54.272]             base::close(...future.stdout)
[13:20:54.272]         }, add = TRUE)
[13:20:54.272]     }
[13:20:54.272]     ...future.frame <- base::sys.nframe()
[13:20:54.272]     ...future.conditions <- base::list()
[13:20:54.272]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:54.272]     if (FALSE) {
[13:20:54.272]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:54.272]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:54.272]     }
[13:20:54.272]     ...future.result <- base::tryCatch({
[13:20:54.272]         base::withCallingHandlers({
[13:20:54.272]             ...future.value <- base::withVisible(base::local({
[13:20:54.272]                 ...future.makeSendCondition <- local({
[13:20:54.272]                   sendCondition <- NULL
[13:20:54.272]                   function(frame = 1L) {
[13:20:54.272]                     if (is.function(sendCondition)) 
[13:20:54.272]                       return(sendCondition)
[13:20:54.272]                     ns <- getNamespace("parallel")
[13:20:54.272]                     if (exists("sendData", mode = "function", 
[13:20:54.272]                       envir = ns)) {
[13:20:54.272]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:54.272]                         envir = ns)
[13:20:54.272]                       envir <- sys.frame(frame)
[13:20:54.272]                       master <- NULL
[13:20:54.272]                       while (!identical(envir, .GlobalEnv) && 
[13:20:54.272]                         !identical(envir, emptyenv())) {
[13:20:54.272]                         if (exists("master", mode = "list", envir = envir, 
[13:20:54.272]                           inherits = FALSE)) {
[13:20:54.272]                           master <- get("master", mode = "list", 
[13:20:54.272]                             envir = envir, inherits = FALSE)
[13:20:54.272]                           if (inherits(master, c("SOCKnode", 
[13:20:54.272]                             "SOCK0node"))) {
[13:20:54.272]                             sendCondition <<- function(cond) {
[13:20:54.272]                               data <- list(type = "VALUE", value = cond, 
[13:20:54.272]                                 success = TRUE)
[13:20:54.272]                               parallel_sendData(master, data)
[13:20:54.272]                             }
[13:20:54.272]                             return(sendCondition)
[13:20:54.272]                           }
[13:20:54.272]                         }
[13:20:54.272]                         frame <- frame + 1L
[13:20:54.272]                         envir <- sys.frame(frame)
[13:20:54.272]                       }
[13:20:54.272]                     }
[13:20:54.272]                     sendCondition <<- function(cond) NULL
[13:20:54.272]                   }
[13:20:54.272]                 })
[13:20:54.272]                 withCallingHandlers({
[13:20:54.272]                   {
[13:20:54.272]                     b <- a * ii
[13:20:54.272]                     a <- 0
[13:20:54.272]                     b
[13:20:54.272]                   }
[13:20:54.272]                 }, immediateCondition = function(cond) {
[13:20:54.272]                   sendCondition <- ...future.makeSendCondition()
[13:20:54.272]                   sendCondition(cond)
[13:20:54.272]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.272]                   {
[13:20:54.272]                     inherits <- base::inherits
[13:20:54.272]                     invokeRestart <- base::invokeRestart
[13:20:54.272]                     is.null <- base::is.null
[13:20:54.272]                     muffled <- FALSE
[13:20:54.272]                     if (inherits(cond, "message")) {
[13:20:54.272]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:54.272]                       if (muffled) 
[13:20:54.272]                         invokeRestart("muffleMessage")
[13:20:54.272]                     }
[13:20:54.272]                     else if (inherits(cond, "warning")) {
[13:20:54.272]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:54.272]                       if (muffled) 
[13:20:54.272]                         invokeRestart("muffleWarning")
[13:20:54.272]                     }
[13:20:54.272]                     else if (inherits(cond, "condition")) {
[13:20:54.272]                       if (!is.null(pattern)) {
[13:20:54.272]                         computeRestarts <- base::computeRestarts
[13:20:54.272]                         grepl <- base::grepl
[13:20:54.272]                         restarts <- computeRestarts(cond)
[13:20:54.272]                         for (restart in restarts) {
[13:20:54.272]                           name <- restart$name
[13:20:54.272]                           if (is.null(name)) 
[13:20:54.272]                             next
[13:20:54.272]                           if (!grepl(pattern, name)) 
[13:20:54.272]                             next
[13:20:54.272]                           invokeRestart(restart)
[13:20:54.272]                           muffled <- TRUE
[13:20:54.272]                           break
[13:20:54.272]                         }
[13:20:54.272]                       }
[13:20:54.272]                     }
[13:20:54.272]                     invisible(muffled)
[13:20:54.272]                   }
[13:20:54.272]                   muffleCondition(cond)
[13:20:54.272]                 })
[13:20:54.272]             }))
[13:20:54.272]             future::FutureResult(value = ...future.value$value, 
[13:20:54.272]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.272]                   ...future.rng), globalenv = if (FALSE) 
[13:20:54.272]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:54.272]                     ...future.globalenv.names))
[13:20:54.272]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:54.272]         }, condition = base::local({
[13:20:54.272]             c <- base::c
[13:20:54.272]             inherits <- base::inherits
[13:20:54.272]             invokeRestart <- base::invokeRestart
[13:20:54.272]             length <- base::length
[13:20:54.272]             list <- base::list
[13:20:54.272]             seq.int <- base::seq.int
[13:20:54.272]             signalCondition <- base::signalCondition
[13:20:54.272]             sys.calls <- base::sys.calls
[13:20:54.272]             `[[` <- base::`[[`
[13:20:54.272]             `+` <- base::`+`
[13:20:54.272]             `<<-` <- base::`<<-`
[13:20:54.272]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:54.272]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:54.272]                   3L)]
[13:20:54.272]             }
[13:20:54.272]             function(cond) {
[13:20:54.272]                 is_error <- inherits(cond, "error")
[13:20:54.272]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:54.272]                   NULL)
[13:20:54.272]                 if (is_error) {
[13:20:54.272]                   sessionInformation <- function() {
[13:20:54.272]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:54.272]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:54.272]                       search = base::search(), system = base::Sys.info())
[13:20:54.272]                   }
[13:20:54.272]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.272]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:54.272]                     cond$call), session = sessionInformation(), 
[13:20:54.272]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:54.272]                   signalCondition(cond)
[13:20:54.272]                 }
[13:20:54.272]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:54.272]                 "immediateCondition"))) {
[13:20:54.272]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:54.272]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.272]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:54.272]                   if (TRUE && !signal) {
[13:20:54.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.272]                     {
[13:20:54.272]                       inherits <- base::inherits
[13:20:54.272]                       invokeRestart <- base::invokeRestart
[13:20:54.272]                       is.null <- base::is.null
[13:20:54.272]                       muffled <- FALSE
[13:20:54.272]                       if (inherits(cond, "message")) {
[13:20:54.272]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.272]                         if (muffled) 
[13:20:54.272]                           invokeRestart("muffleMessage")
[13:20:54.272]                       }
[13:20:54.272]                       else if (inherits(cond, "warning")) {
[13:20:54.272]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.272]                         if (muffled) 
[13:20:54.272]                           invokeRestart("muffleWarning")
[13:20:54.272]                       }
[13:20:54.272]                       else if (inherits(cond, "condition")) {
[13:20:54.272]                         if (!is.null(pattern)) {
[13:20:54.272]                           computeRestarts <- base::computeRestarts
[13:20:54.272]                           grepl <- base::grepl
[13:20:54.272]                           restarts <- computeRestarts(cond)
[13:20:54.272]                           for (restart in restarts) {
[13:20:54.272]                             name <- restart$name
[13:20:54.272]                             if (is.null(name)) 
[13:20:54.272]                               next
[13:20:54.272]                             if (!grepl(pattern, name)) 
[13:20:54.272]                               next
[13:20:54.272]                             invokeRestart(restart)
[13:20:54.272]                             muffled <- TRUE
[13:20:54.272]                             break
[13:20:54.272]                           }
[13:20:54.272]                         }
[13:20:54.272]                       }
[13:20:54.272]                       invisible(muffled)
[13:20:54.272]                     }
[13:20:54.272]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.272]                   }
[13:20:54.272]                 }
[13:20:54.272]                 else {
[13:20:54.272]                   if (TRUE) {
[13:20:54.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.272]                     {
[13:20:54.272]                       inherits <- base::inherits
[13:20:54.272]                       invokeRestart <- base::invokeRestart
[13:20:54.272]                       is.null <- base::is.null
[13:20:54.272]                       muffled <- FALSE
[13:20:54.272]                       if (inherits(cond, "message")) {
[13:20:54.272]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.272]                         if (muffled) 
[13:20:54.272]                           invokeRestart("muffleMessage")
[13:20:54.272]                       }
[13:20:54.272]                       else if (inherits(cond, "warning")) {
[13:20:54.272]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.272]                         if (muffled) 
[13:20:54.272]                           invokeRestart("muffleWarning")
[13:20:54.272]                       }
[13:20:54.272]                       else if (inherits(cond, "condition")) {
[13:20:54.272]                         if (!is.null(pattern)) {
[13:20:54.272]                           computeRestarts <- base::computeRestarts
[13:20:54.272]                           grepl <- base::grepl
[13:20:54.272]                           restarts <- computeRestarts(cond)
[13:20:54.272]                           for (restart in restarts) {
[13:20:54.272]                             name <- restart$name
[13:20:54.272]                             if (is.null(name)) 
[13:20:54.272]                               next
[13:20:54.272]                             if (!grepl(pattern, name)) 
[13:20:54.272]                               next
[13:20:54.272]                             invokeRestart(restart)
[13:20:54.272]                             muffled <- TRUE
[13:20:54.272]                             break
[13:20:54.272]                           }
[13:20:54.272]                         }
[13:20:54.272]                       }
[13:20:54.272]                       invisible(muffled)
[13:20:54.272]                     }
[13:20:54.272]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.272]                   }
[13:20:54.272]                 }
[13:20:54.272]             }
[13:20:54.272]         }))
[13:20:54.272]     }, error = function(ex) {
[13:20:54.272]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:54.272]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.272]                 ...future.rng), started = ...future.startTime, 
[13:20:54.272]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:54.272]             version = "1.8"), class = "FutureResult")
[13:20:54.272]     }, finally = {
[13:20:54.272]         if (!identical(...future.workdir, getwd())) 
[13:20:54.272]             setwd(...future.workdir)
[13:20:54.272]         {
[13:20:54.272]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:54.272]                 ...future.oldOptions$nwarnings <- NULL
[13:20:54.272]             }
[13:20:54.272]             base::options(...future.oldOptions)
[13:20:54.272]             if (.Platform$OS.type == "windows") {
[13:20:54.272]                 old_names <- names(...future.oldEnvVars)
[13:20:54.272]                 envs <- base::Sys.getenv()
[13:20:54.272]                 names <- names(envs)
[13:20:54.272]                 common <- intersect(names, old_names)
[13:20:54.272]                 added <- setdiff(names, old_names)
[13:20:54.272]                 removed <- setdiff(old_names, names)
[13:20:54.272]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:54.272]                   envs[common]]
[13:20:54.272]                 NAMES <- toupper(changed)
[13:20:54.272]                 args <- list()
[13:20:54.272]                 for (kk in seq_along(NAMES)) {
[13:20:54.272]                   name <- changed[[kk]]
[13:20:54.272]                   NAME <- NAMES[[kk]]
[13:20:54.272]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.272]                     next
[13:20:54.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.272]                 }
[13:20:54.272]                 NAMES <- toupper(added)
[13:20:54.272]                 for (kk in seq_along(NAMES)) {
[13:20:54.272]                   name <- added[[kk]]
[13:20:54.272]                   NAME <- NAMES[[kk]]
[13:20:54.272]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.272]                     next
[13:20:54.272]                   args[[name]] <- ""
[13:20:54.272]                 }
[13:20:54.272]                 NAMES <- toupper(removed)
[13:20:54.272]                 for (kk in seq_along(NAMES)) {
[13:20:54.272]                   name <- removed[[kk]]
[13:20:54.272]                   NAME <- NAMES[[kk]]
[13:20:54.272]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.272]                     next
[13:20:54.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.272]                 }
[13:20:54.272]                 if (length(args) > 0) 
[13:20:54.272]                   base::do.call(base::Sys.setenv, args = args)
[13:20:54.272]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:54.272]             }
[13:20:54.272]             else {
[13:20:54.272]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:54.272]             }
[13:20:54.272]             {
[13:20:54.272]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:54.272]                   0L) {
[13:20:54.272]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:54.272]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:54.272]                   base::options(opts)
[13:20:54.272]                 }
[13:20:54.272]                 {
[13:20:54.272]                   {
[13:20:54.272]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:54.272]                     NULL
[13:20:54.272]                   }
[13:20:54.272]                   options(future.plan = NULL)
[13:20:54.272]                   if (is.na(NA_character_)) 
[13:20:54.272]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.272]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:54.272]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:54.272]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:54.272]                     envir = parent.frame()) 
[13:20:54.272]                   {
[13:20:54.272]                     if (is.function(workers)) 
[13:20:54.272]                       workers <- workers()
[13:20:54.272]                     workers <- structure(as.integer(workers), 
[13:20:54.272]                       class = class(workers))
[13:20:54.272]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:54.272]                       workers >= 1)
[13:20:54.272]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:54.272]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:54.272]                     }
[13:20:54.272]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:54.272]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:54.272]                       envir = envir)
[13:20:54.272]                     if (!future$lazy) 
[13:20:54.272]                       future <- run(future)
[13:20:54.272]                     invisible(future)
[13:20:54.272]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:54.272]                 }
[13:20:54.272]             }
[13:20:54.272]         }
[13:20:54.272]     })
[13:20:54.272]     if (TRUE) {
[13:20:54.272]         base::sink(type = "output", split = FALSE)
[13:20:54.272]         if (TRUE) {
[13:20:54.272]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:54.272]         }
[13:20:54.272]         else {
[13:20:54.272]             ...future.result["stdout"] <- base::list(NULL)
[13:20:54.272]         }
[13:20:54.272]         base::close(...future.stdout)
[13:20:54.272]         ...future.stdout <- NULL
[13:20:54.272]     }
[13:20:54.272]     ...future.result$conditions <- ...future.conditions
[13:20:54.272]     ...future.result$finished <- base::Sys.time()
[13:20:54.272]     ...future.result
[13:20:54.272] }
[13:20:54.274] Poll #1 (0): usedNodes() = 2, workers = 2
[13:20:54.285] receiveMessageFromWorker() for ClusterFuture ...
[13:20:54.285] - Validating connection of MultisessionFuture
[13:20:54.285] - received message: FutureResult
[13:20:54.285] - Received FutureResult
[13:20:54.285] - Erased future from FutureRegistry
[13:20:54.286] result() for ClusterFuture ...
[13:20:54.286] - result already collected: FutureResult
[13:20:54.286] result() for ClusterFuture ... done
[13:20:54.286] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:54.286] result() for ClusterFuture ...
[13:20:54.286] - result already collected: FutureResult
[13:20:54.286] result() for ClusterFuture ... done
[13:20:54.286] result() for ClusterFuture ...
[13:20:54.286] - result already collected: FutureResult
[13:20:54.286] result() for ClusterFuture ... done
[13:20:54.287] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[13:20:54.287] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[13:20:54.288] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[13:20:54.288] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[13:20:54.288] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[13:20:54.288] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[13:20:54.289] MultisessionFuture started
[13:20:54.289] - Launch lazy future ... done
[13:20:54.289] run() for ‘MultisessionFuture’ ... done
[13:20:54.290] result() for ClusterFuture ...
[13:20:54.290] - result already collected: FutureResult
[13:20:54.290] result() for ClusterFuture ... done
[13:20:54.290] result() for ClusterFuture ...
[13:20:54.290] - result already collected: FutureResult
[13:20:54.290] result() for ClusterFuture ... done
[13:20:54.291] result() for ClusterFuture ...
[13:20:54.291] receiveMessageFromWorker() for ClusterFuture ...
[13:20:54.291] - Validating connection of MultisessionFuture
[13:20:54.294] - received message: FutureResult
[13:20:54.295] - Received FutureResult
[13:20:54.295] - Erased future from FutureRegistry
[13:20:54.295] result() for ClusterFuture ...
[13:20:54.295] - result already collected: FutureResult
[13:20:54.295] result() for ClusterFuture ... done
[13:20:54.295] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:54.295] result() for ClusterFuture ... done
[13:20:54.296] result() for ClusterFuture ...
[13:20:54.296] - result already collected: FutureResult
[13:20:54.296] result() for ClusterFuture ... done
[13:20:54.296] result() for ClusterFuture ...
[13:20:54.296] receiveMessageFromWorker() for ClusterFuture ...
[13:20:54.296] - Validating connection of MultisessionFuture
[13:20:54.338] - received message: FutureResult
[13:20:54.338] - Received FutureResult
[13:20:54.338] - Erased future from FutureRegistry
[13:20:54.338] result() for ClusterFuture ...
[13:20:54.338] - result already collected: FutureResult
[13:20:54.338] result() for ClusterFuture ... done
[13:20:54.338] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:54.338] result() for ClusterFuture ... done
[13:20:54.338] result() for ClusterFuture ...
[13:20:54.338] - result already collected: FutureResult
[13:20:54.339] result() for ClusterFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:54.339] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:54.339] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:54.341] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:54.341] Searching for globals ... DONE
[13:20:54.342] Resolving globals: TRUE
[13:20:54.342] Resolving any globals that are futures ...
[13:20:54.342] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:54.342] Resolving any globals that are futures ... DONE
[13:20:54.342] Resolving futures part of globals (recursively) ...
[13:20:54.343] resolve() on list ...
[13:20:54.343]  recursive: 99
[13:20:54.343]  length: 2
[13:20:54.343]  elements: ‘a’, ‘ii’
[13:20:54.343]  length: 1 (resolved future 1)
[13:20:54.343]  length: 0 (resolved future 2)
[13:20:54.343] resolve() on list ... DONE
[13:20:54.343] - globals: [2] ‘a’, ‘ii’
[13:20:54.343] Resolving futures part of globals (recursively) ... DONE
[13:20:54.343] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:54.344] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:20:54.344] - globals: [2] ‘a’, ‘ii’
[13:20:54.344] 
[13:20:54.344] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:54.345] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:54.345] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:54.347] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:54.347] Searching for globals ... DONE
[13:20:54.347] Resolving globals: TRUE
[13:20:54.347] Resolving any globals that are futures ...
[13:20:54.347] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:54.347] Resolving any globals that are futures ... DONE
[13:20:54.348] Resolving futures part of globals (recursively) ...
[13:20:54.348] resolve() on list ...
[13:20:54.348]  recursive: 99
[13:20:54.348]  length: 2
[13:20:54.348]  elements: ‘a’, ‘ii’
[13:20:54.348]  length: 1 (resolved future 1)
[13:20:54.348]  length: 0 (resolved future 2)
[13:20:54.348] resolve() on list ... DONE
[13:20:54.348] - globals: [2] ‘a’, ‘ii’
[13:20:54.349] Resolving futures part of globals (recursively) ... DONE
[13:20:54.349] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:54.349] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:20:54.349] - globals: [2] ‘a’, ‘ii’
[13:20:54.349] 
[13:20:54.349] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:54.350] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:54.350] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:54.352] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:54.352] Searching for globals ... DONE
[13:20:54.352] Resolving globals: TRUE
[13:20:54.352] Resolving any globals that are futures ...
[13:20:54.352] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[13:20:54.352] Resolving any globals that are futures ... DONE
[13:20:54.353] Resolving futures part of globals (recursively) ...
[13:20:54.353] resolve() on list ...
[13:20:54.353]  recursive: 99
[13:20:54.353]  length: 2
[13:20:54.353]  elements: ‘a’, ‘ii’
[13:20:54.353]  length: 1 (resolved future 1)
[13:20:54.354]  length: 0 (resolved future 2)
[13:20:54.354] resolve() on list ... DONE
[13:20:54.354] - globals: [2] ‘a’, ‘ii’
[13:20:54.354] Resolving futures part of globals (recursively) ... DONE
[13:20:54.354] The total size of the 2 globals is 112 bytes (112 bytes)
[13:20:54.354] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:20:54.354] - globals: [2] ‘a’, ‘ii’
[13:20:54.355] 
[13:20:54.355] getGlobalsAndPackages() ... DONE
[13:20:54.355] run() for ‘Future’ ...
[13:20:54.355] - state: ‘created’
[13:20:54.355] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:54.370] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:54.370] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:54.370]   - Field: ‘node’
[13:20:54.370]   - Field: ‘label’
[13:20:54.370]   - Field: ‘local’
[13:20:54.370]   - Field: ‘owner’
[13:20:54.370]   - Field: ‘envir’
[13:20:54.371]   - Field: ‘workers’
[13:20:54.371]   - Field: ‘packages’
[13:20:54.371]   - Field: ‘gc’
[13:20:54.371]   - Field: ‘conditions’
[13:20:54.371]   - Field: ‘persistent’
[13:20:54.371]   - Field: ‘expr’
[13:20:54.371]   - Field: ‘uuid’
[13:20:54.371]   - Field: ‘seed’
[13:20:54.371]   - Field: ‘version’
[13:20:54.371]   - Field: ‘result’
[13:20:54.371]   - Field: ‘asynchronous’
[13:20:54.372]   - Field: ‘calls’
[13:20:54.372]   - Field: ‘globals’
[13:20:54.372]   - Field: ‘stdout’
[13:20:54.372]   - Field: ‘earlySignal’
[13:20:54.372]   - Field: ‘lazy’
[13:20:54.374]   - Field: ‘state’
[13:20:54.374] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:54.374] - Launch lazy future ...
[13:20:54.375] Packages needed by the future expression (n = 0): <none>
[13:20:54.375] Packages needed by future strategies (n = 0): <none>
[13:20:54.375] {
[13:20:54.375]     {
[13:20:54.375]         {
[13:20:54.375]             ...future.startTime <- base::Sys.time()
[13:20:54.375]             {
[13:20:54.375]                 {
[13:20:54.375]                   {
[13:20:54.375]                     {
[13:20:54.375]                       base::local({
[13:20:54.375]                         has_future <- base::requireNamespace("future", 
[13:20:54.375]                           quietly = TRUE)
[13:20:54.375]                         if (has_future) {
[13:20:54.375]                           ns <- base::getNamespace("future")
[13:20:54.375]                           version <- ns[[".package"]][["version"]]
[13:20:54.375]                           if (is.null(version)) 
[13:20:54.375]                             version <- utils::packageVersion("future")
[13:20:54.375]                         }
[13:20:54.375]                         else {
[13:20:54.375]                           version <- NULL
[13:20:54.375]                         }
[13:20:54.375]                         if (!has_future || version < "1.8.0") {
[13:20:54.375]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:54.375]                             "", base::R.version$version.string), 
[13:20:54.375]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:54.375]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:54.375]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:54.375]                               "release", "version")], collapse = " "), 
[13:20:54.375]                             hostname = base::Sys.info()[["nodename"]])
[13:20:54.375]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:54.375]                             info)
[13:20:54.375]                           info <- base::paste(info, collapse = "; ")
[13:20:54.375]                           if (!has_future) {
[13:20:54.375]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:54.375]                               info)
[13:20:54.375]                           }
[13:20:54.375]                           else {
[13:20:54.375]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:54.375]                               info, version)
[13:20:54.375]                           }
[13:20:54.375]                           base::stop(msg)
[13:20:54.375]                         }
[13:20:54.375]                       })
[13:20:54.375]                     }
[13:20:54.375]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:54.375]                     base::options(mc.cores = 1L)
[13:20:54.375]                   }
[13:20:54.375]                   options(future.plan = NULL)
[13:20:54.375]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.375]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:54.375]                 }
[13:20:54.375]                 ...future.workdir <- getwd()
[13:20:54.375]             }
[13:20:54.375]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:54.375]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:54.375]         }
[13:20:54.375]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:54.375]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:54.375]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:54.375]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:54.375]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:54.375]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:54.375]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:54.375]             base::names(...future.oldOptions))
[13:20:54.375]     }
[13:20:54.375]     if (FALSE) {
[13:20:54.375]     }
[13:20:54.375]     else {
[13:20:54.375]         if (TRUE) {
[13:20:54.375]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:54.375]                 open = "w")
[13:20:54.375]         }
[13:20:54.375]         else {
[13:20:54.375]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:54.375]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:54.375]         }
[13:20:54.375]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:54.375]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:54.375]             base::sink(type = "output", split = FALSE)
[13:20:54.375]             base::close(...future.stdout)
[13:20:54.375]         }, add = TRUE)
[13:20:54.375]     }
[13:20:54.375]     ...future.frame <- base::sys.nframe()
[13:20:54.375]     ...future.conditions <- base::list()
[13:20:54.375]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:54.375]     if (FALSE) {
[13:20:54.375]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:54.375]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:54.375]     }
[13:20:54.375]     ...future.result <- base::tryCatch({
[13:20:54.375]         base::withCallingHandlers({
[13:20:54.375]             ...future.value <- base::withVisible(base::local({
[13:20:54.375]                 ...future.makeSendCondition <- local({
[13:20:54.375]                   sendCondition <- NULL
[13:20:54.375]                   function(frame = 1L) {
[13:20:54.375]                     if (is.function(sendCondition)) 
[13:20:54.375]                       return(sendCondition)
[13:20:54.375]                     ns <- getNamespace("parallel")
[13:20:54.375]                     if (exists("sendData", mode = "function", 
[13:20:54.375]                       envir = ns)) {
[13:20:54.375]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:54.375]                         envir = ns)
[13:20:54.375]                       envir <- sys.frame(frame)
[13:20:54.375]                       master <- NULL
[13:20:54.375]                       while (!identical(envir, .GlobalEnv) && 
[13:20:54.375]                         !identical(envir, emptyenv())) {
[13:20:54.375]                         if (exists("master", mode = "list", envir = envir, 
[13:20:54.375]                           inherits = FALSE)) {
[13:20:54.375]                           master <- get("master", mode = "list", 
[13:20:54.375]                             envir = envir, inherits = FALSE)
[13:20:54.375]                           if (inherits(master, c("SOCKnode", 
[13:20:54.375]                             "SOCK0node"))) {
[13:20:54.375]                             sendCondition <<- function(cond) {
[13:20:54.375]                               data <- list(type = "VALUE", value = cond, 
[13:20:54.375]                                 success = TRUE)
[13:20:54.375]                               parallel_sendData(master, data)
[13:20:54.375]                             }
[13:20:54.375]                             return(sendCondition)
[13:20:54.375]                           }
[13:20:54.375]                         }
[13:20:54.375]                         frame <- frame + 1L
[13:20:54.375]                         envir <- sys.frame(frame)
[13:20:54.375]                       }
[13:20:54.375]                     }
[13:20:54.375]                     sendCondition <<- function(cond) NULL
[13:20:54.375]                   }
[13:20:54.375]                 })
[13:20:54.375]                 withCallingHandlers({
[13:20:54.375]                   {
[13:20:54.375]                     b <- a * ii
[13:20:54.375]                     a <- 0
[13:20:54.375]                     b
[13:20:54.375]                   }
[13:20:54.375]                 }, immediateCondition = function(cond) {
[13:20:54.375]                   sendCondition <- ...future.makeSendCondition()
[13:20:54.375]                   sendCondition(cond)
[13:20:54.375]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.375]                   {
[13:20:54.375]                     inherits <- base::inherits
[13:20:54.375]                     invokeRestart <- base::invokeRestart
[13:20:54.375]                     is.null <- base::is.null
[13:20:54.375]                     muffled <- FALSE
[13:20:54.375]                     if (inherits(cond, "message")) {
[13:20:54.375]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:54.375]                       if (muffled) 
[13:20:54.375]                         invokeRestart("muffleMessage")
[13:20:54.375]                     }
[13:20:54.375]                     else if (inherits(cond, "warning")) {
[13:20:54.375]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:54.375]                       if (muffled) 
[13:20:54.375]                         invokeRestart("muffleWarning")
[13:20:54.375]                     }
[13:20:54.375]                     else if (inherits(cond, "condition")) {
[13:20:54.375]                       if (!is.null(pattern)) {
[13:20:54.375]                         computeRestarts <- base::computeRestarts
[13:20:54.375]                         grepl <- base::grepl
[13:20:54.375]                         restarts <- computeRestarts(cond)
[13:20:54.375]                         for (restart in restarts) {
[13:20:54.375]                           name <- restart$name
[13:20:54.375]                           if (is.null(name)) 
[13:20:54.375]                             next
[13:20:54.375]                           if (!grepl(pattern, name)) 
[13:20:54.375]                             next
[13:20:54.375]                           invokeRestart(restart)
[13:20:54.375]                           muffled <- TRUE
[13:20:54.375]                           break
[13:20:54.375]                         }
[13:20:54.375]                       }
[13:20:54.375]                     }
[13:20:54.375]                     invisible(muffled)
[13:20:54.375]                   }
[13:20:54.375]                   muffleCondition(cond)
[13:20:54.375]                 })
[13:20:54.375]             }))
[13:20:54.375]             future::FutureResult(value = ...future.value$value, 
[13:20:54.375]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.375]                   ...future.rng), globalenv = if (FALSE) 
[13:20:54.375]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:54.375]                     ...future.globalenv.names))
[13:20:54.375]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:54.375]         }, condition = base::local({
[13:20:54.375]             c <- base::c
[13:20:54.375]             inherits <- base::inherits
[13:20:54.375]             invokeRestart <- base::invokeRestart
[13:20:54.375]             length <- base::length
[13:20:54.375]             list <- base::list
[13:20:54.375]             seq.int <- base::seq.int
[13:20:54.375]             signalCondition <- base::signalCondition
[13:20:54.375]             sys.calls <- base::sys.calls
[13:20:54.375]             `[[` <- base::`[[`
[13:20:54.375]             `+` <- base::`+`
[13:20:54.375]             `<<-` <- base::`<<-`
[13:20:54.375]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:54.375]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:54.375]                   3L)]
[13:20:54.375]             }
[13:20:54.375]             function(cond) {
[13:20:54.375]                 is_error <- inherits(cond, "error")
[13:20:54.375]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:54.375]                   NULL)
[13:20:54.375]                 if (is_error) {
[13:20:54.375]                   sessionInformation <- function() {
[13:20:54.375]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:54.375]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:54.375]                       search = base::search(), system = base::Sys.info())
[13:20:54.375]                   }
[13:20:54.375]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.375]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:54.375]                     cond$call), session = sessionInformation(), 
[13:20:54.375]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:54.375]                   signalCondition(cond)
[13:20:54.375]                 }
[13:20:54.375]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:54.375]                 "immediateCondition"))) {
[13:20:54.375]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:54.375]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.375]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:54.375]                   if (TRUE && !signal) {
[13:20:54.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.375]                     {
[13:20:54.375]                       inherits <- base::inherits
[13:20:54.375]                       invokeRestart <- base::invokeRestart
[13:20:54.375]                       is.null <- base::is.null
[13:20:54.375]                       muffled <- FALSE
[13:20:54.375]                       if (inherits(cond, "message")) {
[13:20:54.375]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.375]                         if (muffled) 
[13:20:54.375]                           invokeRestart("muffleMessage")
[13:20:54.375]                       }
[13:20:54.375]                       else if (inherits(cond, "warning")) {
[13:20:54.375]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.375]                         if (muffled) 
[13:20:54.375]                           invokeRestart("muffleWarning")
[13:20:54.375]                       }
[13:20:54.375]                       else if (inherits(cond, "condition")) {
[13:20:54.375]                         if (!is.null(pattern)) {
[13:20:54.375]                           computeRestarts <- base::computeRestarts
[13:20:54.375]                           grepl <- base::grepl
[13:20:54.375]                           restarts <- computeRestarts(cond)
[13:20:54.375]                           for (restart in restarts) {
[13:20:54.375]                             name <- restart$name
[13:20:54.375]                             if (is.null(name)) 
[13:20:54.375]                               next
[13:20:54.375]                             if (!grepl(pattern, name)) 
[13:20:54.375]                               next
[13:20:54.375]                             invokeRestart(restart)
[13:20:54.375]                             muffled <- TRUE
[13:20:54.375]                             break
[13:20:54.375]                           }
[13:20:54.375]                         }
[13:20:54.375]                       }
[13:20:54.375]                       invisible(muffled)
[13:20:54.375]                     }
[13:20:54.375]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.375]                   }
[13:20:54.375]                 }
[13:20:54.375]                 else {
[13:20:54.375]                   if (TRUE) {
[13:20:54.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.375]                     {
[13:20:54.375]                       inherits <- base::inherits
[13:20:54.375]                       invokeRestart <- base::invokeRestart
[13:20:54.375]                       is.null <- base::is.null
[13:20:54.375]                       muffled <- FALSE
[13:20:54.375]                       if (inherits(cond, "message")) {
[13:20:54.375]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.375]                         if (muffled) 
[13:20:54.375]                           invokeRestart("muffleMessage")
[13:20:54.375]                       }
[13:20:54.375]                       else if (inherits(cond, "warning")) {
[13:20:54.375]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.375]                         if (muffled) 
[13:20:54.375]                           invokeRestart("muffleWarning")
[13:20:54.375]                       }
[13:20:54.375]                       else if (inherits(cond, "condition")) {
[13:20:54.375]                         if (!is.null(pattern)) {
[13:20:54.375]                           computeRestarts <- base::computeRestarts
[13:20:54.375]                           grepl <- base::grepl
[13:20:54.375]                           restarts <- computeRestarts(cond)
[13:20:54.375]                           for (restart in restarts) {
[13:20:54.375]                             name <- restart$name
[13:20:54.375]                             if (is.null(name)) 
[13:20:54.375]                               next
[13:20:54.375]                             if (!grepl(pattern, name)) 
[13:20:54.375]                               next
[13:20:54.375]                             invokeRestart(restart)
[13:20:54.375]                             muffled <- TRUE
[13:20:54.375]                             break
[13:20:54.375]                           }
[13:20:54.375]                         }
[13:20:54.375]                       }
[13:20:54.375]                       invisible(muffled)
[13:20:54.375]                     }
[13:20:54.375]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.375]                   }
[13:20:54.375]                 }
[13:20:54.375]             }
[13:20:54.375]         }))
[13:20:54.375]     }, error = function(ex) {
[13:20:54.375]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:54.375]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.375]                 ...future.rng), started = ...future.startTime, 
[13:20:54.375]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:54.375]             version = "1.8"), class = "FutureResult")
[13:20:54.375]     }, finally = {
[13:20:54.375]         if (!identical(...future.workdir, getwd())) 
[13:20:54.375]             setwd(...future.workdir)
[13:20:54.375]         {
[13:20:54.375]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:54.375]                 ...future.oldOptions$nwarnings <- NULL
[13:20:54.375]             }
[13:20:54.375]             base::options(...future.oldOptions)
[13:20:54.375]             if (.Platform$OS.type == "windows") {
[13:20:54.375]                 old_names <- names(...future.oldEnvVars)
[13:20:54.375]                 envs <- base::Sys.getenv()
[13:20:54.375]                 names <- names(envs)
[13:20:54.375]                 common <- intersect(names, old_names)
[13:20:54.375]                 added <- setdiff(names, old_names)
[13:20:54.375]                 removed <- setdiff(old_names, names)
[13:20:54.375]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:54.375]                   envs[common]]
[13:20:54.375]                 NAMES <- toupper(changed)
[13:20:54.375]                 args <- list()
[13:20:54.375]                 for (kk in seq_along(NAMES)) {
[13:20:54.375]                   name <- changed[[kk]]
[13:20:54.375]                   NAME <- NAMES[[kk]]
[13:20:54.375]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.375]                     next
[13:20:54.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.375]                 }
[13:20:54.375]                 NAMES <- toupper(added)
[13:20:54.375]                 for (kk in seq_along(NAMES)) {
[13:20:54.375]                   name <- added[[kk]]
[13:20:54.375]                   NAME <- NAMES[[kk]]
[13:20:54.375]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.375]                     next
[13:20:54.375]                   args[[name]] <- ""
[13:20:54.375]                 }
[13:20:54.375]                 NAMES <- toupper(removed)
[13:20:54.375]                 for (kk in seq_along(NAMES)) {
[13:20:54.375]                   name <- removed[[kk]]
[13:20:54.375]                   NAME <- NAMES[[kk]]
[13:20:54.375]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.375]                     next
[13:20:54.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.375]                 }
[13:20:54.375]                 if (length(args) > 0) 
[13:20:54.375]                   base::do.call(base::Sys.setenv, args = args)
[13:20:54.375]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:54.375]             }
[13:20:54.375]             else {
[13:20:54.375]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:54.375]             }
[13:20:54.375]             {
[13:20:54.375]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:54.375]                   0L) {
[13:20:54.375]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:54.375]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:54.375]                   base::options(opts)
[13:20:54.375]                 }
[13:20:54.375]                 {
[13:20:54.375]                   {
[13:20:54.375]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:54.375]                     NULL
[13:20:54.375]                   }
[13:20:54.375]                   options(future.plan = NULL)
[13:20:54.375]                   if (is.na(NA_character_)) 
[13:20:54.375]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.375]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:54.375]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:54.375]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:54.375]                     envir = parent.frame()) 
[13:20:54.375]                   {
[13:20:54.375]                     if (is.function(workers)) 
[13:20:54.375]                       workers <- workers()
[13:20:54.375]                     workers <- structure(as.integer(workers), 
[13:20:54.375]                       class = class(workers))
[13:20:54.375]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:54.375]                       workers >= 1)
[13:20:54.375]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:54.375]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:54.375]                     }
[13:20:54.375]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:54.375]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:54.375]                       envir = envir)
[13:20:54.375]                     if (!future$lazy) 
[13:20:54.375]                       future <- run(future)
[13:20:54.375]                     invisible(future)
[13:20:54.375]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:54.375]                 }
[13:20:54.375]             }
[13:20:54.375]         }
[13:20:54.375]     })
[13:20:54.375]     if (TRUE) {
[13:20:54.375]         base::sink(type = "output", split = FALSE)
[13:20:54.375]         if (TRUE) {
[13:20:54.375]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:54.375]         }
[13:20:54.375]         else {
[13:20:54.375]             ...future.result["stdout"] <- base::list(NULL)
[13:20:54.375]         }
[13:20:54.375]         base::close(...future.stdout)
[13:20:54.375]         ...future.stdout <- NULL
[13:20:54.375]     }
[13:20:54.375]     ...future.result$conditions <- ...future.conditions
[13:20:54.375]     ...future.result$finished <- base::Sys.time()
[13:20:54.375]     ...future.result
[13:20:54.375] }
[13:20:54.378] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[13:20:54.378] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:20:54.378] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:20:54.378] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:20:54.379] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:20:54.379] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[13:20:54.379] MultisessionFuture started
[13:20:54.379] - Launch lazy future ... done
[13:20:54.379] run() for ‘MultisessionFuture’ ... done
[13:20:54.380] result() for ClusterFuture ...
[13:20:54.380] receiveMessageFromWorker() for ClusterFuture ...
[13:20:54.380] - Validating connection of MultisessionFuture
[13:20:54.425] - received message: FutureResult
[13:20:54.426] - Received FutureResult
[13:20:54.426] - Erased future from FutureRegistry
[13:20:54.426] result() for ClusterFuture ...
[13:20:54.426] - result already collected: FutureResult
[13:20:54.426] result() for ClusterFuture ... done
[13:20:54.426] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:54.426] result() for ClusterFuture ... done
[13:20:54.426] result() for ClusterFuture ...
[13:20:54.426] - result already collected: FutureResult
[13:20:54.426] result() for ClusterFuture ... done
[13:20:54.427] run() for ‘Future’ ...
[13:20:54.427] - state: ‘created’
[13:20:54.427] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:54.441] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:54.441] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:54.441]   - Field: ‘node’
[13:20:54.441]   - Field: ‘label’
[13:20:54.442]   - Field: ‘local’
[13:20:54.442]   - Field: ‘owner’
[13:20:54.442]   - Field: ‘envir’
[13:20:54.442]   - Field: ‘workers’
[13:20:54.442]   - Field: ‘packages’
[13:20:54.442]   - Field: ‘gc’
[13:20:54.442]   - Field: ‘conditions’
[13:20:54.442]   - Field: ‘persistent’
[13:20:54.442]   - Field: ‘expr’
[13:20:54.442]   - Field: ‘uuid’
[13:20:54.443]   - Field: ‘seed’
[13:20:54.443]   - Field: ‘version’
[13:20:54.443]   - Field: ‘result’
[13:20:54.443]   - Field: ‘asynchronous’
[13:20:54.443]   - Field: ‘calls’
[13:20:54.443]   - Field: ‘globals’
[13:20:54.443]   - Field: ‘stdout’
[13:20:54.443]   - Field: ‘earlySignal’
[13:20:54.443]   - Field: ‘lazy’
[13:20:54.443]   - Field: ‘state’
[13:20:54.443] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:54.444] - Launch lazy future ...
[13:20:54.444] Packages needed by the future expression (n = 0): <none>
[13:20:54.444] Packages needed by future strategies (n = 0): <none>
[13:20:54.444] {
[13:20:54.444]     {
[13:20:54.444]         {
[13:20:54.444]             ...future.startTime <- base::Sys.time()
[13:20:54.444]             {
[13:20:54.444]                 {
[13:20:54.444]                   {
[13:20:54.444]                     {
[13:20:54.444]                       base::local({
[13:20:54.444]                         has_future <- base::requireNamespace("future", 
[13:20:54.444]                           quietly = TRUE)
[13:20:54.444]                         if (has_future) {
[13:20:54.444]                           ns <- base::getNamespace("future")
[13:20:54.444]                           version <- ns[[".package"]][["version"]]
[13:20:54.444]                           if (is.null(version)) 
[13:20:54.444]                             version <- utils::packageVersion("future")
[13:20:54.444]                         }
[13:20:54.444]                         else {
[13:20:54.444]                           version <- NULL
[13:20:54.444]                         }
[13:20:54.444]                         if (!has_future || version < "1.8.0") {
[13:20:54.444]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:54.444]                             "", base::R.version$version.string), 
[13:20:54.444]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:54.444]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:54.444]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:54.444]                               "release", "version")], collapse = " "), 
[13:20:54.444]                             hostname = base::Sys.info()[["nodename"]])
[13:20:54.444]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:54.444]                             info)
[13:20:54.444]                           info <- base::paste(info, collapse = "; ")
[13:20:54.444]                           if (!has_future) {
[13:20:54.444]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:54.444]                               info)
[13:20:54.444]                           }
[13:20:54.444]                           else {
[13:20:54.444]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:54.444]                               info, version)
[13:20:54.444]                           }
[13:20:54.444]                           base::stop(msg)
[13:20:54.444]                         }
[13:20:54.444]                       })
[13:20:54.444]                     }
[13:20:54.444]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:54.444]                     base::options(mc.cores = 1L)
[13:20:54.444]                   }
[13:20:54.444]                   options(future.plan = NULL)
[13:20:54.444]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.444]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:54.444]                 }
[13:20:54.444]                 ...future.workdir <- getwd()
[13:20:54.444]             }
[13:20:54.444]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:54.444]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:54.444]         }
[13:20:54.444]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:54.444]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:54.444]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:54.444]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:54.444]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:54.444]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:54.444]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:54.444]             base::names(...future.oldOptions))
[13:20:54.444]     }
[13:20:54.444]     if (FALSE) {
[13:20:54.444]     }
[13:20:54.444]     else {
[13:20:54.444]         if (TRUE) {
[13:20:54.444]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:54.444]                 open = "w")
[13:20:54.444]         }
[13:20:54.444]         else {
[13:20:54.444]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:54.444]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:54.444]         }
[13:20:54.444]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:54.444]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:54.444]             base::sink(type = "output", split = FALSE)
[13:20:54.444]             base::close(...future.stdout)
[13:20:54.444]         }, add = TRUE)
[13:20:54.444]     }
[13:20:54.444]     ...future.frame <- base::sys.nframe()
[13:20:54.444]     ...future.conditions <- base::list()
[13:20:54.444]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:54.444]     if (FALSE) {
[13:20:54.444]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:54.444]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:54.444]     }
[13:20:54.444]     ...future.result <- base::tryCatch({
[13:20:54.444]         base::withCallingHandlers({
[13:20:54.444]             ...future.value <- base::withVisible(base::local({
[13:20:54.444]                 ...future.makeSendCondition <- local({
[13:20:54.444]                   sendCondition <- NULL
[13:20:54.444]                   function(frame = 1L) {
[13:20:54.444]                     if (is.function(sendCondition)) 
[13:20:54.444]                       return(sendCondition)
[13:20:54.444]                     ns <- getNamespace("parallel")
[13:20:54.444]                     if (exists("sendData", mode = "function", 
[13:20:54.444]                       envir = ns)) {
[13:20:54.444]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:54.444]                         envir = ns)
[13:20:54.444]                       envir <- sys.frame(frame)
[13:20:54.444]                       master <- NULL
[13:20:54.444]                       while (!identical(envir, .GlobalEnv) && 
[13:20:54.444]                         !identical(envir, emptyenv())) {
[13:20:54.444]                         if (exists("master", mode = "list", envir = envir, 
[13:20:54.444]                           inherits = FALSE)) {
[13:20:54.444]                           master <- get("master", mode = "list", 
[13:20:54.444]                             envir = envir, inherits = FALSE)
[13:20:54.444]                           if (inherits(master, c("SOCKnode", 
[13:20:54.444]                             "SOCK0node"))) {
[13:20:54.444]                             sendCondition <<- function(cond) {
[13:20:54.444]                               data <- list(type = "VALUE", value = cond, 
[13:20:54.444]                                 success = TRUE)
[13:20:54.444]                               parallel_sendData(master, data)
[13:20:54.444]                             }
[13:20:54.444]                             return(sendCondition)
[13:20:54.444]                           }
[13:20:54.444]                         }
[13:20:54.444]                         frame <- frame + 1L
[13:20:54.444]                         envir <- sys.frame(frame)
[13:20:54.444]                       }
[13:20:54.444]                     }
[13:20:54.444]                     sendCondition <<- function(cond) NULL
[13:20:54.444]                   }
[13:20:54.444]                 })
[13:20:54.444]                 withCallingHandlers({
[13:20:54.444]                   {
[13:20:54.444]                     b <- a * ii
[13:20:54.444]                     a <- 0
[13:20:54.444]                     b
[13:20:54.444]                   }
[13:20:54.444]                 }, immediateCondition = function(cond) {
[13:20:54.444]                   sendCondition <- ...future.makeSendCondition()
[13:20:54.444]                   sendCondition(cond)
[13:20:54.444]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.444]                   {
[13:20:54.444]                     inherits <- base::inherits
[13:20:54.444]                     invokeRestart <- base::invokeRestart
[13:20:54.444]                     is.null <- base::is.null
[13:20:54.444]                     muffled <- FALSE
[13:20:54.444]                     if (inherits(cond, "message")) {
[13:20:54.444]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:54.444]                       if (muffled) 
[13:20:54.444]                         invokeRestart("muffleMessage")
[13:20:54.444]                     }
[13:20:54.444]                     else if (inherits(cond, "warning")) {
[13:20:54.444]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:54.444]                       if (muffled) 
[13:20:54.444]                         invokeRestart("muffleWarning")
[13:20:54.444]                     }
[13:20:54.444]                     else if (inherits(cond, "condition")) {
[13:20:54.444]                       if (!is.null(pattern)) {
[13:20:54.444]                         computeRestarts <- base::computeRestarts
[13:20:54.444]                         grepl <- base::grepl
[13:20:54.444]                         restarts <- computeRestarts(cond)
[13:20:54.444]                         for (restart in restarts) {
[13:20:54.444]                           name <- restart$name
[13:20:54.444]                           if (is.null(name)) 
[13:20:54.444]                             next
[13:20:54.444]                           if (!grepl(pattern, name)) 
[13:20:54.444]                             next
[13:20:54.444]                           invokeRestart(restart)
[13:20:54.444]                           muffled <- TRUE
[13:20:54.444]                           break
[13:20:54.444]                         }
[13:20:54.444]                       }
[13:20:54.444]                     }
[13:20:54.444]                     invisible(muffled)
[13:20:54.444]                   }
[13:20:54.444]                   muffleCondition(cond)
[13:20:54.444]                 })
[13:20:54.444]             }))
[13:20:54.444]             future::FutureResult(value = ...future.value$value, 
[13:20:54.444]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.444]                   ...future.rng), globalenv = if (FALSE) 
[13:20:54.444]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:54.444]                     ...future.globalenv.names))
[13:20:54.444]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:54.444]         }, condition = base::local({
[13:20:54.444]             c <- base::c
[13:20:54.444]             inherits <- base::inherits
[13:20:54.444]             invokeRestart <- base::invokeRestart
[13:20:54.444]             length <- base::length
[13:20:54.444]             list <- base::list
[13:20:54.444]             seq.int <- base::seq.int
[13:20:54.444]             signalCondition <- base::signalCondition
[13:20:54.444]             sys.calls <- base::sys.calls
[13:20:54.444]             `[[` <- base::`[[`
[13:20:54.444]             `+` <- base::`+`
[13:20:54.444]             `<<-` <- base::`<<-`
[13:20:54.444]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:54.444]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:54.444]                   3L)]
[13:20:54.444]             }
[13:20:54.444]             function(cond) {
[13:20:54.444]                 is_error <- inherits(cond, "error")
[13:20:54.444]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:54.444]                   NULL)
[13:20:54.444]                 if (is_error) {
[13:20:54.444]                   sessionInformation <- function() {
[13:20:54.444]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:54.444]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:54.444]                       search = base::search(), system = base::Sys.info())
[13:20:54.444]                   }
[13:20:54.444]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.444]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:54.444]                     cond$call), session = sessionInformation(), 
[13:20:54.444]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:54.444]                   signalCondition(cond)
[13:20:54.444]                 }
[13:20:54.444]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:54.444]                 "immediateCondition"))) {
[13:20:54.444]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:54.444]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.444]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:54.444]                   if (TRUE && !signal) {
[13:20:54.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.444]                     {
[13:20:54.444]                       inherits <- base::inherits
[13:20:54.444]                       invokeRestart <- base::invokeRestart
[13:20:54.444]                       is.null <- base::is.null
[13:20:54.444]                       muffled <- FALSE
[13:20:54.444]                       if (inherits(cond, "message")) {
[13:20:54.444]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.444]                         if (muffled) 
[13:20:54.444]                           invokeRestart("muffleMessage")
[13:20:54.444]                       }
[13:20:54.444]                       else if (inherits(cond, "warning")) {
[13:20:54.444]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.444]                         if (muffled) 
[13:20:54.444]                           invokeRestart("muffleWarning")
[13:20:54.444]                       }
[13:20:54.444]                       else if (inherits(cond, "condition")) {
[13:20:54.444]                         if (!is.null(pattern)) {
[13:20:54.444]                           computeRestarts <- base::computeRestarts
[13:20:54.444]                           grepl <- base::grepl
[13:20:54.444]                           restarts <- computeRestarts(cond)
[13:20:54.444]                           for (restart in restarts) {
[13:20:54.444]                             name <- restart$name
[13:20:54.444]                             if (is.null(name)) 
[13:20:54.444]                               next
[13:20:54.444]                             if (!grepl(pattern, name)) 
[13:20:54.444]                               next
[13:20:54.444]                             invokeRestart(restart)
[13:20:54.444]                             muffled <- TRUE
[13:20:54.444]                             break
[13:20:54.444]                           }
[13:20:54.444]                         }
[13:20:54.444]                       }
[13:20:54.444]                       invisible(muffled)
[13:20:54.444]                     }
[13:20:54.444]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.444]                   }
[13:20:54.444]                 }
[13:20:54.444]                 else {
[13:20:54.444]                   if (TRUE) {
[13:20:54.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.444]                     {
[13:20:54.444]                       inherits <- base::inherits
[13:20:54.444]                       invokeRestart <- base::invokeRestart
[13:20:54.444]                       is.null <- base::is.null
[13:20:54.444]                       muffled <- FALSE
[13:20:54.444]                       if (inherits(cond, "message")) {
[13:20:54.444]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.444]                         if (muffled) 
[13:20:54.444]                           invokeRestart("muffleMessage")
[13:20:54.444]                       }
[13:20:54.444]                       else if (inherits(cond, "warning")) {
[13:20:54.444]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.444]                         if (muffled) 
[13:20:54.444]                           invokeRestart("muffleWarning")
[13:20:54.444]                       }
[13:20:54.444]                       else if (inherits(cond, "condition")) {
[13:20:54.444]                         if (!is.null(pattern)) {
[13:20:54.444]                           computeRestarts <- base::computeRestarts
[13:20:54.444]                           grepl <- base::grepl
[13:20:54.444]                           restarts <- computeRestarts(cond)
[13:20:54.444]                           for (restart in restarts) {
[13:20:54.444]                             name <- restart$name
[13:20:54.444]                             if (is.null(name)) 
[13:20:54.444]                               next
[13:20:54.444]                             if (!grepl(pattern, name)) 
[13:20:54.444]                               next
[13:20:54.444]                             invokeRestart(restart)
[13:20:54.444]                             muffled <- TRUE
[13:20:54.444]                             break
[13:20:54.444]                           }
[13:20:54.444]                         }
[13:20:54.444]                       }
[13:20:54.444]                       invisible(muffled)
[13:20:54.444]                     }
[13:20:54.444]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.444]                   }
[13:20:54.444]                 }
[13:20:54.444]             }
[13:20:54.444]         }))
[13:20:54.444]     }, error = function(ex) {
[13:20:54.444]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:54.444]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.444]                 ...future.rng), started = ...future.startTime, 
[13:20:54.444]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:54.444]             version = "1.8"), class = "FutureResult")
[13:20:54.444]     }, finally = {
[13:20:54.444]         if (!identical(...future.workdir, getwd())) 
[13:20:54.444]             setwd(...future.workdir)
[13:20:54.444]         {
[13:20:54.444]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:54.444]                 ...future.oldOptions$nwarnings <- NULL
[13:20:54.444]             }
[13:20:54.444]             base::options(...future.oldOptions)
[13:20:54.444]             if (.Platform$OS.type == "windows") {
[13:20:54.444]                 old_names <- names(...future.oldEnvVars)
[13:20:54.444]                 envs <- base::Sys.getenv()
[13:20:54.444]                 names <- names(envs)
[13:20:54.444]                 common <- intersect(names, old_names)
[13:20:54.444]                 added <- setdiff(names, old_names)
[13:20:54.444]                 removed <- setdiff(old_names, names)
[13:20:54.444]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:54.444]                   envs[common]]
[13:20:54.444]                 NAMES <- toupper(changed)
[13:20:54.444]                 args <- list()
[13:20:54.444]                 for (kk in seq_along(NAMES)) {
[13:20:54.444]                   name <- changed[[kk]]
[13:20:54.444]                   NAME <- NAMES[[kk]]
[13:20:54.444]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.444]                     next
[13:20:54.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.444]                 }
[13:20:54.444]                 NAMES <- toupper(added)
[13:20:54.444]                 for (kk in seq_along(NAMES)) {
[13:20:54.444]                   name <- added[[kk]]
[13:20:54.444]                   NAME <- NAMES[[kk]]
[13:20:54.444]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.444]                     next
[13:20:54.444]                   args[[name]] <- ""
[13:20:54.444]                 }
[13:20:54.444]                 NAMES <- toupper(removed)
[13:20:54.444]                 for (kk in seq_along(NAMES)) {
[13:20:54.444]                   name <- removed[[kk]]
[13:20:54.444]                   NAME <- NAMES[[kk]]
[13:20:54.444]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.444]                     next
[13:20:54.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.444]                 }
[13:20:54.444]                 if (length(args) > 0) 
[13:20:54.444]                   base::do.call(base::Sys.setenv, args = args)
[13:20:54.444]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:54.444]             }
[13:20:54.444]             else {
[13:20:54.444]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:54.444]             }
[13:20:54.444]             {
[13:20:54.444]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:54.444]                   0L) {
[13:20:54.444]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:54.444]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:54.444]                   base::options(opts)
[13:20:54.444]                 }
[13:20:54.444]                 {
[13:20:54.444]                   {
[13:20:54.444]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:54.444]                     NULL
[13:20:54.444]                   }
[13:20:54.444]                   options(future.plan = NULL)
[13:20:54.444]                   if (is.na(NA_character_)) 
[13:20:54.444]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.444]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:54.444]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:54.444]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:54.444]                     envir = parent.frame()) 
[13:20:54.444]                   {
[13:20:54.444]                     if (is.function(workers)) 
[13:20:54.444]                       workers <- workers()
[13:20:54.444]                     workers <- structure(as.integer(workers), 
[13:20:54.444]                       class = class(workers))
[13:20:54.444]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:54.444]                       workers >= 1)
[13:20:54.444]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:54.444]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:54.444]                     }
[13:20:54.444]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:54.444]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:54.444]                       envir = envir)
[13:20:54.444]                     if (!future$lazy) 
[13:20:54.444]                       future <- run(future)
[13:20:54.444]                     invisible(future)
[13:20:54.444]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:54.444]                 }
[13:20:54.444]             }
[13:20:54.444]         }
[13:20:54.444]     })
[13:20:54.444]     if (TRUE) {
[13:20:54.444]         base::sink(type = "output", split = FALSE)
[13:20:54.444]         if (TRUE) {
[13:20:54.444]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:54.444]         }
[13:20:54.444]         else {
[13:20:54.444]             ...future.result["stdout"] <- base::list(NULL)
[13:20:54.444]         }
[13:20:54.444]         base::close(...future.stdout)
[13:20:54.444]         ...future.stdout <- NULL
[13:20:54.444]     }
[13:20:54.444]     ...future.result$conditions <- ...future.conditions
[13:20:54.444]     ...future.result$finished <- base::Sys.time()
[13:20:54.444]     ...future.result
[13:20:54.444] }
[13:20:54.447] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[13:20:54.447] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:20:54.448] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:20:54.448] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:20:54.448] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:20:54.448] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[13:20:54.449] MultisessionFuture started
[13:20:54.449] - Launch lazy future ... done
[13:20:54.449] run() for ‘MultisessionFuture’ ... done
[13:20:54.449] result() for ClusterFuture ...
[13:20:54.449] receiveMessageFromWorker() for ClusterFuture ...
[13:20:54.450] - Validating connection of MultisessionFuture
[13:20:54.498] - received message: FutureResult
[13:20:54.498] - Received FutureResult
[13:20:54.498] - Erased future from FutureRegistry
[13:20:54.498] result() for ClusterFuture ...
[13:20:54.498] - result already collected: FutureResult
[13:20:54.498] result() for ClusterFuture ... done
[13:20:54.498] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:54.499] result() for ClusterFuture ... done
[13:20:54.499] result() for ClusterFuture ...
[13:20:54.499] - result already collected: FutureResult
[13:20:54.499] result() for ClusterFuture ... done
[13:20:54.499] run() for ‘Future’ ...
[13:20:54.499] - state: ‘created’
[13:20:54.499] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:54.514] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:54.514] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:54.514]   - Field: ‘node’
[13:20:54.514]   - Field: ‘label’
[13:20:54.514]   - Field: ‘local’
[13:20:54.515]   - Field: ‘owner’
[13:20:54.515]   - Field: ‘envir’
[13:20:54.515]   - Field: ‘workers’
[13:20:54.515]   - Field: ‘packages’
[13:20:54.515]   - Field: ‘gc’
[13:20:54.515]   - Field: ‘conditions’
[13:20:54.515]   - Field: ‘persistent’
[13:20:54.515]   - Field: ‘expr’
[13:20:54.515]   - Field: ‘uuid’
[13:20:54.515]   - Field: ‘seed’
[13:20:54.516]   - Field: ‘version’
[13:20:54.516]   - Field: ‘result’
[13:20:54.516]   - Field: ‘asynchronous’
[13:20:54.516]   - Field: ‘calls’
[13:20:54.516]   - Field: ‘globals’
[13:20:54.516]   - Field: ‘stdout’
[13:20:54.516]   - Field: ‘earlySignal’
[13:20:54.516]   - Field: ‘lazy’
[13:20:54.516]   - Field: ‘state’
[13:20:54.516] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:54.516] - Launch lazy future ...
[13:20:54.517] Packages needed by the future expression (n = 0): <none>
[13:20:54.517] Packages needed by future strategies (n = 0): <none>
[13:20:54.517] {
[13:20:54.517]     {
[13:20:54.517]         {
[13:20:54.517]             ...future.startTime <- base::Sys.time()
[13:20:54.517]             {
[13:20:54.517]                 {
[13:20:54.517]                   {
[13:20:54.517]                     {
[13:20:54.517]                       base::local({
[13:20:54.517]                         has_future <- base::requireNamespace("future", 
[13:20:54.517]                           quietly = TRUE)
[13:20:54.517]                         if (has_future) {
[13:20:54.517]                           ns <- base::getNamespace("future")
[13:20:54.517]                           version <- ns[[".package"]][["version"]]
[13:20:54.517]                           if (is.null(version)) 
[13:20:54.517]                             version <- utils::packageVersion("future")
[13:20:54.517]                         }
[13:20:54.517]                         else {
[13:20:54.517]                           version <- NULL
[13:20:54.517]                         }
[13:20:54.517]                         if (!has_future || version < "1.8.0") {
[13:20:54.517]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:54.517]                             "", base::R.version$version.string), 
[13:20:54.517]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:54.517]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:54.517]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:54.517]                               "release", "version")], collapse = " "), 
[13:20:54.517]                             hostname = base::Sys.info()[["nodename"]])
[13:20:54.517]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:54.517]                             info)
[13:20:54.517]                           info <- base::paste(info, collapse = "; ")
[13:20:54.517]                           if (!has_future) {
[13:20:54.517]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:54.517]                               info)
[13:20:54.517]                           }
[13:20:54.517]                           else {
[13:20:54.517]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:54.517]                               info, version)
[13:20:54.517]                           }
[13:20:54.517]                           base::stop(msg)
[13:20:54.517]                         }
[13:20:54.517]                       })
[13:20:54.517]                     }
[13:20:54.517]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:54.517]                     base::options(mc.cores = 1L)
[13:20:54.517]                   }
[13:20:54.517]                   options(future.plan = NULL)
[13:20:54.517]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.517]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:54.517]                 }
[13:20:54.517]                 ...future.workdir <- getwd()
[13:20:54.517]             }
[13:20:54.517]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:54.517]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:54.517]         }
[13:20:54.517]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:54.517]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:54.517]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:54.517]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:54.517]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:54.517]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:54.517]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:54.517]             base::names(...future.oldOptions))
[13:20:54.517]     }
[13:20:54.517]     if (FALSE) {
[13:20:54.517]     }
[13:20:54.517]     else {
[13:20:54.517]         if (TRUE) {
[13:20:54.517]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:54.517]                 open = "w")
[13:20:54.517]         }
[13:20:54.517]         else {
[13:20:54.517]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:54.517]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:54.517]         }
[13:20:54.517]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:54.517]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:54.517]             base::sink(type = "output", split = FALSE)
[13:20:54.517]             base::close(...future.stdout)
[13:20:54.517]         }, add = TRUE)
[13:20:54.517]     }
[13:20:54.517]     ...future.frame <- base::sys.nframe()
[13:20:54.517]     ...future.conditions <- base::list()
[13:20:54.517]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:54.517]     if (FALSE) {
[13:20:54.517]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:54.517]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:54.517]     }
[13:20:54.517]     ...future.result <- base::tryCatch({
[13:20:54.517]         base::withCallingHandlers({
[13:20:54.517]             ...future.value <- base::withVisible(base::local({
[13:20:54.517]                 ...future.makeSendCondition <- local({
[13:20:54.517]                   sendCondition <- NULL
[13:20:54.517]                   function(frame = 1L) {
[13:20:54.517]                     if (is.function(sendCondition)) 
[13:20:54.517]                       return(sendCondition)
[13:20:54.517]                     ns <- getNamespace("parallel")
[13:20:54.517]                     if (exists("sendData", mode = "function", 
[13:20:54.517]                       envir = ns)) {
[13:20:54.517]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:54.517]                         envir = ns)
[13:20:54.517]                       envir <- sys.frame(frame)
[13:20:54.517]                       master <- NULL
[13:20:54.517]                       while (!identical(envir, .GlobalEnv) && 
[13:20:54.517]                         !identical(envir, emptyenv())) {
[13:20:54.517]                         if (exists("master", mode = "list", envir = envir, 
[13:20:54.517]                           inherits = FALSE)) {
[13:20:54.517]                           master <- get("master", mode = "list", 
[13:20:54.517]                             envir = envir, inherits = FALSE)
[13:20:54.517]                           if (inherits(master, c("SOCKnode", 
[13:20:54.517]                             "SOCK0node"))) {
[13:20:54.517]                             sendCondition <<- function(cond) {
[13:20:54.517]                               data <- list(type = "VALUE", value = cond, 
[13:20:54.517]                                 success = TRUE)
[13:20:54.517]                               parallel_sendData(master, data)
[13:20:54.517]                             }
[13:20:54.517]                             return(sendCondition)
[13:20:54.517]                           }
[13:20:54.517]                         }
[13:20:54.517]                         frame <- frame + 1L
[13:20:54.517]                         envir <- sys.frame(frame)
[13:20:54.517]                       }
[13:20:54.517]                     }
[13:20:54.517]                     sendCondition <<- function(cond) NULL
[13:20:54.517]                   }
[13:20:54.517]                 })
[13:20:54.517]                 withCallingHandlers({
[13:20:54.517]                   {
[13:20:54.517]                     b <- a * ii
[13:20:54.517]                     a <- 0
[13:20:54.517]                     b
[13:20:54.517]                   }
[13:20:54.517]                 }, immediateCondition = function(cond) {
[13:20:54.517]                   sendCondition <- ...future.makeSendCondition()
[13:20:54.517]                   sendCondition(cond)
[13:20:54.517]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.517]                   {
[13:20:54.517]                     inherits <- base::inherits
[13:20:54.517]                     invokeRestart <- base::invokeRestart
[13:20:54.517]                     is.null <- base::is.null
[13:20:54.517]                     muffled <- FALSE
[13:20:54.517]                     if (inherits(cond, "message")) {
[13:20:54.517]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:54.517]                       if (muffled) 
[13:20:54.517]                         invokeRestart("muffleMessage")
[13:20:54.517]                     }
[13:20:54.517]                     else if (inherits(cond, "warning")) {
[13:20:54.517]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:54.517]                       if (muffled) 
[13:20:54.517]                         invokeRestart("muffleWarning")
[13:20:54.517]                     }
[13:20:54.517]                     else if (inherits(cond, "condition")) {
[13:20:54.517]                       if (!is.null(pattern)) {
[13:20:54.517]                         computeRestarts <- base::computeRestarts
[13:20:54.517]                         grepl <- base::grepl
[13:20:54.517]                         restarts <- computeRestarts(cond)
[13:20:54.517]                         for (restart in restarts) {
[13:20:54.517]                           name <- restart$name
[13:20:54.517]                           if (is.null(name)) 
[13:20:54.517]                             next
[13:20:54.517]                           if (!grepl(pattern, name)) 
[13:20:54.517]                             next
[13:20:54.517]                           invokeRestart(restart)
[13:20:54.517]                           muffled <- TRUE
[13:20:54.517]                           break
[13:20:54.517]                         }
[13:20:54.517]                       }
[13:20:54.517]                     }
[13:20:54.517]                     invisible(muffled)
[13:20:54.517]                   }
[13:20:54.517]                   muffleCondition(cond)
[13:20:54.517]                 })
[13:20:54.517]             }))
[13:20:54.517]             future::FutureResult(value = ...future.value$value, 
[13:20:54.517]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.517]                   ...future.rng), globalenv = if (FALSE) 
[13:20:54.517]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:54.517]                     ...future.globalenv.names))
[13:20:54.517]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:54.517]         }, condition = base::local({
[13:20:54.517]             c <- base::c
[13:20:54.517]             inherits <- base::inherits
[13:20:54.517]             invokeRestart <- base::invokeRestart
[13:20:54.517]             length <- base::length
[13:20:54.517]             list <- base::list
[13:20:54.517]             seq.int <- base::seq.int
[13:20:54.517]             signalCondition <- base::signalCondition
[13:20:54.517]             sys.calls <- base::sys.calls
[13:20:54.517]             `[[` <- base::`[[`
[13:20:54.517]             `+` <- base::`+`
[13:20:54.517]             `<<-` <- base::`<<-`
[13:20:54.517]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:54.517]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:54.517]                   3L)]
[13:20:54.517]             }
[13:20:54.517]             function(cond) {
[13:20:54.517]                 is_error <- inherits(cond, "error")
[13:20:54.517]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:54.517]                   NULL)
[13:20:54.517]                 if (is_error) {
[13:20:54.517]                   sessionInformation <- function() {
[13:20:54.517]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:54.517]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:54.517]                       search = base::search(), system = base::Sys.info())
[13:20:54.517]                   }
[13:20:54.517]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.517]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:54.517]                     cond$call), session = sessionInformation(), 
[13:20:54.517]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:54.517]                   signalCondition(cond)
[13:20:54.517]                 }
[13:20:54.517]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:54.517]                 "immediateCondition"))) {
[13:20:54.517]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:54.517]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.517]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:54.517]                   if (TRUE && !signal) {
[13:20:54.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.517]                     {
[13:20:54.517]                       inherits <- base::inherits
[13:20:54.517]                       invokeRestart <- base::invokeRestart
[13:20:54.517]                       is.null <- base::is.null
[13:20:54.517]                       muffled <- FALSE
[13:20:54.517]                       if (inherits(cond, "message")) {
[13:20:54.517]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.517]                         if (muffled) 
[13:20:54.517]                           invokeRestart("muffleMessage")
[13:20:54.517]                       }
[13:20:54.517]                       else if (inherits(cond, "warning")) {
[13:20:54.517]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.517]                         if (muffled) 
[13:20:54.517]                           invokeRestart("muffleWarning")
[13:20:54.517]                       }
[13:20:54.517]                       else if (inherits(cond, "condition")) {
[13:20:54.517]                         if (!is.null(pattern)) {
[13:20:54.517]                           computeRestarts <- base::computeRestarts
[13:20:54.517]                           grepl <- base::grepl
[13:20:54.517]                           restarts <- computeRestarts(cond)
[13:20:54.517]                           for (restart in restarts) {
[13:20:54.517]                             name <- restart$name
[13:20:54.517]                             if (is.null(name)) 
[13:20:54.517]                               next
[13:20:54.517]                             if (!grepl(pattern, name)) 
[13:20:54.517]                               next
[13:20:54.517]                             invokeRestart(restart)
[13:20:54.517]                             muffled <- TRUE
[13:20:54.517]                             break
[13:20:54.517]                           }
[13:20:54.517]                         }
[13:20:54.517]                       }
[13:20:54.517]                       invisible(muffled)
[13:20:54.517]                     }
[13:20:54.517]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.517]                   }
[13:20:54.517]                 }
[13:20:54.517]                 else {
[13:20:54.517]                   if (TRUE) {
[13:20:54.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.517]                     {
[13:20:54.517]                       inherits <- base::inherits
[13:20:54.517]                       invokeRestart <- base::invokeRestart
[13:20:54.517]                       is.null <- base::is.null
[13:20:54.517]                       muffled <- FALSE
[13:20:54.517]                       if (inherits(cond, "message")) {
[13:20:54.517]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.517]                         if (muffled) 
[13:20:54.517]                           invokeRestart("muffleMessage")
[13:20:54.517]                       }
[13:20:54.517]                       else if (inherits(cond, "warning")) {
[13:20:54.517]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.517]                         if (muffled) 
[13:20:54.517]                           invokeRestart("muffleWarning")
[13:20:54.517]                       }
[13:20:54.517]                       else if (inherits(cond, "condition")) {
[13:20:54.517]                         if (!is.null(pattern)) {
[13:20:54.517]                           computeRestarts <- base::computeRestarts
[13:20:54.517]                           grepl <- base::grepl
[13:20:54.517]                           restarts <- computeRestarts(cond)
[13:20:54.517]                           for (restart in restarts) {
[13:20:54.517]                             name <- restart$name
[13:20:54.517]                             if (is.null(name)) 
[13:20:54.517]                               next
[13:20:54.517]                             if (!grepl(pattern, name)) 
[13:20:54.517]                               next
[13:20:54.517]                             invokeRestart(restart)
[13:20:54.517]                             muffled <- TRUE
[13:20:54.517]                             break
[13:20:54.517]                           }
[13:20:54.517]                         }
[13:20:54.517]                       }
[13:20:54.517]                       invisible(muffled)
[13:20:54.517]                     }
[13:20:54.517]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.517]                   }
[13:20:54.517]                 }
[13:20:54.517]             }
[13:20:54.517]         }))
[13:20:54.517]     }, error = function(ex) {
[13:20:54.517]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:54.517]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.517]                 ...future.rng), started = ...future.startTime, 
[13:20:54.517]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:54.517]             version = "1.8"), class = "FutureResult")
[13:20:54.517]     }, finally = {
[13:20:54.517]         if (!identical(...future.workdir, getwd())) 
[13:20:54.517]             setwd(...future.workdir)
[13:20:54.517]         {
[13:20:54.517]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:54.517]                 ...future.oldOptions$nwarnings <- NULL
[13:20:54.517]             }
[13:20:54.517]             base::options(...future.oldOptions)
[13:20:54.517]             if (.Platform$OS.type == "windows") {
[13:20:54.517]                 old_names <- names(...future.oldEnvVars)
[13:20:54.517]                 envs <- base::Sys.getenv()
[13:20:54.517]                 names <- names(envs)
[13:20:54.517]                 common <- intersect(names, old_names)
[13:20:54.517]                 added <- setdiff(names, old_names)
[13:20:54.517]                 removed <- setdiff(old_names, names)
[13:20:54.517]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:54.517]                   envs[common]]
[13:20:54.517]                 NAMES <- toupper(changed)
[13:20:54.517]                 args <- list()
[13:20:54.517]                 for (kk in seq_along(NAMES)) {
[13:20:54.517]                   name <- changed[[kk]]
[13:20:54.517]                   NAME <- NAMES[[kk]]
[13:20:54.517]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.517]                     next
[13:20:54.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.517]                 }
[13:20:54.517]                 NAMES <- toupper(added)
[13:20:54.517]                 for (kk in seq_along(NAMES)) {
[13:20:54.517]                   name <- added[[kk]]
[13:20:54.517]                   NAME <- NAMES[[kk]]
[13:20:54.517]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.517]                     next
[13:20:54.517]                   args[[name]] <- ""
[13:20:54.517]                 }
[13:20:54.517]                 NAMES <- toupper(removed)
[13:20:54.517]                 for (kk in seq_along(NAMES)) {
[13:20:54.517]                   name <- removed[[kk]]
[13:20:54.517]                   NAME <- NAMES[[kk]]
[13:20:54.517]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.517]                     next
[13:20:54.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.517]                 }
[13:20:54.517]                 if (length(args) > 0) 
[13:20:54.517]                   base::do.call(base::Sys.setenv, args = args)
[13:20:54.517]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:54.517]             }
[13:20:54.517]             else {
[13:20:54.517]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:54.517]             }
[13:20:54.517]             {
[13:20:54.517]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:54.517]                   0L) {
[13:20:54.517]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:54.517]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:54.517]                   base::options(opts)
[13:20:54.517]                 }
[13:20:54.517]                 {
[13:20:54.517]                   {
[13:20:54.517]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:54.517]                     NULL
[13:20:54.517]                   }
[13:20:54.517]                   options(future.plan = NULL)
[13:20:54.517]                   if (is.na(NA_character_)) 
[13:20:54.517]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.517]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:54.517]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:54.517]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:54.517]                     envir = parent.frame()) 
[13:20:54.517]                   {
[13:20:54.517]                     if (is.function(workers)) 
[13:20:54.517]                       workers <- workers()
[13:20:54.517]                     workers <- structure(as.integer(workers), 
[13:20:54.517]                       class = class(workers))
[13:20:54.517]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:54.517]                       workers >= 1)
[13:20:54.517]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:54.517]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:54.517]                     }
[13:20:54.517]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:54.517]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:54.517]                       envir = envir)
[13:20:54.517]                     if (!future$lazy) 
[13:20:54.517]                       future <- run(future)
[13:20:54.517]                     invisible(future)
[13:20:54.517]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:54.517]                 }
[13:20:54.517]             }
[13:20:54.517]         }
[13:20:54.517]     })
[13:20:54.517]     if (TRUE) {
[13:20:54.517]         base::sink(type = "output", split = FALSE)
[13:20:54.517]         if (TRUE) {
[13:20:54.517]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:54.517]         }
[13:20:54.517]         else {
[13:20:54.517]             ...future.result["stdout"] <- base::list(NULL)
[13:20:54.517]         }
[13:20:54.517]         base::close(...future.stdout)
[13:20:54.517]         ...future.stdout <- NULL
[13:20:54.517]     }
[13:20:54.517]     ...future.result$conditions <- ...future.conditions
[13:20:54.517]     ...future.result$finished <- base::Sys.time()
[13:20:54.517]     ...future.result
[13:20:54.517] }
[13:20:54.520] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[13:20:54.520] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:20:54.521] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:20:54.521] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:20:54.521] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:20:54.521] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[13:20:54.522] MultisessionFuture started
[13:20:54.522] - Launch lazy future ... done
[13:20:54.522] run() for ‘MultisessionFuture’ ... done
[13:20:54.522] result() for ClusterFuture ...
[13:20:54.522] receiveMessageFromWorker() for ClusterFuture ...
[13:20:54.522] - Validating connection of MultisessionFuture
[13:20:54.570] - received message: FutureResult
[13:20:54.570] - Received FutureResult
[13:20:54.570] - Erased future from FutureRegistry
[13:20:54.571] result() for ClusterFuture ...
[13:20:54.571] - result already collected: FutureResult
[13:20:54.571] result() for ClusterFuture ... done
[13:20:54.571] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:54.571] result() for ClusterFuture ... done
[13:20:54.571] result() for ClusterFuture ...
[13:20:54.571] - result already collected: FutureResult
[13:20:54.571] result() for ClusterFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:54.572] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:54.572] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:54.573] 
[13:20:54.573] Searching for globals ... DONE
[13:20:54.573] - globals: [0] <none>
[13:20:54.573] getGlobalsAndPackages() ... DONE
[13:20:54.573] run() for ‘Future’ ...
[13:20:54.573] - state: ‘created’
[13:20:54.573] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:54.588] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:54.588] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:54.588]   - Field: ‘node’
[13:20:54.588]   - Field: ‘label’
[13:20:54.588]   - Field: ‘local’
[13:20:54.588]   - Field: ‘owner’
[13:20:54.588]   - Field: ‘envir’
[13:20:54.589]   - Field: ‘workers’
[13:20:54.589]   - Field: ‘packages’
[13:20:54.589]   - Field: ‘gc’
[13:20:54.589]   - Field: ‘conditions’
[13:20:54.589]   - Field: ‘persistent’
[13:20:54.589]   - Field: ‘expr’
[13:20:54.589]   - Field: ‘uuid’
[13:20:54.589]   - Field: ‘seed’
[13:20:54.589]   - Field: ‘version’
[13:20:54.589]   - Field: ‘result’
[13:20:54.590]   - Field: ‘asynchronous’
[13:20:54.590]   - Field: ‘calls’
[13:20:54.590]   - Field: ‘globals’
[13:20:54.590]   - Field: ‘stdout’
[13:20:54.590]   - Field: ‘earlySignal’
[13:20:54.590]   - Field: ‘lazy’
[13:20:54.590]   - Field: ‘state’
[13:20:54.590] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:54.590] - Launch lazy future ...
[13:20:54.591] Packages needed by the future expression (n = 0): <none>
[13:20:54.591] Packages needed by future strategies (n = 0): <none>
[13:20:54.591] {
[13:20:54.591]     {
[13:20:54.591]         {
[13:20:54.591]             ...future.startTime <- base::Sys.time()
[13:20:54.591]             {
[13:20:54.591]                 {
[13:20:54.591]                   {
[13:20:54.591]                     {
[13:20:54.591]                       base::local({
[13:20:54.591]                         has_future <- base::requireNamespace("future", 
[13:20:54.591]                           quietly = TRUE)
[13:20:54.591]                         if (has_future) {
[13:20:54.591]                           ns <- base::getNamespace("future")
[13:20:54.591]                           version <- ns[[".package"]][["version"]]
[13:20:54.591]                           if (is.null(version)) 
[13:20:54.591]                             version <- utils::packageVersion("future")
[13:20:54.591]                         }
[13:20:54.591]                         else {
[13:20:54.591]                           version <- NULL
[13:20:54.591]                         }
[13:20:54.591]                         if (!has_future || version < "1.8.0") {
[13:20:54.591]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:54.591]                             "", base::R.version$version.string), 
[13:20:54.591]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:54.591]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:54.591]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:54.591]                               "release", "version")], collapse = " "), 
[13:20:54.591]                             hostname = base::Sys.info()[["nodename"]])
[13:20:54.591]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:54.591]                             info)
[13:20:54.591]                           info <- base::paste(info, collapse = "; ")
[13:20:54.591]                           if (!has_future) {
[13:20:54.591]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:54.591]                               info)
[13:20:54.591]                           }
[13:20:54.591]                           else {
[13:20:54.591]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:54.591]                               info, version)
[13:20:54.591]                           }
[13:20:54.591]                           base::stop(msg)
[13:20:54.591]                         }
[13:20:54.591]                       })
[13:20:54.591]                     }
[13:20:54.591]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:54.591]                     base::options(mc.cores = 1L)
[13:20:54.591]                   }
[13:20:54.591]                   options(future.plan = NULL)
[13:20:54.591]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.591]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:54.591]                 }
[13:20:54.591]                 ...future.workdir <- getwd()
[13:20:54.591]             }
[13:20:54.591]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:54.591]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:54.591]         }
[13:20:54.591]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:54.591]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:54.591]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:54.591]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:54.591]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:54.591]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:54.591]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:54.591]             base::names(...future.oldOptions))
[13:20:54.591]     }
[13:20:54.591]     if (FALSE) {
[13:20:54.591]     }
[13:20:54.591]     else {
[13:20:54.591]         if (TRUE) {
[13:20:54.591]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:54.591]                 open = "w")
[13:20:54.591]         }
[13:20:54.591]         else {
[13:20:54.591]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:54.591]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:54.591]         }
[13:20:54.591]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:54.591]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:54.591]             base::sink(type = "output", split = FALSE)
[13:20:54.591]             base::close(...future.stdout)
[13:20:54.591]         }, add = TRUE)
[13:20:54.591]     }
[13:20:54.591]     ...future.frame <- base::sys.nframe()
[13:20:54.591]     ...future.conditions <- base::list()
[13:20:54.591]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:54.591]     if (FALSE) {
[13:20:54.591]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:54.591]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:54.591]     }
[13:20:54.591]     ...future.result <- base::tryCatch({
[13:20:54.591]         base::withCallingHandlers({
[13:20:54.591]             ...future.value <- base::withVisible(base::local({
[13:20:54.591]                 ...future.makeSendCondition <- local({
[13:20:54.591]                   sendCondition <- NULL
[13:20:54.591]                   function(frame = 1L) {
[13:20:54.591]                     if (is.function(sendCondition)) 
[13:20:54.591]                       return(sendCondition)
[13:20:54.591]                     ns <- getNamespace("parallel")
[13:20:54.591]                     if (exists("sendData", mode = "function", 
[13:20:54.591]                       envir = ns)) {
[13:20:54.591]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:54.591]                         envir = ns)
[13:20:54.591]                       envir <- sys.frame(frame)
[13:20:54.591]                       master <- NULL
[13:20:54.591]                       while (!identical(envir, .GlobalEnv) && 
[13:20:54.591]                         !identical(envir, emptyenv())) {
[13:20:54.591]                         if (exists("master", mode = "list", envir = envir, 
[13:20:54.591]                           inherits = FALSE)) {
[13:20:54.591]                           master <- get("master", mode = "list", 
[13:20:54.591]                             envir = envir, inherits = FALSE)
[13:20:54.591]                           if (inherits(master, c("SOCKnode", 
[13:20:54.591]                             "SOCK0node"))) {
[13:20:54.591]                             sendCondition <<- function(cond) {
[13:20:54.591]                               data <- list(type = "VALUE", value = cond, 
[13:20:54.591]                                 success = TRUE)
[13:20:54.591]                               parallel_sendData(master, data)
[13:20:54.591]                             }
[13:20:54.591]                             return(sendCondition)
[13:20:54.591]                           }
[13:20:54.591]                         }
[13:20:54.591]                         frame <- frame + 1L
[13:20:54.591]                         envir <- sys.frame(frame)
[13:20:54.591]                       }
[13:20:54.591]                     }
[13:20:54.591]                     sendCondition <<- function(cond) NULL
[13:20:54.591]                   }
[13:20:54.591]                 })
[13:20:54.591]                 withCallingHandlers({
[13:20:54.591]                   1
[13:20:54.591]                 }, immediateCondition = function(cond) {
[13:20:54.591]                   sendCondition <- ...future.makeSendCondition()
[13:20:54.591]                   sendCondition(cond)
[13:20:54.591]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.591]                   {
[13:20:54.591]                     inherits <- base::inherits
[13:20:54.591]                     invokeRestart <- base::invokeRestart
[13:20:54.591]                     is.null <- base::is.null
[13:20:54.591]                     muffled <- FALSE
[13:20:54.591]                     if (inherits(cond, "message")) {
[13:20:54.591]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:54.591]                       if (muffled) 
[13:20:54.591]                         invokeRestart("muffleMessage")
[13:20:54.591]                     }
[13:20:54.591]                     else if (inherits(cond, "warning")) {
[13:20:54.591]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:54.591]                       if (muffled) 
[13:20:54.591]                         invokeRestart("muffleWarning")
[13:20:54.591]                     }
[13:20:54.591]                     else if (inherits(cond, "condition")) {
[13:20:54.591]                       if (!is.null(pattern)) {
[13:20:54.591]                         computeRestarts <- base::computeRestarts
[13:20:54.591]                         grepl <- base::grepl
[13:20:54.591]                         restarts <- computeRestarts(cond)
[13:20:54.591]                         for (restart in restarts) {
[13:20:54.591]                           name <- restart$name
[13:20:54.591]                           if (is.null(name)) 
[13:20:54.591]                             next
[13:20:54.591]                           if (!grepl(pattern, name)) 
[13:20:54.591]                             next
[13:20:54.591]                           invokeRestart(restart)
[13:20:54.591]                           muffled <- TRUE
[13:20:54.591]                           break
[13:20:54.591]                         }
[13:20:54.591]                       }
[13:20:54.591]                     }
[13:20:54.591]                     invisible(muffled)
[13:20:54.591]                   }
[13:20:54.591]                   muffleCondition(cond)
[13:20:54.591]                 })
[13:20:54.591]             }))
[13:20:54.591]             future::FutureResult(value = ...future.value$value, 
[13:20:54.591]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.591]                   ...future.rng), globalenv = if (FALSE) 
[13:20:54.591]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:54.591]                     ...future.globalenv.names))
[13:20:54.591]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:54.591]         }, condition = base::local({
[13:20:54.591]             c <- base::c
[13:20:54.591]             inherits <- base::inherits
[13:20:54.591]             invokeRestart <- base::invokeRestart
[13:20:54.591]             length <- base::length
[13:20:54.591]             list <- base::list
[13:20:54.591]             seq.int <- base::seq.int
[13:20:54.591]             signalCondition <- base::signalCondition
[13:20:54.591]             sys.calls <- base::sys.calls
[13:20:54.591]             `[[` <- base::`[[`
[13:20:54.591]             `+` <- base::`+`
[13:20:54.591]             `<<-` <- base::`<<-`
[13:20:54.591]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:54.591]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:54.591]                   3L)]
[13:20:54.591]             }
[13:20:54.591]             function(cond) {
[13:20:54.591]                 is_error <- inherits(cond, "error")
[13:20:54.591]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:54.591]                   NULL)
[13:20:54.591]                 if (is_error) {
[13:20:54.591]                   sessionInformation <- function() {
[13:20:54.591]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:54.591]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:54.591]                       search = base::search(), system = base::Sys.info())
[13:20:54.591]                   }
[13:20:54.591]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.591]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:54.591]                     cond$call), session = sessionInformation(), 
[13:20:54.591]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:54.591]                   signalCondition(cond)
[13:20:54.591]                 }
[13:20:54.591]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:54.591]                 "immediateCondition"))) {
[13:20:54.591]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:54.591]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.591]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:54.591]                   if (TRUE && !signal) {
[13:20:54.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.591]                     {
[13:20:54.591]                       inherits <- base::inherits
[13:20:54.591]                       invokeRestart <- base::invokeRestart
[13:20:54.591]                       is.null <- base::is.null
[13:20:54.591]                       muffled <- FALSE
[13:20:54.591]                       if (inherits(cond, "message")) {
[13:20:54.591]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.591]                         if (muffled) 
[13:20:54.591]                           invokeRestart("muffleMessage")
[13:20:54.591]                       }
[13:20:54.591]                       else if (inherits(cond, "warning")) {
[13:20:54.591]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.591]                         if (muffled) 
[13:20:54.591]                           invokeRestart("muffleWarning")
[13:20:54.591]                       }
[13:20:54.591]                       else if (inherits(cond, "condition")) {
[13:20:54.591]                         if (!is.null(pattern)) {
[13:20:54.591]                           computeRestarts <- base::computeRestarts
[13:20:54.591]                           grepl <- base::grepl
[13:20:54.591]                           restarts <- computeRestarts(cond)
[13:20:54.591]                           for (restart in restarts) {
[13:20:54.591]                             name <- restart$name
[13:20:54.591]                             if (is.null(name)) 
[13:20:54.591]                               next
[13:20:54.591]                             if (!grepl(pattern, name)) 
[13:20:54.591]                               next
[13:20:54.591]                             invokeRestart(restart)
[13:20:54.591]                             muffled <- TRUE
[13:20:54.591]                             break
[13:20:54.591]                           }
[13:20:54.591]                         }
[13:20:54.591]                       }
[13:20:54.591]                       invisible(muffled)
[13:20:54.591]                     }
[13:20:54.591]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.591]                   }
[13:20:54.591]                 }
[13:20:54.591]                 else {
[13:20:54.591]                   if (TRUE) {
[13:20:54.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.591]                     {
[13:20:54.591]                       inherits <- base::inherits
[13:20:54.591]                       invokeRestart <- base::invokeRestart
[13:20:54.591]                       is.null <- base::is.null
[13:20:54.591]                       muffled <- FALSE
[13:20:54.591]                       if (inherits(cond, "message")) {
[13:20:54.591]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.591]                         if (muffled) 
[13:20:54.591]                           invokeRestart("muffleMessage")
[13:20:54.591]                       }
[13:20:54.591]                       else if (inherits(cond, "warning")) {
[13:20:54.591]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.591]                         if (muffled) 
[13:20:54.591]                           invokeRestart("muffleWarning")
[13:20:54.591]                       }
[13:20:54.591]                       else if (inherits(cond, "condition")) {
[13:20:54.591]                         if (!is.null(pattern)) {
[13:20:54.591]                           computeRestarts <- base::computeRestarts
[13:20:54.591]                           grepl <- base::grepl
[13:20:54.591]                           restarts <- computeRestarts(cond)
[13:20:54.591]                           for (restart in restarts) {
[13:20:54.591]                             name <- restart$name
[13:20:54.591]                             if (is.null(name)) 
[13:20:54.591]                               next
[13:20:54.591]                             if (!grepl(pattern, name)) 
[13:20:54.591]                               next
[13:20:54.591]                             invokeRestart(restart)
[13:20:54.591]                             muffled <- TRUE
[13:20:54.591]                             break
[13:20:54.591]                           }
[13:20:54.591]                         }
[13:20:54.591]                       }
[13:20:54.591]                       invisible(muffled)
[13:20:54.591]                     }
[13:20:54.591]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.591]                   }
[13:20:54.591]                 }
[13:20:54.591]             }
[13:20:54.591]         }))
[13:20:54.591]     }, error = function(ex) {
[13:20:54.591]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:54.591]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.591]                 ...future.rng), started = ...future.startTime, 
[13:20:54.591]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:54.591]             version = "1.8"), class = "FutureResult")
[13:20:54.591]     }, finally = {
[13:20:54.591]         if (!identical(...future.workdir, getwd())) 
[13:20:54.591]             setwd(...future.workdir)
[13:20:54.591]         {
[13:20:54.591]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:54.591]                 ...future.oldOptions$nwarnings <- NULL
[13:20:54.591]             }
[13:20:54.591]             base::options(...future.oldOptions)
[13:20:54.591]             if (.Platform$OS.type == "windows") {
[13:20:54.591]                 old_names <- names(...future.oldEnvVars)
[13:20:54.591]                 envs <- base::Sys.getenv()
[13:20:54.591]                 names <- names(envs)
[13:20:54.591]                 common <- intersect(names, old_names)
[13:20:54.591]                 added <- setdiff(names, old_names)
[13:20:54.591]                 removed <- setdiff(old_names, names)
[13:20:54.591]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:54.591]                   envs[common]]
[13:20:54.591]                 NAMES <- toupper(changed)
[13:20:54.591]                 args <- list()
[13:20:54.591]                 for (kk in seq_along(NAMES)) {
[13:20:54.591]                   name <- changed[[kk]]
[13:20:54.591]                   NAME <- NAMES[[kk]]
[13:20:54.591]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.591]                     next
[13:20:54.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.591]                 }
[13:20:54.591]                 NAMES <- toupper(added)
[13:20:54.591]                 for (kk in seq_along(NAMES)) {
[13:20:54.591]                   name <- added[[kk]]
[13:20:54.591]                   NAME <- NAMES[[kk]]
[13:20:54.591]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.591]                     next
[13:20:54.591]                   args[[name]] <- ""
[13:20:54.591]                 }
[13:20:54.591]                 NAMES <- toupper(removed)
[13:20:54.591]                 for (kk in seq_along(NAMES)) {
[13:20:54.591]                   name <- removed[[kk]]
[13:20:54.591]                   NAME <- NAMES[[kk]]
[13:20:54.591]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.591]                     next
[13:20:54.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.591]                 }
[13:20:54.591]                 if (length(args) > 0) 
[13:20:54.591]                   base::do.call(base::Sys.setenv, args = args)
[13:20:54.591]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:54.591]             }
[13:20:54.591]             else {
[13:20:54.591]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:54.591]             }
[13:20:54.591]             {
[13:20:54.591]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:54.591]                   0L) {
[13:20:54.591]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:54.591]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:54.591]                   base::options(opts)
[13:20:54.591]                 }
[13:20:54.591]                 {
[13:20:54.591]                   {
[13:20:54.591]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:54.591]                     NULL
[13:20:54.591]                   }
[13:20:54.591]                   options(future.plan = NULL)
[13:20:54.591]                   if (is.na(NA_character_)) 
[13:20:54.591]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.591]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:54.591]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:54.591]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:54.591]                     envir = parent.frame()) 
[13:20:54.591]                   {
[13:20:54.591]                     if (is.function(workers)) 
[13:20:54.591]                       workers <- workers()
[13:20:54.591]                     workers <- structure(as.integer(workers), 
[13:20:54.591]                       class = class(workers))
[13:20:54.591]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:54.591]                       workers >= 1)
[13:20:54.591]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:54.591]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:54.591]                     }
[13:20:54.591]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:54.591]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:54.591]                       envir = envir)
[13:20:54.591]                     if (!future$lazy) 
[13:20:54.591]                       future <- run(future)
[13:20:54.591]                     invisible(future)
[13:20:54.591]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:54.591]                 }
[13:20:54.591]             }
[13:20:54.591]         }
[13:20:54.591]     })
[13:20:54.591]     if (TRUE) {
[13:20:54.591]         base::sink(type = "output", split = FALSE)
[13:20:54.591]         if (TRUE) {
[13:20:54.591]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:54.591]         }
[13:20:54.591]         else {
[13:20:54.591]             ...future.result["stdout"] <- base::list(NULL)
[13:20:54.591]         }
[13:20:54.591]         base::close(...future.stdout)
[13:20:54.591]         ...future.stdout <- NULL
[13:20:54.591]     }
[13:20:54.591]     ...future.result$conditions <- ...future.conditions
[13:20:54.591]     ...future.result$finished <- base::Sys.time()
[13:20:54.591]     ...future.result
[13:20:54.591] }
[13:20:54.594] MultisessionFuture started
[13:20:54.594] - Launch lazy future ... done
[13:20:54.595] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:54.595] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:54.595] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:54.596] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:54.596] Searching for globals ... DONE
[13:20:54.596] Resolving globals: TRUE
[13:20:54.596] Resolving any globals that are futures ...
[13:20:54.596] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:54.596] Resolving any globals that are futures ... DONE
[13:20:54.597] Resolving futures part of globals (recursively) ...
[13:20:54.597] resolve() on list ...
[13:20:54.597]  recursive: 99
[13:20:54.597]  length: 1
[13:20:54.597]  elements: ‘a’
[13:20:54.642] receiveMessageFromWorker() for ClusterFuture ...
[13:20:54.642] - Validating connection of MultisessionFuture
[13:20:54.642] - received message: FutureResult
[13:20:54.642] - Received FutureResult
[13:20:54.642] - Erased future from FutureRegistry
[13:20:54.642] result() for ClusterFuture ...
[13:20:54.643] - result already collected: FutureResult
[13:20:54.643] result() for ClusterFuture ... done
[13:20:54.643] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:54.643] Future #1
[13:20:54.643] result() for ClusterFuture ...
[13:20:54.643] - result already collected: FutureResult
[13:20:54.643] result() for ClusterFuture ... done
[13:20:54.643] result() for ClusterFuture ...
[13:20:54.643] - result already collected: FutureResult
[13:20:54.643] result() for ClusterFuture ... done
[13:20:54.644] A MultisessionFuture was resolved
[13:20:54.644]  length: 0 (resolved future 1)
[13:20:54.644] resolve() on list ... DONE
[13:20:54.644] - globals: [1] ‘a’
[13:20:54.644] Resolving futures part of globals (recursively) ... DONE
[13:20:54.646] The total size of the 1 globals is 1.55 MiB (1629496 bytes)
[13:20:54.646] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[13:20:54.647] - globals: [1] ‘a’
[13:20:54.647] - packages: [1] ‘future’
[13:20:54.647] getGlobalsAndPackages() ... DONE
[13:20:54.647] run() for ‘Future’ ...
[13:20:54.647] - state: ‘created’
[13:20:54.647] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:54.662] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:54.662] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:54.662]   - Field: ‘node’
[13:20:54.662]   - Field: ‘label’
[13:20:54.662]   - Field: ‘local’
[13:20:54.662]   - Field: ‘owner’
[13:20:54.662]   - Field: ‘envir’
[13:20:54.663]   - Field: ‘workers’
[13:20:54.663]   - Field: ‘packages’
[13:20:54.663]   - Field: ‘gc’
[13:20:54.663]   - Field: ‘conditions’
[13:20:54.663]   - Field: ‘persistent’
[13:20:54.663]   - Field: ‘expr’
[13:20:54.663]   - Field: ‘uuid’
[13:20:54.663]   - Field: ‘seed’
[13:20:54.663]   - Field: ‘version’
[13:20:54.663]   - Field: ‘result’
[13:20:54.663]   - Field: ‘asynchronous’
[13:20:54.664]   - Field: ‘calls’
[13:20:54.664]   - Field: ‘globals’
[13:20:54.664]   - Field: ‘stdout’
[13:20:54.664]   - Field: ‘earlySignal’
[13:20:54.664]   - Field: ‘lazy’
[13:20:54.664]   - Field: ‘state’
[13:20:54.664] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:54.664] - Launch lazy future ...
[13:20:54.665] Packages needed by the future expression (n = 1): ‘future’
[13:20:54.665] Packages needed by future strategies (n = 0): <none>
[13:20:54.665] {
[13:20:54.665]     {
[13:20:54.665]         {
[13:20:54.665]             ...future.startTime <- base::Sys.time()
[13:20:54.665]             {
[13:20:54.665]                 {
[13:20:54.665]                   {
[13:20:54.665]                     {
[13:20:54.665]                       {
[13:20:54.665]                         base::local({
[13:20:54.665]                           has_future <- base::requireNamespace("future", 
[13:20:54.665]                             quietly = TRUE)
[13:20:54.665]                           if (has_future) {
[13:20:54.665]                             ns <- base::getNamespace("future")
[13:20:54.665]                             version <- ns[[".package"]][["version"]]
[13:20:54.665]                             if (is.null(version)) 
[13:20:54.665]                               version <- utils::packageVersion("future")
[13:20:54.665]                           }
[13:20:54.665]                           else {
[13:20:54.665]                             version <- NULL
[13:20:54.665]                           }
[13:20:54.665]                           if (!has_future || version < "1.8.0") {
[13:20:54.665]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:54.665]                               "", base::R.version$version.string), 
[13:20:54.665]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:54.665]                                 base::R.version$platform, 8 * 
[13:20:54.665]                                   base::.Machine$sizeof.pointer), 
[13:20:54.665]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:54.665]                                 "release", "version")], collapse = " "), 
[13:20:54.665]                               hostname = base::Sys.info()[["nodename"]])
[13:20:54.665]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:54.665]                               info)
[13:20:54.665]                             info <- base::paste(info, collapse = "; ")
[13:20:54.665]                             if (!has_future) {
[13:20:54.665]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:54.665]                                 info)
[13:20:54.665]                             }
[13:20:54.665]                             else {
[13:20:54.665]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:54.665]                                 info, version)
[13:20:54.665]                             }
[13:20:54.665]                             base::stop(msg)
[13:20:54.665]                           }
[13:20:54.665]                         })
[13:20:54.665]                       }
[13:20:54.665]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:54.665]                       base::options(mc.cores = 1L)
[13:20:54.665]                     }
[13:20:54.665]                     base::local({
[13:20:54.665]                       for (pkg in "future") {
[13:20:54.665]                         base::loadNamespace(pkg)
[13:20:54.665]                         base::library(pkg, character.only = TRUE)
[13:20:54.665]                       }
[13:20:54.665]                     })
[13:20:54.665]                   }
[13:20:54.665]                   options(future.plan = NULL)
[13:20:54.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:54.665]                 }
[13:20:54.665]                 ...future.workdir <- getwd()
[13:20:54.665]             }
[13:20:54.665]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:54.665]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:54.665]         }
[13:20:54.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:54.665]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:54.665]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:54.665]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:54.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:54.665]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:54.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:54.665]             base::names(...future.oldOptions))
[13:20:54.665]     }
[13:20:54.665]     if (FALSE) {
[13:20:54.665]     }
[13:20:54.665]     else {
[13:20:54.665]         if (TRUE) {
[13:20:54.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:54.665]                 open = "w")
[13:20:54.665]         }
[13:20:54.665]         else {
[13:20:54.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:54.665]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:54.665]         }
[13:20:54.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:54.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:54.665]             base::sink(type = "output", split = FALSE)
[13:20:54.665]             base::close(...future.stdout)
[13:20:54.665]         }, add = TRUE)
[13:20:54.665]     }
[13:20:54.665]     ...future.frame <- base::sys.nframe()
[13:20:54.665]     ...future.conditions <- base::list()
[13:20:54.665]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:54.665]     if (FALSE) {
[13:20:54.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:54.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:54.665]     }
[13:20:54.665]     ...future.result <- base::tryCatch({
[13:20:54.665]         base::withCallingHandlers({
[13:20:54.665]             ...future.value <- base::withVisible(base::local({
[13:20:54.665]                 ...future.makeSendCondition <- local({
[13:20:54.665]                   sendCondition <- NULL
[13:20:54.665]                   function(frame = 1L) {
[13:20:54.665]                     if (is.function(sendCondition)) 
[13:20:54.665]                       return(sendCondition)
[13:20:54.665]                     ns <- getNamespace("parallel")
[13:20:54.665]                     if (exists("sendData", mode = "function", 
[13:20:54.665]                       envir = ns)) {
[13:20:54.665]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:54.665]                         envir = ns)
[13:20:54.665]                       envir <- sys.frame(frame)
[13:20:54.665]                       master <- NULL
[13:20:54.665]                       while (!identical(envir, .GlobalEnv) && 
[13:20:54.665]                         !identical(envir, emptyenv())) {
[13:20:54.665]                         if (exists("master", mode = "list", envir = envir, 
[13:20:54.665]                           inherits = FALSE)) {
[13:20:54.665]                           master <- get("master", mode = "list", 
[13:20:54.665]                             envir = envir, inherits = FALSE)
[13:20:54.665]                           if (inherits(master, c("SOCKnode", 
[13:20:54.665]                             "SOCK0node"))) {
[13:20:54.665]                             sendCondition <<- function(cond) {
[13:20:54.665]                               data <- list(type = "VALUE", value = cond, 
[13:20:54.665]                                 success = TRUE)
[13:20:54.665]                               parallel_sendData(master, data)
[13:20:54.665]                             }
[13:20:54.665]                             return(sendCondition)
[13:20:54.665]                           }
[13:20:54.665]                         }
[13:20:54.665]                         frame <- frame + 1L
[13:20:54.665]                         envir <- sys.frame(frame)
[13:20:54.665]                       }
[13:20:54.665]                     }
[13:20:54.665]                     sendCondition <<- function(cond) NULL
[13:20:54.665]                   }
[13:20:54.665]                 })
[13:20:54.665]                 withCallingHandlers({
[13:20:54.665]                   value(a) + 1
[13:20:54.665]                 }, immediateCondition = function(cond) {
[13:20:54.665]                   sendCondition <- ...future.makeSendCondition()
[13:20:54.665]                   sendCondition(cond)
[13:20:54.665]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.665]                   {
[13:20:54.665]                     inherits <- base::inherits
[13:20:54.665]                     invokeRestart <- base::invokeRestart
[13:20:54.665]                     is.null <- base::is.null
[13:20:54.665]                     muffled <- FALSE
[13:20:54.665]                     if (inherits(cond, "message")) {
[13:20:54.665]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:54.665]                       if (muffled) 
[13:20:54.665]                         invokeRestart("muffleMessage")
[13:20:54.665]                     }
[13:20:54.665]                     else if (inherits(cond, "warning")) {
[13:20:54.665]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:54.665]                       if (muffled) 
[13:20:54.665]                         invokeRestart("muffleWarning")
[13:20:54.665]                     }
[13:20:54.665]                     else if (inherits(cond, "condition")) {
[13:20:54.665]                       if (!is.null(pattern)) {
[13:20:54.665]                         computeRestarts <- base::computeRestarts
[13:20:54.665]                         grepl <- base::grepl
[13:20:54.665]                         restarts <- computeRestarts(cond)
[13:20:54.665]                         for (restart in restarts) {
[13:20:54.665]                           name <- restart$name
[13:20:54.665]                           if (is.null(name)) 
[13:20:54.665]                             next
[13:20:54.665]                           if (!grepl(pattern, name)) 
[13:20:54.665]                             next
[13:20:54.665]                           invokeRestart(restart)
[13:20:54.665]                           muffled <- TRUE
[13:20:54.665]                           break
[13:20:54.665]                         }
[13:20:54.665]                       }
[13:20:54.665]                     }
[13:20:54.665]                     invisible(muffled)
[13:20:54.665]                   }
[13:20:54.665]                   muffleCondition(cond)
[13:20:54.665]                 })
[13:20:54.665]             }))
[13:20:54.665]             future::FutureResult(value = ...future.value$value, 
[13:20:54.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.665]                   ...future.rng), globalenv = if (FALSE) 
[13:20:54.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:54.665]                     ...future.globalenv.names))
[13:20:54.665]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:54.665]         }, condition = base::local({
[13:20:54.665]             c <- base::c
[13:20:54.665]             inherits <- base::inherits
[13:20:54.665]             invokeRestart <- base::invokeRestart
[13:20:54.665]             length <- base::length
[13:20:54.665]             list <- base::list
[13:20:54.665]             seq.int <- base::seq.int
[13:20:54.665]             signalCondition <- base::signalCondition
[13:20:54.665]             sys.calls <- base::sys.calls
[13:20:54.665]             `[[` <- base::`[[`
[13:20:54.665]             `+` <- base::`+`
[13:20:54.665]             `<<-` <- base::`<<-`
[13:20:54.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:54.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:54.665]                   3L)]
[13:20:54.665]             }
[13:20:54.665]             function(cond) {
[13:20:54.665]                 is_error <- inherits(cond, "error")
[13:20:54.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:54.665]                   NULL)
[13:20:54.665]                 if (is_error) {
[13:20:54.665]                   sessionInformation <- function() {
[13:20:54.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:54.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:54.665]                       search = base::search(), system = base::Sys.info())
[13:20:54.665]                   }
[13:20:54.665]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:54.665]                     cond$call), session = sessionInformation(), 
[13:20:54.665]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:54.665]                   signalCondition(cond)
[13:20:54.665]                 }
[13:20:54.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:54.665]                 "immediateCondition"))) {
[13:20:54.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:54.665]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:54.665]                   if (TRUE && !signal) {
[13:20:54.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.665]                     {
[13:20:54.665]                       inherits <- base::inherits
[13:20:54.665]                       invokeRestart <- base::invokeRestart
[13:20:54.665]                       is.null <- base::is.null
[13:20:54.665]                       muffled <- FALSE
[13:20:54.665]                       if (inherits(cond, "message")) {
[13:20:54.665]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.665]                         if (muffled) 
[13:20:54.665]                           invokeRestart("muffleMessage")
[13:20:54.665]                       }
[13:20:54.665]                       else if (inherits(cond, "warning")) {
[13:20:54.665]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.665]                         if (muffled) 
[13:20:54.665]                           invokeRestart("muffleWarning")
[13:20:54.665]                       }
[13:20:54.665]                       else if (inherits(cond, "condition")) {
[13:20:54.665]                         if (!is.null(pattern)) {
[13:20:54.665]                           computeRestarts <- base::computeRestarts
[13:20:54.665]                           grepl <- base::grepl
[13:20:54.665]                           restarts <- computeRestarts(cond)
[13:20:54.665]                           for (restart in restarts) {
[13:20:54.665]                             name <- restart$name
[13:20:54.665]                             if (is.null(name)) 
[13:20:54.665]                               next
[13:20:54.665]                             if (!grepl(pattern, name)) 
[13:20:54.665]                               next
[13:20:54.665]                             invokeRestart(restart)
[13:20:54.665]                             muffled <- TRUE
[13:20:54.665]                             break
[13:20:54.665]                           }
[13:20:54.665]                         }
[13:20:54.665]                       }
[13:20:54.665]                       invisible(muffled)
[13:20:54.665]                     }
[13:20:54.665]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.665]                   }
[13:20:54.665]                 }
[13:20:54.665]                 else {
[13:20:54.665]                   if (TRUE) {
[13:20:54.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.665]                     {
[13:20:54.665]                       inherits <- base::inherits
[13:20:54.665]                       invokeRestart <- base::invokeRestart
[13:20:54.665]                       is.null <- base::is.null
[13:20:54.665]                       muffled <- FALSE
[13:20:54.665]                       if (inherits(cond, "message")) {
[13:20:54.665]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.665]                         if (muffled) 
[13:20:54.665]                           invokeRestart("muffleMessage")
[13:20:54.665]                       }
[13:20:54.665]                       else if (inherits(cond, "warning")) {
[13:20:54.665]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.665]                         if (muffled) 
[13:20:54.665]                           invokeRestart("muffleWarning")
[13:20:54.665]                       }
[13:20:54.665]                       else if (inherits(cond, "condition")) {
[13:20:54.665]                         if (!is.null(pattern)) {
[13:20:54.665]                           computeRestarts <- base::computeRestarts
[13:20:54.665]                           grepl <- base::grepl
[13:20:54.665]                           restarts <- computeRestarts(cond)
[13:20:54.665]                           for (restart in restarts) {
[13:20:54.665]                             name <- restart$name
[13:20:54.665]                             if (is.null(name)) 
[13:20:54.665]                               next
[13:20:54.665]                             if (!grepl(pattern, name)) 
[13:20:54.665]                               next
[13:20:54.665]                             invokeRestart(restart)
[13:20:54.665]                             muffled <- TRUE
[13:20:54.665]                             break
[13:20:54.665]                           }
[13:20:54.665]                         }
[13:20:54.665]                       }
[13:20:54.665]                       invisible(muffled)
[13:20:54.665]                     }
[13:20:54.665]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.665]                   }
[13:20:54.665]                 }
[13:20:54.665]             }
[13:20:54.665]         }))
[13:20:54.665]     }, error = function(ex) {
[13:20:54.665]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:54.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.665]                 ...future.rng), started = ...future.startTime, 
[13:20:54.665]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:54.665]             version = "1.8"), class = "FutureResult")
[13:20:54.665]     }, finally = {
[13:20:54.665]         if (!identical(...future.workdir, getwd())) 
[13:20:54.665]             setwd(...future.workdir)
[13:20:54.665]         {
[13:20:54.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:54.665]                 ...future.oldOptions$nwarnings <- NULL
[13:20:54.665]             }
[13:20:54.665]             base::options(...future.oldOptions)
[13:20:54.665]             if (.Platform$OS.type == "windows") {
[13:20:54.665]                 old_names <- names(...future.oldEnvVars)
[13:20:54.665]                 envs <- base::Sys.getenv()
[13:20:54.665]                 names <- names(envs)
[13:20:54.665]                 common <- intersect(names, old_names)
[13:20:54.665]                 added <- setdiff(names, old_names)
[13:20:54.665]                 removed <- setdiff(old_names, names)
[13:20:54.665]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:54.665]                   envs[common]]
[13:20:54.665]                 NAMES <- toupper(changed)
[13:20:54.665]                 args <- list()
[13:20:54.665]                 for (kk in seq_along(NAMES)) {
[13:20:54.665]                   name <- changed[[kk]]
[13:20:54.665]                   NAME <- NAMES[[kk]]
[13:20:54.665]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.665]                     next
[13:20:54.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.665]                 }
[13:20:54.665]                 NAMES <- toupper(added)
[13:20:54.665]                 for (kk in seq_along(NAMES)) {
[13:20:54.665]                   name <- added[[kk]]
[13:20:54.665]                   NAME <- NAMES[[kk]]
[13:20:54.665]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.665]                     next
[13:20:54.665]                   args[[name]] <- ""
[13:20:54.665]                 }
[13:20:54.665]                 NAMES <- toupper(removed)
[13:20:54.665]                 for (kk in seq_along(NAMES)) {
[13:20:54.665]                   name <- removed[[kk]]
[13:20:54.665]                   NAME <- NAMES[[kk]]
[13:20:54.665]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.665]                     next
[13:20:54.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.665]                 }
[13:20:54.665]                 if (length(args) > 0) 
[13:20:54.665]                   base::do.call(base::Sys.setenv, args = args)
[13:20:54.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:54.665]             }
[13:20:54.665]             else {
[13:20:54.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:54.665]             }
[13:20:54.665]             {
[13:20:54.665]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:54.665]                   0L) {
[13:20:54.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:54.665]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:54.665]                   base::options(opts)
[13:20:54.665]                 }
[13:20:54.665]                 {
[13:20:54.665]                   {
[13:20:54.665]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:54.665]                     NULL
[13:20:54.665]                   }
[13:20:54.665]                   options(future.plan = NULL)
[13:20:54.665]                   if (is.na(NA_character_)) 
[13:20:54.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:54.665]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:54.665]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:54.665]                     envir = parent.frame()) 
[13:20:54.665]                   {
[13:20:54.665]                     if (is.function(workers)) 
[13:20:54.665]                       workers <- workers()
[13:20:54.665]                     workers <- structure(as.integer(workers), 
[13:20:54.665]                       class = class(workers))
[13:20:54.665]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:54.665]                       workers >= 1)
[13:20:54.665]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:54.665]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:54.665]                     }
[13:20:54.665]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:54.665]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:54.665]                       envir = envir)
[13:20:54.665]                     if (!future$lazy) 
[13:20:54.665]                       future <- run(future)
[13:20:54.665]                     invisible(future)
[13:20:54.665]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:54.665]                 }
[13:20:54.665]             }
[13:20:54.665]         }
[13:20:54.665]     })
[13:20:54.665]     if (TRUE) {
[13:20:54.665]         base::sink(type = "output", split = FALSE)
[13:20:54.665]         if (TRUE) {
[13:20:54.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:54.665]         }
[13:20:54.665]         else {
[13:20:54.665]             ...future.result["stdout"] <- base::list(NULL)
[13:20:54.665]         }
[13:20:54.665]         base::close(...future.stdout)
[13:20:54.665]         ...future.stdout <- NULL
[13:20:54.665]     }
[13:20:54.665]     ...future.result$conditions <- ...future.conditions
[13:20:54.665]     ...future.result$finished <- base::Sys.time()
[13:20:54.665]     ...future.result
[13:20:54.665] }
[13:20:54.668] Exporting 1 global objects (1.55 MiB) to cluster node #1 ...
[13:20:54.670] Exporting ‘a’ (1.55 MiB) to cluster node #1 ...
[13:20:54.721] Exporting ‘a’ (1.55 MiB) to cluster node #1 ... DONE
[13:20:54.721] Exporting 1 global objects (1.55 MiB) to cluster node #1 ... DONE
[13:20:54.722] MultisessionFuture started
[13:20:54.722] - Launch lazy future ... done
[13:20:54.722] run() for ‘MultisessionFuture’ ... done
[13:20:54.722] result() for ClusterFuture ...
[13:20:54.722] receiveMessageFromWorker() for ClusterFuture ...
[13:20:54.722] - Validating connection of MultisessionFuture
[13:20:54.775] - received message: FutureResult
[13:20:54.775] - Received FutureResult
[13:20:54.776] - Erased future from FutureRegistry
[13:20:54.776] result() for ClusterFuture ...
[13:20:54.776] - result already collected: FutureResult
[13:20:54.776] result() for ClusterFuture ... done
[13:20:54.776] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:54.776] result() for ClusterFuture ... done
[13:20:54.776] result() for ClusterFuture ...
[13:20:54.776] - result already collected: FutureResult
[13:20:54.776] result() for ClusterFuture ... done
value(b) = 2
[13:20:54.777] result() for ClusterFuture ...
[13:20:54.777] - result already collected: FutureResult
[13:20:54.777] result() for ClusterFuture ... done
[13:20:54.777] result() for ClusterFuture ...
[13:20:54.777] - result already collected: FutureResult
[13:20:54.777] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:54.777] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:54.778] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:54.778] 
[13:20:54.778] Searching for globals ... DONE
[13:20:54.778] - globals: [0] <none>
[13:20:54.778] getGlobalsAndPackages() ... DONE
[13:20:54.779] run() for ‘Future’ ...
[13:20:54.779] - state: ‘created’
[13:20:54.779] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:54.793] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:54.794] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:54.794]   - Field: ‘node’
[13:20:54.794]   - Field: ‘label’
[13:20:54.794]   - Field: ‘local’
[13:20:54.794]   - Field: ‘owner’
[13:20:54.794]   - Field: ‘envir’
[13:20:54.794]   - Field: ‘workers’
[13:20:54.794]   - Field: ‘packages’
[13:20:54.794]   - Field: ‘gc’
[13:20:54.794]   - Field: ‘conditions’
[13:20:54.795]   - Field: ‘persistent’
[13:20:54.795]   - Field: ‘expr’
[13:20:54.795]   - Field: ‘uuid’
[13:20:54.795]   - Field: ‘seed’
[13:20:54.795]   - Field: ‘version’
[13:20:54.795]   - Field: ‘result’
[13:20:54.795]   - Field: ‘asynchronous’
[13:20:54.795]   - Field: ‘calls’
[13:20:54.795]   - Field: ‘globals’
[13:20:54.795]   - Field: ‘stdout’
[13:20:54.795]   - Field: ‘earlySignal’
[13:20:54.796]   - Field: ‘lazy’
[13:20:54.796]   - Field: ‘state’
[13:20:54.796] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:54.796] - Launch lazy future ...
[13:20:54.796] Packages needed by the future expression (n = 0): <none>
[13:20:54.796] Packages needed by future strategies (n = 0): <none>
[13:20:54.797] {
[13:20:54.797]     {
[13:20:54.797]         {
[13:20:54.797]             ...future.startTime <- base::Sys.time()
[13:20:54.797]             {
[13:20:54.797]                 {
[13:20:54.797]                   {
[13:20:54.797]                     {
[13:20:54.797]                       base::local({
[13:20:54.797]                         has_future <- base::requireNamespace("future", 
[13:20:54.797]                           quietly = TRUE)
[13:20:54.797]                         if (has_future) {
[13:20:54.797]                           ns <- base::getNamespace("future")
[13:20:54.797]                           version <- ns[[".package"]][["version"]]
[13:20:54.797]                           if (is.null(version)) 
[13:20:54.797]                             version <- utils::packageVersion("future")
[13:20:54.797]                         }
[13:20:54.797]                         else {
[13:20:54.797]                           version <- NULL
[13:20:54.797]                         }
[13:20:54.797]                         if (!has_future || version < "1.8.0") {
[13:20:54.797]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:54.797]                             "", base::R.version$version.string), 
[13:20:54.797]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:54.797]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:54.797]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:54.797]                               "release", "version")], collapse = " "), 
[13:20:54.797]                             hostname = base::Sys.info()[["nodename"]])
[13:20:54.797]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:54.797]                             info)
[13:20:54.797]                           info <- base::paste(info, collapse = "; ")
[13:20:54.797]                           if (!has_future) {
[13:20:54.797]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:54.797]                               info)
[13:20:54.797]                           }
[13:20:54.797]                           else {
[13:20:54.797]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:54.797]                               info, version)
[13:20:54.797]                           }
[13:20:54.797]                           base::stop(msg)
[13:20:54.797]                         }
[13:20:54.797]                       })
[13:20:54.797]                     }
[13:20:54.797]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:54.797]                     base::options(mc.cores = 1L)
[13:20:54.797]                   }
[13:20:54.797]                   options(future.plan = NULL)
[13:20:54.797]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.797]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:54.797]                 }
[13:20:54.797]                 ...future.workdir <- getwd()
[13:20:54.797]             }
[13:20:54.797]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:54.797]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:54.797]         }
[13:20:54.797]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:54.797]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:54.797]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:54.797]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:54.797]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:54.797]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:54.797]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:54.797]             base::names(...future.oldOptions))
[13:20:54.797]     }
[13:20:54.797]     if (FALSE) {
[13:20:54.797]     }
[13:20:54.797]     else {
[13:20:54.797]         if (TRUE) {
[13:20:54.797]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:54.797]                 open = "w")
[13:20:54.797]         }
[13:20:54.797]         else {
[13:20:54.797]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:54.797]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:54.797]         }
[13:20:54.797]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:54.797]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:54.797]             base::sink(type = "output", split = FALSE)
[13:20:54.797]             base::close(...future.stdout)
[13:20:54.797]         }, add = TRUE)
[13:20:54.797]     }
[13:20:54.797]     ...future.frame <- base::sys.nframe()
[13:20:54.797]     ...future.conditions <- base::list()
[13:20:54.797]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:54.797]     if (FALSE) {
[13:20:54.797]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:54.797]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:54.797]     }
[13:20:54.797]     ...future.result <- base::tryCatch({
[13:20:54.797]         base::withCallingHandlers({
[13:20:54.797]             ...future.value <- base::withVisible(base::local({
[13:20:54.797]                 ...future.makeSendCondition <- local({
[13:20:54.797]                   sendCondition <- NULL
[13:20:54.797]                   function(frame = 1L) {
[13:20:54.797]                     if (is.function(sendCondition)) 
[13:20:54.797]                       return(sendCondition)
[13:20:54.797]                     ns <- getNamespace("parallel")
[13:20:54.797]                     if (exists("sendData", mode = "function", 
[13:20:54.797]                       envir = ns)) {
[13:20:54.797]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:54.797]                         envir = ns)
[13:20:54.797]                       envir <- sys.frame(frame)
[13:20:54.797]                       master <- NULL
[13:20:54.797]                       while (!identical(envir, .GlobalEnv) && 
[13:20:54.797]                         !identical(envir, emptyenv())) {
[13:20:54.797]                         if (exists("master", mode = "list", envir = envir, 
[13:20:54.797]                           inherits = FALSE)) {
[13:20:54.797]                           master <- get("master", mode = "list", 
[13:20:54.797]                             envir = envir, inherits = FALSE)
[13:20:54.797]                           if (inherits(master, c("SOCKnode", 
[13:20:54.797]                             "SOCK0node"))) {
[13:20:54.797]                             sendCondition <<- function(cond) {
[13:20:54.797]                               data <- list(type = "VALUE", value = cond, 
[13:20:54.797]                                 success = TRUE)
[13:20:54.797]                               parallel_sendData(master, data)
[13:20:54.797]                             }
[13:20:54.797]                             return(sendCondition)
[13:20:54.797]                           }
[13:20:54.797]                         }
[13:20:54.797]                         frame <- frame + 1L
[13:20:54.797]                         envir <- sys.frame(frame)
[13:20:54.797]                       }
[13:20:54.797]                     }
[13:20:54.797]                     sendCondition <<- function(cond) NULL
[13:20:54.797]                   }
[13:20:54.797]                 })
[13:20:54.797]                 withCallingHandlers({
[13:20:54.797]                   1
[13:20:54.797]                 }, immediateCondition = function(cond) {
[13:20:54.797]                   sendCondition <- ...future.makeSendCondition()
[13:20:54.797]                   sendCondition(cond)
[13:20:54.797]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.797]                   {
[13:20:54.797]                     inherits <- base::inherits
[13:20:54.797]                     invokeRestart <- base::invokeRestart
[13:20:54.797]                     is.null <- base::is.null
[13:20:54.797]                     muffled <- FALSE
[13:20:54.797]                     if (inherits(cond, "message")) {
[13:20:54.797]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:54.797]                       if (muffled) 
[13:20:54.797]                         invokeRestart("muffleMessage")
[13:20:54.797]                     }
[13:20:54.797]                     else if (inherits(cond, "warning")) {
[13:20:54.797]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:54.797]                       if (muffled) 
[13:20:54.797]                         invokeRestart("muffleWarning")
[13:20:54.797]                     }
[13:20:54.797]                     else if (inherits(cond, "condition")) {
[13:20:54.797]                       if (!is.null(pattern)) {
[13:20:54.797]                         computeRestarts <- base::computeRestarts
[13:20:54.797]                         grepl <- base::grepl
[13:20:54.797]                         restarts <- computeRestarts(cond)
[13:20:54.797]                         for (restart in restarts) {
[13:20:54.797]                           name <- restart$name
[13:20:54.797]                           if (is.null(name)) 
[13:20:54.797]                             next
[13:20:54.797]                           if (!grepl(pattern, name)) 
[13:20:54.797]                             next
[13:20:54.797]                           invokeRestart(restart)
[13:20:54.797]                           muffled <- TRUE
[13:20:54.797]                           break
[13:20:54.797]                         }
[13:20:54.797]                       }
[13:20:54.797]                     }
[13:20:54.797]                     invisible(muffled)
[13:20:54.797]                   }
[13:20:54.797]                   muffleCondition(cond)
[13:20:54.797]                 })
[13:20:54.797]             }))
[13:20:54.797]             future::FutureResult(value = ...future.value$value, 
[13:20:54.797]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.797]                   ...future.rng), globalenv = if (FALSE) 
[13:20:54.797]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:54.797]                     ...future.globalenv.names))
[13:20:54.797]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:54.797]         }, condition = base::local({
[13:20:54.797]             c <- base::c
[13:20:54.797]             inherits <- base::inherits
[13:20:54.797]             invokeRestart <- base::invokeRestart
[13:20:54.797]             length <- base::length
[13:20:54.797]             list <- base::list
[13:20:54.797]             seq.int <- base::seq.int
[13:20:54.797]             signalCondition <- base::signalCondition
[13:20:54.797]             sys.calls <- base::sys.calls
[13:20:54.797]             `[[` <- base::`[[`
[13:20:54.797]             `+` <- base::`+`
[13:20:54.797]             `<<-` <- base::`<<-`
[13:20:54.797]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:54.797]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:54.797]                   3L)]
[13:20:54.797]             }
[13:20:54.797]             function(cond) {
[13:20:54.797]                 is_error <- inherits(cond, "error")
[13:20:54.797]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:54.797]                   NULL)
[13:20:54.797]                 if (is_error) {
[13:20:54.797]                   sessionInformation <- function() {
[13:20:54.797]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:54.797]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:54.797]                       search = base::search(), system = base::Sys.info())
[13:20:54.797]                   }
[13:20:54.797]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.797]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:54.797]                     cond$call), session = sessionInformation(), 
[13:20:54.797]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:54.797]                   signalCondition(cond)
[13:20:54.797]                 }
[13:20:54.797]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:54.797]                 "immediateCondition"))) {
[13:20:54.797]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:54.797]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.797]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:54.797]                   if (TRUE && !signal) {
[13:20:54.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.797]                     {
[13:20:54.797]                       inherits <- base::inherits
[13:20:54.797]                       invokeRestart <- base::invokeRestart
[13:20:54.797]                       is.null <- base::is.null
[13:20:54.797]                       muffled <- FALSE
[13:20:54.797]                       if (inherits(cond, "message")) {
[13:20:54.797]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.797]                         if (muffled) 
[13:20:54.797]                           invokeRestart("muffleMessage")
[13:20:54.797]                       }
[13:20:54.797]                       else if (inherits(cond, "warning")) {
[13:20:54.797]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.797]                         if (muffled) 
[13:20:54.797]                           invokeRestart("muffleWarning")
[13:20:54.797]                       }
[13:20:54.797]                       else if (inherits(cond, "condition")) {
[13:20:54.797]                         if (!is.null(pattern)) {
[13:20:54.797]                           computeRestarts <- base::computeRestarts
[13:20:54.797]                           grepl <- base::grepl
[13:20:54.797]                           restarts <- computeRestarts(cond)
[13:20:54.797]                           for (restart in restarts) {
[13:20:54.797]                             name <- restart$name
[13:20:54.797]                             if (is.null(name)) 
[13:20:54.797]                               next
[13:20:54.797]                             if (!grepl(pattern, name)) 
[13:20:54.797]                               next
[13:20:54.797]                             invokeRestart(restart)
[13:20:54.797]                             muffled <- TRUE
[13:20:54.797]                             break
[13:20:54.797]                           }
[13:20:54.797]                         }
[13:20:54.797]                       }
[13:20:54.797]                       invisible(muffled)
[13:20:54.797]                     }
[13:20:54.797]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.797]                   }
[13:20:54.797]                 }
[13:20:54.797]                 else {
[13:20:54.797]                   if (TRUE) {
[13:20:54.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.797]                     {
[13:20:54.797]                       inherits <- base::inherits
[13:20:54.797]                       invokeRestart <- base::invokeRestart
[13:20:54.797]                       is.null <- base::is.null
[13:20:54.797]                       muffled <- FALSE
[13:20:54.797]                       if (inherits(cond, "message")) {
[13:20:54.797]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.797]                         if (muffled) 
[13:20:54.797]                           invokeRestart("muffleMessage")
[13:20:54.797]                       }
[13:20:54.797]                       else if (inherits(cond, "warning")) {
[13:20:54.797]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.797]                         if (muffled) 
[13:20:54.797]                           invokeRestart("muffleWarning")
[13:20:54.797]                       }
[13:20:54.797]                       else if (inherits(cond, "condition")) {
[13:20:54.797]                         if (!is.null(pattern)) {
[13:20:54.797]                           computeRestarts <- base::computeRestarts
[13:20:54.797]                           grepl <- base::grepl
[13:20:54.797]                           restarts <- computeRestarts(cond)
[13:20:54.797]                           for (restart in restarts) {
[13:20:54.797]                             name <- restart$name
[13:20:54.797]                             if (is.null(name)) 
[13:20:54.797]                               next
[13:20:54.797]                             if (!grepl(pattern, name)) 
[13:20:54.797]                               next
[13:20:54.797]                             invokeRestart(restart)
[13:20:54.797]                             muffled <- TRUE
[13:20:54.797]                             break
[13:20:54.797]                           }
[13:20:54.797]                         }
[13:20:54.797]                       }
[13:20:54.797]                       invisible(muffled)
[13:20:54.797]                     }
[13:20:54.797]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.797]                   }
[13:20:54.797]                 }
[13:20:54.797]             }
[13:20:54.797]         }))
[13:20:54.797]     }, error = function(ex) {
[13:20:54.797]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:54.797]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.797]                 ...future.rng), started = ...future.startTime, 
[13:20:54.797]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:54.797]             version = "1.8"), class = "FutureResult")
[13:20:54.797]     }, finally = {
[13:20:54.797]         if (!identical(...future.workdir, getwd())) 
[13:20:54.797]             setwd(...future.workdir)
[13:20:54.797]         {
[13:20:54.797]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:54.797]                 ...future.oldOptions$nwarnings <- NULL
[13:20:54.797]             }
[13:20:54.797]             base::options(...future.oldOptions)
[13:20:54.797]             if (.Platform$OS.type == "windows") {
[13:20:54.797]                 old_names <- names(...future.oldEnvVars)
[13:20:54.797]                 envs <- base::Sys.getenv()
[13:20:54.797]                 names <- names(envs)
[13:20:54.797]                 common <- intersect(names, old_names)
[13:20:54.797]                 added <- setdiff(names, old_names)
[13:20:54.797]                 removed <- setdiff(old_names, names)
[13:20:54.797]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:54.797]                   envs[common]]
[13:20:54.797]                 NAMES <- toupper(changed)
[13:20:54.797]                 args <- list()
[13:20:54.797]                 for (kk in seq_along(NAMES)) {
[13:20:54.797]                   name <- changed[[kk]]
[13:20:54.797]                   NAME <- NAMES[[kk]]
[13:20:54.797]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.797]                     next
[13:20:54.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.797]                 }
[13:20:54.797]                 NAMES <- toupper(added)
[13:20:54.797]                 for (kk in seq_along(NAMES)) {
[13:20:54.797]                   name <- added[[kk]]
[13:20:54.797]                   NAME <- NAMES[[kk]]
[13:20:54.797]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.797]                     next
[13:20:54.797]                   args[[name]] <- ""
[13:20:54.797]                 }
[13:20:54.797]                 NAMES <- toupper(removed)
[13:20:54.797]                 for (kk in seq_along(NAMES)) {
[13:20:54.797]                   name <- removed[[kk]]
[13:20:54.797]                   NAME <- NAMES[[kk]]
[13:20:54.797]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.797]                     next
[13:20:54.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.797]                 }
[13:20:54.797]                 if (length(args) > 0) 
[13:20:54.797]                   base::do.call(base::Sys.setenv, args = args)
[13:20:54.797]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:54.797]             }
[13:20:54.797]             else {
[13:20:54.797]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:54.797]             }
[13:20:54.797]             {
[13:20:54.797]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:54.797]                   0L) {
[13:20:54.797]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:54.797]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:54.797]                   base::options(opts)
[13:20:54.797]                 }
[13:20:54.797]                 {
[13:20:54.797]                   {
[13:20:54.797]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:54.797]                     NULL
[13:20:54.797]                   }
[13:20:54.797]                   options(future.plan = NULL)
[13:20:54.797]                   if (is.na(NA_character_)) 
[13:20:54.797]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.797]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:54.797]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:54.797]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:54.797]                     envir = parent.frame()) 
[13:20:54.797]                   {
[13:20:54.797]                     if (is.function(workers)) 
[13:20:54.797]                       workers <- workers()
[13:20:54.797]                     workers <- structure(as.integer(workers), 
[13:20:54.797]                       class = class(workers))
[13:20:54.797]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:54.797]                       workers >= 1)
[13:20:54.797]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:54.797]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:54.797]                     }
[13:20:54.797]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:54.797]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:54.797]                       envir = envir)
[13:20:54.797]                     if (!future$lazy) 
[13:20:54.797]                       future <- run(future)
[13:20:54.797]                     invisible(future)
[13:20:54.797]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:54.797]                 }
[13:20:54.797]             }
[13:20:54.797]         }
[13:20:54.797]     })
[13:20:54.797]     if (TRUE) {
[13:20:54.797]         base::sink(type = "output", split = FALSE)
[13:20:54.797]         if (TRUE) {
[13:20:54.797]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:54.797]         }
[13:20:54.797]         else {
[13:20:54.797]             ...future.result["stdout"] <- base::list(NULL)
[13:20:54.797]         }
[13:20:54.797]         base::close(...future.stdout)
[13:20:54.797]         ...future.stdout <- NULL
[13:20:54.797]     }
[13:20:54.797]     ...future.result$conditions <- ...future.conditions
[13:20:54.797]     ...future.result$finished <- base::Sys.time()
[13:20:54.797]     ...future.result
[13:20:54.797] }
[13:20:54.800] MultisessionFuture started
[13:20:54.800] - Launch lazy future ... done
[13:20:54.800] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:54.801] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:54.801] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:54.802] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:54.802] Searching for globals ... DONE
[13:20:54.802] Resolving globals: TRUE
[13:20:54.802] Resolving any globals that are futures ...
[13:20:54.802] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:54.802] Resolving any globals that are futures ... DONE
[13:20:54.802] Resolving futures part of globals (recursively) ...
[13:20:54.803] resolve() on list ...
[13:20:54.803]  recursive: 99
[13:20:54.803]  length: 1
[13:20:54.803]  elements: ‘a’
[13:20:54.846] receiveMessageFromWorker() for ClusterFuture ...
[13:20:54.846] - Validating connection of MultisessionFuture
[13:20:54.846] - received message: FutureResult
[13:20:54.846] - Received FutureResult
[13:20:54.846] - Erased future from FutureRegistry
[13:20:54.846] result() for ClusterFuture ...
[13:20:54.847] - result already collected: FutureResult
[13:20:54.847] result() for ClusterFuture ... done
[13:20:54.847] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:54.847] Future #1
[13:20:54.847] result() for ClusterFuture ...
[13:20:54.847] - result already collected: FutureResult
[13:20:54.847] result() for ClusterFuture ... done
[13:20:54.847] result() for ClusterFuture ...
[13:20:54.847] - result already collected: FutureResult
[13:20:54.847] result() for ClusterFuture ... done
[13:20:54.848] A MultisessionFuture was resolved
[13:20:54.848]  length: 0 (resolved future 1)
[13:20:54.848] resolve() on list ... DONE
[13:20:54.848] - globals: [1] ‘a’
[13:20:54.848] Resolving futures part of globals (recursively) ... DONE
[13:20:54.852] The total size of the 1 globals is 1.55 MiB (1629496 bytes)
[13:20:54.853] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[13:20:54.853] - globals: [1] ‘a’
[13:20:54.853] - packages: [1] ‘future’
[13:20:54.853] getGlobalsAndPackages() ... DONE
[13:20:54.853] run() for ‘Future’ ...
[13:20:54.854] - state: ‘created’
[13:20:54.854] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:54.868] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:54.868] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:54.868]   - Field: ‘node’
[13:20:54.868]   - Field: ‘label’
[13:20:54.868]   - Field: ‘local’
[13:20:54.869]   - Field: ‘owner’
[13:20:54.869]   - Field: ‘envir’
[13:20:54.869]   - Field: ‘workers’
[13:20:54.869]   - Field: ‘packages’
[13:20:54.869]   - Field: ‘gc’
[13:20:54.869]   - Field: ‘conditions’
[13:20:54.869]   - Field: ‘persistent’
[13:20:54.869]   - Field: ‘expr’
[13:20:54.869]   - Field: ‘uuid’
[13:20:54.869]   - Field: ‘seed’
[13:20:54.870]   - Field: ‘version’
[13:20:54.870]   - Field: ‘result’
[13:20:54.870]   - Field: ‘asynchronous’
[13:20:54.870]   - Field: ‘calls’
[13:20:54.870]   - Field: ‘globals’
[13:20:54.870]   - Field: ‘stdout’
[13:20:54.870]   - Field: ‘earlySignal’
[13:20:54.870]   - Field: ‘lazy’
[13:20:54.870]   - Field: ‘state’
[13:20:54.870] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:54.870] - Launch lazy future ...
[13:20:54.871] Packages needed by the future expression (n = 1): ‘future’
[13:20:54.871] Packages needed by future strategies (n = 0): <none>
[13:20:54.871] {
[13:20:54.871]     {
[13:20:54.871]         {
[13:20:54.871]             ...future.startTime <- base::Sys.time()
[13:20:54.871]             {
[13:20:54.871]                 {
[13:20:54.871]                   {
[13:20:54.871]                     {
[13:20:54.871]                       {
[13:20:54.871]                         base::local({
[13:20:54.871]                           has_future <- base::requireNamespace("future", 
[13:20:54.871]                             quietly = TRUE)
[13:20:54.871]                           if (has_future) {
[13:20:54.871]                             ns <- base::getNamespace("future")
[13:20:54.871]                             version <- ns[[".package"]][["version"]]
[13:20:54.871]                             if (is.null(version)) 
[13:20:54.871]                               version <- utils::packageVersion("future")
[13:20:54.871]                           }
[13:20:54.871]                           else {
[13:20:54.871]                             version <- NULL
[13:20:54.871]                           }
[13:20:54.871]                           if (!has_future || version < "1.8.0") {
[13:20:54.871]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:54.871]                               "", base::R.version$version.string), 
[13:20:54.871]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:54.871]                                 base::R.version$platform, 8 * 
[13:20:54.871]                                   base::.Machine$sizeof.pointer), 
[13:20:54.871]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:54.871]                                 "release", "version")], collapse = " "), 
[13:20:54.871]                               hostname = base::Sys.info()[["nodename"]])
[13:20:54.871]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:54.871]                               info)
[13:20:54.871]                             info <- base::paste(info, collapse = "; ")
[13:20:54.871]                             if (!has_future) {
[13:20:54.871]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:54.871]                                 info)
[13:20:54.871]                             }
[13:20:54.871]                             else {
[13:20:54.871]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:54.871]                                 info, version)
[13:20:54.871]                             }
[13:20:54.871]                             base::stop(msg)
[13:20:54.871]                           }
[13:20:54.871]                         })
[13:20:54.871]                       }
[13:20:54.871]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:54.871]                       base::options(mc.cores = 1L)
[13:20:54.871]                     }
[13:20:54.871]                     base::local({
[13:20:54.871]                       for (pkg in "future") {
[13:20:54.871]                         base::loadNamespace(pkg)
[13:20:54.871]                         base::library(pkg, character.only = TRUE)
[13:20:54.871]                       }
[13:20:54.871]                     })
[13:20:54.871]                   }
[13:20:54.871]                   options(future.plan = NULL)
[13:20:54.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:54.871]                 }
[13:20:54.871]                 ...future.workdir <- getwd()
[13:20:54.871]             }
[13:20:54.871]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:54.871]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:54.871]         }
[13:20:54.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:54.871]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:54.871]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:54.871]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:54.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:54.871]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:54.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:54.871]             base::names(...future.oldOptions))
[13:20:54.871]     }
[13:20:54.871]     if (FALSE) {
[13:20:54.871]     }
[13:20:54.871]     else {
[13:20:54.871]         if (TRUE) {
[13:20:54.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:54.871]                 open = "w")
[13:20:54.871]         }
[13:20:54.871]         else {
[13:20:54.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:54.871]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:54.871]         }
[13:20:54.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:54.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:54.871]             base::sink(type = "output", split = FALSE)
[13:20:54.871]             base::close(...future.stdout)
[13:20:54.871]         }, add = TRUE)
[13:20:54.871]     }
[13:20:54.871]     ...future.frame <- base::sys.nframe()
[13:20:54.871]     ...future.conditions <- base::list()
[13:20:54.871]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:54.871]     if (FALSE) {
[13:20:54.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:54.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:54.871]     }
[13:20:54.871]     ...future.result <- base::tryCatch({
[13:20:54.871]         base::withCallingHandlers({
[13:20:54.871]             ...future.value <- base::withVisible(base::local({
[13:20:54.871]                 ...future.makeSendCondition <- local({
[13:20:54.871]                   sendCondition <- NULL
[13:20:54.871]                   function(frame = 1L) {
[13:20:54.871]                     if (is.function(sendCondition)) 
[13:20:54.871]                       return(sendCondition)
[13:20:54.871]                     ns <- getNamespace("parallel")
[13:20:54.871]                     if (exists("sendData", mode = "function", 
[13:20:54.871]                       envir = ns)) {
[13:20:54.871]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:54.871]                         envir = ns)
[13:20:54.871]                       envir <- sys.frame(frame)
[13:20:54.871]                       master <- NULL
[13:20:54.871]                       while (!identical(envir, .GlobalEnv) && 
[13:20:54.871]                         !identical(envir, emptyenv())) {
[13:20:54.871]                         if (exists("master", mode = "list", envir = envir, 
[13:20:54.871]                           inherits = FALSE)) {
[13:20:54.871]                           master <- get("master", mode = "list", 
[13:20:54.871]                             envir = envir, inherits = FALSE)
[13:20:54.871]                           if (inherits(master, c("SOCKnode", 
[13:20:54.871]                             "SOCK0node"))) {
[13:20:54.871]                             sendCondition <<- function(cond) {
[13:20:54.871]                               data <- list(type = "VALUE", value = cond, 
[13:20:54.871]                                 success = TRUE)
[13:20:54.871]                               parallel_sendData(master, data)
[13:20:54.871]                             }
[13:20:54.871]                             return(sendCondition)
[13:20:54.871]                           }
[13:20:54.871]                         }
[13:20:54.871]                         frame <- frame + 1L
[13:20:54.871]                         envir <- sys.frame(frame)
[13:20:54.871]                       }
[13:20:54.871]                     }
[13:20:54.871]                     sendCondition <<- function(cond) NULL
[13:20:54.871]                   }
[13:20:54.871]                 })
[13:20:54.871]                 withCallingHandlers({
[13:20:54.871]                   value(a) + 1
[13:20:54.871]                 }, immediateCondition = function(cond) {
[13:20:54.871]                   sendCondition <- ...future.makeSendCondition()
[13:20:54.871]                   sendCondition(cond)
[13:20:54.871]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.871]                   {
[13:20:54.871]                     inherits <- base::inherits
[13:20:54.871]                     invokeRestart <- base::invokeRestart
[13:20:54.871]                     is.null <- base::is.null
[13:20:54.871]                     muffled <- FALSE
[13:20:54.871]                     if (inherits(cond, "message")) {
[13:20:54.871]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:54.871]                       if (muffled) 
[13:20:54.871]                         invokeRestart("muffleMessage")
[13:20:54.871]                     }
[13:20:54.871]                     else if (inherits(cond, "warning")) {
[13:20:54.871]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:54.871]                       if (muffled) 
[13:20:54.871]                         invokeRestart("muffleWarning")
[13:20:54.871]                     }
[13:20:54.871]                     else if (inherits(cond, "condition")) {
[13:20:54.871]                       if (!is.null(pattern)) {
[13:20:54.871]                         computeRestarts <- base::computeRestarts
[13:20:54.871]                         grepl <- base::grepl
[13:20:54.871]                         restarts <- computeRestarts(cond)
[13:20:54.871]                         for (restart in restarts) {
[13:20:54.871]                           name <- restart$name
[13:20:54.871]                           if (is.null(name)) 
[13:20:54.871]                             next
[13:20:54.871]                           if (!grepl(pattern, name)) 
[13:20:54.871]                             next
[13:20:54.871]                           invokeRestart(restart)
[13:20:54.871]                           muffled <- TRUE
[13:20:54.871]                           break
[13:20:54.871]                         }
[13:20:54.871]                       }
[13:20:54.871]                     }
[13:20:54.871]                     invisible(muffled)
[13:20:54.871]                   }
[13:20:54.871]                   muffleCondition(cond)
[13:20:54.871]                 })
[13:20:54.871]             }))
[13:20:54.871]             future::FutureResult(value = ...future.value$value, 
[13:20:54.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.871]                   ...future.rng), globalenv = if (FALSE) 
[13:20:54.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:54.871]                     ...future.globalenv.names))
[13:20:54.871]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:54.871]         }, condition = base::local({
[13:20:54.871]             c <- base::c
[13:20:54.871]             inherits <- base::inherits
[13:20:54.871]             invokeRestart <- base::invokeRestart
[13:20:54.871]             length <- base::length
[13:20:54.871]             list <- base::list
[13:20:54.871]             seq.int <- base::seq.int
[13:20:54.871]             signalCondition <- base::signalCondition
[13:20:54.871]             sys.calls <- base::sys.calls
[13:20:54.871]             `[[` <- base::`[[`
[13:20:54.871]             `+` <- base::`+`
[13:20:54.871]             `<<-` <- base::`<<-`
[13:20:54.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:54.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:54.871]                   3L)]
[13:20:54.871]             }
[13:20:54.871]             function(cond) {
[13:20:54.871]                 is_error <- inherits(cond, "error")
[13:20:54.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:54.871]                   NULL)
[13:20:54.871]                 if (is_error) {
[13:20:54.871]                   sessionInformation <- function() {
[13:20:54.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:54.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:54.871]                       search = base::search(), system = base::Sys.info())
[13:20:54.871]                   }
[13:20:54.871]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:54.871]                     cond$call), session = sessionInformation(), 
[13:20:54.871]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:54.871]                   signalCondition(cond)
[13:20:54.871]                 }
[13:20:54.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:54.871]                 "immediateCondition"))) {
[13:20:54.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:54.871]                   ...future.conditions[[length(...future.conditions) + 
[13:20:54.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:54.871]                   if (TRUE && !signal) {
[13:20:54.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.871]                     {
[13:20:54.871]                       inherits <- base::inherits
[13:20:54.871]                       invokeRestart <- base::invokeRestart
[13:20:54.871]                       is.null <- base::is.null
[13:20:54.871]                       muffled <- FALSE
[13:20:54.871]                       if (inherits(cond, "message")) {
[13:20:54.871]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.871]                         if (muffled) 
[13:20:54.871]                           invokeRestart("muffleMessage")
[13:20:54.871]                       }
[13:20:54.871]                       else if (inherits(cond, "warning")) {
[13:20:54.871]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.871]                         if (muffled) 
[13:20:54.871]                           invokeRestart("muffleWarning")
[13:20:54.871]                       }
[13:20:54.871]                       else if (inherits(cond, "condition")) {
[13:20:54.871]                         if (!is.null(pattern)) {
[13:20:54.871]                           computeRestarts <- base::computeRestarts
[13:20:54.871]                           grepl <- base::grepl
[13:20:54.871]                           restarts <- computeRestarts(cond)
[13:20:54.871]                           for (restart in restarts) {
[13:20:54.871]                             name <- restart$name
[13:20:54.871]                             if (is.null(name)) 
[13:20:54.871]                               next
[13:20:54.871]                             if (!grepl(pattern, name)) 
[13:20:54.871]                               next
[13:20:54.871]                             invokeRestart(restart)
[13:20:54.871]                             muffled <- TRUE
[13:20:54.871]                             break
[13:20:54.871]                           }
[13:20:54.871]                         }
[13:20:54.871]                       }
[13:20:54.871]                       invisible(muffled)
[13:20:54.871]                     }
[13:20:54.871]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.871]                   }
[13:20:54.871]                 }
[13:20:54.871]                 else {
[13:20:54.871]                   if (TRUE) {
[13:20:54.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:54.871]                     {
[13:20:54.871]                       inherits <- base::inherits
[13:20:54.871]                       invokeRestart <- base::invokeRestart
[13:20:54.871]                       is.null <- base::is.null
[13:20:54.871]                       muffled <- FALSE
[13:20:54.871]                       if (inherits(cond, "message")) {
[13:20:54.871]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:54.871]                         if (muffled) 
[13:20:54.871]                           invokeRestart("muffleMessage")
[13:20:54.871]                       }
[13:20:54.871]                       else if (inherits(cond, "warning")) {
[13:20:54.871]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:54.871]                         if (muffled) 
[13:20:54.871]                           invokeRestart("muffleWarning")
[13:20:54.871]                       }
[13:20:54.871]                       else if (inherits(cond, "condition")) {
[13:20:54.871]                         if (!is.null(pattern)) {
[13:20:54.871]                           computeRestarts <- base::computeRestarts
[13:20:54.871]                           grepl <- base::grepl
[13:20:54.871]                           restarts <- computeRestarts(cond)
[13:20:54.871]                           for (restart in restarts) {
[13:20:54.871]                             name <- restart$name
[13:20:54.871]                             if (is.null(name)) 
[13:20:54.871]                               next
[13:20:54.871]                             if (!grepl(pattern, name)) 
[13:20:54.871]                               next
[13:20:54.871]                             invokeRestart(restart)
[13:20:54.871]                             muffled <- TRUE
[13:20:54.871]                             break
[13:20:54.871]                           }
[13:20:54.871]                         }
[13:20:54.871]                       }
[13:20:54.871]                       invisible(muffled)
[13:20:54.871]                     }
[13:20:54.871]                     muffleCondition(cond, pattern = "^muffle")
[13:20:54.871]                   }
[13:20:54.871]                 }
[13:20:54.871]             }
[13:20:54.871]         }))
[13:20:54.871]     }, error = function(ex) {
[13:20:54.871]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:54.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:54.871]                 ...future.rng), started = ...future.startTime, 
[13:20:54.871]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:54.871]             version = "1.8"), class = "FutureResult")
[13:20:54.871]     }, finally = {
[13:20:54.871]         if (!identical(...future.workdir, getwd())) 
[13:20:54.871]             setwd(...future.workdir)
[13:20:54.871]         {
[13:20:54.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:54.871]                 ...future.oldOptions$nwarnings <- NULL
[13:20:54.871]             }
[13:20:54.871]             base::options(...future.oldOptions)
[13:20:54.871]             if (.Platform$OS.type == "windows") {
[13:20:54.871]                 old_names <- names(...future.oldEnvVars)
[13:20:54.871]                 envs <- base::Sys.getenv()
[13:20:54.871]                 names <- names(envs)
[13:20:54.871]                 common <- intersect(names, old_names)
[13:20:54.871]                 added <- setdiff(names, old_names)
[13:20:54.871]                 removed <- setdiff(old_names, names)
[13:20:54.871]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:54.871]                   envs[common]]
[13:20:54.871]                 NAMES <- toupper(changed)
[13:20:54.871]                 args <- list()
[13:20:54.871]                 for (kk in seq_along(NAMES)) {
[13:20:54.871]                   name <- changed[[kk]]
[13:20:54.871]                   NAME <- NAMES[[kk]]
[13:20:54.871]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.871]                     next
[13:20:54.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.871]                 }
[13:20:54.871]                 NAMES <- toupper(added)
[13:20:54.871]                 for (kk in seq_along(NAMES)) {
[13:20:54.871]                   name <- added[[kk]]
[13:20:54.871]                   NAME <- NAMES[[kk]]
[13:20:54.871]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.871]                     next
[13:20:54.871]                   args[[name]] <- ""
[13:20:54.871]                 }
[13:20:54.871]                 NAMES <- toupper(removed)
[13:20:54.871]                 for (kk in seq_along(NAMES)) {
[13:20:54.871]                   name <- removed[[kk]]
[13:20:54.871]                   NAME <- NAMES[[kk]]
[13:20:54.871]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:54.871]                     next
[13:20:54.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:54.871]                 }
[13:20:54.871]                 if (length(args) > 0) 
[13:20:54.871]                   base::do.call(base::Sys.setenv, args = args)
[13:20:54.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:54.871]             }
[13:20:54.871]             else {
[13:20:54.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:54.871]             }
[13:20:54.871]             {
[13:20:54.871]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:54.871]                   0L) {
[13:20:54.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:54.871]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:54.871]                   base::options(opts)
[13:20:54.871]                 }
[13:20:54.871]                 {
[13:20:54.871]                   {
[13:20:54.871]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:54.871]                     NULL
[13:20:54.871]                   }
[13:20:54.871]                   options(future.plan = NULL)
[13:20:54.871]                   if (is.na(NA_character_)) 
[13:20:54.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:54.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:54.871]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:54.871]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:54.871]                     envir = parent.frame()) 
[13:20:54.871]                   {
[13:20:54.871]                     if (is.function(workers)) 
[13:20:54.871]                       workers <- workers()
[13:20:54.871]                     workers <- structure(as.integer(workers), 
[13:20:54.871]                       class = class(workers))
[13:20:54.871]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:54.871]                       workers >= 1)
[13:20:54.871]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:54.871]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:54.871]                     }
[13:20:54.871]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:54.871]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:54.871]                       envir = envir)
[13:20:54.871]                     if (!future$lazy) 
[13:20:54.871]                       future <- run(future)
[13:20:54.871]                     invisible(future)
[13:20:54.871]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:54.871]                 }
[13:20:54.871]             }
[13:20:54.871]         }
[13:20:54.871]     })
[13:20:54.871]     if (TRUE) {
[13:20:54.871]         base::sink(type = "output", split = FALSE)
[13:20:54.871]         if (TRUE) {
[13:20:54.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:54.871]         }
[13:20:54.871]         else {
[13:20:54.871]             ...future.result["stdout"] <- base::list(NULL)
[13:20:54.871]         }
[13:20:54.871]         base::close(...future.stdout)
[13:20:54.871]         ...future.stdout <- NULL
[13:20:54.871]     }
[13:20:54.871]     ...future.result$conditions <- ...future.conditions
[13:20:54.871]     ...future.result$finished <- base::Sys.time()
[13:20:54.871]     ...future.result
[13:20:54.871] }
[13:20:54.874] Exporting 1 global objects (1.55 MiB) to cluster node #1 ...
[13:20:54.876] Exporting ‘a’ (1.55 MiB) to cluster node #1 ...
[13:20:54.929] Exporting ‘a’ (1.55 MiB) to cluster node #1 ... DONE
[13:20:54.929] Exporting 1 global objects (1.55 MiB) to cluster node #1 ... DONE
[13:20:54.930] MultisessionFuture started
[13:20:54.930] - Launch lazy future ... done
[13:20:54.930] run() for ‘MultisessionFuture’ ... done
[13:20:54.930] result() for ClusterFuture ...
[13:20:54.930] receiveMessageFromWorker() for ClusterFuture ...
[13:20:54.930] - Validating connection of MultisessionFuture
[13:20:54.978] - received message: FutureResult
[13:20:54.978] - Received FutureResult
[13:20:54.979] - Erased future from FutureRegistry
[13:20:54.979] result() for ClusterFuture ...
[13:20:54.979] - result already collected: FutureResult
[13:20:54.979] result() for ClusterFuture ... done
[13:20:54.979] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:54.979] result() for ClusterFuture ... done
[13:20:54.979] result() for ClusterFuture ...
[13:20:54.979] - result already collected: FutureResult
[13:20:54.979] result() for ClusterFuture ... done
value(b) = 2
[13:20:54.979] result() for ClusterFuture ...
[13:20:54.980] - result already collected: FutureResult
[13:20:54.980] result() for ClusterFuture ... done
[13:20:54.980] result() for ClusterFuture ...
[13:20:54.980] - result already collected: FutureResult
[13:20:54.980] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:54.980] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:54.980] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:54.981] 
[13:20:54.981] Searching for globals ... DONE
[13:20:54.981] - globals: [0] <none>
[13:20:54.981] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:54.981] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:54.982] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:54.982] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:54.982] Searching for globals ... DONE
[13:20:54.983] Resolving globals: TRUE
[13:20:54.983] Resolving any globals that are futures ...
[13:20:54.983] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:54.983] Resolving any globals that are futures ... DONE
[13:20:54.983] Resolving futures part of globals (recursively) ...
[13:20:54.983] resolve() on list ...
[13:20:54.983]  recursive: 99
[13:20:54.984]  length: 1
[13:20:54.984]  elements: ‘a’
[13:20:54.984] run() for ‘Future’ ...
[13:20:54.984] - state: ‘created’
[13:20:54.984] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:54.999] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:54.999] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:55.000]   - Field: ‘node’
[13:20:55.000]   - Field: ‘label’
[13:20:55.000]   - Field: ‘local’
[13:20:55.000]   - Field: ‘owner’
[13:20:55.000]   - Field: ‘envir’
[13:20:55.000]   - Field: ‘workers’
[13:20:55.000]   - Field: ‘packages’
[13:20:55.000]   - Field: ‘gc’
[13:20:55.000]   - Field: ‘conditions’
[13:20:55.000]   - Field: ‘persistent’
[13:20:55.001]   - Field: ‘expr’
[13:20:55.001]   - Field: ‘uuid’
[13:20:55.001]   - Field: ‘seed’
[13:20:55.001]   - Field: ‘version’
[13:20:55.001]   - Field: ‘result’
[13:20:55.001]   - Field: ‘asynchronous’
[13:20:55.001]   - Field: ‘calls’
[13:20:55.001]   - Field: ‘globals’
[13:20:55.001]   - Field: ‘stdout’
[13:20:55.001]   - Field: ‘earlySignal’
[13:20:55.002]   - Field: ‘lazy’
[13:20:55.002]   - Field: ‘state’
[13:20:55.002] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:55.002] - Launch lazy future ...
[13:20:55.002] Packages needed by the future expression (n = 0): <none>
[13:20:55.002] Packages needed by future strategies (n = 0): <none>
[13:20:55.003] {
[13:20:55.003]     {
[13:20:55.003]         {
[13:20:55.003]             ...future.startTime <- base::Sys.time()
[13:20:55.003]             {
[13:20:55.003]                 {
[13:20:55.003]                   {
[13:20:55.003]                     {
[13:20:55.003]                       base::local({
[13:20:55.003]                         has_future <- base::requireNamespace("future", 
[13:20:55.003]                           quietly = TRUE)
[13:20:55.003]                         if (has_future) {
[13:20:55.003]                           ns <- base::getNamespace("future")
[13:20:55.003]                           version <- ns[[".package"]][["version"]]
[13:20:55.003]                           if (is.null(version)) 
[13:20:55.003]                             version <- utils::packageVersion("future")
[13:20:55.003]                         }
[13:20:55.003]                         else {
[13:20:55.003]                           version <- NULL
[13:20:55.003]                         }
[13:20:55.003]                         if (!has_future || version < "1.8.0") {
[13:20:55.003]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:55.003]                             "", base::R.version$version.string), 
[13:20:55.003]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:55.003]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:55.003]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:55.003]                               "release", "version")], collapse = " "), 
[13:20:55.003]                             hostname = base::Sys.info()[["nodename"]])
[13:20:55.003]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:55.003]                             info)
[13:20:55.003]                           info <- base::paste(info, collapse = "; ")
[13:20:55.003]                           if (!has_future) {
[13:20:55.003]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:55.003]                               info)
[13:20:55.003]                           }
[13:20:55.003]                           else {
[13:20:55.003]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:55.003]                               info, version)
[13:20:55.003]                           }
[13:20:55.003]                           base::stop(msg)
[13:20:55.003]                         }
[13:20:55.003]                       })
[13:20:55.003]                     }
[13:20:55.003]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:55.003]                     base::options(mc.cores = 1L)
[13:20:55.003]                   }
[13:20:55.003]                   options(future.plan = NULL)
[13:20:55.003]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:55.003]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:55.003]                 }
[13:20:55.003]                 ...future.workdir <- getwd()
[13:20:55.003]             }
[13:20:55.003]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:55.003]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:55.003]         }
[13:20:55.003]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:55.003]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:55.003]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:55.003]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:55.003]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:55.003]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:55.003]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:55.003]             base::names(...future.oldOptions))
[13:20:55.003]     }
[13:20:55.003]     if (FALSE) {
[13:20:55.003]     }
[13:20:55.003]     else {
[13:20:55.003]         if (TRUE) {
[13:20:55.003]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:55.003]                 open = "w")
[13:20:55.003]         }
[13:20:55.003]         else {
[13:20:55.003]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:55.003]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:55.003]         }
[13:20:55.003]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:55.003]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:55.003]             base::sink(type = "output", split = FALSE)
[13:20:55.003]             base::close(...future.stdout)
[13:20:55.003]         }, add = TRUE)
[13:20:55.003]     }
[13:20:55.003]     ...future.frame <- base::sys.nframe()
[13:20:55.003]     ...future.conditions <- base::list()
[13:20:55.003]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:55.003]     if (FALSE) {
[13:20:55.003]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:55.003]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:55.003]     }
[13:20:55.003]     ...future.result <- base::tryCatch({
[13:20:55.003]         base::withCallingHandlers({
[13:20:55.003]             ...future.value <- base::withVisible(base::local({
[13:20:55.003]                 ...future.makeSendCondition <- local({
[13:20:55.003]                   sendCondition <- NULL
[13:20:55.003]                   function(frame = 1L) {
[13:20:55.003]                     if (is.function(sendCondition)) 
[13:20:55.003]                       return(sendCondition)
[13:20:55.003]                     ns <- getNamespace("parallel")
[13:20:55.003]                     if (exists("sendData", mode = "function", 
[13:20:55.003]                       envir = ns)) {
[13:20:55.003]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:55.003]                         envir = ns)
[13:20:55.003]                       envir <- sys.frame(frame)
[13:20:55.003]                       master <- NULL
[13:20:55.003]                       while (!identical(envir, .GlobalEnv) && 
[13:20:55.003]                         !identical(envir, emptyenv())) {
[13:20:55.003]                         if (exists("master", mode = "list", envir = envir, 
[13:20:55.003]                           inherits = FALSE)) {
[13:20:55.003]                           master <- get("master", mode = "list", 
[13:20:55.003]                             envir = envir, inherits = FALSE)
[13:20:55.003]                           if (inherits(master, c("SOCKnode", 
[13:20:55.003]                             "SOCK0node"))) {
[13:20:55.003]                             sendCondition <<- function(cond) {
[13:20:55.003]                               data <- list(type = "VALUE", value = cond, 
[13:20:55.003]                                 success = TRUE)
[13:20:55.003]                               parallel_sendData(master, data)
[13:20:55.003]                             }
[13:20:55.003]                             return(sendCondition)
[13:20:55.003]                           }
[13:20:55.003]                         }
[13:20:55.003]                         frame <- frame + 1L
[13:20:55.003]                         envir <- sys.frame(frame)
[13:20:55.003]                       }
[13:20:55.003]                     }
[13:20:55.003]                     sendCondition <<- function(cond) NULL
[13:20:55.003]                   }
[13:20:55.003]                 })
[13:20:55.003]                 withCallingHandlers({
[13:20:55.003]                   1
[13:20:55.003]                 }, immediateCondition = function(cond) {
[13:20:55.003]                   sendCondition <- ...future.makeSendCondition()
[13:20:55.003]                   sendCondition(cond)
[13:20:55.003]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.003]                   {
[13:20:55.003]                     inherits <- base::inherits
[13:20:55.003]                     invokeRestart <- base::invokeRestart
[13:20:55.003]                     is.null <- base::is.null
[13:20:55.003]                     muffled <- FALSE
[13:20:55.003]                     if (inherits(cond, "message")) {
[13:20:55.003]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:55.003]                       if (muffled) 
[13:20:55.003]                         invokeRestart("muffleMessage")
[13:20:55.003]                     }
[13:20:55.003]                     else if (inherits(cond, "warning")) {
[13:20:55.003]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:55.003]                       if (muffled) 
[13:20:55.003]                         invokeRestart("muffleWarning")
[13:20:55.003]                     }
[13:20:55.003]                     else if (inherits(cond, "condition")) {
[13:20:55.003]                       if (!is.null(pattern)) {
[13:20:55.003]                         computeRestarts <- base::computeRestarts
[13:20:55.003]                         grepl <- base::grepl
[13:20:55.003]                         restarts <- computeRestarts(cond)
[13:20:55.003]                         for (restart in restarts) {
[13:20:55.003]                           name <- restart$name
[13:20:55.003]                           if (is.null(name)) 
[13:20:55.003]                             next
[13:20:55.003]                           if (!grepl(pattern, name)) 
[13:20:55.003]                             next
[13:20:55.003]                           invokeRestart(restart)
[13:20:55.003]                           muffled <- TRUE
[13:20:55.003]                           break
[13:20:55.003]                         }
[13:20:55.003]                       }
[13:20:55.003]                     }
[13:20:55.003]                     invisible(muffled)
[13:20:55.003]                   }
[13:20:55.003]                   muffleCondition(cond)
[13:20:55.003]                 })
[13:20:55.003]             }))
[13:20:55.003]             future::FutureResult(value = ...future.value$value, 
[13:20:55.003]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:55.003]                   ...future.rng), globalenv = if (FALSE) 
[13:20:55.003]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:55.003]                     ...future.globalenv.names))
[13:20:55.003]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:55.003]         }, condition = base::local({
[13:20:55.003]             c <- base::c
[13:20:55.003]             inherits <- base::inherits
[13:20:55.003]             invokeRestart <- base::invokeRestart
[13:20:55.003]             length <- base::length
[13:20:55.003]             list <- base::list
[13:20:55.003]             seq.int <- base::seq.int
[13:20:55.003]             signalCondition <- base::signalCondition
[13:20:55.003]             sys.calls <- base::sys.calls
[13:20:55.003]             `[[` <- base::`[[`
[13:20:55.003]             `+` <- base::`+`
[13:20:55.003]             `<<-` <- base::`<<-`
[13:20:55.003]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:55.003]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:55.003]                   3L)]
[13:20:55.003]             }
[13:20:55.003]             function(cond) {
[13:20:55.003]                 is_error <- inherits(cond, "error")
[13:20:55.003]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:55.003]                   NULL)
[13:20:55.003]                 if (is_error) {
[13:20:55.003]                   sessionInformation <- function() {
[13:20:55.003]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:55.003]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:55.003]                       search = base::search(), system = base::Sys.info())
[13:20:55.003]                   }
[13:20:55.003]                   ...future.conditions[[length(...future.conditions) + 
[13:20:55.003]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:55.003]                     cond$call), session = sessionInformation(), 
[13:20:55.003]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:55.003]                   signalCondition(cond)
[13:20:55.003]                 }
[13:20:55.003]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:55.003]                 "immediateCondition"))) {
[13:20:55.003]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:55.003]                   ...future.conditions[[length(...future.conditions) + 
[13:20:55.003]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:55.003]                   if (TRUE && !signal) {
[13:20:55.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.003]                     {
[13:20:55.003]                       inherits <- base::inherits
[13:20:55.003]                       invokeRestart <- base::invokeRestart
[13:20:55.003]                       is.null <- base::is.null
[13:20:55.003]                       muffled <- FALSE
[13:20:55.003]                       if (inherits(cond, "message")) {
[13:20:55.003]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:55.003]                         if (muffled) 
[13:20:55.003]                           invokeRestart("muffleMessage")
[13:20:55.003]                       }
[13:20:55.003]                       else if (inherits(cond, "warning")) {
[13:20:55.003]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:55.003]                         if (muffled) 
[13:20:55.003]                           invokeRestart("muffleWarning")
[13:20:55.003]                       }
[13:20:55.003]                       else if (inherits(cond, "condition")) {
[13:20:55.003]                         if (!is.null(pattern)) {
[13:20:55.003]                           computeRestarts <- base::computeRestarts
[13:20:55.003]                           grepl <- base::grepl
[13:20:55.003]                           restarts <- computeRestarts(cond)
[13:20:55.003]                           for (restart in restarts) {
[13:20:55.003]                             name <- restart$name
[13:20:55.003]                             if (is.null(name)) 
[13:20:55.003]                               next
[13:20:55.003]                             if (!grepl(pattern, name)) 
[13:20:55.003]                               next
[13:20:55.003]                             invokeRestart(restart)
[13:20:55.003]                             muffled <- TRUE
[13:20:55.003]                             break
[13:20:55.003]                           }
[13:20:55.003]                         }
[13:20:55.003]                       }
[13:20:55.003]                       invisible(muffled)
[13:20:55.003]                     }
[13:20:55.003]                     muffleCondition(cond, pattern = "^muffle")
[13:20:55.003]                   }
[13:20:55.003]                 }
[13:20:55.003]                 else {
[13:20:55.003]                   if (TRUE) {
[13:20:55.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.003]                     {
[13:20:55.003]                       inherits <- base::inherits
[13:20:55.003]                       invokeRestart <- base::invokeRestart
[13:20:55.003]                       is.null <- base::is.null
[13:20:55.003]                       muffled <- FALSE
[13:20:55.003]                       if (inherits(cond, "message")) {
[13:20:55.003]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:55.003]                         if (muffled) 
[13:20:55.003]                           invokeRestart("muffleMessage")
[13:20:55.003]                       }
[13:20:55.003]                       else if (inherits(cond, "warning")) {
[13:20:55.003]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:55.003]                         if (muffled) 
[13:20:55.003]                           invokeRestart("muffleWarning")
[13:20:55.003]                       }
[13:20:55.003]                       else if (inherits(cond, "condition")) {
[13:20:55.003]                         if (!is.null(pattern)) {
[13:20:55.003]                           computeRestarts <- base::computeRestarts
[13:20:55.003]                           grepl <- base::grepl
[13:20:55.003]                           restarts <- computeRestarts(cond)
[13:20:55.003]                           for (restart in restarts) {
[13:20:55.003]                             name <- restart$name
[13:20:55.003]                             if (is.null(name)) 
[13:20:55.003]                               next
[13:20:55.003]                             if (!grepl(pattern, name)) 
[13:20:55.003]                               next
[13:20:55.003]                             invokeRestart(restart)
[13:20:55.003]                             muffled <- TRUE
[13:20:55.003]                             break
[13:20:55.003]                           }
[13:20:55.003]                         }
[13:20:55.003]                       }
[13:20:55.003]                       invisible(muffled)
[13:20:55.003]                     }
[13:20:55.003]                     muffleCondition(cond, pattern = "^muffle")
[13:20:55.003]                   }
[13:20:55.003]                 }
[13:20:55.003]             }
[13:20:55.003]         }))
[13:20:55.003]     }, error = function(ex) {
[13:20:55.003]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:55.003]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:55.003]                 ...future.rng), started = ...future.startTime, 
[13:20:55.003]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:55.003]             version = "1.8"), class = "FutureResult")
[13:20:55.003]     }, finally = {
[13:20:55.003]         if (!identical(...future.workdir, getwd())) 
[13:20:55.003]             setwd(...future.workdir)
[13:20:55.003]         {
[13:20:55.003]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:55.003]                 ...future.oldOptions$nwarnings <- NULL
[13:20:55.003]             }
[13:20:55.003]             base::options(...future.oldOptions)
[13:20:55.003]             if (.Platform$OS.type == "windows") {
[13:20:55.003]                 old_names <- names(...future.oldEnvVars)
[13:20:55.003]                 envs <- base::Sys.getenv()
[13:20:55.003]                 names <- names(envs)
[13:20:55.003]                 common <- intersect(names, old_names)
[13:20:55.003]                 added <- setdiff(names, old_names)
[13:20:55.003]                 removed <- setdiff(old_names, names)
[13:20:55.003]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:55.003]                   envs[common]]
[13:20:55.003]                 NAMES <- toupper(changed)
[13:20:55.003]                 args <- list()
[13:20:55.003]                 for (kk in seq_along(NAMES)) {
[13:20:55.003]                   name <- changed[[kk]]
[13:20:55.003]                   NAME <- NAMES[[kk]]
[13:20:55.003]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.003]                     next
[13:20:55.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:55.003]                 }
[13:20:55.003]                 NAMES <- toupper(added)
[13:20:55.003]                 for (kk in seq_along(NAMES)) {
[13:20:55.003]                   name <- added[[kk]]
[13:20:55.003]                   NAME <- NAMES[[kk]]
[13:20:55.003]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.003]                     next
[13:20:55.003]                   args[[name]] <- ""
[13:20:55.003]                 }
[13:20:55.003]                 NAMES <- toupper(removed)
[13:20:55.003]                 for (kk in seq_along(NAMES)) {
[13:20:55.003]                   name <- removed[[kk]]
[13:20:55.003]                   NAME <- NAMES[[kk]]
[13:20:55.003]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.003]                     next
[13:20:55.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:55.003]                 }
[13:20:55.003]                 if (length(args) > 0) 
[13:20:55.003]                   base::do.call(base::Sys.setenv, args = args)
[13:20:55.003]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:55.003]             }
[13:20:55.003]             else {
[13:20:55.003]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:55.003]             }
[13:20:55.003]             {
[13:20:55.003]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:55.003]                   0L) {
[13:20:55.003]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:55.003]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:55.003]                   base::options(opts)
[13:20:55.003]                 }
[13:20:55.003]                 {
[13:20:55.003]                   {
[13:20:55.003]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:55.003]                     NULL
[13:20:55.003]                   }
[13:20:55.003]                   options(future.plan = NULL)
[13:20:55.003]                   if (is.na(NA_character_)) 
[13:20:55.003]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:55.003]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:55.003]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:55.003]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:55.003]                     envir = parent.frame()) 
[13:20:55.003]                   {
[13:20:55.003]                     if (is.function(workers)) 
[13:20:55.003]                       workers <- workers()
[13:20:55.003]                     workers <- structure(as.integer(workers), 
[13:20:55.003]                       class = class(workers))
[13:20:55.003]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:55.003]                       workers >= 1)
[13:20:55.003]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:55.003]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:55.003]                     }
[13:20:55.003]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:55.003]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:55.003]                       envir = envir)
[13:20:55.003]                     if (!future$lazy) 
[13:20:55.003]                       future <- run(future)
[13:20:55.003]                     invisible(future)
[13:20:55.003]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:55.003]                 }
[13:20:55.003]             }
[13:20:55.003]         }
[13:20:55.003]     })
[13:20:55.003]     if (TRUE) {
[13:20:55.003]         base::sink(type = "output", split = FALSE)
[13:20:55.003]         if (TRUE) {
[13:20:55.003]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:55.003]         }
[13:20:55.003]         else {
[13:20:55.003]             ...future.result["stdout"] <- base::list(NULL)
[13:20:55.003]         }
[13:20:55.003]         base::close(...future.stdout)
[13:20:55.003]         ...future.stdout <- NULL
[13:20:55.003]     }
[13:20:55.003]     ...future.result$conditions <- ...future.conditions
[13:20:55.003]     ...future.result$finished <- base::Sys.time()
[13:20:55.003]     ...future.result
[13:20:55.003] }
[13:20:55.006] MultisessionFuture started
[13:20:55.006] - Launch lazy future ... done
[13:20:55.006] run() for ‘MultisessionFuture’ ... done
[13:20:55.053] receiveMessageFromWorker() for ClusterFuture ...
[13:20:55.054] - Validating connection of MultisessionFuture
[13:20:55.054] - received message: FutureResult
[13:20:55.054] - Received FutureResult
[13:20:55.054] - Erased future from FutureRegistry
[13:20:55.054] result() for ClusterFuture ...
[13:20:55.054] - result already collected: FutureResult
[13:20:55.054] result() for ClusterFuture ... done
[13:20:55.055] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:55.055] Future #1
[13:20:55.055] result() for ClusterFuture ...
[13:20:55.055] - result already collected: FutureResult
[13:20:55.055] result() for ClusterFuture ... done
[13:20:55.055] result() for ClusterFuture ...
[13:20:55.055] - result already collected: FutureResult
[13:20:55.055] result() for ClusterFuture ... done
[13:20:55.055] A MultisessionFuture was resolved
[13:20:55.055]  length: 0 (resolved future 1)
[13:20:55.056] resolve() on list ... DONE
[13:20:55.056] - globals: [1] ‘a’
[13:20:55.056] Resolving futures part of globals (recursively) ... DONE
[13:20:55.058] The total size of the 1 globals is 1.55 MiB (1629664 bytes)
[13:20:55.058] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[13:20:55.058] - globals: [1] ‘a’
[13:20:55.058] - packages: [1] ‘future’
[13:20:55.059] getGlobalsAndPackages() ... DONE
[13:20:55.059] run() for ‘Future’ ...
[13:20:55.059] - state: ‘created’
[13:20:55.059] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:55.073] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:55.073] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:55.073]   - Field: ‘node’
[13:20:55.074]   - Field: ‘label’
[13:20:55.074]   - Field: ‘local’
[13:20:55.074]   - Field: ‘owner’
[13:20:55.074]   - Field: ‘envir’
[13:20:55.074]   - Field: ‘workers’
[13:20:55.074]   - Field: ‘packages’
[13:20:55.074]   - Field: ‘gc’
[13:20:55.074]   - Field: ‘conditions’
[13:20:55.074]   - Field: ‘persistent’
[13:20:55.074]   - Field: ‘expr’
[13:20:55.075]   - Field: ‘uuid’
[13:20:55.075]   - Field: ‘seed’
[13:20:55.075]   - Field: ‘version’
[13:20:55.075]   - Field: ‘result’
[13:20:55.075]   - Field: ‘asynchronous’
[13:20:55.075]   - Field: ‘calls’
[13:20:55.075]   - Field: ‘globals’
[13:20:55.075]   - Field: ‘stdout’
[13:20:55.075]   - Field: ‘earlySignal’
[13:20:55.075]   - Field: ‘lazy’
[13:20:55.075]   - Field: ‘state’
[13:20:55.076] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:55.076] - Launch lazy future ...
[13:20:55.076] Packages needed by the future expression (n = 1): ‘future’
[13:20:55.076] Packages needed by future strategies (n = 0): <none>
[13:20:55.077] {
[13:20:55.077]     {
[13:20:55.077]         {
[13:20:55.077]             ...future.startTime <- base::Sys.time()
[13:20:55.077]             {
[13:20:55.077]                 {
[13:20:55.077]                   {
[13:20:55.077]                     {
[13:20:55.077]                       {
[13:20:55.077]                         base::local({
[13:20:55.077]                           has_future <- base::requireNamespace("future", 
[13:20:55.077]                             quietly = TRUE)
[13:20:55.077]                           if (has_future) {
[13:20:55.077]                             ns <- base::getNamespace("future")
[13:20:55.077]                             version <- ns[[".package"]][["version"]]
[13:20:55.077]                             if (is.null(version)) 
[13:20:55.077]                               version <- utils::packageVersion("future")
[13:20:55.077]                           }
[13:20:55.077]                           else {
[13:20:55.077]                             version <- NULL
[13:20:55.077]                           }
[13:20:55.077]                           if (!has_future || version < "1.8.0") {
[13:20:55.077]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:55.077]                               "", base::R.version$version.string), 
[13:20:55.077]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:55.077]                                 base::R.version$platform, 8 * 
[13:20:55.077]                                   base::.Machine$sizeof.pointer), 
[13:20:55.077]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:55.077]                                 "release", "version")], collapse = " "), 
[13:20:55.077]                               hostname = base::Sys.info()[["nodename"]])
[13:20:55.077]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:55.077]                               info)
[13:20:55.077]                             info <- base::paste(info, collapse = "; ")
[13:20:55.077]                             if (!has_future) {
[13:20:55.077]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:55.077]                                 info)
[13:20:55.077]                             }
[13:20:55.077]                             else {
[13:20:55.077]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:55.077]                                 info, version)
[13:20:55.077]                             }
[13:20:55.077]                             base::stop(msg)
[13:20:55.077]                           }
[13:20:55.077]                         })
[13:20:55.077]                       }
[13:20:55.077]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:55.077]                       base::options(mc.cores = 1L)
[13:20:55.077]                     }
[13:20:55.077]                     base::local({
[13:20:55.077]                       for (pkg in "future") {
[13:20:55.077]                         base::loadNamespace(pkg)
[13:20:55.077]                         base::library(pkg, character.only = TRUE)
[13:20:55.077]                       }
[13:20:55.077]                     })
[13:20:55.077]                   }
[13:20:55.077]                   options(future.plan = NULL)
[13:20:55.077]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:55.077]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:55.077]                 }
[13:20:55.077]                 ...future.workdir <- getwd()
[13:20:55.077]             }
[13:20:55.077]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:55.077]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:55.077]         }
[13:20:55.077]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:55.077]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:55.077]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:55.077]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:55.077]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:55.077]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:55.077]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:55.077]             base::names(...future.oldOptions))
[13:20:55.077]     }
[13:20:55.077]     if (FALSE) {
[13:20:55.077]     }
[13:20:55.077]     else {
[13:20:55.077]         if (TRUE) {
[13:20:55.077]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:55.077]                 open = "w")
[13:20:55.077]         }
[13:20:55.077]         else {
[13:20:55.077]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:55.077]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:55.077]         }
[13:20:55.077]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:55.077]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:55.077]             base::sink(type = "output", split = FALSE)
[13:20:55.077]             base::close(...future.stdout)
[13:20:55.077]         }, add = TRUE)
[13:20:55.077]     }
[13:20:55.077]     ...future.frame <- base::sys.nframe()
[13:20:55.077]     ...future.conditions <- base::list()
[13:20:55.077]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:55.077]     if (FALSE) {
[13:20:55.077]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:55.077]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:55.077]     }
[13:20:55.077]     ...future.result <- base::tryCatch({
[13:20:55.077]         base::withCallingHandlers({
[13:20:55.077]             ...future.value <- base::withVisible(base::local({
[13:20:55.077]                 ...future.makeSendCondition <- local({
[13:20:55.077]                   sendCondition <- NULL
[13:20:55.077]                   function(frame = 1L) {
[13:20:55.077]                     if (is.function(sendCondition)) 
[13:20:55.077]                       return(sendCondition)
[13:20:55.077]                     ns <- getNamespace("parallel")
[13:20:55.077]                     if (exists("sendData", mode = "function", 
[13:20:55.077]                       envir = ns)) {
[13:20:55.077]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:55.077]                         envir = ns)
[13:20:55.077]                       envir <- sys.frame(frame)
[13:20:55.077]                       master <- NULL
[13:20:55.077]                       while (!identical(envir, .GlobalEnv) && 
[13:20:55.077]                         !identical(envir, emptyenv())) {
[13:20:55.077]                         if (exists("master", mode = "list", envir = envir, 
[13:20:55.077]                           inherits = FALSE)) {
[13:20:55.077]                           master <- get("master", mode = "list", 
[13:20:55.077]                             envir = envir, inherits = FALSE)
[13:20:55.077]                           if (inherits(master, c("SOCKnode", 
[13:20:55.077]                             "SOCK0node"))) {
[13:20:55.077]                             sendCondition <<- function(cond) {
[13:20:55.077]                               data <- list(type = "VALUE", value = cond, 
[13:20:55.077]                                 success = TRUE)
[13:20:55.077]                               parallel_sendData(master, data)
[13:20:55.077]                             }
[13:20:55.077]                             return(sendCondition)
[13:20:55.077]                           }
[13:20:55.077]                         }
[13:20:55.077]                         frame <- frame + 1L
[13:20:55.077]                         envir <- sys.frame(frame)
[13:20:55.077]                       }
[13:20:55.077]                     }
[13:20:55.077]                     sendCondition <<- function(cond) NULL
[13:20:55.077]                   }
[13:20:55.077]                 })
[13:20:55.077]                 withCallingHandlers({
[13:20:55.077]                   value(a) + 1
[13:20:55.077]                 }, immediateCondition = function(cond) {
[13:20:55.077]                   sendCondition <- ...future.makeSendCondition()
[13:20:55.077]                   sendCondition(cond)
[13:20:55.077]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.077]                   {
[13:20:55.077]                     inherits <- base::inherits
[13:20:55.077]                     invokeRestart <- base::invokeRestart
[13:20:55.077]                     is.null <- base::is.null
[13:20:55.077]                     muffled <- FALSE
[13:20:55.077]                     if (inherits(cond, "message")) {
[13:20:55.077]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:55.077]                       if (muffled) 
[13:20:55.077]                         invokeRestart("muffleMessage")
[13:20:55.077]                     }
[13:20:55.077]                     else if (inherits(cond, "warning")) {
[13:20:55.077]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:55.077]                       if (muffled) 
[13:20:55.077]                         invokeRestart("muffleWarning")
[13:20:55.077]                     }
[13:20:55.077]                     else if (inherits(cond, "condition")) {
[13:20:55.077]                       if (!is.null(pattern)) {
[13:20:55.077]                         computeRestarts <- base::computeRestarts
[13:20:55.077]                         grepl <- base::grepl
[13:20:55.077]                         restarts <- computeRestarts(cond)
[13:20:55.077]                         for (restart in restarts) {
[13:20:55.077]                           name <- restart$name
[13:20:55.077]                           if (is.null(name)) 
[13:20:55.077]                             next
[13:20:55.077]                           if (!grepl(pattern, name)) 
[13:20:55.077]                             next
[13:20:55.077]                           invokeRestart(restart)
[13:20:55.077]                           muffled <- TRUE
[13:20:55.077]                           break
[13:20:55.077]                         }
[13:20:55.077]                       }
[13:20:55.077]                     }
[13:20:55.077]                     invisible(muffled)
[13:20:55.077]                   }
[13:20:55.077]                   muffleCondition(cond)
[13:20:55.077]                 })
[13:20:55.077]             }))
[13:20:55.077]             future::FutureResult(value = ...future.value$value, 
[13:20:55.077]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:55.077]                   ...future.rng), globalenv = if (FALSE) 
[13:20:55.077]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:55.077]                     ...future.globalenv.names))
[13:20:55.077]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:55.077]         }, condition = base::local({
[13:20:55.077]             c <- base::c
[13:20:55.077]             inherits <- base::inherits
[13:20:55.077]             invokeRestart <- base::invokeRestart
[13:20:55.077]             length <- base::length
[13:20:55.077]             list <- base::list
[13:20:55.077]             seq.int <- base::seq.int
[13:20:55.077]             signalCondition <- base::signalCondition
[13:20:55.077]             sys.calls <- base::sys.calls
[13:20:55.077]             `[[` <- base::`[[`
[13:20:55.077]             `+` <- base::`+`
[13:20:55.077]             `<<-` <- base::`<<-`
[13:20:55.077]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:55.077]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:55.077]                   3L)]
[13:20:55.077]             }
[13:20:55.077]             function(cond) {
[13:20:55.077]                 is_error <- inherits(cond, "error")
[13:20:55.077]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:55.077]                   NULL)
[13:20:55.077]                 if (is_error) {
[13:20:55.077]                   sessionInformation <- function() {
[13:20:55.077]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:55.077]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:55.077]                       search = base::search(), system = base::Sys.info())
[13:20:55.077]                   }
[13:20:55.077]                   ...future.conditions[[length(...future.conditions) + 
[13:20:55.077]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:55.077]                     cond$call), session = sessionInformation(), 
[13:20:55.077]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:55.077]                   signalCondition(cond)
[13:20:55.077]                 }
[13:20:55.077]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:55.077]                 "immediateCondition"))) {
[13:20:55.077]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:55.077]                   ...future.conditions[[length(...future.conditions) + 
[13:20:55.077]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:55.077]                   if (TRUE && !signal) {
[13:20:55.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.077]                     {
[13:20:55.077]                       inherits <- base::inherits
[13:20:55.077]                       invokeRestart <- base::invokeRestart
[13:20:55.077]                       is.null <- base::is.null
[13:20:55.077]                       muffled <- FALSE
[13:20:55.077]                       if (inherits(cond, "message")) {
[13:20:55.077]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:55.077]                         if (muffled) 
[13:20:55.077]                           invokeRestart("muffleMessage")
[13:20:55.077]                       }
[13:20:55.077]                       else if (inherits(cond, "warning")) {
[13:20:55.077]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:55.077]                         if (muffled) 
[13:20:55.077]                           invokeRestart("muffleWarning")
[13:20:55.077]                       }
[13:20:55.077]                       else if (inherits(cond, "condition")) {
[13:20:55.077]                         if (!is.null(pattern)) {
[13:20:55.077]                           computeRestarts <- base::computeRestarts
[13:20:55.077]                           grepl <- base::grepl
[13:20:55.077]                           restarts <- computeRestarts(cond)
[13:20:55.077]                           for (restart in restarts) {
[13:20:55.077]                             name <- restart$name
[13:20:55.077]                             if (is.null(name)) 
[13:20:55.077]                               next
[13:20:55.077]                             if (!grepl(pattern, name)) 
[13:20:55.077]                               next
[13:20:55.077]                             invokeRestart(restart)
[13:20:55.077]                             muffled <- TRUE
[13:20:55.077]                             break
[13:20:55.077]                           }
[13:20:55.077]                         }
[13:20:55.077]                       }
[13:20:55.077]                       invisible(muffled)
[13:20:55.077]                     }
[13:20:55.077]                     muffleCondition(cond, pattern = "^muffle")
[13:20:55.077]                   }
[13:20:55.077]                 }
[13:20:55.077]                 else {
[13:20:55.077]                   if (TRUE) {
[13:20:55.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.077]                     {
[13:20:55.077]                       inherits <- base::inherits
[13:20:55.077]                       invokeRestart <- base::invokeRestart
[13:20:55.077]                       is.null <- base::is.null
[13:20:55.077]                       muffled <- FALSE
[13:20:55.077]                       if (inherits(cond, "message")) {
[13:20:55.077]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:55.077]                         if (muffled) 
[13:20:55.077]                           invokeRestart("muffleMessage")
[13:20:55.077]                       }
[13:20:55.077]                       else if (inherits(cond, "warning")) {
[13:20:55.077]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:55.077]                         if (muffled) 
[13:20:55.077]                           invokeRestart("muffleWarning")
[13:20:55.077]                       }
[13:20:55.077]                       else if (inherits(cond, "condition")) {
[13:20:55.077]                         if (!is.null(pattern)) {
[13:20:55.077]                           computeRestarts <- base::computeRestarts
[13:20:55.077]                           grepl <- base::grepl
[13:20:55.077]                           restarts <- computeRestarts(cond)
[13:20:55.077]                           for (restart in restarts) {
[13:20:55.077]                             name <- restart$name
[13:20:55.077]                             if (is.null(name)) 
[13:20:55.077]                               next
[13:20:55.077]                             if (!grepl(pattern, name)) 
[13:20:55.077]                               next
[13:20:55.077]                             invokeRestart(restart)
[13:20:55.077]                             muffled <- TRUE
[13:20:55.077]                             break
[13:20:55.077]                           }
[13:20:55.077]                         }
[13:20:55.077]                       }
[13:20:55.077]                       invisible(muffled)
[13:20:55.077]                     }
[13:20:55.077]                     muffleCondition(cond, pattern = "^muffle")
[13:20:55.077]                   }
[13:20:55.077]                 }
[13:20:55.077]             }
[13:20:55.077]         }))
[13:20:55.077]     }, error = function(ex) {
[13:20:55.077]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:55.077]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:55.077]                 ...future.rng), started = ...future.startTime, 
[13:20:55.077]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:55.077]             version = "1.8"), class = "FutureResult")
[13:20:55.077]     }, finally = {
[13:20:55.077]         if (!identical(...future.workdir, getwd())) 
[13:20:55.077]             setwd(...future.workdir)
[13:20:55.077]         {
[13:20:55.077]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:55.077]                 ...future.oldOptions$nwarnings <- NULL
[13:20:55.077]             }
[13:20:55.077]             base::options(...future.oldOptions)
[13:20:55.077]             if (.Platform$OS.type == "windows") {
[13:20:55.077]                 old_names <- names(...future.oldEnvVars)
[13:20:55.077]                 envs <- base::Sys.getenv()
[13:20:55.077]                 names <- names(envs)
[13:20:55.077]                 common <- intersect(names, old_names)
[13:20:55.077]                 added <- setdiff(names, old_names)
[13:20:55.077]                 removed <- setdiff(old_names, names)
[13:20:55.077]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:55.077]                   envs[common]]
[13:20:55.077]                 NAMES <- toupper(changed)
[13:20:55.077]                 args <- list()
[13:20:55.077]                 for (kk in seq_along(NAMES)) {
[13:20:55.077]                   name <- changed[[kk]]
[13:20:55.077]                   NAME <- NAMES[[kk]]
[13:20:55.077]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.077]                     next
[13:20:55.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:55.077]                 }
[13:20:55.077]                 NAMES <- toupper(added)
[13:20:55.077]                 for (kk in seq_along(NAMES)) {
[13:20:55.077]                   name <- added[[kk]]
[13:20:55.077]                   NAME <- NAMES[[kk]]
[13:20:55.077]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.077]                     next
[13:20:55.077]                   args[[name]] <- ""
[13:20:55.077]                 }
[13:20:55.077]                 NAMES <- toupper(removed)
[13:20:55.077]                 for (kk in seq_along(NAMES)) {
[13:20:55.077]                   name <- removed[[kk]]
[13:20:55.077]                   NAME <- NAMES[[kk]]
[13:20:55.077]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.077]                     next
[13:20:55.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:55.077]                 }
[13:20:55.077]                 if (length(args) > 0) 
[13:20:55.077]                   base::do.call(base::Sys.setenv, args = args)
[13:20:55.077]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:55.077]             }
[13:20:55.077]             else {
[13:20:55.077]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:55.077]             }
[13:20:55.077]             {
[13:20:55.077]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:55.077]                   0L) {
[13:20:55.077]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:55.077]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:55.077]                   base::options(opts)
[13:20:55.077]                 }
[13:20:55.077]                 {
[13:20:55.077]                   {
[13:20:55.077]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:55.077]                     NULL
[13:20:55.077]                   }
[13:20:55.077]                   options(future.plan = NULL)
[13:20:55.077]                   if (is.na(NA_character_)) 
[13:20:55.077]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:55.077]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:55.077]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:55.077]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:55.077]                     envir = parent.frame()) 
[13:20:55.077]                   {
[13:20:55.077]                     if (is.function(workers)) 
[13:20:55.077]                       workers <- workers()
[13:20:55.077]                     workers <- structure(as.integer(workers), 
[13:20:55.077]                       class = class(workers))
[13:20:55.077]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:55.077]                       workers >= 1)
[13:20:55.077]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:55.077]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:55.077]                     }
[13:20:55.077]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:55.077]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:55.077]                       envir = envir)
[13:20:55.077]                     if (!future$lazy) 
[13:20:55.077]                       future <- run(future)
[13:20:55.077]                     invisible(future)
[13:20:55.077]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:55.077]                 }
[13:20:55.077]             }
[13:20:55.077]         }
[13:20:55.077]     })
[13:20:55.077]     if (TRUE) {
[13:20:55.077]         base::sink(type = "output", split = FALSE)
[13:20:55.077]         if (TRUE) {
[13:20:55.077]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:55.077]         }
[13:20:55.077]         else {
[13:20:55.077]             ...future.result["stdout"] <- base::list(NULL)
[13:20:55.077]         }
[13:20:55.077]         base::close(...future.stdout)
[13:20:55.077]         ...future.stdout <- NULL
[13:20:55.077]     }
[13:20:55.077]     ...future.result$conditions <- ...future.conditions
[13:20:55.077]     ...future.result$finished <- base::Sys.time()
[13:20:55.077]     ...future.result
[13:20:55.077] }
[13:20:55.079] Exporting 1 global objects (1.55 MiB) to cluster node #1 ...
[13:20:55.081] Exporting ‘a’ (1.55 MiB) to cluster node #1 ...
[13:20:55.133] Exporting ‘a’ (1.55 MiB) to cluster node #1 ... DONE
[13:20:55.133] Exporting 1 global objects (1.55 MiB) to cluster node #1 ... DONE
[13:20:55.134] MultisessionFuture started
[13:20:55.134] - Launch lazy future ... done
[13:20:55.134] run() for ‘MultisessionFuture’ ... done
[13:20:55.134] result() for ClusterFuture ...
[13:20:55.135] receiveMessageFromWorker() for ClusterFuture ...
[13:20:55.135] - Validating connection of MultisessionFuture
[13:20:55.182] - received message: FutureResult
[13:20:55.182] - Received FutureResult
[13:20:55.182] - Erased future from FutureRegistry
[13:20:55.182] result() for ClusterFuture ...
[13:20:55.183] - result already collected: FutureResult
[13:20:55.183] result() for ClusterFuture ... done
[13:20:55.183] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:55.183] result() for ClusterFuture ... done
[13:20:55.183] result() for ClusterFuture ...
[13:20:55.183] - result already collected: FutureResult
[13:20:55.183] result() for ClusterFuture ... done
value(b) = 2
[13:20:55.183] result() for ClusterFuture ...
[13:20:55.183] - result already collected: FutureResult
[13:20:55.184] result() for ClusterFuture ... done
[13:20:55.184] result() for ClusterFuture ...
[13:20:55.184] - result already collected: FutureResult
[13:20:55.184] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:55.184] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:55.184] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:55.185] 
[13:20:55.185] Searching for globals ... DONE
[13:20:55.185] - globals: [0] <none>
[13:20:55.185] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:55.185] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:55.186] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:55.186] - globals found: [3] ‘+’, ‘value’, ‘a’
[13:20:55.186] Searching for globals ... DONE
[13:20:55.187] Resolving globals: TRUE
[13:20:55.187] Resolving any globals that are futures ...
[13:20:55.187] - globals: [3] ‘+’, ‘value’, ‘a’
[13:20:55.187] Resolving any globals that are futures ... DONE
[13:20:55.187] Resolving futures part of globals (recursively) ...
[13:20:55.187] resolve() on list ...
[13:20:55.187]  recursive: 99
[13:20:55.188]  length: 1
[13:20:55.188]  elements: ‘a’
[13:20:55.188] run() for ‘Future’ ...
[13:20:55.188] - state: ‘created’
[13:20:55.188] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:55.202] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:55.203] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:55.203]   - Field: ‘node’
[13:20:55.203]   - Field: ‘label’
[13:20:55.203]   - Field: ‘local’
[13:20:55.203]   - Field: ‘owner’
[13:20:55.203]   - Field: ‘envir’
[13:20:55.203]   - Field: ‘workers’
[13:20:55.203]   - Field: ‘packages’
[13:20:55.203]   - Field: ‘gc’
[13:20:55.203]   - Field: ‘conditions’
[13:20:55.204]   - Field: ‘persistent’
[13:20:55.204]   - Field: ‘expr’
[13:20:55.204]   - Field: ‘uuid’
[13:20:55.204]   - Field: ‘seed’
[13:20:55.204]   - Field: ‘version’
[13:20:55.204]   - Field: ‘result’
[13:20:55.204]   - Field: ‘asynchronous’
[13:20:55.204]   - Field: ‘calls’
[13:20:55.204]   - Field: ‘globals’
[13:20:55.204]   - Field: ‘stdout’
[13:20:55.205]   - Field: ‘earlySignal’
[13:20:55.205]   - Field: ‘lazy’
[13:20:55.205]   - Field: ‘state’
[13:20:55.205] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:55.205] - Launch lazy future ...
[13:20:55.205] Packages needed by the future expression (n = 0): <none>
[13:20:55.205] Packages needed by future strategies (n = 0): <none>
[13:20:55.206] {
[13:20:55.206]     {
[13:20:55.206]         {
[13:20:55.206]             ...future.startTime <- base::Sys.time()
[13:20:55.206]             {
[13:20:55.206]                 {
[13:20:55.206]                   {
[13:20:55.206]                     {
[13:20:55.206]                       base::local({
[13:20:55.206]                         has_future <- base::requireNamespace("future", 
[13:20:55.206]                           quietly = TRUE)
[13:20:55.206]                         if (has_future) {
[13:20:55.206]                           ns <- base::getNamespace("future")
[13:20:55.206]                           version <- ns[[".package"]][["version"]]
[13:20:55.206]                           if (is.null(version)) 
[13:20:55.206]                             version <- utils::packageVersion("future")
[13:20:55.206]                         }
[13:20:55.206]                         else {
[13:20:55.206]                           version <- NULL
[13:20:55.206]                         }
[13:20:55.206]                         if (!has_future || version < "1.8.0") {
[13:20:55.206]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:55.206]                             "", base::R.version$version.string), 
[13:20:55.206]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:55.206]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:55.206]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:55.206]                               "release", "version")], collapse = " "), 
[13:20:55.206]                             hostname = base::Sys.info()[["nodename"]])
[13:20:55.206]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:55.206]                             info)
[13:20:55.206]                           info <- base::paste(info, collapse = "; ")
[13:20:55.206]                           if (!has_future) {
[13:20:55.206]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:55.206]                               info)
[13:20:55.206]                           }
[13:20:55.206]                           else {
[13:20:55.206]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:55.206]                               info, version)
[13:20:55.206]                           }
[13:20:55.206]                           base::stop(msg)
[13:20:55.206]                         }
[13:20:55.206]                       })
[13:20:55.206]                     }
[13:20:55.206]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:55.206]                     base::options(mc.cores = 1L)
[13:20:55.206]                   }
[13:20:55.206]                   options(future.plan = NULL)
[13:20:55.206]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:55.206]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:55.206]                 }
[13:20:55.206]                 ...future.workdir <- getwd()
[13:20:55.206]             }
[13:20:55.206]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:55.206]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:55.206]         }
[13:20:55.206]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:55.206]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:55.206]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:55.206]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:55.206]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:55.206]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:55.206]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:55.206]             base::names(...future.oldOptions))
[13:20:55.206]     }
[13:20:55.206]     if (FALSE) {
[13:20:55.206]     }
[13:20:55.206]     else {
[13:20:55.206]         if (TRUE) {
[13:20:55.206]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:55.206]                 open = "w")
[13:20:55.206]         }
[13:20:55.206]         else {
[13:20:55.206]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:55.206]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:55.206]         }
[13:20:55.206]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:55.206]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:55.206]             base::sink(type = "output", split = FALSE)
[13:20:55.206]             base::close(...future.stdout)
[13:20:55.206]         }, add = TRUE)
[13:20:55.206]     }
[13:20:55.206]     ...future.frame <- base::sys.nframe()
[13:20:55.206]     ...future.conditions <- base::list()
[13:20:55.206]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:55.206]     if (FALSE) {
[13:20:55.206]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:55.206]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:55.206]     }
[13:20:55.206]     ...future.result <- base::tryCatch({
[13:20:55.206]         base::withCallingHandlers({
[13:20:55.206]             ...future.value <- base::withVisible(base::local({
[13:20:55.206]                 ...future.makeSendCondition <- local({
[13:20:55.206]                   sendCondition <- NULL
[13:20:55.206]                   function(frame = 1L) {
[13:20:55.206]                     if (is.function(sendCondition)) 
[13:20:55.206]                       return(sendCondition)
[13:20:55.206]                     ns <- getNamespace("parallel")
[13:20:55.206]                     if (exists("sendData", mode = "function", 
[13:20:55.206]                       envir = ns)) {
[13:20:55.206]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:55.206]                         envir = ns)
[13:20:55.206]                       envir <- sys.frame(frame)
[13:20:55.206]                       master <- NULL
[13:20:55.206]                       while (!identical(envir, .GlobalEnv) && 
[13:20:55.206]                         !identical(envir, emptyenv())) {
[13:20:55.206]                         if (exists("master", mode = "list", envir = envir, 
[13:20:55.206]                           inherits = FALSE)) {
[13:20:55.206]                           master <- get("master", mode = "list", 
[13:20:55.206]                             envir = envir, inherits = FALSE)
[13:20:55.206]                           if (inherits(master, c("SOCKnode", 
[13:20:55.206]                             "SOCK0node"))) {
[13:20:55.206]                             sendCondition <<- function(cond) {
[13:20:55.206]                               data <- list(type = "VALUE", value = cond, 
[13:20:55.206]                                 success = TRUE)
[13:20:55.206]                               parallel_sendData(master, data)
[13:20:55.206]                             }
[13:20:55.206]                             return(sendCondition)
[13:20:55.206]                           }
[13:20:55.206]                         }
[13:20:55.206]                         frame <- frame + 1L
[13:20:55.206]                         envir <- sys.frame(frame)
[13:20:55.206]                       }
[13:20:55.206]                     }
[13:20:55.206]                     sendCondition <<- function(cond) NULL
[13:20:55.206]                   }
[13:20:55.206]                 })
[13:20:55.206]                 withCallingHandlers({
[13:20:55.206]                   1
[13:20:55.206]                 }, immediateCondition = function(cond) {
[13:20:55.206]                   sendCondition <- ...future.makeSendCondition()
[13:20:55.206]                   sendCondition(cond)
[13:20:55.206]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.206]                   {
[13:20:55.206]                     inherits <- base::inherits
[13:20:55.206]                     invokeRestart <- base::invokeRestart
[13:20:55.206]                     is.null <- base::is.null
[13:20:55.206]                     muffled <- FALSE
[13:20:55.206]                     if (inherits(cond, "message")) {
[13:20:55.206]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:55.206]                       if (muffled) 
[13:20:55.206]                         invokeRestart("muffleMessage")
[13:20:55.206]                     }
[13:20:55.206]                     else if (inherits(cond, "warning")) {
[13:20:55.206]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:55.206]                       if (muffled) 
[13:20:55.206]                         invokeRestart("muffleWarning")
[13:20:55.206]                     }
[13:20:55.206]                     else if (inherits(cond, "condition")) {
[13:20:55.206]                       if (!is.null(pattern)) {
[13:20:55.206]                         computeRestarts <- base::computeRestarts
[13:20:55.206]                         grepl <- base::grepl
[13:20:55.206]                         restarts <- computeRestarts(cond)
[13:20:55.206]                         for (restart in restarts) {
[13:20:55.206]                           name <- restart$name
[13:20:55.206]                           if (is.null(name)) 
[13:20:55.206]                             next
[13:20:55.206]                           if (!grepl(pattern, name)) 
[13:20:55.206]                             next
[13:20:55.206]                           invokeRestart(restart)
[13:20:55.206]                           muffled <- TRUE
[13:20:55.206]                           break
[13:20:55.206]                         }
[13:20:55.206]                       }
[13:20:55.206]                     }
[13:20:55.206]                     invisible(muffled)
[13:20:55.206]                   }
[13:20:55.206]                   muffleCondition(cond)
[13:20:55.206]                 })
[13:20:55.206]             }))
[13:20:55.206]             future::FutureResult(value = ...future.value$value, 
[13:20:55.206]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:55.206]                   ...future.rng), globalenv = if (FALSE) 
[13:20:55.206]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:55.206]                     ...future.globalenv.names))
[13:20:55.206]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:55.206]         }, condition = base::local({
[13:20:55.206]             c <- base::c
[13:20:55.206]             inherits <- base::inherits
[13:20:55.206]             invokeRestart <- base::invokeRestart
[13:20:55.206]             length <- base::length
[13:20:55.206]             list <- base::list
[13:20:55.206]             seq.int <- base::seq.int
[13:20:55.206]             signalCondition <- base::signalCondition
[13:20:55.206]             sys.calls <- base::sys.calls
[13:20:55.206]             `[[` <- base::`[[`
[13:20:55.206]             `+` <- base::`+`
[13:20:55.206]             `<<-` <- base::`<<-`
[13:20:55.206]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:55.206]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:55.206]                   3L)]
[13:20:55.206]             }
[13:20:55.206]             function(cond) {
[13:20:55.206]                 is_error <- inherits(cond, "error")
[13:20:55.206]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:55.206]                   NULL)
[13:20:55.206]                 if (is_error) {
[13:20:55.206]                   sessionInformation <- function() {
[13:20:55.206]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:55.206]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:55.206]                       search = base::search(), system = base::Sys.info())
[13:20:55.206]                   }
[13:20:55.206]                   ...future.conditions[[length(...future.conditions) + 
[13:20:55.206]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:55.206]                     cond$call), session = sessionInformation(), 
[13:20:55.206]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:55.206]                   signalCondition(cond)
[13:20:55.206]                 }
[13:20:55.206]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:55.206]                 "immediateCondition"))) {
[13:20:55.206]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:55.206]                   ...future.conditions[[length(...future.conditions) + 
[13:20:55.206]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:55.206]                   if (TRUE && !signal) {
[13:20:55.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.206]                     {
[13:20:55.206]                       inherits <- base::inherits
[13:20:55.206]                       invokeRestart <- base::invokeRestart
[13:20:55.206]                       is.null <- base::is.null
[13:20:55.206]                       muffled <- FALSE
[13:20:55.206]                       if (inherits(cond, "message")) {
[13:20:55.206]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:55.206]                         if (muffled) 
[13:20:55.206]                           invokeRestart("muffleMessage")
[13:20:55.206]                       }
[13:20:55.206]                       else if (inherits(cond, "warning")) {
[13:20:55.206]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:55.206]                         if (muffled) 
[13:20:55.206]                           invokeRestart("muffleWarning")
[13:20:55.206]                       }
[13:20:55.206]                       else if (inherits(cond, "condition")) {
[13:20:55.206]                         if (!is.null(pattern)) {
[13:20:55.206]                           computeRestarts <- base::computeRestarts
[13:20:55.206]                           grepl <- base::grepl
[13:20:55.206]                           restarts <- computeRestarts(cond)
[13:20:55.206]                           for (restart in restarts) {
[13:20:55.206]                             name <- restart$name
[13:20:55.206]                             if (is.null(name)) 
[13:20:55.206]                               next
[13:20:55.206]                             if (!grepl(pattern, name)) 
[13:20:55.206]                               next
[13:20:55.206]                             invokeRestart(restart)
[13:20:55.206]                             muffled <- TRUE
[13:20:55.206]                             break
[13:20:55.206]                           }
[13:20:55.206]                         }
[13:20:55.206]                       }
[13:20:55.206]                       invisible(muffled)
[13:20:55.206]                     }
[13:20:55.206]                     muffleCondition(cond, pattern = "^muffle")
[13:20:55.206]                   }
[13:20:55.206]                 }
[13:20:55.206]                 else {
[13:20:55.206]                   if (TRUE) {
[13:20:55.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.206]                     {
[13:20:55.206]                       inherits <- base::inherits
[13:20:55.206]                       invokeRestart <- base::invokeRestart
[13:20:55.206]                       is.null <- base::is.null
[13:20:55.206]                       muffled <- FALSE
[13:20:55.206]                       if (inherits(cond, "message")) {
[13:20:55.206]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:55.206]                         if (muffled) 
[13:20:55.206]                           invokeRestart("muffleMessage")
[13:20:55.206]                       }
[13:20:55.206]                       else if (inherits(cond, "warning")) {
[13:20:55.206]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:55.206]                         if (muffled) 
[13:20:55.206]                           invokeRestart("muffleWarning")
[13:20:55.206]                       }
[13:20:55.206]                       else if (inherits(cond, "condition")) {
[13:20:55.206]                         if (!is.null(pattern)) {
[13:20:55.206]                           computeRestarts <- base::computeRestarts
[13:20:55.206]                           grepl <- base::grepl
[13:20:55.206]                           restarts <- computeRestarts(cond)
[13:20:55.206]                           for (restart in restarts) {
[13:20:55.206]                             name <- restart$name
[13:20:55.206]                             if (is.null(name)) 
[13:20:55.206]                               next
[13:20:55.206]                             if (!grepl(pattern, name)) 
[13:20:55.206]                               next
[13:20:55.206]                             invokeRestart(restart)
[13:20:55.206]                             muffled <- TRUE
[13:20:55.206]                             break
[13:20:55.206]                           }
[13:20:55.206]                         }
[13:20:55.206]                       }
[13:20:55.206]                       invisible(muffled)
[13:20:55.206]                     }
[13:20:55.206]                     muffleCondition(cond, pattern = "^muffle")
[13:20:55.206]                   }
[13:20:55.206]                 }
[13:20:55.206]             }
[13:20:55.206]         }))
[13:20:55.206]     }, error = function(ex) {
[13:20:55.206]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:55.206]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:55.206]                 ...future.rng), started = ...future.startTime, 
[13:20:55.206]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:55.206]             version = "1.8"), class = "FutureResult")
[13:20:55.206]     }, finally = {
[13:20:55.206]         if (!identical(...future.workdir, getwd())) 
[13:20:55.206]             setwd(...future.workdir)
[13:20:55.206]         {
[13:20:55.206]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:55.206]                 ...future.oldOptions$nwarnings <- NULL
[13:20:55.206]             }
[13:20:55.206]             base::options(...future.oldOptions)
[13:20:55.206]             if (.Platform$OS.type == "windows") {
[13:20:55.206]                 old_names <- names(...future.oldEnvVars)
[13:20:55.206]                 envs <- base::Sys.getenv()
[13:20:55.206]                 names <- names(envs)
[13:20:55.206]                 common <- intersect(names, old_names)
[13:20:55.206]                 added <- setdiff(names, old_names)
[13:20:55.206]                 removed <- setdiff(old_names, names)
[13:20:55.206]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:55.206]                   envs[common]]
[13:20:55.206]                 NAMES <- toupper(changed)
[13:20:55.206]                 args <- list()
[13:20:55.206]                 for (kk in seq_along(NAMES)) {
[13:20:55.206]                   name <- changed[[kk]]
[13:20:55.206]                   NAME <- NAMES[[kk]]
[13:20:55.206]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.206]                     next
[13:20:55.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:55.206]                 }
[13:20:55.206]                 NAMES <- toupper(added)
[13:20:55.206]                 for (kk in seq_along(NAMES)) {
[13:20:55.206]                   name <- added[[kk]]
[13:20:55.206]                   NAME <- NAMES[[kk]]
[13:20:55.206]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.206]                     next
[13:20:55.206]                   args[[name]] <- ""
[13:20:55.206]                 }
[13:20:55.206]                 NAMES <- toupper(removed)
[13:20:55.206]                 for (kk in seq_along(NAMES)) {
[13:20:55.206]                   name <- removed[[kk]]
[13:20:55.206]                   NAME <- NAMES[[kk]]
[13:20:55.206]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.206]                     next
[13:20:55.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:55.206]                 }
[13:20:55.206]                 if (length(args) > 0) 
[13:20:55.206]                   base::do.call(base::Sys.setenv, args = args)
[13:20:55.206]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:55.206]             }
[13:20:55.206]             else {
[13:20:55.206]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:55.206]             }
[13:20:55.206]             {
[13:20:55.206]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:55.206]                   0L) {
[13:20:55.206]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:55.206]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:55.206]                   base::options(opts)
[13:20:55.206]                 }
[13:20:55.206]                 {
[13:20:55.206]                   {
[13:20:55.206]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:55.206]                     NULL
[13:20:55.206]                   }
[13:20:55.206]                   options(future.plan = NULL)
[13:20:55.206]                   if (is.na(NA_character_)) 
[13:20:55.206]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:55.206]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:55.206]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:55.206]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:55.206]                     envir = parent.frame()) 
[13:20:55.206]                   {
[13:20:55.206]                     if (is.function(workers)) 
[13:20:55.206]                       workers <- workers()
[13:20:55.206]                     workers <- structure(as.integer(workers), 
[13:20:55.206]                       class = class(workers))
[13:20:55.206]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:55.206]                       workers >= 1)
[13:20:55.206]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:55.206]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:55.206]                     }
[13:20:55.206]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:55.206]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:55.206]                       envir = envir)
[13:20:55.206]                     if (!future$lazy) 
[13:20:55.206]                       future <- run(future)
[13:20:55.206]                     invisible(future)
[13:20:55.206]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:55.206]                 }
[13:20:55.206]             }
[13:20:55.206]         }
[13:20:55.206]     })
[13:20:55.206]     if (TRUE) {
[13:20:55.206]         base::sink(type = "output", split = FALSE)
[13:20:55.206]         if (TRUE) {
[13:20:55.206]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:55.206]         }
[13:20:55.206]         else {
[13:20:55.206]             ...future.result["stdout"] <- base::list(NULL)
[13:20:55.206]         }
[13:20:55.206]         base::close(...future.stdout)
[13:20:55.206]         ...future.stdout <- NULL
[13:20:55.206]     }
[13:20:55.206]     ...future.result$conditions <- ...future.conditions
[13:20:55.206]     ...future.result$finished <- base::Sys.time()
[13:20:55.206]     ...future.result
[13:20:55.206] }
[13:20:55.209] MultisessionFuture started
[13:20:55.209] - Launch lazy future ... done
[13:20:55.209] run() for ‘MultisessionFuture’ ... done
[13:20:55.254] receiveMessageFromWorker() for ClusterFuture ...
[13:20:55.254] - Validating connection of MultisessionFuture
[13:20:55.255] - received message: FutureResult
[13:20:55.255] - Received FutureResult
[13:20:55.255] - Erased future from FutureRegistry
[13:20:55.255] result() for ClusterFuture ...
[13:20:55.255] - result already collected: FutureResult
[13:20:55.255] result() for ClusterFuture ... done
[13:20:55.255] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:55.255] Future #1
[13:20:55.255] result() for ClusterFuture ...
[13:20:55.256] - result already collected: FutureResult
[13:20:55.256] result() for ClusterFuture ... done
[13:20:55.256] result() for ClusterFuture ...
[13:20:55.256] - result already collected: FutureResult
[13:20:55.256] result() for ClusterFuture ... done
[13:20:55.256] A MultisessionFuture was resolved
[13:20:55.256]  length: 0 (resolved future 1)
[13:20:55.256] resolve() on list ... DONE
[13:20:55.256] - globals: [1] ‘a’
[13:20:55.257] Resolving futures part of globals (recursively) ... DONE
[13:20:55.259] The total size of the 1 globals is 1.55 MiB (1629664 bytes)
[13:20:55.259] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[13:20:55.259] - globals: [1] ‘a’
[13:20:55.259] - packages: [1] ‘future’
[13:20:55.259] getGlobalsAndPackages() ... DONE
[13:20:55.260] run() for ‘Future’ ...
[13:20:55.260] - state: ‘created’
[13:20:55.260] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:55.277] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:55.277] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:55.277]   - Field: ‘node’
[13:20:55.277]   - Field: ‘label’
[13:20:55.277]   - Field: ‘local’
[13:20:55.277]   - Field: ‘owner’
[13:20:55.277]   - Field: ‘envir’
[13:20:55.277]   - Field: ‘workers’
[13:20:55.277]   - Field: ‘packages’
[13:20:55.278]   - Field: ‘gc’
[13:20:55.278]   - Field: ‘conditions’
[13:20:55.278]   - Field: ‘persistent’
[13:20:55.278]   - Field: ‘expr’
[13:20:55.278]   - Field: ‘uuid’
[13:20:55.278]   - Field: ‘seed’
[13:20:55.278]   - Field: ‘version’
[13:20:55.278]   - Field: ‘result’
[13:20:55.278]   - Field: ‘asynchronous’
[13:20:55.278]   - Field: ‘calls’
[13:20:55.278]   - Field: ‘globals’
[13:20:55.279]   - Field: ‘stdout’
[13:20:55.279]   - Field: ‘earlySignal’
[13:20:55.279]   - Field: ‘lazy’
[13:20:55.279]   - Field: ‘state’
[13:20:55.279] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:55.279] - Launch lazy future ...
[13:20:55.279] Packages needed by the future expression (n = 1): ‘future’
[13:20:55.279] Packages needed by future strategies (n = 0): <none>
[13:20:55.280] {
[13:20:55.280]     {
[13:20:55.280]         {
[13:20:55.280]             ...future.startTime <- base::Sys.time()
[13:20:55.280]             {
[13:20:55.280]                 {
[13:20:55.280]                   {
[13:20:55.280]                     {
[13:20:55.280]                       {
[13:20:55.280]                         base::local({
[13:20:55.280]                           has_future <- base::requireNamespace("future", 
[13:20:55.280]                             quietly = TRUE)
[13:20:55.280]                           if (has_future) {
[13:20:55.280]                             ns <- base::getNamespace("future")
[13:20:55.280]                             version <- ns[[".package"]][["version"]]
[13:20:55.280]                             if (is.null(version)) 
[13:20:55.280]                               version <- utils::packageVersion("future")
[13:20:55.280]                           }
[13:20:55.280]                           else {
[13:20:55.280]                             version <- NULL
[13:20:55.280]                           }
[13:20:55.280]                           if (!has_future || version < "1.8.0") {
[13:20:55.280]                             info <- base::c(r_version = base::gsub("R version ", 
[13:20:55.280]                               "", base::R.version$version.string), 
[13:20:55.280]                               platform = base::sprintf("%s (%s-bit)", 
[13:20:55.280]                                 base::R.version$platform, 8 * 
[13:20:55.280]                                   base::.Machine$sizeof.pointer), 
[13:20:55.280]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:55.280]                                 "release", "version")], collapse = " "), 
[13:20:55.280]                               hostname = base::Sys.info()[["nodename"]])
[13:20:55.280]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:20:55.280]                               info)
[13:20:55.280]                             info <- base::paste(info, collapse = "; ")
[13:20:55.280]                             if (!has_future) {
[13:20:55.280]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:55.280]                                 info)
[13:20:55.280]                             }
[13:20:55.280]                             else {
[13:20:55.280]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:55.280]                                 info, version)
[13:20:55.280]                             }
[13:20:55.280]                             base::stop(msg)
[13:20:55.280]                           }
[13:20:55.280]                         })
[13:20:55.280]                       }
[13:20:55.280]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:55.280]                       base::options(mc.cores = 1L)
[13:20:55.280]                     }
[13:20:55.280]                     base::local({
[13:20:55.280]                       for (pkg in "future") {
[13:20:55.280]                         base::loadNamespace(pkg)
[13:20:55.280]                         base::library(pkg, character.only = TRUE)
[13:20:55.280]                       }
[13:20:55.280]                     })
[13:20:55.280]                   }
[13:20:55.280]                   options(future.plan = NULL)
[13:20:55.280]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:55.280]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:55.280]                 }
[13:20:55.280]                 ...future.workdir <- getwd()
[13:20:55.280]             }
[13:20:55.280]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:55.280]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:55.280]         }
[13:20:55.280]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:55.280]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:55.280]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:55.280]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:55.280]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:55.280]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:55.280]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:55.280]             base::names(...future.oldOptions))
[13:20:55.280]     }
[13:20:55.280]     if (FALSE) {
[13:20:55.280]     }
[13:20:55.280]     else {
[13:20:55.280]         if (TRUE) {
[13:20:55.280]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:55.280]                 open = "w")
[13:20:55.280]         }
[13:20:55.280]         else {
[13:20:55.280]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:55.280]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:55.280]         }
[13:20:55.280]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:55.280]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:55.280]             base::sink(type = "output", split = FALSE)
[13:20:55.280]             base::close(...future.stdout)
[13:20:55.280]         }, add = TRUE)
[13:20:55.280]     }
[13:20:55.280]     ...future.frame <- base::sys.nframe()
[13:20:55.280]     ...future.conditions <- base::list()
[13:20:55.280]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:55.280]     if (FALSE) {
[13:20:55.280]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:55.280]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:55.280]     }
[13:20:55.280]     ...future.result <- base::tryCatch({
[13:20:55.280]         base::withCallingHandlers({
[13:20:55.280]             ...future.value <- base::withVisible(base::local({
[13:20:55.280]                 ...future.makeSendCondition <- local({
[13:20:55.280]                   sendCondition <- NULL
[13:20:55.280]                   function(frame = 1L) {
[13:20:55.280]                     if (is.function(sendCondition)) 
[13:20:55.280]                       return(sendCondition)
[13:20:55.280]                     ns <- getNamespace("parallel")
[13:20:55.280]                     if (exists("sendData", mode = "function", 
[13:20:55.280]                       envir = ns)) {
[13:20:55.280]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:55.280]                         envir = ns)
[13:20:55.280]                       envir <- sys.frame(frame)
[13:20:55.280]                       master <- NULL
[13:20:55.280]                       while (!identical(envir, .GlobalEnv) && 
[13:20:55.280]                         !identical(envir, emptyenv())) {
[13:20:55.280]                         if (exists("master", mode = "list", envir = envir, 
[13:20:55.280]                           inherits = FALSE)) {
[13:20:55.280]                           master <- get("master", mode = "list", 
[13:20:55.280]                             envir = envir, inherits = FALSE)
[13:20:55.280]                           if (inherits(master, c("SOCKnode", 
[13:20:55.280]                             "SOCK0node"))) {
[13:20:55.280]                             sendCondition <<- function(cond) {
[13:20:55.280]                               data <- list(type = "VALUE", value = cond, 
[13:20:55.280]                                 success = TRUE)
[13:20:55.280]                               parallel_sendData(master, data)
[13:20:55.280]                             }
[13:20:55.280]                             return(sendCondition)
[13:20:55.280]                           }
[13:20:55.280]                         }
[13:20:55.280]                         frame <- frame + 1L
[13:20:55.280]                         envir <- sys.frame(frame)
[13:20:55.280]                       }
[13:20:55.280]                     }
[13:20:55.280]                     sendCondition <<- function(cond) NULL
[13:20:55.280]                   }
[13:20:55.280]                 })
[13:20:55.280]                 withCallingHandlers({
[13:20:55.280]                   value(a) + 1
[13:20:55.280]                 }, immediateCondition = function(cond) {
[13:20:55.280]                   sendCondition <- ...future.makeSendCondition()
[13:20:55.280]                   sendCondition(cond)
[13:20:55.280]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.280]                   {
[13:20:55.280]                     inherits <- base::inherits
[13:20:55.280]                     invokeRestart <- base::invokeRestart
[13:20:55.280]                     is.null <- base::is.null
[13:20:55.280]                     muffled <- FALSE
[13:20:55.280]                     if (inherits(cond, "message")) {
[13:20:55.280]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:55.280]                       if (muffled) 
[13:20:55.280]                         invokeRestart("muffleMessage")
[13:20:55.280]                     }
[13:20:55.280]                     else if (inherits(cond, "warning")) {
[13:20:55.280]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:55.280]                       if (muffled) 
[13:20:55.280]                         invokeRestart("muffleWarning")
[13:20:55.280]                     }
[13:20:55.280]                     else if (inherits(cond, "condition")) {
[13:20:55.280]                       if (!is.null(pattern)) {
[13:20:55.280]                         computeRestarts <- base::computeRestarts
[13:20:55.280]                         grepl <- base::grepl
[13:20:55.280]                         restarts <- computeRestarts(cond)
[13:20:55.280]                         for (restart in restarts) {
[13:20:55.280]                           name <- restart$name
[13:20:55.280]                           if (is.null(name)) 
[13:20:55.280]                             next
[13:20:55.280]                           if (!grepl(pattern, name)) 
[13:20:55.280]                             next
[13:20:55.280]                           invokeRestart(restart)
[13:20:55.280]                           muffled <- TRUE
[13:20:55.280]                           break
[13:20:55.280]                         }
[13:20:55.280]                       }
[13:20:55.280]                     }
[13:20:55.280]                     invisible(muffled)
[13:20:55.280]                   }
[13:20:55.280]                   muffleCondition(cond)
[13:20:55.280]                 })
[13:20:55.280]             }))
[13:20:55.280]             future::FutureResult(value = ...future.value$value, 
[13:20:55.280]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:55.280]                   ...future.rng), globalenv = if (FALSE) 
[13:20:55.280]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:55.280]                     ...future.globalenv.names))
[13:20:55.280]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:55.280]         }, condition = base::local({
[13:20:55.280]             c <- base::c
[13:20:55.280]             inherits <- base::inherits
[13:20:55.280]             invokeRestart <- base::invokeRestart
[13:20:55.280]             length <- base::length
[13:20:55.280]             list <- base::list
[13:20:55.280]             seq.int <- base::seq.int
[13:20:55.280]             signalCondition <- base::signalCondition
[13:20:55.280]             sys.calls <- base::sys.calls
[13:20:55.280]             `[[` <- base::`[[`
[13:20:55.280]             `+` <- base::`+`
[13:20:55.280]             `<<-` <- base::`<<-`
[13:20:55.280]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:55.280]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:55.280]                   3L)]
[13:20:55.280]             }
[13:20:55.280]             function(cond) {
[13:20:55.280]                 is_error <- inherits(cond, "error")
[13:20:55.280]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:55.280]                   NULL)
[13:20:55.280]                 if (is_error) {
[13:20:55.280]                   sessionInformation <- function() {
[13:20:55.280]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:55.280]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:55.280]                       search = base::search(), system = base::Sys.info())
[13:20:55.280]                   }
[13:20:55.280]                   ...future.conditions[[length(...future.conditions) + 
[13:20:55.280]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:55.280]                     cond$call), session = sessionInformation(), 
[13:20:55.280]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:55.280]                   signalCondition(cond)
[13:20:55.280]                 }
[13:20:55.280]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:55.280]                 "immediateCondition"))) {
[13:20:55.280]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:55.280]                   ...future.conditions[[length(...future.conditions) + 
[13:20:55.280]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:55.280]                   if (TRUE && !signal) {
[13:20:55.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.280]                     {
[13:20:55.280]                       inherits <- base::inherits
[13:20:55.280]                       invokeRestart <- base::invokeRestart
[13:20:55.280]                       is.null <- base::is.null
[13:20:55.280]                       muffled <- FALSE
[13:20:55.280]                       if (inherits(cond, "message")) {
[13:20:55.280]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:55.280]                         if (muffled) 
[13:20:55.280]                           invokeRestart("muffleMessage")
[13:20:55.280]                       }
[13:20:55.280]                       else if (inherits(cond, "warning")) {
[13:20:55.280]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:55.280]                         if (muffled) 
[13:20:55.280]                           invokeRestart("muffleWarning")
[13:20:55.280]                       }
[13:20:55.280]                       else if (inherits(cond, "condition")) {
[13:20:55.280]                         if (!is.null(pattern)) {
[13:20:55.280]                           computeRestarts <- base::computeRestarts
[13:20:55.280]                           grepl <- base::grepl
[13:20:55.280]                           restarts <- computeRestarts(cond)
[13:20:55.280]                           for (restart in restarts) {
[13:20:55.280]                             name <- restart$name
[13:20:55.280]                             if (is.null(name)) 
[13:20:55.280]                               next
[13:20:55.280]                             if (!grepl(pattern, name)) 
[13:20:55.280]                               next
[13:20:55.280]                             invokeRestart(restart)
[13:20:55.280]                             muffled <- TRUE
[13:20:55.280]                             break
[13:20:55.280]                           }
[13:20:55.280]                         }
[13:20:55.280]                       }
[13:20:55.280]                       invisible(muffled)
[13:20:55.280]                     }
[13:20:55.280]                     muffleCondition(cond, pattern = "^muffle")
[13:20:55.280]                   }
[13:20:55.280]                 }
[13:20:55.280]                 else {
[13:20:55.280]                   if (TRUE) {
[13:20:55.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.280]                     {
[13:20:55.280]                       inherits <- base::inherits
[13:20:55.280]                       invokeRestart <- base::invokeRestart
[13:20:55.280]                       is.null <- base::is.null
[13:20:55.280]                       muffled <- FALSE
[13:20:55.280]                       if (inherits(cond, "message")) {
[13:20:55.280]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:55.280]                         if (muffled) 
[13:20:55.280]                           invokeRestart("muffleMessage")
[13:20:55.280]                       }
[13:20:55.280]                       else if (inherits(cond, "warning")) {
[13:20:55.280]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:55.280]                         if (muffled) 
[13:20:55.280]                           invokeRestart("muffleWarning")
[13:20:55.280]                       }
[13:20:55.280]                       else if (inherits(cond, "condition")) {
[13:20:55.280]                         if (!is.null(pattern)) {
[13:20:55.280]                           computeRestarts <- base::computeRestarts
[13:20:55.280]                           grepl <- base::grepl
[13:20:55.280]                           restarts <- computeRestarts(cond)
[13:20:55.280]                           for (restart in restarts) {
[13:20:55.280]                             name <- restart$name
[13:20:55.280]                             if (is.null(name)) 
[13:20:55.280]                               next
[13:20:55.280]                             if (!grepl(pattern, name)) 
[13:20:55.280]                               next
[13:20:55.280]                             invokeRestart(restart)
[13:20:55.280]                             muffled <- TRUE
[13:20:55.280]                             break
[13:20:55.280]                           }
[13:20:55.280]                         }
[13:20:55.280]                       }
[13:20:55.280]                       invisible(muffled)
[13:20:55.280]                     }
[13:20:55.280]                     muffleCondition(cond, pattern = "^muffle")
[13:20:55.280]                   }
[13:20:55.280]                 }
[13:20:55.280]             }
[13:20:55.280]         }))
[13:20:55.280]     }, error = function(ex) {
[13:20:55.280]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:55.280]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:55.280]                 ...future.rng), started = ...future.startTime, 
[13:20:55.280]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:55.280]             version = "1.8"), class = "FutureResult")
[13:20:55.280]     }, finally = {
[13:20:55.280]         if (!identical(...future.workdir, getwd())) 
[13:20:55.280]             setwd(...future.workdir)
[13:20:55.280]         {
[13:20:55.280]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:55.280]                 ...future.oldOptions$nwarnings <- NULL
[13:20:55.280]             }
[13:20:55.280]             base::options(...future.oldOptions)
[13:20:55.280]             if (.Platform$OS.type == "windows") {
[13:20:55.280]                 old_names <- names(...future.oldEnvVars)
[13:20:55.280]                 envs <- base::Sys.getenv()
[13:20:55.280]                 names <- names(envs)
[13:20:55.280]                 common <- intersect(names, old_names)
[13:20:55.280]                 added <- setdiff(names, old_names)
[13:20:55.280]                 removed <- setdiff(old_names, names)
[13:20:55.280]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:55.280]                   envs[common]]
[13:20:55.280]                 NAMES <- toupper(changed)
[13:20:55.280]                 args <- list()
[13:20:55.280]                 for (kk in seq_along(NAMES)) {
[13:20:55.280]                   name <- changed[[kk]]
[13:20:55.280]                   NAME <- NAMES[[kk]]
[13:20:55.280]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.280]                     next
[13:20:55.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:55.280]                 }
[13:20:55.280]                 NAMES <- toupper(added)
[13:20:55.280]                 for (kk in seq_along(NAMES)) {
[13:20:55.280]                   name <- added[[kk]]
[13:20:55.280]                   NAME <- NAMES[[kk]]
[13:20:55.280]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.280]                     next
[13:20:55.280]                   args[[name]] <- ""
[13:20:55.280]                 }
[13:20:55.280]                 NAMES <- toupper(removed)
[13:20:55.280]                 for (kk in seq_along(NAMES)) {
[13:20:55.280]                   name <- removed[[kk]]
[13:20:55.280]                   NAME <- NAMES[[kk]]
[13:20:55.280]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.280]                     next
[13:20:55.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:55.280]                 }
[13:20:55.280]                 if (length(args) > 0) 
[13:20:55.280]                   base::do.call(base::Sys.setenv, args = args)
[13:20:55.280]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:55.280]             }
[13:20:55.280]             else {
[13:20:55.280]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:55.280]             }
[13:20:55.280]             {
[13:20:55.280]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:55.280]                   0L) {
[13:20:55.280]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:55.280]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:55.280]                   base::options(opts)
[13:20:55.280]                 }
[13:20:55.280]                 {
[13:20:55.280]                   {
[13:20:55.280]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:55.280]                     NULL
[13:20:55.280]                   }
[13:20:55.280]                   options(future.plan = NULL)
[13:20:55.280]                   if (is.na(NA_character_)) 
[13:20:55.280]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:55.280]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:55.280]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:55.280]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:55.280]                     envir = parent.frame()) 
[13:20:55.280]                   {
[13:20:55.280]                     if (is.function(workers)) 
[13:20:55.280]                       workers <- workers()
[13:20:55.280]                     workers <- structure(as.integer(workers), 
[13:20:55.280]                       class = class(workers))
[13:20:55.280]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:55.280]                       workers >= 1)
[13:20:55.280]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:55.280]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:55.280]                     }
[13:20:55.280]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:55.280]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:55.280]                       envir = envir)
[13:20:55.280]                     if (!future$lazy) 
[13:20:55.280]                       future <- run(future)
[13:20:55.280]                     invisible(future)
[13:20:55.280]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:55.280]                 }
[13:20:55.280]             }
[13:20:55.280]         }
[13:20:55.280]     })
[13:20:55.280]     if (TRUE) {
[13:20:55.280]         base::sink(type = "output", split = FALSE)
[13:20:55.280]         if (TRUE) {
[13:20:55.280]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:55.280]         }
[13:20:55.280]         else {
[13:20:55.280]             ...future.result["stdout"] <- base::list(NULL)
[13:20:55.280]         }
[13:20:55.280]         base::close(...future.stdout)
[13:20:55.280]         ...future.stdout <- NULL
[13:20:55.280]     }
[13:20:55.280]     ...future.result$conditions <- ...future.conditions
[13:20:55.280]     ...future.result$finished <- base::Sys.time()
[13:20:55.280]     ...future.result
[13:20:55.280] }
[13:20:55.283] Exporting 1 global objects (1.55 MiB) to cluster node #1 ...
[13:20:55.284] Exporting ‘a’ (1.55 MiB) to cluster node #1 ...
[13:20:55.337] Exporting ‘a’ (1.55 MiB) to cluster node #1 ... DONE
[13:20:55.337] Exporting 1 global objects (1.55 MiB) to cluster node #1 ... DONE
[13:20:55.338] MultisessionFuture started
[13:20:55.338] - Launch lazy future ... done
[13:20:55.338] run() for ‘MultisessionFuture’ ... done
[13:20:55.338] result() for ClusterFuture ...
[13:20:55.338] receiveMessageFromWorker() for ClusterFuture ...
[13:20:55.338] - Validating connection of MultisessionFuture
[13:20:55.386] - received message: FutureResult
[13:20:55.386] - Received FutureResult
[13:20:55.386] - Erased future from FutureRegistry
[13:20:55.386] result() for ClusterFuture ...
[13:20:55.387] - result already collected: FutureResult
[13:20:55.387] result() for ClusterFuture ... done
[13:20:55.387] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:55.387] result() for ClusterFuture ... done
[13:20:55.387] result() for ClusterFuture ...
[13:20:55.387] - result already collected: FutureResult
[13:20:55.387] result() for ClusterFuture ... done
value(b) = 2
[13:20:55.387] result() for ClusterFuture ...
[13:20:55.387] - result already collected: FutureResult
[13:20:55.388] result() for ClusterFuture ... done
[13:20:55.388] result() for ClusterFuture ...
[13:20:55.388] - result already collected: FutureResult
[13:20:55.388] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:55.388] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:55.388] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:55.389] - globals found: [2] ‘{’, ‘pkg’
[13:20:55.389] Searching for globals ... DONE
[13:20:55.389] Resolving globals: TRUE
[13:20:55.389] Resolving any globals that are futures ...
[13:20:55.390] - globals: [2] ‘{’, ‘pkg’
[13:20:55.390] Resolving any globals that are futures ... DONE
[13:20:55.390] Resolving futures part of globals (recursively) ...
[13:20:55.390] resolve() on list ...
[13:20:55.390]  recursive: 99
[13:20:55.390]  length: 1
[13:20:55.390]  elements: ‘pkg’
[13:20:55.391]  length: 0 (resolved future 1)
[13:20:55.391] resolve() on list ... DONE
[13:20:55.391] - globals: [1] ‘pkg’
[13:20:55.391] Resolving futures part of globals (recursively) ... DONE
[13:20:55.391] The total size of the 1 globals is 112 bytes (112 bytes)
[13:20:55.391] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[13:20:55.391] - globals: [1] ‘pkg’
[13:20:55.392] 
[13:20:55.392] getGlobalsAndPackages() ... DONE
[13:20:55.392] Packages needed by the future expression (n = 0): <none>
[13:20:55.392] Packages needed by future strategies (n = 0): <none>
[13:20:55.393] {
[13:20:55.393]     {
[13:20:55.393]         {
[13:20:55.393]             ...future.startTime <- base::Sys.time()
[13:20:55.393]             {
[13:20:55.393]                 {
[13:20:55.393]                   {
[13:20:55.393]                     base::local({
[13:20:55.393]                       has_future <- base::requireNamespace("future", 
[13:20:55.393]                         quietly = TRUE)
[13:20:55.393]                       if (has_future) {
[13:20:55.393]                         ns <- base::getNamespace("future")
[13:20:55.393]                         version <- ns[[".package"]][["version"]]
[13:20:55.393]                         if (is.null(version)) 
[13:20:55.393]                           version <- utils::packageVersion("future")
[13:20:55.393]                       }
[13:20:55.393]                       else {
[13:20:55.393]                         version <- NULL
[13:20:55.393]                       }
[13:20:55.393]                       if (!has_future || version < "1.8.0") {
[13:20:55.393]                         info <- base::c(r_version = base::gsub("R version ", 
[13:20:55.393]                           "", base::R.version$version.string), 
[13:20:55.393]                           platform = base::sprintf("%s (%s-bit)", 
[13:20:55.393]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:55.393]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:55.393]                             "release", "version")], collapse = " "), 
[13:20:55.393]                           hostname = base::Sys.info()[["nodename"]])
[13:20:55.393]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:20:55.393]                           info)
[13:20:55.393]                         info <- base::paste(info, collapse = "; ")
[13:20:55.393]                         if (!has_future) {
[13:20:55.393]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:55.393]                             info)
[13:20:55.393]                         }
[13:20:55.393]                         else {
[13:20:55.393]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:55.393]                             info, version)
[13:20:55.393]                         }
[13:20:55.393]                         base::stop(msg)
[13:20:55.393]                       }
[13:20:55.393]                     })
[13:20:55.393]                   }
[13:20:55.393]                   options(future.plan = NULL)
[13:20:55.393]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:55.393]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:55.393]                 }
[13:20:55.393]                 ...future.workdir <- getwd()
[13:20:55.393]             }
[13:20:55.393]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:55.393]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:55.393]         }
[13:20:55.393]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:55.393]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:55.393]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:55.393]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:55.393]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:55.393]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:55.393]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:55.393]             base::names(...future.oldOptions))
[13:20:55.393]     }
[13:20:55.393]     if (FALSE) {
[13:20:55.393]     }
[13:20:55.393]     else {
[13:20:55.393]         if (TRUE) {
[13:20:55.393]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:55.393]                 open = "w")
[13:20:55.393]         }
[13:20:55.393]         else {
[13:20:55.393]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:55.393]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:55.393]         }
[13:20:55.393]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:55.393]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:55.393]             base::sink(type = "output", split = FALSE)
[13:20:55.393]             base::close(...future.stdout)
[13:20:55.393]         }, add = TRUE)
[13:20:55.393]     }
[13:20:55.393]     ...future.frame <- base::sys.nframe()
[13:20:55.393]     ...future.conditions <- base::list()
[13:20:55.393]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:55.393]     if (FALSE) {
[13:20:55.393]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:55.393]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:55.393]     }
[13:20:55.393]     ...future.result <- base::tryCatch({
[13:20:55.393]         base::withCallingHandlers({
[13:20:55.393]             ...future.value <- base::withVisible(base::local({
[13:20:55.393]                 pkg
[13:20:55.393]             }))
[13:20:55.393]             future::FutureResult(value = ...future.value$value, 
[13:20:55.393]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:55.393]                   ...future.rng), globalenv = if (FALSE) 
[13:20:55.393]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:55.393]                     ...future.globalenv.names))
[13:20:55.393]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:55.393]         }, condition = base::local({
[13:20:55.393]             c <- base::c
[13:20:55.393]             inherits <- base::inherits
[13:20:55.393]             invokeRestart <- base::invokeRestart
[13:20:55.393]             length <- base::length
[13:20:55.393]             list <- base::list
[13:20:55.393]             seq.int <- base::seq.int
[13:20:55.393]             signalCondition <- base::signalCondition
[13:20:55.393]             sys.calls <- base::sys.calls
[13:20:55.393]             `[[` <- base::`[[`
[13:20:55.393]             `+` <- base::`+`
[13:20:55.393]             `<<-` <- base::`<<-`
[13:20:55.393]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:55.393]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:55.393]                   3L)]
[13:20:55.393]             }
[13:20:55.393]             function(cond) {
[13:20:55.393]                 is_error <- inherits(cond, "error")
[13:20:55.393]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:55.393]                   NULL)
[13:20:55.393]                 if (is_error) {
[13:20:55.393]                   sessionInformation <- function() {
[13:20:55.393]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:55.393]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:55.393]                       search = base::search(), system = base::Sys.info())
[13:20:55.393]                   }
[13:20:55.393]                   ...future.conditions[[length(...future.conditions) + 
[13:20:55.393]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:55.393]                     cond$call), session = sessionInformation(), 
[13:20:55.393]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:55.393]                   signalCondition(cond)
[13:20:55.393]                 }
[13:20:55.393]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:55.393]                 "immediateCondition"))) {
[13:20:55.393]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:55.393]                   ...future.conditions[[length(...future.conditions) + 
[13:20:55.393]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:55.393]                   if (TRUE && !signal) {
[13:20:55.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.393]                     {
[13:20:55.393]                       inherits <- base::inherits
[13:20:55.393]                       invokeRestart <- base::invokeRestart
[13:20:55.393]                       is.null <- base::is.null
[13:20:55.393]                       muffled <- FALSE
[13:20:55.393]                       if (inherits(cond, "message")) {
[13:20:55.393]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:55.393]                         if (muffled) 
[13:20:55.393]                           invokeRestart("muffleMessage")
[13:20:55.393]                       }
[13:20:55.393]                       else if (inherits(cond, "warning")) {
[13:20:55.393]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:55.393]                         if (muffled) 
[13:20:55.393]                           invokeRestart("muffleWarning")
[13:20:55.393]                       }
[13:20:55.393]                       else if (inherits(cond, "condition")) {
[13:20:55.393]                         if (!is.null(pattern)) {
[13:20:55.393]                           computeRestarts <- base::computeRestarts
[13:20:55.393]                           grepl <- base::grepl
[13:20:55.393]                           restarts <- computeRestarts(cond)
[13:20:55.393]                           for (restart in restarts) {
[13:20:55.393]                             name <- restart$name
[13:20:55.393]                             if (is.null(name)) 
[13:20:55.393]                               next
[13:20:55.393]                             if (!grepl(pattern, name)) 
[13:20:55.393]                               next
[13:20:55.393]                             invokeRestart(restart)
[13:20:55.393]                             muffled <- TRUE
[13:20:55.393]                             break
[13:20:55.393]                           }
[13:20:55.393]                         }
[13:20:55.393]                       }
[13:20:55.393]                       invisible(muffled)
[13:20:55.393]                     }
[13:20:55.393]                     muffleCondition(cond, pattern = "^muffle")
[13:20:55.393]                   }
[13:20:55.393]                 }
[13:20:55.393]                 else {
[13:20:55.393]                   if (TRUE) {
[13:20:55.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.393]                     {
[13:20:55.393]                       inherits <- base::inherits
[13:20:55.393]                       invokeRestart <- base::invokeRestart
[13:20:55.393]                       is.null <- base::is.null
[13:20:55.393]                       muffled <- FALSE
[13:20:55.393]                       if (inherits(cond, "message")) {
[13:20:55.393]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:55.393]                         if (muffled) 
[13:20:55.393]                           invokeRestart("muffleMessage")
[13:20:55.393]                       }
[13:20:55.393]                       else if (inherits(cond, "warning")) {
[13:20:55.393]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:55.393]                         if (muffled) 
[13:20:55.393]                           invokeRestart("muffleWarning")
[13:20:55.393]                       }
[13:20:55.393]                       else if (inherits(cond, "condition")) {
[13:20:55.393]                         if (!is.null(pattern)) {
[13:20:55.393]                           computeRestarts <- base::computeRestarts
[13:20:55.393]                           grepl <- base::grepl
[13:20:55.393]                           restarts <- computeRestarts(cond)
[13:20:55.393]                           for (restart in restarts) {
[13:20:55.393]                             name <- restart$name
[13:20:55.393]                             if (is.null(name)) 
[13:20:55.393]                               next
[13:20:55.393]                             if (!grepl(pattern, name)) 
[13:20:55.393]                               next
[13:20:55.393]                             invokeRestart(restart)
[13:20:55.393]                             muffled <- TRUE
[13:20:55.393]                             break
[13:20:55.393]                           }
[13:20:55.393]                         }
[13:20:55.393]                       }
[13:20:55.393]                       invisible(muffled)
[13:20:55.393]                     }
[13:20:55.393]                     muffleCondition(cond, pattern = "^muffle")
[13:20:55.393]                   }
[13:20:55.393]                 }
[13:20:55.393]             }
[13:20:55.393]         }))
[13:20:55.393]     }, error = function(ex) {
[13:20:55.393]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:55.393]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:55.393]                 ...future.rng), started = ...future.startTime, 
[13:20:55.393]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:55.393]             version = "1.8"), class = "FutureResult")
[13:20:55.393]     }, finally = {
[13:20:55.393]         if (!identical(...future.workdir, getwd())) 
[13:20:55.393]             setwd(...future.workdir)
[13:20:55.393]         {
[13:20:55.393]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:55.393]                 ...future.oldOptions$nwarnings <- NULL
[13:20:55.393]             }
[13:20:55.393]             base::options(...future.oldOptions)
[13:20:55.393]             if (.Platform$OS.type == "windows") {
[13:20:55.393]                 old_names <- names(...future.oldEnvVars)
[13:20:55.393]                 envs <- base::Sys.getenv()
[13:20:55.393]                 names <- names(envs)
[13:20:55.393]                 common <- intersect(names, old_names)
[13:20:55.393]                 added <- setdiff(names, old_names)
[13:20:55.393]                 removed <- setdiff(old_names, names)
[13:20:55.393]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:55.393]                   envs[common]]
[13:20:55.393]                 NAMES <- toupper(changed)
[13:20:55.393]                 args <- list()
[13:20:55.393]                 for (kk in seq_along(NAMES)) {
[13:20:55.393]                   name <- changed[[kk]]
[13:20:55.393]                   NAME <- NAMES[[kk]]
[13:20:55.393]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.393]                     next
[13:20:55.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:55.393]                 }
[13:20:55.393]                 NAMES <- toupper(added)
[13:20:55.393]                 for (kk in seq_along(NAMES)) {
[13:20:55.393]                   name <- added[[kk]]
[13:20:55.393]                   NAME <- NAMES[[kk]]
[13:20:55.393]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.393]                     next
[13:20:55.393]                   args[[name]] <- ""
[13:20:55.393]                 }
[13:20:55.393]                 NAMES <- toupper(removed)
[13:20:55.393]                 for (kk in seq_along(NAMES)) {
[13:20:55.393]                   name <- removed[[kk]]
[13:20:55.393]                   NAME <- NAMES[[kk]]
[13:20:55.393]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.393]                     next
[13:20:55.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:55.393]                 }
[13:20:55.393]                 if (length(args) > 0) 
[13:20:55.393]                   base::do.call(base::Sys.setenv, args = args)
[13:20:55.393]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:55.393]             }
[13:20:55.393]             else {
[13:20:55.393]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:55.393]             }
[13:20:55.393]             {
[13:20:55.393]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:55.393]                   0L) {
[13:20:55.393]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:55.393]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:55.393]                   base::options(opts)
[13:20:55.393]                 }
[13:20:55.393]                 {
[13:20:55.393]                   {
[13:20:55.393]                     NULL
[13:20:55.393]                     RNGkind("Mersenne-Twister")
[13:20:55.393]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:20:55.393]                       inherits = FALSE)
[13:20:55.393]                   }
[13:20:55.393]                   options(future.plan = NULL)
[13:20:55.393]                   if (is.na(NA_character_)) 
[13:20:55.393]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:55.393]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:55.393]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:55.393]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:55.393]                     envir = parent.frame()) 
[13:20:55.393]                   {
[13:20:55.393]                     if (is.function(workers)) 
[13:20:55.393]                       workers <- workers()
[13:20:55.393]                     workers <- structure(as.integer(workers), 
[13:20:55.393]                       class = class(workers))
[13:20:55.393]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:55.393]                       workers >= 1)
[13:20:55.393]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:55.393]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:55.393]                     }
[13:20:55.393]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:55.393]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:55.393]                       envir = envir)
[13:20:55.393]                     if (!future$lazy) 
[13:20:55.393]                       future <- run(future)
[13:20:55.393]                     invisible(future)
[13:20:55.393]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:55.393]                 }
[13:20:55.393]             }
[13:20:55.393]         }
[13:20:55.393]     })
[13:20:55.393]     if (TRUE) {
[13:20:55.393]         base::sink(type = "output", split = FALSE)
[13:20:55.393]         if (TRUE) {
[13:20:55.393]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:55.393]         }
[13:20:55.393]         else {
[13:20:55.393]             ...future.result["stdout"] <- base::list(NULL)
[13:20:55.393]         }
[13:20:55.393]         base::close(...future.stdout)
[13:20:55.393]         ...future.stdout <- NULL
[13:20:55.393]     }
[13:20:55.393]     ...future.result$conditions <- ...future.conditions
[13:20:55.393]     ...future.result$finished <- base::Sys.time()
[13:20:55.393]     ...future.result
[13:20:55.393] }
[13:20:55.394] assign_globals() ...
[13:20:55.394] List of 1
[13:20:55.394]  $ pkg: chr "foo"
[13:20:55.394]  - attr(*, "where")=List of 1
[13:20:55.394]   ..$ pkg:<environment: R_EmptyEnv> 
[13:20:55.394]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:20:55.394]  - attr(*, "resolved")= logi TRUE
[13:20:55.394]  - attr(*, "total_size")= num 112
[13:20:55.397] - copied ‘pkg’ to environment
[13:20:55.397] assign_globals() ... done
[13:20:55.397] plan(): Setting new future strategy stack:
[13:20:55.397] List of future strategies:
[13:20:55.397] 1. sequential:
[13:20:55.397]    - args: function (..., envir = parent.frame())
[13:20:55.397]    - tweaked: FALSE
[13:20:55.397]    - call: NULL
[13:20:55.397] plan(): nbrOfWorkers() = 1
[13:20:55.398] plan(): Setting new future strategy stack:
[13:20:55.398] List of future strategies:
[13:20:55.398] 1. multisession:
[13:20:55.398]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:20:55.398]    - tweaked: FALSE
[13:20:55.398]    - call: plan(strategy)
[13:20:55.402] plan(): nbrOfWorkers() = 2
[13:20:55.402] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:55.403] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:55.403] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:55.405] - globals found: [3] ‘{’, ‘<-’, ‘+’
[13:20:55.405] Searching for globals ... DONE
[13:20:55.405] Resolving globals: TRUE
[13:20:55.405] Resolving any globals that are futures ...
[13:20:55.405] - globals: [3] ‘{’, ‘<-’, ‘+’
[13:20:55.405] Resolving any globals that are futures ... DONE
[13:20:55.405] 
[13:20:55.406] 
[13:20:55.406] getGlobalsAndPackages() ... DONE
[13:20:55.406] run() for ‘Future’ ...
[13:20:55.406] - state: ‘created’
[13:20:55.406] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:55.420] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:55.420] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:55.421]   - Field: ‘node’
[13:20:55.421]   - Field: ‘label’
[13:20:55.421]   - Field: ‘local’
[13:20:55.421]   - Field: ‘owner’
[13:20:55.421]   - Field: ‘envir’
[13:20:55.421]   - Field: ‘workers’
[13:20:55.421]   - Field: ‘packages’
[13:20:55.421]   - Field: ‘gc’
[13:20:55.421]   - Field: ‘conditions’
[13:20:55.421]   - Field: ‘persistent’
[13:20:55.422]   - Field: ‘expr’
[13:20:55.422]   - Field: ‘uuid’
[13:20:55.422]   - Field: ‘seed’
[13:20:55.422]   - Field: ‘version’
[13:20:55.422]   - Field: ‘result’
[13:20:55.422]   - Field: ‘asynchronous’
[13:20:55.422]   - Field: ‘calls’
[13:20:55.422]   - Field: ‘globals’
[13:20:55.422]   - Field: ‘stdout’
[13:20:55.422]   - Field: ‘earlySignal’
[13:20:55.422]   - Field: ‘lazy’
[13:20:55.423]   - Field: ‘state’
[13:20:55.423] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:55.423] - Launch lazy future ...
[13:20:55.423] Packages needed by the future expression (n = 0): <none>
[13:20:55.423] Packages needed by future strategies (n = 0): <none>
[13:20:55.424] {
[13:20:55.424]     {
[13:20:55.424]         {
[13:20:55.424]             ...future.startTime <- base::Sys.time()
[13:20:55.424]             {
[13:20:55.424]                 {
[13:20:55.424]                   {
[13:20:55.424]                     {
[13:20:55.424]                       base::local({
[13:20:55.424]                         has_future <- base::requireNamespace("future", 
[13:20:55.424]                           quietly = TRUE)
[13:20:55.424]                         if (has_future) {
[13:20:55.424]                           ns <- base::getNamespace("future")
[13:20:55.424]                           version <- ns[[".package"]][["version"]]
[13:20:55.424]                           if (is.null(version)) 
[13:20:55.424]                             version <- utils::packageVersion("future")
[13:20:55.424]                         }
[13:20:55.424]                         else {
[13:20:55.424]                           version <- NULL
[13:20:55.424]                         }
[13:20:55.424]                         if (!has_future || version < "1.8.0") {
[13:20:55.424]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:55.424]                             "", base::R.version$version.string), 
[13:20:55.424]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:55.424]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:55.424]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:55.424]                               "release", "version")], collapse = " "), 
[13:20:55.424]                             hostname = base::Sys.info()[["nodename"]])
[13:20:55.424]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:55.424]                             info)
[13:20:55.424]                           info <- base::paste(info, collapse = "; ")
[13:20:55.424]                           if (!has_future) {
[13:20:55.424]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:55.424]                               info)
[13:20:55.424]                           }
[13:20:55.424]                           else {
[13:20:55.424]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:55.424]                               info, version)
[13:20:55.424]                           }
[13:20:55.424]                           base::stop(msg)
[13:20:55.424]                         }
[13:20:55.424]                       })
[13:20:55.424]                     }
[13:20:55.424]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:55.424]                     base::options(mc.cores = 1L)
[13:20:55.424]                   }
[13:20:55.424]                   options(future.plan = NULL)
[13:20:55.424]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:55.424]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:55.424]                 }
[13:20:55.424]                 ...future.workdir <- getwd()
[13:20:55.424]             }
[13:20:55.424]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:55.424]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:55.424]         }
[13:20:55.424]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:55.424]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:55.424]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:55.424]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:55.424]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:55.424]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:55.424]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:55.424]             base::names(...future.oldOptions))
[13:20:55.424]     }
[13:20:55.424]     if (FALSE) {
[13:20:55.424]     }
[13:20:55.424]     else {
[13:20:55.424]         if (TRUE) {
[13:20:55.424]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:55.424]                 open = "w")
[13:20:55.424]         }
[13:20:55.424]         else {
[13:20:55.424]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:55.424]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:55.424]         }
[13:20:55.424]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:55.424]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:55.424]             base::sink(type = "output", split = FALSE)
[13:20:55.424]             base::close(...future.stdout)
[13:20:55.424]         }, add = TRUE)
[13:20:55.424]     }
[13:20:55.424]     ...future.frame <- base::sys.nframe()
[13:20:55.424]     ...future.conditions <- base::list()
[13:20:55.424]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:55.424]     if (FALSE) {
[13:20:55.424]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:55.424]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:55.424]     }
[13:20:55.424]     ...future.result <- base::tryCatch({
[13:20:55.424]         base::withCallingHandlers({
[13:20:55.424]             ...future.value <- base::withVisible(base::local({
[13:20:55.424]                 ...future.makeSendCondition <- local({
[13:20:55.424]                   sendCondition <- NULL
[13:20:55.424]                   function(frame = 1L) {
[13:20:55.424]                     if (is.function(sendCondition)) 
[13:20:55.424]                       return(sendCondition)
[13:20:55.424]                     ns <- getNamespace("parallel")
[13:20:55.424]                     if (exists("sendData", mode = "function", 
[13:20:55.424]                       envir = ns)) {
[13:20:55.424]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:55.424]                         envir = ns)
[13:20:55.424]                       envir <- sys.frame(frame)
[13:20:55.424]                       master <- NULL
[13:20:55.424]                       while (!identical(envir, .GlobalEnv) && 
[13:20:55.424]                         !identical(envir, emptyenv())) {
[13:20:55.424]                         if (exists("master", mode = "list", envir = envir, 
[13:20:55.424]                           inherits = FALSE)) {
[13:20:55.424]                           master <- get("master", mode = "list", 
[13:20:55.424]                             envir = envir, inherits = FALSE)
[13:20:55.424]                           if (inherits(master, c("SOCKnode", 
[13:20:55.424]                             "SOCK0node"))) {
[13:20:55.424]                             sendCondition <<- function(cond) {
[13:20:55.424]                               data <- list(type = "VALUE", value = cond, 
[13:20:55.424]                                 success = TRUE)
[13:20:55.424]                               parallel_sendData(master, data)
[13:20:55.424]                             }
[13:20:55.424]                             return(sendCondition)
[13:20:55.424]                           }
[13:20:55.424]                         }
[13:20:55.424]                         frame <- frame + 1L
[13:20:55.424]                         envir <- sys.frame(frame)
[13:20:55.424]                       }
[13:20:55.424]                     }
[13:20:55.424]                     sendCondition <<- function(cond) NULL
[13:20:55.424]                   }
[13:20:55.424]                 })
[13:20:55.424]                 withCallingHandlers({
[13:20:55.424]                   {
[13:20:55.424]                     x <- 0
[13:20:55.424]                     x <- x + 1
[13:20:55.424]                     x
[13:20:55.424]                   }
[13:20:55.424]                 }, immediateCondition = function(cond) {
[13:20:55.424]                   sendCondition <- ...future.makeSendCondition()
[13:20:55.424]                   sendCondition(cond)
[13:20:55.424]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.424]                   {
[13:20:55.424]                     inherits <- base::inherits
[13:20:55.424]                     invokeRestart <- base::invokeRestart
[13:20:55.424]                     is.null <- base::is.null
[13:20:55.424]                     muffled <- FALSE
[13:20:55.424]                     if (inherits(cond, "message")) {
[13:20:55.424]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:55.424]                       if (muffled) 
[13:20:55.424]                         invokeRestart("muffleMessage")
[13:20:55.424]                     }
[13:20:55.424]                     else if (inherits(cond, "warning")) {
[13:20:55.424]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:55.424]                       if (muffled) 
[13:20:55.424]                         invokeRestart("muffleWarning")
[13:20:55.424]                     }
[13:20:55.424]                     else if (inherits(cond, "condition")) {
[13:20:55.424]                       if (!is.null(pattern)) {
[13:20:55.424]                         computeRestarts <- base::computeRestarts
[13:20:55.424]                         grepl <- base::grepl
[13:20:55.424]                         restarts <- computeRestarts(cond)
[13:20:55.424]                         for (restart in restarts) {
[13:20:55.424]                           name <- restart$name
[13:20:55.424]                           if (is.null(name)) 
[13:20:55.424]                             next
[13:20:55.424]                           if (!grepl(pattern, name)) 
[13:20:55.424]                             next
[13:20:55.424]                           invokeRestart(restart)
[13:20:55.424]                           muffled <- TRUE
[13:20:55.424]                           break
[13:20:55.424]                         }
[13:20:55.424]                       }
[13:20:55.424]                     }
[13:20:55.424]                     invisible(muffled)
[13:20:55.424]                   }
[13:20:55.424]                   muffleCondition(cond)
[13:20:55.424]                 })
[13:20:55.424]             }))
[13:20:55.424]             future::FutureResult(value = ...future.value$value, 
[13:20:55.424]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:55.424]                   ...future.rng), globalenv = if (FALSE) 
[13:20:55.424]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:55.424]                     ...future.globalenv.names))
[13:20:55.424]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:55.424]         }, condition = base::local({
[13:20:55.424]             c <- base::c
[13:20:55.424]             inherits <- base::inherits
[13:20:55.424]             invokeRestart <- base::invokeRestart
[13:20:55.424]             length <- base::length
[13:20:55.424]             list <- base::list
[13:20:55.424]             seq.int <- base::seq.int
[13:20:55.424]             signalCondition <- base::signalCondition
[13:20:55.424]             sys.calls <- base::sys.calls
[13:20:55.424]             `[[` <- base::`[[`
[13:20:55.424]             `+` <- base::`+`
[13:20:55.424]             `<<-` <- base::`<<-`
[13:20:55.424]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:55.424]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:55.424]                   3L)]
[13:20:55.424]             }
[13:20:55.424]             function(cond) {
[13:20:55.424]                 is_error <- inherits(cond, "error")
[13:20:55.424]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:55.424]                   NULL)
[13:20:55.424]                 if (is_error) {
[13:20:55.424]                   sessionInformation <- function() {
[13:20:55.424]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:55.424]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:55.424]                       search = base::search(), system = base::Sys.info())
[13:20:55.424]                   }
[13:20:55.424]                   ...future.conditions[[length(...future.conditions) + 
[13:20:55.424]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:55.424]                     cond$call), session = sessionInformation(), 
[13:20:55.424]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:55.424]                   signalCondition(cond)
[13:20:55.424]                 }
[13:20:55.424]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:55.424]                 "immediateCondition"))) {
[13:20:55.424]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:55.424]                   ...future.conditions[[length(...future.conditions) + 
[13:20:55.424]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:55.424]                   if (TRUE && !signal) {
[13:20:55.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.424]                     {
[13:20:55.424]                       inherits <- base::inherits
[13:20:55.424]                       invokeRestart <- base::invokeRestart
[13:20:55.424]                       is.null <- base::is.null
[13:20:55.424]                       muffled <- FALSE
[13:20:55.424]                       if (inherits(cond, "message")) {
[13:20:55.424]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:55.424]                         if (muffled) 
[13:20:55.424]                           invokeRestart("muffleMessage")
[13:20:55.424]                       }
[13:20:55.424]                       else if (inherits(cond, "warning")) {
[13:20:55.424]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:55.424]                         if (muffled) 
[13:20:55.424]                           invokeRestart("muffleWarning")
[13:20:55.424]                       }
[13:20:55.424]                       else if (inherits(cond, "condition")) {
[13:20:55.424]                         if (!is.null(pattern)) {
[13:20:55.424]                           computeRestarts <- base::computeRestarts
[13:20:55.424]                           grepl <- base::grepl
[13:20:55.424]                           restarts <- computeRestarts(cond)
[13:20:55.424]                           for (restart in restarts) {
[13:20:55.424]                             name <- restart$name
[13:20:55.424]                             if (is.null(name)) 
[13:20:55.424]                               next
[13:20:55.424]                             if (!grepl(pattern, name)) 
[13:20:55.424]                               next
[13:20:55.424]                             invokeRestart(restart)
[13:20:55.424]                             muffled <- TRUE
[13:20:55.424]                             break
[13:20:55.424]                           }
[13:20:55.424]                         }
[13:20:55.424]                       }
[13:20:55.424]                       invisible(muffled)
[13:20:55.424]                     }
[13:20:55.424]                     muffleCondition(cond, pattern = "^muffle")
[13:20:55.424]                   }
[13:20:55.424]                 }
[13:20:55.424]                 else {
[13:20:55.424]                   if (TRUE) {
[13:20:55.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.424]                     {
[13:20:55.424]                       inherits <- base::inherits
[13:20:55.424]                       invokeRestart <- base::invokeRestart
[13:20:55.424]                       is.null <- base::is.null
[13:20:55.424]                       muffled <- FALSE
[13:20:55.424]                       if (inherits(cond, "message")) {
[13:20:55.424]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:55.424]                         if (muffled) 
[13:20:55.424]                           invokeRestart("muffleMessage")
[13:20:55.424]                       }
[13:20:55.424]                       else if (inherits(cond, "warning")) {
[13:20:55.424]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:55.424]                         if (muffled) 
[13:20:55.424]                           invokeRestart("muffleWarning")
[13:20:55.424]                       }
[13:20:55.424]                       else if (inherits(cond, "condition")) {
[13:20:55.424]                         if (!is.null(pattern)) {
[13:20:55.424]                           computeRestarts <- base::computeRestarts
[13:20:55.424]                           grepl <- base::grepl
[13:20:55.424]                           restarts <- computeRestarts(cond)
[13:20:55.424]                           for (restart in restarts) {
[13:20:55.424]                             name <- restart$name
[13:20:55.424]                             if (is.null(name)) 
[13:20:55.424]                               next
[13:20:55.424]                             if (!grepl(pattern, name)) 
[13:20:55.424]                               next
[13:20:55.424]                             invokeRestart(restart)
[13:20:55.424]                             muffled <- TRUE
[13:20:55.424]                             break
[13:20:55.424]                           }
[13:20:55.424]                         }
[13:20:55.424]                       }
[13:20:55.424]                       invisible(muffled)
[13:20:55.424]                     }
[13:20:55.424]                     muffleCondition(cond, pattern = "^muffle")
[13:20:55.424]                   }
[13:20:55.424]                 }
[13:20:55.424]             }
[13:20:55.424]         }))
[13:20:55.424]     }, error = function(ex) {
[13:20:55.424]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:55.424]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:55.424]                 ...future.rng), started = ...future.startTime, 
[13:20:55.424]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:55.424]             version = "1.8"), class = "FutureResult")
[13:20:55.424]     }, finally = {
[13:20:55.424]         if (!identical(...future.workdir, getwd())) 
[13:20:55.424]             setwd(...future.workdir)
[13:20:55.424]         {
[13:20:55.424]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:55.424]                 ...future.oldOptions$nwarnings <- NULL
[13:20:55.424]             }
[13:20:55.424]             base::options(...future.oldOptions)
[13:20:55.424]             if (.Platform$OS.type == "windows") {
[13:20:55.424]                 old_names <- names(...future.oldEnvVars)
[13:20:55.424]                 envs <- base::Sys.getenv()
[13:20:55.424]                 names <- names(envs)
[13:20:55.424]                 common <- intersect(names, old_names)
[13:20:55.424]                 added <- setdiff(names, old_names)
[13:20:55.424]                 removed <- setdiff(old_names, names)
[13:20:55.424]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:55.424]                   envs[common]]
[13:20:55.424]                 NAMES <- toupper(changed)
[13:20:55.424]                 args <- list()
[13:20:55.424]                 for (kk in seq_along(NAMES)) {
[13:20:55.424]                   name <- changed[[kk]]
[13:20:55.424]                   NAME <- NAMES[[kk]]
[13:20:55.424]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.424]                     next
[13:20:55.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:55.424]                 }
[13:20:55.424]                 NAMES <- toupper(added)
[13:20:55.424]                 for (kk in seq_along(NAMES)) {
[13:20:55.424]                   name <- added[[kk]]
[13:20:55.424]                   NAME <- NAMES[[kk]]
[13:20:55.424]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.424]                     next
[13:20:55.424]                   args[[name]] <- ""
[13:20:55.424]                 }
[13:20:55.424]                 NAMES <- toupper(removed)
[13:20:55.424]                 for (kk in seq_along(NAMES)) {
[13:20:55.424]                   name <- removed[[kk]]
[13:20:55.424]                   NAME <- NAMES[[kk]]
[13:20:55.424]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.424]                     next
[13:20:55.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:55.424]                 }
[13:20:55.424]                 if (length(args) > 0) 
[13:20:55.424]                   base::do.call(base::Sys.setenv, args = args)
[13:20:55.424]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:55.424]             }
[13:20:55.424]             else {
[13:20:55.424]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:55.424]             }
[13:20:55.424]             {
[13:20:55.424]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:55.424]                   0L) {
[13:20:55.424]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:55.424]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:55.424]                   base::options(opts)
[13:20:55.424]                 }
[13:20:55.424]                 {
[13:20:55.424]                   {
[13:20:55.424]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:55.424]                     NULL
[13:20:55.424]                   }
[13:20:55.424]                   options(future.plan = NULL)
[13:20:55.424]                   if (is.na(NA_character_)) 
[13:20:55.424]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:55.424]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:55.424]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:55.424]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:55.424]                     envir = parent.frame()) 
[13:20:55.424]                   {
[13:20:55.424]                     if (is.function(workers)) 
[13:20:55.424]                       workers <- workers()
[13:20:55.424]                     workers <- structure(as.integer(workers), 
[13:20:55.424]                       class = class(workers))
[13:20:55.424]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:55.424]                       workers >= 1)
[13:20:55.424]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:55.424]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:55.424]                     }
[13:20:55.424]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:55.424]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:55.424]                       envir = envir)
[13:20:55.424]                     if (!future$lazy) 
[13:20:55.424]                       future <- run(future)
[13:20:55.424]                     invisible(future)
[13:20:55.424]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:55.424]                 }
[13:20:55.424]             }
[13:20:55.424]         }
[13:20:55.424]     })
[13:20:55.424]     if (TRUE) {
[13:20:55.424]         base::sink(type = "output", split = FALSE)
[13:20:55.424]         if (TRUE) {
[13:20:55.424]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:55.424]         }
[13:20:55.424]         else {
[13:20:55.424]             ...future.result["stdout"] <- base::list(NULL)
[13:20:55.424]         }
[13:20:55.424]         base::close(...future.stdout)
[13:20:55.424]         ...future.stdout <- NULL
[13:20:55.424]     }
[13:20:55.424]     ...future.result$conditions <- ...future.conditions
[13:20:55.424]     ...future.result$finished <- base::Sys.time()
[13:20:55.424]     ...future.result
[13:20:55.424] }
[13:20:55.427] MultisessionFuture started
[13:20:55.427] - Launch lazy future ... done
[13:20:55.427] run() for ‘MultisessionFuture’ ... done
[13:20:55.427] result() for ClusterFuture ...
[13:20:55.427] receiveMessageFromWorker() for ClusterFuture ...
[13:20:55.427] - Validating connection of MultisessionFuture
[13:20:55.474] - received message: FutureResult
[13:20:55.474] - Received FutureResult
[13:20:55.474] - Erased future from FutureRegistry
[13:20:55.474] result() for ClusterFuture ...
[13:20:55.474] - result already collected: FutureResult
[13:20:55.474] result() for ClusterFuture ... done
[13:20:55.474] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:55.474] result() for ClusterFuture ... done
[13:20:55.475] result() for ClusterFuture ...
[13:20:55.475] - result already collected: FutureResult
[13:20:55.475] result() for ClusterFuture ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:55.475] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:55.475] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:55.477] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[13:20:55.477] Searching for globals ... DONE
[13:20:55.477] Resolving globals: TRUE
[13:20:55.477] Resolving any globals that are futures ...
[13:20:55.477] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[13:20:55.477] Resolving any globals that are futures ... DONE
[13:20:55.478] Resolving futures part of globals (recursively) ...
[13:20:55.478] resolve() on list ...
[13:20:55.478]  recursive: 99
[13:20:55.478]  length: 1
[13:20:55.478]  elements: ‘x’
[13:20:55.478]  length: 0 (resolved future 1)
[13:20:55.478] resolve() on list ... DONE
[13:20:55.478] - globals: [1] ‘x’
[13:20:55.479] Resolving futures part of globals (recursively) ... DONE
[13:20:55.479] The total size of the 1 globals is 56 bytes (56 bytes)
[13:20:55.479] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[13:20:55.479] - globals: [1] ‘x’
[13:20:55.479] 
[13:20:55.479] getGlobalsAndPackages() ... DONE
[13:20:55.480] run() for ‘Future’ ...
[13:20:55.480] - state: ‘created’
[13:20:55.480] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:55.494] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:55.495] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:55.495]   - Field: ‘node’
[13:20:55.495]   - Field: ‘label’
[13:20:55.495]   - Field: ‘local’
[13:20:55.495]   - Field: ‘owner’
[13:20:55.495]   - Field: ‘envir’
[13:20:55.495]   - Field: ‘workers’
[13:20:55.495]   - Field: ‘packages’
[13:20:55.495]   - Field: ‘gc’
[13:20:55.495]   - Field: ‘conditions’
[13:20:55.496]   - Field: ‘persistent’
[13:20:55.496]   - Field: ‘expr’
[13:20:55.496]   - Field: ‘uuid’
[13:20:55.496]   - Field: ‘seed’
[13:20:55.496]   - Field: ‘version’
[13:20:55.496]   - Field: ‘result’
[13:20:55.496]   - Field: ‘asynchronous’
[13:20:55.496]   - Field: ‘calls’
[13:20:55.496]   - Field: ‘globals’
[13:20:55.496]   - Field: ‘stdout’
[13:20:55.496]   - Field: ‘earlySignal’
[13:20:55.497]   - Field: ‘lazy’
[13:20:55.497]   - Field: ‘state’
[13:20:55.497] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:55.497] - Launch lazy future ...
[13:20:55.497] Packages needed by the future expression (n = 0): <none>
[13:20:55.497] Packages needed by future strategies (n = 0): <none>
[13:20:55.498] {
[13:20:55.498]     {
[13:20:55.498]         {
[13:20:55.498]             ...future.startTime <- base::Sys.time()
[13:20:55.498]             {
[13:20:55.498]                 {
[13:20:55.498]                   {
[13:20:55.498]                     {
[13:20:55.498]                       base::local({
[13:20:55.498]                         has_future <- base::requireNamespace("future", 
[13:20:55.498]                           quietly = TRUE)
[13:20:55.498]                         if (has_future) {
[13:20:55.498]                           ns <- base::getNamespace("future")
[13:20:55.498]                           version <- ns[[".package"]][["version"]]
[13:20:55.498]                           if (is.null(version)) 
[13:20:55.498]                             version <- utils::packageVersion("future")
[13:20:55.498]                         }
[13:20:55.498]                         else {
[13:20:55.498]                           version <- NULL
[13:20:55.498]                         }
[13:20:55.498]                         if (!has_future || version < "1.8.0") {
[13:20:55.498]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:55.498]                             "", base::R.version$version.string), 
[13:20:55.498]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:55.498]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:55.498]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:55.498]                               "release", "version")], collapse = " "), 
[13:20:55.498]                             hostname = base::Sys.info()[["nodename"]])
[13:20:55.498]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:55.498]                             info)
[13:20:55.498]                           info <- base::paste(info, collapse = "; ")
[13:20:55.498]                           if (!has_future) {
[13:20:55.498]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:55.498]                               info)
[13:20:55.498]                           }
[13:20:55.498]                           else {
[13:20:55.498]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:55.498]                               info, version)
[13:20:55.498]                           }
[13:20:55.498]                           base::stop(msg)
[13:20:55.498]                         }
[13:20:55.498]                       })
[13:20:55.498]                     }
[13:20:55.498]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:55.498]                     base::options(mc.cores = 1L)
[13:20:55.498]                   }
[13:20:55.498]                   options(future.plan = NULL)
[13:20:55.498]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:55.498]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:55.498]                 }
[13:20:55.498]                 ...future.workdir <- getwd()
[13:20:55.498]             }
[13:20:55.498]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:55.498]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:55.498]         }
[13:20:55.498]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:55.498]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:55.498]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:55.498]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:55.498]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:55.498]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:55.498]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:55.498]             base::names(...future.oldOptions))
[13:20:55.498]     }
[13:20:55.498]     if (FALSE) {
[13:20:55.498]     }
[13:20:55.498]     else {
[13:20:55.498]         if (TRUE) {
[13:20:55.498]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:55.498]                 open = "w")
[13:20:55.498]         }
[13:20:55.498]         else {
[13:20:55.498]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:55.498]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:55.498]         }
[13:20:55.498]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:55.498]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:55.498]             base::sink(type = "output", split = FALSE)
[13:20:55.498]             base::close(...future.stdout)
[13:20:55.498]         }, add = TRUE)
[13:20:55.498]     }
[13:20:55.498]     ...future.frame <- base::sys.nframe()
[13:20:55.498]     ...future.conditions <- base::list()
[13:20:55.498]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:55.498]     if (FALSE) {
[13:20:55.498]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:55.498]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:55.498]     }
[13:20:55.498]     ...future.result <- base::tryCatch({
[13:20:55.498]         base::withCallingHandlers({
[13:20:55.498]             ...future.value <- base::withVisible(base::local({
[13:20:55.498]                 ...future.makeSendCondition <- local({
[13:20:55.498]                   sendCondition <- NULL
[13:20:55.498]                   function(frame = 1L) {
[13:20:55.498]                     if (is.function(sendCondition)) 
[13:20:55.498]                       return(sendCondition)
[13:20:55.498]                     ns <- getNamespace("parallel")
[13:20:55.498]                     if (exists("sendData", mode = "function", 
[13:20:55.498]                       envir = ns)) {
[13:20:55.498]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:55.498]                         envir = ns)
[13:20:55.498]                       envir <- sys.frame(frame)
[13:20:55.498]                       master <- NULL
[13:20:55.498]                       while (!identical(envir, .GlobalEnv) && 
[13:20:55.498]                         !identical(envir, emptyenv())) {
[13:20:55.498]                         if (exists("master", mode = "list", envir = envir, 
[13:20:55.498]                           inherits = FALSE)) {
[13:20:55.498]                           master <- get("master", mode = "list", 
[13:20:55.498]                             envir = envir, inherits = FALSE)
[13:20:55.498]                           if (inherits(master, c("SOCKnode", 
[13:20:55.498]                             "SOCK0node"))) {
[13:20:55.498]                             sendCondition <<- function(cond) {
[13:20:55.498]                               data <- list(type = "VALUE", value = cond, 
[13:20:55.498]                                 success = TRUE)
[13:20:55.498]                               parallel_sendData(master, data)
[13:20:55.498]                             }
[13:20:55.498]                             return(sendCondition)
[13:20:55.498]                           }
[13:20:55.498]                         }
[13:20:55.498]                         frame <- frame + 1L
[13:20:55.498]                         envir <- sys.frame(frame)
[13:20:55.498]                       }
[13:20:55.498]                     }
[13:20:55.498]                     sendCondition <<- function(cond) NULL
[13:20:55.498]                   }
[13:20:55.498]                 })
[13:20:55.498]                 withCallingHandlers({
[13:20:55.498]                   {
[13:20:55.498]                     x <- x + 1
[13:20:55.498]                     x
[13:20:55.498]                   }
[13:20:55.498]                 }, immediateCondition = function(cond) {
[13:20:55.498]                   sendCondition <- ...future.makeSendCondition()
[13:20:55.498]                   sendCondition(cond)
[13:20:55.498]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.498]                   {
[13:20:55.498]                     inherits <- base::inherits
[13:20:55.498]                     invokeRestart <- base::invokeRestart
[13:20:55.498]                     is.null <- base::is.null
[13:20:55.498]                     muffled <- FALSE
[13:20:55.498]                     if (inherits(cond, "message")) {
[13:20:55.498]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:55.498]                       if (muffled) 
[13:20:55.498]                         invokeRestart("muffleMessage")
[13:20:55.498]                     }
[13:20:55.498]                     else if (inherits(cond, "warning")) {
[13:20:55.498]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:55.498]                       if (muffled) 
[13:20:55.498]                         invokeRestart("muffleWarning")
[13:20:55.498]                     }
[13:20:55.498]                     else if (inherits(cond, "condition")) {
[13:20:55.498]                       if (!is.null(pattern)) {
[13:20:55.498]                         computeRestarts <- base::computeRestarts
[13:20:55.498]                         grepl <- base::grepl
[13:20:55.498]                         restarts <- computeRestarts(cond)
[13:20:55.498]                         for (restart in restarts) {
[13:20:55.498]                           name <- restart$name
[13:20:55.498]                           if (is.null(name)) 
[13:20:55.498]                             next
[13:20:55.498]                           if (!grepl(pattern, name)) 
[13:20:55.498]                             next
[13:20:55.498]                           invokeRestart(restart)
[13:20:55.498]                           muffled <- TRUE
[13:20:55.498]                           break
[13:20:55.498]                         }
[13:20:55.498]                       }
[13:20:55.498]                     }
[13:20:55.498]                     invisible(muffled)
[13:20:55.498]                   }
[13:20:55.498]                   muffleCondition(cond)
[13:20:55.498]                 })
[13:20:55.498]             }))
[13:20:55.498]             future::FutureResult(value = ...future.value$value, 
[13:20:55.498]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:55.498]                   ...future.rng), globalenv = if (FALSE) 
[13:20:55.498]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:55.498]                     ...future.globalenv.names))
[13:20:55.498]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:55.498]         }, condition = base::local({
[13:20:55.498]             c <- base::c
[13:20:55.498]             inherits <- base::inherits
[13:20:55.498]             invokeRestart <- base::invokeRestart
[13:20:55.498]             length <- base::length
[13:20:55.498]             list <- base::list
[13:20:55.498]             seq.int <- base::seq.int
[13:20:55.498]             signalCondition <- base::signalCondition
[13:20:55.498]             sys.calls <- base::sys.calls
[13:20:55.498]             `[[` <- base::`[[`
[13:20:55.498]             `+` <- base::`+`
[13:20:55.498]             `<<-` <- base::`<<-`
[13:20:55.498]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:55.498]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:55.498]                   3L)]
[13:20:55.498]             }
[13:20:55.498]             function(cond) {
[13:20:55.498]                 is_error <- inherits(cond, "error")
[13:20:55.498]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:55.498]                   NULL)
[13:20:55.498]                 if (is_error) {
[13:20:55.498]                   sessionInformation <- function() {
[13:20:55.498]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:55.498]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:55.498]                       search = base::search(), system = base::Sys.info())
[13:20:55.498]                   }
[13:20:55.498]                   ...future.conditions[[length(...future.conditions) + 
[13:20:55.498]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:55.498]                     cond$call), session = sessionInformation(), 
[13:20:55.498]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:55.498]                   signalCondition(cond)
[13:20:55.498]                 }
[13:20:55.498]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:55.498]                 "immediateCondition"))) {
[13:20:55.498]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:55.498]                   ...future.conditions[[length(...future.conditions) + 
[13:20:55.498]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:55.498]                   if (TRUE && !signal) {
[13:20:55.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.498]                     {
[13:20:55.498]                       inherits <- base::inherits
[13:20:55.498]                       invokeRestart <- base::invokeRestart
[13:20:55.498]                       is.null <- base::is.null
[13:20:55.498]                       muffled <- FALSE
[13:20:55.498]                       if (inherits(cond, "message")) {
[13:20:55.498]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:55.498]                         if (muffled) 
[13:20:55.498]                           invokeRestart("muffleMessage")
[13:20:55.498]                       }
[13:20:55.498]                       else if (inherits(cond, "warning")) {
[13:20:55.498]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:55.498]                         if (muffled) 
[13:20:55.498]                           invokeRestart("muffleWarning")
[13:20:55.498]                       }
[13:20:55.498]                       else if (inherits(cond, "condition")) {
[13:20:55.498]                         if (!is.null(pattern)) {
[13:20:55.498]                           computeRestarts <- base::computeRestarts
[13:20:55.498]                           grepl <- base::grepl
[13:20:55.498]                           restarts <- computeRestarts(cond)
[13:20:55.498]                           for (restart in restarts) {
[13:20:55.498]                             name <- restart$name
[13:20:55.498]                             if (is.null(name)) 
[13:20:55.498]                               next
[13:20:55.498]                             if (!grepl(pattern, name)) 
[13:20:55.498]                               next
[13:20:55.498]                             invokeRestart(restart)
[13:20:55.498]                             muffled <- TRUE
[13:20:55.498]                             break
[13:20:55.498]                           }
[13:20:55.498]                         }
[13:20:55.498]                       }
[13:20:55.498]                       invisible(muffled)
[13:20:55.498]                     }
[13:20:55.498]                     muffleCondition(cond, pattern = "^muffle")
[13:20:55.498]                   }
[13:20:55.498]                 }
[13:20:55.498]                 else {
[13:20:55.498]                   if (TRUE) {
[13:20:55.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.498]                     {
[13:20:55.498]                       inherits <- base::inherits
[13:20:55.498]                       invokeRestart <- base::invokeRestart
[13:20:55.498]                       is.null <- base::is.null
[13:20:55.498]                       muffled <- FALSE
[13:20:55.498]                       if (inherits(cond, "message")) {
[13:20:55.498]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:55.498]                         if (muffled) 
[13:20:55.498]                           invokeRestart("muffleMessage")
[13:20:55.498]                       }
[13:20:55.498]                       else if (inherits(cond, "warning")) {
[13:20:55.498]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:55.498]                         if (muffled) 
[13:20:55.498]                           invokeRestart("muffleWarning")
[13:20:55.498]                       }
[13:20:55.498]                       else if (inherits(cond, "condition")) {
[13:20:55.498]                         if (!is.null(pattern)) {
[13:20:55.498]                           computeRestarts <- base::computeRestarts
[13:20:55.498]                           grepl <- base::grepl
[13:20:55.498]                           restarts <- computeRestarts(cond)
[13:20:55.498]                           for (restart in restarts) {
[13:20:55.498]                             name <- restart$name
[13:20:55.498]                             if (is.null(name)) 
[13:20:55.498]                               next
[13:20:55.498]                             if (!grepl(pattern, name)) 
[13:20:55.498]                               next
[13:20:55.498]                             invokeRestart(restart)
[13:20:55.498]                             muffled <- TRUE
[13:20:55.498]                             break
[13:20:55.498]                           }
[13:20:55.498]                         }
[13:20:55.498]                       }
[13:20:55.498]                       invisible(muffled)
[13:20:55.498]                     }
[13:20:55.498]                     muffleCondition(cond, pattern = "^muffle")
[13:20:55.498]                   }
[13:20:55.498]                 }
[13:20:55.498]             }
[13:20:55.498]         }))
[13:20:55.498]     }, error = function(ex) {
[13:20:55.498]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:55.498]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:55.498]                 ...future.rng), started = ...future.startTime, 
[13:20:55.498]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:55.498]             version = "1.8"), class = "FutureResult")
[13:20:55.498]     }, finally = {
[13:20:55.498]         if (!identical(...future.workdir, getwd())) 
[13:20:55.498]             setwd(...future.workdir)
[13:20:55.498]         {
[13:20:55.498]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:55.498]                 ...future.oldOptions$nwarnings <- NULL
[13:20:55.498]             }
[13:20:55.498]             base::options(...future.oldOptions)
[13:20:55.498]             if (.Platform$OS.type == "windows") {
[13:20:55.498]                 old_names <- names(...future.oldEnvVars)
[13:20:55.498]                 envs <- base::Sys.getenv()
[13:20:55.498]                 names <- names(envs)
[13:20:55.498]                 common <- intersect(names, old_names)
[13:20:55.498]                 added <- setdiff(names, old_names)
[13:20:55.498]                 removed <- setdiff(old_names, names)
[13:20:55.498]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:55.498]                   envs[common]]
[13:20:55.498]                 NAMES <- toupper(changed)
[13:20:55.498]                 args <- list()
[13:20:55.498]                 for (kk in seq_along(NAMES)) {
[13:20:55.498]                   name <- changed[[kk]]
[13:20:55.498]                   NAME <- NAMES[[kk]]
[13:20:55.498]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.498]                     next
[13:20:55.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:55.498]                 }
[13:20:55.498]                 NAMES <- toupper(added)
[13:20:55.498]                 for (kk in seq_along(NAMES)) {
[13:20:55.498]                   name <- added[[kk]]
[13:20:55.498]                   NAME <- NAMES[[kk]]
[13:20:55.498]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.498]                     next
[13:20:55.498]                   args[[name]] <- ""
[13:20:55.498]                 }
[13:20:55.498]                 NAMES <- toupper(removed)
[13:20:55.498]                 for (kk in seq_along(NAMES)) {
[13:20:55.498]                   name <- removed[[kk]]
[13:20:55.498]                   NAME <- NAMES[[kk]]
[13:20:55.498]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.498]                     next
[13:20:55.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:55.498]                 }
[13:20:55.498]                 if (length(args) > 0) 
[13:20:55.498]                   base::do.call(base::Sys.setenv, args = args)
[13:20:55.498]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:55.498]             }
[13:20:55.498]             else {
[13:20:55.498]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:55.498]             }
[13:20:55.498]             {
[13:20:55.498]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:55.498]                   0L) {
[13:20:55.498]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:55.498]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:55.498]                   base::options(opts)
[13:20:55.498]                 }
[13:20:55.498]                 {
[13:20:55.498]                   {
[13:20:55.498]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:55.498]                     NULL
[13:20:55.498]                   }
[13:20:55.498]                   options(future.plan = NULL)
[13:20:55.498]                   if (is.na(NA_character_)) 
[13:20:55.498]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:55.498]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:55.498]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:55.498]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:55.498]                     envir = parent.frame()) 
[13:20:55.498]                   {
[13:20:55.498]                     if (is.function(workers)) 
[13:20:55.498]                       workers <- workers()
[13:20:55.498]                     workers <- structure(as.integer(workers), 
[13:20:55.498]                       class = class(workers))
[13:20:55.498]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:55.498]                       workers >= 1)
[13:20:55.498]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:55.498]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:55.498]                     }
[13:20:55.498]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:55.498]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:55.498]                       envir = envir)
[13:20:55.498]                     if (!future$lazy) 
[13:20:55.498]                       future <- run(future)
[13:20:55.498]                     invisible(future)
[13:20:55.498]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:55.498]                 }
[13:20:55.498]             }
[13:20:55.498]         }
[13:20:55.498]     })
[13:20:55.498]     if (TRUE) {
[13:20:55.498]         base::sink(type = "output", split = FALSE)
[13:20:55.498]         if (TRUE) {
[13:20:55.498]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:55.498]         }
[13:20:55.498]         else {
[13:20:55.498]             ...future.result["stdout"] <- base::list(NULL)
[13:20:55.498]         }
[13:20:55.498]         base::close(...future.stdout)
[13:20:55.498]         ...future.stdout <- NULL
[13:20:55.498]     }
[13:20:55.498]     ...future.result$conditions <- ...future.conditions
[13:20:55.498]     ...future.result$finished <- base::Sys.time()
[13:20:55.498]     ...future.result
[13:20:55.498] }
[13:20:55.500] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:20:55.501] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[13:20:55.501] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[13:20:55.501] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:20:55.502] MultisessionFuture started
[13:20:55.502] - Launch lazy future ... done
[13:20:55.502] run() for ‘MultisessionFuture’ ... done
[13:20:55.502] result() for ClusterFuture ...
[13:20:55.502] receiveMessageFromWorker() for ClusterFuture ...
[13:20:55.502] - Validating connection of MultisessionFuture
[13:20:55.550] - received message: FutureResult
[13:20:55.550] - Received FutureResult
[13:20:55.550] - Erased future from FutureRegistry
[13:20:55.550] result() for ClusterFuture ...
[13:20:55.550] - result already collected: FutureResult
[13:20:55.550] result() for ClusterFuture ... done
[13:20:55.550] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:55.550] result() for ClusterFuture ... done
[13:20:55.551] result() for ClusterFuture ...
[13:20:55.551] - result already collected: FutureResult
[13:20:55.551] result() for ClusterFuture ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[13:20:55.551] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[13:20:55.551] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[13:20:55.553] - globals found: [3] ‘{’, ‘<-’, ‘x’
[13:20:55.553] Searching for globals ... DONE
[13:20:55.553] Resolving globals: TRUE
[13:20:55.553] Resolving any globals that are futures ...
[13:20:55.553] - globals: [3] ‘{’, ‘<-’, ‘x’
[13:20:55.554] Resolving any globals that are futures ... DONE
[13:20:55.554] Resolving futures part of globals (recursively) ...
[13:20:55.554] resolve() on list ...
[13:20:55.554]  recursive: 99
[13:20:55.554]  length: 1
[13:20:55.554]  elements: ‘x’
[13:20:55.555]  length: 0 (resolved future 1)
[13:20:55.555] resolve() on list ... DONE
[13:20:55.555] - globals: [1] ‘x’
[13:20:55.555] Resolving futures part of globals (recursively) ... DONE
[13:20:55.555] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[13:20:55.555] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[13:20:55.555] - globals: [1] ‘x’
[13:20:55.556] 
[13:20:55.556] getGlobalsAndPackages() ... DONE
[13:20:55.556] run() for ‘Future’ ...
[13:20:55.556] - state: ‘created’
[13:20:55.556] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:20:55.570] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:20:55.570] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:20:55.571]   - Field: ‘node’
[13:20:55.571]   - Field: ‘label’
[13:20:55.571]   - Field: ‘local’
[13:20:55.571]   - Field: ‘owner’
[13:20:55.571]   - Field: ‘envir’
[13:20:55.571]   - Field: ‘workers’
[13:20:55.571]   - Field: ‘packages’
[13:20:55.571]   - Field: ‘gc’
[13:20:55.571]   - Field: ‘conditions’
[13:20:55.571]   - Field: ‘persistent’
[13:20:55.572]   - Field: ‘expr’
[13:20:55.572]   - Field: ‘uuid’
[13:20:55.572]   - Field: ‘seed’
[13:20:55.572]   - Field: ‘version’
[13:20:55.572]   - Field: ‘result’
[13:20:55.572]   - Field: ‘asynchronous’
[13:20:55.572]   - Field: ‘calls’
[13:20:55.572]   - Field: ‘globals’
[13:20:55.572]   - Field: ‘stdout’
[13:20:55.572]   - Field: ‘earlySignal’
[13:20:55.573]   - Field: ‘lazy’
[13:20:55.573]   - Field: ‘state’
[13:20:55.573] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:20:55.573] - Launch lazy future ...
[13:20:55.573] Packages needed by the future expression (n = 0): <none>
[13:20:55.573] Packages needed by future strategies (n = 0): <none>
[13:20:55.574] {
[13:20:55.574]     {
[13:20:55.574]         {
[13:20:55.574]             ...future.startTime <- base::Sys.time()
[13:20:55.574]             {
[13:20:55.574]                 {
[13:20:55.574]                   {
[13:20:55.574]                     {
[13:20:55.574]                       base::local({
[13:20:55.574]                         has_future <- base::requireNamespace("future", 
[13:20:55.574]                           quietly = TRUE)
[13:20:55.574]                         if (has_future) {
[13:20:55.574]                           ns <- base::getNamespace("future")
[13:20:55.574]                           version <- ns[[".package"]][["version"]]
[13:20:55.574]                           if (is.null(version)) 
[13:20:55.574]                             version <- utils::packageVersion("future")
[13:20:55.574]                         }
[13:20:55.574]                         else {
[13:20:55.574]                           version <- NULL
[13:20:55.574]                         }
[13:20:55.574]                         if (!has_future || version < "1.8.0") {
[13:20:55.574]                           info <- base::c(r_version = base::gsub("R version ", 
[13:20:55.574]                             "", base::R.version$version.string), 
[13:20:55.574]                             platform = base::sprintf("%s (%s-bit)", 
[13:20:55.574]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:20:55.574]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:20:55.574]                               "release", "version")], collapse = " "), 
[13:20:55.574]                             hostname = base::Sys.info()[["nodename"]])
[13:20:55.574]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:20:55.574]                             info)
[13:20:55.574]                           info <- base::paste(info, collapse = "; ")
[13:20:55.574]                           if (!has_future) {
[13:20:55.574]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:20:55.574]                               info)
[13:20:55.574]                           }
[13:20:55.574]                           else {
[13:20:55.574]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:20:55.574]                               info, version)
[13:20:55.574]                           }
[13:20:55.574]                           base::stop(msg)
[13:20:55.574]                         }
[13:20:55.574]                       })
[13:20:55.574]                     }
[13:20:55.574]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:20:55.574]                     base::options(mc.cores = 1L)
[13:20:55.574]                   }
[13:20:55.574]                   options(future.plan = NULL)
[13:20:55.574]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:20:55.574]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:20:55.574]                 }
[13:20:55.574]                 ...future.workdir <- getwd()
[13:20:55.574]             }
[13:20:55.574]             ...future.oldOptions <- base::as.list(base::.Options)
[13:20:55.574]             ...future.oldEnvVars <- base::Sys.getenv()
[13:20:55.574]         }
[13:20:55.574]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[13:20:55.574]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[13:20:55.574]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[13:20:55.574]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[13:20:55.574]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:20:55.574]             future.stdout.windows.reencode = NULL, width = 80L)
[13:20:55.574]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:20:55.574]             base::names(...future.oldOptions))
[13:20:55.574]     }
[13:20:55.574]     if (FALSE) {
[13:20:55.574]     }
[13:20:55.574]     else {
[13:20:55.574]         if (TRUE) {
[13:20:55.574]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:20:55.574]                 open = "w")
[13:20:55.574]         }
[13:20:55.574]         else {
[13:20:55.574]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:20:55.574]                 windows = "NUL", "/dev/null"), open = "w")
[13:20:55.574]         }
[13:20:55.574]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:20:55.574]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:20:55.574]             base::sink(type = "output", split = FALSE)
[13:20:55.574]             base::close(...future.stdout)
[13:20:55.574]         }, add = TRUE)
[13:20:55.574]     }
[13:20:55.574]     ...future.frame <- base::sys.nframe()
[13:20:55.574]     ...future.conditions <- base::list()
[13:20:55.574]     ...future.rng <- base::globalenv()$.Random.seed
[13:20:55.574]     if (FALSE) {
[13:20:55.574]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:20:55.574]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:20:55.574]     }
[13:20:55.574]     ...future.result <- base::tryCatch({
[13:20:55.574]         base::withCallingHandlers({
[13:20:55.574]             ...future.value <- base::withVisible(base::local({
[13:20:55.574]                 ...future.makeSendCondition <- local({
[13:20:55.574]                   sendCondition <- NULL
[13:20:55.574]                   function(frame = 1L) {
[13:20:55.574]                     if (is.function(sendCondition)) 
[13:20:55.574]                       return(sendCondition)
[13:20:55.574]                     ns <- getNamespace("parallel")
[13:20:55.574]                     if (exists("sendData", mode = "function", 
[13:20:55.574]                       envir = ns)) {
[13:20:55.574]                       parallel_sendData <- get("sendData", mode = "function", 
[13:20:55.574]                         envir = ns)
[13:20:55.574]                       envir <- sys.frame(frame)
[13:20:55.574]                       master <- NULL
[13:20:55.574]                       while (!identical(envir, .GlobalEnv) && 
[13:20:55.574]                         !identical(envir, emptyenv())) {
[13:20:55.574]                         if (exists("master", mode = "list", envir = envir, 
[13:20:55.574]                           inherits = FALSE)) {
[13:20:55.574]                           master <- get("master", mode = "list", 
[13:20:55.574]                             envir = envir, inherits = FALSE)
[13:20:55.574]                           if (inherits(master, c("SOCKnode", 
[13:20:55.574]                             "SOCK0node"))) {
[13:20:55.574]                             sendCondition <<- function(cond) {
[13:20:55.574]                               data <- list(type = "VALUE", value = cond, 
[13:20:55.574]                                 success = TRUE)
[13:20:55.574]                               parallel_sendData(master, data)
[13:20:55.574]                             }
[13:20:55.574]                             return(sendCondition)
[13:20:55.574]                           }
[13:20:55.574]                         }
[13:20:55.574]                         frame <- frame + 1L
[13:20:55.574]                         envir <- sys.frame(frame)
[13:20:55.574]                       }
[13:20:55.574]                     }
[13:20:55.574]                     sendCondition <<- function(cond) NULL
[13:20:55.574]                   }
[13:20:55.574]                 })
[13:20:55.574]                 withCallingHandlers({
[13:20:55.574]                   {
[13:20:55.574]                     x <- x()
[13:20:55.574]                     x
[13:20:55.574]                   }
[13:20:55.574]                 }, immediateCondition = function(cond) {
[13:20:55.574]                   sendCondition <- ...future.makeSendCondition()
[13:20:55.574]                   sendCondition(cond)
[13:20:55.574]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.574]                   {
[13:20:55.574]                     inherits <- base::inherits
[13:20:55.574]                     invokeRestart <- base::invokeRestart
[13:20:55.574]                     is.null <- base::is.null
[13:20:55.574]                     muffled <- FALSE
[13:20:55.574]                     if (inherits(cond, "message")) {
[13:20:55.574]                       muffled <- grepl(pattern, "muffleMessage")
[13:20:55.574]                       if (muffled) 
[13:20:55.574]                         invokeRestart("muffleMessage")
[13:20:55.574]                     }
[13:20:55.574]                     else if (inherits(cond, "warning")) {
[13:20:55.574]                       muffled <- grepl(pattern, "muffleWarning")
[13:20:55.574]                       if (muffled) 
[13:20:55.574]                         invokeRestart("muffleWarning")
[13:20:55.574]                     }
[13:20:55.574]                     else if (inherits(cond, "condition")) {
[13:20:55.574]                       if (!is.null(pattern)) {
[13:20:55.574]                         computeRestarts <- base::computeRestarts
[13:20:55.574]                         grepl <- base::grepl
[13:20:55.574]                         restarts <- computeRestarts(cond)
[13:20:55.574]                         for (restart in restarts) {
[13:20:55.574]                           name <- restart$name
[13:20:55.574]                           if (is.null(name)) 
[13:20:55.574]                             next
[13:20:55.574]                           if (!grepl(pattern, name)) 
[13:20:55.574]                             next
[13:20:55.574]                           invokeRestart(restart)
[13:20:55.574]                           muffled <- TRUE
[13:20:55.574]                           break
[13:20:55.574]                         }
[13:20:55.574]                       }
[13:20:55.574]                     }
[13:20:55.574]                     invisible(muffled)
[13:20:55.574]                   }
[13:20:55.574]                   muffleCondition(cond)
[13:20:55.574]                 })
[13:20:55.574]             }))
[13:20:55.574]             future::FutureResult(value = ...future.value$value, 
[13:20:55.574]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:55.574]                   ...future.rng), globalenv = if (FALSE) 
[13:20:55.574]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:20:55.574]                     ...future.globalenv.names))
[13:20:55.574]                 else NULL, started = ...future.startTime, version = "1.8")
[13:20:55.574]         }, condition = base::local({
[13:20:55.574]             c <- base::c
[13:20:55.574]             inherits <- base::inherits
[13:20:55.574]             invokeRestart <- base::invokeRestart
[13:20:55.574]             length <- base::length
[13:20:55.574]             list <- base::list
[13:20:55.574]             seq.int <- base::seq.int
[13:20:55.574]             signalCondition <- base::signalCondition
[13:20:55.574]             sys.calls <- base::sys.calls
[13:20:55.574]             `[[` <- base::`[[`
[13:20:55.574]             `+` <- base::`+`
[13:20:55.574]             `<<-` <- base::`<<-`
[13:20:55.574]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:20:55.574]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:20:55.574]                   3L)]
[13:20:55.574]             }
[13:20:55.574]             function(cond) {
[13:20:55.574]                 is_error <- inherits(cond, "error")
[13:20:55.574]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:20:55.574]                   NULL)
[13:20:55.574]                 if (is_error) {
[13:20:55.574]                   sessionInformation <- function() {
[13:20:55.574]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:20:55.574]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:20:55.574]                       search = base::search(), system = base::Sys.info())
[13:20:55.574]                   }
[13:20:55.574]                   ...future.conditions[[length(...future.conditions) + 
[13:20:55.574]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:20:55.574]                     cond$call), session = sessionInformation(), 
[13:20:55.574]                     timestamp = base::Sys.time(), signaled = 0L)
[13:20:55.574]                   signalCondition(cond)
[13:20:55.574]                 }
[13:20:55.574]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:20:55.574]                 "immediateCondition"))) {
[13:20:55.574]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:20:55.574]                   ...future.conditions[[length(...future.conditions) + 
[13:20:55.574]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:20:55.574]                   if (TRUE && !signal) {
[13:20:55.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.574]                     {
[13:20:55.574]                       inherits <- base::inherits
[13:20:55.574]                       invokeRestart <- base::invokeRestart
[13:20:55.574]                       is.null <- base::is.null
[13:20:55.574]                       muffled <- FALSE
[13:20:55.574]                       if (inherits(cond, "message")) {
[13:20:55.574]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:55.574]                         if (muffled) 
[13:20:55.574]                           invokeRestart("muffleMessage")
[13:20:55.574]                       }
[13:20:55.574]                       else if (inherits(cond, "warning")) {
[13:20:55.574]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:55.574]                         if (muffled) 
[13:20:55.574]                           invokeRestart("muffleWarning")
[13:20:55.574]                       }
[13:20:55.574]                       else if (inherits(cond, "condition")) {
[13:20:55.574]                         if (!is.null(pattern)) {
[13:20:55.574]                           computeRestarts <- base::computeRestarts
[13:20:55.574]                           grepl <- base::grepl
[13:20:55.574]                           restarts <- computeRestarts(cond)
[13:20:55.574]                           for (restart in restarts) {
[13:20:55.574]                             name <- restart$name
[13:20:55.574]                             if (is.null(name)) 
[13:20:55.574]                               next
[13:20:55.574]                             if (!grepl(pattern, name)) 
[13:20:55.574]                               next
[13:20:55.574]                             invokeRestart(restart)
[13:20:55.574]                             muffled <- TRUE
[13:20:55.574]                             break
[13:20:55.574]                           }
[13:20:55.574]                         }
[13:20:55.574]                       }
[13:20:55.574]                       invisible(muffled)
[13:20:55.574]                     }
[13:20:55.574]                     muffleCondition(cond, pattern = "^muffle")
[13:20:55.574]                   }
[13:20:55.574]                 }
[13:20:55.574]                 else {
[13:20:55.574]                   if (TRUE) {
[13:20:55.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:20:55.574]                     {
[13:20:55.574]                       inherits <- base::inherits
[13:20:55.574]                       invokeRestart <- base::invokeRestart
[13:20:55.574]                       is.null <- base::is.null
[13:20:55.574]                       muffled <- FALSE
[13:20:55.574]                       if (inherits(cond, "message")) {
[13:20:55.574]                         muffled <- grepl(pattern, "muffleMessage")
[13:20:55.574]                         if (muffled) 
[13:20:55.574]                           invokeRestart("muffleMessage")
[13:20:55.574]                       }
[13:20:55.574]                       else if (inherits(cond, "warning")) {
[13:20:55.574]                         muffled <- grepl(pattern, "muffleWarning")
[13:20:55.574]                         if (muffled) 
[13:20:55.574]                           invokeRestart("muffleWarning")
[13:20:55.574]                       }
[13:20:55.574]                       else if (inherits(cond, "condition")) {
[13:20:55.574]                         if (!is.null(pattern)) {
[13:20:55.574]                           computeRestarts <- base::computeRestarts
[13:20:55.574]                           grepl <- base::grepl
[13:20:55.574]                           restarts <- computeRestarts(cond)
[13:20:55.574]                           for (restart in restarts) {
[13:20:55.574]                             name <- restart$name
[13:20:55.574]                             if (is.null(name)) 
[13:20:55.574]                               next
[13:20:55.574]                             if (!grepl(pattern, name)) 
[13:20:55.574]                               next
[13:20:55.574]                             invokeRestart(restart)
[13:20:55.574]                             muffled <- TRUE
[13:20:55.574]                             break
[13:20:55.574]                           }
[13:20:55.574]                         }
[13:20:55.574]                       }
[13:20:55.574]                       invisible(muffled)
[13:20:55.574]                     }
[13:20:55.574]                     muffleCondition(cond, pattern = "^muffle")
[13:20:55.574]                   }
[13:20:55.574]                 }
[13:20:55.574]             }
[13:20:55.574]         }))
[13:20:55.574]     }, error = function(ex) {
[13:20:55.574]         base::structure(base::list(value = NULL, visible = NULL, 
[13:20:55.574]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:20:55.574]                 ...future.rng), started = ...future.startTime, 
[13:20:55.574]             finished = Sys.time(), session_uuid = NA_character_, 
[13:20:55.574]             version = "1.8"), class = "FutureResult")
[13:20:55.574]     }, finally = {
[13:20:55.574]         if (!identical(...future.workdir, getwd())) 
[13:20:55.574]             setwd(...future.workdir)
[13:20:55.574]         {
[13:20:55.574]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:20:55.574]                 ...future.oldOptions$nwarnings <- NULL
[13:20:55.574]             }
[13:20:55.574]             base::options(...future.oldOptions)
[13:20:55.574]             if (.Platform$OS.type == "windows") {
[13:20:55.574]                 old_names <- names(...future.oldEnvVars)
[13:20:55.574]                 envs <- base::Sys.getenv()
[13:20:55.574]                 names <- names(envs)
[13:20:55.574]                 common <- intersect(names, old_names)
[13:20:55.574]                 added <- setdiff(names, old_names)
[13:20:55.574]                 removed <- setdiff(old_names, names)
[13:20:55.574]                 changed <- common[...future.oldEnvVars[common] != 
[13:20:55.574]                   envs[common]]
[13:20:55.574]                 NAMES <- toupper(changed)
[13:20:55.574]                 args <- list()
[13:20:55.574]                 for (kk in seq_along(NAMES)) {
[13:20:55.574]                   name <- changed[[kk]]
[13:20:55.574]                   NAME <- NAMES[[kk]]
[13:20:55.574]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.574]                     next
[13:20:55.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:55.574]                 }
[13:20:55.574]                 NAMES <- toupper(added)
[13:20:55.574]                 for (kk in seq_along(NAMES)) {
[13:20:55.574]                   name <- added[[kk]]
[13:20:55.574]                   NAME <- NAMES[[kk]]
[13:20:55.574]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.574]                     next
[13:20:55.574]                   args[[name]] <- ""
[13:20:55.574]                 }
[13:20:55.574]                 NAMES <- toupper(removed)
[13:20:55.574]                 for (kk in seq_along(NAMES)) {
[13:20:55.574]                   name <- removed[[kk]]
[13:20:55.574]                   NAME <- NAMES[[kk]]
[13:20:55.574]                   if (name != NAME && is.element(NAME, old_names)) 
[13:20:55.574]                     next
[13:20:55.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:20:55.574]                 }
[13:20:55.574]                 if (length(args) > 0) 
[13:20:55.574]                   base::do.call(base::Sys.setenv, args = args)
[13:20:55.574]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:20:55.574]             }
[13:20:55.574]             else {
[13:20:55.574]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:20:55.574]             }
[13:20:55.574]             {
[13:20:55.574]                 if (base::length(...future.futureOptionsAdded) > 
[13:20:55.574]                   0L) {
[13:20:55.574]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:20:55.574]                   base::names(opts) <- ...future.futureOptionsAdded
[13:20:55.574]                   base::options(opts)
[13:20:55.574]                 }
[13:20:55.574]                 {
[13:20:55.574]                   {
[13:20:55.574]                     base::options(mc.cores = ...future.mc.cores.old)
[13:20:55.574]                     NULL
[13:20:55.574]                   }
[13:20:55.574]                   options(future.plan = NULL)
[13:20:55.574]                   if (is.na(NA_character_)) 
[13:20:55.574]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:20:55.574]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:20:55.574]                   future::plan(list(function (..., workers = availableCores(), 
[13:20:55.574]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:20:55.574]                     envir = parent.frame()) 
[13:20:55.574]                   {
[13:20:55.574]                     if (is.function(workers)) 
[13:20:55.574]                       workers <- workers()
[13:20:55.574]                     workers <- structure(as.integer(workers), 
[13:20:55.574]                       class = class(workers))
[13:20:55.574]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:20:55.574]                       workers >= 1)
[13:20:55.574]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:20:55.574]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:20:55.574]                     }
[13:20:55.574]                     future <- MultisessionFuture(..., workers = workers, 
[13:20:55.574]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:20:55.574]                       envir = envir)
[13:20:55.574]                     if (!future$lazy) 
[13:20:55.574]                       future <- run(future)
[13:20:55.574]                     invisible(future)
[13:20:55.574]                   }), .cleanup = FALSE, .init = FALSE)
[13:20:55.574]                 }
[13:20:55.574]             }
[13:20:55.574]         }
[13:20:55.574]     })
[13:20:55.574]     if (TRUE) {
[13:20:55.574]         base::sink(type = "output", split = FALSE)
[13:20:55.574]         if (TRUE) {
[13:20:55.574]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:20:55.574]         }
[13:20:55.574]         else {
[13:20:55.574]             ...future.result["stdout"] <- base::list(NULL)
[13:20:55.574]         }
[13:20:55.574]         base::close(...future.stdout)
[13:20:55.574]         ...future.stdout <- NULL
[13:20:55.574]     }
[13:20:55.574]     ...future.result$conditions <- ...future.conditions
[13:20:55.574]     ...future.result$finished <- base::Sys.time()
[13:20:55.574]     ...future.result
[13:20:55.574] }
[13:20:55.576] Exporting 1 global objects (1.01 KiB) to cluster node #1 ...
[13:20:55.576] Exporting ‘x’ (1.01 KiB) to cluster node #1 ...
[13:20:55.577] Exporting ‘x’ (1.01 KiB) to cluster node #1 ... DONE
[13:20:55.577] Exporting 1 global objects (1.01 KiB) to cluster node #1 ... DONE
[13:20:55.577] MultisessionFuture started
[13:20:55.578] - Launch lazy future ... done
[13:20:55.578] run() for ‘MultisessionFuture’ ... done
[13:20:55.578] result() for ClusterFuture ...
[13:20:55.578] receiveMessageFromWorker() for ClusterFuture ...
[13:20:55.578] - Validating connection of MultisessionFuture
[13:20:55.626] - received message: FutureResult
[13:20:55.626] - Received FutureResult
[13:20:55.626] - Erased future from FutureRegistry
[13:20:55.627] result() for ClusterFuture ...
[13:20:55.627] - result already collected: FutureResult
[13:20:55.627] result() for ClusterFuture ... done
[13:20:55.627] receiveMessageFromWorker() for ClusterFuture ... done
[13:20:55.627] result() for ClusterFuture ... done
[13:20:55.627] result() for ClusterFuture ...
[13:20:55.627] - result already collected: FutureResult
[13:20:55.627] result() for ClusterFuture ... done
value(f) = ‘TRUE’
Testing with 2 cores ... DONE
> 
> message("*** Tricky use cases related to globals ... DONE")
*** Tricky use cases related to globals ... DONE
> 
> source("incl/end.R")
[13:20:55.628] plan(): Setting new future strategy stack:
[13:20:55.628] List of future strategies:
[13:20:55.628] 1. FutureStrategy:
[13:20:55.628]    - args: function (..., envir = parent.frame())
[13:20:55.628]    - tweaked: FALSE
[13:20:55.628]    - call: future::plan(oplan)
[13:20:55.629] plan(): nbrOfWorkers() = 1
> 
